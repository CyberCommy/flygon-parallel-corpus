- en: Chapter 4. A Blank Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"It''s so fine and yet so terrible to stand in front of a blank canvas."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*—Paul Cezanne*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter we are heading out in a whole new direction. We will learn
    how to use the new HTML5 canvas element and API by creating a simple drawing application.
    Our application will use the canvas basics such as strokes, paths, lines, and
    shapes. We will create a toolbar using custom data attributes, which we learned
    in the previous chapter, to bind menu items to actions in our code.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The canvas element and its drawing API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get a canvas context and what are its global properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to draw lines, rectangles, and other shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get the position of the mouse inside a canvas element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a toolbar that contains drop-down menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use custom data attributes to bind toolbar actions to JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably one of the most exciting new features of HTML5 is the canvas. You can
    use it to create drawings anywhere on a web page. The only way to do this previously
    was by using some other technology such as Flash, SVG, or some other browser plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 canvas is both an element and an API. The `<canvas>` element defines
    a rectangular area of a web page where graphics can be drawn. The canvas API works
    with a `<canvas>` element to provide the JavaScript interface to draw on the canvas.
    It is a low-level set of functions for drawing lines, rectangle, circles, and
    other graphic primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<canvas>` element itself is very simple. You must set the `width` and
    `height` attributes to specify its size. You can optionally put content inside
    the `<canvas>` element to be displayed for browsers that don''t support it. The
    good news is that the HTML5 `<canvas>` element is widely supported by nearly every
    modern browser. The following code creates a canvas element 600 pixels wide and
    400 pixels high:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you set the width and height of a `<canvas>` element in CSS to something
    other than the size specified on the element, it will stretch or shrink the drawing
    in the canvas to fit, which may compromise on the image quality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The canvas API is accessed via a canvas context object. You get the context
    by calling the `getContext()` method of the `<canvas>` element, passing in a string
    parameter that defines the type of the context you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The only valid context type parameter you can pass into `getContext()` at this
    time is `"2d"`. This begs the question, "Is there a 3D context?" The answer is
    *no*, there is not. But we can always hope for one in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will learn some of the basics of using the canvas API. Now
    that we have a context, we can call its methods to draw lines and shapes. The
    API has a whole host of methods that let you draw everything from the most basic
    lines, to shapes, and even bitmap images.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this section in `chapter4/canvas-examples/canvas-examples.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The background of the canvas is transparent. Whatever background color you specify
    for the canvas element in your CSS will show through. You can clear the canvas,
    or a portion of it, using the context's `clearRect()` method. It takes *x*, *y*,
    width, and height parameters and clears that part of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Context properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when you draw on the canvas, lines are one pixel wide and the color
    is black. You can change these by setting global properties on the `context` object.
  prefs: []
  type: TYPE_NORMAL
- en: '`penWidth`: This property sets the width that lines will be drawn with. It
    can be any decimal number. For example, you can have a line that is 1.5 pixels
    wide.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strokeStyle`: This property sets the color that will be used to draw lines.
    It can be any one of the CSS color specifiers. For example, to draw in red you
    could use `red` or `#FF0000`, `rgb(255, 0, 0)`, or `rgba(255, 0, 0, 1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fillStyle`: This property sets the color that will be used to fill shapes.
    Like `strokeStyle` it can be any CSS color specifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globalAlpha`: This property sets the alpha or transparency amount to draw
    with. It can be any number from 0 to 1, where 0 is completely transparent and
    1 is completely opaque.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lineCap`: This property determines how the ends of lines are drawn. It can
    be one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`butt` draws a flat end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`round` draws a rounded end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`square` draws a square end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`square` looks similar to `butt` except that it has an extra rectangle drawn
    at the end, making it longer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context properties](img/5947OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`lineJoin`: This property determines how corners are drawn where two lines
    meet. It can be one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bevel` draws a beveled or flat corner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`round` draws a rounded corner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`miter` draws a sharp corner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Context properties](img/5947OT_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Canvas pad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the basics of the canvas API, let's use our newfound knowledge
    to create a drawing application called **canvas pad**. We'll start off with an
    application that draws black lines, like drawing with a pen on paper. Then we
    will add a toolbar and menus so that the user can change options such as width,
    opacity, color, and select different drawing tools.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a canvas pad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for this section at `chapter4/example4.1`. Let's
    start by copying our application template that we created in the first chapter
    and renaming the file names to `canvasPad.html`, `canvasPad.css`, and `canvasPad.js`.
    Then we'll go in and change the links in the HTML for those files. Finally we
    change the main application object in the JavaScript to `CanvasPadApp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add a `<canvas>` element to the HTML right inside the `<div id="main">`
    element and size it to 600 by 400:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we''ll add some styles to the CSS to center the canvas on the page and
    give it a white background. We''ll also use a `box-shadow` element to make it
    stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to encapsulate our interaction with the canvas we are going to create
    a new object called `Canvas2D` and put it in a file named `canvas2d.js`. In this
    object we will create some higher level drawing functions. This object''s constructor
    takes a `<canvas>` element wrapped in a jQuery object as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the constructor does is set some private variables. We get the
    context, width, and height from the `$canvas` jQuery object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get access to the underlying element that a jQuery object wraps by using
    square brackets such as an array. So in this case `$canvas[0]` gives us the first
    (and only) `<canvas>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a new canvas pad application from our template and added a canvas
    to it. We centered the canvas on the page and gave it an all-over shadow to frame
    it and make it appear to float on top of the page. Finally, we created a `Canvas2D`
    object to encapsulate interaction with the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – showing the coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we will implement in our `Canvas2D` object is a way to convert
    page coordinates to canvas coordinates. Then we will use that to show the mouse
    coordinates on the page as the user moves their mouse over the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with mouse coordinates is that they are always offset from the top
    left of the web page. To get the canvas coordinates we need to find the offset
    of the `<canvas>` element on the page and subtract it from the page coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a variable named `pageOffset` to hold the offset of the canvas
    element. We''ll set its value using jQuery''s `offset()` method, which gets the
    page offset of an element. It returns an object with `left` and `top` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we add a `getCanvasPoint()` method. It takes the `pageX` and `pageY` parameters,
    subtracts the canvas element offsets, and returns a new object with `x` and `y`
    fields to hold the adjusted coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our canvas is centered on the page, whenever the size of the window changes
    the offset of the canvas will change as well. So we need to add a `resize` event
    handler to the window so that whenever it changes the `pageOffset` variable gets
    updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the code to show the mouse coordinates in the status bar when
    the user moves the mouse over the canvas. First we need an instance of the `Canvas2D`
    object in our application''s main class, `CanvasPadApp`. We will assign it to
    a private variable named `canvas2d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will show the coordinates in the `<footer>` element below the canvas. Let''s
    add a `<span>` in the footer to hold the coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we add a `mousemove` event handler to the `<canvas>` element in the `start()`
    method. It will call `onMouseMove` when the mouse is moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onMouseMove` event handler calls the `canvas2d.getCanvasPoint()` method
    passing in the page coordinates from the mouse event. It gets back the position
    of the mouse on the canvas and passes that into the `showCoordinates()` method
    to display them in the footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `showCoordinates()` method uses jQuery's `text()` method to put the coordinates
    into the footer. Now if you move the mouse over the canvas on the page you will
    see the coordinates change. When you move the mouse to the top-left corner it
    should display **(0, 0)**.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We computed the page offset of the mouse on the canvas by subtracting the position
    of the canvas from the mouse coordinates. Then we added a `mousemove` event handler
    to display the coordinates in the footer when the user moves the mouse over the
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we want to implement is a way for the user to draw simple lines,
    or to scribble on the canvas. To do that we need to get the points when the user
    moves the mouse with the mouse button pressed down and draw lines between them.
    So let's learn how to draw on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Paths and strokes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most primitive way to draw on the canvas is by defining paths and then stroking,
    or drawing them. Think of it as planning what you are going to draw in your head,
    then putting your pen to the paper, and actually drawing it out.
  prefs: []
  type: TYPE_NORMAL
- en: To create a path you define it by specifying two or more points using `moveTo()`
    and `lineTo()` methods. Then you draw it to the canvas by calling the `stroke()`
    method. There are four basic methods that you use to define and draw paths.
  prefs: []
  type: TYPE_NORMAL
- en: '`beginPath()`: This method starts a new path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moveTo(x, y)`: This method moves the pen to a new position without drawing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lineTo(x, y)`: This method draws a line from the previous position to a new
    position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stroke()`:This method draws the path onto the canvas. It is important to note
    that nothing actually gets drawn to the canvas until you call `stroke().`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code draws a line from the point (10, 10) to (80, 100):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make any number of calls to the `moveTo()` and `lineTo()` methods between
    `beginPath()` and `stroke()`. This allows you to queue up a number of drawing
    commands and then commit them to the canvas all at once. If you want your path
    to form a closed shape you can call the `closePath()` method to draw a line from
    the last point to the first point. For example, the following code draws a triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to fill your shapes by calling the context''s `fill()`
    method instead of `stroke()` . Actually you can call both `fill()` and `stroke()`
    if you want the shape to be outlined in one color and filled with another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Paths and strokes](img/5947OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – using the mouse to draw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do is capture mouse events. Let''s go into our `CanvasPadApp`
    object and add the code to check for them in the `start()` method. As you may
    recall, we already added a `mousemove` event handler above. Now we will add handlers
    for `mousedown`, `mouseup`, and `mouseout` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: No, there's not a mistake in `mouseout`. We want the `mouseout` event to be
    handled the same way as `mouseup`, so they both stop the drawing process. The
    `mouseout` event is fired when the mouse leaves the `<canvas>` element. When that
    happens we can't get `mousemove` events anymore and therefore lose track of the
    pen position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement the event handlers we need a couple of new variables to
    keep track of things. We need a Boolean value to keep track of when we are drawing,
    an array to keep track of the current set of points, and an array to keep track
    of all the sets of points (we will call them actions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you give your global object variables default values it will make
    it easier for code editors that have an autocomplete feature to figure out what
    the type of the variable is and give you the appropriate suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s implement `onMouseDown()` since this starts the drawing process.
    It takes one parameter, which is the mouse event object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do in the `onMouseDown()`method is call `preventDefault()`
    on the mouse event object. This will stop the system from doing the default mouse
    down behavior, part of which is to change the mouse cursor icon. We want it to
    remain a cross icon, which we previously set in the CSS. Then we call `penDown()`
    passing in the page coordinates of the mouse which we get from the mouse event.
  prefs: []
  type: TYPE_NORMAL
- en: In the `penDown()` method we initialize the drawing process. First, we set the
    `drawing` flag to `true`. Then we create a new array to put the current drawing
    points into it. Then we add the first point to the array after converting it from
    page coordinates to canvas coordinates by calling `getCanvasPoint()` . The final
    thing we do is add the current `points` array to the `actions` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in the drawing process is to handle `mousemove` events, so let''s
    rewrite the `onMouseMove()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `onMouseMove()`calls `penMoved()` passing it the mouse coordinates. The
    `penMoved()` method first converts the coordinates then calls `showCoordinates()`
    as it did before. Then we check if the `drawing` flag is set. This was set in
    the `penDown()` method so we know that the mouse button is down. If the user is
    drawing then we add the current point to the array of points and call `redraw()`,
    which we will implement next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `redraw()` method first clears the canvas by calling `canvas2d.clear()`,
    which we will write next, then it iterates over all of the actions and calls `drawPoints()`
    passing in the set of points for each action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go into our `Canvas2D` object and add the `clear()` and `drawPoints()`
    methods. First, our `clear()` method calls the `context.clearRect()` method passing
    in the canvas `width` and `height` variables we defined in the `Canvas2D` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `drawPoints()` method takes an array of points and draws lines between
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After beginning a new path it calls `moveTo()` to move the pen to the first
    point in the array. Then it iterates over the remaining points in the array calling
    `lineTo()` for each one. When it's done it calls `stroke()` to draw it to the
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all of the methods in Canvas2D that wouldn't normally return a value we
    will return `this` so we can do function chaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to implement is the `onMouseUp()` event handler. All
    we need to do here is set the `drawing` flag back to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used mouse events to capture and store drawing actions in a buffer. Then
    we used the canvas API to draw lines to the canvas from those points. Now let's
    open our application in the browser and check it out. We can scribble on the canvas
    using the mouse and create simple line drawings.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Changing context properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take our application to the next level by allowing the user to change
    the pen properties such as color, opacity, and width.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding context properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First let''s add some code to our `Canvas2D` object to allow us to change the
    global context drawing properties. Let''s set some default values in the constructor.
    We will set the pen to black with a width of `4` and make it completely opaque
    by setting `globalAlpha` to `1`. We will set the line joins and caps to round
    to make our lines look smoother:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we''ll add public property accessor methods to allow us to set and get
    the value of the color, opacity, and width properties. If a parameter is passed
    into a property method (that is, `arguments.length` is not `0`) it will set the
    value of the property then return `this` so we can do function chaining. Otherwise
    it will return the value of the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now all we need is a way for the user to change these settings from the application,
    so the next thing we will implement is a toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our toolbar will need the following buttons. The first three will be used to
    change the properties of the context. The last two will allow us to undo and clear
    the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '**Color**: This button displays a drop-down menu where the user can choose
    a pen color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opacity**: This button displays a drop-down menu where the user can choose
    the pen opacity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Width**: This button displays a drop-down menu where the user can choose
    the pen width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undo**: This button removes the last drawing action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear**: This button clears the canvas and all drawing actions to start over'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom data attributes, which we covered in the previous chapter, will be used
    throughout our toolbar to define actions for the toolbar buttons and options for
    our menus. We will use these later in our JavaScript to determine the action or
    option that was selected. Adding a little extra markup now will save us from writing
    a lot of repetitive code later on.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code for this section in `chapter4/example4.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define the toolbar in our HTML file just inside the main element and
    above the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Each toolbar button has a `data-action` custom attribute. This will be used
    in JavaScript to determine which action to take when the button is clicked. For
    the buttons with drop-down menus we set the `data-action` to `"menu"`. The **Undo**
    and **Clear** buttons each have their own unique action values.
  prefs: []
  type: TYPE_NORMAL
- en: Since the toolbar items for color, opacity, and width are drop-down menus we
    wrapped them in a `<div class="dropdown-menu">` element. This groups the toolbar
    button and the menu to display when the button is clicked. The menus are defined
    using as an unordered list. Each `<ul>` element is given a class of `menu` and
    a `data-option` custom attribute. The value of this attribute matches to the name
    of a property method in the `Canvas2D` object, for example `penColor()`.
  prefs: []
  type: TYPE_NORMAL
- en: The menu items are defined with `<li>` elements. Each one has a `data-value`
    custom attribute. This is set to the value that will be passed into the property
    method defined by the `data-option` attribute on the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s style the toolbar in CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'First we make the color of the toolbar black with a 50 percent opacity so the
    background color bleeds through. Then we style the buttons to remove the borders
    and background color, and set the text color to white. Now let''s style the drop-down
    menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We set the `<div class="dropdown-menu">`wrapper elements to display `inline-block`
    and set the `position` to `relative` so that we can absolutely position the menus
    under them.
  prefs: []
  type: TYPE_NORMAL
- en: For the `<ul>` menu elements first we set `display` to `none` so they are hidden
    by default. Then we set the `position` to `absolute` so they don't take up any
    space in the page. To make them appear below the button instead of over it we
    set `top` to `100%`. Then we give it a shadow to give the illusion of depth. Finally,
    we get rid of the list bullet points by setting `list-style-type` to `none`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally let''s style the menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We give the menu items a minimum width so they don't get too small. We also
    specify a style for the selected menu item to display a circle next to it using
    `list-style-type` and color the background light blue.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a toolbar in our HTML file with menu items for color, width, and
    opacity. We used custom data attributes to define custom actions that will be
    implemented in our JavaScript. Lastly we styled the menus in our CSS file so they
    line up under their toolbar buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing a reusable toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s create a new reusable `Toolbar` object that encapsulates the code
    for a toolbar. That way we can also use it in our other applications later on.
    We will put it inside a new file called `toolbar.js`. The constructor will take
    the root element of the toolbar wrapped in a jQuery object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Remember how I said in [Chapter 1](ch01.html "Chapter 1. The Task at Hand"),
    *The Task at Hand* that the `this` pointer can cause problems when using event
    handlers with public methods? To get around that we will create a global `_this`
    variable and set it to the object's `this` so it's always available.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will implement the public methods. We have two methods that are used
    to notify the application that either a toolbar button or menu item has been clicked.
    In this object they are just placeholders. The client application will override
    them to implement custom behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `toolbarButtonClicked()` method takes the button's `data-action` attribute
    as a parameter. The `menuItemClicked()` method takes the menu's `data-option`
    and the menu item's `data-value` attribute as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a public method called `hideMenus()` to hide all of the toolbar''s
    drop-down menus. It just finds all of the menu elements and hides them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we will add is an event handler for all of the toolbar buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks a button in the toolbar, it calls the private `onToolbarButtonClicked()`
    method passing it the button that was clicked wrapped in a jQuery object. Let''s
    implement that handler now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This method gets the value of the `data-action` custom attribute from the button.
    Then it passes it into the public `toolbarButtonClicked()` method. Notice that
    it must use `_this` to call the public methods because `this` is currently pointing
    at the `window` object. If `toolbarButtonClicked()` returns `true` it means that
    the client handled the action and there's nothing else to do. Otherwise it checks
    if the action was `"menu"` and if so, calls `showMenu()` passing in the menu element,
    which is a sibling of the button. If it's not, the menu action it hides all the
    menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write the private `showMenu()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We use the jQuery `is()` method passing in the `:visible` filter to determine
    if the menu is already showing. If it is, it fades the menu out to hide it. Otherwise
    it hides all of the menus in the toolbar, in case another one is open, and then
    fades the menu in to show it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we add the click event handler for all of the menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user clicks a menu item in the toolbar it calls `onMenuItemClicked()`
    passing it the menu item that was clicked wrapped in a jQuery object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First we get the parent element which is the menu. Then we get the `data-option`
    attribute from it. Next we get the `data-value` attribute from the menu item itself.
    We pass those values as parameters to the public `menuItemClicked()` method. If
    that method returns `true` it means that the client handled the action and there's
    nothing else to do. Otherwise we add a `"selected"` class to the menu item to
    highlight it and remove the class from all of the other menu items. Then we fade
    the menu out to hide it.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a reusable object that encapsulates toolbar behavior including buttons
    and dropdown menus. It uses custom data attributes to define the actions for toolbar
    buttons and menu items. We can use this object in our applications whenever we
    need a toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a `Toolbar` object and the HTML for our toolbar and menus defined
    we can hook up events in our drawing application to handle user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the toolbar object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the `Toolbar` object to our application. First we add a `toolbar`
    variable to `CanvasPadApp` and set it to a new instance of the `Toolbar` object.
    We pass in the toolbar''s root `<div>` element as a parameter to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In `start()` we override the `toolbar` object''s `toolbarButtonClicked()` and
    `menuItemClicked()` methods to set them to our own implementations to handle those
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'First let''s implement our `CanvasPadApp.toolbarButtonClicked()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks the **Clear** button we confirm that they want to clear
    the canvas. If so we set the `actions` array to a new array to clear everything
    out and then call `redraw()`, which clears the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks the **Undo** button it removes the last drawing action
    from the `actions` array, then calls `redraw()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the `menuItemClicked()` method. It takes two parameters;
    the menu option name and the value of the menu item that was selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you remember from earlier instances, the `data-option` attribute is the name
    of the method that is used to set the property in the `Canvas2D` object. We use
    the square brace method of accessing that method in the object, and then we execute
    it passing the `data-value` attribute from the menu item into it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the user clicked the red menu item in the **Color** menu, the
    `data-option` would be `"penColor"` and the `data-value` would be `"red"`. So
    in this case the statement `canvas2d[option](value)` would be equivalent to calling
    `canvas2d.penColor("red")`.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added the reusable `Toolbar` object we created in the previous section to
    our application and added event handlers to handle toolbar button and menu events.
    Then we implemented the undo and clear actions.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – initializing menu items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next we will initialize the **Color** menu to set the background color of each
    item to the color it represents. We could do that in CSS but it would be cumbersome.
    Instead we are going to write a JavaScript method to set them all with just a
    little bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This gets all of the color menu items and iterates over them using the jQuery
    `each()` method. For each item it sets the background color using the jQuery `css()`
    method to the value of the `data-value` custom attribute, which is a CSS color
    name. Just like that we have a menu of colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to do something similar for the width menu''s items, except we will
    set the bottom border to the width in the `data-value` custom attribute to give
    the user some idea of how big the line will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We will call these two methods from the `start()` method when we're initializing
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We changed the styles for the color and width menu items to give them colors
    and widths respectively so that the user can better see what they are selecting
    from the menus.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you open the application in the browser you can change the pen's properties.
    Go ahead and draw a few lines. If you click on **Undo,** the last line is erased.
    When you click on **Clear**, the entire drawing is erased.
  prefs: []
  type: TYPE_NORMAL
- en: Adding drawing actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that when you changed an option, the next time you drew
    something the options applied to all of the previous lines that were drawn. That's
    not a very good user experience. The user expects that when they change the pen
    options it will only apply to the next thing they draw, not everything.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get that to work properly we will need to add more data to each
    action than just a list of points. We also need to know the color, width, and
    opacity to draw the points with. For that we need an object to hold all of these
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating drawing actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use a factory method to create this object. Let''s add a `newAction()`method
    to `CanvasPadApp` that creates the action object for us with the current drawing
    options set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `newAction()` method takes one parameter which is the name of the drawing
    tool the action will use. Next it uses curly braces to define a new object literal.
    The object will hold the tool, the context property values, and the points for
    that action. It gets the current color, width, and opacity settings from our `Canvas2D`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is remove the global `points` variable from the
    `CanvasPadApp` object and replace it with a `curAction` variable to hold the current
    action object created by `newAction()`. Let''s also add a `curTool` variable to
    hold the current tool, and set it to `"pen"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, wherever we used the `points` variable before we will need to change it
    to use `curAction.points` instead. The first spot is the `penDown()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First we set `curAction` to a new action object, and then add the first point
    to the `curAction` object's `points` array. Then we add `curAction` to the `actions`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next stop is the `penMoved()` method. There we add the next point to the
    action''s `points` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update the `penUp()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: First we check the `drawing` variable to make sure we are indeed drawing. If
    so we turn off the `drawing` flag by setting it to `false`. Next we need to make
    sure there are at least two points in the action's `points` array. If the user
    pressed the mouse button but didn't move it, there would only be one point. We
    can't draw anything without two points so we'll just remove that action from the
    `actions` array using `pop()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we will update the `redraw()` method. Here''s where we need to make
    some substantial changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: First of all notice the calls to `savePen()` and `restorePen()` in the `Canvas2D`
    object. They will save the current context properties before we start drawing
    all of the actions and then restore them when we are done. We will implement those
    in a moment. Next we iterate over all of the actions setting the pen color, width,
    and opacity for each one (using function chaining) before drawing the points.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a drawing action object to keep track of the tool, pen properties,
    and points for each drawing action. Now when we change drawing properties they
    don't affect previous actions.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – saving and restoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, about those `savePen()` and `restorePen()` methods. Let's go on over to
    `canvas2d.js` and add them to the `Canvas2D` object. We could keep track of the
    current properties ourselves, but the canvas API provides an easier way.
  prefs: []
  type: TYPE_NORMAL
- en: The canvas API contains both `save()` and `restore()` methods. Any time you
    need to save the state of the context you call `save()` and it pushes the state
    of the context on to a stack. When you want to restore the context state you call
    `restore()` and it pops the state off the stack back into the context. This allows
    you to save and restore the state multiple times recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works great for situations where you may have a library of drawing functions
    that could be drawn in any order at runtime. Each method can call `save()` before
    it starts changing context properties and call `restore()` when it''s done. That
    way when a method is done the context is in the same state that it was before
    the method was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to save the context and restore it so that we don't lose the
    context's current properties.
  prefs: []
  type: TYPE_NORMAL
- en: Let's open the application in the browser and take a look. Now we can draw in
    all different colors, widths, and opacities. If you make a mistake you can click
    on **Undo** to erase it. And if you want to start all over you can click on **Clear**.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding drawing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we have an application where we can draw simple lines such as
    a pen, but it sure would be nice if we could draw some shapes such as straight
    lines, rectangles, and circles. In this section we will add a **Tool** menu to
    allow the user to select different shapes to draw.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code for this section in `chapter4/example4.3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently we can draw freehand lines, but we don''t have a way to draw a straight
    line from one point to another. So let''s add a line drawing tool. To allow the
    user to select different tools we need a new drop-down menu toolbar option. Let''s
    add it to our HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For this menu we are setting the `data-option` attribute to `drawingTool`.
    We add menu items for the **Pen** tool, which we currently have, and a **Line**
    tool, which we are implementing now. Since `drawingTool` isn''t a property of
    the `Canvas2D` object we need to add code to check for it in `menuItemClicked()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: First we check to see which option was selected. If it's `"drawingTool"` we
    simply set the current tool to the value of the menu item that was selected. Otherwise
    we do the default behavior of setting the `Canvas2D` property with the selected
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will change the `penMoved()` method. We need to check which tool we
    are currently using. If it''s the pen we add another point to the `points` array.
    Otherwise we only want to change the second point in the `points` array because
    we are drawing a straight line, and a line only has two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly we need to make some changes to the `redraw()` method. Inside the loop
    we will check the action''s tool. If it''s the pen we call `canvas2d.drawPoints()`
    the same as we did before. If it''s the line tool we call `canvas2d.drawLine()`
    passing in the two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a minute! We don''t have a `drawLine()` method in the `Canvas2D` object
    yet. So let''s go add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `drawLine()` method takes the line start and end points as parameters. After
    beginning a new path it moves to the first point, draws a line to the second point,
    and then strokes it. That's it. Now we can draw straight lines.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a **Tool** menu to our toolbar where the user can select different
    drawing tools. In addition to the pen tool we already had, we added a line drawing
    tool to draw straight lines in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing rectangles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could draw a rectangle using paths, but the canvas API has a couple built
    in methods to do this; `drawRect()` and `fillRect()`. They both take the same
    parameters; *x*, *y*, width, and height. `drawRect()` uses the `strokeStyle` to
    draw the lines and `fillRect()` uses the `fillStyle` to fill it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following draws a rectangle starting at the point (350, 10) with a width
    of `50` and a height of `90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This example draws a filled rectangle starting at the point (425, 10) with
    a width of `50` and a height of `90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![Drawing rectangles](img/5947OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – adding a rectangle tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a tool to draw rectangles. We''ll start by adding a menu item to
    the **Tool** drop-down menu with its `data-value` attribute set to `"rect"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `drawRect()` method in `Canvas2D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Our `drawRect()` method takes three parameters; the two points that define top-left
    and bottom-right coordinates, and a Boolean value to determine if the rectangle
    should be filled. Since `fillRect()` and `strokeRect()` both take width and height
    parameters we need to compute them by subtracting the `point1` variable's coordinates
    from `point2` variable's coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we code up the call to `drawRect()` there is one piece of business we
    need to take care of. Our `drawRect()` method can draw either outlined or filled
    rectangles, so we need a way to let the user pick which one they want. Let''s
    add another drop-down menu to the toolbar named **Fill** that allows the user
    to set this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The drop-down menu has only two options: **Yes** and **No**. In our `CanvasPadApp`
    object we need a global `fillShapes` Boolean variable to keep track of the current
    setting. Let''s add this at the top of the object along with our other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add it to the action object in the `newAction()` method. We
    will add a field named `fill` and set it to the current value of `fillShapes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to add some extra code to the `menuItemClicked()` method to check
    if the option was the **Fill** menu option and if so set the `fillShapes` variable
    to its `data-value`. Since the value is either `"true"` or `"false"` we can convert
    it directly to a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, that''s it for the **Fill** option. Now we can add the code to the `redraw()`
    method to check for the rectangle tool and draw it by calling `drawRect()`. We
    will pass in the two points of the rectangle and the value of `action.fill` to
    tell it whether to fill the rectangle or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a rectangle tool to our **Tool** menu. We also added a new toolbar
    menu to select whether to fill shapes or not. We used this to determine whether
    to draw filled or outlined rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Arcs and circles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to straight lines you can draw arcs, or portions of a circle, using
    the context''s `arc()` method. It takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`centerX`: This parameter tells the horizontal position of the center point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`centerY`: This parameter tells the vertical position of the center point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radius`: This parameter tells the radius of the arc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startAngle`: This parameter tells the starting angle of the arc specified
    in radians. It can be any value between `0` to `2π`. Numbers outside this range
    will automatically be normalized into it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endAngle`: This parameter tells the ending angle of the arc specified in radians.
    It can be any value between `0` to `2π`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`counterclockwise`: This is a `Boolean` parameter that specifies which direction
    to draw the arc from start to end angle. If false it draws clockwise, if true
    counterclockwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arcs are really paths, so you must use `beginPath()` and `stroke()` to draw
    them. The following code draws the bottom-right corner of a circle. The center
    is at the point `(100, 200)`. It has a radius of `40`. The angle starts at `0`
    and ends at `π/2` radians, or 90 degrees. And it is drawn clockwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can draw a full circle using the `arc()` method too. A circle is simply
    a complete arc drawn from `0` to `2π` radians, or 360 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If you are unfamiliar with radians, let me give you a brief overview. Radians
    are simply another way to specify an angle. It is based on the formula for the
    circumference of a circle; `C = 2 * π *` radius. By setting the radius to `1`,
    we can use that formula to measure the length of an arc from one point on the
    circle to another point along the circumference. If you were to measure all the
    way around a circle you would have `2π` radians. Therefore, `2π` radians are equal
    to 360 degrees. Half way around the circle is `π` radians, which is equal to 180
    degrees. One quarter of the way around is `π/2` radians or 90 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arcs and circles](img/5947OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you prefer to use degrees you can always use this conversion function to
    convert degrees to radians:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of arcs using different parameters. Arcs 1 and 2 use
    the same start and end angles, just drawing in different direction. The same is
    true for arcs 3 and 4\. Arc 5 draws a complete circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context.arc(100, 200, 40, 0, toRadians(90), true);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.arc(200, 200, 40, 0, toRadians(90), false);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.arc(300, 200, 40, 0, toRadians(180), true);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.arc(400, 200, 40, 0, toRadians(180), false);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.arc(500, 200, 40, 0, toRadians(360), false);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Arcs and circles](img/5947OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – adding a circle tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a circle menu item to our **Tool** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go ahead and add a `drawCircle()` method to `Canvas2D`. Our method
    will take the center point, the radius, and a Boolean value to determine if the
    circle should be filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If the fill parameter is set to true we call `context.fill()` after calling
    `arc()`. Otherwise we just use `context.stroke()` to draw the outline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally let''s add the code to `redraw()` to draw the circle. Here we need
    to do a little work to find the radius to pass into `drawCircle()`. First we find
    the difference in `x` between the first and second point, then the difference
    in `y`. Whichever one is smaller we will use that as our radius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a new menu item to the **Tool** menu to draw circles using the context's
    `arc()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Open the application and give it a try. Now we have a pretty decent collection
    of drawing tools in our application. We can make some more sophisticated drawings
    with all different colors and opacities rather than just black scribbles.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try adding your own drawing tool, such as a triangle or some other shape. Implement
    the drawing of the shape in the `Canvas2D` object then add a menu item to the
    toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. What unit is used to define the angle when drawing arcs?
  prefs: []
  type: TYPE_NORMAL
- en: Degrees
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Units
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Radians
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arcs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. What context method is used to draw a path to the canvas?
  prefs: []
  type: TYPE_NORMAL
- en: '`drawPath()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stroke()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`draw()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`endPath()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a drawing application called canvas pad which can
    be used to make simple drawings. Along the way we learned how to use the HTML5
    canvas element and API. We also learned how to implement a reusable toolbar with
    menu items that are bound to actions using custom data attributes. We now have
    a reusable toolbar we can use in other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use the `<canvas>` element and the canvas API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get a canvas context and change global drawing properties such as width,
    color, and opacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use paths to draw free lines and shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to draw lines, rectangles, and circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get the position of the mouse inside a canvas element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a reusable toolbar and implement drop-down menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use custom data attributes to bind actions to menu items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will continue our exploration of the canvas. We will
    learn some more advanced canvas features such as transformations and rotations.
    We will also see how to load images and export them from the canvas, in the process
    touching upon the file API. Then we will get down to the individual pixels of
    the canvas to do some image manipulation.
  prefs: []
  type: TYPE_NORMAL
