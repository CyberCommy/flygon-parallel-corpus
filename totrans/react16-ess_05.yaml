- en: Chapter 5. Making Your React Components Reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to create React components with and without state, we
    can start composing React components together and build more complex user interfaces.
    In fact, it's time for us to start building our web application called **Snapterest**
    that we discussed in [Chapter 2](ch02.html "Chapter 2. Installing Powerful Tools
    for Your Project"), *Installing Powerful Tools for Your Project*. While doing
    this, you'll learn how to plan your React application and create composable React
    components. Let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: Solving a problem using React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start writing code for your web application, you need to think about
    the problems that your web application is going to solve. It's very important
    to understand that to define the problem as clearly and as early as possible is
    the most important step toward a successful solution—a useful web application.
    If you failed to define your problem earlier in your development process, or you
    defined it inaccurately, then later on you'll have to stop, rethink what you're
    doing, throw away a piece of the code that you have already written, and write
    a new one. This is a wasteful approach, and as a professional software developer,
    your time is very valuable not only to you but also to your organization, so it's
    in your best interest to invest it wisely. Earlier in this book, I stressed the
    fact that one of the benefits of using React is code reuse, which means that you'll
    be able to do more in less time. However, before we take a look at the React code,
    let's first discuss the problem, keeping React in mind.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be building Snapterest—a web application that receives tweets from a Snapkite
    Engine server in a real-time manner and displays them one at a time to a user.
    We don't actually know when Snapterest will receive a new tweet, but when it does,
    it will display that new tweet for at least 1.5 seconds so that the user has enough
    time to take a look at it, and click on it. Clicking on a tweet will add it to
    an existing collection of tweets or create a new one. Finally, users will be able
    to export their collection to HTML markup code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very high-level description of what we''re going to build. Let''s
    break it down into a list of smaller tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving a problem using React](graphics/B05915_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive tweets from the Snapkite Engine server in real time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display one tweet at a time for at least 1.5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add tweets to a collection on a user click event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display a list of tweets in a collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create HTML markup code for a collection and export it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove tweets from a collection, on a user click event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you identify which tasks can be solved using React? Remember that React
    is a user interface library, so anything that describes the user interface and
    interactions with that user interface can be addressed with React. In the preceding
    list, React can take care of all the tasks, except for the first one because it
    describes data fetching and not the user interface. Step 1 will be solved with
    another library that we'll discuss in the next chapter. Steps 2 and 4 describe
    something that needs to be displayed. They are perfect candidates for React components.
    Steps 3 and 6 describe the user events, and as we've seen in [Chapter 4](ch04.html
    "Chapter 4. Creating Your First React Component"), *Creating Your First React
    Component*, the handling of user events handling can be encapsulated in React
    components as well. Can you think of how step 5 can be solved with React? Remember
    in [Chapter 3](ch03.html "Chapter 3. Creating Your First React Element"), *Creating
    Your First React Element*, we discussed the `ReactDOMServer.renderToStaticMarkup()`
    method that renders the React element to a static HTML markup string. This is
    exactly what we need in order to solve step 5.
  prefs: []
  type: TYPE_NORMAL
- en: Now when we've identified a potential solution for each individual task, let's
    think about how we are going to put them together and create a fully functional
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to build composable React applications:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you can start by building individual React components, and then compose
    them together into higher-level React components, moving up the component hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can start from the topmost React element and then implement its child components,
    moving down the component hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second strategy has an advantage of seeing and understanding the big picture
    of your application's architecture, and I think it's important to understand how
    everything fits together before we can think of how individual pieces of functionality
    are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Planning your React application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two simple guidelines we need to follow when planning your React
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Each React component should represent a single user interface element in your
    web application. It should encapsulate the smallest element possible that can
    potentially be reused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple React components should be composed into a single React component.
    Ultimately, your entire user interface should be encapsulated in one React component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Planning your React application](graphics/B05915_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of our React components hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin with our topmost React component, **Application**. It will encapsulate
    our entire React application, and it will have two child components: the **Stream**
    and **Collection** components. The **Stream** component will be responsible for
    connecting to a stream of tweets, receiving, and displaying the latest tweet.
    The **Stream** component will have two child components: **StreamTweet** and **Header**.
    The **StreamTweet** component will be responsible for displaying the latest tweet.
    It will be composed of the **Header** and **Tweet** components. A **Header** component
    will render a header. It will have no child components. A **Tweet** component
    will render an image from a tweet. Notice how we''re planning to reuse the **Header**
    component twice already.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Collection** component will be responsible for displaying the collection
    controls and a list of tweets. It will have two child components: **CollectionControls**
    and **TweetList**. The **CollectionControls** component will have two child components:
    the **CollectionRenameForm** component that will render a form to rename a collection,
    and the **CollectionExportForm** component that will render a form to export a
    collection to a service called **CodePen**, which is an HTML, CSS, and JavaScript
    playground website. You can learn more about CodePen at [http://codepen.io](http://codepen.io).
    As you might have noticed, we''ll reuse the **Header** and **Button** components
    in the **CollectionRenameForm** and **CollectionControls** components. Our **TweetList**
    component will render a list of tweets. Each tweet will be rendered by a **Tweet**
    component. We''ll be reusing the **Header** component once again in our **Collection**
    component. In fact, in total, we''ll be reusing the **Header** component five
    times. That''s a win for us. As we discussed in the previous chapter, we should
    keep as many React components stateless as possible. So only 5 out of 11 components
    will store the state, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CollectionControls**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CollectionRenameForm**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StreamTweet**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now when we have a plan, we can start implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a container React component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by editing our application''s main JavaScript file. Replace the
    content of the `~/snapterest/source/app.js` file with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are only four lines of code in this file, and as you can guess, they provide
    `document.getElementById('react-application')` as a deployment target for the
    `<Application/>` component and render `<Application/>` to the DOM. The whole user
    interface for our web application will be encapsulated in one React component,
    `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, navigate to `~/snapterest/source/components/` and create the `Application.js`
    file inside this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This component has significantly more code than our `app.js` file, but this
    code can be easily divided into three logical parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing dependency modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a React component class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting a React component class as a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our first logical part of the `Application.js` file, we''re importing the
    dependency modules using the `require()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Application` component will have two child components that we need to
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Stream` component will render a stream section of our user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Collection` component will render a collection section of our user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to import the `React` library as another module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second logical part of the `Application.js` file creates the React `Application`
    component class with the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addTweetToCollection()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeTweetFromCollection()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAllTweetsFromCollection()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only the `render()` method is part of the React API. All the other methods
    are part of our application logic that this component encapsulates. We''ll take
    a closer look at each of them right after we discuss what this component renders
    inside its `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it defines the layout of our web page using the Bootstrap framework.
    If you''re not familiar with Bootstrap, I strongly recommend that you visit [http://getbootstrap.com](http://getbootstrap.com)
    and read the documentation. Learning this framework will empower you to prototype
    user interfaces quickly and easily. Even if you don''t know Bootstrap, it''s quite
    easy to understand what''s going on. We''re dividing our web page into two columns:
    a smaller one and a larger one. The smaller one contains our `Stream` React component,
    and the larger one contains our `Collection` component. You can imagine that our
    web page is divided into two unequal parts, and both of them contain the React
    components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we''re using our `Stream` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Stream` component has an `onAddTweetToCollection` property and our `Application`
    component passes its own `addTweetToCollection()` method as a value for this property.
    The `addTweetToCollection()` method adds a tweet to a collection. It's one of
    the custom methods that we define in our `Application` component. We don't need
    the `this` keyword because the method was defined as an arrow function, so the
    scope of the function is automatically our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what the `addTweetToCollection()` method does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method references collection tweets that are stored in the current state,
    adds a new tweet to a `collectionTweets` object, and updates the state by calling
    the `setState()` method. A new tweet is passed as an argument when the `addTweetToCollection()`
    method is called inside a `Stream` component. This is an example of how a child
    component can update its parent component's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This an important mechanism in React and it works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A parent component passes a callback function as a property to its child component.
    A child component can access this callback function via the `this.props` reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever a child component wants to update the parent component's state, it
    calls that callback function and passes all the necessary data to a new parent
    component's state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A parent component updates its state, and as you already know that this state
    updates and triggers the `render()` method that re-renders all the child components
    as necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how a child component interacts with a parent component. This interaction
    allows a child component to delegate the application''s state management to its
    parent component, and it is only concerned with how to render itself. Now when
    you''ve learned this pattern, you will be using it again and again because most
    of your React components should stay stateless. Only a few parent components should
    store and manage your application''s state. This best practice allows us to logically
    group React components by two different concerns that they address:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the application's state and rendering it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only rendering and delegating the application's state management to a parent
    component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `Application` component has a second child component, `Collection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This component has a number of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tweets`: This refers to our current collection of tweets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRemoveTweetFromCollection`: This refers to a function that removes a particular
    tweet from our collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRemoveAllTweetsFromCollection`: This refers to a function that removes all
    the tweets from our collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see that the `Collection` component''s properties are only concerned
    about how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the application's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutate the application's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can guess, the `onRemoveTweetFromCollection` and `onRemoveAllTweetsFromCollection`
    functions allow the `Collection` component to mutate the `Application` component's
    state. On the other hand, the `tweets` property propagates the `Application` component's
    state to the `Collection` component so that it can gain read-only access to that
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you recognize the single direction of data flow between the `Application`
    and `Collection` components? Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: The `collectionTweets` data is initialized in the `Application` component's
    `constructor()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `collectionTweets` data is passed to the `Collection` component as the `tweets`
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Collection` component calls the `removeTweetFromCollection` and `removeAllTweetsFromCollection`
    functions that update the `collectionTweets` data in the `Application` component,
    and the cycle starts again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the `Collection` component cannot directly mutate the `Application`
    component's state. The `Collection` component has read-only access to that state
    via a `this.props` object, and the only way to update the parent component's state
    is to call the callback functions that are passed by a parent component. In the
    `Collection` component, these callback functions are `this.props.onRemoveTweetFromCollection`
    and `this.props.onRemoveAllTweetsFromCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple mental model of how data flows in our React component hierarchy
    will help us increase the number of components we use, without increasing the
    complexity of how our user interface works. For example, it can have upto 10 levels
    of nested React components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a container React component](graphics/B05915_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If `Component G` wants to mutate the state of root `Component A`, it would do
    it in exactly the same way as `Component B` or `Component F`, or as any other
    component in this hierarchy would. However, in React, you shouldn't pass data
    from `Component A` directly to `Component G`. Instead, you should first pass it
    to `Component B`, then to `Component C`, then to `Component D`, and so on, until
    you finally reach `Component G`. `Component B` to `Component F` will have to carry
    some "transit" properties that are actually only meant for `Component G`. This
    might look like a waste of time, but this design makes it easy for us to debug
    our application and reason out how it works. There are always strategies to optimize
    your application's architecture. One of them is to use **Flux design pattern**.
    Another one is to use **Redux** library. We'll discuss both later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish discussing our `Application` component, let''s take a look
    at the two methods that mutate its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `removeTweetFromCollection()` method removes a tweet from a collection of
    tweets that we store in the `Application` component's state. It takes the current
    `collectionTweets` object from the component's state, deletes a tweet with a given
    `id` from that object, and updates the component's state with an updated `collectionTweets`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `removeAllTweetsFromCollection()` method removes all
    the tweets from the component''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Both of these methods are called from a child's `Collection` component because
    that component has no other way to mutate the `Application` component's state.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to solve a problem with React. We started by
    breaking down the problem into smaller individual problems and then discussing
    how we can address them using React. Then, we created a list of React components
    that we will need to implement. Finally, we created our first composable React
    component and learned about how a parent component interacts with its child components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll implement our child components and learn about React's
    life cycle methods.
  prefs: []
  type: TYPE_NORMAL
