- en: Chapter 8. Building the Customer Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The customer module provides a basis for further sales functionality of our
    web shop. At the very basic level, it is responsible for register, login, management
    and display of relevant customer information. It is a requirement for the later
    sales module, that adds the actual sales capabilities to our web shop application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will be covering following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the high level application requirements, defined under [Chapter 4](ch04.html
    "Chapter 4. Requirement Specification for a Modular Web Shop App"), *Requirement
    Specification for Modular Web Shop App*, our module will have a single `Customer`
    entity defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Customer` entity includes the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: integer, auto-increment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: string, unique'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: string, unique, needed for login system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first_name`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`company`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phone_number`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`country`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`city`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcode`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`street`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, aside from just adding the `Customer` entity and its
    CRUD pages, we also need to address the creation of login, register, forgot your
    password pages, as well as override a core module service responsible for building
    a customer menu.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module has no firm dependencies on any other module. While it does override
    a service defined in core module, the module itself is not dependent on it. Furthermore,
    some security config will need to be provided as part of the core application,
    as we will see later on.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start of by creating a new module called `Foggyline\CustomerBundle`. We
    do so with the help of console, by running the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The command triggers an interactive process asking us several questions along
    the way, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, the following structure is generated for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we now take a look at the `app/AppKernel.php` file, we would see the following
    line under the `registerBundles` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `app/config/routing.yml` directory has the following route definition
    added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we need to change `prefix: /` into `prefix: /customer/`, so we don''t
    collide with core module routes. Leaving it as `prefix: /` would simply overrun
    our core `AppBundle` and output **Hello World!** from the `src/Foggyline/CustomerBundle/Resources/views/Default/index.html.twig`
    template to the browser at this point. We want to keep things nice and separated.
    What this means is that the module does not define `root` route for itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a customer entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a `Customer` entity. We do so by using the console,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command triggers the interactive generator, where we need to provide entity
    properties. Once done, the generator creates the `Entity/Customer.php` and `Repository/CustomerRepository.php`
    files within the `src/Foggyline/CustomerBundle/` directory. After this, we need
    to update the database, so it pulls in the `Customer` entity, by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a screen as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a customer entity](graphics/B05460_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With entity in place, we are ready to generate its CRUD. We do so by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in an interactive output as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a customer entity](graphics/B05460_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This results in the `src/Foggyline/CustomerBundle/Controller/CustomerController.php`
    directory being created. It also adds an entry to our `app/config/routing.yml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the view files were created under the `app/Resources/views/customer/`
    directory, which is not what we might expect. We want them under our module `src/Foggyline/CustomerBundle/Resources/views/Default/customer/`
    directory, so we need to copy them over. Additionally, we need to modify all of
    the `$this->render` calls within our `CustomerController` by appending the `FoggylineCustomerBundle:default:
    string` to each of the template path.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the security configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we proceed further with the actual changes within our module, let''s
    imagine our module requirements mandate a certain security configuration in order
    to make it work. These requirements state that we need to apply several changes
    to the `app/config/security.yml` file. We first edit the `providers` element by
    adding to it the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This effectively defines our `Customer` class as a security provider, whereas
    the `username` element is the property storing user identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define the encoder type under the `encoders` element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This tells Symfony to use the `bcrypt` algorithm with a value of `12` for algorithmic
    cost while encrypting our password. This way our passwords won't end up in clear
    text when saved in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then go ahead and define a new firewall entry under the firewalls element,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is quite a lot going on here. Our firewall uses the `anonymous: ~` definition
    to denote that it does not really need a user to be logged in to see certain pages.
    By default, all Symfony users are authenticated as anonymous, as shown in the
    following screenshot, on the **Developer** toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying the security configuration](graphics/B05460_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `form_login` definition takes three properties. The `login_path` and the
    `check_path` point to our custom route `foggyline_customer_login`. When the security
    system initiates the authentication process, it will redirect the user to the
    `foggyline_customer_login` route, where we will soon implement needed controller
    logic and view templates in order to handle the login form. Once logged in, the
    `default_target_path` determines where the user will be redirected to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we reuse the Symfony anonymous user feature in order to exclude certain
    pages from being forbidden. We want our non-authenticated customer to be able
    to access login, register, and forgotten password pages. To make that possible,
    we add the following entries under the `access_control` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that this approach to handling security between module and
    base application is by far the ideal one. This is merely one possible example
    of how we can achieve what is needed for this module to make it functional.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the customer entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the preceding `security.yml` additions in place, we are now ready to actually
    start implementing the registration process. First we edit the `Customer` entity
    within the `src/Foggyline/CustomerBundle/Entity/` directory, by making it implement
    the `Symfony\Component\Security\Core\User\UserInterface`, `\Serializable`. This
    implies implementation of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even though all of the passwords need to be hashed with salt, the `getSalt`
    function in this case is irrelevant since `bcrypt` does this internally. The `getRoles`
    function is the important bit. We can return one or more roles that individual
    customers will have. To make things simple, we will only assign one `ROLE_USER`
    role to each of our customers. But this can easily be made much more robust, so
    that the roles are stored in the database as well. The `eraseCredentials` function
    is merely a cleanup method, which we left blank.
  prefs: []
  type: TYPE_NORMAL
- en: Since the user object is first unserialized, serialized, and saved to a session
    per each request, we implement the `\Serializable` interface. The actual implementation
    of serialize and unserialize can include only a fraction of customer properties,
    as we do not need to store everything in the session.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go ahead and start implementing the register, login, forgot your password,
    and other bits, let's go ahead and define the needed services we are going to
    use later on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the orders service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an `orders` service which will be used to fill in the data available
    under the **My Account** page. Later on, other modules can override this service
    and inject real customer orders. To define an `orders` service, we edit the `src/Foggyline/CustomerBundle/Resources/config/services.xml`
    file by adding the following under the `services` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we go ahead and create the `src/Foggyline/CustomerBundle/Service/CustomerOrders.php`
    directory with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `getOrders` method simply returns some dummy data here. We can easily make
    it return an empty array. Ideally, we would want this to return a collection of
    certain types of element that conform to some specific interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the customer menu service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous module we defined a `customer` service that filled in the Customer
    menu with some dummy data. Now we will create an overriding service that fills
    the menu with actual customer data, depending on customer login status. To define
    a `customer menu` service, we edit the `src/Foggyline/CustomerBundle/Resources/config/services.xml`
    file by adding the following under the `services` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we are injecting the `token_storage` and `router` objects into our service,
    as we will need them to construct the menu based on the login state of a customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then go ahead and create the `src/Foggyline/CustomerBundle/Service/Menu/CustomerMenu.php`
    directory with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we see a menu being constructed based on user login state. This way a customer
    gets to see the **Logout** link when logged in, or **Login** when not logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the `src/Foggyline/CustomerBundle/DependencyInjection/Compiler/OverrideServiceCompilerPass.php`
    directory with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are doing the actual `customer_menu` service override. However, this
    won''t kick in until we edit the `src/Foggyline/CustomerBundle/FoggylineCustomerBundle.php`
    directory, by adding the `build` method to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `addCompilerPass` method call accepts the instance of our `OverrideServiceCompilerPass`,
    ensuring our service override will kick in.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the register process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement a register page, we first modify the `src/Foggyline/CustomerBundle/Controller/CustomerController.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The register page uses a standard auto-generated Customer CRUD form, simply
    pointing it to the `src/Foggyline/CustomerBundle/Resources/views/Default/customer/register.html.twig`
    template file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once these two files are in place, our register functionality should be working.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the login process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement the login page on its own `/customer/login` URL, thus we
    edit the `CustomerController.php` file by adding the `loginAction` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are simply checking if the user already tried to login, and if it did
    we are passing that info to the template, along with the potential errors. We
    then edit the `src/Foggyline/CustomerBundle/Resources/views/Default/customer/login.html.twig`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in, the user will be redirected to the `/customer/account` page.
    We create this page by adding the `accountAction` method to the `CustomerController.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `$this->getUser()` we are checking if logged in user is set, and if so,
    passing its info to the template. We then edit the `src/Foggyline/CustomerBundle/Resources/views/Default/customer/account.html.twig`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this we address the actual customer information section of the **My Account**
    page. In its current state, this page should render an Edit form as shown in the
    following screenshot, enabling us to edit all of our customer information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the login process](graphics/B05460_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then address the `<!-- customer_orders -->`, by replacing it with the following
    bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This should now render the **My Orders** section of the **My Account** page
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the login process](graphics/B05460_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is just dummy data coming from service defined in a `src/Foggyline/CustomerBundle/Resources/config/services.xml`.
    In a later chapter, when we get to the sales module, we will make sure it overrides
    the `foggyline_customer.customer_orders` service in order to insert real customer
    data here.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the logout process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the changes we did to `security.yml` when defining our firewall, was
    configuring the logout path, which we pointed to `/customer/logout`. The implementation
    of that path is done within the `CustomerController.php` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note, the `logoutAction` method is actually empty. There is no implementation
    as such. Implementation is not needed, as Symfony intercepts the request and processes
    the logout for us. We did, however, need to define this route as we referenced
    it from our `system.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Managing forgotten passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The forgotten password feature is going to be implemented as a separate page.
    We edit the `CustomerController.php` file by adding the `forgottenPasswordAction`
    function to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we merely check if the HTTP request is GET or POST, then either send an
    e-mail or load the template. For the sake of simplicity, we haven''t really implemented
    the actual e-mail sending. This is something that needs to be tackled outside
    of this book. The rendered template is pointing to the `src/Foggyline/CustomerBundle/Resources/views/Default/customer/
    forgotten_password.html.twig` file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from the auto-generated `Customer` entity and its CRUD controller, there
    are only two custom service classes that we created as part of this module. Since
    we are not going after full code coverage, we will merely cover `CustomerOrders`
    and `CustomerMenu` service classes as part of the unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by adding the following line under the `testsuites` element of
    our `phpunit.xml.dist` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, running the `phpunit` command from the root of our shop
    should pick up any test we have defined under the `src/Foggyline/CustomerBundle/Tests/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go ahead and create a test for our `CustomerOrders` service. We
    do so by creating a `src/Foggyline/CustomerBundle/Tests/Service/CustomerOrders.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here we have two tests in total, one instantiating the class through the service
    and the other directly. We are using the `setUp` method merely to set the `container`
    property which we then reuse in the `testGetItemsViaService` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the `CustomerMenu` test within the directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the `phpunit` command, we should see our test being picked up
    and executed alongside other tests. We can even target these two tests specifically
    by executing a `phpunit` command with full class path, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The auto-generate CRUD tool generated the `CustomerControllerTest.php` file
    for us within the `src/Foggyline/CustomerBundle/Tests/Controller/` directory.
    In the previous chapter we showed how to pass an authentication parameter to `static::createClient`
    in order to make it simulate user logging. However, that is not the same login
    as our customers will be using. We are no longer using a basic HTTP authentication,
    rather a full blown login form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to address the login form testing, let''s go ahead and edit the `src/Foggyline/CustomerBundle/Tests/Controller/CustomerControllerTest.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here we first created the `logIn` method, whose purpose is to simulate the login,
    by setting up the proper token value into the session, and passing on that session
    ID to the client via a cookie. We then created the `testMyAccountAccess` method,
    which first calls the `logIn` method and then checks if the crawler was able to
    access the **My Account** page. The great thing about this approach is that we
    did not have to code in the user password, only its username.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and address the customer registration form, by adding
    the following to the `CustomerControllerTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen a test similar to this one in the previous chapter. Here
    we are merely opening a customer/register page, then finding a button with **Register!**
    label, so we can fetch the entire form through it. We then set all of the required
    form data, and simulate the form submit. If successful, we observe for the redirect
    body and assert against value expected in it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the `phpunit` command now should successfully execute our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter we built a miniature but functional customer module.
    The module assumed a certain level of setup done on our `security.yml` file, which
    can be covered as part of module documentation if we were to redistribute it.
    These changes included defining our own custom firewall, with a custom security
    provider. The security provider pointed to our `customer` class, which in turn
    was built in a way that complies to the Symfony `UserInterface`. We then built
    a register, login, and forgot your password form. Though each comes with a minimal
    set of functionalities, we saw how simple it is to build a fully custom register
    and login system.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we applied some forward thinking, by using the specially defined
    service to set up the **My Orders** section under the **My Account** page. This
    is by far the ideal way of doing it, and it serves a purpose, as we will later
    override this service cleanly from the `sales` module.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will build a `payment` module.
  prefs: []
  type: TYPE_NORMAL
