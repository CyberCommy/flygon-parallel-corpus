- en: Chapter 5. Using Widgets and Toolbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a GIS web application developer, you want to focus on building a functionality
    specific to the application you are constructing. Spending valuable time and effort
    adding basic GIS functions such as zooming and panning to your application detracts
    from what should be your primary focus. Many applications also need to add an
    overview map, legend, or scale bar to be added to the user interface. Fortunately,
    the API provides user interface widgets that you can drop directly into your application
    and with a little configuration, they are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: The ArcGIS API for JavaScript also includes helper classes to add the navigation
    and drawing toolbars to your application. In this chapter, you'll learn how easy
    it is to add these user interface components to an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by examining a navigation sample that Esri has placed on their
    resource center website. Open a web browser and go to [http://developers.arcgis.com/en/javascript/samples/toolbar_draw/](http://developers.arcgis.com/en/javascript/samples/toolbar_draw/).
    Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Widgets and Toolbars](graphics/7965OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At first glance over the preceding screenshot, you'd think that the drawing
    toolbar is simply a user interface component that you drop into your application,
    which is not exactly the case. The ArcGIS API for JavaScript provides a toolbar
    helper class called `esri/toolbars/Draw` to assist in accomplishing this task.
    In addition, the API also provides a class to handle navigation tasks. What these
    helper classes do is save you the work of drawing zoom boxes, capturing mouse
    clicks, and other user-initiated events. As any experienced GIS web developer
    can tell you, this is no small accomplishment. Adding these basic navigation capabilities
    into the helper classes provided with the API can easily save hours of development
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding toolbars to an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding toolbars to an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two basic types of toolbars that you can add to your application using
    the helper classes, `Navigation` and `Draw`, provided by the API. There is also
    an editing toolbar that can be used to edit features or graphics through a web
    browser. We'll discuss this toolbar in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Steps for creating a toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Navigation** and **Draw** toolbars are not simply user interface components
    that you can drop into your application. They are helper classes and there are
    several steps that you need to take to actually create your toolbar with the appropriate
    buttons. This to-do list for your toolbars may seem a little intimidating, but
    after you do it once or twice, it becomes pretty simple. The following are the
    steps to do this, and we''ll discuss each item in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the CSS styles for each button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the buttons inside the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of `esri/toolbars/Navigation` or `esri/toolbars/Draw`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect button events to handler functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining CSS styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing you'll need to do is define the CSS styles for each button that
    you intend to include on the toolbar. Each button on your toolbar will need an
    image, text, or both, along with the width and height for the button. Each of
    these properties are defined within the CSS inside a `<style>` tag as seen in
    the following code snippet. In the code example shown in the following code snippet,
    a number of buttons are being defined for the `Navigation` toolbar. Let's examine
    the **Zoom Out** button and follow it through the entire process to make things
    a little simpler. I've highlighted the **Zoom Out** button in the following code.
    As with all the other buttons, we define an image to be used for the button (`nav_zoomout.png`)
    along with the width and height of the button. In addition, the identifier for
    this style is defined as `.zoomoutIcon`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The buttons can to be defined inside a `<div>` container with `data-dojo-type`
    of the `ContentPane` dijit inside `BorderContainer`, as shown in the following
    code example. When creating each button, you will need to define the CSS style
    it should reference and what should happen when the button is clicked. The buttons
    use the `iconClass` attribute to reference a CSS style. In the case of the **Zoom
    Out** button in our example, the `iconClass` attribute references `zoomoutIcon`,
    which is a style we defined earlier. The `zoomoutIcon` style defines an image
    to use for the button along with a width and height for the button. Take a look
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block defines the buttons on the toolbar. Each button is
    created using a `Button` user interface control provided by Dijit (a subproject
    of Dojo). Each control is enclosed within a `<button>` tag inside the `<body>`
    tag of the web page with all the buttons being enclosed by the surrounding the
    `<div>` tag that contains the `ContentPane` dijit.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instance of the Navigation toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the visual interface for the buttons is complete, we need to create
    an instance of `esri/toolbars/Navigation` and wire up the events and event handlers.
    Creating an instance of the `Navigation` class is as easy as calling the constructor
    and passing in a reference to `Map` as you''ll see shortly. However, you''ll first
    want to make sure that you add a reference to `esri/toolbars/navigation`. The
    following code example adds references to the `Navigation` toolbar, creates the
    toolbar, connects click events to the buttons, and activates the tools. The relevant
    lines of code have been highlighted and commented so that you understand each
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, the previous `Navigation` toolbar example has illustrated the steps
    to add a navigation toolbar to your web mapping application through the JavaScript
    API. You no longer have to be concerned with adding in JavaScript code to draw
    and handle the extent rectangle or capture mouse coordinates for a pan operation.
    In addition, the user interface components of the toolbar can be created easily
    through various user interface controls supplied by the Dijit library. The `Draw`
    class makes it equally easy to support the drawing of geometries such as points,
    lines, and polygons within a similar toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: User interface widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API for JavaScript comes with many out of the box widgets that you can drop
    into your application for enhanced productivity. Included are the `BasemapGallery`,
    `Bookmarks`, `Print`, `Geocoder`, `Gauge`, `Measurement`, `Popup`, `Legend`, `Scalebar`,
    `OverviewMap`, `Editor`, `Directions`, `HistogramTimeSlider`, `HomeButton`, `LayerSwipe`,
    `LocateButton`, `TimeSlider`, and `Analysis` widgets. Widgets differ from the
    buttons and tools you create as part of the `Navigation` or `Draw` toolbars we
    discussed earlier. These widgets are out of the box functionalities that you can
    drop into your application with just a few lines of code as opposed to the toolbars,
    which were just helper classes that require a fair amount of HTML, CSS, and JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The BasemapGallery widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BasemapGallery` widget displays a collection of basemaps from [ArcGIS.com](http://ArcGIS.com)
    and/or a user-defined set of map or image services. When a basemap is selected
    from the collection, the current basemap is removed and the newly selected basemap
    appears. When adding custom maps to the basemap gallery, they will need to have
    the same spatial reference as the other layers in the gallery. When using layers
    from [ArcGIS.com](http://ArcGIS.com), this would be the Web Mercator reference
    with wkids 102100, 102113, or 3857 (well known IDs or 'wkids' are unique identifiers
    for a spatial reference system). It is also recommended that all basemaps be tiled
    layers for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: '![The BasemapGallery widget](graphics/7965OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When creating a `BasemapGallery` widget, there are a number of parameters that
    you can supply in the constructor as shown in the preceding screenshot, which
    include the ability to show ArcGIS basemaps, define one or more custom basemaps
    for inclusion in the gallery, supply a Bing maps key and a reference to the map
    where the gallery will be placed, and so on. After creating the `BasemapGallery`
    widget, you need to call the `startup()` method to prepare it for user interaction.
    Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, a new `Basemap` object is created with a title,
    thumbnail image, and an array containing a single layer. This `Basemap` object
    is then pushed into an array of basemaps that will be added to the widget.
  prefs: []
  type: TYPE_NORMAL
- en: The Bookmarks widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Bookmarks` widget is used to display a set of named geographic extents
    to the end user. Clicking on a bookmark name from the widget will automatically
    set the extent of the map to the extent provided for the bookmark. Using the widget,
    you can add new bookmarks, delete existing bookmarks, and update bookmarks. Bookmarks
    are defined in JavaScript code as JSON objects with properties that define the
    name, extent, and bounding coordinates of the bookmark. To add a bookmark to the
    widget, you call `Bookmark.addBookmark()`. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Bookmarks widget](graphics/7965OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code example, a new `Bookmarks` object is created. It is attached
    to the map and a list of bookmarks in the JSON format is added.
  prefs: []
  type: TYPE_NORMAL
- en: The Print widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Print` widget is a much-welcomed tool, which simplifies printing maps
    from web applications. It uses a default or user-defined layout for the map. This
    widget does require the use of an ArcGIS Server 10.1 or higher export web map
    task. Take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Print widget](graphics/7965OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code example, a new `Print` widget is created. The URL property
    is used to point the widget to a **Print** task and the widget is attached to
    a HTML element on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The Geocoder widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Geocoder` widget allows you to easily add geocoding functionality to your
    application. This widget includes a single textbox that autofilters results as
    the end user begins typing in an address. Autocompletion is enabled by setting
    the `autoComplete` property to `true`. By default, the `Geocoder` widget uses
    the ESRI World Locator service. You can change this by setting the `geocoder`
    property. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Geocoder widget](graphics/7965OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also automatically append values to any string that the user enters.
    For example, in a local application, you might want to always append a specific
    city and state to any address entered. This is done through the `suffix` property.
    To enable the map to display the location of the geocoded address, you can set
    `autoNavigate` to `true`. It is certainly possible for more than one potential
    location to be returned from Locator. You can set a maximum number of returned
    locations by setting the `maxLocations` property. In the practice exercise coming
    up in the next section, you'll learn how to add the `Geocoder` widget to your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Time to practice with the Geocoder widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, you'll learn how to add the `Geocoder` widget to an application.
  prefs: []
  type: TYPE_NORMAL
- en: Open the ArcGIS API for JavaScript Sandbox available at [http://developers.arcgis.com/en/javascript/sandbox/sandbox.html](http://developers.arcgis.com/en/javascript/sandbox/sandbox.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter the `<style>` tag so that it appears as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the JavaScript content from the `<script>` tag, highlighted as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You already have a `<div>` container for the map. In this step, you''ll create
    a second `<div>` tag that will serve as the container for the `Geocoding` widget.
    Add the container for the widget as shown in the following highlighted code. Make
    sure you give the `<div>` tag a particular `id` of `search`. This corresponds
    to the CSS styling we defined at the top of the file and highlighted in the following
    code snippet. It connects the HTML `<div>` tag to the CSS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create variables to hold the map and the `geocoder` object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `<script>` tag, add the `require()` function and create a `Map` object
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the geocoding widget as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to execute the code. You should see something similar
    to the following screenshot. Notice the `Geocoder` widget.![Time to practice with
    the Geocoder widget](graphics/7965OT_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin typing an address for `San Antonio, TX`. You can use `1202 Sand Wedge`
    as a sample. Autocompletion should kick in as you begin typing the address. When
    you see the address, select it from the list. The widget will geocode the address
    and positions the map so that the address is centered on the map, as shown in
    the following screenshot:![Time to practice with the Geocoder widget](graphics/7965OT_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Gauge widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Gauge` widget displays numeric data from `FeatureLayer` or `GraphicsLayer`
    in a semicircular gauge interface. You can define the color for the gauge indicator,
    the field to use for the numeric data that drives the gauge, a label field, a
    layer to reference, a maximum data value, a title, and a lot more. Take a look
    at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Gauge widget](graphics/7965OT_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows the creation of a `Gauge` widget. A number of
    parameters are being passed into the constructor for the gauge, including a caption,
    color, data field, layer, max data value, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The Measurement widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Measurement` widget provides three tools that enable the end user to measure
    the length and area as well as obtain the coordinates of the mouse. Take a look
    at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Measurement widget](graphics/7965OT_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Measurement` widget also allows you to change the units of measurement
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows how to create an instance of the `Measurement`
    widget and add it to the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Popup widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Popup` widget is functionally similar to the default info window in that
    it is used to display attribute information about features or graphics. In fact,
    starting with Version 3.4 of the API, this widget is now the default window for
    displaying attributes instead of the `infoWindow` parameter. However, it also
    contains additional functionalities such as the ability to zoom and highlight
    features, handling of multiple selections, and a button to maximize the window.
    The interface can also be styled using CSS. Please refer to the following screenshot
    as an example of the content that can be displayed in the `Popup` widget.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Popup widget](graphics/7965OT_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Starting with version 3.4, the `Popup` widget supports rendering text in a
    **right-to-left** (**RTL**) orientation to support RTL languages such as Hebrew
    and Arabic. RTL support will automatically apply if the page direction is set
    to RTL using the `dir` attribute. The default value is **left-to-right** (**LTR**).
    Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code example, a JSON `popupOptions` object is created to define
    the symbol and margin of the pop up. This `popupOptions` object is then passed
    into the constructor for the `Popup` object. Finally, the `Popup` object is passed
    into the `infoWindow` parameter, which specifies that the `Popup` object should
    be used as the info window.
  prefs: []
  type: TYPE_NORMAL
- en: The Legend widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Legend` widget displays a label and symbols for some or all the layers
    in the map. It does have the ability to respect scale dependencies so that the
    legend values updates to reflect layer visibility at various scale ranges as you
    zoom in or out of the application. The `Legend` widget supports `ArcGISDynamicMapServiceLayer`,
    `ArcGISTiledMapServiceLayer`, and `FeatureLayer`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Legend widget](graphics/7965OT_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When creating a new instance of the `Legend` widget, you can specify the various
    parameters that control the contents and display characteristics of the legend.
    The `arrangement` parameter can be used to specify the alignment of the legend
    within its container HTML element and can be defined as alignment left or right.
    The `autoUpdate` property can be set to `true` or `false` and if `true`, the legend
    will automatically update its parameters when the map scale changes or layers
    are added or removed from the map. The `layerInfos` parameter is used to specify
    a subset of layers to use in the legend, and `respectCurrentMapScale` can be set
    to `true` to trigger automatic legend updates based on the scale ranges for each
    layer. Finally, you need to call the `startup()` method to display the newly created
    legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows how to create a Legend widget and add it to
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: The OverviewMap widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OverviewMap` widget is used to display the current extent of the main map
    within the context of a larger area. This overview map gets updated each time
    the main map extent changes. The extent of the main map is represented as a rectangle
    in the overview map. This extent rectangle can also be dragged to change the extent
    of the main map.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview map can be displayed in a corner of the main map and also hidden
    from display when not in use. It can also be placed inside a `<div>` element outside
    the main map window or temporarily maximized for easy access to far away areas
    of interest. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The OverviewMap widget](graphics/7965OT_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `OverviewMap` widget takes a number of optional parameters in the constructor
    for the object. These parameters allow you to control features such as where the
    overview map is placed in relation to the main map, the base layer to use for
    the overview map, the fill color for the extent rectangle, the appearance of a
    maximize button, and the initial visibility of the overview map. Take a look at
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example illustrates the creation of an `OverviewMap` widget.
  prefs: []
  type: TYPE_NORMAL
- en: The Scalebar widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Scalebar` widget is used to add a scalebar to the map or a specific HTML
    node. The `Scalebar` widget displays units in either English or metric values.
    As of Version 3.4 of the API, it can show both English and metric values at the
    same time if you set the `scalebarUnits` property to `dual`. You can also control
    scalebar positioning through the `attachTo` parameter. By default, the scalebar
    is positioned in the bottom-left-hand corner of the map. Take a look at the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Scalebar widget](graphics/7965OT_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous code sample illustrates the creation of a `Scalebar` widget with
    the units in English.
  prefs: []
  type: TYPE_NORMAL
- en: The Directions widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Directions` widget makes it easy to calculate directions between two or
    more input locations. The resulting directions, displayed in the following screenshot,
    are displayed with detailed turn-by-turn instructions and an optional map. If
    a map is associated with the widget, the direction''s route and stops are displayed
    on the map. The stops displayed on the map are interactive, so you can click on
    them to display a pop up with stop details or drag the stop to a new location
    to recalculate the route. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Directions widget](graphics/7965OT_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows the creation of a `Directions` object.
  prefs: []
  type: TYPE_NORMAL
- en: The HistogramTimeSlider dijit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HistogramTimeSlider` dijit provides a histogram chart representation of
    data for time-enabled layers on a map. Through the UI, users can temporally control
    the display of data with an extension to the `TimeSlider` widget.
  prefs: []
  type: TYPE_NORMAL
- en: '![The HistogramTimeSlider dijit](graphics/7965OT_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code example, a `HistogramTimeSlider` object is created and
    associated with a map.
  prefs: []
  type: TYPE_NORMAL
- en: The HomeButton widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `HomeButton` widget is simply a button that you can add to your application,
    which returns the map to the initial extent. Take a look at the following screeshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The HomeButton widget](graphics/7965OT_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows the creation of a `HomeButton` widget.
  prefs: []
  type: TYPE_NORMAL
- en: The LocateButton widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LocateButton` widget can be used to find and zoom to the current location
    of the user. This widget uses the Geolocation API to find the user''s current
    location. Once the location is found, the map zooms to that location. The widget
    provides options that allow the developer to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 geolocation position provides options for finding a location such
    as `maximumAge` and `timeout`. The `timeout` property defines the maximum amount
    of time that can be used to determine the location of a device, while the `maximumAge`
    property defines the maximum amount of time before a new location for the device
    is found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to define a custom symbol that will be used to highlight the user's
    current location on the map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scale to zoom to when a location has been found.![The LocateButton widget](graphics/7965OT_05_17.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows how to create an instance of the `LocateButton`
    widget and add it to the map.
  prefs: []
  type: TYPE_NORMAL
- en: The TimeSlider widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TimeSlider` widget is used for visualizing time-enabled layers. The `TimeSlider`
    widget is configured to have two thumbs, so only the data within the time frame
    of the two thumb locations is displayed. The `setThumbIndexes()` method determines
    the initial location of each thumb. In this case, a thumb is added at the initial
    start time and another thumb is positioned one time step higher up. Take a look
    at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TimeSlider widget](graphics/7965OT_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example illustrates how you can create an instance of the
    `TimeSlider` object and set various properties, including the start and end time.
  prefs: []
  type: TYPE_NORMAL
- en: The LayerSwipe widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LayerSwipe` widget provides a simple tool to show a portion of a layer
    or layers at the top of a map. You can easily compare the content of multiple
    layers in a map, using this widget to reveal the contents of layer(s) on the map.
    The widget provides horizontal, vertical, and scope viewing modes.
  prefs: []
  type: TYPE_NORMAL
- en: '![The LayerSwipe widget](graphics/7965OT_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows how to create an instance of `LayerSwipe` and
    add it to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number of new analysis widgets have been introduced with the Version 3.7
    release of the ArcGIS API for JavaScript. The analysis widgets provide access
    to the ArcGIS Spatial Analysis Service, which allows you to perform common spatial
    analyses on your hosted data via the API. The previous screenshot shows part of
    the `SummarizeNearby` widget, which is one of the 12 Analysis widgets. The analysis
    widgets include the following 12 widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnalysisBase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AggregatePoints`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateBuffers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateDriveTimeAreas`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DissolveBoundaries`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EnrichLayer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtractData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindHotSpots`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindNearest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MergeLayers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OverlayLayers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SummarizeNearby`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SummarizeWithin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An [ArcGIS.com](http://ArcGIS.com) subscription is required for the widgets.
    Not only will you need to store data using your [ArcGIS.com](http://ArcGIS.com)
    account, but will also need to sign in to run an analysis job as a credit-based
    service. Executing analysis tasks and hosting feature services are not available
    to personal account users.
  prefs: []
  type: TYPE_NORMAL
- en: Feature editing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple feature editing is supported by the ArcGIS API for JavaScript when working
    against data stored in an enterprise geodatabase format. What this means is that
    your data needs to be stored in an enterprise geodatabase managed by ArcSDE.
  prefs: []
  type: TYPE_NORMAL
- en: Editing works on the concept of "last in wins." For example, if two people are
    editing the same feature in a layer and both submit modifications, the last editor
    to submit changes will overwrite any changes made by the first editor. Obviously,
    this could pose a problem in some cases, so before implementing editing in your
    application, you will need to examine how your data could be affected.
  prefs: []
  type: TYPE_NORMAL
- en: Other characteristics of editing include support for domains and subtypes, template
    style editing, and the ability to edit standalone tables and attachments. To use
    editing options, you will need to use `FeatureService` and `FeatureLayer`. Editing
    requests are submitted to the server using a HTTP post request, which in most
    cases will require the use of a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Editing support includes feature editing, including the creation and deletion
    of simple features, along with the ability to modify features through moves, cuts,
    union, or reshaping. In addition, feature attributes can be edited, documents
    can be attached to features, and comments can be added to features.
  prefs: []
  type: TYPE_NORMAL
- en: Feature service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web editing requires a feature service to provide the symbology and feature
    geometry of your data. The feature service is just a map service with the feature
    access capability enabled. This capability allows the map service to expose feature
    geometries and their symbols in a way that is easy for web applications to use
    and update.
  prefs: []
  type: TYPE_NORMAL
- en: Before you build a web editing application, you need to do some work to create
    a feature service exposing the layers that you want to be edited. This involves
    setting up a map document and optionally defining some templates for editing.
    Templates allow you to preconfigure the symbology and attributes for some commonly
    used feature types. For example, to prepare editing streams, you might configure
    templates for "major rivers", "minor rivers", "streams", and "tributaries." Templates
    are optional, but they make it easy for the end user of the application to create
    common features.
  prefs: []
  type: TYPE_NORMAL
- en: Once your map is completed, you need to publish it to ArcGIS Server with the
    Feature Access capability enabled. This creates REST URLs or endpoints to both
    a map service and a feature service. You will use these URLs to reference the
    services in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Feature services are accessible in the web APIs through a `FeatureLayer` object,
    which we examined earlier in a previous chapter. Feature layers can do a variety
    of things and can reference either map services or feature services. However,
    when you use `FeatureLayer` for editing purposes, you need to reference a feature
    service.
  prefs: []
  type: TYPE_NORMAL
- en: With the editing functionality, your web application tells the `FeatureLayer`
    which attributes have changed and, if applicable, how the geometry has changed.
    The `FeatureLayer` object also displays the updated features after editing. You
    can call the `applyEdits()` method on the feature layer to apply the edits, which
    then commits them to the database.
  prefs: []
  type: TYPE_NORMAL
- en: The editing widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ArcGIS API for JavaScript provides widgets to make it easier for you to
    add editing function to your Web applications. These widgets include `Editor`,
    `TemplatePicker`, `AttributeInspector`, and `AttachmentEditor` widgets. The `Editor`
    widget is the default editing interface and includes everything you need to edit
    a layer, and also allows you to choose the number and types of tools available.
    `TemplatePicker` displays a preconfigured template containing symbols for each
    of the layers in your map document. This template style editing allows your users
    to simply pick a layer and begin editing. The `AttributeInspector` widget provides
    an interface for editing the attributes of features and ensures valid data entry.
    Finally, `AttachmentEditor` associates a downloadable file with a feature. We'll
    examine each of these widgets in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Editor widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Editor` widget, shown in the following screenshot, provides the default
    editing interface included with API. It combines the functionality of the other
    widgets to provide everything that you need for editing a layer. You can choose
    the number and types of tools that are available on the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Editor` widget saves your edits immediately after they are made, for example,
    as soon as you finish drawing a point. If you decide not to use the `Editor` widget,
    you must determine when and how often you want to apply edits. Take a look at
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Editor widget](graphics/7965OT_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following code example, a new `Editor` object is created by passing
    a `params` object into the constructor. The input `params` object is where the
    developer defines the functionality that the editing application will include.
    In this case, only the required options are defined. The required options are
    the map, the feature layers to edit, and the URL to a geometry service. Take a
    look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Editor` widget provides out of the box editing capabilities using an editable
    layer in a Feature Service. It combines the out of the box `TemplatePicker`, `AttachmentEditor`,
    `AttributeInspector`, and `GeometryService` to provide feature and attribute editing.
    For most editing applications, you should take advantage of the `Editor` widget.
    This widget allows you to perform all the functions you see listed in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Editor widget](graphics/7965OT_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the `Editor` widget in your code, you'll need to first load the widget
    using `dojo.require`. Required parameters for creating a new instance of `Editor`
    include a reference to the `Map` object and a geometry service.
  prefs: []
  type: TYPE_NORMAL
- en: The TemplatePicker widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `TemplatePicker` widget displays a preconfigured set of features to the
    user, with each feature symbolizing a layer in the service. Editing is initiated
    very simply by selecting a symbol from the template and then clicking on the map
    to add features. The symbols displayed in the template come from the editing templates
    you defined in the feature service''s source map or the symbols defined in the
    application. `TemplatePicker` can also be used as a simple legend. Take a look
    at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TemplatePicker widget](graphics/7965OT_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code example, a new `TemplatePicker` object is created and attached
    to the `Editor` widget.
  prefs: []
  type: TYPE_NORMAL
- en: The AttributeInspector widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `AttributeInspector` widget, as shown in the following screenshot, provides
    an interface for editing feature attributes over the web. It also ensures that
    the data they enter is valid by matching the input to the expected data type.
    Domains are also supported. For example, if a coded value domain is applied to
    a field, the permitted values appear in a drop-down list, restricting the possibility
    of other values being entered. If a field requires a date value, a calendar appears,
    helping the user to supply a valid date. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AttributeInspector widget](graphics/7965OT_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `AttributeInspector` widget exposes all the available attributes on the
    layer for editing. If you want to restrict the available attributes, you must
    code your own interface for entering and validating values. Take a look at the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code example, an `AttributeInspector` widget is created and
    added to the application. In addition, several event handlers including the attributes
    `change`, `next`, and `delete` are set up to handle various attribute changes.
  prefs: []
  type: TYPE_NORMAL
- en: The AttachmentEditor widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some situations, you may want to associate a downloadable file with a feature.
    For example, you might want users to be able to click on a feature representing
    a water meter and see a link to an image of the meter. In the ArcGIS Web APIs,
    such an associated downloadable file is known as a feature attachment.
  prefs: []
  type: TYPE_NORMAL
- en: The `AttachmentEditor` widget, as seen in the following screenshot, is a widget
    that helps users upload and view feature attachments. The `AttachmentEditor` widget
    includes a list of current attachments (with a **Remove** button), as well as
    a **Browse** button that can be used to upload more attachments. The `AttachmentEditor`
    widget works well inside an info window, but can be placed elsewhere on the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![The AttachmentEditor widget](graphics/7965OT_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to use feature attachments, attachments must be enabled on the source
    feature class. You can enable attachments for a feature class in ArcCatalog or
    the **Catalog** window in ArcMap. If the `Editor` widget detects that attachments
    are enabled, it will include `AttachmentEditor`. Take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The previous code shows how to create an `AttachmentEditor` object and add it
    to the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Edit toolbar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There may be times when you don''t want to use the default `Editor` widget
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Edit toolbar](graphics/7965OT_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These situations would include times where you want to code your own editing
    logic, particularly with regards to the client side display of features and graphics.
    You can use the **Edit** toolbar in these cases. The **Edit** toolbar is simply
    a JavaScript helper class that is part of the API. It helps with placing and moving
    vertices and graphics. This toolbar is similar to the **Navigation** and **Draw**
    toolbars that we examined earlier in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Widgets and toolbars provide an easy way to add prebuilt functionalities to
    your application without having to write a lot of code. The wide array of available
    widgets has increased throughout the various releases of the API, and it is expected
    that many new widgets will be available in future releases. Toolbars, though similar
    to widgets, are helper classes that provide the functionality for adding navigation,
    drawing functionality, and editing tools to your application. However, it is up
    to the developer to define the appearance of the toolbars and buttons. In the
    next chapter, you will learn how to create spatial and attribute queries using
    the `Query` and `QueryTask` classes.
  prefs: []
  type: TYPE_NORMAL
