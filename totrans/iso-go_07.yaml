- en: The Isomorphic Web Form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we focused on how we could have the server-side application
    handoff data to the client-side application to seamlessly maintain state while
    implementing the shopping cart feature. In [Chapter 6](5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml),
    *Isomorphic Handoff*, we treated the server, as the single source of truth. The
    server dictated, to the client, what the current state of the shopping cart was.
    In this chapter, we are going to go beyond the simple user interactions that we
    have considered thus far and step into the realm of accepting user-generated data
    submitted through an isomorphic web form.
  prefs: []
  type: TYPE_NORMAL
- en: This signifies that now, the client has a voice, to dictate the user-generated
    data that should be stored on the server, within good reason of course (validation
    of user-submitted data). Using an isomorphic web form, validation logic can be
    shared across environments. The client-side application can chip in and inform
    the user that they've made a mistake prior to the form data being submitted to
    the server. The server-side application has the ultimate veto power because it
    will rerun the validation logic on the server side (where, ostensibly, the validation
    logic can't be tampered with) and process the user-generated data only upon a
    successful validation result.
  prefs: []
  type: TYPE_NORMAL
- en: Besides providing the ability to share validation logic and form structure,
    isomorphic web forms also provide a means to make forms more accessible. We must
    address accessibility concerns for web clients that may not have a JavaScript
    runtime or may have the JavaScript runtime disabled. To accomplish this goal,
    we will build an isomorphic web form for the contact section of IGWEB, with progressive
    enhancement in mind. This means that only after implementing form functionality
    to satisfy the bare-minimum, JavaScript-disabled web client scenario, we will
    proceed to implement the client-side form validation that runs directly within
    a JavaScript equipped web browser.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we'll have a robust, isomorphic web form, implemented
    in a single language (Go), which will reuse common code across environments. Most
    importantly, the isomorphic web form will be accessible to the most stripped down
    web client running in a terminal window, and at the same time, accessible to the
    GUI-based web client with the latest JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the form flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the contact form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating email address syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the contact form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The accessible contact form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact form Rest API Endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the client-side validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the form flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 7.1* depicts an image showing the web form with only server-side validation
    in place. The form is submitted to the web server through an HTTP Post request.
    The server provides a fully rendered web page response. If the user did not fill
    out the form properly, errors will be populated and displayed in the web page
    response. If the user did fill out the form properly, a HTTP redirect will be
    made to the confirmation web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10bb8e33-a740-4d65-a97b-553d9d223faf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The web form with server-side validation only'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.2* depicts an image showing the web form with both client-side and
    server-side validation in place. When the user submits the web form, the data
    in the form is validated using client-side validation. The form data will be submitted
    to the web server using an XHR call to a Rest API endpoint, only upon a successful
    client-side validation result. Once the form data has been submitted to the server,
    it will undergo a second round of server-side validation. This ensures the quality
    of the form data even in a scenario where the client-side validation may have
    been tampered with. The client-side application will inspect the form validation
    result returned from the server and will either display the confirmation page
    upon a successful form submission or will display the contact form errors, upon
    an unsuccessful form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4decea16-9af6-4ee1-ac9d-937cceaca898.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The web form validated on both the client-side and the server-side'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the contact form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The contact form will allow website users to get in touch with the IGWEB team.
    Successfully completing the contact form will result in a contact form submission
    containing the user-generated form data that will be persisted in the Redis database.
    *Figure 7.3* is the wireframe image depicting the contact form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6496bb6-b9b3-45f6-b271-c3464d1e1269.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Wireframe design of the contact form'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.4* is the wireframe image depicting the contact form with form errors
    displayed when the user has not filled out the form properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1bdc574-a9e3-4078-a195-bb5eff1ff568.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Wireframe design of the contact form, with error messages displayed'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.5* is the wireframe image depicting the confirmation page that will
    be displayed to the user upon a successful contact form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/365ab4bf-f5c3-4ec6-88c3-a0416dad30fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Wireframe design of the confirmation page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The contact form will solicit the following required information from the user:
    their first name, their last name, their email address, and their message to the
    team. If the user has not filled out any of these fields, upon hitting the Contact button
    on the form, the user will receive field-specific error messages, indicating the
    fields that have not been filled out.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When rendering the Contact page from the server-side, we will use the `contact_page` template
    (found in the `shared/templates/contact_page.tmpl` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Recall that because we include the `layouts/webpage_layout` template, and this
    will print the markup that generates the `doctype`, `html`, and `body` tags of
    the page. This template will be used exclusively on the server-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `define` template action, we demarcate the `"pagecontent"` block,
    where the content of the contact page will be rendered. The content of the contact
    page is defined inside the `contact_content` template (found in the `shared/template/contact_content.tmpl` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Recall that in addition to the server-side application, the client-side application
    will be using the `contact_content` template to render the contact form in the
    primary content area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `contact_content` template, we include the contact form partial
    template (`partials/contactform_partial`) that contains the markup for the contact
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This partial template contains the HTML markup necessary to implement the wireframe
    design depicted in *Figure 7.3*. The template actions that access the form field
    values and their corresponding errors are shown in bold. The reason that we populate
    the `value` attribute for a given `input` field is in case the user makes a mistake
    filling out the form, these values will be prepopulated with the values the user
    entered in the previous form submission attempt. There is a `<span>` tag directly
    after each `input` field, which will house the corresponding error message for
    that particular field.
  prefs: []
  type: TYPE_NORMAL
- en: The very last `<input>` tag is a `submit` button. By clicking this button, the
    user will be able to submit the form contents to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Validating email address syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the basic requirement that all fields must be filled out, the
    email address field must be a properly formatted email address. If the user fails
    to provide a properly formatted email address, a field-specific error message
    will inform the user that the email address syntax is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using the `EmailSyntax` function from the `validate` package found
    within the `shared` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Recall that because the `validate` package is strategically placed in the `shared`
    folder, the package is meant to be isomorphic (used across environments). The
    job of the `EmailSyntax` function is to determine if an input string is a valid
    email address or not. If the email address is valid, the function will return
    `true` or the function will return `false` if the input string isn't a valid email
    address.
  prefs: []
  type: TYPE_NORMAL
- en: The form interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An isomorphic web form implements the `Form` interface found in the `isokit`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Validate` method determines if the form has been filled out properly or
    not, returning a Boolean value of `true` if the form has been filled out properly,
    and it returns a Boolean value of `false` if the form hasn't been filled out properly.
  prefs: []
  type: TYPE_NORMAL
- en: The `Fields` method returns `map` of all the form fields where the key is the
    name of the form field, and the value is the string value of the form field.
  prefs: []
  type: TYPE_NORMAL
- en: The `Errors` method contains `map` of all the errors that were populated upon
    validation of the form. The key is the name of the form field, and the value is
    a descriptive error message.
  prefs: []
  type: TYPE_NORMAL
- en: The `FormParams` method returns the form's isomorphic form parameters object.
    The form parameters object is important because it determines the source from
    where user entered values for the form fields can be obtained. On the server side,
    form field values are obtained from `*http.Request` and on the client-side, form
    fields are obtained from the `FormElement` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `FormParams` struct looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `PrefillFields` method returns a string slice of all the names of the form
    fields, whose values should be retained in case the user makes a mistake while
    submitting the form.
  prefs: []
  type: TYPE_NORMAL
- en: The last four getter methods considered, `Fields`, `Errors`, `FormParams`, and `PrefillFields`,
    have corresponding settter methods, `SetFields`, `SetErrors`, `SetFormParams`,
    and `SetPrefillFields`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the contact form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know what the form interface looks like, let''s start implementing
    the contact form. In our import grouping, note that we include the validate package
    and the `isokit` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Recall that we need to import the validate package for the email address validation
    functionality using the `EmailSyntax` function defined in the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the functionality needed to implement the `Form` interface that we
    covered earlier is provided by the `BasicForm` type, also found in the `isokit`
    package. We will type embed the type `BasicForm` into the type definition of our
    `ContactForm struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By doing so, most of the functionality to implement the `Form` interface is
    provided to us for free. It is imperative on us though to implement the `Validate`
    method because the default `Validate` method implementation, found in the `BasicForm`
    type, will always return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor function for the contact form accepts a `FormParams` struct
    and will return a pointer to a newly created `ContactForm` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We create a string slice, containing the names of the fields that should have
    their values retained, in the `prefillFields` variable. We create instances of
    type `map[string]string` for both the `fields` variable and the `errors` variable.
    We create a reference to a new `ContactForm` instance and assign it to the variable
    `c`. We call the `SetFields` method of the `ContactForm` instance, `c`, and pass
    the fields variable.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `SetFields` and `SetErrors` methods and pass in `fields` and `errors`
    variables, respectively. We call the `SetFormParams` method of `c` to set the
    form parameters, which were passed into the constructor function. Finally, we
    return the new `ContactForm` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted earlier, the default `Validate` method implementation, found in the
    `BasicForm` type, will always return `false`. Because we are implementing our
    own custom form, the contact form, it is our responsibility to define what a successful
    validation is, and we do so by implementing the `Validate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We first call the `RegenerateErrors` method to clear the current errors that
    are displayed to the user. The functionality for this method is only applicable
    to the client-side application. We will cover this method in more detail when
    we implement the contact form functionality on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `PopulateFields` method to populate the fields `map` of the `ContactForm`
    instance. In case the user had made mistakes filling out the form, this method
    is responsible for prefilling the values that the user had already entered, to
    save them the trouble of having to enter those values again to resubmit the form.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can commence with the form validation. We first check to see
    whether the first name field has been filled out by the user. We use the `FormValue`
    function, found in the `isokit` package, to obtain the user entered value for
    the form field having the name `firstName`. The first argument we pass to the
    `FormValue` function is the contact form's form parameters object, and the second
    value is the name of the form field whose value we wish to obtain, in this case,
    that is the form field with the name `"firstName"`. By checking to see whether
    the user-entered value is an empty string, we can determine whether or not the
    user has entered a value into the field. If they haven't, we call the `SetError`
    method, passing the name of the form field, along with a descriptive error message.
  prefs: []
  type: TYPE_NORMAL
- en: We perform the exact same check, to see if the user has filled out the necessary
    values, for the last name field, the message body, and the email address. If they
    haven't filled out any of these fields, we make calls to the `SetError` method,
    providing the name of the field and a descriptive error message.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the email address, if the user has entered a value for the email
    form field, we perform an additional check on the syntax of the email address
    supplied by the user. We pass the email value entered by the user to the `EmailSyntax`
    function in the validate package. If the email is not a valid syntax, we call
    the `SetError` method, passing in the form field name `"email"`, along with a
    descriptive error message.
  prefs: []
  type: TYPE_NORMAL
- en: As we stated earlier, the `Validate` function returns a Boolean value based
    off of whether the form contains errors or not. We use the if conditional to determine
    If the count of errors is greater than zero, and if it is, that indicates that
    the form has errors, and we return a Boolean value of `false`. If count of errors
    is zero, the flow of control will reach the else block where we return a Boolean
    value of `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've added the contact form, it's time to implement the server-side
    route handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the contact route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start out by adding the routes for the contact form page and the contact
    confirmation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `/contact` route that we have registered, which will be handled
    by the `ContactHandler` function, will accept HTTP requests using both the `GET`
    and the `POST` method. When the contact form is first accessed, it will be through
    a `GET` request to the `/contact` route. When the user submits the contact form,
    they will initiate a `POST` request to the `/contact` route. This explains why
    this route accepts both of these HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: Upon successfully filling out the contact form, the user will be redirected
    to the `/contact-confirmation` route. This is done intentionally to avoid resubmission
    form errors that can occur, when the user attempts to refresh the web page, if
    we had simply printed out a form confirmation message using the `/contact` route
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The contact route handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ContactHandler` is responsible for rendering the contact page on IGWEB,
    where the contact form will reside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare and initialize the `formParams` variable to a newly initialized
    `FormParams` instance, providing the values for the `ResponseWriter` and `Request`
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare and initialize the `contactForm` variable, with a newly created
    `ContactForm` instance, by calling the `NewContactForm` function and passing in
    the reference to the `formParams` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We `switch` on the type of HTTP request method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the case that the HTTP request method is `GET`, we call the `DisplayContactForm`
    function, passing in the `env` object and the `contactForm` object. The `DisplayContactForm`
    function will render the contact form on the contact page.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that the HTTP request method is a `POST`, we validate the contact
    form. Remember that if the `/contact` route is accessed using the `POST` method,
    it is indicative of the user having submitted the contact form to the route. We
    declare and initialize the `validationResult` variable, setting it to the value
    of the result from calling the `Validate` method of the `ContactForm` object,
    `contactForm`.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the `validationResult` is true, the form validated successfully.
    We call the `ProcessContactForm` function in the submissions package, passing
    in the `env` object and the `ContactForm` object. The `ProcessContactForm` function
    is responsible for handling a successful contact form submission. We then call
    the `DisplayConfirmation` function, passing in the `env` object, `http.ResponseWriter`,
    `w`, and `*http.Request`, `r`.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the `validationResult` is `false`, flow of control goes inside
    the `else` block, and we call the `DisplayContactForm` function passing in the
    `env` object and the `ContactForm` object, `contactForm`. This will render the
    contact form again, and this time, the user will see error messages pertaining
    to the fields that were either not filled out or that were not filled out properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that the HTTP request method is neither a `GET` or a `POST`, we
    reach the default condition and simply call the `DisplayContactForm` function
    to display the contact form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `DisplayContactForm` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The function takes in an `env` object and a `ContactForm` object as input arguments.
    We start out by declaring and initializing the variable `templateData`, which
    will serve as the data object that we will be feeding to the `contact_page` template.
    We create a new instance of a `templatedata.Contact` struct and populate its `PageTitle`
    field to `"Contact"`, and its `Form` field to the `ContactForm` object that was
    passed into the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `Contact` struct from the `templatedata` package looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `PageTitle` field represents the page title for the web page, and the `Form`
    field represents the `ContactForm` object.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `Render` method on the `env.TemplateSet` object, and we pass
    in the name of the template we wish to render, `contact_page`, along with the
    isomorphic template render parameters (`RenderParams`) object. We have assigned
    the `Writer` field, of the `RenderParams` object, with the `ResponseWriter` associated
    with the `ContactForm` object, and we have assigned the `Data` field with the
    `templateData` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `DisplayConfirmation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for performing the redirect to the confirmation
    page. In this function, we simply call the `Redirect` function available in the
    `http` package and perform a `302` status redirect to the `/contact-confirmation`
    route.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the route handler for the Contact page, it's time to
    take a look at the route handler for the contact form confirmation web page.
  prefs: []
  type: TYPE_NORMAL
- en: The contact confirmation route handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sole purpose of the `ContactConfirmationHandler` function is to render
    the contact confirmation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We call the `Render` method of the `TemplateSet` object and specify that want
    to render the `contact_confirmation_page` template, along with the passed in `RenderParams`
    struct. We have populated the `Writer` field of the struct with the `http.ResponseWriter`,
    and we have assigned a value of `nil` to the `Data` object, to indicate that there
    is no data object that is to be passed to the template.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the contact form submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upon successful completion of the contact form, we call the `ProcessContactForm`
    function in the `submission` package. If the workflow to fill out the contact
    form were like playing baseball, the call to the `ProcessContactForm` function
    can be considered reaching home plate and scoring a run. As we shall see later
    in the section, *Contact form Rest API endpoint*, this function will also be called
    by the contact form''s Rest API endpoint. Now that we have established the significance
    of this function, let''s go ahead and examine it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We first print out a log message to indicate that we have successfully reached
    the function, indicating that the user has properly filled out the contact form,
    and the user-entered data is worthy to be processed. We then declare and initialize
    the `contactRequest` variable with a newly created `ContactRequest` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the `ContactRequest` struct is to model the data that is collected
    from the contact form. Here''s what the `ContactRequest` struct looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each field in the `ContactRequest` struct corresponds to the
    form field that exists in the contact form. We populate each field in the `ContactRequest`
    struct with its corresponding user-entered value from the contact form by calling
    the `GetFieldValue` method on the contact form object and providing the name of
    the form field.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, a successful contact form submission consists of storing
    the contact request information in the Redis database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `CreateContactRequest` method of our custom Redis datastore object,
    `env.DB`, and pass in the `ContactRequest` object, `contactRequest` to the method.
    This method will save the contact request information into the Redis database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateContactRequest` method accepts a `ContactRequest` object as a sole
    input argument. We JSON marshal the `ContactRequest` value and store it into the
    Redis database. An error object is returned if either the JSON marshaling process
    failed or if saving to the database failed. If there were no errors encountered,
    we return `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: The accessible contact form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have everything in place to take the contact form for a test
    drive. However, instead of opening up the contact form in a GUI-based web browser,
    we're first going to see how accessible the contact form is for visually impaired
    users using the Lynx web browser.
  prefs: []
  type: TYPE_NORMAL
- en: On first impression, it may seem strange that we are test driving the contact
    form using a 25-year-old, text-only web browser. However, Lynx has the capability
    to provide a refreshable braille display, along with text-to-speech functionality,
    which has made it a commendable web browsing technology for the visually impaired.
    Because Lynx does not support displaying images and running JavaScript, we can
    get a good idea of how the contact form will hold up for users that need greater
    accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Homebrew on your Mac, you can easily install Lynx like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Ubuntu, you can install Lynx by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Windows, you can download Lynx from this web page: [http://lynx.invisible-island.net/lynx2.8.8/index.html](http://lynx.invisible-island.net/lynx2.8.8/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the Lynx web browser on Wikipedia at [https://en.wikipedia.org/wiki/Lynx_(web_browser)](https://en.wikipedia.org/wiki/Lynx_(web_browser)).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `igweb` web server instance running, we start up lynx using the `--nocolor`
    option like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 7.6* shows what the contact form looks like in the Lynx web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aca3054b-b49a-4d85-8e0b-8615390a58de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: The contact form in the Lynx web browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to partially fill out the contact form, on purpose to test
    if the form validation logic is working. In the case of the email field, we will
    provide an improperly formatted email address, as shown in *Figure 7.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77416de7-79e3-418c-b45b-cbb788fb5479.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: The contact form filled out improperly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon hitting the Contact button, note that we get error messages that pertain
    to the fields that have not been filled out properly, as shown in *Figure 7.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33ca6e78-e8e4-45a4-b797-75997ac4d45f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Error messages are displayed for the email address field and the
    message text area'
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we received the error message telling us that the email address
    format is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.9* shows what the contact form looks like after we have corrected
    all the errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e251ed95-8f60-4bce-a765-e70fdac4e943.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The contact form filled out properly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon submitting the corrected contact form, we see the confirmation message,
    informing us that we have successfully filled out the contact form, as shown in
    *Figure 7.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e061a763-d5c7-4fa5-871a-8026e37e2c1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: The confirmation page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the Redis database, using the redis-cli command, we can verify that
    we received the form submission, as shown in *Figure 7.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ffb7e74-e596-4036-bb0b-0880aeca7ae1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Verification of a newly stored contact request entry in the Redis
    database'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can be satisfied knowing that we've made our contact form
    accessible for visually impaired users and it didn't take much effort on our part.
    Let's take a look at how the contact form looks in a GUI-based web browser with
    JavaScript disabled.
  prefs: []
  type: TYPE_NORMAL
- en: The contact form can function without JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Safari web browser, we may disable JavaScript, by choosing the Disable
    JavaScript option in Safari''s Develop menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa350d78-e4b2-4a08-8635-92a42f3d45e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Disabling JavaScript using Safari''s develop menu'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.13* shows what the contact form looks like in the **Graphical User
    Interface** (**GUI**)-based web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/442aef8b-1adc-467b-944c-d6c77989cba5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: The contact form in a GUI-based web browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'We follow the same testing strategy that we performed on the Lynx web browser.
    We partially fill out the form and supply an invalid email address, as shown in
    *Figure 7.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf094d58-b72a-4c86-89d3-a817729357c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: The contact form filled out improperly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon hitting the Contact button, the error messages are displayed next to the
    fields with issues, as shown in *Figure 7.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a5811f1-53f5-4575-a008-d21b9623dbbe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Error messages are displayed next to fields with issues'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon submitting the contact form, note that we get errors pertaining to the
    improperly filled out fields. After correcting the errors, we are now ready to
    hit the Contact button to submit the form again, as shown in *Figure 7.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e7c59e6-71c5-4980-a186-89aa445d881b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: The properly filled out contact form ready for resubmission'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon submitting the contact form, we get forwarded to the `/contact-confirmation`
    route, and we receive the confirmation message that the contact form has been
    filled out properly, as shown in *Figure 7.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a27ce314-b179-4a48-86d3-6480020ac679.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: The confirmation page'
  prefs: []
  type: TYPE_NORMAL
- en: The server-side-based contact form that we have implemented will continue to
    function even with JavaScript enabled. You might be wondering why do we need to
    implement the contact form on the client-side? Couldn't we just solely use the
    server-side-based contact form and call it a day?
  prefs: []
  type: TYPE_NORMAL
- en: The answer boils down to providing the user with an enhanced user experience.
    By solely using the server-side contact form, we break the single page application
    architecture that the user is experiencing. The astute reader will recognize that
    it takes a full page reload to submit the form and resubmit the form if there
    were errors. The HTTP redirect to the `/contact-confirmation` route will also
    break the user experience because it will also cause a full page reload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two objectives need to be fulfilled, in order to implement the
    contact form on the client-side:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a consistent, seamless single-page application experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the ability to validate the contact form on the client-side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first objective, providing a consistent, seamless single-page application
    experience, is easily done using the isomorphic template set to render content
    to the primary content area `div` container as we had shown in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The second objective, the ability to validate the contact form on the client
    side, is possible, since the web browser has JavaScript enabled. With this capability,
    we can validate the contact form on the client side itself. Consider the scenario,
    where we have a user, that keeps making mistakes while filling out the contact
    form. We can lessen the amount of unnecessary network calls that are made to the
    web server. Only after the user has gotten past the first round of validation
    (on the client-side), will the form be submitted over the network, to the web
    server, where it undergoes the final round of validation (on the server side).
  prefs: []
  type: TYPE_NORMAL
- en: Client-side considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Amazingly enough, there isn''t much work that we need to perform to get the
    contact form going on the client side. Let''s examine the `contact.go` source
    file found in the `client/handlers` folder, section by section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is our `ContactHandler` function, which will service the needs of the `/contact`
    route on the client side. We start off by declaring and initializing the `contactForm`
    variable, assigning it to the `ContactForm` instance that is returned by calling
    the `NewContactForm` constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we pass `nil` to the constructor function, when we should normally
    be passing a `FormParams` struct. On the client side, we would populate the `FormElement`
    field of the `FormParams` struct to associate the form element on the web page
    to the `contactForm` object. However, prior to rendering the web page, we run
    into a *did the chicken come before the egg* scenario. We can't populate the `FormElement`
    field of the `FormParams` struct because a form element doesn't exist on the web
    page yet. So, our first order of business is to render the contact form, and for
    the time being, we will set the contact form's `FormParams` struct to `nil` in
    order to do so. Later on, we will set the `contactForm` object's `FormParams`
    struct using the `contactForm` object's `SetFormParams` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the contact form on the web page, we call the `DisplayContactForm`
    function passing in the `env` object and the `contactForm` object, `contactForm`.
    This function is instrumental in our first objective to preserve the seamless
    single-page application user experience. Here''s what the `DisplayContactForm`
    function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We declare and initialize the `templateData` variable, which will be the data
    object that we pass to the template. The `templateData` variable is assigned with
    a newly created `Contact` instance from the `templatedata` package, having a `PageTitle`
    property set to `"Contact"` and the `Form` property set to the `contactForm` object.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `Render` method of the `env.TemplateSet` object and specify that
    we wish to render the `"contact_content"` template. We also supply the isomorphic
    render parameters (`RenderParams`) to the `Render` method, setting the `Data`
    field equal to the `templateData` variable, and we set the `Disposition` field
    to `isokit.PlacementReplaceInnerContents,` which declares how we will render the
    template content relative to an associated element. By setting the `Element` field
    to `env.PrimaryContent`, we specify that the primary content `div` container will
    be the associated element that the template will be rendering to. Finally, we
    set the `PageTitle` property to dynamically change the web page's title as the
    user lands on the `/contact` route from the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `InitializeContactPage` function, supplying the `env` object and
    the `contactForm` object. Recall that the `InitializeContactPage` function is
    responsible for setting up the user interactivity-related code (event handlers)
    for the Contact page. Let''s examine the `InitializeContactPage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We call the `GetElementByID` method on the `env.Document` object to fetch the
    contact form element and assign it to the variable `formElement`. We call the
    `SetFormParams` method, supplying a `FormParams` struct and populating its `FormElement`
    field with the `formElement` variable. At this point, we have set the form parameters
    for the `contactForm` object. We obtain the contact form's `button` element by
    calling the `GetElementByID` method on the `env.Document` object and supplying
    an `id` of `"contactButton"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add an event listener, on the click event of the contact `button`, which
    will call the `handleContactButtonClickEvent` function and pass the `env` object,
    the `event` object, and the `contactForm` object. The `handleContactButtonClickEvent`
    function is significant because it will run the form validation on the client-side,
    and if the validation is successful, it will initiate an XHR call to a Rest API
    endpoint on the server-side. Here''s the code for the `handleContactButtonClickEvent`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that we do is suppress the default behavior of clicking the
    Contact button, which will submit the entire web form. This default behavior stems
    from the fact that the contact `button` element is an `input` element of type
    `submit`, whose default behavior when clicked is to submit the web form.
  prefs: []
  type: TYPE_NORMAL
- en: We then declare and initialize `clientSideValidationResult`, a Boolean variable,
    assigned to the result of calling the `Validate` method on the `contactForm` object.
    If the value of `clientSideValidationResult` is `false`, we reach the `else` block
    where we call the `DisplayErrors` method on the `contactForm` object. The `DisplayErrors`
    method is provided to us from the `BasicForm` type in the `isokit` package.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the `clientSideValidationResult` is true, that means the form
    validated properly on the client side. At this point, the contact form submission
    has cleared the first round of validation on the client-side.
  prefs: []
  type: TYPE_NORMAL
- en: To commence the second (and final) round of validation, we need to call the
    Rest API endpoint on the server-side, which is responsible for validating the
    contents of the form and rerun the same set of validations. We create a channel
    named `contactFormErrorsChannel`, which is channel that we'll send `map[string]string`
    values over. We call the `ContactFormSubmissionRequest` function as a goroutine,
    passing in the channel `contactFormErrorsChannel` and the `contactForm` object.
    The `ContactFormSubmissionRequest` function will initiate an XHR call to the server-side
    Rest API endpoint, to validate the contact form on the server-side. A `map` of
    errors will be sent over `contactFormErrorsChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the `ContactFormSubmissionRequest` function before
    we return to the `handleContactButtonClickEvent` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `ContactFormSubmissionRequest` function, we JSON marshal the fields of
    the `contactForm` object and fire an XHR call to the web server by calling the
    `Send` function from the `xhr` package. We specify that the XHR call will be using
    the `POST` HTTP Method and will be posting to the `/restapi/contact-form` endpoint.
    We pass in the JSON-encoded data of the contact form fields as the final argument
    to the `Send` function.
  prefs: []
  type: TYPE_NORMAL
- en: If there were no errors in either the JSON marshaling process, or while making
    the XHR call, we obtain the data retrieved from the server and attempt to decode
    it from JSON format into the `contactFormErrors` variable. We then send the `contactFormErrors`
    variable over the channel, `contactFormErrorsChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s return back to the `handleContactButtonClickEvent` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To prevent blocking within the event handler, we create and run an anonymous
    goroutine function. We receive the `map` of errors into the `serverContactFormErrors`
    variable, from `contactFormErrorsChannel`. The `serverSideValidationResult` Boolean
    variable is responsible for determining if there were errors in the contact form
    by examining the length of the errors `map`. If the length of the errors is zero
    that indicates there were no errors in the contact form submission. If the length
    is greater than zero that indicates that errors are present in the contact form
    submission.
  prefs: []
  type: TYPE_NORMAL
- en: If the `severSideValidationResult` Boolean variable has a value of `true`, we
    call the `Render` method on the isomorphic template set to render the `contact_confirmation_content`
    template and we pass in the isomorphic template render parameters. In the `RenderParams`
    object, we set the `Data` field to `nil` because we won't be passing in any data
    object to the template. We specify the value `isokit.PlacementReplaceInnerContents`
    for the `Disposition` field to indicate that we will be performing a replace inner
    HTML operation on the associated element. We set the `Element` field to the associated
    element, the primary content `div` container, since this is where the template
    will render to.
  prefs: []
  type: TYPE_NORMAL
- en: If the `serverSideValidationResult` Boolean variable has a value of `false`,
    that means the form still contains errors that need to be corrected. We call the
    `SetErrors` method on the `contactForm` object passing in the `serverContactFormErrors`
    variable. We then call the `DisplayErrors` method on the `contactForm` object
    to display the errors to the user.
  prefs: []
  type: TYPE_NORMAL
- en: We're just about done, the only item we have left to realizing the contact form
    on the client-side is implementing the server-side, Rest API endpoint that performs
    the second round of validation on the contact form submission.
  prefs: []
  type: TYPE_NORMAL
- en: Contact form Rest API endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `igweb.go` source file, we have registered the `/restapi/contact-form`
    endpoint and it''s associated handler function, `ContactFormEndpoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContactFormEndpoint` function is responsible for servicing the `/restapi/contact-form`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this function is to provide server-side validation of the contact-form
    and return a JSON-encoded `map` of errors. We create a variable `fields` of type
    `map[string]string` that represents the fields in the contact form. We read the
    request body, which will contain the JSON-encoded fields `map`. We then unmarshal
    the JSON-encoded fields `map` into the the `fields` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new `FormParams` instance and assign it to the variable `formParams`.
    In the `FormParams` struct, we specify the value of the `http.ResponseWriter`,
    `w`, for the `ResponseWriter` field, and the `*http.Request`, `r`, for the `Request`
    field. We set the `UseFormFieldsForValidation` field to `true`. Doing so will
    change the default behavior of fetching the form value for a particular field
    from the request, and instead the values for form fields will be obtained from
    the contact form's `formFields` `map`. Finally, we set the `FormFields` field
    to the `fields` variable, the `map` of fields that we JSON unmarshalled from the
    request body.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new `contactForm` object by calling the `NewContactForm` function
    and passing in a reference to the `formParams` object. To perform the server-side
    validation, we simply call the `Validate` method on the `contactForm` object and
    assign the result of the method call to the `validationResult` variable. Keep
    in mind that the same validation code present on the client-side is also present
    on the server-side, and there's really nothing special we're doing here, except
    invoking the validation logic from the server-side where presumably it cannot
    be tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of `validationResult` is `true`, that means the contact form has
    cleared the second round of form validation on the server-side, and we can call
    the `ProcessContactForm` function in the `submissions` package, passing in the
    `env` object and the `contactForm` object. Remember when it comes to successfully
    validating the contact form, calling the `ProcessContactForm` function means we've
    reached the home plate and scored a run.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the `validationResult` is `false`, there is nothing special
    that we have to do. The `Errors` field of the `contactForm` object would have
    been populated after making a call to the object's `Validate` method. If there
    were no errors, the `Errors` field would just be an empty `map`.
  prefs: []
  type: TYPE_NORMAL
- en: We send a header to the client to indicate that the server will be sending a
    JSON object response. We then encode the errors `map` of the `contactForm` object
    into its JSON representation and write it out to the client using `http.ResponseWriter`,
    `w`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the client-side validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have everything in place now for the contact form''s client-side validation.
    Let''s open up the web browser with JavaScript enabled. Let''s also have the web
    inspector open to check for network calls, as shown in *Figure 7.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04e8698f-932b-4309-b907-865893dce865.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: The contact form with the web inspector open'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will partially fill out the contact form, as shown in *Figure 7.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3669cae-46e7-40b5-9798-c6bdc4871dd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: The contact form filled out improperly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking on the Contact button, we will trigger the form validation errors
    on the client side, as shown in *Figure 7.20*. Note that as we do so, no network
    calls are made to the server, no matter how many times we click on the Contact
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46be4e96-7be7-489e-a45e-c3c341c622e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: Error messages are displayed after performing client-side validation.
    Note that there are no network calls made to the server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s correct the errors present in the contact form (as shown in *Figure
    7.21*) and get ready to resubmit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9b46ccf-8c67-429b-9be5-f65af141f8d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: The contact form filled out properly and ready for resubmission'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon resubmission of the form, we receive the confirmation message, as shown
    *Figure 7.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cc80308-7acd-4d2f-a7ad-a8a6668cddb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.22: An XHR call is made containing the form data, and the confirmation
    message is rendered upon successful server-side form validation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that an XHR call was initiated to the web server, as shown in *Figure
    7.23*. Examining the response of the call, we can see that the empty object (`{}`)
    returned from the endpoint''s response, indicates that the `errors` `map` is empty,
    signifying a successful form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e687cd4e-0305-4735-aba2-9ba6cdec6b17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: The XHR call responded with an empty errors map, indicating that
    the form successfully cleared the server-side form validation'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have verified that the client-side validation logic is working on
    the contact form, we must emphasize a significant point that is important when
    accepting data from the  client-side. The server must always hold the veto power,
    when it comes to validating user-entered data. The round two validation performed
    on the server-side should be a mandatory step. Let's take a look at why we always
    need server-side validation.
  prefs: []
  type: TYPE_NORMAL
- en: Tampering with the client-side validation result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the scenario, where we have a nefarious (and clever) user who
    knows how to short circuit our client-side validation logic. It''s JavaScript
    after all, and it''s running in the web browser. There''s really nothing to stop
    a malicious user from throwing our client-side validation logic to the wind. To
    simulate such a tampering event, we simply need to assign the Boolean value of
    `true` to the `clientSideValidationResult` variable in the `contact.go` source
    file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have bypassed the real result of the client-side validation,
    and we are forcing the client-side web application to always green light the contact
    form validation performed on the client-side. If we were solely performing form
    validation on the client-side, this would put us in a very bad situation. This
    is exactly the reason why, we need the second round of validation on the server-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up the web browser and partially fill out the form again, as shown
    in *Figure 7.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b39c09da-a4a1-4b4b-85a2-c134c6b018b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: Even after disabling the client-side form validation, the server-side
    form validation prevents the improperly filled out contact form from being submitted'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this time, when the Contact button is clicked, the XHR call is initiated
    to the Rest API endpoint on the server-side, which returns `map` of errors in
    the contact form, as shown in *Figure 7.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c04dd7ed-d608-4d0a-8f1a-08631d008d15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.25: The errors map from the server response is populated with an error
    indicating that the value entered in the email address field has an improper syntax'
  prefs: []
  type: TYPE_NORMAL
- en: The second round of validation, performed on the server-side, has kicked in,
    and it prevented the malicious user from being able to reach home plate and score
    a run. If the client-side validation is unable to properly function, that incomplete
    or incorrectly formatted form field will be caught by the server-side validation.
    This is a major reason, why you should always implement server-side form validation
    for your web forms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we demonstrated the process of building an accessible, isomorphic
    web form. First, we demonstrated the flow of the isomorphic web form in both the
    scenario where JavaScript was disabled and in the scenario where JavaScript was
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: We showed you how to create an isomorphic web form, which had the ability to
    share both form code as well as validation logic across environments. In the scenario
    where the form contained errors, we showed you how to display the errors to the
    user in a meaningful manner. The isomorphic web form created was quite robust
    and being able to function, both, in the scenario where JavaScript was either
    disabled in the web browser, or a JavaScript runtime didn't exist (such as the
    Lynx web browser), and in the scenario where JavaScript was enabled in the web
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated testing the accessible, isomorphic web form using the Lynx web
    browser, to verify that the form would be available to users in need of greater
    accessibility. We also verified that the form functioned properly, even with JavaScript
    disabled, in a web browser that was equipped with a JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenario that JavaScript was enabled in the web browser, we showed you
    how to validate the form on the client-side and submit the data to a Rest API
    endpoint after performing client-side validation. Even with the convenience and
    heightened capability of validating the form on the client-side, we emphasized
    the importance of always validating the form on the server-side, by demonstrating
    a scenario where the server-side form validation kicked in, even in the potential
    scenario that the client-side validation result was tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: The interaction between the user and the contact form was fairly simple. The
    user had to fill out the form correctly in order to submit the data to the server,
    where ultimately the form data was processed. In the next chapter, we are going
    to go beyond this simple interaction and consider a scenario where the user and
    the web application engage in communication, in an almost conversation-like manner.
    In [Chapter 8](38c071ef-d44c-452c-80dd-0b76837cc5e8.xhtml), *Real-time Web Application
    Functionality*, we will implement IGWEB's live chat feature, which allows the
    website user to engage in a simple question and answer conversation with a chatbot.
  prefs: []
  type: TYPE_NORMAL
