- en: Chapter 3. Programming Language Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing query and insert operations with PyMongo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing update and delete operations using PyMongo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing aggregation in Mongo using PyMongo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing MapReduce in Mongo using PyMongo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing query and insert operations using a Java client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing update and delete operations using a Java client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing aggregation in Mongo using a Java client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing MapReduce in Mongo using a Java client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have executed the majority of operations in the shell using Mongo.
    The Mongo shell is a great tool for administrators to perform administrative tasks
    and for developers who would like to quickly test things by querying the data
    before coding the logic in the application. However, how do we write application
    code that will allow us to query, insert, update, and delete (among other things)
    the data in MongoDB? There has to be a library for the programming language that
    we write our application in. We should be able to instantiate something or invoke
    methods from the program to perform some operations on the remote Mongo process.
  prefs: []
  type: TYPE_NORMAL
- en: How would this happen unless there is some bridge that understands the protocol
    of communication with the remote server and is able to transmit the operation
    over the wire that we require in order to execute on the Mongo server process
    and get the result back to the client. This bridge, simply put, is called the
    **driver**, also referred to as client libraries. Drivers form the backbone of
    Mongo's programming language interface; in their absence, it would have been the
    responsibility of the application to communicate with the Mongo server using a
    low-level protocol that the server understands. This would have been a lot of
    work, not only to develop, but also to test and maintain. Though the communication
    protocol is standard, there cannot be one implementation that works for all the
    languages. A variety of programming languages need to have their own implementations
    exposing similar sets of programming interfaces to all the languages. The core
    concepts of client APIs, which we will see in this chapter, holds good for all
    the languages.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mongo has support for all major programming and is supported by MongoDB Inc.
    There is even a huge array of programming languages supported by the community.
    You can take a look at the various platforms supported by Mongo by visiting [http://docs.mongodb.org/ecosystem/drivers/community-supported-drivers/](http://docs.mongodb.org/ecosystem/drivers/community-supported-drivers/).
  prefs: []
  type: TYPE_NORMAL
- en: Executing query and insert operations with PyMongo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is all about executing basic query and `insert` operations using
    PyMongo. This is similar to what we did with the Mongo shell earlier in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute simple queries, we need to have a server up and running. A simple
    single node is what we need. Refer to the *Installing single node MongoDB* recipe
    from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"), *Installing
    and Starting the Server* for instructions on how to start the server. The data
    that we will be operating on needs to be imported in the database. The steps to
    import the data are given in the *Creating test data* recipe from [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. Python 2.7, or higher, has to be present on the host operating system
    along with MongoDB's Python client, PyMongo. Look at the earlier recipe, *Connecting
    to a single node using a Python client*, in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system. Additionally, in this recipe, we will
    execute `insert` operations and provide a write concern to use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with querying for Mongo in the Python shell. This will be identical
    to what we do in the mongo shell except that this is in the Python programming
    language, as opposed to the JavaScript that we have in the mongo shell. We can
    use the basics that we will see here to write big production systems that run
    on Python and use mongo as a data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by starting the Python shell from the operating system''s command
    prompt. All these steps are independent of the host operating system. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following in the shell and the Python shell should start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import the `pymongo` package and create the client as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This works well and achieves the same result. Now that we have the client,
    our next step is to get the database that we will be performing the operations
    on. This is unlike some of the programming languages where we have a `getDatabase()`
    method to get an instance of the database. We will get a reference to the database
    object that we will be performing the operations on, `test` in this case. We will
    do this in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will query the `postalCodes` collection. We will limit our results to 10
    items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over the results. Watch out for the indentation of the print after
    the `for` statement. The following fragment should print 10 documents as returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To find one document, execute the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the `state` and `city` of the returned result as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s query top 10 cities in the state of Gujarat sorted by the name of the
    city and, additionally, we just select the `city`, `state`, and `pincode`. Execute
    the following query in the Python shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding cursor's results can be printed in the same way that we printed
    the results in step 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sort the data that we query. We want to sort in a descending order of
    state and then by ascending order of the city. We will write the query as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Iterating through this cursor should print out five results to the console.
    Refer to step 5 on how we iterate over a cursor returned to print the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, we have played a bit to find documents and covered the basic operations
    in Python as far as the querying of MongoDB is concerned. Now, let''s see a bit
    about the `insert` operation. We will use a test collection to perform these operations
    and not disturb our postal codes test data. We will use a `pymongoTest` collection
    for this purpose and add documents in a loop to it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `insert` can take a list of dictionary objects and perform a bulk insert.
    So now, something similar to the following `insert` is perfectly valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Any guesses on the return value? In case of a single document insert, the return
    value is the value of `_id` for the newly created document. In this case, it is
    a list of IDs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 2, we instantiate the client and get the reference to the `MongoClient`
    object that will be used to access the database. There are a couple of ways to
    get this reference. The first option is more convenient, unless your database
    name has some special character, such as a hyphen (-). For example, if the name
    is `db-test`, we would have no option other than to use the `[]` operator to access
    the database. Using either of the alternatives, we now have an object for the
    test database in the `db` variable. After we get the `client` and `db` instances
    in Python, we query to find the top 10 documents in the natural order from the
    collection in step 3\. The syntax is identical to how this query would have been
    executed in the shell. Step 4 simply prints out the results, 10 of them in this
    case. Generally, if you need instant help on a particular class using the class
    name or an instance of this class from the Python interpreter, simply perform
    `dir(<class_name>)` or `dir(<object of a class>)`, which gives you a list of attributes
    and functions defined in the module passed. For example, `dir('pymongo.MongoClient')`
    or `dir(client)`, where the client is the variable holding reference to an instance
    of `pymongo.MongoClient`, can be used to get the list of all the supported attributes
    and functions. The `help` function is more informative, prints out the module's
    documentation, and is a great source of reference just in case you need instant
    help. Try typing `help('pymongo.MongoClient')` or `help(client)`.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 3 and 4, we query the `postalCodes` collection, limit the result to
    the top 10 results, and print them. The returned object is of a type `pymongo.cursor.Cursor`
    class. The next step gets just one document from the collection using the `find_one()`
    function. This is synonymous to the `findOne()` method on the collection invoked
    in the shell. The value returned by this function is an inbuilt object, `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 6, we execute another `find` to query the data. In step 8, we pass
    two Python dicts. The first dict is the query, similar to the query parameter
    we use in mongo shell. The second dictionary is used to provide the fields to
    be returned in the result. A value, one, for a field indicates that the value
    is to be selected and returned in the result. This is synonymous with the `select`
    statement in a relational database with a few sets of columns provided explicitly
    to be selected. The `_id` field is selected by default unless it is explicitly
    set to zero in the selector `dict` object. The selector provided here is `{''_id'':0,
    ''city'':1, ''state'':1, ''pincode'':1}`, which selects the city, state, and pincode
    and suppresses the `_id` field. We have a sort method as well. This method has
    two formats as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first one is used when we want to sort by one field only. The second representation
    accepts a list of pairs of the sort field and sort directions and is used when
    we want to sort by multiple fields. We used the first form in the query in step
    8 and the second format in our query in step 9 as we sort first by the state `name`
    and then, by `city`.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the way we invoke `sort`, it is invoked on the `Cursor` instance.
    Similarly, the `limit` function is also on the `Cursor` class. The evaluation
    is lazy and deferred until the iteration is performed in order to retrieve the
    results from the cursor. Until this point of time, the `Cursor` object is not
    evaluated on the server.
  prefs: []
  type: TYPE_NORMAL
- en: In step 11, we insert a document 20 times in a collection. Each insert, as we
    can see in the Python shell, will return a generated `_id` field. In terms of
    the syntax of insert, it is exactly identical to the operation that we perform
    in the shell. The parameter passed for the insert is an object of type `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 12, we pass a list of documents to insert in the collection. This is
    referred to as a bulk insert operation, which inserts multiple documents in a
    single call to the server. The return value in this case is a list of IDs, one
    for each document inserted, and the order is the same as those passed in the input
    list. However, as MongoDB doesn't support transactions, each insert will be independent
    of each other, and a failure of one insert doesn't roll back the entire operation
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the functionality of inserting multiple documents demanded another parameter
    for the behavior. When one of the inserts in the list given fails, should the
    remaining inserts continue or the insertion stop as soon as the first error is
    encountered? The name of the parameter to control this behavior is `continue_on_error`
    and its default value is `False`, that is, stop as soon as the first error is
    encountered. If this value is `True` and multiple errors occur during insertion,
    only the latest error will be available, and hence the default option with `False`
    as the value is sensible. Let''s look at a couple of examples. In the Python shell,
    execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The count that we will get is `1`, which is for the first document with the
    `_id` field as `1`. The moment another document with the same value of the `_id`
    field is found, `1` in this case, an error is thrown and the bulk insert stops.
    Now execute the following `insert` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have passed an additional parameter, `continue_on_error`, whose value
    is `True`. What this does is ensures that the `insert` operation will continue
    with the next document even if an intermediate `insert` operation fails. The second
    insert with `_id:1` fails, yet the next insert goes through before another insert
    with `_id:2` fails (as one document with this `_id` is already present). Additionally,
    the error reported is for the last failure, the one with `_id:2`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, *Executing update and delete operations using PyMongo*, picks
    up where this leaves off and introduces the update, remove, and atomic find operations.
  prefs: []
  type: TYPE_NORMAL
- en: Executing update and delete operations using PyMongo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to execute `find` and `insert` operations
    in MongoDB using PyMongo. In this recipe, we will see how update and delete work
    in Python. We will also see what atomic find and update/delete is and how to execute
    them. We then conclude by revisiting find operations and looking at some interesting
    functions of the `cursor` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have already seen and completed the previous recipe, you are all set
    to go. If not, it is recommended that you first complete that recipe before going
    ahead with this one. Additionally, if you are not sure what read preference and
    write concern are, refer to the two recipes, *Read preference for querying* and
    *Write concern and its significance*, in [Appendix](apa.html "Appendix A. Concepts
    for Reference"), *Concepts for Reference* of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, let''s define a small function that iterates through
    the cursor and shows the results of a cursor on the console. We will use this
    function whenever we want to display the results of a query on the `pymongoTests`
    collection. The following is the function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to steps 1 and 2 in the previous recipe on how to create a connection
    to the MongoDB server and the `db` object that is used to perform CRUD operations
    on this database. Additionally, refer to step 8 in the previous recipe on how
    to insert the required test data in the `pymongoTest` collection. You can confirm
    the data in this collection by executing the following in the Python shell once
    the data is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For a part of the recipe, one is also expected to know how to start a replica
    set instance. Refer to the *Starting multiple instances as part of a replica set*
    and *Connecting to the replica set in the shell to query and insert data* recipes
    in the first chapter for more details on a replica set and how to start one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will begin by running the following commands in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set a field named `gtTen` specified with a Boolean value `True` if
    the `i` field has a value greater than 10\. Let''s execute the following update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Query the collection, view its data by executing the following, and check the
    data that got updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The results displayed confirm that only one document got updated. We will now
    execute the same update again, but this time around, we will update all the documents
    that match the provided query. Execute the following update in the Python shell.
    Note that this update is identical to the one we performed in step 1 except for
    the additional parameter called multi whose value is given as `True`. Note the
    value of n in the response, which is `10` this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Execute the operation that we did in step 2 again to view the contents in the
    `pymongoTest` collection and verify the documents that got updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at how `upsert` operations can be performed. Upserts are updates
    plus inserts, and they update a document if one exists, just as an update would
    do, or else they insert a new document. We will look at an example. Consider the
    following update on a document that doesn''t exist in the collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The update here will not update anything and will return the number of updated
    documents as zero. However, consider that we want to update a document if it exists,
    or else insert a new document and apply the update to it atomically, then we perform
    an `upsert` operation. In this case, the `upsert` operation is executed as follows.
    Note that the return result mentions `upsert`, `ObjectId` of the newly inserted
    document, and the `updatedExisting` value, which is `False`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how to delete documents from the collection using the `remove` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the value of `n` in the preceding response, we can see that it
    is `1`. This means that one document has been removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To remove multiple documents from the collection, we use the `delete_many`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will look at the find and modify operations now. We can look at these operations
    as a way to find a document and update/remove it, and both of these operations
    are performed atomically. Once the operation is performed, the document returned
    is either the one before or after the update operation was done. (In case of `remove`,
    there will be no document after the operation.) In the absence of this operation,
    we cannot guarantee atomicity where multiple client connections could be performing
    a similar operation on the same document. The following is an example of how to
    perform this find and modify operation in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous result shows us that the resulting document returned is the one
    before the update was applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following `find` method to query and view the document that we
    updated in the last step. The resulting document would contain the newly added
    in the `Words` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute the `find` and `modify` operation again, but this time around,
    we return the updated document rather than the document before the update that
    we saw in step 9\. Execute the following in the Python shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw how to use queries with PyMongo in the previous recipe. Here, we will
    continue with the query operation. We saw how the `sort` and `limit` functions
    were chained to the find operation. The prototype of the call on the `postalCodes`
    collection is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an alternate way to achieve this same result. Execute the following
    query in the Python shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Print the preceding cursor using the `showResult` function already defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at what all we did in this recipe; we started with updating the
    documents in a collection in step 1\. The update operation, however, updates only
    the first matching document by default and the rest of the matching documents
    are not updated. In step 2, we added a parameter called `multi` with a value `True`
    to update multiple documents as part of the same update operation. Note that all
    these documents are not updated atomically as part of one transaction. Looking
    at the update done in the Python shell, we see a striking resemblance to what
    we would have done in the Mongo shell. If we want to name the arguments of the
    update operation, the names of the parameter are called `spec` and `document`
    for the document provided as a query to be used in order to select the documents
    to update and the update document, respectively. For instance, the following update
    is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In step 6, we did an `upsert` (update plus insert) operation. All we had was
    an additional parameter, `upsert`, with a value, `True`. However, what exactly
    happens in the case of an upsert? Mongo tries to update the document matching
    the provided condition, and if it finds one, then this would be a regular update.
    However, in this case (`upsert` in step 6), the document was not found. The server
    inserted the document given as the spec (the first parameter) parameter in the
    collection and then applied the update to it with both these operations taking
    place atomically.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 7 and 9, we saw the `remove` operation. The first variant accepted
    a query and the matching document was removed. The second variant, in step 9,
    removes all the matching documents.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 10 to 12, we executed the `find` and `modify` operations. The gist
    of these operations is pretty straightforward. What we didn't mention was the
    `find_one_and_replace()` method, which, as the name suggests, can be used to search
    a document and completely replace it with another.
  prefs: []
  type: TYPE_NORMAL
- en: All the operations that we saw in this recipe were for a client connected to
    a standalone instance. If you are connected to a replica set, the client is instantiated
    in a different way. We are also aware of the fact that we are not allowed to query
    the secondary nodes for data by default. We need to explicitly do `rs.slaveOk()`
    in the mongo shell connected to a secondary node to query it. It is done in a
    similar way in a Python client as well. If we are connected to a secondary node,
    we cannot query it by default, but the way in which we specify that we are ok
    to query on a secondary node is slightly different. Starting with PyMongo 3.0,
    we can now pass `ReadPreference` when initiating `MongoClient`. This is primarily
    because, starting with PyMongo 3.0, `pymongo.MongoClient()` is the only way to
    connect to a standalone instance, replica set, or sharded cluster. The available
    read preferences are `PRIMARY`, `SECONDARY`, `PRIMARY_PREFERRED`, `SECONDARY_PREFERRED`,
    and `NEAREST`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the client, PyMongo also allows you to have read preferences
    set at the database or collection level.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `read_preference` for a client initialized without an explicit read
    preference is `PRIMARY` (with value zero). However, if we now get the database
    object from the client initialized previously, the read preference will be `NEAREST`
    (with value `4`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the read preference is as simple as doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again, as the read preference gets inherited from the client to the database
    object, it gets inherited from the database object to the collection object. This
    would be used as the default value for all the queries executed against this collection
    unless the read preference is specified explicitly in the `find` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `db.pymongoTest.find_one()` will have a cursor that uses the read preference
    as `SECONDARY` (as we have just set it previously to `SECONDARY` at the database
    object level).
  prefs: []
  type: TYPE_NORMAL
- en: We will now wrap up the basic operations from a Python driver by trying to do
    some common operations that we do in a mongo shell such as getting all the database
    names, getting a list of collections in a database, and creating an index on a
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the shell, we do show `dbs` to show all the database names in the mongo
    instance connected. From the Python client, we do the following on the client
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to see the list of collections, we do show collections in the mongo
    shell; in Python, all we do on the database object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the `index` operations; we first see what all indexes are present in
    the `pymongoTest` collection. Execute the following in the Python shell to view
    the indexes on a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We now will create an index on key `x`, which is sorted in an ascending order
    on the `pymongoTest` collection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can again list the indexes to confirm the creation of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the index has been created. Removing the index is also simple
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Another parameter called `CursorType.TAILABLE` is used to denote that the cursor
    returned by `find` is a tailable cursor. Explaining what tailable cursors and
    giving more details is not in the scope of this recipe and will be explained in
    the recipe named *Creating and tailing a capped collection cursors in MongoDB*
    in [Chapter 5](ch05.html "Chapter 5. Advanced Operations"), *Advanced Operations*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing aggregation in Mongo using PyMongo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen PyMongo using Python's client interface for Mongo in previous
    recipes. In this recipe, we will use the postal codes collection and run an aggregation
    example using PyMongo. The intention of this recipe is not to explain aggregation
    but to show how aggregation can be implemented using PyMongo. In this recipe,
    we will aggregate the data based on the state names and get the top five state
    names by the number of documents that they appear in. We will make use of the
    `$project`, `$group`, `$sort`, and `$limit` operators for the process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the aggregation operation, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are mentioned in the *Creating test data* recipe in [Chapter
    2](ch02.html "Chapter 2. Command-line Operations and Indexes"), *Command-line
    Operations and Indexes*. Additionally, refer to the *Connecting to a single node
    using a Python client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system. As this is a way to implement aggregation
    in Python, it is assumed that the reader is aware of the aggregation framework
    in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the Python terminal by typing the following on the command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Python shell opens, import `pymongo` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of `MongoClient` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the test database''s object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we execute the aggregation operation on the `postalCodes` collection as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Type the following to view the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps are pretty straightforward. We have connected to the database running
    on localhost and created a database object. The aggregation operation that we
    invoked on the collection using the aggregate function is very similar to how
    we would invoke aggregation in the shell. The object in the return value, `result`,
    is a cursor, which returns an object of type `dict` on iteration. This `dict`
    contains two keys, each with the name of the state and count of the number of
    their occurrence. In step 6, we are simply iterating over the cursor (result)
    to fetch each result.
  prefs: []
  type: TYPE_NORMAL
- en: Executing MapReduce in Mongo using PyMongo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, *Implementing aggregation in Mongo using PyMongo*, we
    saw how to execute aggregation operations in Mongo using PyMongo. In this recipe,
    we will work on the same use case as we did for the aggregation operation but
    we will use MapReduce. The intent is to aggregate the data based on the state
    names and get the top five state names by the number of documents that they appear
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Programming language drivers provide us with an interface to invoke the map
    reduce jobs written in JavaScript on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the map reduce operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are mentioned in the *Creating test data* recipe in [Chapter
    2](ch02.html "Chapter 2. Command-line Operations and Indexes"), *Command-line
    Operations and Indexes*. Additionally, refer to the *Connecting to a single node
    using Python client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing and
    Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the Python terminal by typing the following on the command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Python shell opens, import the `bson` package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `pymongo` package as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an of `MongoClient` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the test database''s object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following `mapper` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following `reducer` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke map reduce; the result will be sent to the `pymr_out` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the result as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the regular import for `pymongo`, here we import the `bson` package
    as well. This is where we have the `Code` class; it is the `Python` object that
    we use for the JavaScript `map` and `reduce` functions. It is instantiated by
    passing the JavaScript function body as a constructor argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once two instances of the `Code` class are instantiated, one for `map` and
    the other for `reduce`, all we do is invoke the `map_reduce` function on the collection.
    In this case, we passed three parameters: two `Code` instances for the `map` and
    `reduce` functions with parameter names `map` and `reduce`, respectively and one
    string value used to provide the name of the output collection that the results
    are written to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t be explaining the map reduce JavaScript functions here but it is
    pretty simple, and all it does is emit keys as the names of the states and values
    that are the number of times the particular state name occurs. This result document
    with the key used, the state''s name as the `_id` field, and another field called
    value that is the sum of the times the particular state''s name given in the `_id`
    field appears in the collection is added to the output collection, `pymr_out`.
    For example, in the entire collection, the state `Maharashtra` appeared `6446`
    times, thus the document for the state of Maharashtra is `{u''_id'': u''Maharashtra'',
    u''value'': 6446.0}`. To verify that the result is correct, you can execute the
    following query in the mongo shell and see that the result is indeed `6446`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We are still not done as the requirement is to find the top five states by their
    occurrence in the collection; we still have just the states and their occurrences,
    so the final step is to sort the documents by the value field, which is the number
    of times the state's name occurred in descending order and limit the result to
    five documents.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 8](ch08.html "Chapter 8. Integration with Hadoop"), *Integration
    with Hadoop* for different recipes on executing map reduce jobs in MongoDB using
    the Hadoop connector. This allows us to write the `map` and `reduce` functions
    in languages such as Java, Python, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Executing query and insert operations using a Java client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at executing the query and `insert` operations
    using the Java client for MongoDB. Unlike the Python programming language, Java
    code snippets cannot be executed from an interactive interpreter, and thus we
    will be having some unit test cases already implemented, whose relevant code snippets
    will be shown and explained.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will start a standalone instance. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* for instructions
    on how to start the server.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. This recipe uses a JUnit test case to test out various
    features of the Java client. In this whole process, we will use some of the most
    common API calls and thus learn to use them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  prefs: []
  type: TYPE_NORMAL
- en: The test case that we will execute for this recipe is `com.packtpub.mongo.cookbook.MongoDriverQueryAndInsertTest`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, open this test class and execute it as a JUnit test
    case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Everything should get executed fine and the test case should succeed if the
    Java SDK and Maven are properly set up and the MongoDB server is up and running
    and listening to port `27017` for the incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now open the test class that we executed and see some of the important
    API calls in the `test` method. The super class of our `test` class is `com.packtpub.mongo.cookbook.AbstractMongoTest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by looking at the `getClient` method in this class. The `client` instance
    that has been created is an instance of the `com.mongodb.MongoClient type`. There
    are several overloaded constructors for this class; however, we use the following
    to instantiate the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method to look at is `getJavaDriverTestDatabase` in the same abstract
    class that gets us the database instance. This instance is synonymous to the implicit
    variable `db` in the shell. Here in Java, this class is an instance of the `com.mongodb.DB`
    type. We get an instance of this `DB` class by invoking the `getDB()` method on
    the client instance. In our case, we want the `DB` instance for the `javaDriverTest`
    database, which we get as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we get the instance of `com.mongodb.DB`, we use it to get the instance
    of `com.mongodb.DBCollection`, which would be used to perform various operations—`find`
    and `insert`—on the collection. The `getJavaTestCollection` method in the abstract
    test class returns one instance of `DBCollection`. We get an instance of this
    class for the `javaTest` collection by invoking the `getCollection()` method on
    `com.mongodb.DB` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Once we get an instance of `DBCollection`, we are now ready to perform the operations
    on it. In the scope of this recipe, it is limited to the `find` and `insert` operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we open the main test case class, `com.packtpub.mongo.cookbook.MongoDriverQueryAndInsertTest`.
    Open this class in an IDE or a text editor. We will look at the methods in this
    class. The first method that we will look at is `findOneDocument`. Here, the line
    of our interest is the one that queries for the document with the value of `_id`
    as `3`: `collection.findOne(new BasicDBObject("_id", 3))`.'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns an instance of `com.mongodb.DBObject`, which is a key value
    map returning the fields of a document as a key and the value of this corresponding
    key. For instance, to get the value of `_id` from the returned `DBObject` instance,
    we invoke `result.get("_id")` on the returned result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next method to inspect is `getDocumentsFromTestCollection`. This test case
    executes a `find` operation on the collection and gets all the documents in it.
    The `collection.find()` call executes the `find` operation on the instance of
    `DBCollection`. The return value of the `find` operation is `com.mongodb.DBCursor`.
    An important point to note is that invoking the `find` operation itself doesn''t
    execute the query but just returns the instance of `DBCursor`. This is an inexpensive
    operation that doesn''t consume server-side resources. The actual query gets executed
    on the server side only when the `hasNext` or `next` method is invoked on the
    `DBCursor` instance. The `hasNext()` method is used to check if there are more
    results and the `next()` method is used to navigate to the next `DBObject` instance
    in the result. An example usage of the `DBCursor` instance returned to iterate
    through the results is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We now look at two methods, `withLimitAndSkip` and `withQueryProjectionAndSort`.
    These methods show us how to sort, limit the number of results, and skip a number
    of initial results. As we can see, the sort, limit, and skip methods are chained
    to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: All these methods return an instance of `DBCursor` itself, which allows us to
    chain the calls. These methods are defined in the `DBCursor` class, which changes
    certain states according to the operation that they perform in the instance and
    has return this at the end of the method to return the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the actual operation is invoked on the server only on invoking
    the `hasNext` or `next` method on `DBCursor`. Invoking any method such as `sort`,
    `limit`, and `skip` after the execution of the query on the server will throw
    `java.lang.IllegalStateException`.
  prefs: []
  type: TYPE_NORMAL
- en: We used two variants of the `find` method. One accepts one parameter for the
    query to be executed and one accepts two parameters—the first one for the query
    and the second is another `DBObject`, which is used for projection that will return
    only a selected set of fields from the document in the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following query from the `withQueryProjectionAndSort` method
    of the test case selects all the documents as the first argument as `null` and
    the returned `DBCursor` will have documents containing just one field called `value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `_id` field is to be explicitly set to `0`, or else it will be returned
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we look at two more methods in the test case, `insertDataTest` and
    `insertTestDataWithWriteConcern`. We use a couple of variants of the `insert`
    method in these two methods. All `insert` methods are invoked on the `DBCollection`
    instance and return an instance, `com.mongodb.WriteResult`. The result can be
    used to get the error that occurred during the write operation by invoking the
    `getLastError()` method, the number of documents inserted using the `getN()` method,
    and the write concern for the operation among the few operations. Refer to the
    Javadoc of the MongoDB API for more detail on the methods. The two insert operations
    that we did are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Both of these accept a `DBObject` instance for the document to be inserted as
    the first parameter. The second method allows us to provide the write concern
    to be used for the `write` operation. There are `insert` methods in the `DBCollection`
    class that allow bulk insert as well. Refer to the Javadocs for more details on
    various overloaded versions of the `insert` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Javadocs for the current version of the MongoDB driver can be found at [https://api.mongodb.org/java/current/](https://api.mongodb.org/java/current/).
  prefs: []
  type: TYPE_NORMAL
- en: Executing update and delete operations using a Java client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to execute `find` and `insert` operations
    in MongoDB using the Java client; in this recipe, we will see how updates and
    deletes work in the Java client.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will start a standalone instance. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* for instructions
    on how to start the server.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. This recipe uses a JUnit test case to test out various
    features of the Java client. In this whole process, we will use some of the most
    common API calls and thus learn to use them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  prefs: []
  type: TYPE_NORMAL
- en: The test case that we are going to execute for this recipe is `com.packtpub.mongo.cookbook.MongoDriverUpdateAndDeleteTest`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, open this test class and execute it as a JUnit test
    case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a test data for the recipes using a `setupUpdateTestData()` method.
    Here, we simply put documents in the `javaTest` collection in the `javaDriverTest`
    database. We add 20 documents to this collection with the value of `i` ranging
    from 1 to 20\. This test data is used in different test case methods to create
    test data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the methods in this class. We will first look at
    `basicUpdateTest()`. In this method, we first create the test data and then execute
    the following update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update` method here takes two arguments. The first is the query that would
    be used to select the eligible documents for the update, and the second parameter
    is the actual update. The first parameter looks confusing due to nested `BasicDBObject`
    instances; however, it is the `{''i'' : {''$gt'' : 10}}` condition and the second
    parameter is the update, `{''$set'' : {''gtTen'' : true}}`. The result of the
    update is an instance of `com.mongodb.WriteResult`. The instance of `WriteResult`
    tells us the number of documents that got updated and gets the error that occurred
    while executing the `write` operation and write concern used for the update. Refer
    to the Javadocs of the `WriteConcern` class for more details. This update only
    updates the first matching document by default only if multiple documents match
    the query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method that we will look at is `multiUpdateTest`, which will update
    all the matching documents for the given query instead of the first matching document.
    The method that we used is `updateMulti` on the collection instance. The `updateMulti`
    method is a convenient way to update multiple documents. The following is the
    call that we make to update multiple documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The next operation that we did was to remove documents. The test case method
    to remove documents is `deleteTest()`. The documents are removed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We have two parameters here. The first is the query for which the matching documents
    will be removed from the collection. Note that all matching documents will be
    removed by default unlike update, where only the first matching document will
    be removed by default. The second parameter is the write concern to be used for
    the `remove` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when the server is started on a 32-bit machine, journaling is disabled
    by default. When you use Write Concern on such machines, it may cause the operation
    to fail with the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This would require the server to be started with the `--journal` option. On
    64-bit machines, this is not necessary as journaling is enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the `findAndModify` operation next. The test case method to
    perform this operation is `findAndModifyTest`. The following lines of code are
    used to perform this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The operation is the query that will find the matching documents and then update
    them. The return type of the operation is an instance of `DBObject` before the
    update is applied. One important feature of the `findAndModify` operation is that
    the `find` and `update` operations are performed atomically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding method is a simple version of the `findAndModify` operation.
    There is an overloaded version of this method with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what these parameters are in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `query` | This is the query that is used to query the document, which is
    the one that gets updated/deleted. |'
  prefs: []
  type: TYPE_TB
- en: '| `fields` | The `find` method supports the projection of fields that need
    to be selected in the result document(s) selected. The parameter here does the
    same job of selecting the fixed set of fields from the resulting document. |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | If you haven''t noticed already, let me tell you that the method
    can perform this atomic operation on only one document and also return one document.
    This `sort` function can be used in cases where the query selects multiple documents
    and only the first gets chosen for the operation. The `sort` function is applied
    on the result before picking up the first document to update. |'
  prefs: []
  type: TYPE_TB
- en: '| `remove` | This is a Boolean flag that indicates whether to remove or update
    the document. If this value is `true`, the document will be removed. |'
  prefs: []
  type: TYPE_TB
- en: '| `update` | Unlike the preceding attribute, this is not a Boolean value but
    a `DBObject` instance that will tell what the update needs to be. Note that the
    remove Boolean flag gets precedence over this parameter; if the `remove` attribute
    is `true`, the update will not happen even if one is provided. |'
  prefs: []
  type: TYPE_TB
- en: '| `returnNew` | The find operation returns a document, but which one? The one
    before the update was executed or the one after the update gets executed? This
    Boolean flag, when given as `true`, returns the document after the update is executed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `upsert` | This is a Boolean flag again that executes `upsert` when `true`.
    It is relevant only when the intended operation is update. |'
  prefs: []
  type: TYPE_TB
- en: There are more overloaded methods of this operation. Refer to the Javadocs of
    `com.mongodb.DBCollection` for more methods. The `findAndModify` method that we
    used ultimately invokes the method we discussed with the fields and sort parameters
    as null with the remaining parameters, `remove`, `returnNew`, and `upsert` being
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we look at the query builder support in MongoDB's Java API.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the queries in mongo are `DBObject` instances with possibly more nested
    `DBObject` instances in them. Things are simple for small queries, but they start
    getting ugly for more complicated queries. Consider a relatively simple query
    where we want to query for documents with `i > 10` and `i < 15`. The mongo query
    for this is `{$and:[{i:{$gt:10}}`, `{i:{$lt:15}}]}`. Writing this in Java would
    mean using `BasicDBObject` instances, which is even painful and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Thankfully, however, there is a class called `com.mongodb.QueryBuilder`, which
    is a utility class to build the complex queries. The preceding query is built
    using a query builder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This is less error prone when writing a query and easy to read as well. There
    are a lot of methods in the `com.mongodb.QueryBuilder` class and I would encourage
    you to go through the Javadocs of this class. The basic idea is to start construction
    using the `start` method and the key. We then chain the method calls to add different
    conditions, and when the addition of various conditions is done, the query is
    constructed using the `get()` method, which returns `DBObject`. Refer to the `queryBuilderSample`
    method in the test class for a sample usage of query builder support of the MongoDB
    Java API.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some more operations using the GridFS and geospatial indexes. We will
    see how to use them in the Java application with a small sample in the advanced
    query chapter. Refer to [Chapter 5](ch05.html "Chapter 5. Advanced Operations"),
    *Advanced Operations* for such recipes.
  prefs: []
  type: TYPE_NORMAL
- en: The Javadocs for the current version of the MongoDB driver can be found at [https://api.mongodb.org/java/current/](https://api.mongodb.org/java/current/).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing aggregation in Mongo using a Java client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intention of this recipe is not to explain aggregation but to show you how
    aggregation can be implemented using the Java client from a Java program. In this
    recipe, we will aggregate the data based on the state names and get the top five
    state names by the number of documents that they appear in. We will use the `$project`,
    `$group`, `$sort`, and `$limit` operators for the process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test class used for this recipe is `com.packtpub.mongo.cookbook.MongoAggregationTest`.
    To execute the aggregation operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are given in the *Creating test data* recipe in [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. Though Maven can be used to execute the test case, it
    is convenient to import the project in an IDE and execute the test case class.
    It is assumed that you are familiar with the Java programming language and comfortable
    using the IDE that the project will be imported to.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, open the test class and execute it as a JUnit test
    case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method used for the aggregation functionality is `aggregationTest()` in
    our test class. The aggregation operation is performed on MongoDB from a Java
    client using the `aggregate()` method defined in the `DBCollection` class. The
    method has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Only the first argument is mandatory, which forms the first operation in the
    pipeline. The second argument is a `varagrs` argument (variable number of arguments
    with zero or more values), which allows more pipeline operators. All these arguments
    are of the `com.mongodb.DBObject` type. In case any exception occurs in the execution
    of the aggregation command, the aggregation operation will throw `com.mongodb.MongoException`
    with the cause of the exception.
  prefs: []
  type: TYPE_NORMAL
- en: The return type, `com.mongodb.AggregationOutput`, is used to get the result
    of the aggregation operation. From a developer's perspective, we are more interested
    in the `results` field of this instance, which can be accessed using the `results()`
    method of the returned object. The `results()` method returns an object of type,
    `Iterable<DBObject>`, which one can iterate to get the results of the aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we implemented the aggregation pipeline in our test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four steps in the pipeline in the following order: a `$project` operation,
    followed by `$group`, `$sort`, and then `$limit`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last two operations look inefficient where we sort all and then just take
    the top five elements. In such scenarios, the MongoDB server is intelligent enough
    to consider the limit operation while sorting, where only the top five results
    need to be maintained rather than sorting all the results.
  prefs: []
  type: TYPE_NORMAL
- en: For version 2.6 of MongoDB, the aggregation result can return a cursor. Though
    the preceding code is still valid, the `AggregationResult` object is no longer
    the only way to get the results of the operation. We can use `com.mongodb.Cursor`
    that can be used to iterate the results. Additionally, the preceding format is
    now deprecated in favor of the format that accepts a list of pipeline operators
    rather than `varargs` for the operators. Refer to the Javadocs of the `com.mongodb.DBCollection`
    class and look at the various overloaded `aggregate()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Executing MapReduce in Mongo using a Java client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, *Implementing aggregation in Mongo using a Java client*,
    we saw how to execute aggregation operations in Mongo using the Java client. In
    this recipe, we will work on the same use case as we did for the aggregation operation
    but We will use MapReduce. The intent is to aggregate the data based on the state
    names and get the top five state names by the number of documents that they appear
    in.
  prefs: []
  type: TYPE_NORMAL
- en: If somebody is not aware of how to write MapReduce code for Mongo from a programming
    language client and is seeing it for the first time, you might be surprised to
    see how it is actually done. You might have imagined that you would be writing
    the `map` and `reduce` function in the programming language that you are writing
    the code in, Java in this case, and then using it to execute the map reduce. However,
    we need to bear in mind that the MapReduce jobs run on the mongo servers and they
    execute JavaScript functions. Hence, irrespective of the programming language
    driver, the map reduce functions are written in JavaScript. The programming language
    drivers just act as a means of letting us invoke and execute the map reduce functions
    (written in JavaScript) on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test class used for this recipe is `com.packtpub.mongo.cookbook.MongoMapReduceTest`.
    To execute the map reduce operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are given in the *Creating test data* recipe in [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. Though Maven can be used to execute the test case, it
    is convenient to import the project in an IDE and execute the test case class.
    It is assumed that you are familiar with the Java programming language and comfortable
    using the IDE that the project will be imported to.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, open the test class and execute it as a JUnit test
    case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test case method for our map reduce test is `mapReduceTest()`.
  prefs: []
  type: TYPE_NORMAL
- en: Map reduce operations can be done in Mongo from a Java client using the `mapReduce()`
    method defined in the `DBCollection` class. There are a lot of overloaded versions,
    and you can refer to the Javadocs of the `com.mongodb.DBCollection` class for
    more details on the various flavors of this method. The one that we used is `collection.mapReduce(mapper,
    reducer, output collection, query)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method accepts the following four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mapper` function is of type String and a JavaScript code that would be
    executed on the mongo database server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reducer` function is of type String and a JavaScript code that would be
    executed on the mongo database server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the collection that the output of the map reduce execution will
    be written to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query that will be executed by the server and the result of this query will
    be the input to the map reduce job execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the assumption is that the reader is well-versed with the map reduce operations
    in the shell, we won''t explain the map reduce JavaScript functions that we used
    in the test case method. All it does is emit keys as the names of the states and
    values, which are the number of times the particular state name occurs. This result
    is added to the output collection, `javaMROutput`, in this case. For example,
    in the entire collection, the state `Maharashtra` appears `6446` times; thus,
    the document for the state of `Maharashtra` is `{''_id'': ''Maharashtra'', ''value'':
    6446}`. To confirm that this is the true value or not, you can execute the following
    query in the mongo shell and see that the result is indeed `6446`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We are still not done as the requirement is to find the top five states by their
    occurrence in the collection; we still have just the states and their occurrences,
    so the final step is to sort the documents by the `value` field, which is the
    number of times the state's name occurs in descending order, and limit the result
    to five documents.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 8](ch08.html "Chapter 8. Integration with Hadoop"), *Integration
    with Hadoop* for different recipes on executing Map Reduce jobs in MongoDB using
    the Hadoop connector. This allows us to write the `Map` and `Reduce` functions
    in languages such as Java, Python, and so on.
  prefs: []
  type: TYPE_NORMAL
