- en: Chapter 3. Programming Language Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Executing query and insert operations with PyMongo
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing update and delete operations using PyMongo
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing aggregation in Mongo using PyMongo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing MapReduce in Mongo using PyMongo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing query and insert operations using a Java client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing update and delete operations using a Java client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing aggregation in Mongo using a Java client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing MapReduce in Mongo using a Java client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have executed the majority of operations in the shell using Mongo.
    The Mongo shell is a great tool for administrators to perform administrative tasks
    and for developers who would like to quickly test things by querying the data
    before coding the logic in the application. However, how do we write application
    code that will allow us to query, insert, update, and delete (among other things)
    the data in MongoDB? There has to be a library for the programming language that
    we write our application in. We should be able to instantiate something or invoke
    methods from the program to perform some operations on the remote Mongo process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: How would this happen unless there is some bridge that understands the protocol
    of communication with the remote server and is able to transmit the operation
    over the wire that we require in order to execute on the Mongo server process
    and get the result back to the client. This bridge, simply put, is called the
    **driver**, also referred to as client libraries. Drivers form the backbone of
    Mongo's programming language interface; in their absence, it would have been the
    responsibility of the application to communicate with the Mongo server using a
    low-level protocol that the server understands. This would have been a lot of
    work, not only to develop, but also to test and maintain. Though the communication
    protocol is standard, there cannot be one implementation that works for all the
    languages. A variety of programming languages need to have their own implementations
    exposing similar sets of programming interfaces to all the languages. The core
    concepts of client APIs, which we will see in this chapter, holds good for all
    the languages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mongo has support for all major programming and is supported by MongoDB Inc.
    There is even a huge array of programming languages supported by the community.
    You can take a look at the various platforms supported by Mongo by visiting [http://docs.mongodb.org/ecosystem/drivers/community-supported-drivers/](http://docs.mongodb.org/ecosystem/drivers/community-supported-drivers/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Executing query and insert operations with PyMongo
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is all about executing basic query and `insert` operations using
    PyMongo. This is similar to what we did with the Mongo shell earlier in the book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute simple queries, we need to have a server up and running. A simple
    single node is what we need. Refer to the *Installing single node MongoDB* recipe
    from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"), *Installing
    and Starting the Server* for instructions on how to start the server. The data
    that we will be operating on needs to be imported in the database. The steps to
    import the data are given in the *Creating test data* recipe from [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. Python 2.7, or higher, has to be present on the host operating system
    along with MongoDB's Python client, PyMongo. Look at the earlier recipe, *Connecting
    to a single node using a Python client*, in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system. Additionally, in this recipe, we will
    execute `insert` operations and provide a write concern to use.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with querying for Mongo in the Python shell. This will be identical
    to what we do in the mongo shell except that this is in the Python programming
    language, as opposed to the JavaScript that we have in the mongo shell. We can
    use the basics that we will see here to write big production systems that run
    on Python and use mongo as a data store.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Python shell中查询Mongo开始。这将与我们在mongo shell中所做的完全相同，只是这是用Python编程语言而不是我们在mongo
    shell中使用的JavaScript。我们可以使用这里将看到的基础知识来编写在Python上运行并使用mongo作为数据存储的大型生产系统。
- en: 'Let''s begin by starting the Python shell from the operating system''s command
    prompt. All these steps are independent of the host operating system. Perform
    the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从操作系统的命令提示符开始启动Python shell。所有这些步骤都与主机操作系统无关。执行以下步骤：
- en: 'Type the following in the shell and the Python shell should start:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell中输入以下内容，Python shell应该启动：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, import the `pymongo` package and create the client as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导入`pymongo`包，并创建客户端如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This works well and achieves the same result. Now that we have the client,
    our next step is to get the database that we will be performing the operations
    on. This is unlike some of the programming languages where we have a `getDatabase()`
    method to get an instance of the database. We will get a reference to the database
    object that we will be performing the operations on, `test` in this case. We will
    do this in the following way:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做效果很好，可以实现相同的结果。现在我们有了客户端，下一步是获取我们将执行操作的数据库。这与一些编程语言不同，在那里我们有一个`getDatabase()`方法来获取数据库的实例。我们将获取一个对数据库对象的引用，我们将在其上执行操作，在这种情况下是`test`。我们将以以下方式执行此操作：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will query the `postalCodes` collection. We will limit our results to 10
    items.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将查询`postalCodes`集合。我们将将结果限制为10项。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Iterate over the results. Watch out for the indentation of the print after
    the `for` statement. The following fragment should print 10 documents as returned:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历结果。注意`for`语句后的缩进。以下片段应该打印出返回的10个文档：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To find one document, execute the following:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查找一个文档，请执行以下操作：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Print the `state` and `city` of the returned result as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式打印返回结果的`state`和`city`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s query top 10 cities in the state of Gujarat sorted by the name of the
    city and, additionally, we just select the `city`, `state`, and `pincode`. Execute
    the following query in the Python shell:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查询古吉拉特邦前10个城市，按城市名称排序，并且额外选择`city`、`state`和`pincode`。在Python shell中执行以下查询：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding cursor's results can be printed in the same way that we printed
    the results in step 5.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面游标的结果可以以与我们在第5步中打印结果相同的方式打印出来。
- en: 'Let''s sort the data that we query. We want to sort in a descending order of
    state and then by ascending order of the city. We will write the query as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对我们查询的数据进行排序。我们希望按州的降序和城市的升序进行排序。我们将编写以下查询：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Iterating through this cursor should print out five results to the console.
    Refer to step 5 on how we iterate over a cursor returned to print the results.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过迭代这个游标，应该在控制台上打印出五个结果。参考第5步，了解如何迭代返回的游标以打印结果。
- en: 'So, we have played a bit to find documents and covered the basic operations
    in Python as far as the querying of MongoDB is concerned. Now, let''s see a bit
    about the `insert` operation. We will use a test collection to perform these operations
    and not disturb our postal codes test data. We will use a `pymongoTest` collection
    for this purpose and add documents in a loop to it as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们已经玩了一会儿，找到了文档，并涵盖了Python中与查询MongoDB有关的基本操作。现在，让我们稍微了解一下`insert`操作。我们将使用一个测试集合来执行这些操作，而不会干扰我们的邮政编码测试数据。我们将使用`pymongoTest`集合来实现这个目的，并按以下方式向其中添加文档：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `insert` can take a list of dictionary objects and perform a bulk insert.
    So now, something similar to the following `insert` is perfectly valid:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`insert`可以接受一个字典对象列表并执行批量插入。因此，现在类似以下的`insert`是完全有效的：'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any guesses on the return value? In case of a single document insert, the return
    value is the value of `_id` for the newly created document. In this case, it is
    a list of IDs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对返回值有什么猜测吗？在单个文档插入的情况下，返回值是新创建文档的`_id`的值。在这种情况下，它是一个ID列表。
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 2, we instantiate the client and get the reference to the `MongoClient`
    object that will be used to access the database. There are a couple of ways to
    get this reference. The first option is more convenient, unless your database
    name has some special character, such as a hyphen (-). For example, if the name
    is `db-test`, we would have no option other than to use the `[]` operator to access
    the database. Using either of the alternatives, we now have an object for the
    test database in the `db` variable. After we get the `client` and `db` instances
    in Python, we query to find the top 10 documents in the natural order from the
    collection in step 3\. The syntax is identical to how this query would have been
    executed in the shell. Step 4 simply prints out the results, 10 of them in this
    case. Generally, if you need instant help on a particular class using the class
    name or an instance of this class from the Python interpreter, simply perform
    `dir(<class_name>)` or `dir(<object of a class>)`, which gives you a list of attributes
    and functions defined in the module passed. For example, `dir('pymongo.MongoClient')`
    or `dir(client)`, where the client is the variable holding reference to an instance
    of `pymongo.MongoClient`, can be used to get the list of all the supported attributes
    and functions. The `help` function is more informative, prints out the module's
    documentation, and is a great source of reference just in case you need instant
    help. Try typing `help('pymongo.MongoClient')` or `help(client)`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In steps 3 and 4, we query the `postalCodes` collection, limit the result to
    the top 10 results, and print them. The returned object is of a type `pymongo.cursor.Cursor`
    class. The next step gets just one document from the collection using the `find_one()`
    function. This is synonymous to the `findOne()` method on the collection invoked
    in the shell. The value returned by this function is an inbuilt object, `dict`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 6, we execute another `find` to query the data. In step 8, we pass
    two Python dicts. The first dict is the query, similar to the query parameter
    we use in mongo shell. The second dictionary is used to provide the fields to
    be returned in the result. A value, one, for a field indicates that the value
    is to be selected and returned in the result. This is synonymous with the `select`
    statement in a relational database with a few sets of columns provided explicitly
    to be selected. The `_id` field is selected by default unless it is explicitly
    set to zero in the selector `dict` object. The selector provided here is `{''_id'':0,
    ''city'':1, ''state'':1, ''pincode'':1}`, which selects the city, state, and pincode
    and suppresses the `_id` field. We have a sort method as well. This method has
    two formats as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first one is used when we want to sort by one field only. The second representation
    accepts a list of pairs of the sort field and sort directions and is used when
    we want to sort by multiple fields. We used the first form in the query in step
    8 and the second format in our query in step 9 as we sort first by the state `name`
    and then, by `city`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the way we invoke `sort`, it is invoked on the `Cursor` instance.
    Similarly, the `limit` function is also on the `Cursor` class. The evaluation
    is lazy and deferred until the iteration is performed in order to retrieve the
    results from the cursor. Until this point of time, the `Cursor` object is not
    evaluated on the server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: In step 11, we insert a document 20 times in a collection. Each insert, as we
    can see in the Python shell, will return a generated `_id` field. In terms of
    the syntax of insert, it is exactly identical to the operation that we perform
    in the shell. The parameter passed for the insert is an object of type `dict`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In step 12, we pass a list of documents to insert in the collection. This is
    referred to as a bulk insert operation, which inserts multiple documents in a
    single call to the server. The return value in this case is a list of IDs, one
    for each document inserted, and the order is the same as those passed in the input
    list. However, as MongoDB doesn't support transactions, each insert will be independent
    of each other, and a failure of one insert doesn't roll back the entire operation
    automatically.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the functionality of inserting multiple documents demanded another parameter
    for the behavior. When one of the inserts in the list given fails, should the
    remaining inserts continue or the insertion stop as soon as the first error is
    encountered? The name of the parameter to control this behavior is `continue_on_error`
    and its default value is `False`, that is, stop as soon as the first error is
    encountered. If this value is `True` and multiple errors occur during insertion,
    only the latest error will be available, and hence the default option with `False`
    as the value is sensible. Let''s look at a couple of examples. In the Python shell,
    execute the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The count that we will get is `1`, which is for the first document with the
    `_id` field as `1`. The moment another document with the same value of the `_id`
    field is found, `1` in this case, an error is thrown and the bulk insert stops.
    Now execute the following `insert` operation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have passed an additional parameter, `continue_on_error`, whose value
    is `True`. What this does is ensures that the `insert` operation will continue
    with the next document even if an intermediate `insert` operation fails. The second
    insert with `_id:1` fails, yet the next insert goes through before another insert
    with `_id:2` fails (as one document with this `_id` is already present). Additionally,
    the error reported is for the last failure, the one with `_id:2`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, *Executing update and delete operations using PyMongo*, picks
    up where this leaves off and introduces the update, remove, and atomic find operations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Executing update and delete operations using PyMongo
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to execute `find` and `insert` operations
    in MongoDB using PyMongo. In this recipe, we will see how update and delete work
    in Python. We will also see what atomic find and update/delete is and how to execute
    them. We then conclude by revisiting find operations and looking at some interesting
    functions of the `cursor` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have already seen and completed the previous recipe, you are all set
    to go. If not, it is recommended that you first complete that recipe before going
    ahead with this one. Additionally, if you are not sure what read preference and
    write concern are, refer to the two recipes, *Read preference for querying* and
    *Write concern and its significance*, in [Appendix](apa.html "Appendix A. Concepts
    for Reference"), *Concepts for Reference* of the book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, let''s define a small function that iterates through
    the cursor and shows the results of a cursor on the console. We will use this
    function whenever we want to display the results of a query on the `pymongoTests`
    collection. The following is the function body:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can refer to steps 1 and 2 in the previous recipe on how to create a connection
    to the MongoDB server and the `db` object that is used to perform CRUD operations
    on this database. Additionally, refer to step 8 in the previous recipe on how
    to insert the required test data in the `pymongoTest` collection. You can confirm
    the data in this collection by executing the following in the Python shell once
    the data is present:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For a part of the recipe, one is also expected to know how to start a replica
    set instance. Refer to the *Starting multiple instances as part of a replica set*
    and *Connecting to the replica set in the shell to query and insert data* recipes
    in the first chapter for more details on a replica set and how to start one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于食谱的一部分，人们也应该知道如何启动一个副本集实例。有关副本集的更多细节以及如何启动副本集，请参阅第一章中的*作为副本集的一部分启动多个实例*和*在shell中连接到副本集以查询和插入数据*食谱。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'We will begin by running the following commands in the Python shell:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Python shell中运行以下命令开始：
- en: 'We will set a field named `gtTen` specified with a Boolean value `True` if
    the `i` field has a value greater than 10\. Let''s execute the following update:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`i`字段的值大于10，则我们将设置一个名为`gtTen`的字段，并指定一个布尔值`True`。让我们执行以下更新：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Query the collection, view its data by executing the following, and check the
    data that got updated:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询集合，通过执行以下操作查看其数据，并检查已更新的数据：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The results displayed confirm that only one document got updated. We will now
    execute the same update again, but this time around, we will update all the documents
    that match the provided query. Execute the following update in the Python shell.
    Note that this update is identical to the one we performed in step 1 except for
    the additional parameter called multi whose value is given as `True`. Note the
    value of n in the response, which is `10` this time.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示的结果证实只有一个文档被更新。现在我们将再次执行相同的更新，但这一次，我们将更新所有与提供的查询匹配的文档。在Python shell中执行以下更新。注意响应中的n的值，这次是`10`。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Execute the operation that we did in step 2 again to view the contents in the
    `pymongoTest` collection and verify the documents that got updated.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行我们在步骤2中进行的操作，查看`pymongoTest`集合中的内容，并验证已更新的文档。
- en: 'Let''s look at how `upsert` operations can be performed. Upserts are updates
    plus inserts, and they update a document if one exists, just as an update would
    do, or else they insert a new document. We will look at an example. Consider the
    following update on a document that doesn''t exist in the collection:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何执行`upsert`操作。Upserts是更新加插入，如果文档存在则更新文档，就像更新操作一样，否则插入一个新文档。我们将看一个例子。考虑对集合中不存在的文档进行以下更新：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The update here will not update anything and will return the number of updated
    documents as zero. However, consider that we want to update a document if it exists,
    or else insert a new document and apply the update to it atomically, then we perform
    an `upsert` operation. In this case, the `upsert` operation is executed as follows.
    Note that the return result mentions `upsert`, `ObjectId` of the newly inserted
    document, and the `updatedExisting` value, which is `False`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的更新不会更新任何内容，并且返回更新的文档数为零。但是，如果我们想要更新一个文档（如果存在），否则插入一个新文档并原子性地应用更新，那么我们执行一个`upsert`操作。在这种情况下，`upsert`操作执行如下。请注意返回结果中提到的`upsert`，新插入文档的`ObjectId`和`updatedExisting`值，这个值是`False`：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s see how to delete documents from the collection using the `remove` method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`remove`方法从集合中删除文档：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we look at the value of `n` in the preceding response, we can see that it
    is `1`. This means that one document has been removed.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看前面响应中`n`的值，我们可以看到它是`1`。这意味着已删除一个文档。
- en: 'To remove multiple documents from the collection, we use the `delete_many`
    method:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从集合中删除多个文档，我们使用`delete_many`方法：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will look at the find and modify operations now. We can look at these operations
    as a way to find a document and update/remove it, and both of these operations
    are performed atomically. Once the operation is performed, the document returned
    is either the one before or after the update operation was done. (In case of `remove`,
    there will be no document after the operation.) In the absence of this operation,
    we cannot guarantee atomicity where multiple client connections could be performing
    a similar operation on the same document. The following is an example of how to
    perform this find and modify operation in Python:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将看一下查找和修改操作。我们可以将这些操作视为查找文档并更新/删除它的一种方式，这两种操作都是原子性执行的。操作完成后，返回的文档要么是更新操作之前的文档，要么是更新操作之后的文档。（在`remove`的情况下，操作后将没有文档。）在没有这种操作的情况下，我们无法保证在多个客户端连接可能对同一文档执行类似操作的情况下的原子性。以下是如何在Python中执行此查找和修改操作的示例：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The previous result shows us that the resulting document returned is the one
    before the update was applied.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果告诉我们，在应用更新之前返回的文档是之前的文档。
- en: 'Execute the following `find` method to query and view the document that we
    updated in the last step. The resulting document would contain the newly added
    in the `Words` field:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下`find`方法来查询并查看我们在上一步中更新的文档。结果文档将包含在`Words`字段中新增的内容：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will execute the `find` and `modify` operation again, but this time around,
    we return the updated document rather than the document before the update that
    we saw in step 9\. Execute the following in the Python shell:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次执行`find`和`modify`操作，但这一次，我们返回更新后的文档，而不是在步骤9中看到的更新前的文档。在Python shell中执行以下操作：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We saw how to use queries with PyMongo in the previous recipe. Here, we will
    continue with the query operation. We saw how the `sort` and `limit` functions
    were chained to the find operation. The prototype of the call on the `postalCodes`
    collection is as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一个食谱中看到了如何使用PyMongo进行查询。在这里，我们将继续进行查询操作。我们看到`sort`和`limit`函数是如何链接到find操作的。对`postalCodes`集合的调用原型如下：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There is an alternate way to achieve this same result. Execute the following
    query in the Python shell:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一种实现相同结果的替代方法。在Python shell中执行以下查询：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Print the preceding cursor using the `showResult` function already defined.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用已定义的`showResult`函数打印前面的游标。
- en: How it works…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Let''s look at what all we did in this recipe; we started with updating the
    documents in a collection in step 1\. The update operation, however, updates only
    the first matching document by default and the rest of the matching documents
    are not updated. In step 2, we added a parameter called `multi` with a value `True`
    to update multiple documents as part of the same update operation. Note that all
    these documents are not updated atomically as part of one transaction. Looking
    at the update done in the Python shell, we see a striking resemblance to what
    we would have done in the Mongo shell. If we want to name the arguments of the
    update operation, the names of the parameter are called `spec` and `document`
    for the document provided as a query to be used in order to select the documents
    to update and the update document, respectively. For instance, the following update
    is valid:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In step 6, we did an `upsert` (update plus insert) operation. All we had was
    an additional parameter, `upsert`, with a value, `True`. However, what exactly
    happens in the case of an upsert? Mongo tries to update the document matching
    the provided condition, and if it finds one, then this would be a regular update.
    However, in this case (`upsert` in step 6), the document was not found. The server
    inserted the document given as the spec (the first parameter) parameter in the
    collection and then applied the update to it with both these operations taking
    place atomically.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In steps 7 and 9, we saw the `remove` operation. The first variant accepted
    a query and the matching document was removed. The second variant, in step 9,
    removes all the matching documents.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In steps 10 to 12, we executed the `find` and `modify` operations. The gist
    of these operations is pretty straightforward. What we didn't mention was the
    `find_one_and_replace()` method, which, as the name suggests, can be used to search
    a document and completely replace it with another.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: All the operations that we saw in this recipe were for a client connected to
    a standalone instance. If you are connected to a replica set, the client is instantiated
    in a different way. We are also aware of the fact that we are not allowed to query
    the secondary nodes for data by default. We need to explicitly do `rs.slaveOk()`
    in the mongo shell connected to a secondary node to query it. It is done in a
    similar way in a Python client as well. If we are connected to a secondary node,
    we cannot query it by default, but the way in which we specify that we are ok
    to query on a secondary node is slightly different. Starting with PyMongo 3.0,
    we can now pass `ReadPreference` when initiating `MongoClient`. This is primarily
    because, starting with PyMongo 3.0, `pymongo.MongoClient()` is the only way to
    connect to a standalone instance, replica set, or sharded cluster. The available
    read preferences are `PRIMARY`, `SECONDARY`, `PRIMARY_PREFERRED`, `SECONDARY_PREFERRED`,
    and `NEAREST`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In addition to the client, PyMongo also allows you to have read preferences
    set at the database or collection level.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: By default, `read_preference` for a client initialized without an explicit read
    preference is `PRIMARY` (with value zero). However, if we now get the database
    object from the client initialized previously, the read preference will be `NEAREST`
    (with value `4`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Setting the read preference is as simple as doing the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, as the read preference gets inherited from the client to the database
    object, it gets inherited from the database object to the collection object. This
    would be used as the default value for all the queries executed against this collection
    unless the read preference is specified explicitly in the `find` operation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `db.pymongoTest.find_one()` will have a cursor that uses the read preference
    as `SECONDARY` (as we have just set it previously to `SECONDARY` at the database
    object level).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: We will now wrap up the basic operations from a Python driver by trying to do
    some common operations that we do in a mongo shell such as getting all the database
    names, getting a list of collections in a database, and creating an index on a
    collection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'In the shell, we do show `dbs` to show all the database names in the mongo
    instance connected. From the Python client, we do the following on the client
    instance:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, to see the list of collections, we do show collections in the mongo
    shell; in Python, all we do on the database object is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now for the `index` operations; we first see what all indexes are present in
    the `pymongoTest` collection. Execute the following in the Python shell to view
    the indexes on a collection:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now will create an index on key `x`, which is sorted in an ascending order
    on the `pymongoTest` collection as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can again list the indexes to confirm the creation of the index:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can see that the index has been created. Removing the index is also simple
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Another parameter called `CursorType.TAILABLE` is used to denote that the cursor
    returned by `find` is a tailable cursor. Explaining what tailable cursors and
    giving more details is not in the scope of this recipe and will be explained in
    the recipe named *Creating and tailing a capped collection cursors in MongoDB*
    in [Chapter 5](ch05.html "Chapter 5. Advanced Operations"), *Advanced Operations*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Implementing aggregation in Mongo using PyMongo
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen PyMongo using Python's client interface for Mongo in previous
    recipes. In this recipe, we will use the postal codes collection and run an aggregation
    example using PyMongo. The intention of this recipe is not to explain aggregation
    but to show how aggregation can be implemented using PyMongo. In this recipe,
    we will aggregate the data based on the state names and get the top five state
    names by the number of documents that they appear in. We will make use of the
    `$project`, `$group`, `$sort`, and `$limit` operators for the process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the aggregation operation, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are mentioned in the *Creating test data* recipe in [Chapter
    2](ch02.html "Chapter 2. Command-line Operations and Indexes"), *Command-line
    Operations and Indexes*. Additionally, refer to the *Connecting to a single node
    using a Python client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system. As this is a way to implement aggregation
    in Python, it is assumed that the reader is aware of the aggregation framework
    in MongoDB.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the Python terminal by typing the following on the command prompt:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the Python shell opens, import `pymongo` as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create an instance of `MongoClient` as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Get the test database''s object as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we execute the aggregation operation on the `postalCodes` collection as
    follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Type the following to view the results:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps are pretty straightforward. We have connected to the database running
    on localhost and created a database object. The aggregation operation that we
    invoked on the collection using the aggregate function is very similar to how
    we would invoke aggregation in the shell. The object in the return value, `result`,
    is a cursor, which returns an object of type `dict` on iteration. This `dict`
    contains two keys, each with the name of the state and count of the number of
    their occurrence. In step 6, we are simply iterating over the cursor (result)
    to fetch each result.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Executing MapReduce in Mongo using PyMongo
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, *Implementing aggregation in Mongo using PyMongo*, we
    saw how to execute aggregation operations in Mongo using PyMongo. In this recipe,
    we will work on the same use case as we did for the aggregation operation but
    we will use MapReduce. The intent is to aggregate the data based on the state
    names and get the top five state names by the number of documents that they appear
    in.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Programming language drivers provide us with an interface to invoke the map
    reduce jobs written in JavaScript on the server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the map reduce operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are mentioned in the *Creating test data* recipe in [Chapter
    2](ch02.html "Chapter 2. Command-line Operations and Indexes"), *Command-line
    Operations and Indexes*. Additionally, refer to the *Connecting to a single node
    using Python client* recipe in [Chapter 1](ch01.html "Chapter 1. Installing and
    Starting the Server"), *Installing and Starting the Server* on how to install
    PyMongo for your host operating system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the Python terminal by typing the following on the command prompt:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the Python shell opens, import the `bson` package as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Import the `pymongo` package as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create an of `MongoClient` as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Get the test database''s object as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Write the following `mapper` function:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Write the following `reducer` function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Invoke map reduce; the result will be sent to the `pymr_out` collection:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Verify the result as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the regular import for `pymongo`, here we import the `bson` package
    as well. This is where we have the `Code` class; it is the `Python` object that
    we use for the JavaScript `map` and `reduce` functions. It is instantiated by
    passing the JavaScript function body as a constructor argument.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Once two instances of the `Code` class are instantiated, one for `map` and
    the other for `reduce`, all we do is invoke the `map_reduce` function on the collection.
    In this case, we passed three parameters: two `Code` instances for the `map` and
    `reduce` functions with parameter names `map` and `reduce`, respectively and one
    string value used to provide the name of the output collection that the results
    are written to.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t be explaining the map reduce JavaScript functions here but it is
    pretty simple, and all it does is emit keys as the names of the states and values
    that are the number of times the particular state name occurs. This result document
    with the key used, the state''s name as the `_id` field, and another field called
    value that is the sum of the times the particular state''s name given in the `_id`
    field appears in the collection is added to the output collection, `pymr_out`.
    For example, in the entire collection, the state `Maharashtra` appeared `6446`
    times, thus the document for the state of Maharashtra is `{u''_id'': u''Maharashtra'',
    u''value'': 6446.0}`. To verify that the result is correct, you can execute the
    following query in the mongo shell and see that the result is indeed `6446`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We are still not done as the requirement is to find the top five states by their
    occurrence in the collection; we still have just the states and their occurrences,
    so the final step is to sort the documents by the value field, which is the number
    of times the state's name occurred in descending order and limit the result to
    five documents.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 8](ch08.html "Chapter 8. Integration with Hadoop"), *Integration
    with Hadoop* for different recipes on executing map reduce jobs in MongoDB using
    the Hadoop connector. This allows us to write the `map` and `reduce` functions
    in languages such as Java, Python, and so on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Executing query and insert operations using a Java client
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at executing the query and `insert` operations
    using the Java client for MongoDB. Unlike the Python programming language, Java
    code snippets cannot be executed from an interactive interpreter, and thus we
    will be having some unit test cases already implemented, whose relevant code snippets
    will be shown and explained.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will start a standalone instance. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* for instructions
    on how to start the server.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. This recipe uses a JUnit test case to test out various
    features of the Java client. In this whole process, we will use some of the most
    common API calls and thus learn to use them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The test case that we will execute for this recipe is `com.packtpub.mongo.cookbook.MongoDriverQueryAndInsertTest`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, open this test class and execute it as a JUnit test
    case.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Everything should get executed fine and the test case should succeed if the
    Java SDK and Maven are properly set up and the MongoDB server is up and running
    and listening to port `27017` for the incoming connections.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now open the test class that we executed and see some of the important
    API calls in the `test` method. The super class of our `test` class is `com.packtpub.mongo.cookbook.AbstractMongoTest`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by looking at the `getClient` method in this class. The `client` instance
    that has been created is an instance of the `com.mongodb.MongoClient type`. There
    are several overloaded constructors for this class; however, we use the following
    to instantiate the client:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Another method to look at is `getJavaDriverTestDatabase` in the same abstract
    class that gets us the database instance. This instance is synonymous to the implicit
    variable `db` in the shell. Here in Java, this class is an instance of the `com.mongodb.DB`
    type. We get an instance of this `DB` class by invoking the `getDB()` method on
    the client instance. In our case, we want the `DB` instance for the `javaDriverTest`
    database, which we get as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once we get the instance of `com.mongodb.DB`, we use it to get the instance
    of `com.mongodb.DBCollection`, which would be used to perform various operations—`find`
    and `insert`—on the collection. The `getJavaTestCollection` method in the abstract
    test class returns one instance of `DBCollection`. We get an instance of this
    class for the `javaTest` collection by invoking the `getCollection()` method on
    `com.mongodb.DB` as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Once we get an instance of `DBCollection`, we are now ready to perform the operations
    on it. In the scope of this recipe, it is limited to the `find` and `insert` operations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we open the main test case class, `com.packtpub.mongo.cookbook.MongoDriverQueryAndInsertTest`.
    Open this class in an IDE or a text editor. We will look at the methods in this
    class. The first method that we will look at is `findOneDocument`. Here, the line
    of our interest is the one that queries for the document with the value of `_id`
    as `3`: `collection.findOne(new BasicDBObject("_id", 3))`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: This method returns an instance of `com.mongodb.DBObject`, which is a key value
    map returning the fields of a document as a key and the value of this corresponding
    key. For instance, to get the value of `_id` from the returned `DBObject` instance,
    we invoke `result.get("_id")` on the returned result.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next method to inspect is `getDocumentsFromTestCollection`. This test case
    executes a `find` operation on the collection and gets all the documents in it.
    The `collection.find()` call executes the `find` operation on the instance of
    `DBCollection`. The return value of the `find` operation is `com.mongodb.DBCursor`.
    An important point to note is that invoking the `find` operation itself doesn''t
    execute the query but just returns the instance of `DBCursor`. This is an inexpensive
    operation that doesn''t consume server-side resources. The actual query gets executed
    on the server side only when the `hasNext` or `next` method is invoked on the
    `DBCursor` instance. The `hasNext()` method is used to check if there are more
    results and the `next()` method is used to navigate to the next `DBObject` instance
    in the result. An example usage of the `DBCursor` instance returned to iterate
    through the results is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We now look at two methods, `withLimitAndSkip` and `withQueryProjectionAndSort`.
    These methods show us how to sort, limit the number of results, and skip a number
    of initial results. As we can see, the sort, limit, and skip methods are chained
    to each other:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All these methods return an instance of `DBCursor` itself, which allows us to
    chain the calls. These methods are defined in the `DBCursor` class, which changes
    certain states according to the operation that they perform in the instance and
    has return this at the end of the method to return the same instance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the actual operation is invoked on the server only on invoking
    the `hasNext` or `next` method on `DBCursor`. Invoking any method such as `sort`,
    `limit`, and `skip` after the execution of the query on the server will throw
    `java.lang.IllegalStateException`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We used two variants of the `find` method. One accepts one parameter for the
    query to be executed and one accepts two parameters—the first one for the query
    and the second is another `DBObject`, which is used for projection that will return
    only a selected set of fields from the document in the result.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following query from the `withQueryProjectionAndSort` method
    of the test case selects all the documents as the first argument as `null` and
    the returned `DBCursor` will have documents containing just one field called `value`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `_id` field is to be explicitly set to `0`, or else it will be returned
    by default.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we look at two more methods in the test case, `insertDataTest` and
    `insertTestDataWithWriteConcern`. We use a couple of variants of the `insert`
    method in these two methods. All `insert` methods are invoked on the `DBCollection`
    instance and return an instance, `com.mongodb.WriteResult`. The result can be
    used to get the error that occurred during the write operation by invoking the
    `getLastError()` method, the number of documents inserted using the `getN()` method,
    and the write concern for the operation among the few operations. Refer to the
    Javadoc of the MongoDB API for more detail on the methods. The two insert operations
    that we did are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Both of these accept a `DBObject` instance for the document to be inserted as
    the first parameter. The second method allows us to provide the write concern
    to be used for the `write` operation. There are `insert` methods in the `DBCollection`
    class that allow bulk insert as well. Refer to the Javadocs for more details on
    various overloaded versions of the `insert` method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Javadocs for the current version of the MongoDB driver can be found at [https://api.mongodb.org/java/current/](https://api.mongodb.org/java/current/).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Executing update and delete operations using a Java client
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to execute `find` and `insert` operations
    in MongoDB using the Java client; in this recipe, we will see how updates and
    deletes work in the Java client.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will start a standalone instance. Refer to the *Installing
    single node MongoDB* recipe from [Chapter 1](ch01.html "Chapter 1. Installing
    and Starting the Server"), *Installing and Starting the Server* for instructions
    on how to start the server.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. This recipe uses a JUnit test case to test out various
    features of the Java client. In this whole process, we will use some of the most
    common API calls and thus learn to use them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The test case that we are going to execute for this recipe is `com.packtpub.mongo.cookbook.MongoDriverUpdateAndDeleteTest`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, open this test class and execute it as a JUnit test
    case.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a test data for the recipes using a `setupUpdateTestData()` method.
    Here, we simply put documents in the `javaTest` collection in the `javaDriverTest`
    database. We add 20 documents to this collection with the value of `i` ranging
    from 1 to 20\. This test data is used in different test case methods to create
    test data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the methods in this class. We will first look at
    `basicUpdateTest()`. In this method, we first create the test data and then execute
    the following update:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `update` method here takes two arguments. The first is the query that would
    be used to select the eligible documents for the update, and the second parameter
    is the actual update. The first parameter looks confusing due to nested `BasicDBObject`
    instances; however, it is the `{''i'' : {''$gt'' : 10}}` condition and the second
    parameter is the update, `{''$set'' : {''gtTen'' : true}}`. The result of the
    update is an instance of `com.mongodb.WriteResult`. The instance of `WriteResult`
    tells us the number of documents that got updated and gets the error that occurred
    while executing the `write` operation and write concern used for the update. Refer
    to the Javadocs of the `WriteConcern` class for more details. This update only
    updates the first matching document by default only if multiple documents match
    the query.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method that we will look at is `multiUpdateTest`, which will update
    all the matching documents for the given query instead of the first matching document.
    The method that we used is `updateMulti` on the collection instance. The `updateMulti`
    method is a convenient way to update multiple documents. The following is the
    call that we make to update multiple documents:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The next operation that we did was to remove documents. The test case method
    to remove documents is `deleteTest()`. The documents are removed as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We have two parameters here. The first is the query for which the matching documents
    will be removed from the collection. Note that all matching documents will be
    removed by default unlike update, where only the first matching document will
    be removed by default. The second parameter is the write concern to be used for
    the `remove` operation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when the server is started on a 32-bit machine, journaling is disabled
    by default. When you use Write Concern on such machines, it may cause the operation
    to fail with the following exception:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This would require the server to be started with the `--journal` option. On
    64-bit machines, this is not necessary as journaling is enabled by default.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the `findAndModify` operation next. The test case method to
    perform this operation is `findAndModifyTest`. The following lines of code are
    used to perform this operation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The operation is the query that will find the matching documents and then update
    them. The return type of the operation is an instance of `DBObject` before the
    update is applied. One important feature of the `findAndModify` operation is that
    the `find` and `update` operations are performed atomically.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding method is a simple version of the `findAndModify` operation.
    There is an overloaded version of this method with the following signature:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s see what these parameters are in the following table:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| `query` | This is the query that is used to query the document, which is
    the one that gets updated/deleted. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| `fields` | The `find` method supports the projection of fields that need
    to be selected in the result document(s) selected. The parameter here does the
    same job of selecting the fixed set of fields from the resulting document. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| `sort` | If you haven''t noticed already, let me tell you that the method
    can perform this atomic operation on only one document and also return one document.
    This `sort` function can be used in cases where the query selects multiple documents
    and only the first gets chosen for the operation. The `sort` function is applied
    on the result before picking up the first document to update. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| `remove` | This is a Boolean flag that indicates whether to remove or update
    the document. If this value is `true`, the document will be removed. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| `update` | Unlike the preceding attribute, this is not a Boolean value but
    a `DBObject` instance that will tell what the update needs to be. Note that the
    remove Boolean flag gets precedence over this parameter; if the `remove` attribute
    is `true`, the update will not happen even if one is provided. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| `returnNew` | The find operation returns a document, but which one? The one
    before the update was executed or the one after the update gets executed? This
    Boolean flag, when given as `true`, returns the document after the update is executed.
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| `upsert` | This is a Boolean flag again that executes `upsert` when `true`.
    It is relevant only when the intended operation is update. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: There are more overloaded methods of this operation. Refer to the Javadocs of
    `com.mongodb.DBCollection` for more methods. The `findAndModify` method that we
    used ultimately invokes the method we discussed with the fields and sort parameters
    as null with the remaining parameters, `remove`, `returnNew`, and `upsert` being
    `false`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we look at the query builder support in MongoDB's Java API.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'All the queries in mongo are `DBObject` instances with possibly more nested
    `DBObject` instances in them. Things are simple for small queries, but they start
    getting ugly for more complicated queries. Consider a relatively simple query
    where we want to query for documents with `i > 10` and `i < 15`. The mongo query
    for this is `{$and:[{i:{$gt:10}}`, `{i:{$lt:15}}]}`. Writing this in Java would
    mean using `BasicDBObject` instances, which is even painful and looks as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Thankfully, however, there is a class called `com.mongodb.QueryBuilder`, which
    is a utility class to build the complex queries. The preceding query is built
    using a query builder as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is less error prone when writing a query and easy to read as well. There
    are a lot of methods in the `com.mongodb.QueryBuilder` class and I would encourage
    you to go through the Javadocs of this class. The basic idea is to start construction
    using the `start` method and the key. We then chain the method calls to add different
    conditions, and when the addition of various conditions is done, the query is
    constructed using the `get()` method, which returns `DBObject`. Refer to the `queryBuilderSample`
    method in the test class for a sample usage of query builder support of the MongoDB
    Java API.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some more operations using the GridFS and geospatial indexes. We will
    see how to use them in the Java application with a small sample in the advanced
    query chapter. Refer to [Chapter 5](ch05.html "Chapter 5. Advanced Operations"),
    *Advanced Operations* for such recipes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The Javadocs for the current version of the MongoDB driver can be found at [https://api.mongodb.org/java/current/](https://api.mongodb.org/java/current/).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Implementing aggregation in Mongo using a Java client
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intention of this recipe is not to explain aggregation but to show you how
    aggregation can be implemented using the Java client from a Java program. In this
    recipe, we will aggregate the data based on the state names and get the top five
    state names by the number of documents that they appear in. We will use the `$project`,
    `$group`, `$sort`, and `$limit` operators for the process.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test class used for this recipe is `com.packtpub.mongo.cookbook.MongoAggregationTest`.
    To execute the aggregation operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are given in the *Creating test data* recipe in [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. Though Maven can be used to execute the test case, it
    is convenient to import the project in an IDE and execute the test case class.
    It is assumed that you are familiar with the Java programming language and comfortable
    using the IDE that the project will be imported to.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, open the test class and execute it as a JUnit test
    case.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method used for the aggregation functionality is `aggregationTest()` in
    our test class. The aggregation operation is performed on MongoDB from a Java
    client using the `aggregate()` method defined in the `DBCollection` class. The
    method has the following signature:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Only the first argument is mandatory, which forms the first operation in the
    pipeline. The second argument is a `varagrs` argument (variable number of arguments
    with zero or more values), which allows more pipeline operators. All these arguments
    are of the `com.mongodb.DBObject` type. In case any exception occurs in the execution
    of the aggregation command, the aggregation operation will throw `com.mongodb.MongoException`
    with the cause of the exception.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The return type, `com.mongodb.AggregationOutput`, is used to get the result
    of the aggregation operation. From a developer's perspective, we are more interested
    in the `results` field of this instance, which can be accessed using the `results()`
    method of the returned object. The `results()` method returns an object of type,
    `Iterable<DBObject>`, which one can iterate to get the results of the aggregation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we implemented the aggregation pipeline in our test class:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'There are four steps in the pipeline in the following order: a `$project` operation,
    followed by `$group`, `$sort`, and then `$limit`.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The last two operations look inefficient where we sort all and then just take
    the top five elements. In such scenarios, the MongoDB server is intelligent enough
    to consider the limit operation while sorting, where only the top five results
    need to be maintained rather than sorting all the results.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: For version 2.6 of MongoDB, the aggregation result can return a cursor. Though
    the preceding code is still valid, the `AggregationResult` object is no longer
    the only way to get the results of the operation. We can use `com.mongodb.Cursor`
    that can be used to iterate the results. Additionally, the preceding format is
    now deprecated in favor of the format that accepts a list of pipeline operators
    rather than `varargs` for the operators. Refer to the Javadocs of the `com.mongodb.DBCollection`
    class and look at the various overloaded `aggregate()` methods.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Executing MapReduce in Mongo using a Java client
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, *Implementing aggregation in Mongo using a Java client*,
    we saw how to execute aggregation operations in Mongo using the Java client. In
    this recipe, we will work on the same use case as we did for the aggregation operation
    but We will use MapReduce. The intent is to aggregate the data based on the state
    names and get the top five state names by the number of documents that they appear
    in.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: If somebody is not aware of how to write MapReduce code for Mongo from a programming
    language client and is seeing it for the first time, you might be surprised to
    see how it is actually done. You might have imagined that you would be writing
    the `map` and `reduce` function in the programming language that you are writing
    the code in, Java in this case, and then using it to execute the map reduce. However,
    we need to bear in mind that the MapReduce jobs run on the mongo servers and they
    execute JavaScript functions. Hence, irrespective of the programming language
    driver, the map reduce functions are written in JavaScript. The programming language
    drivers just act as a means of letting us invoke and execute the map reduce functions
    (written in JavaScript) on the server.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test class used for this recipe is `com.packtpub.mongo.cookbook.MongoMapReduceTest`.
    To execute the map reduce operations, we need to have a server up and running.
    A simple single node is what we need. Refer to the *Installing single node MongoDB*
    recipe from [Chapter 1](ch01.html "Chapter 1. Installing and Starting the Server"),
    *Installing and Starting the Server* for instructions on how to start the server.
    The data that we will operate on needs to be imported in the database. The steps
    to import the data are given in the *Creating test data* recipe in [Chapter 2](ch02.html
    "Chapter 2. Command-line Operations and Indexes"), *Command-line Operations and
    Indexes*. The next step is to download the Java project, `mongo-cookbook-javadriver`,
    from the Packt website. Though Maven can be used to execute the test case, it
    is convenient to import the project in an IDE and execute the test case class.
    It is assumed that you are familiar with the Java programming language and comfortable
    using the IDE that the project will be imported to.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute the test case, one can either import the project in an IDE-like Eclipse
    and execute the test case or execute the test case from the command prompt using
    Maven.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, open the test class and execute it as a JUnit test
    case.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning to use Maven to execute this test case, go to the command
    prompt, change the directory at the root of the project, and execute the following
    to execute this single test case:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Everything should get executed fine if the Java SDK and Maven are properly set
    up and the MongoDB server is up and running and listening to port `27017` for
    the incoming connections.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test case method for our map reduce test is `mapReduceTest()`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Map reduce operations can be done in Mongo from a Java client using the `mapReduce()`
    method defined in the `DBCollection` class. There are a lot of overloaded versions,
    and you can refer to the Javadocs of the `com.mongodb.DBCollection` class for
    more details on the various flavors of this method. The one that we used is `collection.mapReduce(mapper,
    reducer, output collection, query)`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'The method accepts the following four parameters:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The `mapper` function is of type String and a JavaScript code that would be
    executed on the mongo database server
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reducer` function is of type String and a JavaScript code that would be
    executed on the mongo database server
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the collection that the output of the map reduce execution will
    be written to
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query that will be executed by the server and the result of this query will
    be the input to the map reduce job execution
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the assumption is that the reader is well-versed with the map reduce operations
    in the shell, we won''t explain the map reduce JavaScript functions that we used
    in the test case method. All it does is emit keys as the names of the states and
    values, which are the number of times the particular state name occurs. This result
    is added to the output collection, `javaMROutput`, in this case. For example,
    in the entire collection, the state `Maharashtra` appears `6446` times; thus,
    the document for the state of `Maharashtra` is `{''_id'': ''Maharashtra'', ''value'':
    6446}`. To confirm that this is the true value or not, you can execute the following
    query in the mongo shell and see that the result is indeed `6446`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We are still not done as the requirement is to find the top five states by their
    occurrence in the collection; we still have just the states and their occurrences,
    so the final step is to sort the documents by the `value` field, which is the
    number of times the state's name occurs in descending order, and limit the result
    to five documents.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 8](ch08.html "Chapter 8. Integration with Hadoop"), *Integration
    with Hadoop* for different recipes on executing Map Reduce jobs in MongoDB using
    the Hadoop connector. This allows us to write the `Map` and `Reduce` functions
    in languages such as Java, Python, and so on.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
