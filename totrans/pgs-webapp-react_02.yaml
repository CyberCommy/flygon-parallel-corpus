- en: Getting Started with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is all about Webpack: what it is, how to use it, and why we care.
    However, before we dive into Webpack, I have a confession to make.'
  prefs: []
  type: TYPE_NORMAL
- en: We cheated a bit in the last chapter on application setup. There’s one last
    piece of our folder structure we need to add--the place where our React files
    will live.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the *Dependencies* section of the last chapter, one of React’s
    killer features is the *componentization of user interfaces*--splitting them up
    into small chunks of related HTML and JavaScript. For instance, a "Save" button
    may be one component, sitting inside a form component, next to a Profile Information
    component, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of the component structure is that everything related to a particular
    piece of the UI sits together (separation of concerns), also, these sections are
    in brief, readable files. As a developer, you can easily find what you’re looking
    for by navigating the folder structure, rather than scrolling through a monolithic
    JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to structure our React project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Dev server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with JavaScript transpilation with Babel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activating hot reloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building for production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s see what this looks like in practice. In our `chatastrophe` project folder,
    create an `src` folder (which should be next to the `public` and `node_modules`
    folder in the root of the project folder).
  prefs: []
  type: TYPE_NORMAL
- en: The `src` folder is where all our React files will live. To illustrate what
    this will look like, let’s create some mock files.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `src`, make another folder, called `components`. Inside that folder,
    let's make three JavaScript files. You can name them whatever you like, but for
    example purposes, I’ll call them `Component1.js`, `Component2.js`, and `Component3.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that each of these component files holds a bit of our user interface.
    We need all three files to construct a complete UI. How do we import them all?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can do what we’ve done so far when we needed to use JavaScript files.
    We can create a `script` tag for each component in our `index.html`. That’s the
    brute force way.
  prefs: []
  type: TYPE_NORMAL
- en: However, as our application grows, this approach will quickly become unwieldy.
    An application such as Facebook, for example, will have tens of thousands of components.
    We can’t write tens of thousands of `script` tags!
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we’d have only one `script` tag, with all our JavaScript combined.
    We need a tool that takes our varied files and squishes them together, giving
    us the best of both worlds--organized, separated code for the developer, and compressed,
    optimized code for the user.
  prefs: []
  type: TYPE_NORMAL
- en: '"But wait, Scott," you might say, "if we put all our code in one file, won’t
    that take longer for the browser to download? Isn’t it a good thing to have small,
    separate files?"'
  prefs: []
  type: TYPE_NORMAL
- en: You're exactly right. We don’t want to go back to a monolithic single file in
    the end, but neither do we want thousands of separate files. We need a happy medium
    of a handful of code files, and we’ll get to that medium. However, to start, let’s
    see how we can bundle multiple JavaScript files into just one using our new friend--**Webpack**.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal for this section is to take the JavaScript sitting in our script tag
    in our `index.html` (the line responsible for rendering our "Hello from React!")
    and move that to a JavaScript file in the `src` folder, which is then bundled
    and injected into the HTML by Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'It sounds complicated, but it’s simpler than it sounds, thanks to the magic
    of Webpack. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install Webpack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the `package.json`, you should see Webpack listed under our dependencies.
    For this book, I’ll be using **version 3.5.4**; if you run into any inexplicable
    problems, try specifying this version with `yarn add webpack@3.5.4`:'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to tell Webpack what to do. Let’s start by moving our React code
    into the `src` folder. Inside `chatastrophe/src`, create a file called `index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to get this greeting to display in our browser console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let’s try out Webpack. In your Terminal, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Your Terminal should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What does this do? Well, it tells Webpack to take the first file and copy it
    (and everything it needs, that is, every file it requires) into the second file
    (which Webpack created for us, since it didn’t exist).
  prefs: []
  type: TYPE_NORMAL
- en: If you open up the newly created `public/bundle.js`, you’ll see a lot of Webpack
    boilerplate… and at the bottom, our `console.log`.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so it works; we can require this file in our `index.html` to see our `console.log`,
    but that's not using Webpack to its full potential. Let’s try something else.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at how Webpack combines our JavaScript files together. Go
    through the following steps to add a second JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: In our `src` folder, create another file. Let’s call it `index2.js`, for lack
    of creativity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside, add a second `console.log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, back in `index.js` (the first one), we’ll require the other file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This basically means that `index.js` now tells Webpack, "Hey, I need this other
    index!"
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let’s rerun the same Webpack command as earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we’ll only specify `src/index.js`, but if you look at the console output,
    you’ll see that Webpack now grabs the other file too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Open up `public/bundle.js`, scroll to the bottom, and you’ll see both console
    logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s the beauty of Webpack. We can now expand our app to contain any number
    of JavaScript files, and use Webpack to merge them all into one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let’s ensure that those console logs are working. In our `public/index.html`,
    add another script tag below the other three:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the page, open up your console, and you''ll have this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Moving our React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enough of console logs; now, let’s use Webpack to take care of some useful
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete our `index2.js`, and delete all code from `index.js`. Then, copy and
    paste our React code into `index.js`, and delete the first three script tags in
    the `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After doing so, you should have only one script tag in your `index.html` (the
    one for `bundle.js`), and your `index.js` should consist of this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before we run Webpack, though, we have a problem. We deleted the script tags
    that required React and ReactDOM, but we still need a way to access them in our
    `index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can do it in the same way we required `index2.js`, that is, type out `require(‘../node_modules/react/dist/react.js’)`,
    but that’s a lot of typing. Also, we will be using many dependencies from `node_modules`
    in our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fortunately, requiring modules in this way is common, so the `require` function
    is smart enough to grab a dependency based on the name alone, which means we can
    add this to the beginning of our `index.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can then use these packages in our code, just as before!
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let’s try it out. Run Webpack again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can see all the files that Webpack bundles together in our `index.js`:
    React, all its dependencies, and ReactDOM.'
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and you should see that nothing has changed. However, our application
    is now much more scalable, and we can organize our files a lot better. When we
    add a dependency, we no longer need to add another `<script>` tag; we just require
    it in our code where we're using it.
  prefs: []
  type: TYPE_NORMAL
- en: Shortcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typing out that long Webpack command is boring and opens us up to errors potentially
    being made (what if we mistype `bundle.js` and end up generating the wrong file?).
    Let’s simplify that process for our own sanity.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s decide that our `index.js` will be the entry point to our application,
    which means that it will require all the other files in the application (or rather,
    it will require a few files that require a few other files, which require a few
    other files, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, our `bundle.js` will be our output file, where all our bundled code
    goes.
  prefs: []
  type: TYPE_NORMAL
- en: Those two files, therefore, will always be the arguments we give to the Webpack
    command in our Terminal. Since they won’t change, let’s configure Webpack to always
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project folder (not in `src`, but the top-level folder), create a file
    called `webpack.config.js`. In it, put the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We define our entry point as the path to the `index.js` (`__dirname` is a global
    variable which grabs the current directory, that is, wherever we run the command
    `webpack`). We then define our output file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can simply run `node_modules/.bin/webpack` in our Terminal, with no
    arguments, and get the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A good improvement, but we’re developers, so we’re lazy and want to take even
    more shortcuts. Let’s shorten that `node_modules/.bin/webpack` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the cool features of `npm` is the ability to write scripts to perform
    commonly used tasks. Let’s try it out. In our `package.json`, create a scripts
    section; within that, make a script named `build`, with a value of the `node_modules/.bin/webpack`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the Terminal, you can run either `npm run build` or `yarn build`.
    They do the same thing: run the Webpack command and bundle our files!'
  prefs: []
  type: TYPE_NORMAL
- en: Wow, our life is getting easier and easier. Could we be any lazier?
  prefs: []
  type: TYPE_NORMAL
- en: In short, yes.
  prefs: []
  type: TYPE_NORMAL
- en: Our Dev server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to update our code (say, to change our `h1` to `h2`), we’ll have
    to make the change, rerun `yarn build`, and then reload the page for every single
    change we want to see. That’ll slow us down a lot in our development process.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, every time we change our JavaScript, the Webpack command will automatically
    rerun, and will reload the page. What a world of luxury that would be!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s a package called `webpack-dev-server` for exactly this
    purpose. To install it, just run `yarn add webpack-dev-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump in, let’s briefly cover how the Dev Server works. It runs a small
    Node application in the background of our machine, serving up the files in our
    public folder so that we can see them by visiting `localhost:3000` in our browser.
    At the same time, it watches the source files of the `bundle.js`, rebundles them
    when they change, and then reloads the page.
  prefs: []
  type: TYPE_NORMAL
- en: To get it to work, we need to specify which folder we want to serve up (public),
    and then do some basic configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `webpack.config.js`, add the following before the closing squiggly bracket
    (we have the full code here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`contentBase` does this, setting `public` as the folder to serve, `historyApiFallback`
    lets our single-page app seem like a multipage app, and `inline` is the bit that
    automatically refreshes the page on file changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let’s try it. First, we’ll add a new script to our `package.json`, called
    `start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will run our Dev Server (ensure that you ran `yarn add webpack-dev-server`
    first). In your Terminal, type in **`yarn start`**. You’ll see our Webpack compile,
    and a notice that our app is running on port `8080`. Let’s hop over to `http://localhost:8080`
    in our browser and we should see our application.
  prefs: []
  type: TYPE_NORMAL
- en: The last test is to change the text in our `index.js` from `Hello from React`
    to `Hello from Webpack!`. Your browser tab should automatically reload and reflect
    the changes, without you having to rerun the Webpack command.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re about to step into the future.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this book, we’ve been using JavaScript in its old form. The language
    recently (in 2015) got a facelift, with a smattering of conveniences and new functionalities
    added. This new release is called **ECMAScript 2015**, or **ES6** for short. It’s
    much more enjoyable to use than older JavaScript (ES5), but there’s a problem.
  prefs: []
  type: TYPE_NORMAL
- en: All internet browsers are perfectly capable of running JavaScript, but many
    users are using older browsers that are not yet capable of running ES6\. So, as
    developers, we want to use ES6, but how can we do so and still have our website
    work on older browsers?
  prefs: []
  type: TYPE_NORMAL
- en: The key is that ES6 doesn’t do much that ES5 couldn’t do, it just makes it easier
    to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, looping through an array was done like this previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An older browser understands the first one, but not the second, but the code
    does the same thing. So, all we need to do is convert the second code snippet
    into the first. This is where Babel comes in. **Babel** is a transpiler tool for
    JavaScript; think of it as a translator. We give it our beautiful ES6 code, and
    it converts it into uglier but more browser-friendly ES5 code.
  prefs: []
  type: TYPE_NORMAL
- en: We will stick Babel into our Webpack build process so that when we bundle all
    our JavaScript files, we also transpile them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we will install Babel, along with a bunch of plugins and add-ons
    for it to make it play nice with React. Stop your Dev server, and then run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Yikes, that’s a lot of packages all at once! The important one for the next
    step is `babel-loader`. This is a Webpack loader, and we use it to grab (and then
    transpile) our JavaScript files before passing them to Webpack for bundling. Let’s
    plug it into Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `webpack.config.js`, make a module object with a loaders array within
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then, we can define our loader inside the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make an object with four keys: test, exclude, loader, and query:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test** is what the loader will use to determine which files it should transpile.
    For Babel, we want to run on all JavaScript files, so our test will be for the
    files ending with `.js`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Exclude** is what not to run on. We can skip our entire `node_modules` folder,
    since the packages are already in ES5:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Loader** is what our loader is called:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll use **query** to define our presets (what Babel will use to
    transpile the JavaScript):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the full file should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run **`yarn start`** and look for errors. If there aren’t any, we can take it
    for a test drive and write some ES6 code.
  prefs: []
  type: TYPE_NORMAL
- en: Our first ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s open up our `src/index.js` and see how we can spice it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can replace our `require` calls with the new `import` syntax. It
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It's a little cleaner, and it lets us do some cool stuff, which we’ll see later.
  prefs: []
  type: TYPE_NORMAL
- en: Do that for both React and ReactDOM, and then we can finally replace our `React.createElement`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: As you may guess, it would be very unwieldy to build a complex UI by calling
    `React.createElement` for every HTML element we need. We want the power and functionality
    of JavaScript, but with the readability of HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Enter JSX; **JSX** is a type of syntax that looks like HTML, but is actually
    JavaScript underneath. In other words, it compiles down to `React.createElement`,
    just as our ES6 JavaScript will compile into ES5.
  prefs: []
  type: TYPE_NORMAL
- en: It has some gotchas as well, since it’s not true HTML, but we’ll get there.
    The last thing to note is that JSX makes some developers very uncomfortable; they
    say it looks odd to have HTML inside JavaScript. I don’t agree, personally, but
    it's an opinion thing. Whatever your aesthetic stance, JSX offers a lot of convenience,
    so let’s try it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply convert our line of code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Run `yarn start` (or, if it’s already running, it should automatically refresh).
    If Babel is working correctly, nothing should change. Our first JSX is done!
  prefs: []
  type: TYPE_NORMAL
- en: We will, of course, work much more with JSX, looking at how it differs from
    HTML, and what advantages it offers to us as developers. However, for now, let’s
    make our lives even easier.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To organize our app a bit better (and to do some magic in the next section),
    let’s move our JSX into a separate file from our `ReactDOM.render`. This will
    ensure good separation of concerns throughout our file structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to `index.js`, in our `src` folder, create a file called `App.js`. Inside,
    we’ll just make a function called `App`, which returns our JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note the `export` statement at the bottom; this means when we import our file,
    we’ll automatically get this function as the default import. We'll see an example
    of non-default imports down the line, which will make this clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we jump back to `index.js`, we can now import `App` from `''./App’`. Then,
    we render it, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are using it just like an HTML (or rather, JSX) tag. We’ll talk
    more about why in the coming chapters; for now, the important thing is that our
    app is a bit more organized, with our view logic (the JSX) separate from the render
    logic (`ReactDOM.render`).
  prefs: []
  type: TYPE_NORMAL
- en: Hot reloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have achieved some pretty big wins for our development process. There’s one
    more convenience I want to add before we move deeper into Webpack configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an application that consists of a form that pops up in a modal when
    a user clicks on an Edit button. When you reload the page, that modal is closed.
    Now, imagine that you’re the developer trying to fine-tune that form. Your Dev
    server is reloading the page after every tweak, forcing you to reopen the modal.
    This is mildly annoying in this case, but think about something like a browser
    game, where getting back to where you were requires several clicks.
  prefs: []
  type: TYPE_NORMAL
- en: In short, we need a way to reload our JavaScript while still preserving the
    current state of the application, without reloading the page itself; this is called
    **hot reloading**. We use Webpack to swap out the bits of our UI that have changed,
    without reloading everything.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, we will use *Dan Abramov’s* `react-hot-loader` package. Let’s
    install it and see how we will configure Webpack to play nicely with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install, type `yarn add react-hot-loader@3.0.0`. At the time of writing,
    version 3 is still in beta; if yarn prompts you to select a beta version of 3.0,
    pick the latest (for me, I chose beta.7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To get it working, we need to do four things:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn on Webpack’s own hot module replacement plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use React Hot Loader as an entry point to our app so that Webpack looks to it
    for source files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect React Hot Loader to Babel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on hot reloading with our Dev Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Installing Webpack’s `HMR` plugin is actually quite easy. In our `webpack.config.js`,
    first require Webpack at the top of the file so that we can access the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our Webpack file is not processed by Babel, so we will still use `require` instead
    of `import`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, above our `devServer` key, add a new key called `plugins`, with an array
    as the value, which includes `new webpack.HotModuleReplacementPlugin()` as the
    only item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Restart your server to check for errors, and then move on to step 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, our `index.js` is our entry point for Webpack; it executes the code
    in that file and derives from the bundle of the files used in that execution.
    We want to execute the `react-hot-loader` package first. Let’s modify our entry
    key to be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it work with our Dev server, we need to add a bit more code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This configuration means that Webpack will execute the code in these paths before
    moving on to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Again, try restarting your server. If there is an error, check for typos; otherwise,
    onward!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to add a Babel plugin so that our hot reloaded files are compiled
    with `babel-loader`. Just update our Babel configuration, as shown, using the
    Babel plugin included in `react-hot-loader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to turn on hot reloading with our Dev Server; do so by adding
    a `hot: true` to our `devServer` config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last step, we need to add a bit of code to our `index.js`. Add the following
    to the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code basically sends a new version of our app to `ReactDOM.render`
    when the files change.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s give it a shot. Restart your server, and then open up `localhost:8080`.
    Try editing the text `Hello from React!`, and watch as the HTML updates without
    the page ever reloading; neat.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hot Module Replacement** will make our lives much easier, especially once
    we start building our app with different states--states that reloading the page
    will reset.'
  prefs: []
  type: TYPE_NORMAL
- en: Building for production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve been entirely focused on using Webpack in a development context,
    but we also need to think about deploying our app to production, and what that
    may involve.
  prefs: []
  type: TYPE_NORMAL
- en: When we send our app out to the World Wide Web, we don’t want to send anything
    unnecessary (remember that our goal is performance); we want to deploy the bare
    minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: An `index.html` page (minified)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CSS file (minified)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JavaScript file (minified)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All image assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An asset manifest (a list of the preceding static files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have some of these, but not all. Let’s work on using Webpack to automatically
    generate a `build` folder with all of these, which we can deploy later.
  prefs: []
  type: TYPE_NORMAL
- en: First, a minified `index.html`. We want Webpack to take our `public/index.html`
    file, minify it, add the appropriate script and CSS links automatically, and then
    add that to a `build` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Since our Webpack process for production will be different from development,
    let’s make a duplicate of our `webpack.config.js` and name it `webpack.config.prod.js`.
    For most of the rest of the chapter, we’ll work with `webpack.config.prod.js`,
    not `webpack.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, delete the `devServer` key from `webpack.config.prod.js`.
    We won''t use a Dev server in production, nor will we use hot reloading. We need
    to delete the two `devServer` specific lines under `entry`, and the hot reloading
    line, so that it now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, inside our `webpack.config.prod.js`, let’s specify that our output folder
    is now `chatastrophe/build` by changing this line under output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It needs to be changed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also want to add a `publicPath`, so our `index.html` in `build` will
    know to look for the bundled JavaScript in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set our environment to production so that React doesn''t display its
    (helpful, in development) warnings. We can also remove `HotModuleReplacementPlugin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will use a new Webpack plugin, called `HtmlWebpackPlugin`. It does
    what it sounds like--packs down HTML for us! Let’s install it with `yarn add html-webpack-plugin`,
    and then add it with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t forget to require it at the top of `webpack.config.prod.js`, just like
    we required Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to give it a test! In your `package.json`, update our build script to
    use our new config, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Then, run `yarn build`.
  prefs: []
  type: TYPE_NORMAL
- en: You should see a `build` folder appear in your project directory. If you open
    `build/index.html`, you’ll see that it’s nice and mushed together. However, there’s
    a problem; in that squashed code, you should see two script tags, both requiring
    `bundle.js`*.*
  prefs: []
  type: TYPE_NORMAL
- en: That is the result of the `inject` option we specified earlier with `HtmlWebpackPlugin`.
    The plugin adds the script tag for us! How convenient, except that we already
    added it in `public/index.html` ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple solution--let’s copy our `HtmlWebpackPlugin` configuration
    (and require statement) over to `webpack.config.js` (our original configuration
    file). However, we can remove the `minify` key and all its options, since that’s
    not necessary in development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Then, delete the script tag from `public/index.html` and try `yarn start` again
    to test whether our development environment is working, and `yarn build` to test
    our production build.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we have a minified HTML file in our build, and we have improved our development
    start process a bit as well. The next task is to ensure that our CSS is minified
    and copied into our build folder as well.
  prefs: []
  type: TYPE_NORMAL
- en: In our webpack configuration (both production and development), we used `babel-loader`
    to load our JavaScript files in; we will do something similar with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will combine two loaders: `css-loader` and `style-loader`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about why it’s recommended to use both on the style-loader
    GitHub page at [https://github.com/webpack-contrib/style-loader](https://github.com/webpack-contrib/style-loader).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install both with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add them to both our `webpack.config.prod.js` and `webpack.config.js`,
    by adding the following code under our `babel-loader` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'What these plugins do is take a CSS file required by our React code and turn
    it into a `<style>` tag injected into our HTML. Right now, that won’t do much
    for us, since our CSS is sitting in our `public`/`assets` folder. Let’s move it
    to `src`, then require it in `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can delete our link tag from our `public/index.html` and restart our
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect the head of our HTML in our browser, we should see a `<style>`
    tag with all our CSS inside. Neat!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, you may notice when we refresh the page, that there’s a flash of unstyled
    content; this is a consequence of our app now requiring React to boot up before
    adding styling. We’ll address that issue in the coming chapters, rest assured.
  prefs: []
  type: TYPE_NORMAL
- en: Run `yarn build` and take a look at `bundle.js`. If you search for "Start initial
    styles" you’ll see where our CSS is bundled in our JavaScript. Also, note how
    relatively readable our JavaScript is compared to our HTML. The next step is to
    take care of minifying it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, doing so is quite easy. We just add another Webpack plugin to
    our `production` file. After `HtmlWebpackPlugin`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Run `yarn build` again, and you should see that our `bundle.js` has become a
    single line. This is not great for humans, but much faster for the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we're getting closer to the end. Next, we want to ensure that all our
    asset files get copied over to our `build` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do so by adding another loader to our Webpack config, called `file-loader`.
    We’ll install it with `yarn add file-loader@0.11.2`. Let’s see what the code looks
    like (note that this is only for our `webpack.config.prod.js` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’re excluding HTML, CSS, JSON, and JS files. These are covered by
    our other loaders, so we don’t want to duplicate files.
  prefs: []
  type: TYPE_NORMAL
- en: We’re also putting these assets in a `static` folder, just like our `assets`
    folder in our `public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: However, `file-loader` will only apply to those files required by our JavaScript
    code. We have our favicon and icon, which are currently only used in our `index.html`,
    so Webpack won't find them.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we will use JavaScript instead of Webpack (since Webpack focuses only
    on our `src` folder).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make a new folder in the root of your directory and name it `scripts`. Inside,
    make a file called `copy_assets.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In here, we will copy everything in `public` to `build`, excluding our `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: To do this (you guessed it), we need one more package; run `yarn add fs-extra`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, require it inside `copy_assets.js`, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`fs-extra` is a package used for manipulating files in a Node environment.
    It has a method called `copySync`, which we''ll use here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is rather straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This says copy everything in the `public` folder to the `build` folder, except
    the `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a `bundle.js` in your `public` folder from our previous Webpack
    config, you can delete it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to run this command whenever we build, add it to the build script in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It's a good idea to put the `copy_assets` command before our Webpack command,
    just to ensure that we don't accidentally copy any JavaScript assets in `public`
    without transpiling them.
  prefs: []
  type: TYPE_NORMAL
- en: Making an asset manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the last step, we want a list of all the static assets that we’re generating.
    This will be useful down the line, once we start caching them to save load times.
    Fortunately, it’s an easy step, another plugin!
  prefs: []
  type: TYPE_NORMAL
- en: '`yarn add webpack-manifest-plugin` and add it to `webpack.config.prod.js`,
    under plugins, with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Okay, let’s try it all together. Run **`yarn build`** and then open `index.html`
    in the browser. It should look exactly the same as running **`yarn start`**. You
    should also see an `index.html`, a `bundle.js`, an `asset-manifest.json`, and
    an `assets` folder in our `build` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whew! That was a lot of configuration. The good news is that now we are completely
    ready to start writing React, and build our application. That's what we'll move
    on to next!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered everything to do with Webpack, adding in a bunch
    of convenient features to speed up our development. In the next chapter, we'll
    start the development process, and begin constructing our React application. This
    is where the fun begins!
  prefs: []
  type: TYPE_NORMAL
