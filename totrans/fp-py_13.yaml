- en: Chapter 13. Conditional Expressions and the Operator Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming emphasizes lazy or non-strict ordering of operations.
    The idea is to allow the compiler or runtime to do as little work as possible
    to compute the answer. Python tends to impose strict ordering on evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we used the Python `if`, `elif`, and `else` statements. They're
    clear and readable, but they imply a strict ordering on the evaluation of the
    conditions. We can, to an extent, free ourselves from the strict ordering here,
    and develop a limited kind of non-strict conditional statement. It's not clear
    if this is helpful but it shows some alternative ways to express an algorithm
    in a functional style.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this chapter will look at ways we can implement non-strict
    evaluation. This is a tool that's interesting because it can lead to performance
    optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we looked at a number of higher-order functions. In
    some cases, we used these higher-order functions to apply fairly sophisticated
    functions to collections of data. In other cases, we applied simple functions
    to collections of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, in many cases, we wrote tiny `lambda` objects to apply a single Python
    operator to a function. For example, we can use the following to define a `prod()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the `lambda x,y: x*y` parameter seems a bit wordy for multiplication.
    After all, we just want to use the multiplication operator, `*`. Can we simplify
    the syntax? The answer is yes; the `operator` module provides us with definitions
    of the built-in operators.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of features of the `operator` module that lead to some simplification
    and potential clarification to create higher-order functions. While important
    conceptually, the `operator` module isn't as interesting as it initially appears.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating conditional expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python imposes relatively strict ordering on expressions; the notable exceptions
    are the short-circuit operators, `and` and `or`. It imposes very strict ordering
    on statement evaluation. This makes it challenging to find different ways to avoid
    this strict evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that evaluating condition expressions is one way in which we can
    experiment with non-strict ordering of statements. We'll examine some ways to
    refactor the `if` and `else` statements to explore this aspect of non-strict evaluation
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `if`, `elif`, and `else` statements are evaluated in a strict order
    from first to last. Ideally, a language might relax this rule so that an optimizing
    compiler can find a faster order for evaluating the conditional expressions. The
    idea is for us to write the expressions in an order that makes sense to a reader,
    even if the actual evaluation order is non-strict.
  prefs: []
  type: TYPE_NORMAL
- en: Lacking an optimizing compiler, this concept is a bit of a stretch for Python.
    Nonetheless, we do have alternative ways to express conditions that involve the
    evaluation of functions instead of the execution of imperative statements. This
    can allow you to make some rearrangement at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python does have a conditional `if` and `else` expression. This expression
    form can be used when there''s a single condition. When we have multiple conditions,
    however, it can get awkwardly complex: we''d have to carefully nest the subexpressions.
    We might wind up with a command, as follows, which is rather difficult to comprehend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use dictionary keys and the `lambda` objects to create a very complex
    set of conditions. Here''s a way to express the factorial function as expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This rewrites the conventional `if`, `elif`, `elif`, and `else` sequence of
    statements into a single expression. We've decomposed it into two steps to make
    what's happening slightly clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we''ll evaluate the various conditions. One of the given
    conditions will evaluate to `True`, the others should all evaluate to `False`.
    The resulting dictionary will have two items in it: a `True` key with a `lambda`
    object and a `False` key with a `lambda` object. We''ll select the `True` item
    and assign it to the `f` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: We used lambdas as the values in this mapping so that the value expressions
    aren't evaluated when the dictionary is built. We want to evaluate just one of
    the value expressions. The `return` statement evaluates the one expression associated
    with the `True` condition.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting non-strict dictionary rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dictionary's keys have no order. If we try to create a dictionary with multiple
    items that share a common key value, we'll only have one item in the resulting
    `dict` object. It's not clear which of the duplicated key values will be preserved,
    and it shouldn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a situation where we explicitly don''t care which of the duplicated
    keys is preserved. We''ll look at a degenerate case of the `max()` function, it
    simply picks the largest of two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the case where `a == b`, both items in the dictionary will have a key of
    the `True` condition. Only one of the two will actually be preserved. Since the
    answer is the same, it doesn't matter which is kept and which is treated as a
    duplicate and overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering true conditional expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a number of ways of determining which expression is `True`. In the previous
    example, we loaded the keys into a dictionary. Because of the way the dictionary
    is loaded, only one value will be preserved with a key of `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another variation to this theme, written using the `filter()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We defined the alternatives as a sequence of `condition` and `function` pairs.
    When we apply the `filter()` function using the `itemgetter(0)` parameter, we'll
    select those pairs with a `True` condition. Of those which are `True`, we'll select
    the first item in the iterable created by the `filter()` function. The selected
    condition is assigned to the `c` variable, the selected function is assigned to
    the `f` variable. We can ignore the condition (it will be `True`), and we can
    evaluate the `filter()` function.
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous example, we used lambdas to defer evaluation of the functions
    until after the conditions have been evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `semifact()` function is also called **double factorial**. The definition
    of the semifactorial is similar to the definition of factorial. The important
    difference is that it is the product of alternate numbers instead of all numbers.
    For example, take a look at the following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering true conditional expressions](graphics/B03652_13_01.jpg) , and
    ![Filtering true conditional expressions](graphics/B03652_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the operator module instead of lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using the `max()`, `min()`, and `sorted()` functions, we have an optional
    `key=` parameter. The function provided as an argument value modifies the behavior
    of the higher-order function. In many cases, we used simple lambda forms to pick
    items from a tuple. Here are two examples we heavily relied on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These match built-in functions in other functional programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: We don't really need to write these functions. There's a version available in
    the `operator` module which describes these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some sample data we can work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is the annual cheese consumption. We used this example in [Chapter 2](ch02.html
    "Chapter 2. Introducing Some Functional Features"), *Introducing Some Functional
    Features* and [Chapter 9](ch09.html "Chapter 9. More Itertools Techniques"), *More
    Itertools Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can locate the data point with minimal cheese using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `operator` module gives us an alternative to pick particular elements from
    a tuple. This saves us from using a `lambda` variable to pick the second item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of defining our own `fst()` and `snd()` functions, we can use the `itemgetter(0)`
    and the `itemgetter(1)` parameters, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `itemgetter()` function relies on the special method, `__getitem__()`, to
    pick items out of a tuple (or list) based on their index position.
  prefs: []
  type: TYPE_NORMAL
- en: Getting named attributes when using higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at a slightly different collection of data. Let''s say we were
    working with namedtuples instead of anonymous tuples. We have two ways to locate
    the range of cheese consumption shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use lambda forms or we can use the `attrgetter()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What's important here is that with a `lambda` object, the attribute name is
    expressed as a token in the code. With the `attrgetter()` function, the attribute
    name is a character string. This could be a parameter, which allows us to be considerably
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Starmapping with operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `itertools.starmap()` function can be applied to an operator and a sequence
    of pairs of values. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `itertools.zip_longest()` function will create a sequence of pairs such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It does this because we provided two sequences: the `[]` brackets and the `range(4)`
    parameter. The `fillvalue` parameter will be used when the shorter sequence runs
    out of data.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `starmap()` function, each pair becomes the argument to the
    given function. In this case, we provided the `operator.pow()` function, which
    is the `**` operator. We've calculated values for `[60**0, 60**1, 60**2, 60**3]`.
    The value of the `d` variable is `[1, 60, 3600, 216000]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `starmap()` function is useful when we have a sequence of tuples. We have
    a tidy equivalence between the `map(f, x, y)` and `starmap(f, zip(x,y))` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a continuation of the preceding example of the `itertools.starmap()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've zipped together two sequences of four values. We used the `starmap()`
    function with the `operator.truediv()` function, which is the `/` operator. This
    will compute a sequence of fractions that we sum. The sum is really an approximation
    of ![Starmapping with operators](graphics/B03652_13_03.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simpler version that uses the `map(f, x, y)` function instead of
    the `starmap(f, zip(x,y))` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we effectively converted a base `60` fractional value to base
    `10`. The sequence of values in the `d` variable are the appropriate denominators.
    A technique similar to the one explained earlier in this section can be used to
    convert other bases.
  prefs: []
  type: TYPE_NORMAL
- en: Some approximations involve potentially infinite sums (or products). These can
    be evaluated using similar techniques explained previously in this section. We
    can leverage the `count()` function in the `itertools` module to generate an arbitrary
    number of terms in an approximation. We can then use the `takewhile()` function
    to only use values that contribute a useful level of precision to the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a potentially infinite sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `num` variable is a potentially infinite sequence of numerators, based on
    a factorial function. The `den` variable is a potentially infinite sequence of
    denominators, based on the semifactorial (sometimes called the double factorial)
    function.
  prefs: []
  type: TYPE_NORMAL
- en: To create terms, we used the `map()` function to apply the `operators.truediv()`
    function, the `/` operator, to each pair of values. We wrapped this in a `takewhile()`
    function so that we only take values while the fraction is greater than some relatively
    small value; in this case, ![Starmapping with operators](graphics/B03652_13_05.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: This is a series expansion based on 4 arctan(1)=![Starmapping with operators](graphics/B03652_13_03.jpg).
    The expansion is ![Starmapping with operators](graphics/B03652_13_04.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: An interesting variation to the series expansion theme is to replace the `operator.truediv()`
    function with the `fractions.Fraction()` function. This will create exact rational
    values that don't suffer from the limitations of floating-point approximations.
  prefs: []
  type: TYPE_NORMAL
- en: All of the Python operators are available in the `operators` module. This includes
    all of the bit-fiddling operators as well as the comparison operators. In some
    cases, a generator expression may be more succinct or expressive than a rather
    complex-looking `starmap()` function with a function that represents an operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue is that the `operator` module provides only a single operator, essentially
    a shorthand for `lambda`. We can use the `operator.add` method instead of the
    `add=lambda a,b: a+b` method. If we have more complex expressions, then the `lambda`
    object is the only way to write them.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing with operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll look at one more way that we might try to use the operator definitions.
    We can use them with the built-in `functools.reduce()` function. The `sum()` function,
    for example, can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We created a partially evaluated version of the `reduce()` function with the
    first argument supplied. In this case, it's the `+` operator, implemented via
    the `operator.add()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a requirement for a similar function that computes a product, we
    can define it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This follows the pattern shown in the preceding example. We have a partially
    evaluated `reduce()` function with the first argument of `*` operator, as implemented
    by the `operator.mul()` function.
  prefs: []
  type: TYPE_NORMAL
- en: It's not clear whether we can do similar things with too many of the other operators.
    We might be able to find a use for the `operator.concat()` function as well as
    the `operator.and()` and `operator.or()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `and()` and `or()` functions are the bit-wise `&` and `/` operators. If
    we want the proper Boolean operators, we have to use the `all()` and `any()` functions
    instead of the `reduce()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a `prod()` function, this means that the factorial can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the advantage of being succinct: it provides a single line definition
    of factorial. It also has the advantage of not relying on recursion but has the
    potential of running afoul Python''s stack limit.'
  prefs: []
  type: TYPE_NORMAL
- en: It's not clear that this has any dramatic advantages over the many alternatives
    we have in Python. The concept of building a complex function from primitive pieces
    like the `partial()` and `reduce()` functions, and the `operator` module is very
    elegant. In most cases, though, the simple functions in the `operator` module
    aren't very helpful; we'll almost always want to use more complex lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at alternatives to the `if`, `elif`, and `else` statement
    sequence. Ideally, using a conditional expression allows some optimization to
    be done. Pragmatically, Python doesn't optimize, so there's little tangible benefit
    to the more exotic ways to handle conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how we can use the `operator` module with higher order functions
    like `max()`, `min()`, `sorted()`, and `reduce()`. Using operators can save us
    from having to create a number of small lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the `PyMonad` library to express a functional
    programming concept directly in Python. We don't require monads generally because
    Python is an imperative programming language under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Some algorithms might be expressed more clearly with monads than with stateful
    variable assignments. We'll look at an example where monads lead to a succinct
    expression of a rather complex set of rules. Most importantly, the `operator`
    module shows off many functional programming techniques.
  prefs: []
  type: TYPE_NORMAL
