- en: Continuous Integration and Project Hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](e51bcf25-f258-4c2d-9180-9a3291a2a406.xhtml), *.NET Core Unit
    Testing*, we explored the various unit testing frameworks available for .NET Core
    and C# and later explored in detail the xUnit.net framework. We then moved on
    to the important concepts of data-driven unit tests in [Chapter 5](ef706a31-a272-418d-9706-ed84089d89a4.xhtml), *Data-Driven
    Unit Tests*, which facilitate the creation of unit tests that can be executed
    with data loaded from disparate data sources. In [Chapter 6](0cb02f2e-d71f-48d7-a688-5dec9f56396f.xhtml), *Mocking
    Dependencies*, we explained in details dependencies mocking, where we walked through
    creation of simulated objects using the *Moq framework*.
  prefs: []
  type: TYPE_NORMAL
- en: Effective practice of TDD can assist with providing useful and insightful feedback
    on the quality of the code base of software projects. With continuous integration,
    the process of build automation and code automated tests are taken to the next
    level, allowing development teams to take advantage of the basic and advanced
    features available in cutting edge modern source code version control systems.
  prefs: []
  type: TYPE_NORMAL
- en: Proper continuous integration setup and practice yield a rewarding continuous
    delivery where a software project development process is done in such a way that
    it can be shipped or delivered to production through the life cycle of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the concepts of continuous integration and
    continuous delivery. This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub online project hosting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Git commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring GitHub WebHooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TeamCity continuous integration platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) is a software development practice where
    the source code of software projects is integrated by members of a software development
    team daily into a repository. It is preferably started at an early stage of the
    development process. The code integration is usually carried out by a CI tool
    that performs the verification of the code using an automated build script.'
  prefs: []
  type: TYPE_NORMAL
- en: In a development team, there are often multiple developers working on different
    portions of a project, with the source code of the project hosted in a repository.
    Each developer can have a local version or working copy of the main branch or
    mainline on their computer.
  prefs: []
  type: TYPE_NORMAL
- en: A developer working on a feature will make a change to the local copy, and test
    the code using a set of prepared automated tests to ensure that the code works
    and does not break any existing working functionalities. Once this can be verified,
    the local copy is updated with the latest from the repository. If there are any
    conflicts resulting from the update, these conflicts need to be resolved before
    eventually committing or integrating the work done into the mainline.
  prefs: []
  type: TYPE_NORMAL
- en: The source code repository facilitates adequate versioning of the code base
    of projects, by keeping snapshots and versions of source files also the changes
    made overtime. Developers can revert or checkout an earlier version of commits
    made if necessary. The repository can be hosted locally on the team's infrastructure,
    such as having an onsite **Microsoft Team Foundation Server** or a cloud-based
    repository, such as **GitHub**, **Bitbucket**, and a host of others.
  prefs: []
  type: TYPE_NORMAL
- en: CI workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI requires that a proper workflow be put in place. The first major integral
    part of CI is the setup of a working source code repository. This is needed to
    keep track of all the changes made by the contributors to the project and for
    coordinating the different activities.
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement a robust and effective CI setup, the following areas need
    to be covered and properly set up.
  prefs: []
  type: TYPE_NORMAL
- en: Single source code repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To effectively use the source code repository, all the required files needed
    to successfully build a working version of a project should be put in a single
    source code repository. The files should include the source files, properties
    files, database scripts, and schema, as well as third-party libraries and assets
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Other configuration files can also be put in the repository, especially development
    environment configurations. This will ensure the developers on the project have
    a consistent environment setup. New members of the development team can easily
    set up their environment, using the configuration available in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Build automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build automation step of the CI workflow is to ensure that changes in the
    a project's code base are detected and automatically tested and built. The build
    automation is usually done with the help of build scripts, which analyze the changes
    to be made and the compilation needed to be done. The source code should be regularly
    built, preferably daily or nightly. The success of a commit is measured based
    on if the code base has been successfully built.
  prefs: []
  type: TYPE_NORMAL
- en: The build automation scripts should be able to build the system with or without
    the tests. This should be configurable in the build. Irrespective of whether the
    developer's IDEs have in-built build management in place, there should be a central
    build script configured on the server to ensure the project can be built and easily
    run on the development server.
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code base should have automated tests that cover a large percentage of possible
    test combinations using relevant test data. The automated tests should be developed
    using a suitable test framework that can cover all tiers or parts of the software
    project.
  prefs: []
  type: TYPE_NORMAL
- en: With proper automation tests in place, bugs in the source code can be easily
    detected when the automation build script runs. Integrating automated tests into
    the build process will ensure that good test coverage and reports of failing or
    passing tests are provided to facilitate refactoring of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Identical test and production environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to have a smooth CI experience, it is important to ensure that the
    test and production environments are identical. Both environments should have
    similar hardware and operating system configurations, as well as environment setup.
  prefs: []
  type: TYPE_NORMAL
- en: Also, for applications that use databases, both the test and production environments
    should have the same versions. The runtimes and libraries should also be similar.
    However, sometimes it might not be possible to test in every instance of the production
    environment, such as desktop applications, but you must ensure that a replica
    of the production environment is used in testing.
  prefs: []
  type: TYPE_NORMAL
- en: Daily commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The overall health of the code base is determined by the successful build process
    run. The project's mainline should be regularly updated with commits from the
    developers. It is the responsibility of the developer making commits to ensure
    that the code is tested before pushing to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where a commit from the developer breaks the build, this should not
    be procrastinated. A rollback can be done to fix the issue in isolation before
    committing the changes again. The projects mainline or main branch should always
    be in good health. Daily commits of changes is usually preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incorporating CI into development process can be greatly valuable to a development
    team. The CI process provides numerous benefits, some of which are explained next.
  prefs: []
  type: TYPE_NORMAL
- en: Quick bugs detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a CI process in place, automated tests are run frequently and bugs can
    be discovered on time and fixed, yielding a robust system of high quality. CI
    will not automatically eliminate the bug in the system; developers must strive
    to write clean code that is well tested. However, CI can facilitate the timely
    detection of bugs that otherwise would have crept into production.
  prefs: []
  type: TYPE_NORMAL
- en: Improved productivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A development team's overall productivity can be enhanced through CI as developers
    are freed from mundane or manual tasks, which would have been automated as part
    of CI the process. Developers can focus on the important tasks of developing the
    system's features.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced risks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, due to inherent complexities, software projects tend to overshoot
    budgets and timelines due to underestimation of requirements and other issues.
    CI can assist in reducing the risks associated with software development. With
    frequent code commits and integration, a clearer picture of the state of the project
    can be established and any potential issue can be easily isolated and dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: Facilitating continuous delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a development team that uses CI, continuous or frequent deployment becomes
    relatively easy. This is because new features or requirements can be quickly delivered
    and shipped. This will allow the users to provide adequate and useful feedback
    on the product, which can be used to further refine the software and increase
    the quality.
  prefs: []
  type: TYPE_NORMAL
- en: CI tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are quite a number of CI tools available, each with different features
    that facilitate easy CI and provide a good structure for the deployment pipeline.
    The choice of a CI tool depends on several factors, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The development environment, program language, frameworks, and application architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development team's composition, level of experience, skills, and capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment environment setup, operating system, and hardware requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the popular and most used CI tools are explained next. These CI tools,
    when effectively used, can assist a development team in achieving quality standards
    in software projects.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Team Foundation Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft **Team Foundation Server** (**TFS**) is an integrated server suit
    containing a set of collaborative tools to increase the productivity of software
    development teams. TFS provide tools that can integrate with IDEs, such as **Visual
    Studio**, **Eclipse**, and many more IDEs and code editors.
  prefs: []
  type: TYPE_NORMAL
- en: TFS provides sets of tools and extensions that facilitate a smooth CI process.
    Using TFS, the process of building, testing, and deploying applications can be
    automated. TFS provides great flexibility by supporting wide ranges of programming
    languages and source code repositories.
  prefs: []
  type: TYPE_NORMAL
- en: TeamCity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TeamCity** is an enterprise level CI tool by JetBrains. It has support for
    a bundled .NET CLI and, similar to TFS, it provides support for automated deployment
    and composite builds. TeamCity can verify and run automated tests on the server
    before the code is committed through the plugins available for IDEs.'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jenkins** is an open source CI server that can be run as a standalone or
    in a container, or installed through native system packages. It is self-contained
    and capable of automating testing, build related tasks, and application deployment.
    Through a set of chain-tools and plugins, Jenkins can integrate with IDEs and
    source code repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous delivery** is a sequel or an extension of CI. It is a set of software
    development practices that make sure that a project''s code can be deployed to
    a test environment that is identical to the production environment. Continuous
    delivery ensures that all changes are up-to-date and can be shipped and deployed
    to production, immediately once the changes have passed the automated tests.'
  prefs: []
  type: TYPE_NORMAL
- en: It is widely known that practicing CI will facilitate good communication among
    team members and can eliminate potential risks. Development teams need to take
    this a step further by practicing continuous delivery to ensure that their development
    activities are beneficial to customers. This can be made possible by ascertaining
    that the application is deployable and production-ready at any stage of the development
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Through effective communication and collaboration of members of a development
    team, continuous delivery can be achieved. This requires that the major parts
    of the application delivery process are automated through a developed and refined
    deployment pipeline. At any point in time, the application being developed should
    be deployable. The product owner or the customer will determine when the application
    is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of continuous delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through continuous delivery, a software development team's productivity can
    be improved while also reducing the cost and turnaround time of releasing software
    applications into production. The following are the reasons why your team should
    practice continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Lower risks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to CI, continuous delivery assists in lowering risks usually associated
    with software releases and deployment. This can ensure zero downtime and an application's
    high availability because the frequent changes made are regularly integrated and
    production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Quality software products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software products are readily made available to the end users due to the automation
    of the testing, build, and deployment process. Users will be able to give useful
    and valuable feedback that can be used to further refine and improve the quality
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced costs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software project development and release costs can be greatly reduced, due to
    automation of the different parts of the development and deployment processes.
    This is because costs associated to incremental and continuous changes are eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub online project hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GitHub** is a source code hosting platform for version control that allows
    development team members to collaborate and work on software projects, irrespective
    of their geographical location. GitHub currently houses several open source and
    proprietary projects in different programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub provides basic and advanced features that make collaboration easier.
    It is essentially a web-based source code repository or hosting service using
    Git as the version control system, based on Git's distributed versioning behavior.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to know that top companies such as **Microsoft**, **Google**,
    **Facebook**, and **Twitter** host their open source projects on GitHub. Basically,
    any CI tool can be used with GitHub. This gives development teams the flexibility
    to choose CI tools based on their budgets, working with GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the source code hosting service provided by GitHub, public web
    pages can also be hosted through GitHub for free. This feature allows GitHub users
    to create personal websites that are related to the open source projects being
    hosted.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub supports both public and private project repository hosting. Anyone can
    see the files and the commit history of a public repository, while private repository
    access is restricted to only the added members. Private repository hosting on
    GitHub comes with a cost.
  prefs: []
  type: TYPE_NORMAL
- en: Project hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a project repository and have access to GitHub's features, you need
    to first create a GitHub account. This can be done by navigating to [https://github.com](https://github.com).
    Upon a successful account creation, you can proceed to create a project repository.
  prefs: []
  type: TYPE_NORMAL
- en: A GitHub repository is used to organize project folders, files, and assets.
    The files can be images, videos, and source files. It is a common practice in
    GitHub for a repository to have a `README` file that contains a concise description
    of the project. Optionally, a software license file can be added to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps describes how to create a new repository in GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to GitHub with the account created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to [https://github.com/](https://github.com/) new or from the upper-right
    corner of the screen, next to the account's avatar or profile picture, click on
    the + icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A drop-down menu is displayed where you can select New repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cae41656-4b6d-42cb-95b1-463cdab802b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Name the repository `LoanApplication` and provide a project description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Public, to make the repository publicly accessible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Initialize this repository with a README, to include a `README` file
    in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, click on Create repository, to create and initialize the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1783a922-7346-4ca5-bd3f-e8f17e64633c.png)'
  prefs: []
  type: TYPE_IMG
- en: Branching with GitHub Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub has a branch-based workflow known as **GitHub Flow**, with great supports
    and tools for development teams to collaborate and frequently deploy projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Flow facilitates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating branches from a new or existing repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, editing, renaming, moving, or deleting files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a pull request from branches based on agreed changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making changes on a branch as needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging pull requests when a branch is ready to be merged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Housekeeping and cleaning up branches by using the delete button in the pull
    request or on the branches page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating branches from a project is core to Git and is an extension to GitHub,
    which is the central concept of GitHub Flow. **Branches** are created to try out
    new concepts, and ideas or for working on a feature fix. A branch is a different
    version of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new branch, the usual practice is to create the branch off the
    master branch. This will create a copy of all the files and configurations contained
    in the master at that time. The branch is technically independent of the master
    as changes made on a branch do not affect the master branch. However, new updates
    can be pulled from the master to the branch and changes made on the branch can
    be merged back to the master.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram on GitHub, further explains the GitHub flow of the project
    branch, where committed changes to a branch are merged to the master through a
    pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fc03b93-395a-45ac-af19-8d52984d823c.png)'
  prefs: []
  type: TYPE_IMG
- en: The master branch must always be deployable at any time. Changes on created
    branches should only be merged to the master branch after a pull request has been
    opened. The changes will later be carefully reviewed and accepted after passing
    the necessary validation and automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new branch from the `LoanApplication` repository created earlier,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the dropdown located at the top of the file list with the caption Branch:
    master.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type a descriptive branch name that provides meaningful information about the
    branch in the new branch text box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the highlighted link with the branch name supplied to create the branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec790570-c4e7-4972-910e-f1777864c909.png)'
  prefs: []
  type: TYPE_IMG
- en: For now, the newly created branch and the master branch are exactly the same.
    You can begin to make changes to the created branch, by adding and modifying source
    files. Changes are committed directly to the branch and not the master.
  prefs: []
  type: TYPE_NORMAL
- en: Committing changes facilitates the proper tracking of changes made to the branch
    over time. A commit message is provided every time changes are to be committed.
    The commit messages provide a detailed description of what the changes are about.
    It is important to always provide commit messages because Git tracks changes using
    commits. This can facilitate easy collaboration on a project, with the commit
    messages providing a history of the changes made.
  prefs: []
  type: TYPE_NORMAL
- en: In the repository, each commit is a distinct unit of change. If the working
    code base breaks as a result of a commit, or the commit introduces a bug, the
    commit can be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: Pull request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Irrespective of whether the changes you made to the code base are small or large,
    you can initiate a pull request at any time during the project development process.
    Pull requests are central to collaboration in GitHub as these facilitate the discussion
    and review of commits made.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open a pull request, click the New pull request tab. You will be taken to
    the pull request page, where you can provide a comment or description for the
    request, and click the New pull request button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fee4803-9d87-4e08-afdc-6432e1c79df4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you open a pull request, the owners or maintainers of the project are
    notified about the pending changes and your intention to have a merge. Necessary
    feedback can be provided to further refine the code after an appropriate review
    has been done on the changes made to the branch. The pull request shows the differences
    of the files and contents of your branch and the master branch. If the contributions
    made are deemed to be okay, they will be accepted and merged to the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c82db3eb-38cd-403a-a9d8-cceb8bd5d7aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Reviewing changes and merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a pull request has been initiated, the changes are reviewed by the participating
    team members and comments are provided based on the current position of the repository.
    You can continue to make changes while a pull request is open, and any comments
    associated with the review will be shown on the unified pull request view. Comments
    are written in markdown and contain pre-formatted text blocks, images, and emoji.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the pull request has been reviewed and accepted, they will be merged into
    the master branch. The following steps can be followed to merge requests in GitHub.
    Click the Merge pull request button to merge the changes into master. Then click
    Confirm merge, which will merge the commits on the branch to the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad16d568-f7cf-4473-88e2-7fd68cbedbca.png)'
  prefs: []
  type: TYPE_IMG
- en: A history of pull requests are kept in GitHub and can be searched later on to
    determine why the pull requests were initiated while providing access to the review
    done and the comments added.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Git commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is a **distributed version control system** (**DVCS**). The branching system
    of Git is very robust and makes it stand out among other version control systems.
    Using Git, several branches of a project can be created, independent of each other.
    The process of creation, merging, and deletion of branches are seamless and very
    fast.
  prefs: []
  type: TYPE_NORMAL
- en: Git greatly supports the concept of frictionless context switching, where you
    can easily create a branch to explore your ideas, create and apply patches, make
    commits, merge the branches, and later switch back to the earlier branch you were
    working on. The branching workflow being used will determine whether to create
    a branch for each feature or group of features, while easily switching between
    the branches to test the features.
  prefs: []
  type: TYPE_NORMAL
- en: Your development can get organized and be productive with Git, by having different
    branches for your production, test, and development, thereby controlling the flow
    of files and commits that go into each branch. By having a good repository structure,
    you can easily and quickly experiment with new ideas and delete the branches when
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Git has a rich set of useful commands that when mastered provide full access
    to its internals and allow basic and advanced source code versioning operations.
    Git provides command line interface and graphical user interface clients for the
    Windows, Macintosh, and Linux operating systems. The commands can be run from
    the Terminal on Mac and Linux, while in Windows there is Git Bash, an emulator
    used to run Git from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The available commands on Git are used to perform the initial setup and configuration
    of the source code repository, sharing and updating projects, branching and merging,
    as well as various source code versioning related operations.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a set of commands that can be used to configure user information that
    cut across all local repositories on the computer where Git is installed. The `git
    config` command is used to get and set global repository options. It accepts the `--global`
    option which is followed by the specific configuration to get or set entries from
    the global `.gitconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the global username that will be attached to all commit transactions,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The global user email address can also be set. This will attach the set email
    address to all commit transactions. Run the following command to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For good aesthetics, you can enable colorization of the command line output,
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Initializing repository commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git init` command is used to create an empty Git repository as well as
    to reinitialize an existing repository. When the `git init` command is run, a
    `.git` directory is created alongside sub-directories to hold objects, `refs/heads`,
    `refs/tags`, template files, and an initial HEAD file, which references the HEAD
    of the master branch. In its simplest form, the `git init` command passes the
    repository name, and this creates a repository with the specified name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To update and pick newly added templates or relocate a repository to another
    location, `git init` can be rerun in an existing repository. The command will
    not overwrite the configurations already in the repository. The full `git init`
    command synopsis is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the preceding command in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-q` or `--quiet` option when used will print errors and warning messages
    while other output messages are suppressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--bare` option is used to create a bare repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--template=<template_directory>` is used to specify the folder where the templates
    will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--separate-git-dir=<git dir>` is used to indicate the directory or path to
    the repository, or the path to move the repository to, in case of re-initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--shared[=(false|true|umask|group|all|world|everybody|0xxx)]` is the option
    is used to notify Git that the repository is to be shared among many users. Users
    that are in the same group can push into the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `git clone` command, the existing repository can be cloned into a
    new directory. The command creates remote-tracking branches for all the branches
    in the cloned repository. It will download the project and its entire version
    history. The `git clone` command can simply be used by passing the URL of the
    repository as an option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The URL passed to the command will contain information of the transport protocol,
    the address of the remote server, and the repository path. The protocols Git supports
    are SSH, Git, HTTP, and HTTPS. The command has other options that can be passed
    to it, to configure the repository to be cloned.
  prefs: []
  type: TYPE_NORMAL
- en: Change commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git has a set of useful commands that are used to check the status of files
    in the repository, review updates made to the files, and commit changes made to
    the project files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git status` command is used to show the working status of the repository.
    The command essentially gives a summary of the files that have changed and are
    staged for the next commit. It displays the paths of the files that have differences
    between the current HEAD commit and the index file. It also displays the paths
    of the files that have differences between the index file and the working tree
    as well as paths of the files that are not currently being tracked by Git but
    have not been added in the `.gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `git add` command uses the content found in the working tree to update the
    index. It basically adds file content to the index. It is used to add the current
    content of existing paths. It can be used to remove paths that no longer exist
    in the tree or add content with the part of the changes made to the working tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The practice is usually to run the command several times before performing
    a commit. It adds the content of the files as it was at the time when the command
    was run. It takes options that are used for tweaking its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `git commit` command is used to record or store the content of the index
    in a commit together with the commit message supplied by the user to describe
    the changes made to the project files. The changes must have been added, using
    `git add`, before the command is run.
  prefs: []
  type: TYPE_NORMAL
- en: The command is flexible and the usage allows different options for recording
    the changes. An approach is to list the files with changes as parameters to the
    commit command, which informs Git to ignore changes staged in the index and store
    the current contents of the listed files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, `-a` switch can be used with the command to add changes from all files
    that are listed in the index and are not in the working tree. Switch `-m` is used
    to specify the commit message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it is desirable to display the differences or changes between the
    index and the working tree, changes available between two files or blob objects.
    The `git diff` command is used for this purpose. When the `--staged` option is
    passed to the command, Git displays the differences between the staging and the
    last file version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git rm` command removes files from the working tree and the index. The
    files to be removed are passed as an option to the command. The files passed to
    the command as arguments are deleted from the working directory and staged for
    deletion. When the `--cached` option is passed to the command, Git does not delete
    the file from the working directory, but removes it from the version control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `git reset` command can be used to unstage and preserve the contents of
    files that have already been staged in a repository. The command is used to reset
    the current `HEAD` to a specified state. Also, it can be used to modify the index
    and working tree, based on the option specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command has three forms. The first and second forms are used to copy the
    entries from tree to the index, while the last form is used to set the current
    branch `HEAD` to a particular commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Branching and merging commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git branch` command is core to the Git version control system. It is used
    to create, move, rename, delete, and list available branches in a repository.
    The command has several forms and accepts different options used to set up and
    configure repository branches. When the `git branch` command is run on Bash, without
    specifying an option, the available branches in the repository are listed. This
    is similar to using the `--list` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new branch, the `git branch` command is run with the branch name
    as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `--delete` option is used to delete the branch specified, and the `--copy` option
    is used to create a copy of the specified branch alongside its `reflog`.
  prefs: []
  type: TYPE_NORMAL
- en: To update the files in a working tree or branch to match what is available in
    another working tree, the `git checkout` command is used. The command is used
    to switch branch or to restore working tree files. Similar to `git branch`, it
    has several forms and accepts different options.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the command is run with the branch name passed as an argument, Git switches
    to the branch specified, updates the working directory, and points the HEAD at
    the branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in the previous section, branching concepts allow development teams
    to try out new ideas and create new versions of a project from existing ones.
    The beauty of branching lies in being able to incorporate changes from one branch
    to another, in essence joining or merging branches or development lines together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Git, the `git merge` command is used for the purpose of integrating development
    branches created from a branch into a single branch. For example, if there is
    a development branch, created from a master branch to test a certain feature,
    when the `git merge [branch name]` command is run, Git will retrace the changes
    that have been made to the branch. This is because it was spurned from the master
    branch until the latest branch and stores these changes on the master branch in
    a new commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Quite often, the merge process can result in conflicts between files of the
    different branches. Running the `git merge --abort` command will abort the merge
    process and restore the branches back to the pre-merge state. After the conflicts
    encountered have been resolved, `git merge --continue` can be run to re-run the
    merge process.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring GitHub WebHooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **WebHook** is an event notification delivered through an HTTP POST. A WebHook
    is often referred to as a web callback or HTTP push API. A WebHook provides a
    mechanism by which an application delivers data to other applications in real
    time as they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: A WebHook differs from a regular API in that there is no continuous resource
    utilization through polling of data to get the latest data. The subscriber or
    consuming application receives the data when it is available through a URL that
    must have been registered with the WebHook provider. A WebHook is effective and
    efficient for both the provider of the data and the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming WebHooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To receive notifications or data from a WebHook, the consuming application needs
    to register a URL with the provider. The provider will deliver the data through
    POST to the URL. The URL must be publicly accessible from the web and be reachable.
  prefs: []
  type: TYPE_NORMAL
- en: The WebHook provider usually delivers the data through HTTP POST as JSON, XML,
    or as a form data through multipart or URL encoded. The implementation of the
    API at the URL of the subscriber will be influenced by the mode of data delivery
    used by the WebHook provider.
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, there are situations that require that WebHooks be debugged. This
    might be to troubleshoot an error. This can sometimes be challenging because of
    the asynchronous nature of WebHooks. First, the data from the WebHook must be
    understood. This can be achieved using tools that can get and parse WebHook requests.
    Based on the knowledge of the structure and content of the WebHook data, the requests
    can be mocked in order to test the URL API code to resolve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: When consuming data from a WebHook, it is important to be security aware and
    factor this into the design of the consuming application. Because the callback
    URL that the WebHook provider will POST data to is publicly available, it can
    be subject to malicious attacks.
  prefs: []
  type: TYPE_NORMAL
- en: A common and easy approach is to append to the URL a mandatory authentication
    token that will be verified on each request. Also, basic authentication can be
    built around the URL to verify the party initiating the POST before accepting
    and processing the data. Alternatively, the provider can sign every WebHook request,
    if the request signing is already implemented at the provider's end. The signature
    of every request posted will be verified by the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the frequency of events generation from the subscriber, a lot of
    requests can be raised by WebHooks. If the subscriber is not properly designed
    to handle such large requests, this can lead to high resource utilization, both
    in terms of bandwidth and server resources. When resources are fully utilized
    and used up, the consumer might no longer be able to handle more requests, resulting
    in a denial of service of the consumer application.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub WebHook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In GitHub, WebHooks serve as a means of delivering notifications to an external
    web server when events occur. GitHub WebHooks allow you to set up your projects
    that are hosted on GitHub to subscribe to the desired events available on the [www.github.com](http://www.github.com)
    platform. When the event occurs, GitHub sends a payload to the configured endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: WebHooks are configured on any of the repository or at the organizational level.
    Once successfully configured, the WebHook will be triggered every time a subscribed
    event or action is triggered. GitHub allows for the creation of up to 20 WebHooks
    per event for a repository or organization. The WebHooks, after installation,
    can be triggered on a repository or organization.
  prefs: []
  type: TYPE_NORMAL
- en: Events and payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the point of WebHook configuration in GitHub, you can specify which events
    you want to receive requests from GitHub. WebHook requests data is termed payloads
    in GitHub. It is smarter to subscribe to only the events for the data that is
    needed so as to limit the HTTP requests sent to the application server from GitHub.
    By default, even a WebHook created on GitHub is subscribed to the `push` event.
    Event subscriptions can be modified through the GitHub web or API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the available events that can be subscribed to on GitHub are explained
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `push` | This is the default event and is raised when there is a Git push
    to a repository. This also includes editing tags or branches and commits made
    via API actions that update references |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | Raised whenever a branch or tag is created. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete` | Raised whenever a branch or tag is deleted. |'
  prefs: []
  type: TYPE_TB
- en: '| `issues` | Raised whenever an issue is assigned, unassigned, labeled, unlabeled,
    opened, edited, milestoned, de-milestoned, closed, or reopened. |'
  prefs: []
  type: TYPE_TB
- en: '| `repository` | Raised whenever a repository is created, deleted (organization
    hooks only), archived, unarchived, made public, or made private. |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | This is a wildcard event and indicates that the URL should be notified
    for any event. |'
  prefs: []
  type: TYPE_TB
- en: A full list of all available events on GitHub is available at [https://developer.github.com/webhooks/](https://developer.github.com/webhooks/).
  prefs: []
  type: TYPE_NORMAL
- en: The `push` event has a payload that contains more detailed information. Every
    event in GitHub has a specific payload format that describes the information required
    for that event. Besides the specific fields peculiar to an event, each event includes
    in the payload the user or sender who triggers the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, included in the payload is the repository or organization that the event
    occurred on and the application that the event is related to. Payloads cannot
    exceed 5 MB in size. An event that produces a payload with a size larger than
    5 MB will not be fired. A payload delivered to the URL usually contains several
    headers, some of which are explained in the following table. When a new WebHook
    is created, GitHub sends a ping to the configured URL, as an indicator that the
    WebHook configuration was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Header** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `User-Agent` | User agent initiating the request. This will always have the
    prefix `Github-Hookshot`. |'
  prefs: []
  type: TYPE_TB
- en: '| `X-GitHub-Event` | Contains the name of the event that triggered the delivery.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `X-GitHub-Delivery` | A GUID to identify the delivery. |'
  prefs: []
  type: TYPE_TB
- en: '| `X-Hub-Signature` | This header contains the HMAC hex digest of the response
    body. This header will be sent if the WebHook is configured with a secret. The
    content of the header is generated using the `sha1 hash` function and the secret
    as the HMAC key. |'
  prefs: []
  type: TYPE_TB
- en: Setting up your first WebHook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure a WebHook, we will use the `LoanApplication` repository created
    earlier. Click on the Settings page of the repository, click on Webhooks, and
    click on Add webhook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec26cece-7d41-4bc6-95a3-bfca75bf8c3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'GitHub will ask you to authenticate the action. Supply your GitHub account
    password to continue. The WebHook configuration page will be loaded, where you
    can configure the options for the WebHook:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Payload URL field, provide the endpoint of the web application server.
    Since we will be running the `LoanApplication` from Visual Studio, we will use
    the following URL: `http://localhost:54113/API/webhook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Content type dropdown to application/json, to allow GitHub to send
    the payload via POST as JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, choose the option Let me select individual events. This will display a
    full list of available WebHook events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the events that you want the WebHook to subscribe to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, click on the **Add webhook** button, to finish the configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b97675f1-e44e-42a9-8f1b-ba2fb96c5776.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the WebHook has been created, GitHub will attempt to send a ping to the
    configured URL in the WebHook. The URL specified, `http://localhost:54113/api/webhook`,
    is a local development and not publicly available. It is therefore not reachable
    by GitHub, causing the WebHook request to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49e0be46-65e8-444e-a98e-1f099a77f7a7.png)'
  prefs: []
  type: TYPE_IMG
- en: To expose the development environment to the internet to make it accessible
    to GitHub, we can use **Ngrok**, a tool to create a public URL for exposing a
    local web server. Navigate to [https://ngrok.com/download](https://ngrok.com/download)
    to download Ngrok for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to tell Ngrok to expose port `54113` to the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Ngrok will create a public URL that will be accessible and forwarded to the
    specified port on your development PC. In this case, Ngrok generated `http://d73c1ef5.ngrok.io`
    as the URL that will be forwarded to port `54113`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe7fb1cc-5047-411e-bd21-54370828ea77.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, update the payload URL for the WebHook created earlier to `http://d73c1ef5.ngrok.io/api/webhook`.
    Click on the Update WebHook button to save the changes. Under Recent Deliveries
    tab, click on the GUID for the payload that failed to deliver. This will open
    up a screen showing the JSON payload, with a request and response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Redeliver button. This will display a dialog box asking you if
    want to redeliver the payload. Click on Yes, redeliver this payload button. This
    will attempt to POST the JSON payload to the new endpoint specified in the payload
    URL field. This time, the payload delivery will be successful with HTTP response
    code `200`, indicating that the endpoint was contacted successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12d0e466-f986-4972-8f42-e63c11de1f64.png)'
  prefs: []
  type: TYPE_IMG
- en: You can program the consumer web application to process the payload data the
    way you want. With the successful configuration, GitHub will POST the payload
    to the endpoint whenever any event subscribed to in the WebHook is raised.
  prefs: []
  type: TYPE_NORMAL
- en: TeamCity CI platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TeamCity is a platform-independent CI tool by JetBrains. It is a user-friendly
    CI tool specifically built with software developers and engineers in mind. TeamCity
    is a robust and powerful CI tool because of the capability to fully optimize the
    integration cycle.
  prefs: []
  type: TYPE_NORMAL
- en: TeamCity can also run builds in parallel simultaneously on different platforms
    and environments. Using TeamCity, you can have customized statistics on code quality,
    build duration, or even create custom metrics. It has a feature for running code
    coverage and it has a duplicates finder.
  prefs: []
  type: TYPE_NORMAL
- en: TeamCity concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, some basic terms regularly used in TeamCity will be explained.
    This is necessary in order to understand some of the concepts required to successfully
    configure the build steps as well as artifacts needed for a quality continuous
    process. Let''s have a look at some basic terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project**: This is the software project being developed. It can be a release
    or specific version. Also, it includes the collection of Build Configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build Agent**: This is the software that executes a build process. It is
    installed independently from the TeamCity Server. They can both reside on the
    same machine or on separate machines running similar or different operating systems.
    For production purposes, it is usually recommended that they both are installed
    on different machines for optimal performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TeamCity Server**: The TeamCity Server monitors the Build Agents while using
    compatibility requirements to distribute builds to connected agents, and it reports
    the progress and results. The information in the results include the build history,
    logs, and build data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: This is the process of creating a specific version of a software
    project. Triggering a build process places it in the Build Queue and will be started
    when there is an available agent to run it. The Build Agent sends Build Artifacts
    to the TeamCity Server upon completion of the build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build Queue**: This is a list containing builds that have been triggered
    and yet to be started. The TeamCity Server reads the queue for pending builds
    and distributes the build to compatible Build Agents the moment the agent is idle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build Artifacts**: These are files generated by a build. These can include `dll`
    files, executables, installers, reports, log files, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build Configuration**: This is a collection of settings describing a build
    procedure. This includes VCS Roots, Build Steps, and Build Triggers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build Step**: A Build Step is represented by a build runner with integration
    with a build tool, such as MSBuild, a code analysis engine, and a testing framework,
    such as xUnit.net. The build step is essentially a task to be executed, which
    can contain many steps that are sequentially executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build Trigger**: This is a set of rules that triggers a new build on certain
    events, such as when a VCS triggers a new build when TeamCity detects changes
    in the configured VCS Roots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VCS Root**: This is a collection of version control settings, including paths
    to sources, credentials, and other settings that define the way TeamCity communicates
    with a version control system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change**: This is a modification to the source code of the project. A Change
    is termed pending for a certain Build Configuration when the Change has been committed
    to the version control system, but not yet included in a build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing TeamCity Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TeamCity can be hosted locally on a development team's server infrastructure
    or by integrating TeamCity with cloud solutions. This allows virtual machines
    to be provisioned to run TeamCity. A TeamCity installation will comprise of the
    server installation and a default Build Agent.
  prefs: []
  type: TYPE_NORMAL
- en: To install the TeamCity Server, navigate to the JetBrains download site to get
    the free professional edition of the TeamCity Server which comes with free licence
    key that unlocks 3 Build Agents and 100 Build Configurations. If you are on the
    Windows operating system, run the download `.exe`, which is bundled with Tomcat
    Java JRE 1.8\. Follow the dialog prompts to extract and install the TeamCity core
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the installation, you can set up the port that TeamCity will be listening
    to or leave it at default `8080`. If the installation is successful, TeamCity
    will open in the browser, prompting you to complete the installation process by
    specifying the Data Directory Location on the server. Specify the path and click
    Proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b00f61fc-a20d-4a35-a237-6c9e9230ea17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the Data Directory Location path has been initialized, you will be taken
    to the database selection page, where you will be given the option of selecting
    any of the supported databases. Select Internal (HSQLDB) and click the Proceed
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05532102-4ddf-410e-85ff-f09b3e93ac84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The database configuration will take a few seconds, before you are presented
    with the license agreement page. Accept the license agreement and click on the
    Continue button. The next page is the admin account creation page. Create the
    account with the desired credentials to finish the installation. After the installation
    is completed, you will be directed to the overview page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f576b08-af3d-4e25-9925-ba7709abb491.png)'
  prefs: []
  type: TYPE_IMG
- en: TeamCity CI workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TeamCity build life cycle describes the data flow between the server and
    the agents. This is basically the information passed to the agents and the process
    of retrieving the results by TeamCity. The workflow describes the manner in which
    configured build steps for projects are executed end to end:'
  prefs: []
  type: TYPE_NORMAL
- en: The TeamCity Server detects a change in the VCS Root and persists this in the
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Build Trigger notices the change in the database and adds a build to the
    queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TeamCity Server assigns the build on the queue to a compatible idle Build
    Agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Build Agent executes the build steps. During the execution of the build
    steps, the agents sends reports of the build progress to the server. The Build
    Agent reports the build progress to the TeamCity Server to allow for real time
    monitoring of the build process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Build Agent sends Build Artifacts to the TeamCity Server upon completion
    of the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring and running build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Essentially, a project should contain configuration and project properties required
    to run a successful build. Using the TeamCity CI server, the steps required to
    run tests, perform environmental checks, compile, build, and make available a
    deploy-ready version of a project can be automated end to end.
  prefs: []
  type: TYPE_NORMAL
- en: The installed TeamCity Server can be accessed locally at the port specified
    during installation. In this case, we will use `http://localhost:8060`. To create
    a TeamCity project, navigate to the server URL and log in using the earlier created
    credentials. Click on the Projects menu and click on the Create Project button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be presented with several project options for creating the project
    from a repository, manually, or connecting to any of GitHub, Bitbucket, or Visual
    Studio Team Services. Click on the From GitHub.com button to connect TeamCity
    to the `LoanApplication` repository we created earlier on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/822c68c9-b100-4914-b97d-e1a7bc1db8a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Add Connection** dialog is displayed where TeamCity will be connected
    to GitHub. A new GitHub OAuth application needs to be created to successfully
    connect TeamCity to GitHub. To create a new OAuth application in GitHub, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://github.com/settings/applications/new](https://github.com/settings/applications/new).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the homepage URL field, supply the URL of the TeamCity Server: `http://localhost:8060`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supply `http://localhost:8060/oauth/github/accessToken.html` in the Authorization
    callback URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Register application button to complete the registration. A new
    client secret and client ID will be created for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c22bc375-7ebb-4be0-8cae-a8a4ff68e247.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The new client ID and client secret created will be used to fill the fields
    in the add connection dialog on TeamCity to create a connection from TeamCity
    to GitHub. Click on the Save button to save the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5647f0d2-7fe4-4e6b-b598-49a9e4b0093c.png)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to authorize TeamCity to have access to the VCS. This can be
    done by clicking the Sign in to GitHub button. A page will be displayed where
    you have to authorize TeamCity to access both public and private repositories
    in the GitHub account. Click Authorize to complete the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TeamCity will initiate a connection to GitHub to retrieve the list of available repositories
    that you can select from. You can filter the list to select the desired repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1b4cd33-b1dc-4121-827f-c91eccd445db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connection to the selected repository will be verified by TeamCity. If this
    is successful, Create Project will be displayed. On this page, the project and
    Build configuration name will be displayed. You can modify this if required. Click
    the Proceed button to continue with the project setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6ae2ec9-1eb6-4a07-a6fd-48a12a03e947.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next screen, TeamCity will scan the connected repository for available
    configured build steps. You can click on the Create Build Step button to add a
    build step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc7ee611-53ce-4ae6-9b25-715412134b99.png)'
  prefs: []
  type: TYPE_IMG
- en: In the New Build Step screen, you have to select the build runner from the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify a descriptive name for the build step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next select the command that you want the build runner to execute. Fill in all
    the other required fields
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the Save button to save the build step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b5ea0f5-99b2-4a42-ba57-1e21abc60196.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the build step is saved, the list of the available build steps will be
    displayed where you can add more build steps as desired following the same procedure.
    Also, you can reorder the build steps and can detect build steps, by clicking
    the Auto-detect build steps button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After configuring the build steps, you can run the build by clicking on the
    run link on the top menu of the TeamCity web page. This will redirect to you to
    the build result page where you can view the progress of the build and subsequently
    review it or edit the Build Configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b2cf317b-51ea-4584-a517-412c6b142bec.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have extensively explored the concept of CI, a software
    development practice that assists development teams in integrating their code
    frequently. Developers are expected to check the code several times a day, which
    is then verified by an automated build process, using a CI tool.
  prefs: []
  type: TYPE_NORMAL
- en: Also, common terminologies of CI be for continuous delivery were discussed.
    We explained the steps on how to host software projects on GitHub and online hosting
    platforms and later discussed basic Git commands.
  prefs: []
  type: TYPE_NORMAL
- en: The process of creating GitHub WebHooks to configure integrations with build
    management systems was explored. Finally, a step-by-step description of installing
    and configuring the TeamCity CI platform was given.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Cake Bootstrapper and configure TeamCity
    to use a cross-platform build automation system called Cake to clean, build, and
    restore package dependencies and test our `LoanApplication` project.
  prefs: []
  type: TYPE_NORMAL
