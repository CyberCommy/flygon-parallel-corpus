- en: Building the 5.x Linux Kernel from Source - Part 1
  prefs: []
  type: TYPE_NORMAL
- en: Building the Linux kernel from source code is an interesting way to begin your
    kernel development journey! Rest assured, it's a long and arduous journey, but
    that's the fun of it, right? The kernel build topic itself is large enough to
    merit being divided into two chapters, this one and the next.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of this chapter and the next is to describe in detail how
    exactly you can build a Linux kernel from scratch, from source code. In this chapter,
    you will initially learn how to download a stable vanilla Linux kernel source
    tree onto a guest Linux **Virtual Machine** (**VM**) (by vanilla kernel, we mean
    the plain and regular default kernel source code released by the Linux kernel
    community on its repository, [https://www.kernel.org](https://kernel.org)). Next,
    we will learn a little bit about the layout of the kernel source code – getting,
    in effect, a 10,000-foot view of the kernel code base. The actual kernel build
    recipe then follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, a key piece of information: any Linux system, be it a supercomputer
    or a tiny embedded device, has three required components: a bootloader, an **Operating
    System** (**OS**) kernel, and a root filesystem. In this chapter, we concern ourselves only with
    the building of the Linux kernel from source. We do not delve into the root filesystem
    details, and (in the next chapter) learn to minimally configure the (very x86-specific)
    GNU GRUB bootloader.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preliminaries for the kernel build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps to build the kernel from source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 1 – obtaining a Linux kernel source tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 2 – extracting the kernel source tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – configuring the Linux kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the kernel menu – adding our own menu item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume that you have gone through [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel
    Workspace Setup*, and have appropriately prepared a guest VM running Ubuntu 18.04
    LTS (or CentOS 8, or later stable releases of these distributions) and installed
    all the required packages. If not, I highly recommend you do this first.
  prefs: []
  type: TYPE_NORMAL
- en: To get the most out of this book, I strongly recommend you first set up the
    workspace environment, including cloning this book's GitHub repository ([https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming))
    for the code, and work on it in a hands-on fashion*.*
  prefs: []
  type: TYPE_NORMAL
- en: Preliminaries for the kernel build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s important to understand a few things right from the outset that will
    help you as we proceed on our journey of building and working with a Linux kernel. Firstly,
    the Linux kernel and its sister projects are completely decentralized - it''s
    a virtual, online open-source community! The closest we come to an office is this:
    stewardship of the Linux kernel (as well as several dozen related projects) is
    in the capable hands of the Linux Foundation ([https://linuxfoundation.org/](https://linuxfoundation.org/));
    further, it manages the Linux Kernel Organization, a private foundation that distributes
    the Linux kernel to the public for no charge ([https://www.kernel.org/nonprofit.html](https://www.kernel.org/nonprofit.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key points we discuss in this section includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel release, or version number nomenclature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The typical kernel development workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The existence of different types of kernel source trees within the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this information in place, you will be better armed to move through the
    kernel build procedure. All right, let's go over each of the preceding points.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel release nomenclature**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the kernel version number, simply run `uname -r` on your shell. How
    do you precisely interpret the output of `uname -r`? On our Ubuntu distribution
    version 18.04 LTS guest VM, we run `uname(1)`, passing the `-r` option switch
    to display just the current kernel release or version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Of course, by the time you read this, the Ubuntu 18.04 LTS kernel has certainly
    been upgraded to a later release; that's perfectly normal. The 5.0.0-36-generic
    kernel was the one I encountered with the Ubuntu 18.04.3 LTS at the time of writing
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modern Linux kernel release number nomenclature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is also often written or described as `w.x[.y][-z]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The square brackets around the `patchlevel` and `EXTRAVERSION` components indicate
    that they are optional. The following table summarizes the meaning of the components
    of the release number:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Release # component** | **Meaning** | **Example numbers** |'
  prefs: []
  type: TYPE_TB
- en: '| Major `#` (or `w`) | Main or major number; currently, we are on the 5.x kernel
    series, thus the major number is `5`. | `2`, `3`, `4`, and `5` |'
  prefs: []
  type: TYPE_TB
- en: '| Minor `#` (or `x`) | The minor number, hierarchically under the major number.
    | `0` onward |'
  prefs: []
  type: TYPE_TB
- en: '| `[patchlevel]` (or `y`) | Hierarchically under the minor number – also called
    the ABI or revision – applied on occasion to the stable kernel when significant
    bug/security fixes are required. | `0` onward |'
  prefs: []
  type: TYPE_TB
- en: '| `[-EXTRAVERSION]` (or `-z`) | Also called `localversion`; typically used
    by distribution kernels to track their internal changes. | Varies; Ubuntu uses `w.x.y-''n''-generic`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – Linux kernel release nomenclature
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can now interpret our Ubuntu 18.04 LTS distribution''s kernel release
    number, `5.0.0-36-generic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major # (or w)**: `5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor # (or x)**: `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[patchlevel] (or y)**: `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[-EXTRAVERSION] (or -z)**: `-36-generic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that distribution kernels may or may not precisely follow these conventions,
    it's really up to them. The regular or vanilla kernels released on [https://www.kernel.org/](https://www.kernel.org/) do
    follow these conventions (at least until Linus decides to change them).
  prefs: []
  type: TYPE_NORMAL
- en: (a) As part of an interesting exercise configuring the kernel, we will later
    change the `localversion` (aka `-EXTRAVERSION`) component of the kernel we build.
  prefs: []
  type: TYPE_NORMAL
- en: (b) Historically, in kernels before 2.6 (IOW, ancient stuff now), the *minor
    number *held a special meaning; if an even number, it indicated a stable kernel
    release, if odd, an unstable or beta release. This is no longer the case.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel development workflow – the basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we provide a brief overview of the typical kernel development workflow.
    Anyone like you who is interested in kernel development should at least minimally
    understand the process.
  prefs: []
  type: TYPE_NORMAL
- en: A detailed description can be found within the kernel documentation here: [https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works](https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works).
  prefs: []
  type: TYPE_NORMAL
- en: A common misconception, especially in its baby years, was that the Linux kernel
    is developed in a very ad hoc fashion. This is not true at all! The kernel development
    process has evolved to become a (mostly) well-oiled system with a thoroughly documented
    process and expectation of what a kernel contributor should know in order to use
    it well. I refer you to the preceding link for the complete details.
  prefs: []
  type: TYPE_NORMAL
- en: In order for us to take a peek into a typical development cycle, let's assume
    we have the latest mainline Linux Git kernel tree cloned on to our system.
  prefs: []
  type: TYPE_NORMAL
- en: The details regarding the use of the powerful `git(1)` **Source Code Management**
    (**SCM**) tool is beyond the scope of this book. Please see the *Further reading *section
    for useful links on learning how to use Git. Obviously, I highly recommend gaining
    at least basic familiarity with using `git(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, as of the time of writing, **the 5.4 kernel** is the
    latest **Long-Term Stable** (**LTS**) version, so we shall use it in the materials
    that follow. So, how did it come to be? Obviously, it has evolved from the **release
    candidate** (**rc**) kernels and the previous stable kernel release that precedes
    it, which in this case would be the *v5.4-rc''n''* kernels and the stable *v5.3* one
    before it. We use the `git log` command as follows to get a human-readable log
    of the tags in the kernel Git tree ordered by date. Here, we are only interested
    in the work that has lead to the release of the 5.4 LTS kernel, hence we have
    deliberately truncated the following output to reveal only that portion:'
  prefs: []
  type: TYPE_NORMAL
- en: The `git log` command (that we use in the following code block, and in fact
    any other `git` sub-commands) will only work on a `git` tree. We use the following
    one purely for demonstrating the evolution of the kernel. A bit later, we will
    show how you can clone a Git tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Aha! In the preceding code block, you can clearly see that the stable 5.4 kernel
    was released on 24 November 2019 and the 5.3 tree on 15 September 2019 (you can
    also verify this by looking up other useful kernel resources, such as [https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions)).
  prefs: []
  type: TYPE_NORMAL
- en: For the development series that ultimately led to the 5.4 kernel, this latter
    date (15 September 2019) marks the start of what is called the **merge window **for
    the next stable kernel for a period of (approximately) two weeks. In this period,
    developers are allowed to submit new code to the kernel tree (in reality, the
    actual work would have been going on from a lot earlier; the fruit of this work
    is now merged into mainline at this time).
  prefs: []
  type: TYPE_NORMAL
- en: Two weeks later (on 30 September 2019), the merge window was closed and the
    `rc` kernel work started, with `5.4-rc1` being the first of the `rc` versions,
    of course. The `-rc` (also known as prepatch) trees work primarily on merging
    patches and fixing (regression) bugs, ultimately leading to what is determined
    by the chief maintainers (Linus Torvalds and Andrew Morton) to be a "stable" kernel
    tree. The number of prepatches (`-rc` releases) varies. Typically, though, this
    "bugfix" window takes anywhere between 6 to 10 weeks, after which the new stable
    kernel is released. In the preceding code block, we can see that eight release
    candidate kernels finally resulted in the stable release of the v5.4 tree on 24
    November 2019 (taking a total of 70 days).
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be seen more visually via the releases page at [https://github.com/torvalds/linux/releases](https://github.com/torvalds/linux/releases):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97f30cbb-0926-4115-850d-bc9c6a87679f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The releases leading up to the 5.4 LTS kernel (read it bottom-up)
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot is a partial screenshot showing how various *v5.4-rc''n''*
    release candidate kernels ultimately resulted in the release of the LTS 5.4 tree
    (on 25 November 2019, with *v5.4-rc8* being the last `rc` release). The work never
    really stops: by early December 2019, the *v5.5-rc1* release candidate went out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generically, taking the 5.x kernel series as an example (the same holds true
    for any other recent `major` kernel series), the kernel development workflow is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The 5.x stable release is made. Thus, the merge window for the 5.x+1 (mainline) kernel
    has begun.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The merge window remains open for about 2 weeks and new patches are merged into
    the mainline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once (typically) 2 weeks have elapsed, the merge window is closed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rc` (aka mainline, prepatch) kernels start. *5.x+1-rc1, 5.x+1-rc2, ..., 5.x+1-rcn*
    are released. This process takes anywhere between 6 to 8 weeks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The stable release has arrived: the new *5.x+1* stable kernel is released.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The release is handed off to the "stable team":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Significant bug or security fixes result in the release of *5.x+1.y :*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*5.x+1.1, 5**.x+1.2, ... , 5.x+1.n*.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintained until the next stable release or **End Of Life** (**EOL**) date reached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...and the whole process repeats.'
  prefs: []
  type: TYPE_NORMAL
- en: So, when you now see Linux kernel releases, the names and the process involved
    will make sense. Let's now move on to looking at the different types of kernel
    source trees out there.
  prefs: []
  type: TYPE_NORMAL
- en: Types of kernel source trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several types of Linux kernel source trees. The key one is the **Long
    Term Support** (**LTS**) kernel. Okay, so what exactly is an LTS release kernel?
    It’s simply a "special" release in the sense that the kernel maintainers will
    continue to backport important bug and security fixes upon it (well, security
    issues are typically nothing but bugs), until a given EOL date.
  prefs: []
  type: TYPE_NORMAL
- en: The "life" of an LTS kernel will usually be a minimum of 2 years, and it can
    go for several more (it's extended at times). The **5.4 LTS kernel** that we will
    use throughout this book is the 20^(th) LTS kernel and has **a lifespan of just
    over 6 years – from November 2019 to December 2025**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of release kernels in the repository. However, here,
    we mention an incomplete list, ordered from least to most stable (thus, their
    life, from shortest to longest time span):'
  prefs: []
  type: TYPE_NORMAL
- en: '**-next trees**: This is indeed the bleeding edge, subsystem trees with new
    patches collected here for testing and review. This is what an upstream kernel
    contributor will work on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prepatches, also known as -rc or mainline**: These are release candidate
    kernels that get generated prior to a release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stable kernels**: As the name implies, this is the business end. These kernels
    are typically picked up by distributions and other projects (at least to begin
    with). They are also known as vanilla kernels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distribution and LTS kernels**: Distribution kernels are (obviously) the
    kernels provided by the distributions. They typically begin with a base vanilla/stable
    kernel. LTS kernels are the specially maintained-for-a-longer-while kernels, making
    them especially useful for industry/production projects and products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will work throughout on the latest LTS kernel as of the time
    of writing, which is the 5.4 LTS kernel. As I mentioned in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel
    Workspace Setup*, the 5.4 LTS kernel was initially slated to have an EOL of "at
    least December 2021." Recently (June 2020), it's now been pushed **to** **December
    2025**, keeping this book's content current and valid for years to come!
  prefs: []
  type: TYPE_NORMAL
- en: '**Super LTS (SLTS) kernels**: Even longer maintained LTS kernels (by the *Civil
    Infrastructure Platform* ([https://www.cip-project.org/](https://www.cip-project.org/)),
    a Linux Foundation project).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's quite intuitive. Nevertheless, I refer you to kernel.org's Releases page to
    obtain details on the type of release kernels: [https://www.kernel.org/releases.html](https://www.kernel.org/releases.html).
    Again, for even more detail, visit *How the development process works* ([https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works](https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works)).
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting aside, certain LTS kernels are very long-term releases, the
    aptly named **SLTS** or **Super LTS** kernels. As an example, the 4.4 Linux kernel
    (the 16^(th) LTS release) is considered to be an SLTS kernel. As the first kernel
    selected for SLTS, the Civil Infrastructure Platform will provide support until
    at least 2026, possibly until 2036.
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying the repository, `www.kernel.org`, in a non-interactive scriptable
    fashion can be done using `curl(1)` (the following output is the state of Linux
    as of 05 January 2021):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, by the time you read this, it's extremely likely (certain, in fact)
    that the kernel has evolved further and later versions show up. For a book such
    as this one, the best I could do is pick the latest LTS kernel at the time of
    writing.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it's happened already! The 5.10 kernel was released on 13 December
    2020 and, as of the time of writing (just before going to print), the work on
    the 5.11 kernel is in progress...
  prefs: []
  type: TYPE_NORMAL
- en: Finally, yet another safe way to download a given kernel is provided by the
    kernel maintainers who offer a script to safely download a given Linux kernel
    source tree, verifying its PGP signature. The script is available here: [https://git.kernel.org/pub/scm/linux/kernel/git/mricon/korg-helpers.git/tree/get-verified-tarball](https://git.kernel.org/pub/scm/linux/kernel/git/mricon/korg-helpers.git/tree/get-verified-tarball).
  prefs: []
  type: TYPE_NORMAL
- en: Right, now that we're armed with the knowledge on kernel version nomenclature
    and types of kernel source trees, it's time to begin our journey of building our
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Steps to build the kernel from source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a convenient and quick reference, the following are the key steps required
    to build a Linux kernel from source. As the explanation for each of them is pretty
    detailed, you can refer back to this summary to see the bigger picture. The steps
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtain a Linux kernel source tree through either of the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading a specific kernel source as a compressed file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning a (kernel) Git tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the kernel source tree into some location in your home directory (skip
    this step if you obtained a kernel by cloning a Git tree).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configuration: Select the kernel support options as required for the new kernel,'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`make [x|g|menu]config`, with `make menuconfig` being the preferred way.'
  prefs: []
  type: TYPE_NORMAL
- en: Build the kernel's loadable modules and any **Device Tree Blobs** (**DTBs**)
    with `make [-j'n'] all`. This builds the compressed kernel image (`arch/<arch>/boot/[b|z|u]image`),
    the uncompressed kernel image (`vmlinux`), `System.map`, the kernel module objects,
    and any configured DTB(s) files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the just-built kernel modules with `sudo make modules_install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This step installs kernel modules by default under `/lib/modules/$(uname -r)/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the GRUB bootloader and the `initramfs` (earlier called `initrd`) image
    (x86-specific):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sudo make install`:'
  prefs: []
  type: TYPE_NORMAL
- en: This creates and installs the `initramfs` (or `initrd`) image under `/boot`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It updates the bootloader configuration file to boot the new kernel (first entry).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize the GRUB bootloader menu (optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter, being the first of two on this topic, will essentially cover *steps
    1 to 3*, with a lot of required background material thrown in as well. The next
    chapter will cover the remaining steps, *4 to 7*. So, let's begin with *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – obtaining a Linux kernel source tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see two broad ways in which you can obtain a Linux
    kernel source tree:'
  prefs: []
  type: TYPE_NORMAL
- en: By downloading and extracting a specific kernel source tree from the Linux kernel
    public repository ([https://www.kernel.org](https://www.kernel.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By cloning Linus Torvalds' source tree (or others') – for example, the `linux-next` Git
    tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But how do you decide which approach to use? For the majority of developers
    like you working on a project or product, the decision has already been made –
    the project uses a very specific Linux kernel version. You will thus download
    that particular kernel source tree, quite possibly apply project-specific patches
    to it if required, and use it.
  prefs: []
  type: TYPE_NORMAL
- en: For folks whose intention is to contribute or "upstream" code to the mainline
    kernel, the second approach – cloning the Git tree – is the way to go for you.
    (Of course, there's more to it; we described some details in the *Types of kernel
    source trees* section)*.*
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we demonstrate both approaches. First, we describe
    the approach where a particular kernel source tree (not a Git tree) is downloaded
    from the kernel repository. We choose, as of the time of writing, the **latest
    LTS 5.4 Linux kernel** for this purpose. In the second approach, we clone a Git
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading a specific kernel tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, where is the kernel source code? The short answer is that it''s on
    the public kernel repository server visible at [https://www.kernel.org](https://www.kernel.org).
    The home page of this site displays the latest stable Linux kernel version, as
    well as the latest `longterm` and `linux-next` releases (the following screenshot
    shows the site as of 29 November 2019\. It shows dates in the well-known `yyyy-mm-dd`format):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e90a555-0632-4d57-8d2a-a0184ec36212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The kernel.org site (as of 29 November 2019)
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick reminder: we also provide a PDF file that has the full-color images
    of the screenshots/diagrams used in this book. You can download it here: [https://static.packt-cdn.com/downloads/9781789953435_ColorImages.pdf](_ColorImages.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to download a (compressed) kernel source file. Let''s look
    at two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: An interactive, and perhaps simplest way, is to visit the preceding website
    and simply click on the appropriate `tarball` link. The browser will download
    the image file (in `.tar.xz` format) to your system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, you can download it from the command line (a shell or the CLI)
    using the `wget(1)` utility (we can also use the powerful `curl(1)` utility to
    do so). For example, to download the stable 5.4.0 kernel source compressed file,
    we can do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding `wget(1)` utility doesn't work, it's likely because the kernel
    (compressed) `tarball` link changed. For example, if it didn't work for `5.4.0.tar.xz`,
    try the same `wget` utility but change the version to `5.4.1.tar.xz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will securely download the 5.4.0 compressed kernel source tree to your
    computer''s `~/Downloads` folder. Of course, you may not want the versions of
    the kernel that are displayed on the repository''s home page. For example, what
    if, for my particular project, I require the latest 4.19 stable (LTS) kernel,
    the 19^(th) LTS release? Simple: via the browser, just click on the [https://www.kernel.org/pub/](https://www.kernel.org/pub/)
    (or the mirror [https://mirrors.edge.kernel.org/pub/](https://mirrors.edge.kernel.org/pub/))
    link (immediately to the right of the "HTTP" link shown in the first few lines)
    and navigate to the `linux/kernel/v4.x/` directory on the server (you might be
    directed to a mirror site). Or, simply point `wget(1)` at the URL (here, as of
    the time of writing, it happens to be [https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.164.tar.xz](https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.164.tar.xz)).'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a Git tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a developer like you working on and looking to contribute code upstream,
    you *must *work on the very latest version of the Linux kernel code base. Well,
    there are fine gradations of the latest version within the kernel community. As
    mentioned earlier, the `linux-next` tree, and some specific branch or tag within
    it, is the one to work on for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, though, we do not intend to delve into the gory details of setting
    up a `linux-next` tree. This process is already very well documented and we would
    prefer not to merely repeat instructions (see the *Further reading *section for
    detailed links). The detailed page on how exactly you should clone a `linux-next`
    tree is here: *Working with linux-next, *[https://www.kernel.org/doc/man-pages/linux-next.html](https://www.kernel.org/doc/man-pages/linux-next.html),
    and, as mentioned there, the *linux-next tree*, [http://git.kernel.org/cgit/linux/kernel/git/next/linux-next.git](http://git.kernel.org/cgit/linux/kernel/git/next/linux-next.git),
    is the holding area for patches aimed at the next kernel merge window. If you're
    doing bleeding-edge kernel development, you may want to work from that tree rather
    than Linus Torvalds' mainline tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, cloning the *mainline *Linux Git repository (Torvalds'' Git
    tree) is more than sufficient. Do so like this (type this on one line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that cloning a complete Linux kernel tree is a time-, network-, and disk-consuming
    operation! Ensure you have sufficient disk space free (at least a few gigabytes
    worth).
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing `git clone --depth n <...>`, where `n` is an integer value, is very
    useful to limit the depth of history (commits) and thus keep the download/disk
    usage low(er). As the `man` page on `git-clone(1)` mentions for the `--depth` option:
    "Create a shallow clone with a history truncated to a specified number of commits."'
  prefs: []
  type: TYPE_NORMAL
- en: As per the preceding tip, why not do the following (again, type this on one
    line)?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you intend to work on this mainline Git tree, please skip the *Step* 2 –
    *extracting the kernel source tree *section (as the `git clone` operation will,
    in any case, extract the source tree) and continue with the section that follows
    it (*Step 3 – configuring the Linux kernel)*.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – extracting the kernel source tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, this section is meant for those of you who have downloaded
    a particular Linux kernel from the repository, [https://www.kernel.org](https://www.kernel.org)*, *and
    aim to build it. In this book, we use the 5.4 LTS kernel release. On the other
    hand, if you have performed `git clone` on the mainline Linux Git tree, as shown
    in the immediately preceding section, you can safely skip this section and move
    on to the next one on kernel configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the download is done, let's proceed further. The next step is to extract
    the kernel source tree – remember, it's a tar-ed and compressed (typically `.tar.xz`)
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We assume that, as shown in detail earlier in this chapter, you have by now
    downloaded the Linux kernel version 5.4 code base as a compressed file (into the
    `~/Downloads` directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The simple way to extract this file is by using the ubiquitous `tar(1)` utility
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will extract the kernel source tree into a directory named `linux-5.4`
    within the `~/Downloads` directory. But what if we would like to extract it into
    another folder, say `~/kernels`? Then, do it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will extract the kernel source into the `~/kernels/linux-5.4/` folder.
    As a convenience, and good practice, let''s set up an *environment variable* to
    point to the location of the root of our kernel source tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that, going forward, we will assume that this variable holds the location
    of the kernel source tree.
  prefs: []
  type: TYPE_NORMAL
- en: While you could always use a GUI file manager application (such as `Nautilus(1)`)
    to extract the compressed file, I strongly urge you to get familiar with using
    the Linux CLI to perform these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget `tldr(1)` when you need to quickly lookup the most frequently used
    options to common commands! For example, for `tar(1)`, simply use `tldr tar` to
    look it up.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice? We extract the kernel source tree into *any* directory under
    our home directory (or even elsewhere), unlike in the old days when the tree was
    always extracted under a root-writeable location (often, `/usr/src/`). Nowadays,
    just say no (to that).
  prefs: []
  type: TYPE_NORMAL
- en: If all you wish to do now is proceed with the kernel build recipe, skip the
    following section and move along. If interested (we certainly hope so!), the next
    section is a brief but important deviation into looking at the structure and layout
    of the kernel source tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**A brief tour of the kernel source tree**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel source code is now available on your system! Cool, let''s take a
    quick look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7495234c-06e5-47b3-93c8-e8a1e08e0a20.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The root of the 5.4 Linux kernel source tree
  prefs: []
  type: TYPE_NORMAL
- en: Great! How big is it? A quick `du -m .` in the root of the kernel source tree
    reveals that this particular kernel source tree (recall, it's version 5.4) is
    a little over 1,000 MB in size – almost a gigabyte!
  prefs: []
  type: TYPE_NORMAL
- en: FYI, the Linux kernel has grown to be big and is getting bigger in terms of
    **Source ****Lines Of Code**(**SLOCs**). Current estimates are well over 20 million
    SLOCs. Of course, do realize that not *all* of this code will get compiled when
    building a kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we know which version exactly of the Linux kernel this code is by just
    looking at the source? That''s easy, one quick way is to just check out the first
    few lines of the project''s Makefile. Incidentally, the kernel uses Makefile''s
    all over the place; most directories have one. We will refer to this Makefile,
    the one at the root of the kernel source tree, as the *top-level Makefile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, it's the source of the 5.4.0 kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get for ourselves a zoomed-out 10,000-foot view of the kernel source
    tree. The following table summarizes the broad categorization and purpose of the
    (more) important files and directories within the root of the Linux kernel source
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File or directory name** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| **Top-level file****s** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `README` | The project''s `README` file. It informs us as to where the kernel
    documentation is kept – spoiler, it''s in the directory called `Documentation`
    – and how to begin using it. The documentation is really important; it''s the
    authentic thing, written by the kernel developers themselves. |'
  prefs: []
  type: TYPE_TB
- en: '| `COPYING` | The license terms under which the kernel source is released.
    The vast majority are released under the well-known GNU GPL v2 (written as GPL-2.0)
    license [1]. |'
  prefs: []
  type: TYPE_TB
- en: '| `MAINTAINERS` | *FAQ:* *something''s wrong in XYZ, who do I contact to get
    some support?* That is precisely what this file provides – the list of all kernel
    subsystems, indeed down to the level of individual components (such as a particular
    driver), its status, who is currently maintaining it, the mailing list, website,
    and so on. Very helpful! There''s even a helper script to find the person or team
    to talk to: `scripts/get_maintainer.pl` [2]. |'
  prefs: []
  type: TYPE_TB
- en: '| Makefile | This is the kernel''s top-level Makefile; the `kbuild` kernel
    build system as well as kernel modules use this Makefile (at least initially)
    for the build. |'
  prefs: []
  type: TYPE_TB
- en: '| **Major subsystem directories** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `kernel/` | Core kernel subsystem: the code here deals with process/thread
    life cycle, CPU scheduling, locking, cgroups, timers, interrupts, signaling, modules,
    tracing, and more. |'
  prefs: []
  type: TYPE_TB
- en: '| `mm/` | The bulk of the **memory management** (**mm**) code lives here. We
    will cover a little of this in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml),
    *Kernel Internals Essentials – Processes and Threads*, and some related coverage
    in [Chapter 7](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml), *Memory Management
    Internals – Essentials*, and [Chapter 8](e78245d1-5a99-4b9e-a98c-cb16b15f3bee.xhtml),
    *Kernel Memory Allocation for Module Authors – Part 1*, as well. |'
  prefs: []
  type: TYPE_TB
- en: '| `fs/` | The code here implements two key filesystem features: the abstraction
    layer – the kernel **Virtual Filesystem Switch** (**VFS**), and the individual
    filesystem drivers (for example, `ext[2&#124;4]`, `btrfs`, `nfs`, `ntfs`, `overlayfs`,
    `squashfs`, `jffs2`, `fat`, `f2fs`, and so on). |'
  prefs: []
  type: TYPE_TB
- en: '| `block/` | The underlying (to the VFS/FS) block I/O code path. It includes
    the code implementing the page cache, a generic block IO layer, IO schedulers,
    and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `net/` | Complete (to the letter of the **Request For Comments** (**RFCs**)—[https://whatis.techtarget.com/definition/Request-for-Comments-RFC](https://whatis.techtarget.com/definition/Request-for-Comments-RFC))
    implementation of the network protocol stack. Includes a high-quality implementation
    of TCP, UDP, IP, and many more networking protocols. |'
  prefs: []
  type: TYPE_TB
- en: '| `ipc/` | The **Inter-Process Communication** (**IPC**) subsystem code; covers
    IPC mechanisms such as (both SysV and POSIX) message queues, shared memory, semaphores,
    and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `sound/` | The audio subsystem code, also known as**Advanced Linux Sound
    Architecture** (**ALSA**). |'
  prefs: []
  type: TYPE_TB
- en: '| `virt/` | The *virtualization* (hypervisor) code; the popular and powerful **Kernel
    Virtual Machine** (**KVM**) is implemented here. |'
  prefs: []
  type: TYPE_TB
- en: '| **Infrastructure/misc** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `arch/` | The arch-specific code lives here (by the word arch, we mean CPU).
    Linux started as a small hobby project for the i386\. It is now probably the most
    ported OS (see the arch ports in *step 3* of the list that follows after this
    table). |'
  prefs: []
  type: TYPE_TB
- en: '| `crypto/` | This directory contains the kernel-level implementation of ciphers
    (encryption/decryption algorithms, aka transformations) and kernel APIs to serve
    consumers that require cryptographic services. |'
  prefs: []
  type: TYPE_TB
- en: '| `include/` | This directory contains the arch-independent kernel headers
    (there are also some arch-specific ones under `arch/<cpu>/include/...`).  |'
  prefs: []
  type: TYPE_TB
- en: '| `init/` | The arch-independent kernel initialization code; perhaps the closest
    we get to the kernel''s main function (remember, the kernel is not an application)
    is here: `init/main.c:start_kernel()`, with the `start_kernel()` function within
    it considered the early C entry point during kernel initialization. |'
  prefs: []
  type: TYPE_TB
- en: '| `lib/` | The closest equivalent to a library for the kernel. It''s important
    to understand that the kernel does *not* support shared libraries as userspace
    apps do. The code here is auto-linked into the kernel image file and hence available
    to the kernel at runtime (various useful components exist within `/lib`: [un]compression,
    checksum, bitmap, math, string routines, tree algos, and so on). |'
  prefs: []
  type: TYPE_TB
- en: '| `scripts/` | Various scripts are housed here, some of which are used during
    kernel build, many for other purposes (like static/dynamic analysis, and so on;
    mostly Bash and Perl). |'
  prefs: []
  type: TYPE_TB
- en: '| `security/` | Houses the kernel''s **Linux Security Module** (**LSM**), a
    **Mandatory Access Control** (**MAC**) framework that aims at imposing stricter
    access control of user apps to kernel space than the default kernel does (the
    default model is called **Discretionary Access Control** (**DAC**)). Currently,
    Linux supports several LSMs; well-known ones are SELinux, AppArmor, Smack, Tomoyo,
    Integrity, and Yama (note that LSMs are "off" by default). |'
  prefs: []
  type: TYPE_TB
- en: '| `tools/` | Various tools are housed here, mostly userspace applications (or
    scripts) that have a "tight coupling" with the kernel (*perf*, the modern profiling
    tool, serves as an excellent example). |'
  prefs: []
  type: TYPE_TB
- en: Table 2.2 – Layout of the Linux kernel source tree
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some important explanations from the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel licensing**: Without getting stuck in the legal details, here''s the
    pragmatic essence of the thing: as the kernel is released under the GNU GPL-2.0
    license (**GNU GPL** is the **GNU General Public License**), any project that
    directly uses the kernel code base (even a tiny bit of it!), automatically falls
    under this license (the "derivative work" property of the GPL-2.0). These projects
    or products must release their kernels under the same license terms. Practically
    speaking, the situation on the ground is a good deal hazier; many commercial products
    that run on the Linux kernel do have  proprietary user- and/or kernel-space code
    within them. They typically do so by refactoring kernel (most often, device driver)
    work in **Loadable Kernel Module** (**LKM**) format. It is possible to release
    the kernel module (LKM) under a *dual license *model (for example, as dual BSD/GPL;
    the LKM is the subject matter of [Chapter 4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml),
    *Writing your First Kernel Module – LKMs Part 1*, and [Chapter 5](408b6f9d-42dc-4c59-ab3d-1074d595f9e2.xhtml), *Writing
    your First Kernel Module – LKMs Part 2*, and we cover some information on the
    licensing of kernel modules there). Some folks, preferring proprietary licenses,
    manage to release their kernel code within a kernel module that is not licensed
    under GPL-2.0 terms; technically, this is perhaps possible, but is (at the very
    least) considered as being anti-social (and can even cross the line to being illegal).
    The interested among you can find more links on licensing in the *Further reading* document
    for this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MAINTAINERS`: An example of running the `get_maintainer.pl` Perl script (note:
    it is meant to run on a Git tree only):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Linux `arch` (CPU) ports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a kernel or driver developer, browsing the kernel source tree is something
    you will have to get quite used to (and even enjoy!). Searching for a particular
    function or variable can be a daunting task when the code is in the ballpark of
    20 million SLOCs! Do use efficient code browser tools. I suggest the `ctags(1)`
    and `cscope(1)` **Free and Open Source Software** (**FOSS**) tools. In fact, the
    kernel''s top-level Makefile has targets for precisely these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make tags ; make cscope`'
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed *step 2*, the extraction of the kernel source tree! As
    a bonus, you also learned the basics regarding the layout of the kernel source.
    Let's now move on to *step 3* of the process and learn how to *configure *the
    Linux kernel prior to building it.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – configuring the Linux kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring the new kernel is perhaps *the* *most* critical step in the kernel
    build process. One of the many reasons Linux is a critically acclaimed OS is its
    versatility. It's a common misconception to think that there is a separate Linux
    kernel code base for an (enterprise-class) server, a data center, a workstation,
    and a tiny embedded Linux device – no, *they all use the very same unified Linux
    kernel source!* Thus, carefully *configuring* the kernel for a particular use
    case (server, desktop, embedded, or hybrid/custom) is a powerful feature and a
    requirement. This is precisely what we are delving into here.
  prefs: []
  type: TYPE_NORMAL
- en: Do carry out this kernel configuration step regardless. Even if you feel you
    do not require any changes to the existing (or default) config, it's very important
    to run this step at least once as part of the build process. Otherwise, certain
    headers that are auto-generated here will be missing and cause issues. At the
    very least, `make oldconfig` should be carried out. This will set up the kernel
    config to that of the existing system with config options being requested from
    the user only for any new options.
  prefs: []
  type: TYPE_NORMAL
- en: First though, let's cover some required background on the **kernel build** (**kbuild**)
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the kbuild build system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The infrastructure that the Linux kernel uses to configure and build the kernel
    is known as the **kbuild** system. Without delving into the gory details, the
    kbuild system ties together the complex kernel configuration and build process
    via four key components:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CONFIG_FOO` symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The menu specification file(s), called `Kconfig`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Makefile(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overall kernel config file itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The purpose of these components is summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Kbuild component** | **Purpose in brief** |'
  prefs: []
  type: TYPE_TB
- en: '| Config symbol: `CONFIG_FOO` | Every kernel configurable `FOO` is represented
    by a `CONFIG_FOO` macro. Depending on the user''s choice, the macro will resolve
    to one of `y`, `m`, or `n`:- `y=yes`: Implying to build the feature into the kernel
    image itself - `m=module`: Implying to build it as a separate object, a kernel
    module- `n=no`: Implying not to build the featureNote that `CONFIG_FOO` is an
    alphanumeric string (as we will soon see, you can look up the precise config option
    name by using the `make menuconfig` option, navigating to a config option, and
    selecting the `< Help >` button). |'
  prefs: []
  type: TYPE_TB
- en: '| `Kconfig` files | This is where the `CONFIG_FOO` symbol is defined. The kbuild
    syntax specifies its type (Boolean, tristate, [alpha]numeric, and so on) and dependency
    tree. Furthermore, for the menu-based config UI (invoked via one of `make [menu&#124;g&#124;x]config`),
    it specifies the menu entries themselves. We will, of course, make use of this
    feature later. |'
  prefs: []
  type: TYPE_TB
- en: '| Makefile(s) | The kbuild system uses a *recursive* Makefile approach. The
    Makefile under the kernel source tree root folder is called the *top-level* Makefile,
    with a Makefile within each sub-folder to build the source there. The 5.4 vanilla
    kernel source has over 2,500 Makefiles in all! |'
  prefs: []
  type: TYPE_TB
- en: '| The `.config` file | Ultimately, the essence of it – the actual kernel configuration
    – is generated and stored within the kernel source tree root folder in an ASCII
    text file called `.config`. Keep this file safe, it''s a key part of your product.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.3 – Major components of the Kbuild build system
  prefs: []
  type: TYPE_NORMAL
- en: The key thing is to get ourselves a working `.config` file. How can we do so?
    We do this iteratively. We begin with a "default" configuration – the topic of
    the following section – and carefully work our way up to a custom config as required.
  prefs: []
  type: TYPE_NORMAL
- en: Arriving at a default configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, how do you decide the initial kernel configuration to begin with? Several
    techniques exist; a few common ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't specify anything; the kbuild system will pull in a default kernel configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the existing distribution's kernel configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a custom configuration based on the kernel modules currently loaded in
    memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first approach has the benefit of simplicity. The kernel will handle the
    details, giving you a default configuration. The downside is that the default
    config is really pretty large (here, we mean with reference to building Linux
    for an x86-based desktop or server-type system) – a huge number of options are
    turned on, just in case, which can make the build time very long and kernel image
    size very large. Of course, you are then expected to manually configure the kernel
    to the desired settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up the question, *where is the default kernel config stored*? The
    kbuild system uses a priority list fallback scheme to retrieve a default configuration.
    The priority list and its order (first being highest priority) are specified within
    `init/Kconfig:DEFCONFIG_LIST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'FYI, the kernel documentation on `Kconfig` (found here: [https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt](https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt))
    documents what `defconfig_list` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From the list, you can see that the kbuild system first checks for the presence
    of a `.config` file in the `/lib/modules/$(uname -r)` folder. If found, the values
    there will be used as the defaults. If not found, it next checks for the presence
    of a `/etc/kernel-config` file. If found, the values there will be used as defaults,
    and if not found it moves on to the next option in the preceding priority list,
    and so on. Note, though, that the presence of a `.config` file in the root of
    the kernel source tree overrides all of this!
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a good starting point for kernel configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This brings us to a **really important point**: playing around with the kernel
    configuration is okay to do as a learning exercise (as we do here), but for a
    production system, it''s really critical that you use a proven – known, tested,
    and working – kernel configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, to help you understand the nuances of selecting a valid starting point
    for kernel configuration, we will see three approaches to obtaining a starting
    point for kernel configuration that (we hope) are typical:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the approach to follow for a typical small embedded Linux system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, an approach where you emulate the distribution's configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, an approach where you base the kernel configuration on the existing
    (or another) system's kernel modules (the `localmodconfig` approach)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine each of these approaches in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel config for typical embedded Linux systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The typical target system for using this approach is a small embedded Linux
    system. The goal here is to begin with a proven – a known, tested, and working
    – kernel configuration for our embedded Linux project. Well, how exactly can we
    achieve this?
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the kernel code base itself provides known, tested, and working
    kernel configuration files for various hardware platforms. We merely have to select
    the one that matches (or is the nearest match to) our embedded target board. These
    kernel config files are present within the kernel source tree in the `arch/<arch>/configs/` directory.
    The config files are in the format `<platform-name>_defconfig`. A quick peek is
    in order; see the following screenshot showing the command `ls arch/arm/configs`
    being performed on the v5.4 Linux kernel code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06950efa-a78e-4194-a747-2414cddfe329.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The contents of arch/arm/configs on the 5.4 Linux kernel
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, for example, if you find yourself configuring the Linux kernel for a
    hardware platform having, say, a Samsung Exynos **System on Chip** (**SoC**) on
    it, please don’t start with an x86-64 kernel config file as the default (or simply
    attempt to use it). It won''t work. Even if you manage it, the kernel will not
    build/work cleanly. Pick the appropriate kernel config file: for our example here,
    the `arch/arm/configs/exynos_defconfig` file would be a good starting point. You
    can copy this file into `.config` in the root of your kernel source tree and then
    proceed to fine-tune it to your project-specific needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, the Raspberry Pi ([https://www.raspberrypi.org/](https://www.raspberrypi.org/))
    is a popular hobbyist platform. The kernel config file – within its kernel source
    tree – used (as a base) is this one: `arch/arm/configs/bcm2835_defconfig`. The
    filename reflects the fact that  Raspberry Pi boards use a Broadcom 2835-based
    SoC. You can find details regarding kernel compilation for the Raspberry Pi here:
    [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md).
    Hang on, though, we will be covering at least some of this in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 2*, in the *Kernel build for
    the Raspberry Pi* section.'
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to see exactly which configuration file is good for which platform
    is to simply perform `make help` on the target platform itself. The latter part
    of the output displays the config files under the *Architecture specific targets* heading (note
    though that this is meant for foreign CPUs and doesn't work for the x86[-64]).
  prefs: []
  type: TYPE_NORMAL
- en: The careful tweaking and setup of the kernel config for a product is an important
    part of the work typically carried out by the engineers working within the *platform*
    or**Board Support Package** (**BSP**) team.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel config using distribution config as a starting point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The typical target system for using this approach is a desktop or server Linux
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving along, this second approach is also quick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply copy the existing Linux distribution's (here, it's our Ubuntu
    18.04.3 LTS guest VM) config file into the `.config` file in the root of the kernel
    source tree, of course, thereby making the distribution config the starting point,
    which can then be further edited (a more generic command: `cp /boot/config-$(uname
    -r) ${LLKD_KSRC}/.config`).
  prefs: []
  type: TYPE_NORMAL
- en: Tuned kernel config via the localmodconfig approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The typical target system for using this approach is a desktop or server Linux
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This third approach we consider is a good one to use when the goal is to begin
    with a kernel config that is based on your existing system and is thus (usually)
    relatively compact compared to the typical default config on a desktop or server
    Linux system. Here, we provide the kbuild system with a snapshot of the kernel
    modules currently running on the system by simply redirecting the output of `lsmod(8)`
    into a temporary file, and then providing that file to the build. This can be
    achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `lsmod(8)` utility simply lists all the kernel modules currently residing
    in system (kernel) memory. We will see (a lot) more on this in [Chapter 4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml),
    *Writing Your First Kernel Module – LKMs Part 1*. We save its output in a temporary
    file, which we pass within the `LSMOD` environment variable to the Makefile's
    `localmodconfig` target. The job of this target is to configure the kernel in
    a manner as to only include the base functionality plus the functionality provided
    by these kernel modules and leave out the rest, in effect giving us a reasonable
    facsimile of the current kernel (or of whichever kernel the `lsmod` output represents).
    We use precisely this technique to configure our 5.4 kernel in the following *Getting
    started with the localmodconfig approach* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right, this concludes the three approaches to setting up a starting point for
    kernel configuration. As a matter of fact, we have just scratched the surface.
    Many more techniques to explicitly generate the kernel configuration in a given
    manner are encoded into the kbuild system itself! How? Via configuration targets
    to `make`. See them under the `Configuration targets` heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick but very useful point: to ensure a clean slate, use the `mrproper`
    target first. We will show a summary of all the steps carried out next, so don''t
    worry for now.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the localmodconfig approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's quickly get started on creating a base kernel configuration for our
    new kernel by using the third approach we discussed previously – the `localmodconfig`
    technique. As mentioned, this existing kernel modules-only approach is a good
    one when the goal is to obtain a starting point for kernel config on an x86-based
    system by keeping it relatively small and thus make the build quicker as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget: the kernel configuration being performed right now is appropriate
    for your typical x86-based desktop/server systems. For embedded targets, the approach
    is different (as seen in the *Kernel config for typical embedded Linux systems* section).
    We further cover this practically in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 2*, under the *Kernel build
    for the Raspberry Pi* section*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As described previously, first obtain a snapshot of the currently loaded kernel
    modules, and then have the kbuild system operate upon it by specifying the `localmodconfig`
    target, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, something to understand: when we perform the actual `make [...] localmodconfig`
    command, it''s entirely possible, indeed even probable, that there will be a difference
    in the configuration options between the kernel you are currently building (version
    5.4) and the kernel you are currently actually running the build on (`$(uname
    -r) = 5.0.0-36-generic`, here). In these cases, the kbuild system will display
    every single new config option and the available values you can set it to, on
    the console (terminal) window. Then, it will prompt the user to select the value
    of any new config options it encounters in the kernel being built. You will see
    this as a series of questions and a prompt to answer them on the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: The prompt will be suffixed with `(NEW)`, in effect telling you that this is
    a *new* kernel config option and it wants your answer as to how to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, at least, we will take the easy way out: just press the `[Enter]` key
    to accept the default selection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After pressing the `[Enter]` key many times, the interrogation mercifully finishes
    and the kbuild system writes the newly generated configuration to the `.config` file in
    the current working directory (we truncated the previous output as it's simply
    too voluminous, and unnecessary, to reproduce fully).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding two steps take care of generating the `.config` file via the
    `localmodconfig` approach. Before we conclude this section, here are some key
    points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: To ensure a completely clean slate, run `make mrproper` or `make distclean`
    in the root of the kernel source tree (useful when you want to restart from scratch;
    rest assured, it will happen one day! Note that doing this deletes the kernel
    configuration file(s) too).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, in this chapter, all the kernel configuration steps and the screenshots
    pertaining to it have been performed on an Ubuntu 18.04.3 LTS x86-64 guest VM,
    which we use as the host to build a brand spanking new 5.4 Linux kernel. The precise
    names, the presence and content of the menu items, as well as the look and feel
    of the menu system (the UI) can and do vary based on (a) the architecture (CPU)
    and (b) the kernel version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned earlier, on a production system or project, the platform or **Board
    Support Package** (**BSP**) team, or indeed the embedded Linux BSP vendor company
    if you have partnered with one, will provide a good known, working, and tested
    kernel config file. Do use this as a starting point by copying it onto the `.config` file
    in the root of the kernel source tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you gain experience with building the kernel, you will realize that the effort
    in setting up the kernel configuration correctly the first time (critical!) is
    higher; and, of course, the time required for the very first build is a lengthy
    one. Once done correctly, though, the process typically becomes much simpler –
    a recipe to run over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to use a useful and intuitive UI to tune our kernel configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning our kernel configuration via the make menuconfig UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay, great, we now have an initial kernel config file (`.config`) generated
    for us via the `localmodconfig` Makefile target, as shown in detail in the previous
    section, which is a good starting point. Now, we want to further examine and fine-tune
    our kernel''s configuration. One way to do this – in fact, the recommended way
    – is via the `menuconfig` Makefile target. This target has the kbuild system generate
    a pretty sophisticated (C-based) program executable (`scripts/kconfig/mconf`),
    which presents to the end user a neat menu-based UI. In the following code block,
    when we invoke the command for the first time, the kbuild system builds the `mconf`
    executable and invokes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, a picture is no doubt worth a thousand words, so here''s what the
    `menuconfig` UI looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddd39591-ff94-4c75-998d-f87fb3b1fa17.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The main menu of kernel configuration via make menuconfig (on x86-64)
  prefs: []
  type: TYPE_NORMAL
- en: 'As experienced developers, or indeed anyone who has sufficiently used a computer,
    well know, things can and do go wrong. Take, for example, the following scenario
    – running `make menuconfig` for the first time on a freshly installed Ubuntu system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Hang on, don''t panic (yet). Read the failure message(s) carefully. The line
    after `YACC [...]` provides the clue: `/bin/sh: 1: bison: not found`. Ah, so install
    `bison(1)` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt install bison`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all should be well. Well, almost; again, on a freshly baked Ubuntu guest,
    `make menuconfig` then complains that `flex(1)` was not installed. So, we install
    it (you guessed it: via `sudo apt install flex`). Also, specifically on Ubuntu,
    you need the `libncurses5-dev` package installed (on Fedora, do `sudo dnf install
    ncurses-devel`).'
  prefs: []
  type: TYPE_NORMAL
- en: If you have read and followed [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel*
    *Workspace Setup*, you would have all these prerequisite packages already installed.
    If not, please refer to it now and install all required packages. Remember, *as
    ye sow…*
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving along, the kbuild open source framework (reused in a whole bunch of
    projects, incidentally) provides some clues to the user via its UI. The meaning
    of the symbols prefixing the menu entries are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[.]`: In-kernel feature, Boolean option (it''s either on or off):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[*]`: On, feature compiled and built in (compiled in) to the kernel image
    (y)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ ]`: Off, not built at all (n)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<.>`: A feature that could be in one of three states (tristate):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<*>`: On, feature compiled and built in (compiled in) the kernel image (y)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<M>`: Module, feature compiled and built as a kernel module (an LKM) (m)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`< >`: Off, not built at all (n)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{.}`: A dependency exists for this config option; hence, it''s required to
    be built (compiled) as either a module (m) or built in (compiled in) to the kernel
    image (y).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-*-`: A dependency requires this item to be compiled in (y).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(...)`: Prompt: an alphanumeric input is required (press the `[Enter]` key
    while on this option and a prompt appears).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Menu entry>  --->`: A sub-menu follows (press `[Enter]` on this item to navigate
    to the sub-menu).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, the empirical approach is key. Let's actually experiment with the `make
    menuconfig` UI to see how it works. This is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sample usage of the make menuconfig UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get a feel for using the kbuild menu system via the convenient `menuconfig`
    target, let's step through the process to navigate to the tristate menu item called
    `Kernel .config support`. It will be off by default, so let's turn it on; that
    is, let's make it `y`, built into the kernel image. We can find it under the `General
    Setup` main menu item on the home screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'What exactly does turning this feature on achieve? When turned on to `y` (or,
    of course, if made to `M`, then a kernel module will become available, and once
    it''s loaded up), then the currently running kernel''s configuration settings
    can be looked up at any time in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By running the `scripts/extract-ikconfig` script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By directly reading the content of the `/proc/config.gz` pseudo-file (of course,
    it's `gzip(1)`-compressed; first uncompress it, and then read it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a learning exercise, we will now learn how to configure our 5.4 Linux kernel
    (for the x86-64 architecture) for the kernel config options with the values shown
    in the following table. For now, don''t stress regarding the meaning of each of
    these options; it''s just to get some practice with the kernel config system:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Effect and location in the make menuconfig UI** |  **Select
    the < Help > button**'
  prefs: []
  type: TYPE_NORMAL
- en: '**to see the precise CONFIG_<FOO> option** | **Value: original** **-> new value**
    |'
  prefs: []
  type: TYPE_NORMAL
- en: '| Local version | Sets the `-EXTRAVERSION` component of the kernel release/version
    (seen with `uname -r`); `General Setup / Local version - append to kernel release`
    | `CONFIG_LOCALVERSION` | (none) -> `-llkd01` |'
  prefs: []
  type: TYPE_TB
- en: '| Kernel config file support | Allows you to see the current kernel configuration
    details;  `General Setup / Kernel .config support` | `CONFIG_IKCONFIG` |  `n`
    -> `y` |'
  prefs: []
  type: TYPE_TB
- en: '| The same as the preceding plus access via procfs | Allows you to see the
    current kernel configuration details via **proc filesystem** (**p****rocfs**);  `General
    Setup / Enable access to .config through /proc/config.gz` | `CONFIG_IKCONFIG_PROC`
    | `n` -> `y` |'
  prefs: []
  type: TYPE_TB
- en: '| Kernel profiling | Kernel profiling support; `General Setup / Profiling support`
    | `CONFIG_PROFILING` | `y` -> `n` |'
  prefs: []
  type: TYPE_TB
- en: '| HAM radio | Support for HAM radio; `Networking support /  Amateur Radio support`
    | `CONFIG_HAMRADIO` | `y` -> `n` |'
  prefs: []
  type: TYPE_TB
- en: '| VirtualBox support | (Para)virtualization support for VirtualBox; `Device
    Drivers / Virtualization drivers / Virtual Box Guest integration support` | `CONFIG_VBOXGUEST`
    | `n` -> `m` |'
  prefs: []
  type: TYPE_TB
- en: '| **Userspace IO Drivers** (**UIO**) | UIO support; `Device Drivers / Userspace
    I/O Drivers` | `CONFIG_UIO` | `n` -> `m` |'
  prefs: []
  type: TYPE_TB
- en: '| The preceding plus the UIO platform driver with generic IRQ handling | UIO
    platform driver with generic IRQ handling; `Device Drivers / Userspace I/O Drivers
    / Userspace I/O platform driver with generic IRQ handling` | `CONFIG_UIO_PDRV_GENIRQ`
    | `n` -> `m` |'
  prefs: []
  type: TYPE_TB
- en: '| MS-DOS filesystem support | `File systems / DOS/FAT/NT Filesystems / MSDOS
    fs support` | `CONFIG_MSDOS_FS` | `n` -> `m` |'
  prefs: []
  type: TYPE_TB
- en: '| Security: LSMs | Turn *off* kernel LSMs; `Security options / Enable different
    security models` *(NOTE: it''s typically, safer to keep this ON for production
    systems!)* | `CONFIG_SECURITY` | `y` -> `n` |'
  prefs: []
  type: TYPE_TB
- en: '| Kernel debug: stack utilization info | `Kernel hacking / Memory Debugging
    / Stack utilization instrumentation` | `CONFIG_DEBUG_STACK_USAGE` | `n` -> `y`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.4 – Items to configure
  prefs: []
  type: TYPE_NORMAL
- en: 'How exactly do you interpret this table? Let''s take the first row as an example;
    we go over it column by column:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The first column **specifies the kernel *feature* we are wanting to modify
    (edit/enable/disable). Here, it''s the last part of the kernel version string
    (as it shows up in the output of `uname -r`). It''s called the `-EXTRAVERSION`
    component of the release (see the *Kernel release nomenclature* section for details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The second column **specifies two things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One, what we're attempting to do. Here, we want to *set* the `-EXTRAVERSION`
    component of the kernel release string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two, the location of this kernel config option within the `menuconfig` UI is
    shown. Here, it's within the `General Setup` sub-menu, and under that it's the
    menu item called `Local version - append to kernel release`*.* We write it as
    `General Setup / Local version - append to kernel release`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The third column** specifies the kernel config option''s name as `CONFIG_<FOO>`.
    You can search for this within the menu system if required. In this example, it''s
    called `CONFIG_LOCALVERSION`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The fourth column** shows the original *value* of this kernel config option
    and the value we''d like you to change it to (the "new" value). It''s shown in
    the format *original value -> new value.* In our example, it''s `(none) -> -llkd01`,
    implying that the original value of the `-EXTRAVERSION` string component was empty
    and we would like you to modify it, changing it to the value `-llkd01`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, for several items we show, it may not be immediately apparent
    – say `n -> m`; what does this mean? `n -> m` implies that you should change the
    original value from `n` (not selected) to `m` (selected to be built as a kernel
    module). Similarly, the `y -> n` string means change the config option from on
    to off.
  prefs: []
  type: TYPE_NORMAL
- en: You can *search* for kernel config options within the `menuconfig` system UI
    by pressing the / key (just as with vi; we show more on this in the section that
    follows).
  prefs: []
  type: TYPE_NORMAL
- en: Then (in the following chapter, actually), we will build the kernel (and modules)
    with these new config options, boot from it, and verify that the preceding kernel
    config options were set as we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'But right now, you are expected to do your bit: fire up the menu UI (with the
    usual `make menuconfig`), then navigate the menu system, finding the relevant
    kernel config options described previously, and edit it as required, to whatever
    the fourth column in the preceding table shows.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that, depending on the Linux distribution you're currently running and
    its kernel modules (we used `lsmod(8)` to generate an initial config, remember?),
    the actual values and defaults you see when configuring the kernel might differ
    from that of the *Ubuntu 18.04.3 LTS* distribution (running the 5.0.0-36-generic
    kernel), as we have used and shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, to keep the discussion sane and compact, we will only show the complete
    detailed steps in setting up the second and third of the kernel config options
    shown in the preceding table (the `Kernel .config support` ones). It''s up to
    you to edit the remainder. Let''s get going:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change directory to the root of your kernel source tree (wherever you extracted
    it on your disk):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up an initial kernel configuration file, based on the third approach described
    previously (in the *Tuned kernel config via the localmodconfig approach* section):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once the `menuconfig` UI loads up, go to the `General Setup` menu item. Usually,
    it's the second item on x86-64\. Navigate to it using the keyboard arrow keys
    and enter into it by pressing the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You are now within the `General Setup` menu item. Scroll down the menu items
    by pressing the down arrow key a few times. We scroll down to the menu of interest
    for us – `Kernel .config support` – and highlight it; the screen should look (something)
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/255d0e1a-ffed-4ada-8417-3c7a437fbcf8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Kernel configuration via make menuconfig; General setup / Kernel
    .config support
  prefs: []
  type: TYPE_NORMAL
- en: For the 5.4.0 vanilla Linux kernel on the x86-64, `General Setup / Kernel .config
    support` is the 20^(th) menu item from the top of the `General Setup` menu.
  prefs: []
  type: TYPE_NORMAL
- en: Once on the `Kernel .config support` menu item, we can see (in the preceding
    screenshot) from its `<M>` prefix that it's a tristate menu item that's set to
    the choice `<M>` for module, to begin with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keeping this item (`Kernel .config support`) highlighted, use the right arrow
    key to navigate to the `< Help >` button on the bottom toolbar and press the *Enter*
    key while on the `< Help >` button. The screen should now look (something) like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bc005d7d-6840-4224-b325-471055fb315a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Kernel configuration via make menuconfig; an example help screen
  prefs: []
  type: TYPE_NORMAL
- en: The help screen is quite informative. Indeed, several of the kernel config help
    screens are very well populated and actually helpful. Unfortunately, some just
    aren't.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, next, press *Enter *on the `< Exit >` button so that we go back to the
    previous screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, toggle the `Kernel .config support` menu item by pressing the space bar
    (assuming it''s initially like this: `<M>`; that is, set to module). Pressing
    the space bar once makes the UI items appear like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice how it's become `<*>`, implying that this feature will be built into
    the kernel image itself (in effect, it will be *always on*). For now, let's do
    it this way (of course, pressing the space bar again makes it toggle to the off
    state, `< >`, and then back to the original `<M>` state).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with the item in the `<*>` (yes) state, scroll down to the next menu item, `[*]
    Enable access to .config through /proc/config.gz`, and enable it (again, by pressing
    the space bar); the screen should now appear (something) like this (we''ve zoomed
    in to the relevant portion only):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d2f0a06-cb54-459c-994f-7f2dbeca1af5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8 – Kernel configuration via make menuconfig: toggling a Boolean config
    option to the on state'
  prefs: []
  type: TYPE_NORMAL
- en: You can always use the right arrow key to go to `< Help >` and view the help
    screen for this item as well.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will not explore the remaining kernel config menus; I will leave that
    to you to find and set as shown in the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the main menu (the home screen), use the right arrow key to navigate
    to the `< Exit >` button and press *Enter* on it. A dialog pops up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/53fdb7cc-c7d3-44ff-bd7e-b6bef75f611c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9 – Kernel configuration via make menuconfig: save dialog'
  prefs: []
  type: TYPE_NORMAL
- en: It's quite straightforward, isn't it? Press *Enter *on the `< Yes >` button
    to save and exit. If you select the `< No >` button, you lose all your configuration
    changes (made during this session). Or, you can press the *Esc* key *twice* to
    get rid of this dialog and continue working on the kernel config.
  prefs: []
  type: TYPE_NORMAL
- en: Save and exit. Press *Enter *while on the `< Yes >` button. The menu system
    UI now saves the new kernel configuration and the process exits; we're back on
    the console (a shell or terminal window) prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But where’s the new kernel configuration saved? This is important: the kernel
    configuration is written into a simple ASCII text file in the root of the kernel
    source tree, named **`.config`**. That is, it''s saved in `${LLKD_KSRC}/.config`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, every single kernel config option is associated with
    a config variable of the form `CONFIG_<FOO>`, where `<FOO>`, of course, is replaced
    with an appropriate name. Internally, these become *macros* that the build system
    and indeed the kernel source code uses. For example, consider this for the `Kernel
    .config support` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha! The configuration now reflects the fact that we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Turned on the `CONFIG_IKCONFIG` kernel feature (`=y` indicates that it is on
    and will be built into the kernel image).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/proc/config.gz` (pseudo) file will now be available, as `CONFIG_IKCONFIG_PROC=y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caution*:* it's best to NOT attempt to edit the `.config` file manually ("by
    hand"). There are several inter-dependencies you may not be aware of; always use
    the kbuild menu system (we suggest via `make menuconfig`) to edit it.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, during our quick adventure with the kbuild system so far, quite
    a lot has occurred under the hood. The next section examines a little bit to do
    with this, searching within the menu system and cleanly visualizing the differences
    between the original (or older) and new kernel configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: More on kbuild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creation of, or edits to, the `.config` file within the root of the kernel
    source tree via `make menuconfig` or other methods is not the final step in how
    the kbuild system works with the configuration. No, it now proceeds to internally
    invoke a target called `syncconfig`, which was earlier (mis)named `silentoldconfig`.
    This target has kbuild generate a few header files that are further used in the
    setup to build the kernel. These files include some meta headers under `include/config`,
    as well as the `include/generated/autoconf.h` header file, which stores the kernel
    config as C macros, thus enabling both the kernel Makefile(s) and kernel code
    to make decisions based on whether or not a kernel feature is available.
  prefs: []
  type: TYPE_NORMAL
- en: Moving along, what if you are looking for a particular kernel configuration
    option but are having difficulty spotting it? No problem, the `menuconfig` UI
    system has a `Search Configuration Parameter`feature. Just as with the famous
    `vi(1)` editor, press the `/` (forward slash) key to have a search dialog pop
    up, then enter your search term with or without `CONFIG_` preceding it, and select
    the `< Ok >` button to have it go on its way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following couple of screenshots show the search dialog and the result dialog
    (as an example, we searched for the term `vbox`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c56f14c-3dad-4cb4-8931-d4d1cbdc2efc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10 – Kernel configuration via make menuconfig: searching for a config
    parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result dialog for the preceding search is interesting. It reveals several
    pieces of information regarding the configuration option(s):'
  prefs: []
  type: TYPE_NORMAL
- en: The config directive (just prefix `CONFIG_` onto whatever it shows in `Symbol:`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of config (Boolean, tristate, alphanumeric, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prompt string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importantly, its location in the menu system (so you can find it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its internal dependencies, if any
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any config option it auto-selects (turns on) if it itself is selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the result dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78b4af6f-1d70-4004-b7b4-91e1de325f23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11 – Kernel configuration via make menuconfig: the result dialog from
    the preceding search'
  prefs: []
  type: TYPE_NORMAL
- en: All this information is present in an ASCII text file used by the kbuild system
    to build the menu system UI – this file is called `Kconfig` (there are several
    of them, actually). Its location, too, is shown (in the `Defined at ...` line).
  prefs: []
  type: TYPE_NORMAL
- en: Looking up the differences in configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The moment the `.config` kernel configuration file is to be written to, the
    kbuild system checks whether it already exists, and if so, it backs it up with
    the name `.config.old`. Knowing this, we can always differentiate the two to see
    the changes we have wrought. However, using your typical `diff(1)` utility to
    do so makes the differences quite hard to interpret. The kernel helpfully provides
    a better way, a console-based script that specializes in doing precisely this. The `scripts/diffconfig` script
    (within the kernel source tree) is really useful for this. To see why, let''s
    just run its help screen first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you modified the kernel configuration changes as shown in the preceding table,
    you should see an output similar to that shown in the preceding code block via
    the kernel's `diffconfig` script. It clearly shows us exactly which kernel config
    options we changed and how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish, a quick note on something critical: *kernel security*. While
    userspace security hardening technologies have vastly grown, kernel-space security
    hardening technologies are actually playing catch-up. Careful configuration of
    the kernel''s config options does play a key role in determining the security
    posture of a given Linux kernel; the trouble is, there are so many options (and
    indeed opinions) that it''s often hard to (cross) check what''s a good idea security-wise
    and what isn''t. Alexander Popov has written a very useful Python script named `kconfig-hardened-check`;
    it can be run to check and compare a given kernel configuration (via the usual
    config file) to a set of predetermined hardening preferences (from various Linux
    kernel security projects: the well known **Kernel Self Protection Project** (**KSPP**),
    the last public grsecurity patch, the CLIP OS and the security lockdown LSM).
    Lookup the `kconfig-hardened-check` GitHub repository at [https://github.com/a13xp0p0v/kconfig-hardened-check](https://github.com/a13xp0p0v/kconfig-hardened-check) and
    try it out!'
  prefs: []
  type: TYPE_NORMAL
- en: Alright! You have now completed the first three steps of the Linux kernel build,
    quite a thing. (Of course, we will complete the remaining four steps in the build
    process in the following chapter.) We will end this chapter with a final section
    on learning a useful skill – how to customize the kernel UI menu.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the kernel menu – adding our own menu item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's say you have developed a device driver, an experimental new scheduling
    class, a custom `debugfs` (debug filesystem) callback, or some other cool kernel
    feature. How will you let others on the team – or for that matter, your customer
    – know that this fantastic new kernel feature exists and allow them to select
    it (as either a built-in or as a kernel module) and thus build and make use of
    it? The answer is to insert *a new menu item* at an appropriate place in the kernel
    configuration menu.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, it's useful to first understand a little more about the various `Kconfig*` files
    and where they reside. Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: The Kconfig* files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Kconfig` file at the root of the kernel source tree is used to fill in
    the initial screen of the `menuconfig` UI. Take a look at it if you wish. It works
    by sourcing various other `Kconfig` files in different folders of the kernel source
    tree. The following table summarizes the more important `Kconfig*` files and which
    menu they serve in the kbuild UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Menu** | **Kconfig file location for it** |'
  prefs: []
  type: TYPE_TB
- en: '| The main menu, the initial screen | `Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| General setup+ Enable loadable module support | `init/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Processor types and features + Bus options + Binary Emulations'
  prefs: []
  type: TYPE_NORMAL
- en: '(arch-specific; above the menu title is for x86; in general, the Kconfig file
    is here: `arch/<arch>/Kconfig`) | `arch/<arch>/Kconfig` |'
  prefs: []
  type: TYPE_NORMAL
- en: '| Power management | `kernel/power/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Firmware drivers | `drivers/firmware/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Virtualization | `arch/<arch>/kvm/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| General architecture-dependent options | `arch/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Enable the block layer + IO Schedulers | `block/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Executable file formats | `fs/Kconfig.binfmt` |'
  prefs: []
  type: TYPE_TB
- en: '| Memory Management options | `mm/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Networking support | `net/Kconfig, net/*/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Device Drivers | `drivers/Kconfig, drivers/*/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| File systems | `fs/Kconfig, fs/*/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Security options | `security/Kconfig, security/*/Kconfig*` |'
  prefs: []
  type: TYPE_TB
- en: '| Cryptographic API | `crypto/Kconfig, crypto/*/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Library routines | `lib/Kconfig, lib/*/Kconfig` |'
  prefs: []
  type: TYPE_TB
- en: '| Kernel hacking | `lib/Kconfig.debug, lib/Kconfig.*` |'
  prefs: []
  type: TYPE_TB
- en: Table 2.5 – Kernel config menu items and the corresponding Kconfig* file defining
    them
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a single `Kconfig` file drives a single menu. Now, let's move on
    to actually adding a menu item.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new menu item in the Kconfig file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a trivial example, let's add our own Boolean dummy config option within the `General
    Setup` menu. We want the config name to be `CONFIG_LLKD_OPTION1`. As can be seen
    from the preceding table, the relevant `Kconfig` file to edit is the `init/Kconfig`
    one as this is the menu meta file that defines the `General Setup` menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be safe, always make a backup copy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit the `init/Kconfig` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down to an appropriate location within the file; here, we choose to
    insert our menu entry just after the `CONFIG_LOCALVERSION_AUTO` one. The following
    screenshot shows our new entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e083586-fb43-43a6-b1af-f5675e70bb4d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Editing init/Kconfig and inserting our own menu entry
  prefs: []
  type: TYPE_NORMAL
- en: We have provided the preceding text as a patch to the original `init/Kconfig`
    file in our book's *GitHub* source tree. Find it under `ch2/Kconfig.patch`.
  prefs: []
  type: TYPE_NORMAL
- en: The new item starts with the `config` keyword followed by the `FOO` part of
    your new `CONFIG_LLKD_OPTION1` config variable. For now, just read the statements
    we have made in the `Kconfig` file regarding this entry. More details on the `Kconfig`
    language/syntax are in the *A few details on the Kconfig language* section that
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and exit the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(Re)configure the kernel. Navigate to our new menu item and turn the feature
    on (notice how, in the following clipped screenshot, it''s highlighted and *off*
    by default):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b201c7d0-b928-4192-8c15-99660dcbccac.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Kernel configuration via make menuconfig showing our new menu
    entry
  prefs: []
  type: TYPE_NORMAL
- en: Turn it *on* (toggle it with the space bar), then save and exit the menu system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While there, try pressing the `< Help >` button. You should see the "help" we
    provided within the `Kconfig` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether our feature has been selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We find that indeed it has been set to *on* within our `.config` file, but is
    not (yet!) within the kernel's internal auto-generated header file. This will
    happen when we build the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the kernel (worry not; the full details on building the kernel are found
    in the next chapter. You could always first cover [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 2*, and then come back to this
    point, if you so wish...):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, recheck the `autoconf.h` header for the presence of our new config
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It worked! Yes, but when working on an actual project (or product), we would
    typically require a further step, setting up our config entry within the Makefile relevant
    to the code that uses this config option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick example of how this might look. In the kernel''s top-level
    (or whichever) Makefile, the following line will ensure that our own code (the
    following is within the `llkd_option1.c` source file) gets compiled into the kernel
    at build time. Add this line to the end of the relevant Makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Don't stress about the fairly weird kernel Makefile syntax for now. The next
    few chapters will shed some light on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you should realize that the very same config can be used as a normal
    C macro within a piece of kernel code; for example, we could do things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it''s very much worth noting that the Linux kernel community has devised
    and strictly adheres to certain rigorous coding style guidelines. In this context,
    the guidelines state that conditional compilation should be avoided whenever possible,
    and if it is required to use a `Kconfig` symbol as a conditional, then please
    do it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The Linux kernel *coding style guidelines* can be found here: [https://www.kernel.org/doc/html/latest/process/coding-style.html](https://www.kernel.org/doc/html/latest/process/coding-style.html).
    I urge you to refer to them often, and, of course, to follow them!
  prefs: []
  type: TYPE_NORMAL
- en: A few details on the Kconfig language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our usage of the `Kconfig` language so far is just the tip of the proverbial
    iceberg. The fact is, the kbuild system uses the `Kconfig` language (or syntax)
    to express and create menus using simple ASCII text directives. The language includes
    menu entries, attributes, (reverse) dependencies, visibility constraints, help
    text, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel documents the `Kconfig` language constructs and syntax here: [https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt](https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt).
    Do refer to this document for complete details.
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief (and incomplete) mention of the more common `Kconfig` constructs is
    given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Construct** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `config <FOO>` | Specifies the menu entry name (of the form `CONFIG_FOO`)
    here; just put the `FOO` part. |'
  prefs: []
  type: TYPE_TB
- en: '| **Menu attributes** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `  bool ["<description>"]` | Specifies the config option as a *Boolean*;
    its value in `.config` will be either `Y` (built into the kernel image) or will
    not exist (will show up as a commented-out entry). |'
  prefs: []
  type: TYPE_TB
- en: '| `  tristate ["description>"]` | Specifies the config option as *tristate*;
    its value in `.config` will be either `Y`,  `M` (built as a kernel module), or
    will not exist (will show up as a commented-out entry) |'
  prefs: []
  type: TYPE_TB
- en: '| `  int ["<description>"]` | Specifies the config option as taking an *integer*
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `     range x-y` | The integer range is from `x` to `y`. |'
  prefs: []
  type: TYPE_TB
- en: '| `  default <value>` | Specifies the default value; use `y`, `m`, `n`, or
    another, as required.  |'
  prefs: []
  type: TYPE_TB
- en: '| ` prompt "<description>"` | A sentence describing the kernel config. |'
  prefs: []
  type: TYPE_TB
- en: '| `depends on "expr"` | Defines a dependency for the menu item; can have several
    with the `depends on FOO1 && FOO2 && (FOO3 &#124;&#124; FOO4)` type of syntax.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `select <config> [if "expr"]` | Defines a reverse dependency. |'
  prefs: []
  type: TYPE_TB
- en: '| `help "help-text"` | Text to display when the `< Help >` button is selected.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.6 – Kconfig, a few constructs
  prefs: []
  type: TYPE_NORMAL
- en: 'To help understand the syntax, a few examples from `lib/Kconfig.debug` (the
    file that describes the menu items for the `Kernel Hacking` - kernel debugging,
    really - section of the UI) follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with a simple one (the `CONFIG_DEBUG_INFO` option):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the `CONFIG_FRAME_WARN` option. Notice `range` and the
    conditional default value syntax, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `CONFIG_HAVE_DEBUG_STACKOVERFLOW` option is a simple Boolean; it''s
    either on or off. The `CONFIG_DEBUG_STACKOVERFLOW` option is also a Boolean. Notice
    how it depends on two other options, separated with a Boolean AND (`&&`) operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Alright! This completes our coverage for creating (or editing) a custom menu
    entry in the kernel config, and indeed this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you first learned how to obtain for yourself a Linux kernel
    source tree. You then understood its release (or version) nomenclature, the various
    types of Linux kernels (`-next` trees, `-rc`/mainline trees, stable, LTS, SLTS
    and distributions), and the basic kernel development workflow. Along the way,
    you even got a quick tour of the kernel source tree so that its layout is clearer.
    Next, you saw how to extract the compressed kernel source tree to disk and, critically,
    how to configure the kernel – a key step in the process. Furthermore, you learned
    how to customize the kernel menu, adding your own entries to it, and a bit about
    the kbuild system and the associated `Kconfig` files it uses, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to fetch and configure the Linux kernel is a useful skill to possess.
    We have just begun this long and exciting journey. You will realize that with
    more experience and knowledge of kernel internals, drivers, and the target system
    hardware, your ability to fine-tune the kernel to your project's purpose will
    only get better.
  prefs: []
  type: TYPE_NORMAL
- en: We're halfway there; I suggest you first digest this material, and, importantly
    - try out the steps in this chapter, work on the questions/exercises, and browse
    through the *Further reading *section. Then, in the next chapter, let's actually
    build the 5.4.0 kernel and verify it!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help you delve deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times, even books)
    in a Further reading document in this book's GitHub repository. The *Further reading*
    document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  prefs: []
  type: TYPE_NORMAL
