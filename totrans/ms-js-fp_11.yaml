- en: Implementing Design Patterns - The Functional Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring Purity
    - Immutability*, we saw several functional techniques to solve different problems.
    However, programmers who are used to employing OOP may find that we have missed
    some well-known formulae and solutions, which are often used in imperative coding.
    Since design patterns are well known, and programmers will be likely already be
    aware of how they are applied in other languages, it's important to take a look
    at how a functional implementation would be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall consider the solutions implied by *design patterns*,
    which are common in OOP to see their equivalences in FP. In particular, we will
    study the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of *design patterns*and to what they apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few OOP standard patterns and what alternative we have in FP, if we need one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A discussion about FP design patterns, not related to the OOP ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Design Patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most relevant books in software engineering was d*esign patterns:
    Elements of Reusable Object-Oriented Software*, 1994, written by the**GoF** (**Gang
    of Four**): Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. This
    book presented about two dozen different OOP *patterns*and has been recognized
    as a highly important book in computer science.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Patterns* are actually a concept from architectural design, originally defined
    by an architect, Christopher Alexander.'
  prefs: []
  type: TYPE_NORMAL
- en: In software terms, a *design pattern* is a generally applicable, reusable solution,
    to a usually seen, common problem in software design. Rather than a specific,
    finished and coded design, it's a description of a solution (the word *template*is
    also used) that can solve a given problem that appears in many contexts. Given
    their advantages, design patterns are on their own *best practices*, which can
    be used by developers working with different kinds of systems, programming languages,
    and environments.
  prefs: []
  type: TYPE_NORMAL
- en: The book obviously focused on OOP, and some of the patterns within cannot be
    recommended for or applied in FP. Other patterns are unnecessary or irrelevant
    because FP languages already provide standard solutions to the corresponding OOP
    problems. Even given this difficulty, since most programmers have been exposed
    to OOP design patterns and usually try to apply them even in other contexts such
    as FP, it makes sense to consider the original problems and then take a look at
    how a new solution can be produced. The standard object-based solutions may not
    apply, but the problem can still stand, so seeing how to solve it is still valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns are often described in terms of four essential, basic elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A simple, short, *name*that is used to describe the problem, its solutions,
    and their consequences. The name is useful for talking with colleagues, explaining
    a design decision, or describing a specific implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *context* to which the pattern applies: this implies specific situations
    that require a solution, with possibly some extra conditions that must be met.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A*solution* that lists the elements (classes, objects, functions, relationships,
    and so on) that you'll need in order to solve the given situation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *consequences* (results and trade-offs) if you apply the pattern. You may
    derive some gains from the solution, but it may also imply some losses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we will assume that the reader is already aware of the design
    patterns that we will be describing and using, so we won't be providing much details
    about them. Rather, we will focus on how FP either makes the problem irrelevant
    (because there is an obvious way of applying functional techniques to solve it)
    or solves it in some fashion. Also, we won't be going over all the GoF patterns;
    we'll just focus on those for which applying FP is more interesting, bringing
    out more differences with the usual OOP implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Design pattern categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Design patterns are usually grouped into several distinct categories, according
    to their focus. The firstthree in the following list are the ones that appeared
    in the original GoF book, but more categories have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavioral design patterns**: These have to do with interactions and communications
    between objects. Rather than focusing on how objects are created or built, the
    key consideration is how to connect them so that they can cooperate when performing
    a complex task, preferably in a way that provides well-known advantages, such
    as diminished *coupling* or enhanced *cohesiveness*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creational design patterns**: They deal with ways to create objects in a
    manner that is suitable for the current problem, possibly guiding the selection
    between several alternative objects, so the program can work in different ways
    depending on parameters that may be known at compilation time or at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural design patterns**: They have to do with the composition of objects,
    forming larger structures from many individual parts and implementing relationships
    between objects. Some of the patterns imply inheritance or implementation of interfaces,
    whereas others use different mechanisms, all geared towards being able to dynamically
    change the way objects are composed at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency patterns**: They are related to dealing with multithreaded programming.
    Although FP is generally quite appropriate for that (given, for example, the lack
    of assignments and side effects) since we are working with JavaScript, these patterns
    are not very relevant to us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architectural patterns**: They are more high-level oriented, with a broader
    scope than the previous patterns we''ve listed, and provide general solutions
    to software architecture problems. As is, we aren''t considering such problems
    in the book, so we won''t deal with these either.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coupling and cohesiveness are terms that were in use even before OOP came into
    vogue; they date back to the late 60's when*Structured Design*by Larry Constantine
    was out. The former measures the interdependence between any two modules,and the
    latter has to do with the degree to which all components of a module really belong
    together. Low coupling and high cohesiveness are good goals for software design
    because they imply that related things are close by and unrelated ones are separate.
  prefs: []
  type: TYPE_NORMAL
- en: Following along these lines, you could also classify design patterns as *Object
    Patterns* (which concern the dynamic relationships between objects) and *Class
    Patterns*that deal with the relationships between classes and subclasses (which
    are defined statically at compile time). We won't be worrying much about this
    classification because our point of view has more to do with behaviors and functions
    rather than classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, we can now readily observe that these categories are
    heavily oriented toward OOP, and the first three directly mention objects. However,
    without the loss of generality, we will look beyond the definitions, remember
    what problem we were trying to solve, and then look into analogous solutions with
    FP, which if not 100% equivalent to the OOP ones, will in spirit be solving the
    same problem in a parallel way.
  prefs: []
  type: TYPE_NORMAL
- en: Do we need design patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an interesting point of view that says that design patterns are only
    needed to patch shortcomings of a programming language. The rationale is that
    if you can solve a problem with a language, in a simple, trivial way, then you
    may not need a design pattern at all.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, it's interesting, for OOP developers, to really understand why
    FP helps solve some problems without need of further tools. In the next section,
    we shall consider several well-known design patterns and take a look at why we
    don't need them or how we can easily implement them. It's also a fact that we
    have already applied several patterns earlier in the text, so we'll point out
    to those examples as well.
  prefs: []
  type: TYPE_NORMAL
- en: We won't try, however, to express or convert all design patterns into FP terms.
    For example, the *Singleton* pattern basically requires a single, global, object,
    which is sort of opposed to everything that functional programmers are used to.
    Given our approach to FP (remember SFP, *Sorta Functional Programming*, from the
    initial part of the first chapter?), we won't mind either, and if a Singleton
    is required, we may consider using it, even though FP doesn't have an appropriate
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it must be said that one's point of view may affect what is considered
    a pattern and what isn't. What may be a pattern to some may be considered a trivial
    detail for others. We will find some such situations, given that FP lets us solve
    some particular problems in easy ways, and we have already seen examples of that
    in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll go over some of the GoF design patterns, check whether
    they are pertinent to FP, and study how to implement them. Of course, there are
    some design patterns that don't get an FP solution. For example, there's no equivalent
    for a Singleton, which implies the foreign concept of a globally accessed object.
    Also, while it's true that you may no longer need OOP-specific patterns, developers
    will still think in terms of those. Also, finally, since we're not going *fully
    functional* if an OOP pattern fits, why not use it?
  prefs: []
  type: TYPE_NORMAL
- en: Façade and Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of these two patterns, let's start with the *Façade*. This is meant tosolve
    the problem of providing a different interface to the methods of a class or to
    a library. The idea is to provide a new interface to a system that makes it easier
    to use. You might say that aFaçade provides a better *control panel*to access
    certain functionalities, removing difficulties for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Façade or facade? The original word is an architectural term meaning the *front
    of a building* and comes from the French language. According to this source andthe
    usual sound of the cedilla (ç) character, its pronunciation is something like
    *fuh-sahd*. The other spelling probably has to do with the lack of international
    characters in keyboards and poses the following problem: Shouldn''t you read it
    as *faKade*? You may see this problem as the reverse of *celtic*, which is pronounced
    as *Keltic*, changing the *s*sound for a *k*sound.'
  prefs: []
  type: TYPE_NORMAL
- en: The main problem that we want to solve is being able to use external code in
    an easier way (of course, if it were your code, you could handle such problems
    directly; we must assume you cannot--or shouldn't--try to modify that other code.
    This would be the case when you use any library that's available over the web,
    for example). The key to this is to implement a module of your own that will provide
    an interface that better suits your need. Your code will use your module and won't
    directly interact with the original code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want to do Ajax calls, and your only possibility is using
    some hard library with a really complex interface. With ES8''s modules, you might
    write something as the following, working with an imagined hard Ajax library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you need to do a `GET` or `POST`, instead of having to go through all
    the complications of the provided hard Ajax library, you can use the new façade
    that provides a simpler way of working. Developers would just `import {getUrl,
    postUrl} from "simpleAjax"` and could then work in a more reasonable way.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, why are we showing this code that, though interesting, doesn''t show
    any particular FP aspects? The key is that, at least until modules are fully implemented
    in browsers, the internal, implicit way to do this is with the usage of an IIFE
    (*immediately invoked function expression*) as we saw in the*Immediate Invocation*sectionof
    [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with Functions
    - A Core Concept*, by means of a *revealing module* pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The reason for the *revealing module*name should be now obvious. With the preceding
    code, because of the scope rules in JS, the only visible attributes of `simpleAjax`
    will be `simpleAjax.getUrl` and `simpleAjax.postUrl`; using an IIFE lets us implement
    the module (and thus thefaçade) in a safe way, making implementation details private.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the *Adapter* pattern is similar, insofar it is also meant to define a
    new interface. However, whileFaçadedefines a new interface to old code, Adapter
    is used when you need to implement an old interface for a new code, so it will
    match what you already had. If you are working with modules, it's clear that the
    same type of solution that worked for Façade will work here, so we don't have
    to study it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator or Wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Decorator* pattern (also known as *Wrapper*) is useful when you want to
    add additional responsibilities or functionalities to an object in a dynamic way.
    Let's consider a simple example, which we will illustrate with some React code.
    (Don't worry if you do not know this framework; the example will be easy to understand).
    Suppose we want to show some element on screen, and for debugging purposes, we
    want to show a thin red border around the object. How can you do it?
  prefs: []
  type: TYPE_NORMAL
- en: If you were programming using OO, you would probably have to create a new subclass,
    with the extended functionality. For this particular example, you may just provide
    some attribute with the name of some CSS class that would provide the required
    style, but let's keep ourfocusto the OO; using CSS won't always solve this software
    design problem, so we want a more general solution. The new subclass would *know*how
    to show itself with a border, and you'd use this subclass whenever you wanted
    an object's border to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: With our experience on higher-order functions, we can solve this in a different
    way using*wrapping*; wrap the original function within another one, which would
    provide the extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have already seen some examples of wrapping in the*Wrapping functions*sectionof
    [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*. For example, in that section, we saw how to wrap functions
    in order to produce new versions that could log their input and output, provide
    timing information, or even memorize calls to avoid future delays. In this occasion,
    for a variety, we are applying the concept to *decorate*a visual component, but
    the principle remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a simple React component, `ListOfNames`, that can display a heading
    and a list of people, and for the latter, it will use a `FullNameDisplay` component.
    The code for those elements would be as seen in the following fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListOfNames` component uses mapping to create a `FullNameDisplay` component
    to show data for each person.The full logic for our application could then be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In real life, you wouldn''t put all the code for every component in the single,
    same source code file -- and you would probably have a few CSS files. However,
    for our example, having everything in one place, and going with inline styles
    is enough, so bear with me and keep in mind the following saying: *Do as I say,
    not as I do.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly test the result in the online React sandbox at[https://codesandbox.io/](https://codesandbox.io/);
    Google for *react online sandbox*if you want some other options. Results aren''t
    much to talk about, but we are interested in a design pattern right now, and not
    in UI design; refer to Figure 11.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a42709b0-331b-4b4c-91d5-6311602b8b7b.png)Figure 11.1: The original
    version of our components shows a (not much to speak about) list of names'
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, inline components are written in JSX (inline HTML style) and are
    actually compiled into objects, which are later transformed into HTML code to
    be displayed. Whenever the `render()` method is called, it returns a structure
    of objects. So, if we write a function that will take a component as a parameter,
    and return new JSX, which will be a wrapped object. In our case, we''d like to
    wrap the original component within a `<div>` with the required border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you wish, you could make this function aware of whether it's executing in
    development mode or in production; in the latter case, it would simply return
    the original component argument without any change, but let's not worry about
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have to change `ListOfNames` to use wrapped components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorated version of the code works as expected: each of the `ListOfNames`
    components is now wrapped in another component that adds the desired border to
    them; refer to Figure 11.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/745c6765-ee43-43b5-bc74-31bd45f70c3a.png)Figure 11.2: The decorated
    ListOfNames component is still nothing much to look at, but now it shows an added
    border'
  prefs: []
  type: TYPE_NORMAL
- en: In earlier chapters, we saw how to decorate a function, wrapping it inside of
    another function, so it would perform extra code and add a few functionalities.
    Now, here, we saw how to apply the same style of solution to provide a *higher-order
    component*(as called in React parlance) wrapped in an extra `<div>` to provide
    some visual distinctive details.
  prefs: []
  type: TYPE_NORMAL
- en: If you have used Redux and the *react-redux* package, you may note that the
    latter's `connect()` method is also a decorator in the same sense; it receives
    a component class, and returns a new, connected to the store, component class
    for usage in your forms; refer to[https://github.com/reactjs/react-redux](https://github.com/reactjs/react-redux)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy, Template, and Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Strategy* pattern applies whenever you want to have the ability to change
    a class, method, or function, possibly in a dynamic way, by changing the way it
    *does its thing*. For example, a GPS application might want to find a route between
    two places, but applying different strategies if the person is on foot, rides
    a bicycle, or goes by car. In that case, the fastest or the shortest routes might
    be desired. The problem is the same, but different algorithms must be applied,
    depending on the given condition.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, does this sound familiar? If so, it is because we have already met
    a similar problem. When we wanted to sort a set of strings in different ways,
    in [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*, we needed a way to specify how the ordering was to
    be applied or, equivalently, how to compare two given strings and determine which
    had to go first. Depending on the language, we had to sort applying different
    comparison methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before trying an FP solution, let''s consider more ways of implementing our
    routing function. You could make do by having a big enough piece of code, which
    would receive an argument declaring which algorithm to use, plus the starting
    and ending points. With these arguments, the function could do a switch or something
    similar to apply the correct path-finding logic. The code would be roughly equivalent
    to the following fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This kind of solution is really not desirable, and your function is really the
    sum of a lot of distinct other functions, which doesn't offer a high level of
    cohesion. If your language doesn't support lambda functions (as was the case with
    Java, for example, until Java 8 came out in 2014), the OO solution for this requires
    defining classes that implement the different strategies you may want, creating
    an appropriate object, and passing it around.
  prefs: []
  type: TYPE_NORMAL
- en: 'With FP in JS, implementing strategies is trivial, instead of using a variable
    such as`byMeans`to switch, you can just pass a function around, which will implement
    the desired path logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You would still have to implement all the desired strategies (no way around
    that) and decide which function to pass to `findRoute()`, but now that function
    is independent of the routing logic, and if you wanted to add new routing algorithms,
    you wouldn't touch `findRoute()`.
  prefs: []
  type: TYPE_NORMAL
- en: If you consider the *Template* pattern, the difference is that Strategy allows
    you to use completely different ways of achieving an outcome, while Template provides
    an overarching algorithm (or *template*) in which some implementation details
    are left to methods to be specified. In the same way, you can provide functions
    to implement the Strategy pattern; you can also provide them for a Template pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the pattern*Command*also benefits from the ability of being able to
    pass functions as arguments.This pattern is meant to be enabled to encapsulate
    a request as an object, so for different requests, you have differently parameterized
    objects. Given that we can simply pass functions as arguments to other functions,
    there's no need for the *enclosing*object.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw a similar use of this pattern back in the *A React+Redux reducer*section
    of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*. There, we defined a table, each of whose entries
    was a callback that was called whenever needed. We could directly say that the
    Command pattern is just an object-oriented replacement for plain functions working
    as callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Other patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s end this section by glossing over some other patterns, where the equivalence
    may or may not be so good:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Currying and Partial Application** (which we saw in [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying and Partial Application*): This can be seen
    as approximately equivalent to a *Factory* for functions. Given a general function,
    you can produce specialized cases by fixing one or more arguments, and this is,
    in essence, what a Factory does, of course, speaking about functions, and not
    objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative functions**(such as `map()` or `reduce()`): They can be considered
    an application of the *Iterator* pattern. The traversal of the container''s elements
    is decoupled from the container itself. You might also provide different `map()`
    methods for different objects, so you could traverse all kinds of data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent data structures**: As mentioned in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml),
    *Ensuring Purity - Immutability*, they allow for an implementation of the *Memento*
    pattern. The central idea is, given an object, to be able to go back to a previous
    state. As we saw, each updated version of a data structure doesn''t impact on
    the previous one(s), so you could easily add a mechanism to provide any earlier
    state and *roll back*to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **Chain of Responsibility** pattern: In this pattern, there is a potentially
    variable number of *request processors*, and a stream of requests to be handled,
    may be implemented using `find()` to determine which is the processor that will
    handle the request (the desired one is the first in the list that accepts the
    request) and then simply doing the required process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember the warning at the beginning: with these patterns, the match with
    FP techniques may not be so perfect as with others that we have previously seen,
    but the idea was to show that there are some common FP patterns that can be applied,
    and it will produce the same results as the OOP solutions, despite having different
    implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having seen several OOP design patterns, it may seem a cheat to say that
    there's no approved, official, or even remotely generally accepted similar list
    of patterns for FP. There are, however,several problems for which there are standard
    FP solutions, which can be considered design patterns on their own, and we have
    already covered most of them in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are candidates for a possible list of patterns? Let''s attempt preparing
    one -- but remember, it''s just a personal view; also, I''ll admit that I''m not
    trying to mimic the usual style ofpattern definition--I''ll just be mentioning
    a general problem and refer to the way FP in JS can solve it, and I won''t be
    aiming for nice, short, memorable names for the patterns either:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing collections using filter/map/reduce:**Whenever you have to process
    a data collection, using declarative, higher-order functions, as `filter()`, `map()`,
    and `reduce()`, as we saw in [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),*Programming
    Declaratively - A Better Style*, is a way to remove complexity from the problem
    (the usual *MapReduce* web framework is an extension of this concept, which allows
    for distributed processing among several servers, even if the implementation and
    details aren''t exactly the same). Instead of performing looping and processing
    as a single step, you should think about the problem as a sequence of steps, sequentially
    applied, applying transformations until obtaining the final, desired result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JS also includes *iterators*, that is, another way of looping through a collection.
    Using *iterators* isn't particularly functional, but you may want to look at them
    since they may be able to simplify some situations. Read more at[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy evaluation with thunks**: The idea of *lazy evaluation*is not doing
    any calculations until they are actually needed. In some programming languages,
    this is built-in. However, in JS (and in most imperative languages as well) *eager
    evaluation* is applied, in which an expression is evaluated as soon as it is bound
    to some variable (another way of saying this is that JavaScript is a *strict programming
    language*, with a *strict paradigm*, which only allows calling a function if all
    of its parameters have been completely evaluated). This sort of evaluation is
    required when you need to specify the order of evaluation with precision, mainly
    because such evaluations may have side effects. In FP, which is rather more declarative
    and pure, you can delay such evaluation with *thunks* (which we used in the*Trampolines
    and Thunks*section of [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml),
    *Designing Functions - Recursion*) by passing a thunk that can do instead of doing
    a calculationso that whenever the actual value is needed, it will be calculated
    at that time, but not earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also want to look at JS *generators*, which is another way of delaying
    evaluation, though it's not particularly related to FP at all. Read more about
    *generators* at[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
    The combination of *generators* and promises is called an async function, and
    those may be of interest to you; refer to[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
  prefs: []
  type: TYPE_NORMAL
- en: '**Persistent data structures for immutability**. Having immutable data structures,
    as we saw in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring
    Purity - Immutability*, is mandatory when working with certain frameworks, and
    in general it is recommended because it helps to reason about a program or debugging
    it. (Earlier in this chapter, we also mentioned how the *Memento* OOP pattern
    can be implemented in this fashion). Whenever you have to represent structured
    data, the FP solution of using a persistent data structure helps in many ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrapped values for checks and operations**: If you directly work with variables
    or data structures, you may modify them at will (possibly violating any restrictions)
    or you may need to do many checks before using them (such as verifying that a
    value is not null before trying to access the corresponding object). The idea
    of this pattern is to wrap a value within an object or function, so direct manipulation
    won''t be possible, and checks can be managed in a more functional way. We''ll
    be referring to more of this in [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have said, the power of FP is such that instead of having a couple of
    dozens standard design patterns (and that's only in the GoF book; if you read
    other texts, the list grows!) there isn't yet a standard or acknowledged list
    of functional patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11.1\. **Decorating methods, the future way**. In [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, we wrote a decorator to enable
    logging for any function. Currently, method decorators are being considered for
    upcoming versions of JavaScript: refer to[https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/)
    for that (Draft 2 means that inclusion of this feature in the standard is likely,
    although there may be some additions or small changes). Study the draft and take
    a look at what makes the next code tick.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some questions: Do you see the need for the `savedMethod` variable? Why do
    we use `function()` when assigningnew `descriptor.value`, instead of an arrow
    function? Can you understand why `.bind()` is used? What is `descriptor`?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A working example would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '11.2.**Decorator with mixins**: Back in the *Questions* section of [Chapter
    1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional - Several
    Questions*, we saw that classes are first-class objects. Taking advantage of this,
    complete thefollowing`addBar()`function, which will add some mixins to the `Foo`
    class so that code will run as shown. The created `fooBar` object should have
    two attributes (`.fooValue` and `.barValue`) and twomethods (`.doSomething()`
    and `.doSomethingElse()`) that simply show some text and a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Could you include a third mixin, `addBazAndQux()`, so that`addBazAndQux(addBar(Foo))`
    would add even more attributes and methods to`Foo`?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have done a bridge from the object-oriented way of thinking,
    and the usual patterns that we use when coding that way, to the functional programming
    style, by showing how we can solve the same basic problems, but rather more easily
    than with classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building Better
    Containers - Functional Data Types*, we will be working with a *potpourri*of functional
    programming concepts, which will give you, even more, ideas about tools you can
    use. I promised that this book wouldn't become deeply theoretical, but rather
    more practical, and we'll try to keep it this way, even if some of the presented
    concepts may look abstruse or remote.
  prefs: []
  type: TYPE_NORMAL
