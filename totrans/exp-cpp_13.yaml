- en: Designing a Strategy Game Using Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game development is one of the most interesting topics in software engineering.
    C++ is extensively used in game development because of its efficiency. However,
    since the language doesn't have GUI components, it's used on the backend. In this
    chapter, we will learn how to design a strategy game on the backend. We will incorporate
    almost everything that we've learned in previous chapters, including design patterns
    and multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: The game that we will design is a strategy game called **Readers and Disturbers**.
    Here, the player creates units, known as readers, who are able to build libraries
    and other buildings, and soldiers, who are defending those buildings from the
    enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to game design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into the process of game design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the game loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The g++ compiler with the `-std=c++2a` option will be used to compile the examples
    throughout this chapter. You can find the source files that will be used throughout
    this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to game design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will design the backend of a strategy game where the player
    can create units (workers, soldiers), build buildings, and fight the enemy. Whenever
    you design a game, whether it's a strategy game or a first-person shooter, there
    are several fundamental components that are the same, such as game physics, which
    are used to make the game feel more real and immersive to the player.
  prefs: []
  type: TYPE_NORMAL
- en: There are components in game design that are repeated in almost all games, such
    as collision detection mechanisms, the audio system, graphics rendering, and so
    on. When designing a game, we can either distinguish between the engine and the
    game or develop a strongly tied application representing both the engine and the
    game as a single outcome. Designing the game engine separately allows it to be
    extended for further releases and even used for other games. After all, games
    have the same mechanics and the same flow. They differ mostly by in their plotline.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a game engine, you should carefully plan the types of game that
    will be designed using the engine. Though most fundamental features are the same.
    independent of the game type, there are distinctions for a 3D shooter and, for
    example, a strategy game. In a strategy game, the player strategically deploys
    units across a large playing field. The game world is displayed from a top-down
    viewing angle.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Readers and Disturbers game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic idea of the game is simple: the player has a limited set of resources.
    Those resources can be used to create buildings for game characters. We name the
    character units, which are divided into readers and soldiers. The Readers are
    smart characters who build libraries and other buildings. Each built library can
    host up to 10 readers. If the player moves 10 readers into the library, after
    a specified amount of time, the library produces one professor. A professor is
    a powerful unit that can destroy three enemy soldiers at once. A professor can
    create better weapons for the player''s soldiers.'
  prefs: []
  type: TYPE_NORMAL
- en: The game starts with a single house already built, two soldiers, and three readers.
    A house produces a new reader every 5 minutes. Readers can build new houses, which
    then produce more readers. They can also build barracks that produce soldiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of the player is to build five libraries, each of which has produced
    at least one professor. The player has to defend his/her buildings and readers
    from the enemy during the game. Enemies are called **disturbers** because their
    goal is to disturb readers from their main goal: studying inside the libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: Strategy game components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, our strategy game will comprise basic components –
    readers and soldiers (we'll refer to them as units), buildings, and a map. The
    game map contains coordinates for each object in the game. We will discuss a lighter
    version of a game map. Now, let's leverage our project-designing skills to decompose
    the game itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game consists of the following character units:'
  prefs: []
  type: TYPE_NORMAL
- en: A reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A soldier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A professor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also consists of the following buildings:'
  prefs: []
  type: TYPE_NORMAL
- en: A library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A house
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A barrack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s discuss the properties for each component of the game. A game character
    has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Life points (an integer, which decreases after each attack from the enemy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power (an integer, which defines the amount of damage a unit can cause to enemy
    units)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type (a reader, a soldier, or a professor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The life property should have an initial value based on the type of the unit.
    For example, a reader's initial life points are 10, whereas a soldier's life points
    are 12\. When interacting in the game, all of the units might be attacked by enemy
    units. Each attack is described as a decrease in life points. The amount we will
    decrease the life points by is based on the value of the power of the attacker.
    For example, the power of a soldier is set to three, which means each attack that's
    made by a soldier will decrease the victim's life points by three. When the victim's
    life points become zero, the character unit will be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for buildings. A building has a construction duration that it
    will be completely built by. A complete building also has life points, and any
    damage caused to the building by enemy forces will decrease these life points.
    The following is the full list of building properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Life points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construction duration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit production duration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit production duration is the amount of time it takes for a new character
    unit to be produced. For example, a barrack produces a soldier every 3 minutes,
    a house produces a reader every 5 minutes, and a library produces a professor
    from 10 readers instantly when the last missing reader goes inside the library.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've defined the game components, let's discuss the interaction between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction between the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next important thing in the design of the Readers and Disturbers game is
    the interaction between the characters. We already mentioned that readers can
    build buildings. In the game, this process should be taken care of because each
    type of building has its duration of construction. Therefore, if a reader is busy
    with the building process, we should measure the time to make sure the building
    will be ready after a specified time. However, to make the game even better, we
    should take into account that more than one reader can take part in the process
    of construction. This should make constructing a building faster. For example,
    if a barrack is built in 5 minutes by one reader, then it should be built in 2
    and a half minutes by two readers, and so on. This is one example of complex interactions
    in the game and can be depicted with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e52d3229-e4d3-4f13-b697-607876bc466e.png)'
  prefs: []
  type: TYPE_IMG
- en: Complex interaction
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the attack handling. When one unit is attacked by enemies, we should
    decrease the defendant''s life points. The defendant itself could attack the attacker
    (to defend itself). Whenever there is more than one attacker or defender, we should
    correspondingly handle how the life points of each attacked unit decrease. We
    should also define the duration of each hit by the unit. A unit shouldn''t hit
    another very fast. To make things a bit more natural, we might introduce a 1 second
    or 2 second pause between each hit. The following diagram depicts a simple attack
    interaction. This will be replaced with a class interaction diagram later in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/888a94bb-3bb8-4339-abab-f453c0a64778.png)'
  prefs: []
  type: TYPE_IMG
- en: Simple attack interaction
  prefs: []
  type: TYPE_NORMAL
- en: An even bigger interaction is happening in the game in general. There are two
    groups in the game, one of which is controlled by the player. The other one is
    automatically controlled by the game itself. That means that we, as the game designers,
    are obliged to define the life cycle of the enemy forces. The game will automatically
    create readers who will be assigned the tasks of creating libraries, barracks,
    and houses. Each soldier should take responsibility for defending the buildings
    and readers (the people). And from time to time, soldiers should group together
    and go on an attack mission.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be designing a platform that lets the player create an empire; however,
    the game should also create the enemy to make the game complete. The player will
    face regular attacks from the enemy, and the enemy will evolve by constructing
    more buildings and producing more units. Overall, we can depict the interaction
    using the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4dd9522-8e38-463f-855d-946467b87157.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration between the player and the automated player
  prefs: []
  type: TYPE_NORMAL
- en: We will refer to the preceding diagram regularly while designing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though a game is not a typical piece of software, its design doesn't differ
    much from regular application design. We will start with the main entities and
    decompose them further into classes and their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we discussed all the necessary game components and
    their interaction. We did a requirement analysis and gathering in terms of the
    project development life cycle. Now, we'll start designing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Designing character units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following class diagram represents a reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b494e5af-c72e-493b-bd01-f51ffc39c83b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we go through the other character units, we will come up with a base class
    for each character unit. Each specific unit will inherit from that base class
    and will add its specific properties, if any. Here''s the complete class diagram
    for character units:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98c96e09-c293-4218-a3dc-f4f5e713e7a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pay attention to the base class – it''s an interface rather than a regular
    class. It defines pure virtual functions to be implemented in derived classes.
    Here''s what the `CharacterUnit` interface looks like in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `attack()` method decreases the life points of the character, while `destroy()`
    destroys the character. Destroying means not only removing the character from
    the scene but also stopping all the interactions that the unit has in progress
    (such as constructing buildings, defending itself, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The derived classes provide an implementation for the pure virtual functions
    of the `CharacterUnit` interface class. Let''s take a look at the code for the
    `Reader` character unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create `Reader` units by declaring them in any of the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will mostly refer to character units by their base interface class.
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the copy constructor and the assignment operators. We intentionally
    marked them as deleted because we don't want to create units by copying others.
    We will use the `Prototype` pattern for that behavior. This will be discussed
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the `CharacterUnit` interface is crucial in scenarios where we should
    do the same thing for different types of unit. For example, suppose that we have
    to calculate the complete damage that two soldiers, one reader, and a professor
    can cause to a building. Instead of keeping three different references to refer
    to three different types of unit, we are free to refer to them all as `CharacterUnits`.
    Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `calculate_damage()` function abstracts from unit types; it doesn't care
    about readers or soldiers. It just calls the `get_power()` method of the `CharacterUnit`
    interface, which is guaranteed to have an implementation for the specific object.
  prefs: []
  type: TYPE_NORMAL
- en: We will update character unit classes as we go. Now, let's move on to designing
    classes for buildings.
  prefs: []
  type: TYPE_NORMAL
- en: Designing buildings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes for buildings are similar to character units in terms of their common
    interface. For example, we can start by defining the class for a house as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `std::chrono::duration` to keep a time interval for the `House`
    construction duration. It is defined in the `<chrono>` header as a number of ticks
    and a tick period, where the tick period is the number of seconds from one tick
    to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `House` class needs more details, but we will soon come to the realization
    that we need a base interface (or even an abstract class) for all the buildings.
    The buildings that will be described in this chapter share certain behaviors.
    The interface for `Building` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note the `I` prefix in front of `Building`. Many developers suggest using a
    prefix or postfix for interface classes for better readability. For example, `Building`
    might have been named `IBuilding` or `BuildingInterface`. We will use the same
    naming technique for the previously described `CharacterUnit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `House`, `Barrack`, and `Library` classes implement the `IBuilding` interface
    and must provide implementations for pure virtual methods. For example, the `Barrack` class
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss the construction duration implementation in more detail, At this
    point, `std::chrono::` duration point, kept as a reminder to us that the construction
    should take a specified amount of time. Also, note that the final design of classes
    might change over the course of this chapter. Now, let's find out how will we
    make the components of the game interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Designing game controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing classes for character units and buildings is just the first step in
    designing the game itself. One of the most important things in the game is designing
    the interaction between those components. We should carefully analyze and design
    cases such as two or more characters constructing a building. We already introduced
    a construction time for a building, but we didn't take into account that a building
    might be constructed by more than one reader (the character unit that can build
    buildings).
  prefs: []
  type: TYPE_NORMAL
- en: We could say that a building built by two readers should be built twice as fast
    than when it's built by one reader. And if another reader joins the construction,
    we should recalculate the duration. However, we should limit the number of readers
    that can work on constructing the same building.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the readers get attacked by the enemy, that should disturb the reader
    from building so that they can concentrate on self-defense. When a reader stops
    working on the building, we should recalculate the construction time again. The
    attack is another case that's similar to the building. When a character gets attacked,
    it should defend itself by fighting back. Each hit will decrease the character's
    life points. A character might be attacked by more than one enemy character at
    the same time. That will decrease their life points even faster.
  prefs: []
  type: TYPE_NORMAL
- en: A building has a timer because it produces a character periodically. The most
    important thing to design is the game dynamics – that is, the loop. At each specified
    time frame, something happens in the game. This can be enemy soldiers approaching,
    the character units building something, or anything else. The execution of an
    action is not strictly tied to the finishing of another unrelated action. This
    means that the construction of a building happens concurrently with the creation
    of a character. Unlike most applications, the game should keep moving, even if
    the user didn't provide any input. The game doesn't freeze if the player fails
    to perform an action. The character units might wait for a command, but the buildings
    will be continuously doing their job – producing new characters. Also, the enemy
    player (the automated one) strives for victory and never pauses.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many actions in the game happen concurrently. As we've just discussed, the construction
    of buildings should not stop because a unit that is not involved in the construction
    gets attacked by the enemy. If the enemy attacks, a building should not stop producing
    new characters. This means we should design concurrent behavior for many of the
    objects in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the best ways to achieve concurrency in C++ is using threads. We can
    redesign the units and buildings so that they include an overridable action in
    their base class that will be executed in a separate thread. Let''s redesign `IBuilding`
    so that it''s an abstract class that has an additional `run()` virtual function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the `background_action_()` function; it's private, but virtual.
    We can override it in derived classes. The `run()` function is not virtual; it
    runs the private implementation in a thread. Here, the derived classes might provide
    an implementation for the `background_action_()`. When a unit is assigned to construct
    the building, the `build()` virtual function is called. The `build()` function
    delegates the job of calculating the construction time to the `run()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The game event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest approach to this problem is defining an event loop. An event loop
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Even if there is no action from the user (the player), the game still goes on
    by calling the `updateGame()` function. Note that the preceding code is just a
    general introduction to the event loop. As you can see, it loops indefinitely
    and processes and updates the game on each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Each loop iteration advances the state of the game. If user action processing
    takes a long time, it might block the loop. The game will freeze for a moment.
    We usually measure the speed of the game in **frames per second** (**FPS**). The
    higher its value, the smoother the game.
  prefs: []
  type: TYPE_NORMAL
- en: We need to design the game loop that runs continuously during gameplay. It's
    important to design it in such a way that the user action processing won't block
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The game loop takes care of everything happening in the game, including AI.
    By AI, we mean the automation of the enemy player we discussed previously. Other
    than that, the game loop handles the actions of characters, and building, and
    updates the state of the game accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the game loop design, let's understand several design patterns
    that will help us in this complex task. After all, the game loop is another design
    pattern!
  prefs: []
  type: TYPE_NORMAL
- en: Using design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's natural to design a game using the **object-oriented** **programming**
    (**OOP**) paradigm. After all, a game represents a combination of objects that
    intensively interact with each other. In our strategy game, we have buildings
    built by units. Units defend themselves from enemy units and so on. This inter-communication
    leads to the growth of complexity. As the project evolves and gains more features,
    it will become harder to support it. It's already obvious to us that designing
    is one of the most important (if not the most important) part of building projects.
    Incorporating design patterns will drastically improve both the design process
    and project support.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine some design patterns that are useful in game development. We will
    start with classic patterns and then discuss more game-specific patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The Command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developers categorize design patterns into creational, structural, and behavioral
    categories. The Command pattern is a behavioral design pattern. Behavioral design
    patterns are mainly concerned with providing flexibility in communication between
    objects. In this context, the Command pattern encapsulates an action in an object
    that contains the necessary information, along with the action itself. This way,
    the Command pattern behaves as a smart function. The simplest way to implement
    it in C++ is by overloading the `operator()` for a class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A class with an overloaded `operator()` is sometimes referred to as a **functor**.
    The preceding code is almost the same as the following regular function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the regular function and the object of the `Command` class looks similar,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between these two is obvious whenever we need to use a state
    for the function. To store the state for a regular function, we use a static variable.
    To store the state in the object, we use the object itself. Here''s how we can
    track the number of calls of the overloaded operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of calls is unique for each instance of the `Command` class. The
    following code declares two instances of `Command` and calls them two and three
    times, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try to apply this pattern to our strategy game. The final version
    of the game has a graphical interface that allows its users to control the game
    using various buttons and mouse clicks. For example, to make a character unit
    build a house, and not a barrack, we should choose the corresponding icon on the
    game panel. Let's visualize a game panel with a map of the game and a bunch of
    buttons to control the game dynamics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game provides the following commands to the player:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the character unit from point A to point B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attack the enemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct a building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Settle the house
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The design of the game commands looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03f3119a-3a41-4fd1-b3ac-f5245be1e74b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each class encapsulates the action logic. The client code is not concerned with
    processing the action. It operates with command pointers, each of which will point
    to the concrete **Command** (as shown in the preceding image). Note that we''ve
    only depicted commands that the player will execute. The game itself communicates
    between modules using commands. Examples of automatic commands include **Run**,
    **Defend**, **Die**, and **Create**. The following is a broader diagram showing
    the commands in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87e3d426-3977-49b5-ac4e-266dfcb3a93b.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding commands execute any of the aforementioned events that arise during
    the gameplay. To listen to those events, we should consider using the Observer
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Observer pattern is an architectural mechanism that allows us to subscribe
    to object state changes. We say that we observe the changes of the object. The
    Observer pattern is also a behavioral design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Most strategy games incorporate the concept of a resource. This might be a rock,
    gold, wood, and so on. For example, upon constructing a building, the player has
    to spend 20 units of wood, 40 units of rock, and 10 units of gold. Eventually,
    the player will run out of resources and has to collect them. This player creates
    more character units and tasks them with collecting resources – almost like what
    happens in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's suppose we have a similar resource gathering or spending activity
    in our game. When the player tasks units to collect a resource, they should somehow
    notify us each time a fixed amount of resource is collected. The player is the
    subscriber to the **resource collected** event.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for buildings. A building produces a character – subscribers
    get a notification. A character unit finishes the building construction – subscribers
    get a notification. In most cases, the subscriber is the player. We update the
    player dashboard to keep the game state up to date for the player; that is, the
    player oversees how many resources, how many units, and how many buildings they
    have while playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Observer involves implementing a class that stores its subscribers and
    calls the specified function on an event. It consists of two entities: a subscriber
    and a publisher. As shown in the following diagram, the number of subscribers
    is not limited to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5441e6d9-b94b-435b-ac15-bf16bd0be9a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, when a character unit is assigned to build a building, it will
    continuously strive to build it unless it gets stopped. There are various reasons
    why this may happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The player decides to cancel the process of constructing the building.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The character unit has to defend itself from an enemy attack and pauses the
    construction process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The building has been finished, so the character unit stops working on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The player would also like to be notified when the building is completed because
    they might have plans for the character unit to perform other tasks when they''re
    done with the building process. We can design the building process so that it
    notifies its listeners (subscribers) when the event is completed. The following
    class diagram also involves an Action interface. Consider it as an implementation
    of the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ae90c0d-17e8-4028-8bfa-e944ffac3e4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Developing classes with regards to the Observer leads us to a point where almost
    all the entities in the game are subscribers, publishers, or both. If you encounter
    a similar scenario, you might consider using the Mediator – another behavioral
    pattern. Objects communicate with each other via a mediator object. An object
    that triggers an event lets the Mediator know about it. The Mediator then passes
    the message to any related object that''s "subscribed" to the object state. The
    following diagram is a simplified version of the Mediator''s integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db974456-125d-46b8-bb44-65bf4da3fb29.png)'
  prefs: []
  type: TYPE_IMG
- en: Each object contains a Mediator that's used to notify subscribers about changes.
    The Mediator object usually contains all the objects that communicate with each
    other. On an event, each object notifies the interested parties via the mediator.
    For example, when the building construction is done, it triggers the Mediator,
    which, in turn, notifies all the subscribed parties. To receive those notifications,
    each object should be subscribed to the Mediator beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The Flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flyweight is a structural design pattern. Structural patterns take care of assembling
    objects and classes into larger, more flexible, structures. Flyweight allows us
    to cache objects by sharing their common parts.
  prefs: []
  type: TYPE_NORMAL
- en: In our strategy game, we're dealing with many objects being rendered on the
    screen. The number of objects increases during gameplay. The longer the player
    plays the game, the more character units and buildings they create (the same is
    true for the automated enemy). Each unit in the game represents a separate object
    containing data. A character unit takes at least 16 bytes of memory (for its two
    integer data members and the virtual table pointer).
  prefs: []
  type: TYPE_NORMAL
- en: Things get worse when we add additional fields to units in order to render them
    on the screen; for example, their height, width, and sprite (the image representing
    the unit for rendering). Besides the character units, the game should have supplementary
    items to make the user experience even better, for example, decorative items such
    as trees, rocks, and so on. At some point, we'll conclude that we have plenty
    of objects to render on the screen, each of which represents almost the same object,
    but with a small difference in their states. The Flyweight pattern comes to the
    rescue here. For the character unit, its height, width, and sprite store almost
    identical data across all units.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Flyweight pattern suggests decomposing a heavy object into two:'
  prefs: []
  type: TYPE_NORMAL
- en: An immutable object that contains the same data for each object of the same
    kind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mutable object that uniquely identifies itself from others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, a moving character unit has its own height, length, and sprite,
    all of which are repeated for all the character units. Therefore, we can represent
    those properties as a single immutable object with the same values for the properties
    for all the objects. However, a character unit might have a different location
    on the screen than others, and when the player commands the unit to move somewhere
    else or start constructing a building, the position of the unit changes continuously
    until it reaches an endpoint. At each step, the unit should be redrawn on the
    screen. By doing this, we arrive at the following design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/969db8dd-89fb-4fc8-91eb-c7c9a186c889.png)'
  prefs: []
  type: TYPE_IMG
- en: The left-hand side is the `CharacterUnit` before modifications, while the right-hand
    side represents recent modifications using the Flyweight pattern. The game can
    now deal with a bunch of `CharacterUnit` objects, while each of them will store
    a reference to a few `UnitData` objects. This way, we save a lot of memory. We
    store the values that are unique to each unit in a `CharacterUnit` object. These
    values change over time. The dimensions and sprite are constant, so we can keep
    a single object with these values. This immutable data is called the **intrinsic
    state**, while the mutable part of the object (the `CharacterUnit`) is called
    the **extrinsic** **state**.
  prefs: []
  type: TYPE_NORMAL
- en: We intentionally moved the data members to `CharacterUnit`, thus redesigning
    it from an interface into an abstract class. As we discussed in [Chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details
    of Object-Oriented Programming*, an abstract class is almost the same as the interface
    that might contain an implementation. The `move()` method is an example of a default
    implementation for all types of units. This way, the derived classes only provide
    the necessary behavior because all the units share common properties, such as
    life points and power.
  prefs: []
  type: TYPE_NORMAL
- en: After optimizing memory usage, we should deal with copying objects. The game
    involves extensively creating new objects. Each building produces a specific character
    unit; character units construct buildings, and the game world itself renders decorative
    elements (trees, rocks, and so on). Now, let's try to improve `CharacterUnit`
    by incorporating a cloning functionality. Earlier in this chapter, we intentionally
    deleted the copy constructor and assignment operator. Now, it's time to provide
    a mechanism that will create new objects from existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: The Prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This pattern lets us create duplicates of objects independently of their type. The
    following code represents the final version of the `CharacterUnit` class with
    regard to our recent modifications. We''ll also add the new `clone()` member function
    in order to incorporate the Prototype pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We deleted the assignment operator and moved the copy constructor to the private
    section. The derived classes override the `clone()` member function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The Prototype pattern delegates cloning to the objects. The common interface
    allows us to decouple the client code from the class of the object. Now, we can
    clone a character unit without knowing it''s a `Reader` or a `Soldier`. Look at
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A dynamic cast works fine whenever we need to convert the object into a specific
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've discussed many useful design patterns. This might seem
    a little overwhelming if you are new to these patterns; however, using them properly allows
    us to design flexible and maintainable projects. Let's finally get back to the
    game loop that we introduced earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strategy games have one of the most intensively changing gameplays. At each
    point in time, many actions happen simultaneously. Readers finish their building;
    a barrack produces a soldier; a soldier gets attacked by the enemy; the player
    commands units to move, build, attack, or run; and so on. The game loop handles
    everything. Usually, a game engine provides a well-designed game loop.
  prefs: []
  type: TYPE_NORMAL
- en: The game loop runs while we play the game. As we already mentioned, the loop
    handles player actions, updates the game state, and also renders the game (makes
    state changes visible to the player). It does so on each iteration. The loop should
    also control the rate of gameplay, that is, its FPS. A common term for one iteration
    of the game loop is a frame, which is why we emphasize the FPS as the speed of
    the gameplay. For example, if you design a game running at 60 FPS, this means
    each frame takes around 16ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code was used earlier in this chapter for a simple game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will run quickly if there are no long user actions to process.
    It will run even faster on fast machines. Your goal is to stick to the 16ms for
    a frame. This might require us to wait a bit after processing actions and updating
    the game state, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73b78d78-f5e3-4e4d-8398-eefd4d363046.png)'
  prefs: []
  type: TYPE_IMG
- en: Each update advances the game time by a fixed amount, which takes a fixed amount
    of real-world time to process. On the other hand, the game will slow down if the
    processing takes longer than the specified milliseconds for a frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything that happens in the game is mostly covered in the update part of
    the game, as shown in the preceding diagram. Most of the time, updating might
    require performing several operations at a time. Also, as we mentioned earlier,
    we have to keep timers for some of the operations that occur in the game in the
    background. It mostly depends on how detailed we want to make the game. For example,
    constructing a building might be represented as two states: initial and final.'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of graphic design, those two states should represent two different
    images. The first image contains some fundamental part for the building and might
    include a couple of rocks around it as if it's just getting ready to be constructed.
    The next image represents the final constructed building. When a character unit
    just starts constructing the building, we show the player the first image (the
    fundament with a couple of rocks around it). When the construction is finished,
    we replace the first image with the image containing the final building. To make
    the process more natural (more real-world), we artificially make it take longer.
    This means we keep a timer lasting 30 seconds or more between two states of the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: We described the simplest case with the least amount of detail. If we need to
    make the game more detailed, for example, by rendering every change of in the
    building during the construction, we should keep a lot of timers between a lot
    of images representing each step of the construction. Take a look at the preceding
    diagram once again. After updating the game, we wait for *N* milliseconds. Waiting
    for more milliseconds tends to make the flow of the game closer to real life.
    What if the update takes so long that the player experience lags behind? In that
    case, we need to optimize the game so that it fits the time frame that's the most
    optimal in terms of user experience. Now, let's say updating the game takes more
    than hundreds of operations to perform; the player has achieved a prosperous empire;
    is now constructing lots of buildings, and attacks the enemy with many soldiers.
  prefs: []
  type: TYPE_NORMAL
- en: Each action of one character unit, such as moving from one point to another
    one, attacking an enemy unit, constructing a building, and so on, is rendered
    on the screen on time. Now, what if we render states of hundreds of units on the
    screen at once? That's where we use a multithreaded approach. Each action involves
    independently modifying the state of an object (an object being any of the units
    in the game, including static buildings).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing a game is a complex task. We can consider game development as a separate
    programming area. Games have different genres, and one of them is strategy games.
    Strategy game design involves designing game components such as units and buildings.
    Usually, a strategy game involves collecting resources, building an empire, and
    fighting the enemy. The gameplay involves dynamic communication between game components,
    such as character units constructing buildings and collecting resources, soldiers
    defending the land from enemies, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To properly design a strategy game, we incorporate OOP design skills, along
    with design patterns. Design patterns play a huge role in designing the whole
    game and how its components interact. In this chapter, we discussed the Command
    pattern, which encapsulates actions under objects; the Observer pattern, which
    is used to subscribe to object events; and the Mediator pattern, which is used
    to advance the Observer to a level of complex interactions between components.
  prefs: []
  type: TYPE_NORMAL
- en: The most important part of the game is its loop. The game loop controls rendering,
    timely updates of the game state, and other subsystems. Designing it involves
    using event queues and timers. Modern games use networking to allow multiple players
    to play together via the internet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce network programming in C++ so that you
    will have the skills you need to incorporate networking into your games.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the purpose of overriding a private virtual function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the Command design pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the Flyweight pattern save memory usage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between the Observer and Mediator patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we design the game loop as an infinite loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Game Development Patterns and Best Practices: Better games, less hassle* by
    John P. Doran, Matt Casanova: [https://www.amazon.com/Game-Development-Patterns-Best-Practices/dp/1787127834/](https://www.amazon.com/Game-Development-Patterns-Best-Practices/dp/1787127834/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
