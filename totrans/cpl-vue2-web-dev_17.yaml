- en: Advanced Vue.js - Directives, Plugins, and Render Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Vue.js - 指令、插件和渲染函数
- en: 'In this chapter, we will talk about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating a new directive
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新指令
- en: Using WebSockets in Vue
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue中使用WebSockets
- en: Writing a plugin for Vue
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Vue编写一个插件
- en: Rendering a simple component manually
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动渲染一个简单的组件
- en: Rendering a component with children
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染带有子元素的组件
- en: Using JSX to render a component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSX来渲染一个组件
- en: Creating a functional component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个功能性组件
- en: Building a responsive table with higher-order components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶组件构建响应式表格
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Directives and plugins are ways to package functionality in a reusable way and
    also make it easily shareable across apps and teams; you will build a few of them
    in this chapter. Render functions are how Vue really works under the hood to turn
    templates into the Vue language and then into HTML and JavaScript again; they become
    useful if you need to optimize the performance of your apps and work in some corner
    cases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 指令和插件是以可重用的方式打包功能，并且使其在应用程序和团队之间易于共享的方式；在本章中，您将构建其中的一些。渲染函数是Vue在幕后真正工作的方式，它将模板转换为Vue语言，然后再次转换为HTML和JavaScript；如果您需要优化应用程序的性能并处理一些边缘情况，它们将变得有用。
- en: In general, you should avoid using these advanced functions when possible as
    they have been a little overused in the past. Usually, many problems can be solved
    by simply writing a good component and distributing the component itself; you
    should look at advanced features only when this is not true.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，尽量避免使用这些高级功能，因为它们在过去有点被滥用。通常，许多问题可以通过简单地编写一个良好的组件并分发组件本身来解决；只有在这种情况不成立时，才应该考虑使用高级功能。
- en: This chapter is for the slightly more experienced, and you probably won't find
    the level of step-by-step detail found in other recipes, but I have strived to
    make them complete nonetheless.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章面向略有经验的人，您可能不会在其他教程中找到的逐步详细级别，但我仍然努力使它们完整。
- en: Creating a new directive
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新指令
- en: Directives are like mini functions that you can use to quickly drop into your
    code, mainly to improve the user experience, and to add new low-level features
    to your graphic interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 指令就像迷你函数，您可以快速地将其放入您的代码中，主要是为了改善用户体验，并向图形界面添加新的低级功能。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe, although found in the advanced chapter, is really easy to complete.
    The main reason directives are *advanced* is because you should usually prefer
    composition to add functionality and style to your apps. When components won't
    cut it, use directives.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个教程在高级章节中，但实际上非常容易完成。指令被认为是*高级*的主要原因是，通常情况下，您应该更喜欢组合来添加功能和样式到您的应用程序中。当组件无法满足需求时，使用指令。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will build a `v-pony` directive that will turn any element into a pony element.
    A pony element is created with a pink background and changes color when you click
    on it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个`v-pony`指令，它将把任何元素转换为一个小马元素。小马元素创建时具有粉色背景，并在点击时更改颜色。
- en: 'The HTML code for the pony element is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 小马元素的HTML代码如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Just to show the difference, I''ve included a normal `blockquote` element.
    In our JavaScript section, write the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示区别，我包含了一个普通的`blockquote`元素。在我们的JavaScript部分，写入以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how you declare a new directive. The `bind` hook is called when the
    directive is bound to the element. The only thing we are doing now is setting
    the background color. We also want to make it change color after each click. To
    do this, you have to add this code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何声明一个新指令的方式。`bind`钩子在指令绑定到元素时被调用。我们现在唯一要做的事情就是设置背景颜色。我们还希望它在每次点击后改变颜色。要做到这一点，您必须添加以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are creating an `onclick` listener that will generate a random color
    with a bias toward red and assign it as a new background color.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`onclick`监听器，它将生成一个偏向红色的随机颜色，并将其分配为新的背景颜色。
- en: 'At the end of our JavaScript, remember to create a `Vue` instance:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript结尾处，记得创建一个`Vue`实例：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can launch your application to see your directive in action:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动应用程序以查看指令的运行情况：
- en: '![](assets/886f331f-42ba-42b3-a41c-9991e9cf5a01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/886f331f-42ba-42b3-a41c-9991e9cf5a01.png)'
- en: Don't forget to click on the text to change the background color!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记点击文本以更改背景颜色！
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The syntax to declare a new directive is as illustrated:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 声明新指令的语法如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will register a new global directive. Inside the hooks object, you can
    define two important functions: `bind`, which you used in this recipe, and `update`,
    which is triggered every time a component contained in it is updated.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注册一个新的全局指令。在hooks对象内，您可以定义两个重要的函数：`bind`，您在本教程中使用了它，以及`update`，每当包含在其中的组件更新时触发。
- en: 'Every hook function is called with at least three arguments:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个hook函数至少带有三个参数：
- en: '`el`: The HTML element'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`el`: HTML元素'
- en: '`binding`: Directives can receive an argument; binding is an object that will
    contain the value of the argument'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`：指令可以接收一个参数；binding是一个包含参数值的对象'
- en: '`vnode`: the Vue internal representation of this element'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vnode`：这个元素的Vue内部表示'
- en: We used the `el` parameter to edit the appearance of our element, manipulating
    it directly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`el`参数直接编辑元素的外观。
- en: Using WebSockets in Vue
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vue中使用WebSockets
- en: WebSockets is a new technology that enables two-way communication between the
    user and the server where the app is hosted. Before this technology, only the
    browser could initiate a request and, thus, a connection. If some update on the
    page was expected, the browser had to continuously poll the server. With WebSockets,
    this is no longer necessary; after the connection is established, the server can
    send updates only when there is a need.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets是一种新技术，它使用户和托管应用程序的服务器之间实现双向通信。在这项技术出现之前，只有浏览器可以发起请求和建立连接。如果页面上有更新，浏览器必须不断地轮询服务器。有了WebSockets，这就不再需要了；连接建立后，服务器只有在需要时才能发送更新。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You don't need any preparation for this recipe, just the basics of Vue. If you
    don't know what WebSockets are, you don't really need to, just think about them
    as a channel of continuous two-way communication between a server and browser.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，您不需要做任何准备，只需要了解Vue的基础知识。如果您不知道什么是WebSockets，您也不需要知道，只需将它们视为服务器和浏览器之间持续双向通信的通道。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: For this recipe, we need a server and a browser that will act a client. We will not
    build a server; instead, we'll use an already existing server that just echoes
    whatever you send to it via WebSockets. So, if we were to send the `Hello` message,
    the server would respond with `Hello`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们需要一个服务器和一个将充当客户端的浏览器。我们不会构建服务器；相反，我们将使用一个已经存在的服务器，它只会通过WebSockets回显您发送的任何内容。因此，如果我们发送`Hello`消息，服务器将回复`Hello`。
- en: 'You will build a chat app that will talk to this server. Write the following
    HTML code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个聊天应用程序，它将与此服务器通信。编写以下HTML代码：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `<pre>` tag will help us render a chat. As we don't need the `<br/>` element
    to break a line, we can just use the `n` special character that means a new line.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`<pre>`标签将帮助我们呈现聊天。由于我们不需要`<br/>`元素来换行，我们可以使用`n`特殊字符，表示换行。'
- en: 'For our chat to work, we first have to declare our WebSocket in the JavaScript:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的聊天工作，我们首先必须在JavaScript中声明我们的WebSocket：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, we declare our `Vue` instance that will contain a `chat` string
    (to contain the chat so far) and a `message` string (to contain the message we
    are currently writing):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们声明将包含`chat`字符串（目前为止包含聊天内容）和`message`字符串（包含我们当前正在编写的消息）的`Vue`实例：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We still need to define the `send` method, which is called upon pressing *Enter*
    in the textbox:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要定义`send`方法，在文本框中按下*Enter*时调用：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We factored out the `appendToChat` method because we will use it to append
    all the messages we''ll receive. To do this, we must wait for the component to
    be instantiated. The `created` hook is a safe place for that:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`appendToChat`方法分解出来，因为我们将用它来附加我们将收到的所有消息。为此，我们必须等待组件被实例化。`created`挂钩是一个安全的地方：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now launch the application to chat with your personal echo chamber:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动应用程序，与您的个人回声室聊天：
- en: '![](assets/2be880b7-2320-4cd4-9d75-86d83a5fe745.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2be880b7-2320-4cd4-9d75-86d83a5fe745.png)'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To see the internals of what you have built, open the Chrome developer tools
    (![](assets/77a56c95-2c9d-4704-bc07-f38fb2e8cf62.png) | More tools | Developer
    tools or *Opt* + *Cmd* + *I*):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您构建的内容的内部，请打开Chrome开发者工具（![](assets/77a56c95-2c9d-4704-bc07-f38fb2e8cf62.png)
    | 更多工具 | 开发者工具或*Opt* + *Cmd* + *I*）：
- en: '![](assets/74ff02b5-6528-42ce-995a-2d4d27ed90e5.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/74ff02b5-6528-42ce-995a-2d4d27ed90e5.png)'
- en: 'Go to the Network tab and reload the page; you should see the `echo.websocket.orl` WebSocket,
    as seen in the screenshot. Write something and messages will appear in the frame
    tab, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 转到网络选项卡并重新加载页面；您应该会看到`echo.websocket.orl` WebSocket，就像屏幕截图中所示。写点东西，消息将出现在帧选项卡中，就像这样：
- en: '![](assets/02d81265-937d-44e8-9208-3772eaf362c6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02d81265-937d-44e8-9208-3772eaf362c6.png)'
- en: The green messages are sent from you while the white messages are the ones you
    receive. You can also examine the message length (in bytes) and the exact time
    they were sent or received.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色消息是您发送的，而白色消息是您收到的。您还可以检查消息长度（以字节为单位）和发送或接收的确切时间。
- en: Writing a plugin for Vue
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Vue编写插件
- en: A plugin is a collection of utilities or a global new behavior that we want
    in our application. Vuex and vue-router are two famous examples of Vue plugins.
    A plugin can really be anything, since writing one means acting at a very low
    level. There are different kinds of plugins you can write. For this recipe, we
    will concentrate on building a directive with global properties.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是我们想要在应用程序中使用的一组实用程序或全局新行为。Vuex和vue-router是Vue插件的两个著名示例。插件实际上可以是任何东西，因为编写插件意味着在非常低的级别上进行操作。您可以编写不同类型的插件。对于这个示例，我们将集中于构建具有全局属性的指令。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will be based on *Creating a new directive*, except that we will
    add some features for global coordination.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将基于*创建一个新的指令*，只是我们将为全局协调添加一些功能。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, we will build a website for a kangaroo appreciation club.
    The layout of the home page HTML looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将为袋鼠欣赏俱乐部构建一个网站。主页HTML的布局如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can change the link to the images of kangaroos with the one you prefer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将袋鼠图片的链接更改为你喜欢的链接。
- en: 'In the JavaScript part, we instantiate an empty `Vue` instance for now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript部分，我们目前实例化了一个空的`Vue`实例：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we open the page now, we get this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开页面，会得到这个：
- en: '![](assets/cce76243-a432-47d4-9f5b-aa3bac83740e.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cce76243-a432-47d4-9f5b-aa3bac83740e.jpg)'
- en: Now we want to add a fun note to our website. We want the elements of the page,
    except the title, to jump at random intervals.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想在我们的网站上添加一个有趣的注释。我们希望页面的元素（除标题外）在随机时间间隔跳动。
- en: To do this, the strategy you will implement is to register all the elements
    that will need to jump in an array, and then, periodically take a random element
    and make it jump.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to define is the jump animation in CSS:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What this does is create a class named `kangaroo` that, when applied to an element,
    makes it jump twice by translating it along the y axis.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, write a function that adds this class to a specified element in the JavaScript:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `jump` function adds the `kangaroo` class and then removes it when the animation
    is finished.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to perform this action on a random element picked from the ones registered:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `doOnRandomElement` function takes an action and a collection and applies
    the action to a drawn element. We then need to schedule it at random intervals:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `atRandomIntervals` function takes the specified function and calls it at
    random intervals shorter than 6 seconds.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have all the functions we need to actually build a plugin that will
    make our element jump:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Kangaroo plugin, when installed, creates an empty array; it declares a new
    directive, `kangaroo` which will register all the elements with it inside the
    array.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Then at random intervals, one random element is drawn from the array and the
    jump function is called on it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the plugin, we need one line before declaring the `Vue` instance
    (but after declaring `Kangaroo`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have to choose the elements that jump, that is, everything except the title:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you run your app now, you will see that an image or the text jumps just like
    a kangaroo every few seconds.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its essence, a Vue plugin is just a way to group some functionalities. There
    are not many restrictions and all you have to do to create a plugin is to declare
    an install function. The general syntax to do that is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To use the plugin you just made, write the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the second parameter is the optional object that gets passed to the `install`
    function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Since plugins are global entities, you should use them sparsely and only for
    features that you foresee will affect your app throughout.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a simple component manually
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue turns your HTML templates into render functions. Usually, you should stick
    to templates because they are much simpler. There are a couple of cases in which
    render functions become in handy. Here, we show a simple example in which render
    functions are useful.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first recipe on render functions. If you already understand the
    basics of Vue, you will understand everything.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first use case for render functions is whenever you just want a `Vue` instance
    that displays another component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Write an empty HTML layout, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have a Greeter component somewhere that we want to show as the main `Vue`
    instance. In the JavaScript part, add the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we have to imagine that we are taking the `Greeter` component from somewhere
    else and, since the component is nicely packaged, we don''t want to modify it.
    Instead, we will pass it to the `Vue` main instance:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we launch the application now, we will only see the `Greeter` component.
    The main `Vue` instance will only act as a wrapper.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The render function replaces the template in the `Vue` instance. When render
    is called, the passed argument is the so-called `createElement` function. We named
    it `h` for brevity. This function accepts three arguments, but for now, just note
    how the first argument we are passing (the only one we are passing) is the `Greeter`
    component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In theory, you can write the component inline, inside the `h` function. In a
    real project, this is not always possible depending on the presence of the Vue
    template compiler at runtime. When you use the official Webpack template, one
    of the questions you are asked is whether you want to include the Vue template
    compiler when distributing your software.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments for the `createElement` function are listed here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first argument, the only required one, you have the option to pass three
    different things:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The options of a Vue component, like in our recipe
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string representing an HTML tag (such as `div`, `h1`, and `p`)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that returns an options object for a Vue component or a string representing
    an HTML tag
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument must be an object called **Data Object**. This object is
    explained in the next recipe.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third argument is an array or a string:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The array represents a list of elements, text, or components to put inside the
    component
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can write a string that will be rendered to text
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a component with children
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will build a simple web page with a few elements and components
    completely using render functions. This will give you a close-up view of how Vue
    compiles your templates and components. It may be useful if you want to build
    an advanced component and you want a full example to kick start.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a complete recipe on how to build components through render functions.
    Usually, you don't need to do this in practice; it's recommended only for advanced
    readers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will build a page for a plumber club. The page will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f1122977-a2ba-4565-8652-c6f910aee0b8.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Whenever we write a name inside the name textbox, it will be written in the
    greeting exactly like the `v-model` directive.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we are starting from the end instead of the beginning because
    usually when you have to resort to the `render` function, you have a pretty clear
    idea of what you are trying to get.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'In the HTML side of our app, let''s start with an empty tag:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the JavaScript, write an empty `<div>` element in the `render` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first thing we''ll put inside is the title, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All the other elements and components will fit inside the array we have just
    created for the title.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: We need an `<input>` element that will take the value and display a greeting.
    For this, we can build a `Vue` component.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we are using a regular JavaScript function instead of
    an arrow function; this is because we want a reference to the component itself.
    Arrow functions don't allow you to modify the scope of `this`, while `this` depends
    on how the function is called and can be optionally bound to any variable in regular
    functions. In our case, it will be bound to the instance component.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'After the title of the page, we add the following component in the same array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The component has three options: the `render`, `data`, and `props` functions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter of the `createElement` function is to actually assign
    values to our props:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will be equivalent to writing `:exclamation="true"` when declaring the
    component.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: You can easily understand the `data` and `props` options of the component. Let's
    examine what we wrote in the `render` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line of the function, we set `self = this` as a convenient way
    to refer to the component were we to add any nested functions. Then, we return
    the result of a `createElement` function (`h`) that, inside a div tag, places
    three things in the DOM. The first is the raw text `Your name is` and then two
    elements: an input and a paragraph.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We don't have a direct equivalent of the `v-model` directive when working with
    render functions. Instead, we implement it manually. We bind the value to the
    name, and then we add a listener to the input event that will set the value of
    the state variable, `name`, to whatever is inside the textbox.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We then insert a paragraph element that will compose the greeting phrase, adding
    an exclamation point based on the value of the `exclamation` prop.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'After the component, we can add the following, as illustrated, in the same
    array:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you have done things right, you should be able to run the application and
    see the whole page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we've seen a glimpse of what happens behind the curtains when
    Vue compiles our templates; again, you are not advised to do this with regular
    components. Most of the time, the result will be just more verbose with little
    or no gain. On the other hand, there are a couple of cases in which writing the
    render function may actually result in better or more robust code and cover some
    functionality that is difficult to express with templates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Using JSX to render a component
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX is very popular in the React community. In Vue, you don't have to use JSX
    to build templates for your components; you can use the much more familiar HTML. JSX,
    however, is the next best thing you can do if you are forced to write a lot of
    render functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before venturing into this recipe, you better play a little with the render
    function. The previous recipes provide some exercises.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX needs a Babel plugin to work. For this recipe, I will assume that you are
    working within the webpack template.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the babel plugin, you can run the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the `.babelrc` file, add the following in the `plugins` array:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run `npm install`, as usual, to actually install all the dependencies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `main.js` and delete everything inside. Replace it with the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The highlighted line is the weird bit if you have never seen JSX. Just note
    that we didn't use the arrow function in the `render` option in the preceding code.
    That's because we are using `this` inside and we want it to be bound to the component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: You can already see your page working using the `npm run dev` command.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The babel plugin will turn the JSX code into a JavaScript `render` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: I wouldn't recommend using JSX with Vue. The only time I can see it being useful
    is whenever you need to intermix `render` functions with JavaScript and you need
    a quick and readable way of defining templates. Other than that, there are not
    many advantages to using JSX.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's complicate the code a little bit to at least have a flavor of how JSX
    plays with props.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new component before the main `Vue` instance:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s use this component in our `Vue` instance and pass the `msg` variable
    via props:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The syntax is slightly different from an HTML template. In particular, note
    how props are passed and how we can use camelCase and self-closing tags.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Creating a functional component
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lighter version of a component is a functional component. The functional component
    doesn't have instance variables (so no `this`) and has no state. In this recipe,
    we will write a simple functional component that takes some instructions via HTML
    and turns them into a drawing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before attempting this recipe, you should at least become familiar with the
    render function in Vue. You can use the previous recipes to do that.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are writing an `<svg>` element, you usually have to put data in the
    attributes of elements inside it to actually draw shapes. For example, if you
    want to draw a triangle, you have to write the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The text inside the `d` attribute is a series of instructions that make a virtual
    cursor move to draw: `M` moves the cursor to the (100, 30) coordinate inside the
    `<svg>`, then `L` traces a line up until (200, 30) and then again to the (150,
    120) coordinate. Finally, `z` closes the path we are drawing, and the result is
    always a triangle.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to write a triangle with a component, but we don''t like attributes
    and we want to write in our own language, so we would write the following to get
    the same result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a perfect job for a functional component because there is no state to
    manage, only a translation from one component to one element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Your HTML layout will simply look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, lay out your functional component in your JavaScript:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You have to specify that the component will be functional with `functional:
    true`; then the render function is slightly different than usual. The first argument
    is still the `createElement` function, but the second passed is the context of
    our component.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: We can access the text written inside the HTML of our component (the commands
    to draw) through `context.children`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that I already added an empty `<svg>` element. Inside this, there
    is an empty array of children; we will put only the `<path>` element there, which
    is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The highlighted code creates a path element and then sets some attributes, such
    as `fill` and `stroke`. The `d` attribute takes the text from inside the component,
    makes some substitutions, and then returns it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to create the `Vue` instance in the JavaScript:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, loading the app, we should see a triangle, which is shown in the following
    screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6fe42ac0-2a31-49a7-a2ac-3f4b3ef23ba4.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue lets you create components that are very lightweight as they don't have
    any internal state. With this come some limitations, for example, the only place
    where we can put some logic to process user input (in the form of children of
    the element or props) is in the render function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The context we passed contains the following properties:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '`props`: This is passed by the user.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`children`: This is really an array of virtual nodes, children of our component
    in the template. We don''t have the actual HTML element here but only a representation
    of it by Vue.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slots`: This is a function returning the slots (can be used instead of children
    in some cases).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This is the entire data object passed to the component.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent`: This is a reference to the parent component.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our code, we extracted the text inside the component by doing the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are taking the array of virtual nodes contained in children and mapping
    each node to its text. Since we put only some text in our HTML, the array of nodes
    will be a singleton, with only one node: the text we entered. Therefore, in this
    particular case, doing `var a = children.map(c => someFunction(c))` is then equivalent
    of doing `var a = [someFunction(children[0])]`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We are not only extracting the text though, but we are also replacing some terms
    I invented to describe `svg` commands, with the real commands. The `join` function
    will sew together all the strings in the array (just one in our case) and `trim`
    will remove all the white spaces and line breaks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Building a responsive table with higher-order components
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional components are very good wrappers when we have to decide which component
    to actually wrap. In this recipe, you'll write a responsive table that will display
    different columns depending on the browser width.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is about functional components. If you want to warm up, you can
    try and complete the previous recipe.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the excellent semantic UI CSS framework. To use
    it, you have to include the CSS library as a dependency or as a `<link>` tag.
    For example, you can put the following code in the `<head>` of your HTML:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you are using JSFiddle, the link inside should be sufficient.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tag you have to add to your page for it to look good on mobile is this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This tells the mobile browser that the width of the page is equal to the width
    of the device. If you don't put this, the mobile may assume that the page is much
    larger than the phone and, trying to display all of it, show a miniaturized version
    of your app.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We will design a table of cat breeds. You can see all the data in the Vue instance
    status. Write it in your JavaScript:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We are declaring the `width` variable to change the layout of the page and since
    the width of the page is not reactive by nature, we're also installing a listener
    on `window.onresize`. For a real project, you'll probably want something a bit
    more sophisticated, but for this recipe, this will suffice.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note how we are using the `BreedTable` component, which we write like
    this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What our component is doing is just passing all the `context.data` and `context.children`
    to another component, which will be `DesktopTable` or `MobileTable`, depending
    on the resolution.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML layout is the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `breeds` props will be passed on to the selected component in the `context.data`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Our desktop table will look pretty regular for a table:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The classes at the top are part of semantic UI and they will make our table
    look much better. The `unstackable` class, in particular, disables the automatic
    stacking performed by CSS. We will cover more on this in the next section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'For the mobile table, we''d like to edit not only the styling, but we''d also
    like to group the columns themselves. The breed will go along with the color and
    the affection with the shedding. Also, we want to express them in a compact style.
    The table head will look like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instead of just spelling the coat color, we draw a little circle of that color:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Also, instead of using numbers like in the desktop table for the affection
    and shedding level, we put a heart and star rating:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Also, don't forget to declare the `breeds` prop like in the `DesktopTable` component.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Now launch your application in a browser. You can see how the table groups
    the column when squished enough:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f412040b-98f6-40b2-a2a6-bcd040783e8a.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows that numbers are replaced by hearts and star
    rating:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/345c3620-753a-4e06-b1dc-4f1278ae72d8.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A responsive page changes its layout according to the width of the browser and
    this is very important when the user is using a tablet or smartphone to browse
    the website.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Most of the components have to be developed only once for a responsive page,
    and only the styling is done multiple times according to different sizes. This
    can save a lot of development time if compared to having a separate site optimized
    for mobile.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, in a responsive page table, go from columnar to stacked, as shown in
    the following illustration:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a65800dd-a4d1-4188-85e1-cb663f980d60.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: I never liked this approach, but the objective disadvantage is that if you make
    your table look good on one side, it will look not so good on the other. This
    is because you have to style the cells in the same way and what the responsiveness
    does is that it stacks them up.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: What our `BreedTable` component does is to dynamically switch between the two
    components instead of simply relying on the CSS. Since it's a functional component,
    it has the advantage of being very lightweight compared to a full-fledged component.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: In a real application, using the `onresize` event is questionable, mainly because
    of the performance hit. In a production system, the solutions for responsiveness via
    JavaScript need to be more structured. For example, consider using a timer or
    using `matchMedia`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: As a last thing, note how the Vue instance never registers the two subcomponents;
    this is because they never appear in a template but are referenced directly in
    the code as objects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
