- en: Chapter 12. 3T Administration Made Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 3T administration interface allows a user to maintain company, project,
    and task relationships. As the relationship is hierarchical, we will be working
    with one of the most versatile components in Ext JS: `Ext.tree.Panel`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface we will be building looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![3T Administration Made Easy](img/5457_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting an item in the tree will display the appropriate record on the panel
    to the right, while the **Add New Company** button will allow the user to enter
    the name of a new company. Let's now examine these actions in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Administration workflows and layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three different entities that may be edited (company, project, and
    task), with the preceding screenshot showing the company. Selecting a project
    in the tree will display the **Edit Project** form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Administration workflows and layouts](img/5457_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Selecting a task will display the **Edit Task** form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Administration workflows and layouts](img/5457_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Selecting the **Add New Company** button will display an empty company form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Administration workflows and layouts](img/5457_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the **Delete** and **Add Project** buttons are disabled. When an action
    is not allowed, the appropriate button will be disabled in all the screens. In
    this situation, you cannot add a project to a company that has not yet been saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tree tools will allow the user to expand, collapse, and refresh the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Administration workflows and layouts](img/5457_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user first displays the administration interface, the **Add New Company**
    screen is shown. When any item is deleted, the **Please select an item from the
    tree…** message is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Administration workflows and layouts](img/5457_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have defined the interfaces and their behavior, it is time to define
    our views.
  prefs: []
  type: TYPE_NORMAL
- en: Building the 3T administration interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 3T administration interface will require us to build the components displayed
    in the following screenshot. The `ProjectForm` and `TaskForm` views are not visible
    and will be displayed when required in a card layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the 3T administration interface](img/5457_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `ManageTasks` view is an `hbox` layout that equally splits the left and
    right parts of the screen. The toolbar contains a single button to add a new company,
    while the region to the right is a card layout containing the `CompanyForm`, `ProjectForm`,
    and `TaskForm` views. Let's now look at each component in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The ManageTasks.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ManageTasks` view defines the toolbar with the **Add New Company** button
    and splits the view into an `hbox` layout. The `companytree` panel and `container`
    defined with the card layout are configured by `xtype`. The card layout container
    contains the `CompanyForm`, `ProjectForm`, and `TaskForm`. The `ManageTasks` view
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of a simple container as the first item of the card layout to display
    the **Please select an item from the tree...** message.
  prefs: []
  type: TYPE_NORMAL
- en: The CompanyForm.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CompanyForm` view has a very simple interface that only has one data entry
    field: `companyName`. This can be seen in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note the initial state of the **Delete** and **Add Project** buttons are disabled
    until a valid company is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The ProjectForm.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The layout and structure of the `ProjectForm` view is very similar to the company
    form we have just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once again the initial state of the **Delete** and **Add Task** buttons is `disabled`
    until a valid project is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskForm.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TaskForm` view is again similar to the previous forms but will only need
    two buttons that are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the initial state of the **Delete** button is disabled until a valid
    task has been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The CompanyTree.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final view is the `CompanyTree` view that represents the relationship between
    the company, project, and task.
  prefs: []
  type: TYPE_NORMAL
- en: '![The CompanyTree.js file](img/5457_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This view is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `CompanyTree` view extends `Ext.tree.Panel` that requires a specialized
    `Ext.data.TreeStore` implementation which manages tree nodes and the relationship
    between items. The Ext JS 4 tree is a very flexible component and we recommend
    you become familiar with the core tree concepts at [http://docs.sencha.com/extjs/4.2.2/#!/guide/tree](http://docs.sencha.com/extjs/4.2.2/#!/guide/tree).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Ext.data.TreeStore class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Ext.data.TreeStore` class is the default store implementation used by `Ext.tree.Panel`.
    The `TreeStore` function provides many convenient functions for loading and managing
    hierarchical data. A `TreeStore` function may be defined with a model but this
    is not required. If a model is provided, it is decorated with the fields, methods,
    and properties of `Ext.data.NodeInterface` that are required for use in the tree.
    This additional functionality is applied to the prototype of the model to allow
    the tree to maintain the state and relationships between models.
  prefs: []
  type: TYPE_NORMAL
- en: If a model is not provided, one such model will be created by the store in a
    way that it implements the `Ext.data.NodeInterface` class. We recommend you browse
    the `NodeInterface` API documentation to see the full set of fields, methods,
    and properties available on nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `CompanyTree` store definition for use in our tree is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All the tree stores consume data that is in a hierarchical structure, either
    in JSON or XML format. We will generate JSON data in our request handling layer
    with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This structure defines the core properties used by any tree including `id`,
    `children`, `text`, `leaf`, and `expanded`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `children` property defines an array of nodes that exist at the same level
    and belong to the same parent. The top-level children in the structure belong
    to the root node and will be added to the root level of the tree. The tree panel
    property, `rootVisible:false`, will hide the root level from the view, displaying
    only the children. Enabling root-level visibility by setting the property to `rootVisible:true`
    will display the root node as defined in the `TreeStore` class. For example, adding
    the following definition to the tree store will result in the `Companies` node
    being displayed as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Introducing the Ext.data.TreeStore class](img/5457_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We wish to display each company at the top level of the tree and hence will
    be hiding the root node from the view.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` property is used internally to uniquely identify each node. There can
    be no duplicates for this property within the tree structure, and we will hence
    prefix the `id` value with the type of node. A node representing a company will
    be prefixed with `C_`, a project node with `P_`, and a task node with `T_`. This
    `id` format will allow us to determine both the node type and the primary key
    of the node. If an ID is not provided, the store would generate one for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ID can also be used to dynamically assign an `iconCls` class to the node.
    We do this through the use of the `append` listener of the store and define this
    later in the controller. Note that we could just as easily define the `iconCls`
    property in JSON itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, we are now combining data with the presentation, and the Java method
    that generates JSON should not be concerned with how data is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `text` field of the JSON tree is used to display the node's text. For simple
    trees, without multiple columns, this is the default field name if not explicitly
    set with a column definition (tree columns will be discussed later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The leaf property identifies whether this node can have children. All the task
    nodes have the `"leaf":true` setting. The `leaf` property defines whether the
    expand icon is shown next to the node.
  prefs: []
  type: TYPE_NORMAL
- en: The last property of interest is the `expanded` property that indicates whether
    the node should be displayed in an expanded state. This property must be set to
    `true` on each node that has children if we're loading an entire tree at once;
    otherwise, the proxy will attempt to load children for these nodes dynamically
    when they are expanded. Our JSON data will contain the entire tree, and hence
    we set the `expanded` property to `true` for each parent node.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a JSON tree in the CompanyHandler class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to enhance the `CompanyHandler` class to generate the required
    JSON to load the tree store and display the company tree. We will create two new
    methods to implement this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The CompanyHandler.getTreeNodeId() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CompanyHandler.getTreeNodeId()` helper method generates a unique ID based
    on the ID of the `EntityItem` class. It will be used to generate type-specific
    IDs for each node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The CompanyHandler.getCompanyTreeJson() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CompanyHandler getCompanyTreeJson()` method is mapped to the `company/tree.json`
    URL and has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This method performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a `JsonArrayBuilder` object with the name `companyChildrenArrayBuilder`
    to hold the set of company `JsonObjectBuilder` instances that will be created
    in the main `for` loop when iterating through the company list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It loops through each project assigned to each company, adding each project's
    `JsonObjectBuilder` tree node representation to the `projectChildrenArrayBuilder
    JsonArrayBuilder` instance. The `projectChildrenArrayBuilder` instance is then
    added as the `children` property of the owning company `JsonObjectBuilder` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It loops through each task assigned to each project, adding each task's `JsonObjectBuilder`
    tree node representation to the `taskChildrenArrayBuilder JsonArrayBuilder` instance.
    The `taskChildrenArrayBuilder` instance is then added as the `children` property
    of the owning project, the `JsonObjectBuilder` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds the `companyChildrenArrayBuilder` as the `children` property of the
    `builder` instance that will be used to build and return JSON from the method
    with `success` property `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getCompanyTreeJson` method returns a hierarchical JSON structure that encapsulates
    the relationship between the company, project, and task in a format that can be
    consumed by the `CompanyTree` store.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the 3T administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TTT.controller.AdminController` ties together the views and implements
    the many actions that are possible in this user interface. You must download the
    source code to see the complete definition of this controller as it is not reproduced
    completely within the following text.
  prefs: []
  type: TYPE_NORMAL
- en: The `AdminController` has references to the four stores required for processing
    actions. Each store is reloaded after an `update` or `delete` action to ensure
    the store is in sync with the database. For multiuser applications, this is an
    important point to consider; can view data be changed by a different user during
    the lifetime of a session? Unlike the task log interface, where data belongs to
    the user in the session, the 3T administration module may be actively used by
    different users at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is beyond the scope of this book to discuss strategies for data integrity
    in multiuser environments. This is usually achieved through the use of per record
    timestamps that indicate the last update time. Appropriate logic in the service
    layer would test the submitted record timestamp against the timestamp in the database
    and then process the action accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There is one store and model that is yet to be fully defined; we will do so
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Company model and store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Company` model was first defined using Sencha Cmd in [Chapter 9](ch09.html
    "Chapter 9. Getting Started with Ext JS 4"), *Getting Started with Ext JS 4*,
    but we now need to add the appropriate proxy and validations. The full definition
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Company` store will load all the company records through the `company/findAll.json`
    URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Company` model and store are our simplest definitions to date. We will
    now examine the core actions in our `AdminController`.
  prefs: []
  type: TYPE_NORMAL
- en: The doAfterActivate function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three stores that are required for 3T administration are loaded when the
    `ManageTasks` panel is activated. This will ensure that valid records are available
    in each store when selecting an item in the tree. The `doAfterActivate` function
    can be used for initializing the state of any components belonging to the `AdminController`.
    This is especially useful when configuring the drag-and-drop action at the end
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are adding the **append** listener to the tree store view and assigning
    the `doSetTreeIcon` function. It is not possible to do this in the `init` function
    control config as the view is not yet configured and ready at this point in time.
    Assigning the `doSetTreeIcon` function to the listener after the activation ensures
    the component is fully configured. The `doSetTreeIcon` function dynamically assigns
    an `iconCls` class to each node depending on the node type.
  prefs: []
  type: TYPE_NORMAL
- en: The final step in the `doAfterActivate` function is to load the tree store to
    display the data in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The doSelectTreeItem function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `doSelectTreeItem` function is called when a user selects an item in the
    tree. The node ID is retrieved and split to allow us to determine the type of
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For each node, the primary key value is determined and used to retrieve the
    record from the appropriate store. The record is then loaded into the form, which
    is then set to be the active item in the admin card's layout.
  prefs: []
  type: TYPE_NORMAL
- en: The doSave functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each save function retrieves the record from the form and updates the record
    with the form values. The record is saved if the validation is successful and
    the form updated to reflect the changing button state. The store that owns the
    record is then reloaded to sync with the database.
  prefs: []
  type: TYPE_NORMAL
- en: The doDelete functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each delete function confirms the user action before calling the `destroy`
    method of the model. If successful, the active item in the admin card''s layout
    is set to display the default message: **Please select an item from the tree**.
    If the deletion was not successful, an appropriate message is displayed to inform
    the user.'
  prefs: []
  type: TYPE_NORMAL
- en: The doAdd functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Add** buttons are on the form that is the parent for the `Add` action.
    You can only add a project to a company or add a task to a project. Each `doAdd`
    function retrieves the parent and creates an instance of the child before loading
    the appropriate form. Buttons on the child form are disabled as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the 3T administration interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to add our new components to our `Application.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the `ManageTasks` view to our `MainCards`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can now run the application in the GlassFish server and test the 3T administration
    interface by logging on as the `bjones` user (or any other user who has administrator
    permission).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loading tree nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise applications usually have data sets that prohibit the loading of
    the full tree in a single JSON request. Large trees can be configured to load
    children on a per node basis by expanding levels on demand. A few minor changes
    to our code can allow us to implement this dynamic loading of node children.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a node is expanded, the tree store proxy submits a request that contains
    a `node` parameter with the ID of the node being expanded. The URL submitted is
    that which is configured in the proxy. We will change our tree store proxy as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the URL of the proxy has been changed to `treenode`. This mapping,
    when implemented in `CompanyHandler`, will load one level at a time. The first
    request submitted by the proxy to load the top level of the tree will have the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the root node''s list of companies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no `children` array defined for each company, and the `leaf`
    property is set to `false`. The Ext JS tree will display an expander icon next
    to the node if there are no children defined and the node is not a leaf. Clicking
    on the expander icon will submit a request that has the `node` parameter set to
    the `id` value for the node being expanded. Expanding the `"PACKT Publishing"`
    node would hence submit a request to load the children via `company/treenode.json?node=C_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON response would consist of a `children` array that would be appended
    to the tree as children of the `PACKT Publishing` node. In our example, the response
    would include the projects assigned to the company:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again each project would not define a `children` array, even if there
    are tasks assigned. Each project would be defined with `"leaf":false` to render
    an expander icon if there are tasks assigned. Expanding the `P_1` node would result
    in the proxy submitting a request to load the next level: `company/treenode.json?node=P_1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This would result in the following JSON being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This time we define these nodes with `"leaf":true` to ensure the expander icon
    is not displayed and users are unable to attempt loading a fourth level of the
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CompanyHandler` method that is responsible for this logic can now be defined
    and mapped to the `company/treenode.json` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `getCompanyTreeNode` method determines the type of node being expanded and
    loads appropriate records from the service layer. The returned JSON is then consumed
    by the store and displayed in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the project in GlassFish and display the **3T Admin** interface.
    The first level of the tree is loaded as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamically loading tree nodes](img/5457_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the expander icon is clicked, the next level of the tree will be dynamically
    loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamically loading tree nodes](img/5457_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The third level can then be expanded to display the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamically loading tree nodes](img/5457_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will leave it to you to enhance the `AdminController` for use with dynamic
    trees. Reloading the tree after each successful save or delete would not be very
    user friendly; changing the logic to only reload the parent node would be a far
    better solution.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying multiple tree columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ext JS 4 trees can be configured to display multiple columns for visualising
    advanced data structures. We will make a few minor changes to display the ID of
    each node in the tree. Simply adding a new column to the tree definition will
    achieve this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also added the `text` property to each column, which is displayed in
    the header row, and enabled headers with `hideHeaders:false`. These minor changes
    will result in the following tree being displayed when fully expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying multiple tree columns](img/5457_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drag-and-drop made easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dragging and dropping nodes within trees is easy with Ext JS 4\. To allow the
    drag-and-drop action within a tree, we need to add the `TreeViewDragDrop` plugin
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This simple inclusion will enable the drag-and-drop support for your tree. You
    will now be able to drag-and-drop any node to a new parent. Unfortunately, this
    is not exactly what we need. A task node should only be allowed to drop on a project
    node, while a project node should only be allowed to drop on a company node. How
    can we restrict the drag-and-drop action to these rules?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two events that can be used to configure this functionality. These
    events are fired from the `TreeViewDragDrop` plugin and can be configured in the
    `doAfterActivate` function of the `AdminController` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `beforedrop` event can be used to test whether the `drag` and `drop` actions
    are valid. Returning `false` will stop the `drop` action from occurring and animate
    the node back to the origin of the action. The `drop` event can be used to process
    the `drop` action, most likely to persist the change to the underlying storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isDropAllowed` function returns `true` or `false` depending on whether
    the drop target is valid for the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will restrict the `drag` and `drop` actions to two valid scenarios:
    dragging a project to a new company and dragging a task to a new project. All
    the other `drag` and `drop` actions are not allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dragging and dropping alone is not enough; we now need to save the new parent
    after a successful drop. This action is handled in the `doChangeParent` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Dragging a valid node to a new parent is now persisted when the record is saved.
    You will now be able to drag-and-drop between valid tree nodes and automatically
    save the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animations provided by Ext JS 4 trees will guide your `drag` and `drop`
    actions. Dragging the **Database Development** node will animate the action as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drag-and-drop made easy](img/5457_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Should the drop action not be allowed, the node will animate back to the original
    position, providing instant visual feedback for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS 4 trees are very flexible components, and there is still much to learn
    if you want to fully leverage trees in your application. We recommend that you
    explores the many tree examples on the *Sencha Docs* website for more complex
    examples including the `drag` and `drop` actions between trees and persisting
    model-based data nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **3T Admin** interface introduced the tree component for displaying hierarchical
    data. The company, project, and task relationship was loaded into the tree via
    a single JSON request and allowed the user to maintain and add new entities.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic loading of tree nodes was then explained and implemented. This strategy
    is best suited for very large trees with potentially complex data structures.
    Node-by-node dynamic loading is easily achieved with minimum changes required
    in the Ext JS 4 client and Java backend.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying multiple tree columns and the basic drag-and-drop functionality was
    also explored and implemented to show the flexibility of the Ext JS 4 tree.
  prefs: []
  type: TYPE_NORMAL
- en: Our final step in the enterprise application development with Ext JS and Spring
    journey is building our 3T project for production deployment. Thankfully, Maven
    and Sencha Cmd can help make this an easy task as you will learn in our final
    chapter, [Chapter 13](ch13.html "Chapter 13. Moving Your Application to Production"),
    *Moving Your Application to Production*.
  prefs: []
  type: TYPE_NORMAL
