- en: Scheduling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'System programming is about interacting with the underlying OS. The scheduler
    is one of the core components of every OS and impacts the way processes are allocated
    on CPUs. Ultimately, this is what the end user is concerned about: processes running
    smoothly and with correct priority over other processes. This chapter will teach
    you the practical skills you need in order to interact with the scheduler by changing
    the process'' policy, its `nice` value, the real-time priority, processor affinity,
    and how real-time processes can **yield** the processor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to set and get a scheduler policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to get the timeslice value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to set a nice value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to yield the processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about processor affinity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To try out the programs in this chapter, we've set up a Docker image that contains
    all the tools and libraries we'll need throughout this book. It is based on Ubuntu
    19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Docker Engine from [www.docker.com](https://www.docker.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should have the following image: `kasperondocker/system_programming_cookbook`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell with the help of the `docker
    run -it --cpu-rt-runtime=95000 --ulimit rtprio=99 --cap add=sys_nice kasperondocker/system_programming_cookbook:latest /bin/bash` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Use `root@39a5a8934370/#
    cd /BOOK/` to get all the programs that have been developed for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cpu-rt-runtime=95000`, `--ulimit rtprio=99`, and `--cap add=sys_nice` arguments are
    needed to allow the software written in Docker to set the scheduler parameters.
    If the host machine has been configured correctly, the software won't have any
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to set and get a scheduler policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a system programming context, there are cases where some processes must be
    handled differently than others. By differently, we mean the different ways a
    process gets a processor time or a different priority. A system programmer must
    be aware of this and learn how to interact with the scheduler's API. This recipe
    will show you how to change the **policy** of a process to meet different scheduling
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will show you how to get and set the *policy* of a process alongside
    the limits that can be assigned to it. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a shell, let''s open a new source file called `schedParameters.cpp`. We
    need to check what the current (default) process policy is. To do this, we''ll
    use the `sched_getscheduler()` system call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to assign the `SCHED_FIFO` policy with a real-time (`rt`) priority.
    To make the code portable, we get the min and max from the `sched_get_priority_min`
    and `sched_get_priority_max` APIs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be able to check the new `SCHED_FIFO` policy that was assigned with
    the `sched_getscheduler()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The next section will describe the preceding code in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The POSIX standard defines the following policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SCHED_OTHER`: The normal scheduler policy (that is, not for real-time processes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCHED_FIFO`: First-in/first-out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCHED_RR`: Round-robin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `SCHED_OTHER` is the default one and `SCHED_FIFO` and `SCHED_RR` are the
    real-time ones. Actually, Linux defines `SCHED_NORMAL`, `SCHED_BATCH`, and `SCHED_IDLE` as
    other real-time policies. These are defined in the `sched.h` header file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* calls `sched_getscheduler()` to check the current policy of the process.
    As expected, the default is `SCHED_OTHER`. We passed the input to the `getpid()`
    function (`<unistd.h>`), which returns the PID of the current process. `sched_getscheduler()`
    also accepts `0`, which in this case represents the current process.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* has the goal of setting a real-time policy and giving priority to
    the current process with the `sched_setscheduler()` function. We want this process
    to have a higher priority over the normal processes running on the machine. Think,
    for example, of a (soft) real-time application where the computation cannot be
    interrupted or if a software interrupt is received and its processing cannot be
    postponed. These Linux boxes usually run very few processes for a dedicated purpose.
    To achieve this, the policy to set is `SCHED_FIFO` and the priority we set is
    the middle value between the min and max that can be set on the current system.
    It is always suggested to check these values with the `sched_get_priority_max()`
    and `sched_get_priority_min()` functions in order to write portable code. One
    thing to highlight is that the `sched_setscheduler()` function internally sets
    the `rt_priority` field of `struct task_struct`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* checks that `SCHED_FIFO` has been correctly set by calling the `sched_getscheduler()`
    function, similar to what happened in *step 1*.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SCHED_FIFO` and `SCHED_RR` are the two policies that are defined by POSIX
    and implemented on Linux that allocate tasks on processors that are more suitable
    for real-time software. Let''s go over how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SCHED_FIFO`: When a task is returned by this policy, it continues to run until
    it blocks (for example, I/O requests), it yields the processor, or a higher priority
    task preempts it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCHED_RR`: This has the exact same logic as `SCHED_FIFO` but with one difference:
    the tasks that are scheduled with this policy have a timeslice assigned so that
    a task continues to run until the time slice expires or a higher task preempts
    it or yields the processor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that when `SCHED_OTHER` (or `SCHED_NORMAL`) implements a preemptive form
    of multitasking, `SCHED_FIFO` and `SCHED_RR` are cooperative (they are not preempted).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux main scheduler function loops over all the policies and for each
    one, it asks the next task to run. It does this with the `pick_next_task()` function,
    which is implemented by each policy. The main scheduler is defined in `kernel/sched.c`,
    which defines the `sched_class` struct. This states that each policy must be defined
    and implemented so that all the different policies are working properly. Let''s
    take a look at this at a graphical level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kernel/sched.c`: Defines `struct sched_class` and loops over the following
    policies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kernel/rt.c` (for `SCHED_FIFO` and `SCHED_RR`) sets `const struct sched_class
    rt_sched_class` with the specific real-time policy functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kernel/fair.c` (for `SCHED_NORMAL` or `SCHED_OTHER`) sets `const struct sched_class
    fair_sched_class` with the fair scheduler-specific functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way of looking at the Linux scheduler design is this: `kernel/sched.c`
    defines the interface and the specific policies beneath the interface. The interface
    is represented by the `struct sched_class` structure. The following is the interface
    implementation for `SCHED_OTHER`/`SCHED_NORMAL` (the CFS fair scheduler policy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The real-time priority range of the `SCHED_FIFO` and `SCHED_RR` policies is `[1,
    99]`, while the `SCHED_OTHER` priority (called `nice`) is `[-20, 10]`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning how to set a nice value* recipe to see how the real-time priority
    is related to the nice priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning how to yield the processor* recipe to learn how to yield a running
    real-time task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Kernel Development*, *Third Edition*, by Robert Love'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to get the timeslice value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux scheduler offers different policies for allocating processor time
    to tasks. The *Learning to set and get a scheduler policy* recipe shows what policies
    are available and how to change them. The `SCHED_RR` policy, that is, the round-robin
    policy, is the one that's used on real-time tasks (with `SCHED_FIFO`). The `SCHED_RR`
    policy assigns a timeslice to each process. This recipe will show you how to configure
    the timeslice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be writing a small program to get the round-robin timeslice
    by using the `sched_rr_get_interval()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a new shell, open a new file called `schedGetInterval.cpp`. We have to include
    `<sched.h>` for the scheduler capabilities, `<iostream.h>` to log to the standard
    output, and `<string.h>` to use the `strerror` function and translate the `errno`
    integer into a readable string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the round-robin interval, we have to set the scheduler policy for our
    process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can get the interval with the `sched_rr_get_interval()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how this works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a task gets the processor with the `SCHED_RR` policy, it has priority over
    the `SCHED_OTHER` and `SCHED_NORMAL` tasks and gets allocated a defined timeslice
    that continues to run until the timeslice expires. Higher priority tasks run until
    they explicitly yield the processor or block. An important factor for a system
    programmer is to know the timeslice for the `SCHED_RR` policy. This is quite important.
    If the time slice is too large, other processes might wait a long time before
    getting CPU time, while if it is too small, the system might spend a significant
    amount of time context switching.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* shows the includes that are needed for the rest of the program. `<iostream>` is
    for the standard output, `<sched.h>` is used to get access to the scheduler features,
    and `<string.h>` is used for the `strerror()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* is very important as it sets the `SCHED_RR` policy for the current
    process. As you may have noticed, we passed `0` as the first parameter. This is
    perfectly fine since the man page of the `sched_setscheduler()` function says, *If
    pid equals zero, the policy of the calling thread will be set*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* calls the `sched_rr_get_interval()` function. It accepts two parameters:
    the PID and `struct timespec`. The first is an input parameter, while the latter
    is an output parameter that contains the timeslice in the form of `{sec, nanoseconds}`.
    For the first parameter, we could have passed the `getpid()` function, which returns
    the PID of the current process. Then, we simply log the standard output to the
    timeslice that''s returned.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Where does the `SCHED_RR` timeslice come from? The Linux scheduler, as we already
    know, has different policies. All of them are implemented in different modules:
    `kernel/sched_fair.c` for `SCHED_NORMAL` or `SCHED_OTHER` and `kernel/rt.c` for
    `SCHED_RR` and `SCHED_FIFO`. By looking at `kernel/rt.c`, we can see that the `sched_rr_get_interval()`
    function returns the `sched_rr_timeslice()` variable, which is defined on top
    of the module. We can also see that if `sched_rr_timeslice()` is called for the
    `SCHED_FIFO` policy, it returns `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning how to yield the processor* recipe as an alternative to stopping
    the running task instead of waiting for the timeslice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning to set and get a scheduler policy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Kernel Development, Third Edition*, by Robert Love'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to set a nice value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SCHED_OTHER`/`SCHED_NORMAL` policy implements the so-called completely
    fair scheduler (`CFS`). This recipe will show you how to set the nice value for
    normal processes in order to increase their priority. We'll see that the nice
    value is used to weigh the timeslice that a process has. Priority must not be
    confused with the real-time priority, which is specific to the `SCHED_FIFO` and
    `SCHED_RR` policies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll implement a program that will increase the nice value
    of a process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a shell, open a new source file called `schedNice.cpp`. We need to add some
    includes and call the `nice()` system call by passing the value we want to set
    for the current process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll see how this program works and how the `nice` value
    is used to influence the time a task gets on a processor.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Step 1* basically calls the `nice()` system call, which increments the static
    priority of the task by the given amount. Just to be clear, assuming a process
    starts with a priority of `0` (which is the default value for the `SCHED_OTHER`
    and `SCHED_NORMAL` policies), two consecutive calls of `nice(5)` will set its
    static priority to `10`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build and run the `schedNice.cpp` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72ada2c0-3f65-42c4-9324-8ae514069606.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that, on the left, we have our process running and on the right,
    we've run the `ps -el` command to get the nice values of the running processes.
    We can see that the `./a.out` process now has a `nice` value of `5`. To give a
    task a higher priority (and then a lower value of `nice`), the process needs to
    run as root.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `struct task_struct` structure has three values to represent a task priority:
    `rt_prio`, `static_prio`, and `prio`. We discussed `rt_prio` in the *Learning
    to set and get a scheduler policy* recipe and defined that this field represents
    the priority for real-time tasks. `static_prio` is the `struct task_struct` field
    that''s used to store the `nice` value, while `prio` contains the actual task
    priority. The lower `static_prio` is, the higher the `prio` value of the task.'
  prefs: []
  type: TYPE_NORMAL
- en: There may be cases where we need to set the `nice` value of a process at runtime.
    The command we should use in this situation is `renice value -p pid`; for example, `renice
    10 -p 186`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning how to yield the processor* recipe as an alternative to stopping
    the running task instead of waiting for the timeslice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning to set and get a scheduler policy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to yield the processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a task is scheduled with one of the real-time scheduling policies (that
    is, `SCHED_RR` or `SCHED_FIFO`), you may need to yield the task from the processor (yielding
    the task means to relinquish the CPU, making it available to other tasks). As
    we described in the *Learning to set and get a scheduler policy* recipe, when
    a task is scheduled with the `SCHED_FIFO` policy, it does not leave the processor
    until a certain event occurs; that is, there is no concept of a timeslice. This
    recipe will show you how to yield a process with the `sched_yield()` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll develop a program that will yield the current process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a shell, open a new source file called `schedYield.cpp` and type in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll describe how our program and `sched_yield()` work.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When `sched_yield()` is called on a task scheduled with `SCHED_FIFO` or `SCHED_RR`,
    it is moved to the end of a queue with the same priority and another task is run.
    Yields cause a context switch, so it should be used carefully and when strictly
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* defines the program that shows us how to use `sched_yield()`. We simulated
    a CPU-bound type of process where we check periodically in order to yield the
    processor. Before doing that, we had to set the policy type for this process to
    `SCHED_RR` and the priority to `8`. As you can see, there is no information about
    the process (PID) to yield, so it assumes that the current task will be yielded.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sched_yield()` is a system call that can be used by userspace applications.
    Linux usually calls the `yield()` system call, which has the advantage of keeping
    the process in a `RUNNABLE` state.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning to set and get a scheduler policy* recipe to review how to change
    a policy's type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Kernel Development,* *Third Edition*, by Robert Love'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about processor affinity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a multi-processor environment, the scheduler has to deal with task allocation
    on multiple processors or cores. From a Linux perspective, processes and threads
    are the same thing; both are represented by the `struct task_struct` kernel structure.
    There may be the need to force two or more tasks (that is, threads or processes)
    to run on the same processor to leverage, for example, the cache by avoiding the
    cache invalidation. This recipe will teach you how to set a *hard affinity* on
    a task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll develop a small piece of software in which we''ll force
    it to run on a CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a shell, open a new source file called `schedAffinity.cpp`. What we want
    is to check the affinity mask for the newly created process. Then, we need to
    prepare the `cpu_set_t` mask to set the affinity on the CPU to `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to call the `sched_setaffinity()` method and force the hard
    affinity for the current task on CPU number `3`. To check whether the affinity
    has been set correctly, we''ll also print the mask:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to develop the `current_affinity()` method, which will just print
    the mask for the processors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What would happen if we set the affinity on a nonexistent CPU (for example, `cpu_id
    = 12`)? Where in the kernel is the affinity mask information stored? We'll answer
    these and other questions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Step 1* does two things. First, it prints the default affinity mask. We can
    see that the process is scheduled to run on all the processors. Second, it prepares `cpu_set_t`,
    which represents a set of CPUs, by initializing it with the `CPU_ZERO` macro and
    setting the affinity on CPU `3` with the `CPU_SET` macro. Note that the `cpu_set_t` object
    must be manipulated directly but only via the macro provided. A full list of macros
    is documented on the man page: `man cpu_set`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* calls the `sched_setaffinity()` system call to set the affinity (specified
    in the `mask` variable, that is, `cpu_set_t`) on the process with the PID returned
    by the `getpid()` function. We could have passed `0` instead of `getpid()`, meaning
    the current process. After the `setaffinity` function, we printed the CPU''s mask
    to verify the correct new value.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* contains the definition of the helper function we used to print the
    standard output onto the mask for the CPUs. Note that we get the number of available
    processors through the `sysconf()` system call and by passing `_SC_NPROCESSORS_ONLN`.
    This function checks the system information that''s present in the `/sys/` folder.
    Then, we loop over each processor and call the `CPU_ISSET` macro while passing
    `i-th`. The `CPU_ISSET` macro will set the respective bit for the `i-th` CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to modify `int cpu_id = 3` and pass a different processor, that is,
    a nonexisting one (for example, `15`), the `sched_setaffinity()` function will
    obviously fail, returning `EINVAL` and leaving the affinity mask untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the program now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d5e58de-a8e5-4864-95ee-0d348ada14af.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the CPUs mask is set to 1 for each processor. This means that
    the process, at this stage, can be scheduled on each CPU. Now, we set the mask,
    asking the scheduler to run the process (**hard affinity**) only on CPU `3`. When
    we call `sched_getaffinity()`, the mask reflects this.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we call the `sched_setaffinity()` system call, we ask the scheduler to
    run a task on a specific processor. We call this hard affinity. There is also
    a soft affinity. This is automatically managed by the scheduler. Linux always
    tries to optimize resources and avoids cache invalidation in order to speed up
    the performance of the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: When we set the affinity mask through the macro, we are basically setting `cpus_allowed` in
    the `task_struct` structure. This makes a lot of sense since we're setting the
    affinity of a process or thread on one or more CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to set the affinity of a task to more than one CPU, the `CPU_SET`
    macro must be called for the CPUs you want to set.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning how to yield the processor* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning to get the timeslice value* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning to set and get a scheduler policy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
