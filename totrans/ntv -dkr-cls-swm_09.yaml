- en: Chapter 9. Securing a Swarm Cluster and the Docker Software Supply Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is all about Swarm cluster security. In particular, we''ll take
    a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Software supply chain with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations on how to secure a Swarm cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Docker Notary to secure the Software supply chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software Supply Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Software Supply Chain](images/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Docker orchestration is only a component of the larger software supply chain.
    We basically start with *Source Code* as the raw material*.* Our source code is
    compiled and linked with *Library and Dependent packages*. We use *Build Service*
    to continuously integrate our Source Code and its Dependencies together and finally
    assemble them as a *Product*. We then ship the Product on the Internet, to store
    it somewhere else. We usually call this warehouse an *Application Repository*
    or simply a *repository*. Finally, we send the product to the customer's environment,
    for example a cloud or a physical data center.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is perfect for this workflow. Developers use Docker locally to compile
    and test applications, system administrators deploy these applications on the
    Build Servers using Docker, and Docker may also play an important role in the
    process of continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: Security kicks in here. We need a secure way to sign our products before pushing
    it to the Application Repository. In our Docker-centric world, we store ready
    products in a warehouse called *Docker Registry*. Then a signed product will be
    verified, each time, before it is deployed to the production system where we're
    running our Docker Swarm mode cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the remainder of the chapter, we will talk about the following two aspects
    of security:'
  prefs: []
  type: TYPE_NORMAL
- en: How to secure a production Swarm cluster, which we achieve with best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to secure the software supply chain, which we achieve with Docker Notary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Swarm cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall the picture of a secured Swarm cluster from [Chapter 4](ch04.html "Chapter 4. Creating
    a Production-Grade Swarm"), *Creating a Production-Grade Swarm*; we'll explain
    the security aspects found in a Docker Swarm model cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing Swarm cluster](images/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have the Orchestrator as one of the main parts of a Docker Swarm manager.
    Diogo Monica, a member of the Docker Security team, mentioned in his Orchestration
    Least Privileged presentation, in Berlin 2016, that each component in the orchestration
    must have a limitation of what it can do.
  prefs: []
  type: TYPE_NORMAL
- en: '**Node management**: A cluster operator may instruct an Orchestrator to perform
    actions for a set of nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task assignment**: The Orchestrator is also responsible for assigning tasks
    to each node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster state reconciliation**: The Orchestrator maintains the state of the
    cluster by reconciling each state to the desired state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource management**: The Orchestrator offers and revokes resources for
    submitted tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Orchestrator with the least privilege will make the system secure and a least
    privilege Orchestrator is defined based on these functionalities. Following the
    principle of least privilege, a manager as well as the workers must be able to
    access *only the information and resource that are necessary to perform a given
    task*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Diogo presented the following list of five different attacking models
    that can be applied to Docker. They are listed from the lowest to the highest
    risk.
  prefs: []
  type: TYPE_NORMAL
- en: '**External attacker**: Outside of the firewall trying to compromise the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal attacker**: Doesn''t own the switch but has access to the switch.
    It can send packets to communicate with nodes in the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Man-in-the-middle**: An attacker who can listen to everything going in the
    network and can conduct an active attack. With this model, there is a Swarm cluster
    and the communications of worker nodes to the manager nodes are intercepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malicious worker node**: The resources owned by the worker are effectively
    owned by the attacker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malicious manager node**: The manager is an attacker who can control the
    complete Orchestrator and gain access to all available resources. It is the worst
    case scenario. If we could implement the least privileges, the malicious manager
    node can only attack the workers associated to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Securing a Swarm: Best practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now summarize the checklist for securing a Swarm cluster. The Swarm
    team is working hard to achieve the goals of preventing attacks on the full stack,
    but the following rules apply in any case.
  prefs: []
  type: TYPE_NORMAL
- en: Certification Authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first important step to guarantee security is deciding on how to use CA.
    When you form a cluster with the first node, it will automatically create a self-signed
    CA for the whole cluster. After spinning up, it creates CA, signs the certificate
    itself, adds the certificate for the manager, which is itself, and becomes the
    ready-to-operate 1-node cluster. When a new node joins, it gets the certificate
    by providing the correct token. Every node has its own identity which is cryptographically
    signed. Also, the system has a certificate for each rule, worker, or manager.
    The role is inside the identity information to tell who a node is. In the case
    that a manager leaks the root CA, the whole cluster is compromised. Docker Swarm
    mode supports external CAs to maintain the manager's identity. The manager can
    simply forward the CSR to the external CA so it does not need to maintain its
    own CA. Please note that the only protocol supported at this moment is`cfssl`.
    The following command is to init the cluster with the external CA.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Certificates and Mutual TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every single endpoint communication on the network control plane must have a
    mutual TLS and is encrypted and authorized by default. This means that a worker
    cannot fake to be a manager and no external attacker can connect to an endpoint
    and successfully complete the TLS handshake because the attacker does not have
    the keys to mutually authenticate itself. This means that each node must provide
    a valid CA-signed certificate, which has the OU field that matches each rule of
    the cluster. If a worker connects to the manager endpoint, it will be denied access.
  prefs: []
  type: TYPE_NORMAL
- en: The Certificate rotation is done automatically by Swarm. You can have the certificate
    rotation as short as one hour in SwarmKit and also Docker Swarm mode. The following
    is the command to adjust the certificate expiry time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The join token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each token, used by nodes to join the cluster, has the following four components:'
  prefs: []
  type: TYPE_NORMAL
- en: SWMTKN, the Swarm prefix that allows finding, or grepping, when tokens are leaked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The token version, which is currently 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cryptographically hashed value of the CA root certificate to allow bootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A randomly generated Secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of token:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SWMTKN-1-11lo1xx5bau6nmv5jox26rc5mr7l1mj5wi7b84w27v774frtko-e82x3ti068m9eec9w7q2zp9fe`'
  prefs: []
  type: TYPE_NORMAL
- en: To access the cluster, it is necessary to send a token as proof. It is like
    the cluster password.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that in case of token compromising, the token can be *simply
    rotate*d using one of the following commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Add TLS with Docker Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another good practice is provisioning all manager nodes with Docker Machine
    to set up an extra layer of TLS, automatically, so that each manager can be accessed
    by remote Docker clients in a secure manner. This can simply be done using the
    following command, similar to how we did in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Form a cluster on a private network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If forming a hybrid cluster is not a requirement, one of the best practices
    is that we should form a cluster with all the nodes being on a local private network.
    With this, the data of overlay network will not need to be encrypted and the performance
    of cluster will be fast.
  prefs: []
  type: TYPE_NORMAL
- en: When forming this kind of cluster, the Routing Mesh allows us to expose any
    worker, not necessarily a manager, to the public-network interface. The following
    figure shows the cluster configuration. You can see that with this configuration
    and a Docker service published port 80 on the Ingress network. The routing mesh
    forms a star-like mesh but we simplified it and showed only one-side from the
    Big W node connecting IPVS load-balancing to others. The Big W node has two network
    interfaces. Its public interface allows the node to act as a front-end node of
    the whole cluster. With this architecture, we can achieve a certain level of security
    by not exposing any manager node to the public network.
  prefs: []
  type: TYPE_NORMAL
- en: '![Form a cluster on a private network](images/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Docker Notary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker Content Trust mechanism is implemented using Docker Notary ([https://github.com/docker/notary](https://github.com/docker/notary)),
    which is on The Update Framework ([https://github.com/theupdateframework/tuf](https://github.com/theupdateframework/tuf)).
    TUF is a secure framework that allows us to delivery a collection of trusted content
    at a time. Notary allows a client and a server to form a trusted *collection*
    by making it easier to publish and verify contents. If we have a Docker image,
    we can sign it offline using a highly secure offline key. Then when we publish
    that image, we can push it to a Notary server that can be used to delivery trusted
    images. Notary is the way to enable *Secured Software Supply Chain* for the enterprise
    using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrate how to set up our own Notary server and use it to sign Docker
    image content before pushing to a Docker registry. The prerequisite is to have
    a recent version of Docker Compose installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to clone Notary (in this example we fix its version at 0.4.2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Open `docker-compose.yml` and add the image option to specify an image name
    and tag for both signer and server. In this example, I used Docker Hub to store
    the build images. So it's `chanwit/server:v042` and c`hanwit/signer:v042`. Change
    this to reflect your local configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Notary](images/image_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then start with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We now have a Notary server up and running at [https://127.0.0.1:4443](https://127.0.0.1:4443).
    To make it possible for the Docker client to do a handshake with Notary, we need
    to copy the Notary Server certificate as CA of this trusted address (`127.0.0.4443`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After that, we enable Docker Content Trust and point Docker Content Trust server
    to our own Notary at `https://127.0.0.1:4443`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we tag the image as a new one and push the image while enabling Docker
    Content Trust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the setup finishes correctly, we'll see the Docker client asking for the
    new root key and the new repository key. Then it will confirm that `chanwit/busybox:signed`
    was successfully signed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try pulling the same image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we pull an unsigned image, and this time it will show that there is no
    trusted data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Introducing Docker secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker 1.13 includes in Swarm the new concept of secrets management.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, we need Swarm mode to use secrets. When we initialize a Swarm,
    Swarm generates some secrets for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Docker 1.13 adds the secrets management with a new command, secret, with the
    purpose to handle them efficiently. Secret subcommands are created, ls, to inspect
    and rm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first secret. The `secret create` sub-command takes a secret
    from the standard input. So, we need to type in our secret, and then press *Ctrl*+*D*
    to save the content. Be careful to not hit the *Enter* key. We need only `1234` not
    `1234\n` as our password, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then press *Ctrl*+*D* twice to close the standard input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check if there is a secret called password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? The content of secret can be bound to a service by passing
    the secret option when we create a new service. The secret will be a file in the
    `/run/secrets/` directory. In our case, we'll have `/run/secrets/password` containing
    the string `1234`.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets are designed to replace the abuse of environment variables. For example,
    in the case of a MySQL or MariaDB container, its root password should be set as
    a secret instead of passing it as a plaintext via an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will show a small hack to make MariaDB support the new Swarm secrets, starting
    from the following `entrypoint.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We put this line into this script, around line 56, before the check of `MYSQL_ROOT_PASSWORD`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code checks if there exists `/run/secrets/mysql-root-password`. If so,
    it assigns the secret to the environment variable `MYSQL_ROOT_PASSWORD`.
  prefs: []
  type: TYPE_NORMAL
- en: After this we can prepare a Dockerfile to override the MariaDB's default `docker-entrypoint.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We then build the new image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Recalled that we have a secret named password, we have an image which allows
    us to set the root password from the secret file `/run/secrets/mysql-root-password`.
    So, the image expects a different file name under `/run/secrets`. With this we
    can use the secret with full option (`source=password`, `target=mysql-root-password`)
    to make a Swarm service work. For example, we can now start a new `mysql` Swarm
    service from this MariaDB image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To see if our secret works, we can start an instance of PHPMyAdmin on the same
    overlay network. Don't forget to link these services together by passing `-e PMA_HOST=mysql`
    to the `myadmin` service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then you can open your browser to `http://127.0.0.1:8080` and log in to `PHPMyAdmin`
    as root with `1234` as the password, which we provided through a Docker secret.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about securing Swarm Mode and the Docker Software
    Supply Chain. We talked about some best practices on how to secure a Docker Swarm
    cluster to use in production. We then proceeded to Notary, a secure delivery mechanism
    to allow Docker Content Trust. This chapter ended with an overview of a new feature
    in Docker 1.13: the Secrets management. We showed how we could use Docker Secret
    to securely deploy MySQL MariaDB server without passing the root password via
    the environment. In the next chapter, we''re going to discover how to deploy Swarm
    on some of the public cloud providers and on OpenStack.'
  prefs: []
  type: TYPE_NORMAL
