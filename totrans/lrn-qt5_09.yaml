- en: Wrapping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will mop up a couple of subjects that didn''t quite make
    it into the earlier chapters. We’ll make our application more testable by moving
    object creation into an object factory. We’ll make our UI even more dynamic by
    adding scaling capabilities. `EnumeratorDecorator` properties get their own UI
    components, and we’ll put them to use when we add contact management. Finally,
    we’ll wrap everything up by packaging and deploying our application. We will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Object factories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic UI scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an image to the Dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerator selectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment and installation of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a larger system with more comprehensive `MasterController` tests in place,
    having all of that object creation hard-coded inside the private implementation
    will cause problems because of the tight coupling between the `MasterController`
    and its dependencies. One option will be to create all the other objects in `main()`
    instead and inject them into the `MasterController` constructor as we have done
    with the other controllers. This will mean injecting a lot of constructor parameters,
    and it is handy to be able to keep the `MasterController` instance as the parent
    of all the other objects, so we will inject a single object factory that the controller
    can use for all of its object creation needs instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The critical part of this factory pattern is to hide everything behind interfaces,
    so when testing `MasterController`, you can pass in a mock factory and control
    all the object creation. In `cm-lib`, create a new `i-object-factory.h` header
    file in `source/framework`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All the objects we will create will be moved behind interfaces apart from the
    models. This is because they are essentially just data containers, and we can
    easily create real instances in a test scenario with no side effects.
  prefs: []
  type: TYPE_NORMAL
- en: We will skip that exercise here for brevity and leave it as an exercise for
    the reader. Use `IDatabaseController` as an example or refer to the code samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the factory interface available, change the `MasterController` constructor
    to take an instance as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the object through to `Implementation` and store it in a private member
    variable as we have done numerous times before. With the factory available, we
    can now move all the `new` based object creation statements into a concrete implementation
    of the `IObjectFactory` interface (the `ObjectFactory` class) and replace those
    statements in `MasterController` with something more abstract and testable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when testing `MasterController`, we can pass in a mock implementation
    of the `IObjectFactory` interface and control the creation of objects. In addition
    to implementing `ObjectFactory` and passing it to `MasterController` when we instantiate
    it, one further change is that in `main.cpp`, we now need to register the interfaces
    to `NavigationController` and `CommandController`, rather than the concrete implementations. 
    We do this by simply swapping out the `qmlRegisterType` statements with the `qmlRegisterUncreatableType`
    companion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: UI scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve focused a lot on responsive UI in this book, using anchors and relative
    positioning where possible so that when the user resizes the window, the contents
    scale and adjust themselves appropriately. We’ve also pulled all the “hard-coded”
    properties like sizes and colors into a centralized Style object.
  prefs: []
  type: TYPE_NORMAL
- en: If we pick a property concerned with sizing, for example, `sizeScreenMargin`,
    it currently has a fixed value of `20`. If we decide to increase the starting
    size of our **Window** element in `MasterView`, this screen margin size will remain
    the same. Now, it’s really easy to increase the screen margin too, thanks to the
    Style object, but it would be nice if all the hard-coded properties could scale
    up and down dynamically along with our **Window** element. That way, we can try
    out different window sizes without having to update Style each time.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve already seen, the flexibility of QML is extended even further with
    the built-in JavaScript support, and we can do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create new width and height properties for the window in Style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use these new properties in `MasterView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All the size properties in Style that we’ve created so far are relevant to
    this window size of 1920 x 1080, so let’s record that as new properties in Style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the reference sizes and the actual sizes to calculate scaling
    factors in the horizontal and vertical axes. So in simple terms, if we design
    everything with a window width of 1,000 in mind and then we set the window to
    be 2,000 wide, we want everything to scale horizontally by a factor of 2\. Add
    the following functions to Style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `hscale` and `vscale` functions calculate the horizontal and vertical scaling
    factors respectively. For certain size properties like pixel size for fonts, there
    is no independent width and height, so we can calculate an average of the horizontal
    and vertical scales using the `tscale` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then wrap any properties we want to scale in the appropriate function.
    For example, our screen margin can use the `tscale` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, not only can you increase the initial size of the window in Style, but
    your selected properties will automatically scale to the new size.
  prefs: []
  type: TYPE_NORMAL
- en: A really useful module you can add to help with sizing is `QtQuick.Window`.
    We already added this to `MasterView` in order to access the Window element. There
    is another object in that module, Screen, which makes available information regarding
    the user’s display. It contains properties for things like the width and height
    of the screen, and orientation and pixel density, which can be useful if you’re
    working with high DPI displays such as the Microsoft Surface or Macbook. You can
    use these values in conjunction with your Style properties to do things such as
    making your window fullscreen, or make it 50% of the screen size and positioning
    it in the center of the display.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Dashboard or “home page” is a great place to welcome users and present the
    current state of play. Daily messages, facts and figures, performance charts,
    or simply some company branding can all help orient and focus the user. Let’s
    jazz up our Dashboard view a little and demonstrate how to display images to boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grab an image of your choice that has a 1:1 aspect ratio, which means that
    the width is the same as the height. It’s not necessary to be square, it’s just
    simpler to manage the scaling for the purposes of this example. I have picked
    the **Packt** logo, which is 500 x 500 pixels, and which I have saved as `packt-logo-500x500.jpg`.
    Save it to `cm/cm-ui/assets` and add it to our `assets.qrc` resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some new Style properties, leveraging our new scaling capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add our image to `DashboardView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we go to the Dashboard, we can see something a bit more stimulating:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4badcae8-575c-4c7b-b610-e366d5579693.png)'
  prefs: []
  type: TYPE_IMG
- en: Enumerator selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml), *Data*, we
    created a Contact model where we implemented a `ContactType` property with an
    `EnumeratorDecorator`. For the other string-based properties we’ve worked with
    in the book, a simple textbox is a fine solution for capturing data, but how can
    we capture an enumerated value? The user can’t be expected to know the underlying
    integer values of the enumerator, and asking them to type in a string representation
    of the option they want is asking for trouble. What we really want is a drop-down
    list that somehow utilizes the `contactTypeMapper` container we added to the class.
    We’d like to present the string descriptions to the user to pick from but then
    store the integer value in the `EnumeratorDecorator` object.
  prefs: []
  type: TYPE_NORMAL
- en: Desktop applications generally present drop-down lists in a particular way,
    with some kind of selector you press that then pops out (or more accurately, drops
    down!) a scrollable list of options to choose from. However, QML is geared toward
    not only cross-platform, but cross-device applications, too. Many laptops have
    touch capable screens, and more and more hybrid devices are appearing in the market
    that act as both laptops and tablets. As such, it’s important to consider how
    “finger friendly” our application is, even if we’re not planning on building the
    next big thing for the mobile stores, and the classic drop-down list can be difficult
    to work with on a touch screen. Let’s instead use a button-based approach as used
    on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we can’t really work directly with our existing `std::map` in
    QML, so we will need to add a few new classes to bridge the gap for us. We’ll
    represent each key/value pair as a `DropDownValue` and hold a collection of these
    objects in a `DropDown` object. A `DropDown` object should take a `std::map<int,
    QString>` in its constructor and create the `DropDownValue` collection for us.
  prefs: []
  type: TYPE_NORMAL
- en: Create the `DropDownValue` class first in `cm-lib/source/data`.
  prefs: []
  type: TYPE_NORMAL
- en: '`dropdown-value.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`dropdown-value.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing complicated here, it’s just a QML friendly wrapper for an integer
    value and associated string description.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create the `DropDown` class, again in `cm-lib/source/data`.
  prefs: []
  type: TYPE_NORMAL
- en: '`dropdown.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`dropdown.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As discussed, we implement a constructor that takes the same kind of `std::map`
    that we use in our `EnumeratorDecorator` class and create a collection of `DropDownValue`
    objects based on it. The UI can then access that collection via the `ui_values`
    property. The other capability we provide for the UI is via the `findDescriptionForDropdownValue`
    public slot, and this allows the UI to take a selected integer value from an `EnumeratorDecorator`
    and get the corresponding text description. If there is no current selection (that
    is, the description is an empty string), then we will return `Select >` to denote
    to the user that they need to make a selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will use these new types in QML, we need to register them in `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add a new `DropDown` property to the Contact named `ui_contactTypeDropDown` and
    in the constructor, instantiate the member variable with the `contactTypeMapper`.
    Now, whenever a Contact is presented in the UI, the associated `DropDown` will
    be available. This can quite easily go into a dedicated component like a drop-down
    manager instead, if you wanted to reuse drop-downs throughout the application,
    but for this example, let’s avoid the additional complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to be able to add a new contact object from the UI, so add
    a new public slot to `Client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the C++ done, we can move on to the UI implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We will need a couple of components for the dropdown selection. When presenting
    an `EnumeratorDecorator` property, we want to display the currently selected value,
    just as we do with our string editor. Visually, it will resemble a button with
    the associated string description as its label and when pressed, the user will
    be transitioned to the second component that is essentially a view. This subview
    will take up the whole of the content frame and present a list of all the available
    enumerated options, again represented as buttons. When the user makes their selection
    by pressing one of the buttons, they will be transitioned back to the original
    view, and their selection will be updated in the original component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create the view the user will transition to, which will list all
    the available options. To support this, we need a few additional properties in
    Style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `EnumeratorSelectorView.qml` in `cm-ui/components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use a **Repeater** element for the first time. A Repeater instantiates
    the QML element defined in its delegate property for each item it finds in its
    model property. We pass it the collection of `DropDownValue` objects as its model
    and create a delegate inline. The delegate is essentially another button with
    some selection code. We can create a new custom component and use that for the
    delegate instead to keep the code cleaner, but we’ll skip that here for brevity.
    The key parts of this component are the `Binding` element that gives us the two-way
    binding to the supplied `EnumeratorDecorator`, and the `onClicked` event delegate
    in the `MouseArea`, which performs the update and pops this component off the
    stack, returning us to whichever view we came from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `EnumeratorSelector.qml` in `cm-ui/components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This component has a lot of similarities to `StringEditorSingleLine` in its
    layout, but it replaces the Text element with a button representation. We grab
    the value from the bound `EnumeratorDecorator` and pass that to the slot we created
    on the `DropDown` class to get the string description for the currently selected
    value. When the user presses the button, the `onClicked` event of the `MouseArea`
    performs the same kind of view transition we’ve seen in `MasterView`, taking the
    user to the new `EnumeratorSelectorView`.
  prefs: []
  type: TYPE_NORMAL
- en: We’re cheating a bit here in that we are directly referencing the `StackView`
    in `MasterView` by its `contentFrame` ID. At design time, Qt Creator can’t know
    what `contentFrame` is as it is in a totally different file, so it may flag it
    as an error, and you certainly won’t get auto-completion. At runtime, however,
    this component will be part of the same QML hierarchy as `MasterView`, so it will
    be able to find it. This is a risky approach, because if another element in the
    hierarchy is also called `contentFrame`, then bad things may happen. A safer way
    to do this is to pass `contentFrame` all the way down through the QML hierarchy
    from `MasterView` as a `QtObject` property.
  prefs: []
  type: TYPE_NORMAL
- en: When we add or edit a Client, we currently ignore contacts and always have an
    empty collection. Let’s take a look at how we can add objects to a collection
    and put our shiny new `EnumeratorSelector` to use while we’re at it.
  prefs: []
  type: TYPE_NORMAL
- en: Contacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need a handful of new UI components to manage our contacts. We’ve previously
    worked with an `AddressEditor` to look after our address details, so we’ll continue
    in that mold and create a `ContactEditor` component. This component will display
    our collection of contacts, each of which will be represented by a `ContactDelegate`.
    Upon initially creating a new Client object, there won’t be any contacts, so we
    also need some way for the user to add a new one. We’ll enable that with a button
    press, and we’ll create a new component for buttons we can add to a content view.
    Let’s do that first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this new component, as usual, we’ll go ahead and add some properties
    to Style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `FormButton.qml` in `cm-ui/components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we combine aspects of the `NavigationButton` and `CommandButton` controls
    we wrote earlier in the book. The only real difference is that it is intended
    for more free-form use in the main content frame rather than being constrained
    to one of the toolbars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s add the component we’ll use to display/edit a single Contact object.
    Create `ContactDelegate.qml` in `cm-ui/components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is much the same as the `RssItemDelegate` we added in [Chapter 8](d04b2aa4-cbbe-4826-b27f-5f00ea4cfb07.xhtml),
    *Web Requests*. We add our new `EnumeratorSelector` and bind it to the `ui_contactType`
    property, using `ui_contactTypeDropDown` to provide the control with the drop-down
    information it needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `ContactsEditor.qml` in `cm-ui/components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We’ve already done all the hard work in our `ContactDelegate` and `FormButton`
    controls, so this is really short and sweet. We add everything to a `Panel` so
    that the look and feel will be consistent with the rest of the views. We use another
    `Repeater` so that we can spin up a `ContactDelegate` for every contact in the
    collection and immediately after the contacts, we display a button to add a new
    contact to the list. In order to do this, we call the `addContact()` method we
    added earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to add instances of our `ContactsEditor` to the `CreateClientView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the same component in `EditClientView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it. Build and Run, and you can add and edit contacts to your heart’s
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1b86286-e84d-43b7-9f18-ba51c1a8023a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you save a new client, if you take a look at the database, you will see
    that the contacts array has been updated accordingly, as highlighted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf2f77a9-4754-4ab2-9509-63d059de3288.png)'
  prefs: []
  type: TYPE_IMG
- en: All that’s left now is the appointments collection, and we’ve already covered
    all the skills you need to tackle that, so we’ll leave that as an exercise for
    the reader and move on to the final topic—deploying our application to our end
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The center piece of our application is the `cm-ui` executable. This is the file
    that gets launched by the end user and that opens graphical windows and orchestrates
    all the fancy stuff we’ve written. When we run the `cm-ui` project in Qt Creator,
    it opens the executable file for us and everything works perfectly. However, distributing
    our application to another user is unfortunately more complicated than simply
    plonking a copy of the executable on their machine and launching it.
  prefs: []
  type: TYPE_NORMAL
- en: Our executable has a variety of dependencies that need to be in place in order
    for it to run. A prime example of a dependency is our very own `cm-lib` library.
    Pretty much all of our business logic is hidden away in there, and without that
    functionality, our UI can’t do much. The implementation details for dependency
    resolution across the various operating systems are complex and well beyond the
    scope of this book. However, the fundamental requirements of our application are
    the same, irrespective of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four categories of dependency that we need to consider and ensure
    that they are in place on our target user’s machine in order for our application
    to function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Item 1: Custom libraries we’ve written or added to our solution manually. In
    this case, it is only the `cm-lib` library that we need to worry about.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 2: The parts of the Qt framework that our application links to, both directly
    and indirectly. We already know some of these through the modules we’ve added
    to our `.pro` files, for example, the `qml` and quick modules require the `QtQml`
    and `QtQuick` components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 3: Any internal dependencies of the Qt framework itself. This includes
    platform-specific files, resources for the QML subsystem, and third-party libraries
    such as `sqlite` or `openssl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 4: Any libraries required by the C++ compiler we have built the application
    with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve already worked extensively with item 1, back in [Chapter 2](ed8edd43-9e54-4b4c-907e-349764f26c55.xhtml),
    *Project Structure*, we put a lot of work into controlling exactly where that
    output goes. We haven’t really needed to worry about items 2 and 3, because we
    have a full installation of the Qt Framework in our development machine and that
    takes care of everything for us. Similarly, item 4 is dictated by the kit we use,
    and if we have a compiler available on our machine, it follows that we have the
    libraries it needs too.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying exactly what we need to copy for our end users (who more than likely
    don’t have Qt or other development tools installed) can be an excruciating exercise.
    Even once we’ve done that, packaging everything up into a neat package or installer
    that is simple for the user to run can be a project in itself. Fortunately, Qt
    offers us some help in the form of bundled tools.
  prefs: []
  type: TYPE_NORMAL
- en: Linux and macOS X have a concept of application packages, whereby the application
    executable and all dependencies can be rolled up together into a single file that
    can then be easily distributed and launched at the click of a button. Windows
    is a bit more freestyle and if we want to bundle all of our files into a single
    installable file, we need to do a bit more work, but again, Qt comes to the rescue
    and comes with the fantastic Qt Installer Framework that simplifies it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at each operating system in turn and produce an application
    package or installer for each.
  prefs: []
  type: TYPE_NORMAL
- en: OS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, build the solution using the kit of your choice in the Release mode.
    You already know that if we press the Run button in Qt Creator, our app launches
    and all is well. However, navigate to the `cm-ui.app` file in Finder and try and
    launch it directly; with this, things aren’t quite so rosy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57963241-c098-441c-84b2-01a504c479a6.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem here is missing dependencies. We can use **otool** to take a look
    at what those dependencies are. First, copy the `cm-ui.app` package to a new directory—`cm/installer/osx`.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t strictly necessary, but I like to keep build and deployment files
    separate. This way, if we make a code change and rebuild the solution, we will
    only update the app in the binaries folder, and our deployment files remain untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Next, have a poke around inside the app package and see what we’re working with.
    In Finder, *Ctrl* and click on the `cm-ui.app` we just copied to the installer
    folder and select Show Package Contents. The bit we’re interested in is the `Contents/MacOS`
    folder. In there, you will find our `cm-ui` application executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that identified, open up a command terminal, navigate to `cm/installer/osx`,
    and run `otool` on the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output the same as (or similar to) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s remind ourselves of the dependencies we need to consider and look at
    how they relate to the output we’ve just seen:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom libraries we’ve written or added to our solution manually (`cm-lib`).
    This is the `libcm-lib.1.dylib` reference. The fact that there is no path component
    suggests that the tool isn’t quite sure where this file is located. Should it
    be in the same folder as the executable itself? Should it be in the standard `/usr/lib/`
    folder? Fortunately, we can specify the location of this file when we package
    our app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parts of the Qt framework that our application links to. `QtQuick`, `QtQml`,
    and such are all the framework modules we directly reference in our `cm-ui` code.
    Some of them are explicitly brought in via the QT variable in our `cm-ui.pro`
    file and others are implicitly included using things like QML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any internal dependencies of the Qt framework itself. We don’t see those listed
    earlier, but if we were to run otool against the `QtQuick` module, you would see
    that it is dependent on `QtQml`, `QtNetwork`, `QtGui`, and `QtCore`. There are
    also several system level libraries required, such as OpenGL, which we haven’t
    explicitly coded against but are used by Qt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any libraries required by the C++ compiler we have built the application with;
    `libc++.1.dylib` stands out here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To bundle all of our dependencies manually, we can copy them all inside the
    app package and then perform some reconfiguration steps to update the location
    metadata we saw from otool.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pick one of the framework dependencies—`QtQuick`—and quickly work through
    what we will have to do to achieve this, and then we’ll move on to the really
    handy tool that does all of this very unpleasant grunt work for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a `Frameworks` directory where the system will search
    for the bundled dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will physically copy the referenced file to that new directory. We
    know where to look for the existing file on our development machine, thanks to
    the preceding `LC_RPATH` entry, in this case `/Users/<Your Username>/Qt5.9.1/5.9.1/clang_64/lib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to change the shared library identification name for the copied
    library file using `install_name_tool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The syntax here is `install_name_tool -id [New name] [Shared library file]`.
    To get to the library file (not the framework package, which is what we copied),
    we drill down to `Versions/5/QtQuick`. We set the ID of that binary to where the
    executable will look to find it, which, in this case, is in the `Frameworks` folder
    a level up (`../`) from the executable file itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we also need to update the executable’s list of dependencies to look
    in the correct place for this new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The syntax here is `install_name_tool -change [old value] [new value] [executable
    file]`. We want to change the old `@rpath` entry for `QtQuick` to be the new Frameworks
    path we’ve just added. Again, we use the `@executable_path` variable so that the
    dependencies are always located in the same place relative to the executable.
    Now, the metadata in the executable and the shared library both match each other
    and relate to the `Frameworks` folder, which we have now added to our app package.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, that’s not all, because `QtQuick` itself has dependencies, so we will
    need to copy and reconfigure all of those files too and then check their dependencies.
    Once we’ve exhausted the whole dependency tree for our `cm-ui` executable, we
    also need to repeat the process for our `cm-lib` library. As you can imagine,
    this gets tedious very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `macdeployqt` Qt Mac Deployment Tool is just what we need here.
    It scans an executable file for Qt dependencies and copies them across to our
    app package for us as well as for handling the reconfiguration work. The tool
    is located in the `bin` folder of the installed kit you have built the application
    with, for example, `/Qt/5.9.1/5.9.1/clang_64/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a command terminal, execute `macdeployqt` as follows (assuming that you
    are in the `cm/installer/osx` directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Remember to replace the parameters in angle brackets with the full paths on
    your system (or add the executable paths to your system PATH variable).
  prefs: []
  type: TYPE_NORMAL
- en: The `qmldir` flag tells the tool where to scan for QML imports and is set to
    our UI project folder. The `libpath` flag is used to specify where our compiled
    `cm-lib` file lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this operation will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Qt is a bit quirky with the SQL module, whereby if you use one SQL driver, it
    will try and package them all; however, we know that we are only using SQLite
    and don’t need MySQL or PostgreSQL, so we can safely ignore those errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once executed, you should be able to Show Package Contents  again in Finder
    and see all the dependencies ready and waiting for deployment, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ded5936e-733d-4c71-8b31-9786ceda7e81.png)'
  prefs: []
  type: TYPE_IMG
- en: What a huge timesaver! It has created the appropriate file structure and copied
    all the Qt modules and plugins for us, along with our `cm-lib` shared library.
    Try and execute the `cm-ui.app` file now, and it should successfully launch the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux packaging and deployment is broadly similar to OS X, and we won’t cover
    it in the same level of detail, so at least skim the OS X section first if you
    haven’t already. As with all platforms, the first thing to do is build the solution
    using the kit of your choice in the **Release** mode in order to generate the
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building in Release mode for the first time, I received the “cannot find
    -lGL” error. This was because the `dev` libraries for OpenGL were not installed
    on my system. One way of obtaining these libraries is to install FreeGlut:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo apt-get update`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo apt-get install build-essential`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo apt-get install freeglut3-dev`'
  prefs: []
  type: TYPE_NORMAL
- en: Once compiled, copy the `cm-ui` binary to a new `cm/installer/linux` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can take a look at what dependencies our application has. In a command
    terminal, change to the `cm/installer/linux` folder and run `ldd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s some list of dependencies! Crucially, note the dependency on our `cm-lib`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the executable will look for our library in the `/usr/lib`
    folder, so let’s ensure that it’s available there before we move on by copying
    `libcm-lib.so.1` to `/usr/lib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can already guess what a nightmare managing all these dependencies manually
    will be, having discussed the OS X process and seen how many dependencies there
    are, so there must be a tool in our Kit’s `bin` folder that does it all for us,
    right? Well, yes and no. There is no official Qt tool we get out of the box to
    do this for us like there is for OS X and Windows. Fortunately, a fantastic member
    of the Qt community `probonopd` has come to the rescue and plugged the gap with
    `linuxdeployqt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a `linuxdeployqt` app image from the releases page of the GitHub
    project at [https://github.com/probonopd/linuxdeployqt](https://github.com/probonopd/linuxdeployqt).
    Download the file (`linuxdeployqt-continuous-x86_64.AppImage`) and then make it
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then execute it and have it work its dependency-based magic for us.
    Change the directory to `cm/installer/linux` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `qmldir` flag tells the tool where to scan for QML imports and is set to
    our UI project folder. The `appimage` flag is used to get the tool to create an
    application image file for us, which is a single file with everything bundled
    inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things may not work perfectly the first time. Your output may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two errors are just because we haven’t provided a desktop file or
    icon and defaults have been generated for us; we can ignore those. The rest are
    because `linuxdeployqt` doesn''t know where `qmake` is. We can either provide
    the path as an extra parameter (`-qmake=<PATH>`), or to save us having to do it
    every time, we can add it to our PATH environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then check whether qmake can be found by trying to retrieve the version
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is happy, you will see the version information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With that fixed, we can now try running the `linuxdeployqt` command again.
    However, we’ve fixed one problem, but now experience another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Ignore the first two errors again. Now it can''t find MySQL drivers, which
    is annoying, because we aren’t even MySQL and it is the same Qt SQL quirk we saw
    on OS X. As a workaround, let''s effectively "hide" the SQL drivers we don''t
    want from the tool by temporarily renaming them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `linuxdeployqt` command again. You will get lots of output this time,
    culminating in a success message, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is telling us that our app image has been named as `Application-x86_64.AppImage`,
    which it saves to the `Downloads` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look in file manager, and you will see that it has added various files
    and directories alongside our executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12883b0f-bef0-4b40-b640-55dda2680b47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It has also deposited the `Application-x86_64.AppImage` file in the `Downloads`
    folder that is a single self-contained executable package with all dependencies.
    However, if you head over to `Downloads` and try and launch the `AppImage`, you
    may get an error (execute it via a Terminal command to see the error message):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This appears to be an issue with `linuxdeployqt` missing some dependencies,
    but for some reason, running the tool a second time magically picks them up. Execute
    the `linuxdeployqt` command again, and hey presto, the `AppImage` now works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, build the solution using the kit of your choice in the **Release** mode.
    Once complete, copy the `cm-ui.exe` and `cm-lib.dll` application binaries to a
    new `cm/installer/windows/packages/com.packtpub.cm/data` directory. This strange
    directory structure will be explained in the next section—Qt Installer Framework—and
    we are simply saving ourselves some additional copying later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s remind ourselves of the dependencies we need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Item 1: Custom libraries we’ve written or added to our solution manually (`cm-lib`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 2: The parts of the Qt framework that our application links to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 3: Any internal dependencies of the Qt framework itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 4: Any libraries required by the C++ compiler we have built the application
    with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The good news is that item 1 is already done! Windows will look for the dependencies
    of an executable in the same folder that the executable is in. This is really
    helpful and by simply copying the DLL to the same folder as the executable, we’ve
    already taken care of that dependency. The Qt Installer framework takes all the
    files from a given folder and deploys them to the target machine in the same place
    relative to each other, so we know this will be preserved after deployment too.
  prefs: []
  type: TYPE_NORMAL
- en: The bad news is that the remaining steps are a bit of a nightmare to manage
    manually. We can have a decent first stab at what parts of Qt we need by reviewing
    the modules we’ve explicitly added to our `*.pro` files. This will be `qml`, `quick`, and
    `xml` from `cm-ui` and `sql`, and network and `xml` from `cm-lib` core is also
    included by default. In File Explorer, navigate to `<Qt Installation Folder>/5.9.1/<Kit>/bin`.
    In there, you can find all the binaries relating to these modules, for example,
    `Qt5Qml.dll` for the `qml` module.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the approach that we did for `cm-lib.dll` and simply manually copy
    each of the Qt DLL files across to the data folder too. This will fulfil item
    2 and while deeply tedious, it’s fairly straightforward. However, item 3 is a
    painful exercise that we really don’t want to do ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `windeployqt` Qt Windows Deployment Tool is just what we need
    here. It scans an `.exe` file for Qt dependencies and copies them across to our
    installer folder for us. The tool is located in the `bin` folder of the installed
    kit you have built the application with, for example, `/Qt/5.9.1/mingw32/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a command terminal, execute `windeployqt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Remember to replace the parameters in angle brackets with the full paths on
    your system (or add the executable paths to your system PATH variable).
  prefs: []
  type: TYPE_NORMAL
- en: The `qmldir` flag tells the tool where to scan for QML imports and is set to
    our UI project folder. After we tell the tool which `.exe` to scan for dependencies,
    the `compiler-runtime` flag denotes that we want the compiler runtime files too,
    so it even takes care of item 4 for us as a bonus!
  prefs: []
  type: TYPE_NORMAL
- en: By default, found dependencies will subsequently be copied to the same folder
    as the executable being scanned. This is a good reason to copy the compiled binaries
    to a dedicated installer folder first so that development project output and content
    for deployment remain separate.
  prefs: []
  type: TYPE_NORMAL
- en: Once executed, you should see a large block of output. Although it’s tempting
    to think “oh, that’s done stuff so everything must be ok”, it’s a good idea to
    scan through the output, even if you’re not sure what it’s doing as you can sometimes
    pick up obvious issues that you can can take action to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when first deploying a MinGW kit build, I encountered the given
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Although the command had executed successfully, and I can see a whole bunch
    of Qt dependencies in the installer folder, I was actually missing the GCC dependencies.
    It was a simple fix to follow the instructions and add `<Qt Installation path>/Tools/mingw530_32/bin`
    to the PATH variable in my system environment variables. After restarting the
    command terminal and running the `windeployqt` command again, it subsequently
    completed successfully without the warning, and the GCC files were present as
    expected in data alongside all the Qt binaries. Without picking up on this quiet
    little warning, I would have proceeded with some potentially critical missing
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `windeployqt` is a huge time saver, but unfortunately, it isn’t
    a silver bullet and sometimes misses the required files. Tools like Dependency
    Walker exist, which can help analyze the dependency tree in detail, but a good
    starting point is to just manually launch the `cm-ui` executable from the data
    folder and see what happens. In our case, it is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9705df93-43d7-4d61-a747-23ea31e54225.png)'
  prefs: []
  type: TYPE_IMG
- en: The bad news is that it doesn’t work, but the good news is that at least it
    clearly tells us why it doesn’t work—it is missing the `Qt5Sql.dll` dependency.
    We know that we do indeed have a dependency there, because we had to add the `sql`
    module to our `.pro` files when we started doing database work. However, wait,
    we’ve just executed a command that should pull in all the Qt dependencies for
    us, right? Right, I don’t know why the tool misses out some dependencies that
    it really should know about, but it does. I don’t know if it’s a bug, an oversight,
    or a licensing restriction related to the underlying third-party SQLite implementation,
    but in any case, the simple solution is that we just need to copy it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Head over to `<Qt Installation>/5.9.1/<kit>/bin` and copy `Qt5Sql.dll` over
    to our data folder. Launch the `cm-ui.exe` again and hurrah, it opens successfully!
  prefs: []
  type: TYPE_NORMAL
- en: 'One other thing to look out for apart from missing `.dll` files from the bin
    directory is missing files/folders from the plugins directory. You will see in
    our case that several folders have been copied successfully (bearer, iconengines,
    and such), but sometimes they don’t, and can be very difficult to figure out as
    you don’t get a helpful error message like we did with the missing DLL. I can
    only recommend three things in that situation: trial, error, and the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: So, we now have a folder containing our lovely application binaries and a whole
    bunch of similarly lovely other files and folders. What now? Well, we can simply
    copy the folder wholesale onto our users' machines and get them to launch the
    executable as we did. However, a neater and more professional solution is to bundle
    up everything into a pretty installation package, and that is where the Qt Installer
    Framework tool comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Installer framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's edit our Qt installation and grab the Qt Installer framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the MaintenanceTool application from your Qt installation directory,
    and you will be presented with a wizard virtually identical to the one we saw
    when we first installed Qt. To add Qt Installer Framework to your existing installation,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Either log in to your Qt Account or Skip
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add or remove components and click on Next
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Select Components dialog, check Tools > Qt Installer Framework 3.0 and
    click on Next
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin the installation by clicking on Update
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once complete, you can find the installed tools in `Qt/Tools/QtInstallerFramework/3.0`.
  prefs: []
  type: TYPE_NORMAL
- en: You can add further modules, kits, and such in exactly the same way. Any components
    you already have installed will be unaffected unless you actively deselect them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qt Installer Framework requires two specific directories to be present:
    config and packages. Config is a singular piece of configuration that describes
    the installer as a whole, whereas you can bundle multiple packages (or components)
    together in the same installation package. Each component has its own subdirectory
    within the packages folder, with a data folder containing all the items to be
    installed for that component and a meta folder where configuration data for the
    package is held.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, although we have two projects (`cm-lib` and `cm-ui`), it makes
    no sense to distribute one without the other, so we will aggregate the files together
    into one package. A common naming convention for packages is `com.<publisher>.<component>`,
    so we’ll name ours `com.packtpub.cm.` We already created the required data folder
    in the previous section (yay for forward planning!) and `windeployqt` stuffed
    it full of files for us.
  prefs: []
  type: TYPE_NORMAL
- en: There is no required naming convention here, so feel free to name the package
    something else if you wish. If we wanted to bundle an additional, optional component
    with our application, we would do so by simply creating an additional package
    folder (for example, `com.packtpub.amazingcomponent`) containing the relevant
    data and meta files, including a separate `package.xml` to configure that component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create any missing folders so that you end up with the following folder structure
    inside `cm/installer/windows`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08e3a715-ebf8-4bec-acb8-bab8f8b1c958.png)'
  prefs: []
  type: TYPE_IMG
- en: To compliment these folders, we also need to provide two XML configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `config.xml` in the config subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration file customizes the behavior of the installer. The properties
    we have specified here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| `Name` | The application name |'
  prefs: []
  type: TYPE_TB
- en: '| `Version` | The application version |'
  prefs: []
  type: TYPE_TB
- en: '| `Title` | The installer name displayed in the title bar |'
  prefs: []
  type: TYPE_TB
- en: '| `Publisher` | The publisher of the software |'
  prefs: []
  type: TYPE_TB
- en: '| `StartMenuDir` | The default program group in the Windows Start menu |'
  prefs: []
  type: TYPE_TB
- en: '| `TargetDir` | The default target directory for the application installation
    |'
  prefs: []
  type: TYPE_TB
- en: You will note strange @ symbols in the `TargetDir` property, and they define
    a predefined variable `HomeDir` that allows us to dynamically obtain a path to
    the end user’s home directory. You can also access the values of other properties
    in the same way, for example, `@ProductName@` will return “Client Management”.
    Further information is available at [http://doc.qt.io/qtinstallerframework/scripting.html#predefined-variables](http://doc.qt.io/qtinstallerframework/scripting.html#predefined-variables).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create `package.xml` in the `packages/com.packtpub.cm/meta` subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This file configures the `com.packtpub.cm` package (our Client Management application)
    with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| `DisplayName` | The name of the component. |'
  prefs: []
  type: TYPE_TB
- en: '| `Description` | The text displayed when the component is selected. |'
  prefs: []
  type: TYPE_TB
- en: '| `Version` | The version of the component (used to promote component updates).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ReleaseDate` | The date the component was released. |'
  prefs: []
  type: TYPE_TB
- en: '| `Licenses` | A collection of licenses that must be agreed to in order to
    install the package. The text for the license agreement is obtained from the specified
    file that must be alongside the configuration file in the meta folder. |'
  prefs: []
  type: TYPE_TB
- en: '| `Default` | Boolean flag denoting whether the component is selected by default.
    |'
  prefs: []
  type: TYPE_TB
- en: You will also need to create `license.txt` in the meta folder; the content doesn’t
    matter in this case as it’s just for demonstration, so write any old nonsense
    in there.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the binaries, dependencies, and configuration in place, we can now
    run the Qt Framework Installer in a command terminal to generate our installation
    package. First, change directory to the `cm/installer/windows` folder and then
    execute `binarycreator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `-c` flag tells the tool where the `config.xml` file resides and `-p` where
    all the packages are. The final parameter is the name you want to give the resulting
    installer.
  prefs: []
  type: TYPE_NORMAL
- en: With our application neatly packaged up into a single installer file, `ClientManagementInstaller.exe`,
    we can now easily distribute it to our end users for installation.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upon launching the installer, you will be presented with a welcome dialog,
    the content of which is derived from our `config.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f37cf0b-bffa-4217-aa87-6b2ae057355f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are then prompted to specify the target directory for the installation and
    what we expect is that after installation, this folder will contain all the files
    and folders we pulled together in the data folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/205b591a-cfc4-4cf2-ba78-58238f6a3a10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are then presented with a list of all the components we defined via the
    packages directory, which in this case is simply the application and dependencies
    in the `com.packtpub.cm` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01881dcf-369b-463f-b905-267d30053ea9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we are presented with any licenses we defined in `packages.xml`, including
    the license information provided in the text files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccff9ba7-834c-4e72-8ce1-0a5d5ac24cf5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are then prompted for the Start Menu shortcuts, with the default provided
    by `config.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/058b12dd-aa3e-4869-9137-3904578bf55e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’re ready to install now and are provided with disk usage stats before we
    confirm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7af94f05-a95f-48d5-a092-0d683ae56cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After a brief wait while the installation completes, we are presented with
    a final confirmation dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16c6a965-1105-4705-bf3a-4487e1f71473.png)'
  prefs: []
  type: TYPE_IMG
- en: You should see a new `ClientManagement` folder in the target directory containing
    our installed application!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made our application even more testable by introducing our
    first object factory. They are a really useful layer of abstraction that make
    unit testing so much easier, and on larger projects, it's common to end up with
    several factories. We then made our UI even more dynamic by having Style properties
    that can scale along with the Window.  `EnumeratorDecorators` got some love and
    an editor component of their own, fully finger-friendly to boot. We then put that
    editor to use and implemented Contact management, showing how collections of objects
    can easily be viewed and edited.
  prefs: []
  type: TYPE_NORMAL
- en: With our application more fleshed out, we then took a look at how to get our
    shiny new work of genius into the hands of our end users. Different operating
    systems each have their own take on things, and you will undoubtedly discover
    quirks and encounter challenges in your own particular environment, but hopefully,
    you now have the tools you need to be able to work through them.
  prefs: []
  type: TYPE_NORMAL
- en: That sentiment goes not just for deployment, but for the whole project life
    cycle.  The goal of this book was not to discuss theoretical problems that while
    interesting, will never come up in your day-to-day role as a developer.  The goal
    was to present solutions to real-world problems. We have developed a functional
    Line of Business application from start to finish, working through common tasks
    that you will encounter on a daily basis, whether working on an initiative at
    work or on a personal project at home.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that some of the approaches detailed in this book prove useful to you
    and that you go on to enjoy working with Qt as much as I do.
  prefs: []
  type: TYPE_NORMAL
