- en: Chapter 5. Classification and Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to an IBM study ([http://www-935.ibm.com/services/us/gbs/bus/pdf/gbe03100-usen-03-making-change-work.pdf](http://www-935.ibm.com/services/us/gbs/bus/pdf/gbe03100-usen-03-making-change-work.pdf)),
    only 41% of projects meet their schedule, budget, and quality goals. The success
    or failure of a project largely does not depend on the technology, but the people
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a software project where every developer is always aware of all the
    intricacies of the decision making process that goes into every part of a project.
    In this ideal world, a developer could always make an informed decision and provided
    no developer wants to actively harm the project, the decisions will be reasonable.
    If an incorrect decision is made, it will not cause a huge problem in the grand
    scheme of things because the developer who touches this part of the project next
    will know what to do to fix it and will also be aware of all the dependencies
    involved. Such a project is highly unlikely to fail from a project perspective.
    The sad truth, though, is that there are almost no such projects in the world,
    and this is most likely due to the overhead such a system would create by needing
    the whole team to review every change made.
  prefs: []
  type: TYPE_NORMAL
- en: This might work for a very small project, most likely a start-up with few engineers,
    but it simply does not scale up as the project grows. When functionality and complexity
    grow, we need to decompose the project, and as we have seen already, small projects
    are easier to handle than big ones. Decomposition is not easy, so we need to find
    the seams in the project, and we also need to be aware of and decide on a governance
    model for the project as a whole, as well as the sub-projects, or sub-domains
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: In the open source world, the Linux kernel project is a good example of a project
    starting out with only a few developers and growing since then. Since increasing
    beyond a size that one person can keep in their head at any point in time, the
    kernel has split into sub-projects, or sub-domains, be it the network handling,
    or filesystem, or others. Each sub-project has established its own domain, and
    the project grows with the trust that each sub-project will do the right thing.
    This means that the projects will drift apart, so an open mailing list enables
    discussions on topics around the grand architecture and the goal of the project
    in general. To facilitate this, the language used in this mailing list is very
    focused on the needs of the community. Explaining everything in detail every time
    would otherwise end up in huge discussions that completely miss the point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go into detail on how we can leverage domain-driven
    design in the context of a growing project, in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: Using and extending the language of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the context of the domain and its sub-domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The building blocks of a domain-driven project, aggregates, entities, value-objects,
    and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a common language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can't make every developer constantly aware of the project as a whole, but
    we can make the decisions very clear and the structure very intuitive to use through
    the establishment of a common language that is shared inside the project. A developer
    who looks at a piece of unfamiliar code should be able to figure out what it does
    and where it belongs in the system's context as a whole, if they are familiar
    with the language used throughout the project. Even as a project grows in a domain
    and the language of the sub-domain becomes more pronounced and starts to focus
    more on the specific parts of the sub-domain it is used in, it is important to
    keep an overall structure in place. As a developer of one sub-domain, I should
    not feel lost looking at a separate sub-domain as the language of the overarching
    domain maintains a global context for me to follow.
  prefs: []
  type: TYPE_NORMAL
- en: We have been building a common language so far by taking words from the business
    domain and using them in the application. A business expert is able to broadly
    understand what each component is about, and how the components will interact.
    It is also important to build this language as we grow, with developers contributing
    new words to the business domain to disambiguate elements.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of contributions are not only valuable to developers, as they are
    now able to clearly communicate what a certain element is, they are also beneficial
    for business experts as they can now communicate more clearly as well. If a term
    fits well, it will be adapted by the domain; if it does not, then it is better
    to drop it in most cases. To do this, we must first be make ourselves aware of
    what kind of patterns are available to us and use the terms already provided to
    us to let them influence the language we use throughout.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of object classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developers like to classify things, as we saw earlier when describing why naming
    things like `SomethingManager` is harmful. We like to classify things because
    it gives us a way to make assumptions about the object we are dealing with. Describing
    the purpose of a certain element is not only problematic and error-prone in the
    business domain, but also in the programming domain. We want to be able to quickly
    associate certain parts of the code with certain problems. While a ubiquitous
    language solves this part in the business domain, we can draw from patterns to
    better describe our programming problems. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer 1**: Hi, let''s talk about the code to transform between our domain
    objects and the persistence.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer 2**: Yes, I think there is a lot of room to optimize here. Have
    we ever looked at something provided by an outside company here?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer 1**: Yes, we have, but we have very special needs and the common
    available alternatives seem to be not performing well enough for us.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer 2**: Oh, okay. I was under the impression our home grown version
    has trouble with threading and is overall not that performant.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer 1**: I don''t think we need to talk about threading here, this
    should be handled at a lower level.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer 2**: Wait, are we not talking about the database connection here?
    How much lower do you want to get?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer 1**: No, no! I''m talking about the transformation of domain objects
    to database objects as we translate the fields to the right types and the column
    names and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer 2**: Oh, in this case you are talking to the wrong person. I''m
    not familiar with this part, sorry.'
  prefs: []
  type: TYPE_NORMAL
- en: This conversation is likely to happen when bad naming creeps into a project.
    Developer 1 is talking about what would commonly be known as a **Data Mapper Pattern**,
    while Developer 2 is talking about the database API. Having commonly accepted
    names not only eases the conversation, but also lets certain developers much more
    easily express which part of the code they are more or less familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns are most commonly used for naming programming techniques, for example,
    the Data Mapper Pattern describes a way to deal with the interaction between objects
    and their persistence to a database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Data Mapper performs a bidirectional transfer of data between a persistent
    data store and the in-memory data representation of domain objects or data structures
    like it. It was named in *Patterns of Enterprise Application Architecture*, *Martin
    Fowler*, *Pearson*.
  prefs: []
  type: TYPE_NORMAL
- en: In domain-driven design, we also have *certain* way of dealing with certain
    kinds of objects and their relationships. On the one hand, there are patterns
    for organizing the development itself, and on the other hand there are names given
    to objects that fulfill a specific purpose. This kind of classification is what
    this chapter is all about. We build an understanding of certain domain elements
    by making them into concrete implementations of certain domain-driven design concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the bigger picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with a large project, the most common problem is to figure out
    what the guiding idea behind the design is. When a piece of software grows large,
    it is likely that the project comprises of more than one project but is actually
    split into sub-projects, each responsible for its own API and design. In terms
    of domain-driven design, there are domains and sub-domains. Each sub-domain carries
    its own context; in domain-driven design this is the bounded-context. The separate
    contexts together with the relationship of the main domain and its sub-domains
    hold the knowledge together in a conclusive whole.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the server side, there is a move towards service-oriented architecture, which
    introduces quite a hard split between certain elements of the project by separating
    them out into different components that are run separately.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there has always been the concept of packages that define their own
    visibility. JavaScript is somewhat lacking in this area as all the code is traditionally
    run in the browser under one thread. This does not mean of course that all is
    lost, as we can separate namespaces by convention and tools like **npm** and **browserify**
    now enable us to use backend like separation on the frontend as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supporting the process of looking up certain parts of the code, as well as
    figuring out what can be shared in between different parts of the domain, is a
    problem that has been tackled in multiple ways by different languages. As JavaScript
    is very dynamic, it means that there has never been a strict way to enforce privacy
    of certain parts in the language itself, for example keywords such as `private`.
    It is, however, possible to hide certain details, if we choose to do so. The following
    code uses a JavaScript pattern to define private properties and functions in the
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This style of coding is possible, but it is not very idiomatic. In JavaScript,
    programmers tend to trust their fellow programmers to do the right thing and assume
    that if somebody wants to gain access to a certain property, he or she will have
    a good reason for it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great feature of object orientation often mentioned is that it hides the details
    of implementation from others. Depending of the environment you work in, the reason
    for hiding details is often different. While most Java developers go to great
    lengths to prevent others from touching "their" implementation. Most developers
    of JavaScript tend to interpret it as the fact that others developers shouldn't
    need to know how things work, but if they want to reuse internal parts they are
    free to do so and have to deal with the consequences. It is hard to say what works
    better in practice.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true on a higher level of abstraction; it would be possible to hide
    a lot of details but in general, packages tend to be quite open to expansion exposing
    an inner structure if a programmer wants to get to it. JavaScript itself, and
    its culture, don't lend themselves nicely to hiding details effectively. We can
    go to great lengths to achieve this effect, but it would go against the principles
    people expect from the software.
  prefs: []
  type: TYPE_NORMAL
- en: Even though hiding many details completely is hard, we still need to maintain
    consistency in our application. This is what we use aggregates for, which encapsulate
    a set of functionality to expose through a coherent interface. For our domain-driven
    design, we need to be aware of this fact; by using the right language and patterns,
    we need to guide other programmers through our code. We want to provide the right
    context in the right situation by naming consistently and guiding the use of domain
    related names through tests explaining the level a certain piece of functionality
    is located at. When we classify certain parts of the software as an aggregate,
    we show the next developer that the safe way to access the functionality is through
    this aggregate. With this in mind, even though it is still possible to reach inside
    and inspect the inner details, you should only do this if you have a very good
    reason to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with objects in various languages, including JavaScript, objects
    are almost universally passed and compared by reference, which means that an object
    that is passed to a method does not get copied, but rather its pointer gets passed,
    and when two objects are compared, their pointers are compared. This is not how
    we think about objects and especially value objects, as we think of those as identical
    if their properties are identical. More importantly, we don''t want to consider
    the inner implementation details when we consider things like equality. This has
    some implications for the function using the object; one important implication
    is that modifying the object will actually change it for everybody in the system,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Related to this is the fact that comparing does not always yield the expected
    result as in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Even though this might be obvious to us as programmers, it really is not capturing
    the intention of the objects in the domain. In the real world, having two 50-cent
    coins and considering them different is not convenient, for example, in the domain
    of payment. It does not make sense for a shop to accept a certain 50-cent coin
    while rejecting another. We would like to compare our coins by the value they
    represent, rather than the physical form. On the other hand, coin collectors will
    think quite differently about the problem, and for them a certain 50-cent coin
    might be worth a fortune, while a generic one is not. The comparison of objects
    and their identity always has to be considered in the context of the domain.
  prefs: []
  type: TYPE_NORMAL
- en: If we decide to compare and identify an object in a software system by its property
    value rather than its intrinsic identity, we have an instance of a value object.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of value objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects that are passed around and can be modified can cause unexpected behavior,
    and depending on the domain, comparing objects by identity can be misleading.
    In those kind of situations, declaring a certain object as a value object can
    save you a lot of trouble down the road. Making sure an object is not modified
    in turn makes it easier to reason about any code interacting with it. This is
    because we don't have to look at the dependencies down the line, as we can just
    use the object as it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has support for these kinds of objects built in; using the `Object.freeze`
    method will make sure that no changes can happen to the object after it has been
    frozen. Adding this to the construction of the object will let us be confident
    that the object will always behave as we expect it to. The following code constructs
    an immutable value object using `freeze`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A noteworthy addition to JavaScript was the `use strict` directive. If we do
    not use this directive, the assignment to the value property would silently fail.
    Even though we can still be sure that no changes will happen, this will cause
    some blank stares at the code. So even if it is mostly left out in this book in
    order to keep the code samples short, the use of `use strict` is highly recommended.
    You can use **JSLint** to enforce this, for example ([http://www.jslint.com/](http://www.jslint.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with value objects, it is also a good idea to provide a function
    to compare them against each other, whatever that means in the current domain.
    In the coin example, we would want to compare them by the value of the coin, so
    we provide an `equals` function to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `equals` function makes sure we are dealing with coins, and if so checks
    if they have the same value. This makes sense in the domain of payment, but might
    not necessarily hold true everywhere else. It is important to note that the fact
    something is a value object in a certain domain does not mean this is universally
    true. This becomes specifically important when dealing with the relationship of
    projects inside an organization. It can very well be necessary to have separate
    definitions of similar things because they are regarded in different ways across
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code uses the *__proto__* property of an object, which is an internally
    managed property pointing to the prototype of an object and was a recent addition
    to JavaScript. Even though this is very convenient, we can always get to the prototype
    via `Object.prototype` (object) if necessary and if *__proto__* is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just having a method to compare does not mean everybody will use
    it in all situations, and JavaScript does not provide a way to enforce it. This
    is one place where the domain language comes to save us. Spreading the knowledge
    about the domain will make it clear to fellow developers what should be considered
    a value object, and the ways to compare it. This might be a good idea in a situation
    where you are documenting the class in use and need to provide the next person
    with some details.
  prefs: []
  type: TYPE_NORMAL
- en: The referential transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Coin` objects we have been working with have another interesting property,
    which could be useful in our system, and this is that they are referentially transparent.
    This is a very fancy way of saying whenever we have a coin, it does not matter
    what we do with it, as it will be regarded as the same in every part of the application.
    We are therefore free to pass it to other functions and keep a hold of it without
    having to worry about it changing. We also don''t need to follow the coin as a
    dependency, checking what might have happened to it before or how it might be
    changed by other functions in case we pass it along. The following code illustrates
    the simple usage of a coin object constructed as a value object. Even though the
    code depends on it we don''t need to take special care of interacting with the
    object as it is defined as an immutable value object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding example is a save operation with only one dependency – the
    wallet, to watch with the `Coin` being a value object, it would be much more complicated
    if the `Coin` object is an entity. The `checkIfValid` function might change attributes
    and we would therefore have to investigate what happens inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only does the value object make the code flow easier to follow, referential
    transparency is a very important factor when it comes to dealing with caching
    objects across the lifetime of our application. Even though JavaScript is single-threaded,
    so we don''t have to worry about objects being modified by other threads, we have
    seen that objects can still be modified by other functions, and they also might
    change for other reasons. With a value object, we never have to worry about this,
    so we are free to save it for later and refer to it whenever we need to. In between
    functions, an event might occur that leads to the modification of objects we are
    currently working with, and this can make it very hard to track down bugs. In
    the following code, we see a simple usage of the `EventEmitter` variable and how
    we can use it to listen to a `"change"` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Looking at just the functions `doStuff` and `doMoreStuff`, we would expect to
    see a 10 printed to the console, but it actually prints 11 as the event change
    is interleaved. This is pretty obvious in the previous example, but dependencies
    like this can hide deep inside the code, crossing many more functions. Value objects
    make the same mistake impossible, as the change to the object would have been
    prohibited. This is not the end to all errors in asynchronous programming, of
    course, and more patterns are needed to make sure this works as expected; for
    most use cases I would recommend a look at **async** ([https://github.com/caolan/async](https://github.com/caolan/async)),
    a library to help with all kinds of asynchronous programming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Objects defined as entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, having objects primarily defined by their properties can be
    really useful and helps us deal with a lot of scenarios when designing a system.
    So, we often see that certain objects have a different lifecycle attached to them.
    In such a case, the object is defined by its ID, and in domain-driven design terms,
    it is considered an entity. This is a contrast to value objects that are defined
    by their properties, and are considered to be equal when their properties match.
    An entity is only ever equal if it has the same ID, even if all the properties
    match; as long as the ID is different, the entity is not the same.
  prefs: []
  type: TYPE_NORMAL
- en: Entity objects manage the lifecycle inside the application; this can either
    be the lifecycle spread across the application as a whole, but it might well be
    a transaction happening in the system. In the dungeon, we are dealing with a lot
    OF cases where we don't really care about the lifecycle of an object itself, but
    rather WE care about its attributes. Staying with the prisoner transport example,
    we know that it comprises many different objects, but most of them could be implemented
    as value objects. We do not really care about the lifecycle of the orc guard accompanying
    the transport, and we are fine as long as we know there is one and that he is
    armed to protect us.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem a little seem counterintuitive as we know we need to take care
    about the assignment of orcs as we don''t have an infinite number of them, but
    really there are two separate concepts hiding inside, one being the `Orc` as a
    value object and the other being its assignment to guard the transport. The following
    code defines an `OrcRepository` function, which can be used to get orcs under
    controlled circumstances and use them. This pattern can be used to control access
    to a shared resource in conjunction with most likely database access encapsulated
    within:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While the `Orc` object itself might be a value object, the assignment needs
    to have a lifecycle, defining the start, the end, and the availability. We would
    need to get an orc from a repository of `Orc` objects, fulfilling the need to
    be able to guard the transport and return it as soon as the transport is done.
    In the preceding case, the `Orcs` repository is an entity, so we need to make
    sure that it is managed correctly otherwise we might end up with incorrect orc
    counts or unrecorded weapons, as both are bad for business. The orc in this case
    can be passed around freely, and we are isolated from its management.
  prefs: []
  type: TYPE_NORMAL
- en: More on entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entities come up regularly when building an application, and it is easy to fall
    into the trap of making most objects in the system entities, instead of value
    objects. The important thing to keep in mind is that value objects can perform
    a lot of work, and that dependencies on value objects are "cheap".
  prefs: []
  type: TYPE_NORMAL
- en: 'So why are dependencies on value objects "cheaper" than a dependency on an
    entity? When dealing with entities, we have to deal with state, so any modification
    being made can have an impact on other subsystems using this entity in their processing.
    The reason for this is the fact that each entity is a unique thing that can change,
    while a value object boils down to a collection of properties. When we pass around
    entities, we need to synchronize the consumers on the state of the entity, and
    possibly on all its dependent entities as well. This can get out of control very
    quickly. The following code shows complication when dealing with the interaction
    of multiple entities. We need to control multiple aspects when keeping the Wallet,
    inventory and the orc itself in a consistent state when adding and removing items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we need to make sure that the buy action is not interrupted because
    a strange behavior could occur depending on other implementations. This would
    get even worse if the inventory had more behavior associated with it, such as
    a size check, then we would need to coordinate the two checks while making sure
    we can roll back without being interrupted. We have seen before how events can
    cause us a lot of problems here and this gets unwieldy fast. Even though it is
    of course unavoidable to deal with this at some level, being aware of the problems
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: Entities need to have their lifecycle controlled in a way that makes sure there
    is no inconsistent state present. This makes handling entities more complicated
    and can also have an impact performance on due to locking and transaction control.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the application's lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entities and aggregations are all about managing this cycle at every level of
    the application. We can think about the application itself being the aggregation
    wrapped around all its components to manage the attached value objects and contained
    entities. At the level of our prisoner transfer, we treat the transfer itself
    as a transaction wrapping all the local dependents, and managing the eventual
    result of either a successful transfer or a failed one.
  prefs: []
  type: TYPE_NORMAL
- en: It is always possible to push the lifecycle management further up or down the
    chain of objects, and finding the right level can be hard. In the previous example,
    the assignment might as well be a value object managed by an aggregate up the
    chain to ensure its constraints are satisfied. The right level of abstraction
    at this stage is a decision that the developers of the system have to make. Pushing
    the transaction control too high and then making the transaction span more objects
    can be costly as the locks are more coarse and therefore concurrent operations
    are hindered; pushing it too low can result in a complex interaction between the
    aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deciding the right level of abstraction to manage the lifecycle has a deeper
    influence into the application than is visible at first. Since entities are managed
    by their ID while being mutable, this means they are objects that need to be synchronized
    when dealing with concurrency, and because of this it influences the concurrency
    of the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object orientation relies heavily on combining the functionality of multiple
    collaborators to achieve certain functionality. When building systems, there is
    often the problem that certain objects attract more and more functionality, and
    in that, becoming a kind of god object that is involved in almost every interaction
    in the system. The way around this is to let multiple objects collaborate to achieve
    the same functionality, but as a sum of small parts instead of one large object.
  prefs: []
  type: TYPE_NORMAL
- en: Building up those interconnected subsystems has a different problem, in that
    it tends to expose large and complex interfaces as the user needs to know more
    about the internals to use the system as the objects structure is being build
    up. Letting a client handle the internals of a subsystem is not a good way to
    model such a system, and this is where the concept of aggregation comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: An aggregation allows use to expose one consistent interface to our clients
    and let them deal only with the parts they need to provide to make the system
    function as a whole, and let the outside entry point handle the different internal
    parts. In the previous chapter, [Chapter 4](ch04.html "Chapter 4. Modeling the
    Actors"), *Modelling the Actors*, we talked about aggregation in the example of
    a horse carriage being made up of all the elements needed to make it work as a
    whole. The same concept applies to other levels as well, and each subsystem we
    build is a kind of aggregation of its parts, comprising of entities and value
    objects along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The questions we need to ask ourselves as developers are, at that point during
    our development, how do we group parts, where are the interfaces governing those
    aggregations best built, and what should they look like? Even though there is,
    of course, no strict formula for this, there are parts described in the following
    that can be used as guidance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces should only require a client to provide the parts it actually cares
    about as being flexible, which often means that there are multiple entry points
    to a subsystem and clients touching a system through different points might step
    on others'' toes along the way. We can borrow some classic techniques at this
    point and provide so-called `factory` methods to give us the entry point to the
    object graph that we need. This allows use to create an easily readable syntax
    instead of trying to take advantage of all the dynamic ways of to make the object
    creation flexible and accept very different parameters to provide the same functionality.
    The following code shows this kind of factory in the context of creating an orc.
    We want to have the object constructor as flexible as possible, while providing
    factory methods for the common case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we could have detected missing attributes and reshuffled the
    input parameters to ensure that generating an orc works with every kind of combination,
    but this quickly becomes unwieldy. As soon as the collaborators are no longer
    just simple strings like picked here for simplicity, we need to interact with
    more objects and control more interaction. By providing a factory function, we
    can express exactly what we intend to provide and don't need to resort to very
    complex handling.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the goal of grouping collaborators in aggregates and providing different
    interfaces for the access is to control the context, as well as to engrain the
    language of the domain more deeply in the project. Aggregates are there to provide
    a simpler view of the model data they aggregate to protect against inconsistent
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we have been expressing concepts around "things", but there are certain
    concepts that are best expressed around the act of doing something, and this is
    where services come in. Services are a first class element of domain-driven design,
    and their goal is to encapsulate actions in the domain that involves the coordination
    of many collaborators.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"[…]Verbs in Javaland are responsible for all the work, but as they
    are held in contempt by all, no Verb is ever permitted to wander about freely.
    If a Verb is to be seen in public at all, it must be escorted at all times by
    a Noun.**Of course "escort", being a Verb itself, is hardly allowed to run around
    naked; one must procure a VerbEscorter to facilitate the escorting. But what about
    "procure" and "facilitate?" As it happens, Facilitators and Procurers are both
    rather important Nouns whose job is is the chaperonment of the lowly Verbs "facilitate"
    and "procure", via Facilitation and Procurement, respectively.[…]"* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*- Steve Yegge - Thursday, March 30, 2006 - Execution in the Kingdom
    of Nouns* |'
  prefs: []
  type: TYPE_TB
- en: 'Services are a very useful but also often abused concept, and they come down
    to naming in general. The act of doing something can either be expressed in terms
    of a "thing" doing or naming the "doinger". For example, we could have a `Letter`
    and call the `send` method on it, letting it decided what to do and passing it
    the collaborators needed, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative is to have a service that handles the sending of the letter
    and calls it in a stateless way, passing all the collaborators to the service
    upon construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In a simple example, it is very obvious that the second approach seems complicated
    and does not add to the domain language of sending letters in any meaningful way.
    In more complex code, this is often overlooked because the complexity of a certain
    action needs to live somewhere. Which approach to choose comes down to the amount
    of functionality that can be encapsulated in the service. When a service exists
    only to split out a piece of code into a now separate but kind of homeless piece,
    a service is probably a bad idea. If we are able to encapsulate domain knowledge
    in the service, then we will have a valid reason to create one.
  prefs: []
  type: TYPE_NORMAL
- en: Having one object being named after what it does and having only one method
    in it which is actually the action should raise a red flag for any object-oriented
    programmer. Good services add to the domain and express a concept that has a solid
    foundation in the domain itself. This means there are names to express this concept.
    Services can encapsulate those concepts not directly backed by "things", and they
    should be named according to the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Associations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw that the delivery of a letter is dependent on
    a postman. There is a certain relationship between the letter and the person who
    delivers it, but depending on the domain, this relationship might not be a very
    strong or relevant one. It could be relevant for our dungeon master to know who
    delivered which letter, for example, in case every deliveryman is instantly imprisoned
    and held responsible for the content of the post he or she delivers.
  prefs: []
  type: TYPE_NORMAL
- en: The ways of the orcs might not be as understandable as the rules of business
    often are. In this case, we would want to make sure that we put a label on each
    letter and the postman who delivered it, associating the letter with a certain
    person. The other way around is not relevant. As we model this in our domain,
    we want to carry this important knowledge across and have a way to associate the
    message in the process of delivery with the appropriate deliveryman. In code this
    can be done more easily; we might for example create a history for the letter,
    where each collaborator being associated with the delivery is linked.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of associations between domain models is an integral part of the
    domain design, as most objects of whatever form will not work in complete independence.
    We want to codify as much knowledge as possible in the associations. When we think
    about associations between objects, the association itself can hold domain knowledge
    that we want to have incorporated in our model.
  prefs: []
  type: TYPE_NORMAL
- en: Insight during implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of patterns is well established across object-oriented languages
    as well as other types. Many books have been written on it, and many discussions
    have been had that deal with encoding the knowledge of many developers in patterns
    to be used in enterprise, as well as other kinds of software. In the end, it comes
    down to using the right pattern at the right point during development, which is
    not only true for domain patterns but other software patterns as well.
  prefs: []
  type: TYPE_NORMAL
- en: In his book *Patterns of Enterprise Application Architecture*, Martin Fowler
    not only discusses the available options to deal with communication to a database
    by means of a `DataMapper` plugin plus domain layer, Transaction Scripts, Active
    Record, and so on, but also discusses when to use them. As with most things, the
    conclusion in the end is so that all choices have good and bad sides to them.
  prefs: []
  type: TYPE_NORMAL
- en: When working on software, there are multiple insights to gain as we move forward.
    A very valuable insight is the introduction of a new concept that was not clear
    before. To reach such a point there is no obvious way, what we can do is to start
    classifying the patterns we currently have in the software and making them as
    clear as possible to make the discovery of new concepts more likely. With a set
    of well separated pieces, discovering missing pieces if more likely to happen.
    When we are thinking about domain patterns, especially the various ways that we
    can classify certain elements of the application, the ways to classify are not
    always as clear as we would like them to be.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing domain patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the example of handling sending the letter, we noticed that even
    though the proposed option uses a service to handle the collaboration, there are
    other ways to go about this. The problem with small examples like we have in this
    book is that it is hard to convey when a certain option has a benefit or when
    a certain design is overkill in the general context; this is especially true for
    complex architecture as domain-driven design is, after all if the application
    is done in a couple hundred lines of code, many problems the domain-driven design
    solves are not present.
  prefs: []
  type: TYPE_NORMAL
- en: When we write the code for a certain feature, we always need to be aware of
    the fact that the design of the components is not set in stone. An application
    might start out with a lot of entities being present, handling most interactions
    inline, as the system has not evolved enough yet to have a clear view on which
    interactions are complex and important enough to have them as a domain concept.
    Also, often the fact that we *use* the software means we recognize certain concepts,
    and by use as developers, I mean touching the interfaces and extending the software
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Not everything is an entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, in domain-driven design it is easy to create entities for everything.
    The idea of an entity is a very common one in the mind of developers. Objects
    always have a fixed identity when we think about them as things in memory, and
    most languages by default compare this way, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This makes it easy to just expect everything to be an entity, with its ID being
    whatever JavaScript considers it to be.
  prefs: []
  type: TYPE_NORMAL
- en: When we think about the domain, this of course does not always make sense, and
    we quickly start to recognize that certain things are not identified this way,
    which often moves certain parts of the application towards the use of value objects,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Starting out as simple as possible is a good thing, but what makes the project
    a great place to work on over time is taking as many opportunities as possible
    to make things better. Even if the route does not end up being the one taken,
    the mere act of trying it makes the code better.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **primitive obsession** anti-pattern is a trap often fallen into when not
    refactoring early and often. The problem is that new objects are introduced rarely
    and many concepts are represented by primitives, like an email as a string, or
    money values as pure integers. The problem is that the primitives don't encapsulate
    all the knowledge but just the pure property, and this leads to duplication of
    knowledge all over the place where a named concept such as an e-mail or a money
    object could have been shared.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring all the time towards malleable code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we start to work toward letting the code guide our design in different
    ways, we notice the places that are continually changing, and the ones that trouble
    us with most new features, or even refactoring being implemented. Those are the
    pain points that we need to address.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *In object-oriented programming, the single responsibility principle
    states that every class should have responsibility over a single part of the functionality
    provided by the software, and that responsibility should be entirely encapsulated
    by the class. All its services should be narrowly aligned with that responsibility*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*– the Single Responsibility Principle according to Wikipedia, originally
    defined by Robert C. Martin* |'
  prefs: []
  type: TYPE_TB
- en: We want our changes to be localized, and exploring a different route for the
    implementation of a certain feature should touch the least amount of code possible.
    This is the purpose of the **Single Responsibility Principle**, as defined by
    Robert C. Martin, which defines a responsibility as a reason to change. Together
    with the **Open/closed principle**, making code open for extension but closed
    for modification, this leads to code being easy to work with due to known seams
    and building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of domain-driven design is to take the concepts of object-oriented
    programming and take them to a higher level, so most concepts of object orientation
    apply to domain-driven design, as well. Whereas in object orientation we want
    to encapsulate objects, in domain driven design we encapsulate domain knowledge.
    We want each subsystem and each element of our domain to be as independent as
    possible and if we achieve this, the code will be easy to change along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing language guidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain-driven design is all about encapsulating domain knowledge and the guiding
    force to contain and distribute knowledge is language. We have talked before about
    the fact that one of the goals of domain-driven design is to create a ubiquitous
    language in the project that is shared between the developers and the project
    owners or stakeholders to guide the implementation. And it has been hinted before
    that this is, of course, not a one way street.
  prefs: []
  type: TYPE_NORMAL
- en: As domain concepts are uncovered, it is often useful to establish and name the
    new concepts as a team to make them the established way of communication. Sometimes,
    these new names and meanings can make it back into the business, they will start
    to get used to describe the now named pattern and over a long time can make it
    back in the common language used in the domain cross businesses if they are considered
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: In the original book on domain-driven design, by Eric Evans, he discusses the
    development of a financial software and how terms established made it back all
    the way to the Sales and Marketing departments to describe the new features of
    the software. Even though this might not be the case with your new additions to
    the business language, if an addition is helpful, at least core parts of the business
    will adopt them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with and on the business language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building a language of the domain is very different, depending on the domain.
    Very few domains already have a very specific language associated with them. If
    we look into accounting, for example, there are books written about what everything
    is called and how things interact. Similar things can also exist for established
    businesses, and even if there might not be a book to read up on it, following
    a person who does the business on a day-to-day basis can quickly reveal some concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shadowing the process you are tasked to implement for a day can provide some
    very important insights. It can also hint in the areas where the business behaves
    in very specific way, those little things we as programmers otherwise come up
    against after the fact. Things that we see as illogical have a hard time fitting
    into our model.
  prefs: []
  type: TYPE_NORMAL
- en: Not many areas of business are this lucky, and especially in the world of young
    businesses developing new ideas, there is inherently a lack of established language.
    Also those businesses are most often the ones that invest heavily in a JavaScript-based
    application, so how can we deal with this?
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the orc dungeon, we are dealing with a world that is very alien
    to us and that does not have a very established language to deal with its processes,
    as so far there was hardly ever a need for it. We dealt with this problem in the
    book already, as many terms are heavily overloaded in context. A notification
    could be a message to an orc to inform him that he is assigned to a certain prisoner
    transport, or a message to another dungeon to inform them of prisoners arriving,
    or a prison requesting new prisoners. How can we deal with situation?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the example of the orc master explaining to us how he would need
    to notify another dungeon:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer:** What do you need when the dungeon is overflowing with prisoners?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** No problem! Let Xaguk deal with it?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer:** As I know, Xaguk is the leader of the dungeon up north, so I
    guess you need to get a transport ready?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** Yes, I need to message Baronk to set up a transport and Xaguk
    for him to be ready.'
  prefs: []
  type: TYPE_NORMAL
- en: '*He writes down two letters and calls for his goblin helper.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** Get this to Baronk, and this to Xaguk!'
  prefs: []
  type: TYPE_NORMAL
- en: '*The goblin starts to run off, but just before he leaves the room through the
    south door, the master starts screaming.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** What are you doing? You need to get a raven and send this to
    Xaguk first!'
  prefs: []
  type: TYPE_NORMAL
- en: '*The goblin looks very confused but starts running of the other way now.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** This happens all the time—the goblin just can''t remember who
    is who, and he doesn''t have to, but he needs to get the letters to the right
    office.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer:** Ahh, so if you want to send a message to the other dungeon,
    you get a raven? When you message somebody insight the dungeon, it gets carried
    locally?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** That is right!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer:** Okay, so we don''t get confused in the system, I''m just going
    to call the messaging of another dungeon, to "raven" somebody, and locally we
    just continue calling it "message." Does this make sense?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** Yes! Hopefully the goblin will no longer mess up this way,
    as this has caused some strange conversations already.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a major simplification of how things like this could evolve, but the
    important thing that we as developers should take in pieces of the language that
    the business provides and incorporate them in the domain. This not only makes
    our life easier, but also improves business communication in general.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that we need to make sure we don't force our very specific
    language into the business, that is, if a certain concept does not get adopted,
    be ready to scrap it. After all, the only thing worse than an unnamed concept
    is a confusingly named concept. Building a language needs to come from the domain,
    and should not be forced on the domain. A name that does not stick is either one
    that names an unimportant concept, or one that is not descriptive enough to stick.
  prefs: []
  type: TYPE_NORMAL
- en: If an unimportant concept is named, it often forces unnecessary attention to
    it, and this can cause trouble down the road as we might be reluctant to change
    it or to adapt to new needs when we consider it too important. Consider, for example,
    that we developed the concept of automatic prisoner cell assignment, which uses
    an algorithm to determine the optimal cell for the amount of prisoners we have.
    This seemed very important as we want the dungeon to be used as optimally as possible.
    One day, a single new prisoner arrives and the system starts the calculation determining
    the optimal cell for him, while the guard is saying, "Why is this taking so long?
    Every time! I already know where I put him, I just cram him in cell number 1!"
    This is valid user feedback—even though we might have found a way to optimally
    use the dungeon, this might not actually be important as the orc sees the amount
    of prisoners per cell in a far more relaxed way than we do. The concept of automatic
    assignment is something that never really caught on; we have never heard anybody
    talking about it, so we might as well remove the whole thing, making the system
    easier for us and the users.
  prefs: []
  type: TYPE_NORMAL
- en: Systems, of course, not only serve the users; they might also serve other systems
    along the way. So keeping in mind who is the actually user can have a major influence
    on decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Building context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been talking a lot about the language we use, and how systems interact
    and what they are comprised of, but there is a higher level we need to touch as
    well: *How do systems interact with other systems?*'
  prefs: []
  type: TYPE_NORMAL
- en: In the server world, there is currently a strong focus on microservices and
    their building and interaction. The important takeaway is that having a system
    that a small team owns is easier to maintain than a system built by a larger team;
    this is only half the story, so services need to interact after all. Microservices
    are the more technical approach to the domain-driven design bounded context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how an interaction in a microservice world can
    take place. We have a lot of small services calling each other to accomplish a
    bigger task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building context](graphics/B03704_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interaction not only happens on the API level but at the developer level, as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Separation and shared knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Teams working on different parts of the application need to be aware of how
    they are able to share knowledge and work together when change arises. Eric Evans
    devotes a large section of domain-driven design to the patterns we see in practice.
    We see patterns a lot in software development, be it software patterns such as
    `DataMapper`, `ActiveRecord`, or the patterns Eric Evans discusses that are about
    the process of working together.
  prefs: []
  type: TYPE_NORMAL
- en: In the current world of microservices, we seem to have moved away from deep
    integration towards a more flexible way of touching other parts of the system
    only very lightly. It is still important to share a domain across the team, and
    a map of what touches what is becoming more important than ever.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone into a lot of detail on how to separate out systems
    and how to deal with concepts throughout the application, mostly on the smaller
    scale of a project, and how it interacts with the larger scale.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ideas that have been used in other places we can draw from when
    building the project, be it object-oriented design or be it software architecture
    patterns; the important thing to keep in mind is that nothing should be set in
    stone. One very important thing about domain-driven design is that it constantly
    changes, and that this change is a good thing. As soon as a project becomes too
    solid, it becomes hard to change and this means the business using it can no longer
    evolve alongside its software, which ultimately means switching to another system
    and different software, or rewriting the existing software.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will touch more on the higher level view of the intertwining
    pieces of the project as a whole, going into detail about the context that each
    part of the project is set in.
  prefs: []
  type: TYPE_NORMAL
