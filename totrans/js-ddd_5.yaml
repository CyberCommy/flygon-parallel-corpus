- en: Chapter 5. Classification and Implementation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。分类和实施
- en: According to an IBM study ([http://www-935.ibm.com/services/us/gbs/bus/pdf/gbe03100-usen-03-making-change-work.pdf](http://www-935.ibm.com/services/us/gbs/bus/pdf/gbe03100-usen-03-making-change-work.pdf)),
    only 41% of projects meet their schedule, budget, and quality goals. The success
    or failure of a project largely does not depend on the technology, but the people
    involved.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IBM的一项研究（[http://www-935.ibm.com/services/us/gbs/bus/pdf/gbe03100-usen-03-making-change-work.pdf](http://www-935.ibm.com/services/us/gbs/bus/pdf/gbe03100-usen-03-making-change-work.pdf)），只有41%的项目能够达到其进度、预算和质量目标。项目的成功或失败在很大程度上并不取决于技术，而是取决于参与其中的人。
- en: Imagine a software project where every developer is always aware of all the
    intricacies of the decision making process that goes into every part of a project.
    In this ideal world, a developer could always make an informed decision and provided
    no developer wants to actively harm the project, the decisions will be reasonable.
    If an incorrect decision is made, it will not cause a huge problem in the grand
    scheme of things because the developer who touches this part of the project next
    will know what to do to fix it and will also be aware of all the dependencies
    involved. Such a project is highly unlikely to fail from a project perspective.
    The sad truth, though, is that there are almost no such projects in the world,
    and this is most likely due to the overhead such a system would create by needing
    the whole team to review every change made.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个软件项目，每个开发人员始终了解项目各个部分决策制定过程的复杂性。在这个理想的世界中，开发人员可以始终做出明智的决定，只要没有开发人员想要积极损害项目，决策就会是合理的。如果做出了错误的决定，在整体规划中不会造成巨大问题，因为接下来接触该项目部分的开发人员将知道如何修复它，并且也会了解所有涉及的依赖关系。这样的项目从项目角度来看极不可能失败。然而，悲哀的事实是，世界上几乎没有这样的项目，这很可能是因为这样的系统会带来整个团队需要审查每一次变更的额外开销。
- en: This might work for a very small project, most likely a start-up with few engineers,
    but it simply does not scale up as the project grows. When functionality and complexity
    grow, we need to decompose the project, and as we have seen already, small projects
    are easier to handle than big ones. Decomposition is not easy, so we need to find
    the seams in the project, and we also need to be aware of and decide on a governance
    model for the project as a whole, as well as the sub-projects, or sub-domains
    in it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能适用于非常小的项目，很可能是一个只有少数工程师的初创公司，但随着项目的增长，它根本无法扩展。当功能和复杂性增长时，我们需要分解项目，正如我们已经看到的，小项目比大项目更容易处理。分解并不容易，所以我们需要找到项目中的接缝，我们还需要意识到并决定项目整体的治理模式，以及子项目或子域。
- en: In the open source world, the Linux kernel project is a good example of a project
    starting out with only a few developers and growing since then. Since increasing
    beyond a size that one person can keep in their head at any point in time, the
    kernel has split into sub-projects, or sub-domains, be it the network handling,
    or filesystem, or others. Each sub-project has established its own domain, and
    the project grows with the trust that each sub-project will do the right thing.
    This means that the projects will drift apart, so an open mailing list enables
    discussions on topics around the grand architecture and the goal of the project
    in general. To facilitate this, the language used in this mailing list is very
    focused on the needs of the community. Explaining everything in detail every time
    would otherwise end up in huge discussions that completely miss the point.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源世界中，Linux内核项目是一个很好的例子，它最初只有少数开发人员，但从那时起不断增长。自从超出了一个人在任何时间点都能掌握的规模后，内核就分裂成了子项目或子域，无论是网络处理、文件系统还是其他方面。每个子项目都建立了自己的领域，项目的增长建立在每个子项目都会做正确的事情的信任基础上。这意味着项目会分裂，因此一个开放的邮件列表可以让人们讨论有关整体架构和项目目标的话题。为了促进这一点，该邮件列表中使用的语言非常专注于社区的需求。否则，每次都详细解释会导致完全偏离重点的大讨论。
- en: 'In this chapter, we will go into detail on how we can leverage domain-driven
    design in the context of a growing project, in particular:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍如何在不断增长的项目中利用领域驱动设计，特别是：
- en: Using and extending the language of the project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和扩展项目的语言
- en: Managing the context of the domain and its sub-domains
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理领域及其子领域的上下文
- en: The building blocks of a domain-driven project, aggregates, entities, value-objects,
    and services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动项目的构建块，聚合、实体、值对象和服务
- en: Building a common language
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立一个共同的语言
- en: We can't make every developer constantly aware of the project as a whole, but
    we can make the decisions very clear and the structure very intuitive to use through
    the establishment of a common language that is shared inside the project. A developer
    who looks at a piece of unfamiliar code should be able to figure out what it does
    and where it belongs in the system's context as a whole, if they are familiar
    with the language used throughout the project. Even as a project grows in a domain
    and the language of the sub-domain becomes more pronounced and starts to focus
    more on the specific parts of the sub-domain it is used in, it is important to
    keep an overall structure in place. As a developer of one sub-domain, I should
    not feel lost looking at a separate sub-domain as the language of the overarching
    domain maintains a global context for me to follow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法让每个开发人员始终了解整个项目，但我们可以通过建立项目内部共享的通用语言，使决策非常清晰，结构非常直观。熟悉项目中使用的语言的开发人员应该能够弄清楚陌生代码的作用以及它在整个系统上下文中的位置。即使在一个领域中项目增长并且子领域的语言变得更加突出并开始更专注于子领域的特定部分，保持整体结构也是很重要的。作为一个子领域的开发人员，当我看到另一个子领域时，我不应该感到迷失，因为总体领域的语言为我提供了一个全局上下文。
- en: We have been building a common language so far by taking words from the business
    domain and using them in the application. A business expert is able to broadly
    understand what each component is about, and how the components will interact.
    It is also important to build this language as we grow, with developers contributing
    new words to the business domain to disambiguate elements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在通过从业务领域中获取单词并在应用程序中使用它们来建立一个共同的语言。业务专家能够大致了解每个组件的内容以及组件之间的交互方式。随着我们的发展，构建这种语言也很重要，开发人员可以为业务领域贡献新的单词，以消除元素的歧义。
- en: These kinds of contributions are not only valuable to developers, as they are
    now able to clearly communicate what a certain element is, they are also beneficial
    for business experts as they can now communicate more clearly as well. If a term
    fits well, it will be adapted by the domain; if it does not, then it is better
    to drop it in most cases. To do this, we must first be make ourselves aware of
    what kind of patterns are available to us and use the terms already provided to
    us to let them influence the language we use throughout.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些贡献不仅对开发人员有价值，因为他们现在能够清楚地传达某个元素是什么，而且对业务专家也有益，因为他们现在也能更清楚地传达信息。如果一个术语很合适，它将被领域所采纳；如果不合适，那么在大多数情况下最好放弃它。为了做到这一点，我们必须首先意识到我们可以使用哪些模式，并使用已经提供给我们的术语来影响我们在整个过程中使用的语言。
- en: The importance of object classification
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象分类的重要性
- en: 'Developers like to classify things, as we saw earlier when describing why naming
    things like `SomethingManager` is harmful. We like to classify things because
    it gives us a way to make assumptions about the object we are dealing with. Describing
    the purpose of a certain element is not only problematic and error-prone in the
    business domain, but also in the programming domain. We want to be able to quickly
    associate certain parts of the code with certain problems. While a ubiquitous
    language solves this part in the business domain, we can draw from patterns to
    better describe our programming problems. Let''s take a look at an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员喜欢对事物进行分类，就像我们之前讨论为什么命名类似`SomethingManager`是有害的时候所看到的那样。我们喜欢对事物进行分类，因为这样可以让我们对我们正在处理的对象做出一些假设。描述某个元素的目的不仅在业务领域中存在问题且容易出错，而且在编程领域中也是如此。我们希望能够快速地将代码的某些部分与特定问题关联起来。虽然通用语言解决了业务领域中的这一部分，但我们可以借鉴模式来更好地描述我们的编程问题。让我们来看一个例子：
- en: '**Developer 1**: Hi, let''s talk about the code to transform between our domain
    objects and the persistence.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者1：嗨，让我们谈谈代码，以便在我们的领域对象和持久性之间进行转换。
- en: '**Developer 2**: Yes, I think there is a lot of room to optimize here. Have
    we ever looked at something provided by an outside company here?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者2：是的，我认为这里有很大的优化空间。我们有没有看过外部公司提供的东西？
- en: '**Developer 1**: Yes, we have, but we have very special needs and the common
    available alternatives seem to be not performing well enough for us.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者1：是的，我们有，但我们有非常特殊的需求，而常见的可用替代方案似乎对我们来说性能不够好。
- en: '**Developer 2**: Oh, okay. I was under the impression our home grown version
    has trouble with threading and is overall not that performant.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者2：哦，好的。我印象中我们自己开发的版本在处理线程方面有问题，整体性能也不太好。
- en: '**Developer 1**: I don''t think we need to talk about threading here, this
    should be handled at a lower level.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者1：我认为我们不需要在这里讨论线程，这应该在更低的层次处理。
- en: '**Developer 2**: Wait, are we not talking about the database connection here?
    How much lower do you want to get?'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者2：等等，我们现在不是在讨论数据库连接吗？你想要降到多低的层次？
- en: '**Developer 1**: No, no! I''m talking about the transformation of domain objects
    to database objects as we translate the fields to the right types and the column
    names and so on.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者1：不，不！我在谈论将领域对象转换为数据库对象，因为我们需要将字段转换为正确的类型和列名等等。
- en: '**Developer 2**: Oh, in this case you are talking to the wrong person. I''m
    not familiar with this part, sorry.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者2：哦，在这种情况下，你找错人了。对这部分我不太熟悉，抱歉。
- en: This conversation is likely to happen when bad naming creeps into a project.
    Developer 1 is talking about what would commonly be known as a **Data Mapper Pattern**,
    while Developer 2 is talking about the database API. Having commonly accepted
    names not only eases the conversation, but also lets certain developers much more
    easily express which part of the code they are more or less familiar with.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当糟糕的命名潜入项目时，这种对话很可能会发生。开发者1谈论的通常被称为**数据映射器模式**，而开发者2谈论的是数据库API。拥有通常被接受的名称不仅使对话变得更容易，而且还让某些开发人员更容易地表达他们对代码的哪一部分更熟悉或不太熟悉。
- en: Patterns are most commonly used for naming programming techniques, for example,
    the Data Mapper Pattern describes a way to deal with the interaction between objects
    and their persistence to a database.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模式最常用于命名编程技术，例如，数据映射器模式描述了处理对象与它们对数据库的持久性之间的交互的一种方式。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: A Data Mapper performs a bidirectional transfer of data between a persistent
    data store and the in-memory data representation of domain objects or data structures
    like it. It was named in *Patterns of Enterprise Application Architecture*, *Martin
    Fowler*, *Pearson*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据映射器执行持久数据存储和领域对象或类似它的内存数据表示之间的双向数据传输。它在*企业应用架构模式*，*Martin Fowler*，*Pearson*中被命名。
- en: In domain-driven design, we also have *certain* way of dealing with certain
    kinds of objects and their relationships. On the one hand, there are patterns
    for organizing the development itself, and on the other hand there are names given
    to objects that fulfill a specific purpose. This kind of classification is what
    this chapter is all about. We build an understanding of certain domain elements
    by making them into concrete implementations of certain domain-driven design concepts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the bigger picture
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with a large project, the most common problem is to figure out
    what the guiding idea behind the design is. When a piece of software grows large,
    it is likely that the project comprises of more than one project but is actually
    split into sub-projects, each responsible for its own API and design. In terms
    of domain-driven design, there are domains and sub-domains. Each sub-domain carries
    its own context; in domain-driven design this is the bounded-context. The separate
    contexts together with the relationship of the main domain and its sub-domains
    hold the knowledge together in a conclusive whole.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the server side, there is a move towards service-oriented architecture, which
    introduces quite a hard split between certain elements of the project by separating
    them out into different components that are run separately.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there has always been the concept of packages that define their own
    visibility. JavaScript is somewhat lacking in this area as all the code is traditionally
    run in the browser under one thread. This does not mean of course that all is
    lost, as we can separate namespaces by convention and tools like **npm** and **browserify**
    now enable us to use backend like separation on the frontend as well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Supporting the process of looking up certain parts of the code, as well as
    figuring out what can be shared in between different parts of the domain, is a
    problem that has been tackled in multiple ways by different languages. As JavaScript
    is very dynamic, it means that there has never been a strict way to enforce privacy
    of certain parts in the language itself, for example keywords such as `private`.
    It is, however, possible to hide certain details, if we choose to do so. The following
    code uses a JavaScript pattern to define private properties and functions in the
    object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This style of coding is possible, but it is not very idiomatic. In JavaScript,
    programmers tend to trust their fellow programmers to do the right thing and assume
    that if somebody wants to gain access to a certain property, he or she will have
    a good reason for it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great feature of object orientation often mentioned is that it hides the details
    of implementation from others. Depending of the environment you work in, the reason
    for hiding details is often different. While most Java developers go to great
    lengths to prevent others from touching "their" implementation. Most developers
    of JavaScript tend to interpret it as the fact that others developers shouldn't
    need to know how things work, but if they want to reuse internal parts they are
    free to do so and have to deal with the consequences. It is hard to say what works
    better in practice.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The same is true on a higher level of abstraction; it would be possible to hide
    a lot of details but in general, packages tend to be quite open to expansion exposing
    an inner structure if a programmer wants to get to it. JavaScript itself, and
    its culture, don't lend themselves nicely to hiding details effectively. We can
    go to great lengths to achieve this effect, but it would go against the principles
    people expect from the software.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Even though hiding many details completely is hard, we still need to maintain
    consistency in our application. This is what we use aggregates for, which encapsulate
    a set of functionality to expose through a coherent interface. For our domain-driven
    design, we need to be aware of this fact; by using the right language and patterns,
    we need to guide other programmers through our code. We want to provide the right
    context in the right situation by naming consistently and guiding the use of domain
    related names through tests explaining the level a certain piece of functionality
    is located at. When we classify certain parts of the software as an aggregate,
    we show the next developer that the safe way to access the functionality is through
    this aggregate. With this in mind, even though it is still possible to reach inside
    and inspect the inner details, you should only do this if you have a very good
    reason to do so.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Value objects
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with objects in various languages, including JavaScript, objects
    are almost universally passed and compared by reference, which means that an object
    that is passed to a method does not get copied, but rather its pointer gets passed,
    and when two objects are compared, their pointers are compared. This is not how
    we think about objects and especially value objects, as we think of those as identical
    if their properties are identical. More importantly, we don''t want to consider
    the inner implementation details when we consider things like equality. This has
    some implications for the function using the object; one important implication
    is that modifying the object will actually change it for everybody in the system,
    for example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Related to this is the fact that comparing does not always yield the expected
    result as in this case:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even though this might be obvious to us as programmers, it really is not capturing
    the intention of the objects in the domain. In the real world, having two 50-cent
    coins and considering them different is not convenient, for example, in the domain
    of payment. It does not make sense for a shop to accept a certain 50-cent coin
    while rejecting another. We would like to compare our coins by the value they
    represent, rather than the physical form. On the other hand, coin collectors will
    think quite differently about the problem, and for them a certain 50-cent coin
    might be worth a fortune, while a generic one is not. The comparison of objects
    and their identity always has to be considered in the context of the domain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: If we decide to compare and identify an object in a software system by its property
    value rather than its intrinsic identity, we have an instance of a value object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of value objects
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects that are passed around and can be modified can cause unexpected behavior,
    and depending on the domain, comparing objects by identity can be misleading.
    In those kind of situations, declaring a certain object as a value object can
    save you a lot of trouble down the road. Making sure an object is not modified
    in turn makes it easier to reason about any code interacting with it. This is
    because we don't have to look at the dependencies down the line, as we can just
    use the object as it is.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has support for these kinds of objects built in; using the `Object.freeze`
    method will make sure that no changes can happen to the object after it has been
    frozen. Adding this to the construction of the object will let us be confident
    that the object will always behave as we expect it to. The following code constructs
    an immutable value object using `freeze`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A noteworthy addition to JavaScript was the `use strict` directive. If we do
    not use this directive, the assignment to the value property would silently fail.
    Even though we can still be sure that no changes will happen, this will cause
    some blank stares at the code. So even if it is mostly left out in this book in
    order to keep the code samples short, the use of `use strict` is highly recommended.
    You can use **JSLint** to enforce this, for example ([http://www.jslint.com/](http://www.jslint.com/)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的一个值得注意的补充是`use strict`指令。如果我们不使用这个指令，对值属性的赋值将会悄悄失败。即使我们仍然可以确保不会发生任何更改，这也会导致代码中出现一些茫然的表情。因此，即使在本书中大部分时间都没有提到，为了使代码示例简短，强烈建议使用`use
    strict`。例如，您可以使用**JSLint**来强制执行此操作（[http://www.jslint.com/](http://www.jslint.com/)）。
- en: 'When dealing with value objects, it is also a good idea to provide a function
    to compare them against each other, whatever that means in the current domain.
    In the coin example, we would want to compare them by the value of the coin, so
    we provide an `equals` function to do this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理值对象时，还可以提供一个函数来比较它们，无论在当前领域中意味着什么。在硬币的例子中，我们希望通过硬币的价值来比较它们，因此我们提供了一个`equals`函数来实现这一点：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `equals` function makes sure we are dealing with coins, and if so checks
    if they have the same value. This makes sense in the domain of payment, but might
    not necessarily hold true everywhere else. It is important to note that the fact
    something is a value object in a certain domain does not mean this is universally
    true. This becomes specifically important when dealing with the relationship of
    projects inside an organization. It can very well be necessary to have separate
    definitions of similar things because they are regarded in different ways across
    applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`函数确保我们正在处理硬币，并且如果是的话，检查它们是否具有相同的价值。这在支付领域是有意义的，但在其他地方可能并不一定成立。重要的是要注意，某些领域中的某些东西是值对象并不意味着这在普遍意义上也是如此。当处理组织内部项目的关系时，这一点变得特别重要。可能需要对类似的事物进行不同的定义，因为它们在不同的应用程序中以不同的方式被看待。'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The preceding code uses the *__proto__* property of an object, which is an internally
    managed property pointing to the prototype of an object and was a recent addition
    to JavaScript. Even though this is very convenient, we can always get to the prototype
    via `Object.prototype` (object) if necessary and if *__proto__* is not available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了对象的`__proto__`属性，这是一个内部管理的属性，指向对象的原型，是JavaScript的一个最近的补充。尽管这非常方便，但如果必要的话，我们总是可以通过`Object.prototype`（对象）来获取原型，如果`__proto__`不可用的话。
- en: Of course, just having a method to compare does not mean everybody will use
    it in all situations, and JavaScript does not provide a way to enforce it. This
    is one place where the domain language comes to save us. Spreading the knowledge
    about the domain will make it clear to fellow developers what should be considered
    a value object, and the ways to compare it. This might be a good idea in a situation
    where you are documenting the class in use and need to provide the next person
    with some details.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅有一个比较的方法并不意味着每个人都会在所有情况下使用它，而JavaScript也没有提供强制执行的方法。这是一个领域语言能够帮助我们的地方。传播关于领域的知识将使其他开发人员清楚地知道什么应该被视为值对象，以及比较它的方法。在使用类并需要向下一个人提供一些细节时，这可能是一个不错的主意。
- en: The referential transparency
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用透明度
- en: 'The `Coin` objects we have been working with have another interesting property,
    which could be useful in our system, and this is that they are referentially transparent.
    This is a very fancy way of saying whenever we have a coin, it does not matter
    what we do with it, as it will be regarded as the same in every part of the application.
    We are therefore free to pass it to other functions and keep a hold of it without
    having to worry about it changing. We also don''t need to follow the coin as a
    dependency, checking what might have happened to it before or how it might be
    changed by other functions in case we pass it along. The following code illustrates
    the simple usage of a coin object constructed as a value object. Even though the
    code depends on it we don''t need to take special care of interacting with the
    object as it is defined as an immutable value object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用的`Coin`对象还有另一个有趣的属性，这对我们的系统可能很有用，那就是它们是引用透明的。这是一个非常花哨的说法，意思是无论我们对硬币做什么，它在应用程序的每个部分都会被视为相同。因此，我们可以自由地将其传递给其他函数，并保持它，而不必担心它的变化。我们也不需要跟踪硬币作为依赖项，检查在传递它时可能发生了什么，或者它可能被其他函数改变了。下面的代码说明了构造为值对象的硬币对象的简单用法。即使代码依赖于它，我们也不需要特别小心地与对象交互，因为它被定义为不可变的值对象。
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the preceding example is a save operation with only one dependency – the
    wallet, to watch with the `Coin` being a value object, it would be much more complicated
    if the `Coin` object is an entity. The `checkIfValid` function might change attributes
    and we would therefore have to investigate what happens inside.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，只有一个依赖项 - 钱包的保存操作，如果`Coin`是一个值对象，那么情况就会复杂得多。`Coin`对象是一个实体的话，`checkIfValid`函数可能会改变属性，因此我们必须调查内部发生了什么。
- en: 'Not only does the value object make the code flow easier to follow, referential
    transparency is a very important factor when it comes to dealing with caching
    objects across the lifetime of our application. Even though JavaScript is single-threaded,
    so we don''t have to worry about objects being modified by other threads, we have
    seen that objects can still be modified by other functions, and they also might
    change for other reasons. With a value object, we never have to worry about this,
    so we are free to save it for later and refer to it whenever we need to. In between
    functions, an event might occur that leads to the modification of objects we are
    currently working with, and this can make it very hard to track down bugs. In
    the following code, we see a simple usage of the `EventEmitter` variable and how
    we can use it to listen to a `"change"` event:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象不仅使代码流程更容易跟踪，引用透明性在处理应用程序生命周期内的缓存对象时也是一个非常重要的因素。尽管 JavaScript 是单线程的，所以我们不必担心对象被其他线程修改，但我们已经看到对象仍然可以被其他函数修改，它们也可能因其他原因而改变。有了值对象，我们就不必担心这一点，因此我们可以自由地将其保存起来，以后需要时引用它。在函数之间，可能会发生事件导致我们当前正在处理的对象被修改，这可能会使跟踪错误变得非常困难。在下面的代码中，我们看到了`EventEmitter`变量的简单用法，以及如何使用它来监听`"change"`事件：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Looking at just the functions `doStuff` and `doMoreStuff`, we would expect to
    see a 10 printed to the console, but it actually prints 11 as the event change
    is interleaved. This is pretty obvious in the previous example, but dependencies
    like this can hide deep inside the code, crossing many more functions. Value objects
    make the same mistake impossible, as the change to the object would have been
    prohibited. This is not the end to all errors in asynchronous programming, of
    course, and more patterns are needed to make sure this works as expected; for
    most use cases I would recommend a look at **async** ([https://github.com/caolan/async](https://github.com/caolan/async)),
    a library to help with all kinds of asynchronous programming tasks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 仅查看`doStuff`和`doMoreStuff`函数，我们期望在控制台上看到10被打印出来，但实际上打印出了11，因为事件`change`是交错的。在前面的例子中这是非常明显的，但是这样的依赖关系可能深藏在代码内部，跨越更多的函数。值对象使相同的错误变得不可能，因为对象的更改将被禁止。当然，这并不是异步编程中所有错误的终点，需要更多的模式来确保这样的预期工作；对于大多数用例，我建议查看**async**([https://github.com/caolan/async](https://github.com/caolan/async))，这是一个帮助处理各种异步编程任务的库。
- en: Objects defined as entities
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为实体定义的对象
- en: As we have seen, having objects primarily defined by their properties can be
    really useful and helps us deal with a lot of scenarios when designing a system.
    So, we often see that certain objects have a different lifecycle attached to them.
    In such a case, the object is defined by its ID, and in domain-driven design terms,
    it is considered an entity. This is a contrast to value objects that are defined
    by their properties, and are considered to be equal when their properties match.
    An entity is only ever equal if it has the same ID, even if all the properties
    match; as long as the ID is different, the entity is not the same.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，通过其属性主要定义对象可以非常有用，并帮助我们处理系统设计中的许多场景。因此，我们经常看到某些对象具有与它们相关的不同生命周期。在这种情况下，对象由其ID定义，在领域驱动设计术语中，它被视为实体。这与值对象相反，值对象由其属性定义，当它们的属性匹配时被视为相等。只有当实体具有相同的ID时，它才是相等的，即使所有属性匹配；只要ID不同，实体就不相同。
- en: Entity objects manage the lifecycle inside the application; this can either
    be the lifecycle spread across the application as a whole, but it might well be
    a transaction happening in the system. In the dungeon, we are dealing with a lot
    OF cases where we don't really care about the lifecycle of an object itself, but
    rather WE care about its attributes. Staying with the prisoner transport example,
    we know that it comprises many different objects, but most of them could be implemented
    as value objects. We do not really care about the lifecycle of the orc guard accompanying
    the transport, and we are fine as long as we know there is one and that he is
    armed to protect us.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实体对象管理应用程序内部的生命周期；这可以是整个应用程序中的生命周期，但也可能是系统中发生的事务。在地牢中，我们处理了许多情况，我们实际上并不关心对象本身的生命周期，而是关心它的属性。以囚犯运输为例，我们知道它包括许多不同的对象，但其中大多数可以实现为值对象。我们并不真的关心随行的兽人守卫的生命周期，只要我们知道有一个守卫，并且他有武器保护我们就可以了。
- en: 'This might seem a little seem counterintuitive as we know we need to take care
    about the assignment of orcs as we don''t have an infinite number of them, but
    really there are two separate concepts hiding inside, one being the `Orc` as a
    value object and the other being its assignment to guard the transport. The following
    code defines an `OrcRepository` function, which can be used to get orcs under
    controlled circumstances and use them. This pattern can be used to control access
    to a shared resource in conjunction with most likely database access encapsulated
    within:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点违直觉，因为我们知道我们需要注意分配兽人，因为我们没有无限数量的兽人，但实际上里面隐藏着两个不同的概念，一个是`Orc`作为值对象，另一个是它被分配来守卫运输。下面的代码定义了一个`OrcRepository`函数，它可以用于在受控情况下获取兽人并使用它们。这种模式可以用于控制对共享资源的访问，通常与最有可能封装在其中的数据库访问一起使用：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While the `Orc` object itself might be a value object, the assignment needs
    to have a lifecycle, defining the start, the end, and the availability. We would
    need to get an orc from a repository of `Orc` objects, fulfilling the need to
    be able to guard the transport and return it as soon as the transport is done.
    In the preceding case, the `Orcs` repository is an entity, so we need to make
    sure that it is managed correctly otherwise we might end up with incorrect orc
    counts or unrecorded weapons, as both are bad for business. The orc in this case
    can be passed around freely, and we are isolated from its management.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Orc`对象本身可能是一个值对象，但分配需要具有生命周期，定义开始、结束和可用性。我们需要从`Orc`对象的存储库中获取一个兽人，满足能够在运输过程中保护并在运输完成后立即归还的需求。在前面的情况下，`Orcs`存储库是一个实体，因此我们需要确保它被正确管理，否则我们可能会得到不正确的兽人数量或未记录的武器，这两者对业务都不利。在这种情况下，兽人可以自由传递，我们与其管理隔离开来。
- en: More on entities
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于实体的内容
- en: Entities come up regularly when building an application, and it is easy to fall
    into the trap of making most objects in the system entities, instead of value
    objects. The important thing to keep in mind is that value objects can perform
    a lot of work, and that dependencies on value objects are "cheap".
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，实体经常出现，很容易陷入使系统中的大多数对象成为实体而不是值对象的陷阱。要牢记的重要事情是值对象可以执行大量工作，并且对值对象的依赖是“便宜”的。
- en: 'So why are dependencies on value objects "cheaper" than a dependency on an
    entity? When dealing with entities, we have to deal with state, so any modification
    being made can have an impact on other subsystems using this entity in their processing.
    The reason for this is the fact that each entity is a unique thing that can change,
    while a value object boils down to a collection of properties. When we pass around
    entities, we need to synchronize the consumers on the state of the entity, and
    possibly on all its dependent entities as well. This can get out of control very
    quickly. The following code shows complication when dealing with the interaction
    of multiple entities. We need to control multiple aspects when keeping the Wallet,
    inventory and the orc itself in a consistent state when adding and removing items:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么对值对象的依赖比对实体的依赖“更便宜”呢？当处理实体时，我们必须处理状态，因此对实体进行的任何修改都可能对使用该实体的其他子系统产生影响。造成这种情况的原因是每个实体都是一个可以改变的独特事物，而值对象归结为一组属性。当我们传递实体时，我们需要同步实体的状态，可能还需要同步所有依赖实体的状态。这可能会很快失控。以下代码显示了处理多个实体交互时的复杂性。在添加和删除物品时，我们需要控制钱包、库存和兽人本身的多个方面，以保持一致的状态：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we need to make sure that the buy action is not interrupted because
    a strange behavior could occur depending on other implementations. This would
    get even worse if the inventory had more behavior associated with it, such as
    a size check, then we would need to coordinate the two checks while making sure
    we can roll back without being interrupted. We have seen before how events can
    cause us a lot of problems here and this gets unwieldy fast. Even though it is
    of course unavoidable to deal with this at some level, being aware of the problems
    is important.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要确保购买行为不会被中断，因为根据其他实现可能会出现奇怪的行为。如果库存有更多与之相关的行为，比如大小检查，那么我们需要在确保可以无中断地回滚的同时协调这两个检查。我们之前已经看到事件如何在这里给我们带来了很多问题，这会很快变得难以控制。尽管在某个级别上不可避免地需要处理这个问题，但意识到这些问题是很重要的。
- en: Entities need to have their lifecycle controlled in a way that makes sure there
    is no inconsistent state present. This makes handling entities more complicated
    and can also have an impact performance on due to locking and transaction control.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实体需要以确保不存在不一致状态的方式来控制它们的生命周期。这使得处理实体更加复杂，也可能会影响性能，因为需要进行锁定和事务控制。
- en: Managing the application's lifecycle
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序的生命周期
- en: Entities and aggregations are all about managing this cycle at every level of
    the application. We can think about the application itself being the aggregation
    wrapped around all its components to manage the attached value objects and contained
    entities. At the level of our prisoner transfer, we treat the transfer itself
    as a transaction wrapping all the local dependents, and managing the eventual
    result of either a successful transfer or a failed one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实体和聚合都是关于在应用程序的每个级别管理这个周期。我们可以将应用程序本身视为包装在其所有组件周围以管理附加值对象和包含实体的聚合。在我们的囚犯转移级别上，我们将转移本身视为包装所有本地从属者的事务，并管理最终结果，无论是成功的转移还是失败的转移。
- en: It is always possible to push the lifecycle management further up or down the
    chain of objects, and finding the right level can be hard. In the previous example,
    the assignment might as well be a value object managed by an aggregate up the
    chain to ensure its constraints are satisfied. The right level of abstraction
    at this stage is a decision that the developers of the system have to make. Pushing
    the transaction control too high and then making the transaction span more objects
    can be costly as the locks are more coarse and therefore concurrent operations
    are hindered; pushing it too low can result in a complex interaction between the
    aggregates.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 始终可以将生命周期管理进一步推到对象链的上方或下方，并找到合适的级别可能很困难。在前面的例子中，分配也可以是一个值对象，由对象链上的聚合管理，以确保满足其约束。在这个阶段，正确的抽象级别是系统开发人员必须做出的决定。将事务控制推得太高，然后使事务跨越更多对象可能会很昂贵，因为锁更粗糙，因此并发操作受到阻碍；将其推得太低可能会导致聚合之间的复杂交互。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Deciding the right level of abstraction to manage the lifecycle has a deeper
    influence into the application than is visible at first. Since entities are managed
    by their ID while being mutable, this means they are objects that need to be synchronized
    when dealing with concurrency, and because of this it influences the concurrency
    of the system as a whole.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Aggregations
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object orientation relies heavily on combining the functionality of multiple
    collaborators to achieve certain functionality. When building systems, there is
    often the problem that certain objects attract more and more functionality, and
    in that, becoming a kind of god object that is involved in almost every interaction
    in the system. The way around this is to let multiple objects collaborate to achieve
    the same functionality, but as a sum of small parts instead of one large object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Building up those interconnected subsystems has a different problem, in that
    it tends to expose large and complex interfaces as the user needs to know more
    about the internals to use the system as the objects structure is being build
    up. Letting a client handle the internals of a subsystem is not a good way to
    model such a system, and this is where the concept of aggregation comes into play.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: An aggregation allows use to expose one consistent interface to our clients
    and let them deal only with the parts they need to provide to make the system
    function as a whole, and let the outside entry point handle the different internal
    parts. In the previous chapter, [Chapter 4](ch04.html "Chapter 4. Modeling the
    Actors"), *Modelling the Actors*, we talked about aggregation in the example of
    a horse carriage being made up of all the elements needed to make it work as a
    whole. The same concept applies to other levels as well, and each subsystem we
    build is a kind of aggregation of its parts, comprising of entities and value
    objects along the way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Grouping and interfaces
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The questions we need to ask ourselves as developers are, at that point during
    our development, how do we group parts, where are the interfaces governing those
    aggregations best built, and what should they look like? Even though there is,
    of course, no strict formula for this, there are parts described in the following
    that can be used as guidance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces should only require a client to provide the parts it actually cares
    about as being flexible, which often means that there are multiple entry points
    to a subsystem and clients touching a system through different points might step
    on others'' toes along the way. We can borrow some classic techniques at this
    point and provide so-called `factory` methods to give us the entry point to the
    object graph that we need. This allows use to create an easily readable syntax
    instead of trying to take advantage of all the dynamic ways of to make the object
    creation flexible and accept very different parameters to provide the same functionality.
    The following code shows this kind of factory in the context of creating an orc.
    We want to have the object constructor as flexible as possible, while providing
    factory methods for the common case:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we could have detected missing attributes and reshuffled the
    input parameters to ensure that generating an orc works with every kind of combination,
    but this quickly becomes unwieldy. As soon as the collaborators are no longer
    just simple strings like picked here for simplicity, we need to interact with
    more objects and control more interaction. By providing a factory function, we
    can express exactly what we intend to provide and don't need to resort to very
    complex handling.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the goal of grouping collaborators in aggregates and providing different
    interfaces for the access is to control the context, as well as to engrain the
    language of the domain more deeply in the project. Aggregates are there to provide
    a simpler view of the model data they aggregate to protect against inconsistent
    usage.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Services
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we have been expressing concepts around "things", but there are certain
    concepts that are best expressed around the act of doing something, and this is
    where services come in. Services are a first class element of domain-driven design,
    and their goal is to encapsulate actions in the domain that involves the coordination
    of many collaborators.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"[…]Verbs in Javaland are responsible for all the work, but as they
    are held in contempt by all, no Verb is ever permitted to wander about freely.
    If a Verb is to be seen in public at all, it must be escorted at all times by
    a Noun.**Of course "escort", being a Verb itself, is hardly allowed to run around
    naked; one must procure a VerbEscorter to facilitate the escorting. But what about
    "procure" and "facilitate?" As it happens, Facilitators and Procurers are both
    rather important Nouns whose job is is the chaperonment of the lowly Verbs "facilitate"
    and "procure", via Facilitation and Procurement, respectively.[…]"* |   |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '|   | --*- Steve Yegge - Thursday, March 30, 2006 - Execution in the Kingdom
    of Nouns* |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: 'Services are a very useful but also often abused concept, and they come down
    to naming in general. The act of doing something can either be expressed in terms
    of a "thing" doing or naming the "doinger". For example, we could have a `Letter`
    and call the `send` method on it, letting it decided what to do and passing it
    the collaborators needed, for example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The alternative is to have a service that handles the sending of the letter
    and calls it in a stateless way, passing all the collaborators to the service
    upon construction:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In a simple example, it is very obvious that the second approach seems complicated
    and does not add to the domain language of sending letters in any meaningful way.
    In more complex code, this is often overlooked because the complexity of a certain
    action needs to live somewhere. Which approach to choose comes down to the amount
    of functionality that can be encapsulated in the service. When a service exists
    only to split out a piece of code into a now separate but kind of homeless piece,
    a service is probably a bad idea. If we are able to encapsulate domain knowledge
    in the service, then we will have a valid reason to create one.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Having one object being named after what it does and having only one method
    in it which is actually the action should raise a red flag for any object-oriented
    programmer. Good services add to the domain and express a concept that has a solid
    foundation in the domain itself. This means there are names to express this concept.
    Services can encapsulate those concepts not directly backed by "things", and they
    should be named according to the domain.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Associations
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw that the delivery of a letter is dependent on
    a postman. There is a certain relationship between the letter and the person who
    delivers it, but depending on the domain, this relationship might not be a very
    strong or relevant one. It could be relevant for our dungeon master to know who
    delivered which letter, for example, in case every deliveryman is instantly imprisoned
    and held responsible for the content of the post he or she delivers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The ways of the orcs might not be as understandable as the rules of business
    often are. In this case, we would want to make sure that we put a label on each
    letter and the postman who delivered it, associating the letter with a certain
    person. The other way around is not relevant. As we model this in our domain,
    we want to carry this important knowledge across and have a way to associate the
    message in the process of delivery with the appropriate deliveryman. In code this
    can be done more easily; we might for example create a history for the letter,
    where each collaborator being associated with the delivery is linked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The concept of associations between domain models is an integral part of the
    domain design, as most objects of whatever form will not work in complete independence.
    We want to codify as much knowledge as possible in the associations. When we think
    about associations between objects, the association itself can hold domain knowledge
    that we want to have incorporated in our model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Insight during implementation
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of patterns is well established across object-oriented languages
    as well as other types. Many books have been written on it, and many discussions
    have been had that deal with encoding the knowledge of many developers in patterns
    to be used in enterprise, as well as other kinds of software. In the end, it comes
    down to using the right pattern at the right point during development, which is
    not only true for domain patterns but other software patterns as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In his book *Patterns of Enterprise Application Architecture*, Martin Fowler
    not only discusses the available options to deal with communication to a database
    by means of a `DataMapper` plugin plus domain layer, Transaction Scripts, Active
    Record, and so on, but also discusses when to use them. As with most things, the
    conclusion in the end is so that all choices have good and bad sides to them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When working on software, there are multiple insights to gain as we move forward.
    A very valuable insight is the introduction of a new concept that was not clear
    before. To reach such a point there is no obvious way, what we can do is to start
    classifying the patterns we currently have in the software and making them as
    clear as possible to make the discovery of new concepts more likely. With a set
    of well separated pieces, discovering missing pieces if more likely to happen.
    When we are thinking about domain patterns, especially the various ways that we
    can classify certain elements of the application, the ways to classify are not
    always as clear as we would like them to be.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing domain patterns
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the example of handling sending the letter, we noticed that even
    though the proposed option uses a service to handle the collaboration, there are
    other ways to go about this. The problem with small examples like we have in this
    book is that it is hard to convey when a certain option has a benefit or when
    a certain design is overkill in the general context; this is especially true for
    complex architecture as domain-driven design is, after all if the application
    is done in a couple hundred lines of code, many problems the domain-driven design
    solves are not present.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: When we write the code for a certain feature, we always need to be aware of
    the fact that the design of the components is not set in stone. An application
    might start out with a lot of entities being present, handling most interactions
    inline, as the system has not evolved enough yet to have a clear view on which
    interactions are complex and important enough to have them as a domain concept.
    Also, often the fact that we *use* the software means we recognize certain concepts,
    and by use as developers, I mean touching the interfaces and extending the software
    as a whole.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Not everything is an entity
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, in domain-driven design it is easy to create entities for everything.
    The idea of an entity is a very common one in the mind of developers. Objects
    always have a fixed identity when we think about them as things in memory, and
    most languages by default compare this way, for example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This makes it easy to just expect everything to be an entity, with its ID being
    whatever JavaScript considers it to be.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: When we think about the domain, this of course does not always make sense, and
    we quickly start to recognize that certain things are not identified this way,
    which often moves certain parts of the application towards the use of value objects,
    for example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Starting out as simple as possible is a good thing, but what makes the project
    a great place to work on over time is taking as many opportunities as possible
    to make things better. Even if the route does not end up being the one taken,
    the mere act of trying it makes the code better.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **primitive obsession** anti-pattern is a trap often fallen into when not
    refactoring early and often. The problem is that new objects are introduced rarely
    and many concepts are represented by primitives, like an email as a string, or
    money values as pure integers. The problem is that the primitives don't encapsulate
    all the knowledge but just the pure property, and this leads to duplication of
    knowledge all over the place where a named concept such as an e-mail or a money
    object could have been shared.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring all the time towards malleable code
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we start to work toward letting the code guide our design in different
    ways, we notice the places that are continually changing, and the ones that trouble
    us with most new features, or even refactoring being implemented. Those are the
    pain points that we need to address.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *In object-oriented programming, the single responsibility principle
    states that every class should have responsibility over a single part of the functionality
    provided by the software, and that responsibility should be entirely encapsulated
    by the class. All its services should be narrowly aligned with that responsibility*
    |   |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '|   | --*– the Single Responsibility Principle according to Wikipedia, originally
    defined by Robert C. Martin* |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: We want our changes to be localized, and exploring a different route for the
    implementation of a certain feature should touch the least amount of code possible.
    This is the purpose of the **Single Responsibility Principle**, as defined by
    Robert C. Martin, which defines a responsibility as a reason to change. Together
    with the **Open/closed principle**, making code open for extension but closed
    for modification, this leads to code being easy to work with due to known seams
    and building blocks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The goal of domain-driven design is to take the concepts of object-oriented
    programming and take them to a higher level, so most concepts of object orientation
    apply to domain-driven design, as well. Whereas in object orientation we want
    to encapsulate objects, in domain driven design we encapsulate domain knowledge.
    We want each subsystem and each element of our domain to be as independent as
    possible and if we achieve this, the code will be easy to change along the way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Implementing language guidance
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain-driven design is all about encapsulating domain knowledge and the guiding
    force to contain and distribute knowledge is language. We have talked before about
    the fact that one of the goals of domain-driven design is to create a ubiquitous
    language in the project that is shared between the developers and the project
    owners or stakeholders to guide the implementation. And it has been hinted before
    that this is, of course, not a one way street.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: As domain concepts are uncovered, it is often useful to establish and name the
    new concepts as a team to make them the established way of communication. Sometimes,
    these new names and meanings can make it back into the business, they will start
    to get used to describe the now named pattern and over a long time can make it
    back in the common language used in the domain cross businesses if they are considered
    useful.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In the original book on domain-driven design, by Eric Evans, he discusses the
    development of a financial software and how terms established made it back all
    the way to the Sales and Marketing departments to describe the new features of
    the software. Even though this might not be the case with your new additions to
    the business language, if an addition is helpful, at least core parts of the business
    will adopt them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Working with and on the business language
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building a language of the domain is very different, depending on the domain.
    Very few domains already have a very specific language associated with them. If
    we look into accounting, for example, there are books written about what everything
    is called and how things interact. Similar things can also exist for established
    businesses, and even if there might not be a book to read up on it, following
    a person who does the business on a day-to-day basis can quickly reveal some concepts.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shadowing the process you are tasked to implement for a day can provide some
    very important insights. It can also hint in the areas where the business behaves
    in very specific way, those little things we as programmers otherwise come up
    against after the fact. Things that we see as illogical have a hard time fitting
    into our model.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Not many areas of business are this lucky, and especially in the world of young
    businesses developing new ideas, there is inherently a lack of established language.
    Also those businesses are most often the ones that invest heavily in a JavaScript-based
    application, so how can we deal with this?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the orc dungeon, we are dealing with a world that is very alien
    to us and that does not have a very established language to deal with its processes,
    as so far there was hardly ever a need for it. We dealt with this problem in the
    book already, as many terms are heavily overloaded in context. A notification
    could be a message to an orc to inform him that he is assigned to a certain prisoner
    transport, or a message to another dungeon to inform them of prisoners arriving,
    or a prison requesting new prisoners. How can we deal with situation?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the example of the orc master explaining to us how he would need
    to notify another dungeon:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer:** What do you need when the dungeon is overflowing with prisoners?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** No problem! Let Xaguk deal with it?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer:** As I know, Xaguk is the leader of the dungeon up north, so I
    guess you need to get a transport ready?'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** Yes, I need to message Baronk to set up a transport and Xaguk
    for him to be ready.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '*He writes down two letters and calls for his goblin helper.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** Get this to Baronk, and this to Xaguk!'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '*The goblin starts to run off, but just before he leaves the room through the
    south door, the master starts screaming.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** What are you doing? You need to get a raven and send this to
    Xaguk first!'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '*The goblin looks very confused but starts running of the other way now.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** This happens all the time—the goblin just can''t remember who
    is who, and he doesn''t have to, but he needs to get the letters to the right
    office.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer:** Ahh, so if you want to send a message to the other dungeon,
    you get a raven? When you message somebody insight the dungeon, it gets carried
    locally?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** That is right!'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Developer:** Okay, so we don''t get confused in the system, I''m just going
    to call the messaging of another dungeon, to "raven" somebody, and locally we
    just continue calling it "message." Does this make sense?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Orc master:** Yes! Hopefully the goblin will no longer mess up this way,
    as this has caused some strange conversations already.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: This is a major simplification of how things like this could evolve, but the
    important thing that we as developers should take in pieces of the language that
    the business provides and incorporate them in the domain. This not only makes
    our life easier, but also improves business communication in general.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that we need to make sure we don't force our very specific
    language into the business, that is, if a certain concept does not get adopted,
    be ready to scrap it. After all, the only thing worse than an unnamed concept
    is a confusingly named concept. Building a language needs to come from the domain,
    and should not be forced on the domain. A name that does not stick is either one
    that names an unimportant concept, or one that is not descriptive enough to stick.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If an unimportant concept is named, it often forces unnecessary attention to
    it, and this can cause trouble down the road as we might be reluctant to change
    it or to adapt to new needs when we consider it too important. Consider, for example,
    that we developed the concept of automatic prisoner cell assignment, which uses
    an algorithm to determine the optimal cell for the amount of prisoners we have.
    This seemed very important as we want the dungeon to be used as optimally as possible.
    One day, a single new prisoner arrives and the system starts the calculation determining
    the optimal cell for him, while the guard is saying, "Why is this taking so long?
    Every time! I already know where I put him, I just cram him in cell number 1!"
    This is valid user feedback—even though we might have found a way to optimally
    use the dungeon, this might not actually be important as the orc sees the amount
    of prisoners per cell in a far more relaxed way than we do. The concept of automatic
    assignment is something that never really caught on; we have never heard anybody
    talking about it, so we might as well remove the whole thing, making the system
    easier for us and the users.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Systems, of course, not only serve the users; they might also serve other systems
    along the way. So keeping in mind who is the actually user can have a major influence
    on decisions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Building context
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been talking a lot about the language we use, and how systems interact
    and what they are comprised of, but there is a higher level we need to touch as
    well: *How do systems interact with other systems?*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: In the server world, there is currently a strong focus on microservices and
    their building and interaction. The important takeaway is that having a system
    that a small team owns is easier to maintain than a system built by a larger team;
    this is only half the story, so services need to interact after all. Microservices
    are the more technical approach to the domain-driven design bounded context.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how an interaction in a microservice world can
    take place. We have a lot of small services calling each other to accomplish a
    bigger task:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Building context](graphics/B03704_05_01.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Interaction not only happens on the API level but at the developer level, as
    well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Separation and shared knowledge
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Teams working on different parts of the application need to be aware of how
    they are able to share knowledge and work together when change arises. Eric Evans
    devotes a large section of domain-driven design to the patterns we see in practice.
    We see patterns a lot in software development, be it software patterns such as
    `DataMapper`, `ActiveRecord`, or the patterns Eric Evans discusses that are about
    the process of working together.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the current world of microservices, we seem to have moved away from deep
    integration towards a more flexible way of touching other parts of the system
    only very lightly. It is still important to share a domain across the team, and
    a map of what touches what is becoming more important than ever.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone into a lot of detail on how to separate out systems
    and how to deal with concepts throughout the application, mostly on the smaller
    scale of a project, and how it interacts with the larger scale.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: There are many ideas that have been used in other places we can draw from when
    building the project, be it object-oriented design or be it software architecture
    patterns; the important thing to keep in mind is that nothing should be set in
    stone. One very important thing about domain-driven design is that it constantly
    changes, and that this change is a good thing. As soon as a project becomes too
    solid, it becomes hard to change and this means the business using it can no longer
    evolve alongside its software, which ultimately means switching to another system
    and different software, or rewriting the existing software.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will touch more on the higher level view of the intertwining
    pieces of the project as a whole, going into detail about the context that each
    part of the project is set in.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
