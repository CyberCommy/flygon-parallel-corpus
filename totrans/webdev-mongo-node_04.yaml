- en: Introducing Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we need to build a full-fledged web application, writing the whole application
    from scratch is not the best approach to take. We can use a well-maintained and
    well-written web application framework to build our application to reduce development
    effort and increase maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the Express.js web application framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the various elements of Express.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop the necessary code to bootstrap a web application using Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web application frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, a web framework makes it easier to develop a web application. Consider
    the aspect of breaking down commonly used functionality into reusable modules.
    That is exactly what frameworks do. They come with a lot of reusable modules and
    enforce a standard structure for the code so that it will be easier for developers
    across the world to go through and understand the application.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from all these advantages, web frameworks mostly get maintained by a lot
    of developers across the world. So, the effort of developers to incorporate the
    newer bug fixes and features of underlying languages is minimized to a point where
    we just need to upgrade the framework version which is being used by the application.
    So, the use of web frameworks for building web applications brings a lot of advantages
    to the development and maintenance phases of a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Express.js framework that we are going to use throughout this book is a
    **Model-View-Controller** (**MVC**) based web application framework. MVC is just
    an architectural design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Models: Models are used to represent the data or entities of the web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They align more closely with the instances, which store the data of the applicationâ€”typically
    a database or a web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views: Views are responsible for how the application gets presented to the
    end user. So, a View can be considered as the presentation layer of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Controllers: Now, you may be wondering about the role of controllers in the
    web application. Well, the role of controllers is to just glue together the models
    with the respective Views and to take care of the request from the user for a
    particular web page in our application end to end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may be a bit hard for you to grasp if you are hearing this concept for
    the first time. But after going through this chapter, you will get used to these
    concepts while we present various examples to you.
  prefs: []
  type: TYPE_NORMAL
- en: What is Express.js?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described perfectly on its home page, Express is a minimal and flexible Node.js
  prefs: []
  type: TYPE_NORMAL
- en: web application framework, providing a robust set of features for building single,
    multipage, and hybrid web applications. In other words, it provides all the tools
    and basic building blocks you need to get a web server up and running by writing
    very little code. It puts the power in focusing on writing your application and
    not worrying about the nuts and bolts that go into making the basic stuff work
    in your hands.
  prefs: []
  type: TYPE_NORMAL
- en: The Express framework is one of the most popular Node-based web frameworks and
    one of the single most popular packages available in `npm`. It is built based
    on the Sinatra web framework, which is quite popular in the Ruby world. There
    are a lot of frameworks across languages that take inspiration from Sinatra's
    simplicity, such as PHP's Laravel framework. So, Express is the Sinatra-based
    web framework in the Node.js world.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at a sample piece of code, one of the most basic implementations
    of Express, you can see how easy it is to get a web server up and running, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of Express is that it makes building and maintaining the server code
    for a website simple.
  prefs: []
  type: TYPE_NORMAL
- en: Building a complete web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beginning with this chapter, we are going to build a complete web application.
  prefs: []
  type: TYPE_NORMAL
- en: The web application that we are going to build will be a clone of a popular
    social image sharing site, [imgur.com](http://imgur.com). We'll call our site
    `imgPloadr.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements of the site are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The home page will allow visitors to upload an image as well as browse the existing
    uploaded images, which will be sorted from newest to oldest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each uploaded image will be presented via its own page that shows its title,
    description, and a large image display. Visitors will be able to like the image
    and post comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A consistently shared sidebar will be visible on both pages and will showcase
    some general statistics about the site, the most popular images, and the most
    recent comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The site will use Bootstrap so that it has a nice professional design and is
    responsive on any device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is from the home page of the completed site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03b442bd-b85f-4b44-b678-59376c2e67dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot is an image''s details page from the site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/583645f2-a488-46a8-91cd-ae0421631c8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Organizing the files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start writing any code, we want to make sure that you have a project
    folder set up correctly, with the proper folder structure to house all of the
    various files that you will be creating. Get started by creating a new folder
    for your project, and name it anything you like. Then, inside that folder, create
    additional folders to match the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each of these folders will contain important modules that we will write throughout
    the remainder of this chapter and this book.
  prefs: []
  type: TYPE_NORMAL
- en: If you use an Express-based generator through Yeoman, you will get the necessary
    folder structure and the dependencies imported with the boilerplate code. However,
    as our intention is to understand this framework, we will skip this. Visit [http://yeoman.io/](http://yeoman.io/)
    for more information on the features of `Yeoman`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to need a `package.json` file for this project, and the easiest
    way to create one of these is by simply executing the following command from the
    root of the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Respond to each of the questions as you are prompted, or simply press *Enter*
    repeatedly to accept the default values. Now, let''s install Express and its necessary
    dependencies via `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will install the Express framework in the `node_modules` folder and also
    add Express to the `package.json` file in the dependencies section. Note that
    at the time of writing this book, Express.js is in its 4.x.x versions. Here, as
    you can see, Express is a completely decoupled framework that doesn't come with
    a lot of packaged modules within itself. Instead, you can figure out the dependencies
    of your application and plug in and out of the application anytime. If you have
    been following Express development from the beginning, you must have noticed that
    these changes were introduced as a part of the Express 4.x.x versions. Prior to
    this version, Express used to come with a lot of built-in modules bundled within
    it. Here, the modules we install alongside Express are the various dependencies
    our application has when we start building the complete web application. We will
    discuss the use of each module in a later section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application's entry point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After installing Express and the necessary dependencies, the next step in developing
    the application will be to create a file which will serve as the default entry
    point of this application. We will be executing this file to start our web application,
    and it will contain the necessary code to require dependent modules and boot up
    the application to listen to a specified port on the development server.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to name the entry point file `server.js` for now and will keep
    it pretty lean so that its content is quite self-explanatory. Any major logic
    that is going to be executed within this file will actually be deferred to external
    modules hosted within other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can do anything within `server.js`, we require a few modules that
    we''re going to work with, specifically Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are assigning the `express` module to the `express`
    variable. The `config` module is actually going to be our own module that we will
    write shortly, but for now, since it doesn't exist, we will leave that line commented
    out. Finally, we will declare a variable called `app` that is actually what the
    Express framework returns when it is executed. This `app` object powers our entire
    `app` application, which is how it was so cleverly named.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter and the remainder of the book, I may include commented
    out code in the samples (code that starts with `//`). This is so that following
    along will be easier when we use the commented lines as reference points, or when
    we enable those features by simply uncommenting the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we will set a few simple settings via the `app` object using the `app.set()`
    function. These settings are really just a way for us to define some app-level
    constants that we can use throughout the rest of our code as handy shortcuts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines of the preceding code use built-in constants in Node. The
    `process.env.PORT` constant is an environment setting that is set on the actual
    machine for the default port value to the server. If no port value is set on the
    machine, we will hardcode a default value of `3300` to use in its place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we set the location of our Views (HTML templates) to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${__dirname}''/Views`, or using another Node constant, the `/Views`'
  prefs: []
  type: TYPE_NORMAL
- en: folder within the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: The third line of code is referencing the `config` module, which we haven't
    written yet, so that the line is commented out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Last but not least, we will create a HTTP server using our `app` object and
    tell it to listen for connections:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set a route in our application to respond with a `Hello World` message.
    If any user requests for the root of our application, it will respond with a `Hello
    World` message. The last section of the code is to call the `listen()` function
    on our app that tells it which port to listen to, and to pass in a simple anonymous
    callback function that will execute once the server is up and listening by executing
    a simple `console.log()` message. That's it! Again, make sure to save this file
    with the name `server.js` within the root of the project. You're ready to run
    your server and see if it works.
  prefs: []
  type: TYPE_NORMAL
- en: Booting up the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take your server for a spin and see how you''re doing so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! At this point, your server doesn't actually do anything great. Try
    pointing your browser to `http://localhost:3300`. You should receive a pretty
    basic message that says `Hello World`! If you request any other routes on the
    port, such as `http://localhost:3300/`, it will respond with a cannot get response.
    This is because you haven't configured any routes or any actual logic in your
    server to say how to handle certain requests, but only a `GET` request to the
    default route of `/`.
  prefs: []
  type: TYPE_NORMAL
- en: Before you set up your routes, we should understand the concept of middleware
    in Express, which will be essential to understand how the modules that are custom
    dependencies of our application get integrated with our normal application flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set any number of environment variables right from the command line
    before you run your server by executing something like the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can also set environment variables in your environment settings permanently.
    This can be done typically by editing your `.profile` file or equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Middlewares
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful features available with Express is the concept of middleware.
    The idea behind middleware is that it acts like a stack of filters that every
    request to your server passes through. Every request passes through each filter
    and each filter can perform a specific task against the request before it passes
    through to the next filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand it better, here is a diagrammatic view of middlewares:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21df5552-efca-45c1-9090-21550c23cac5.png)'
  prefs: []
  type: TYPE_IMG
- en: Typically, these filters are used for tasks such as cookie parsing, form-field
    handling, session handling, authentication, and error handling and logging. The
    list goes on and on. You can use hundreds of third-party modules as well as simply
    write your own custom middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Undoubtedly, there will be a time when you want to write your own custom middleware
    in addition to the existing middleware provided by *Connect* or any other third
    party. Before you write your own custom middleware in Node, make it a habit to
    search through [https://www.npmjs.org/](https://www.npmjs.org/) first, as there's
    a fairly big chance someone else has already done the work.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own custom middleware is pretty simple. While using an Express
    framework, it documents various types of middleware that we would simply categorize
    into two types, that is, application-based and route-based middlewares.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a super basic example of application-based middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `app.use` function allows us to register as a middleware. At its basic
    level, it is a function that is called on receiving a request in the `http.createServer`
    method. Further, we need to write a function that accepts four parameters: `err`,
    `req`, `res`, and `next`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is an error object, and if there were any stack errors prior
    to your middleware running, that error would be passed to your middleware so that
    you can handle it accordingly. This is an optional parameter; hence, we can skip
    it if no error handling is required for the specific implementation of functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are already familiar with the `req` and `res` parameters, having written
    your routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter is actually a reference to a callback. This next parameter
    is how the middleware stack is able to behave like a stackâ€”each executing and
    ensuring that the next middleware in the pipeline is returned and called via `next`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `app.use` method also accepts the first parameter as a route or an endpoint.
    This forms the second type of middleware called the **route-based middleware**
    that was mentioned earlier. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, this depicts that instead of applying a middleware to all the incoming requests,
    we make it specific to a route and call on the route match.
  prefs: []
  type: TYPE_NORMAL
- en: The only important thing to keep in mind while writing your own custom middleware
    is that you have the correct parameters and you return `next()`. The rest is completely
    up to you!
  prefs: []
  type: TYPE_NORMAL
- en: Order of middlewares
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order that the middleware is called in is very important. Again, using the
    concept of filters as a request that passes through each filter, you want to be
    sure that they are performing their responsibilities in the correct order. A great
    example of this is implementing a cookie parser before a session handler, since
    sessions typically rely on cookies to maintain states with a user between requests.
  prefs: []
  type: TYPE_NORMAL
- en: Another great example of how the order of middleware is important involves error
    handling. If any of your middleware encounters an error, they will simply pass
    that error along to the next middleware in the stack. If the last middleware,
    regardless of what it is, doesn't gracefully handle that error, it will basically
    show up in your application as a stack trace (and that's bad). Having an error
    handler configured as one of the last middleware is like saying "*if everything
    else fails, and at any point in the previous middleware a failure occurs, deal
    with it gracefully*."
  prefs: []
  type: TYPE_NORMAL
- en: The various dependencies we have installed to use in this application are going
    to be integrated into our code as middlewares. We are going to carry out this
    task of integrating the various middlewares through the `config` module, as it
    will help us to make our `server.js` file leaner and add more readability to the
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: The configure module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since, we are keeping our `server.js` file very lean, there is still a fair
    amount of logic that is required in configuring our server. For this, we will
    defer to a custom module that we'll create called `configure`. To get started,
    create a `configure.js` file in the `server` folder. We have already installed
    the custom dependencies when we were installing Express in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the module is installed and ready to be used, let''s start writing
    the `configure.js` file. First, like any of our modules, we will declare our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declared `const` for each of the modules that we will
    be using in our custom `configure` module. Then, we defined the actual module
    that will be exported by this code file, more specifically a function that accepts
    our `app` object as a parameter, as well as returns that same object (after we
    make some configuration modifications to it).
  prefs: []
  type: TYPE_NORMAL
- en: You should see that we require Connect, which is actually installed by default
    with Express.js as one of its core dependencies. Connect is a popular third-party
    middleware framework that we will learn more about later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at each of the Connect middleware we have used in the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`morgan`: This is the module responsible for logging. This is very helpful
    for debugging your Node server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bodyParser`: This helps to facilitate the packing of any form fields that
    are submitted via a HTML form submission from a browser. Form fields that are
    submitted via a `POST` request will be made available via the `req.body` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`methodOverride`: For older browsers which don''t support REST HTTP verbs properly,
    such as `UPDATE` and `PUT`, the `methodOverride` middleware allows this to be
    faked using a special hidden input field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookieParser`: This allows cookies to be sent and received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errorHandler`: This handles any error that occur throughout the entire middleware
    process. Typically, you would write your own custom `errorHandler` that might
    render a default 404 HTML page, log the error to a data store, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handlebars`: This is the templating engine we are going to use with the Views.
    We will explain more about integrating it in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routes(app)` line is a special component of Express that says you are actually
    using a router with your server, and you can respond to requests such as `GET`,
    `POST`, `PUT`, and `UPDATE`. Since you are using the Express router as one of
    the last middleware, we will also define the actual routes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `express.static()` middleware is used to render static content
    files to the browser from a predefined static resource directory. This is important
    so that the server can serve up static files, such as `.js`, `.css`, `images`,
    and `regular.html`, as well as any other files you might need to serve up. The
    static middleware will serve up any static files from the public directory, like
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's important that your static middleware is defined after `app.router()`,
    so that static assets aren't inadvertently taking priority over a matching route
    that you may have defined.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the configure module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that your `configure.js` file is complete, you''re ready to call it from
    your main `server.js` file. If you recall, we included two lines of code that
    were commented out for our `configure` module. It''s time to uncomment these two
    lines so that when you run your server, your `configure` module will do its part.
    The two lines should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Boot up your server again by executing the `server.js` node and everything should
    still be running smoothly. Now, it's time to incorporate more routes into our
    application in addition to the `Hello World` route we added earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Routers and controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have your `server.js` file and a `configure` module that is used
    to wire up all of the necessary middleware for the application. The next step
    is to implement proper routers and the necessary controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router is going to be a map of each of the available URL paths for the
    app. Every route on the server will correspond to a function in a controller.
    Here is what our routes table will look like for the particular application we
    are writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we are handling two different `GET` requests and three different
    `POST` requests. In addition, we have two main controllers: `home` and `image`.
    Controllers are really just modules with different functions defined that match
    up with the corresponding routes. As pointed out earlier, they are called controllers
    in MVC design patterns. Typically, every route will correspond to a controller.
    This controller will more than likely render a View, and that View will more than
    likely have its own model (any data that is displayed in the View).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our router as its own module matching the table outlined. First,
    create a `routes.js` file within the `server` folder. The `routes` file is going
    to be pretty simple, and the only dependencies it requires will be the controllers
    we define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Right off the bat, we declare a `router` variable and require the `controllers`
    folder to assign each application route (we haven't yet created these files, but
    that's coming up next). Here, we are assigning each route to its corresponding
    function in the controllers. Then, we export a module that, when invoked by itself,
    will attach all these routes to the `app` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter for a route is the string value of the route itself, which
    can contain variable values as subpaths. You can see with the second `router.get`,
    that we assign a route value of `/images/:image_id` that basically equates to
    `/image/ANYVALUE` in the browser address bar. When we write the `image.index`
    controller, you will see how to retrieve the value for `:image_id` and use it
    within the `controller` function itself.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter for a route is a callback function. You can completely
    omit the idea of using controllers and just define your callbacks as inline anonymous
    functions; however, as your routes grow, this file will get larger and larger,
    and the code will start to become a mess. It's always a good practice to break
    your code up into as many small and manageable modules as possible to keep yourself
    sane!
  prefs: []
  type: TYPE_NORMAL
- en: The first two `router.get` routes are typical routes that would be called whenever
    a visitor points their browser to `yourdomain.com/routepath`â€”the browser sends
    a `GET` request to the server by default. The other three `router.post` routes
    are defined to handle when the browser posts a request to the server, typically
    done via a HTML form submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of our routes defined, let''s now create the matching controllers.
    Within the `controllers` folder, create both the `home.js` and `image.js` files.
    The `home.js` file is very basic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this module, we are actually exporting an object that has a single function
    called `index`. The `function` signature for `index` is the signature that is
    required for every route using Express. A first parameter is a request object
    and a second parameter is a response object. Every detail specific to the request
    that the browser sent to the server will be available via the request object.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the request object will be modified using all of the middleware
    that was declared earlier. You will use the response object to send a response
    back to the clientâ€”this may be a rendered HTML page, static asset, JSON data,
    an error, or whatever you determine. For now, our controllers just respond with
    a simple text so you can see that they are all working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an image controller that has a few more functions. Edit the `/controllers/image.js`
    file and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined the `index` function, just like we did in the home controller,
    except that we will also display `image_id`, which is set in the route when this
    controller function is executed. The `params` property was added to the `request`
    object via the `urlencoded` feature, which is a part of the body parser module!
  prefs: []
  type: TYPE_NORMAL
- en: Note that the controller currently doesn't require any dependencies (there were
    no `require` declarations defined at the top of the file). This will change as
    we actually flesh out the controller functions and start to do things such as
    inserting records into our MongoDB database and using other third-party `npm`
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that your controllers are created and ready to be used, you just need to
    activate your routes. To do this, we will insert one last line of code into our
    `configure.js` file, right above the `return app;` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to uncomment the `routes = require('./routes')` line at the top
    of the file as well. What we're doing here is using the `routes` module we defined
    and executing the `initialize` function, which will actually wire up our routes
    via our `app` object. We will need to comment out the redundant code that we just
    moved to `routes`, which is still present in `server.js.`
  prefs: []
  type: TYPE_NORMAL
- en: 'As a recap of each of the files you have created so far, here are the uninterrupted
    files listed so you can view the full code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to boot up with `server.js`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will configure the server with `server/configure.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have our routes defined in `server/routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will define our controllers with `controllers/home.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we will also define our controllers with `controllers/image.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's fire up the server one last time and check if it's all working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the `server.js` node, and this time point your browser to `http://localhost:3300`.
    Now, you should be seeing some responses in the browser. Go to `http://localhost:3300/images/testing123`.
    You should see the following message on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Handlebars as View engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Express can and will happily render static HTML documents and serve
    them back to the client. However, unless you're building a purely static, content-driven
    site, which is doubtful, you're more than likely going to want to render your
    HTML dynamically. That is, you want to generate portions of HTML on the fly as
    pages are requested, perhaps using loops, conditional statements, data-driven
    content, and so on. In order to render dynamic HTML pages, you need to use a rendering
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where Handlebars comes in. The rendering engine is given its name because
    of the syntax it uses to display data, namely, double pairs of braces, `{{` and
    `}}`. Using Handlebars, you can have sections of your HTML pages that are determined
    at run time based on data passed to it. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual HTML that would wind up on a visitor''s browser would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we want to take care of in our `configure` module is to register
    Handlebars as the default View rendering engine. In the `configure.js` file, above
    the `return(app);` line, you should insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, using the Express `app` object that was passed into the `configure` function,
    we define our rendering engine of choice by calling the engine function of `app`.
    The first parameter to the `engine` function is the file extension that the rendering
    engine should look for, namely, `handlebars`.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter builds the engine by calling the `express-hbs` module's
    `create` function. This `create` function takes an `options` object as a parameter,
    and this `options` object defines a number of constants for our server. Most importantly,
    we will define which layout is our default layout and also where our layouts will
    be stored. If you recall, in `server.js` we used `app.set` to set a `Views` property
    of our `app` that pointed to the current working directory `+/Views`. This setting
    is used when we configure the options for our rendering engine as well. You'll
    notice that the `partialsDir` property uses an array (with a single item) and
    a single string value for `layoutsDir`. Both of these methods are interchangeable,
    and I just wanted to demonstrate that you could have more than one partial directory,
    and it could just be an array of string values.
  prefs: []
  type: TYPE_NORMAL
- en: With that set, our server now knows that any time we try to render a HTML page
    that has a file extension of `handlebars`, it will use the Handlebars engine to
    perform the rendering. This means that we need to be sure to use Handlebars-specific
    syntax in our dynamic HTML pages.
  prefs: []
  type: TYPE_NORMAL
- en: We will be learning more about Handlebars and how to write dynamic HTML pages
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using `.handlebars` as a file extension was purely a personal choice. Some people
    prefer `.hbs`, and if you want, you can use anything you like. Just make sure
    that the first parameter in the `app.engine()` function and the second parameter
    in the `app.set('View engine')` function are identical.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the many template engines available with Express.js, check
    out this link [https://github.com/expressjs/express/wiki#template-engines](https://github.com/expressjs/express/wiki#template-engines).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Express web framework for Node and wrote
    a basic web server using Express that will act as the foundation for the image
    uploading website that we will build throughout the remainder of the book.
  prefs: []
  type: TYPE_NORMAL
- en: The web server you wrote handles requests to specific routes, uses controllers
    to handle the logic for those routes, and supports all of the standard requirements
    a typical web server should.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the Handlebars template engine to write each
    of the dynamic HTML pages that the website needs. In addition, we will update
    the image and home controllers to include the necessary logic to properly render
    these HTML pages.
  prefs: []
  type: TYPE_NORMAL
