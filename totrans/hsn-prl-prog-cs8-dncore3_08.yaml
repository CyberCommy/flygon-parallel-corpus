- en: Using Concurrent Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we saw some parallel programming implementations in which
    resources needed to be protected from concurrent access by multiple threads. Synchronization
    primitives are tricky to implement. Often, a shared resource is a collection that
    needs to be read and written by multiple threads. Since a collection can be accessed
    in a variety of ways (such as by using `Enumerate`, `Read`, `Write`, `Sort`, or
    `Filter`), it becomes tricky to write a custom collection with managed synchronization
    using primitives. Because of this, there has always been a need for thread-safe
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about various programming constructs available
    in C# that help in parallel development. The following are the high-level topics
    that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to concurrent collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A multiple producer/consumer scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a good understanding of TPL and C#. The source code for this
    chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to concurrent collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From .NET Framework 4, a lot of thread-safe collections were added to the .NET
    repertoire. A new namespace, `System.Threading.Concurrent`, was also added. This
    included constructs like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IProducerConsumerCollection<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentDictionary<TKey,TValue>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the preceding structs, there is no need for any additional synchronization
    and both reading and updating can be done atomically.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety is not an entirely new concept in the case of collections. Even
    with older collections such as `ArrayList` and `Hashtable`, the `Synchronized`
    property was exposed, which made it possible to access these collections in a
    thread-safe manner. This, however, came with a performance hit, because to make
    the collection thread-safe, the entire collection was wrapped inside a lock with
    every read or update operation.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent collections wrap lightweight, slim synchronization primitives such
    as `SpinLock`, `SpinWait`, `SemaphoreSlim`, and `CountDownEvent`, hence making
    them less heavy on cores. As we already know, spinning is much more efficient
    than blocking for smaller wait times. Also, with built-in algorithms in place,
    if wait times increase, the lighter locks are converted into kernel locks.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IProducerConsumerCollection<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The producer and consumer collections are the collections that provide efficient
    lock-free alternatives to their generic counterparts, such as `Stack<T>` and `Queue<T>`.
    Any producer or consumer collection must allow the user to add items and remove
    items. .NET Framework provides the `IProducerConsumerCollection<T>` interface
    that represents thread-safe stacks, queues, and bags. The following are the classes
    that implement the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcurrentQueue<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentStack<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentBag<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two important methods are provided by the interface: `TryAdd` and `TryTake`.
    The syntax of `TryAdd` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `TryAdd` method adds an item and returns `true`. If there is any problem
    with adding the item, it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of `TryTake` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `TryTake` method removes an item and returns `true`. If there is any problem
    with removing the item, it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConcurrentQueue<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Concurrent queues can be used to solve producer/consumer scenarios in application
    programming. In the producer/consumer programming pattern, one or more threads
    produce data and one or more threads consume data. This leads to race conditions
    among threads. We can solve this problem via the following approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Using queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ConcurrentQueue<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on which thread (producer/consumer) has the responsibility to add/consume
    data, the producer-consumer pattern can be classified into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pure producer-consumer**, where a thread can either only produce data or
    only consume data but cannot do both'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixed producer-consumer**, where any thread can produce or consume data at
    the same time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try to solve a producer-consumer problem using queues first.
  prefs: []
  type: TYPE_NORMAL
- en: Using queues to solve a producer-consumer problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will create a producer and consumer scenario using queues
    that are defined in the `System.Collections` namespace. There will be multiple
    tasks that will attempt to read or write to a queue and we need to ensure that
    the reads and writes are atomic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create `queue` and populate it with some data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a variable that will hold the final result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a parallel loop that will read the item from the queue
    using multiple tasks and add the sum in a thread-safe manner to the sum variable
    declared previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the program, you will get the following output. As you can see, it''s
    not the expected output due to the race condition that occurred between the tasks
    while trying to read concurrently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50f765c8-c081-4b67-a8cf-6bc432dc2dc2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the preceding program thread-safe, we can lock the critical section
    by modifying the parallel loop code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we need to synchronize all read/write points to the queue that is
    exposed to the parallel code in more complex scenarios. The following is the output
    if we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d129a15a-2e1e-4b32-b3ca-acb5c8983295.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, everything works as expected, although there is an additional
    synchronization overhead that can lead to deadlock in frequent read or write scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems using concurrent queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can solve the producer-consumer problem by making use of the  `System.Collections.Concurrent.ConcurrentQueue` class,
    which is a thread-safe version of a queue. Let''s modify the preceding code by
    using a concurrent queue, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have just replaced `Queue<int>` with `ConcurrentQueue<int>`
    in the code we wrote previously, which had synchronization overheads. With `ConcurrentQueue`,
    we don't have to worry about other synchronization primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output if we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/676c49ca-488e-48da-9016-96a9dd59dfc5.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like `Queue<T>`, `ConcurrentQueue<T>` also works in **First In, First Out**
    (**FIFO**) mode.
  prefs: []
  type: TYPE_NORMAL
- en: Performance consideration – Queue<T> versus ConcurrentQueue<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should use `ConcurrentQueue` in the following scenarios, where it has slight
    or very big performance benefits over queues:'
  prefs: []
  type: TYPE_NORMAL
- en: In a pure producer-consumer scenario, where the processing time for each item
    is very low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a pure producer-consumer scenario, where there is only one dedicated producer
    thread and only one dedicated consumer thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In pure as well as mixed producer-consumer scenarios where the processing time
    is 500 **FLOPS** (short for **Floating-Point Operations Per Second**) or more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should use queues over concurrent queues in a mixed producer-consumer scenario
    where the processing time for each item is lower, to gain performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConcurrentStack<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ConcurrentStack<T>` is a concurrent version of `Stack<T>` and implements the `IProducerConsumerCollection<T>`
    interface. We can push or pop items from the stack, which works in the **Last
    In, First Out** (**LIFO**) format. It doesn''t involve kernel-level locking, rather
    it relies on spinning and compare-and-swap operations to remove any contention.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some important methods of the `ConcurrentStack<T>` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Clear`: Removes all elements from the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: Returns the number of elements in the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsEmpty`: Returns `true` if the collection is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Push (T item)`: Adds an element to the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryPop (out T result)`: Removes an element from the collection, and returns
    `true` if the item is removed; otherwise, it returns `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PushRange (T [] items)`:Adds a range of items to the collection; the operation
    is performed atomically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryPopRange (T [] items)`:Removes a range of items from the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how to create a concurrent stack instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a concurrent stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a concurrent stack instance and add items as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get items from the stack as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the complete code that creates a concurrent stack, adds items, and
    iterates on items in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7564b63-881e-4bc9-bbea-ccd465825517.png)'
  prefs: []
  type: TYPE_IMG
- en: Using ConcurrentBag<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ConcurrentBag<T>` is an unordered collection, unlike `ConcurrentStack` and
    `ConcurrentQueues`, which orders the items while storing and retrieving them.
    `ConcurrentBag<T>` is optimized for scenarios in which the same threads work as
    a producer as well as a consumer. `ConcurrentBag` supports the work-stealing algorithm
    and maintains a local queue for each thread.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates `ConcurrentBag` and adds or gets items from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/125e306d-f7dc-4872-a5b9-2029132f9595.png)'
  prefs: []
  type: TYPE_IMG
- en: As you are aware, every thread has a thread-local queue. Items 1, 2, and 3 are
    added to the local queue of `producerAndConsumerTask` and items 4, 5, and 6 are
    added to the local queue of `producerTask`. When `producerAndConsumerTask` has
    added items, we wait for `producerTask` to finish pushing its items. Once all
    the items are pushed, `producerAndConsumerTask` starts retrieving items. Since
    it has pushed 1, 2, and 3, which are in the local queue, it will process those
    first before moving to the local queue of `producerTask`.
  prefs: []
  type: TYPE_NORMAL
- en: Using BlockingCollection<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BlockingCollection<T>` class is a thread-safe collection that implements
    the `IProduceConsumerCollection<T>` interface. We can add or remove items from
    the collection concurrently without worrying about synchronization, which is handled
    automatically. There will be two threads: the producer and the consumer. The producer
    thread will produce data and we can limit the maximum number of items that can
    be produced by the producer thread before it enters sleep mode and is then blocked.
    The consumer thread will consume data and will be blocked when the collection
    is emptied. The producer thread is unblocked and the consumer thread removes some
    items from the collection. The consumer thread is unblocked when the producer
    thread adds some data to the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important aspects of blocking collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounding**:This means we can bound the collection to a maximum value after
    which no new objects can be added and the producer thread enters sleep mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocking**: This means we can block the consumer thread when the collection
    is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how to create blocking collections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating BlockingCollection<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code creates a new `BlockingCollection` that creates up to 10
    items after which it goes to the blocked state before items are consumed by consumer
    threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Items can be added to the collection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Items can be removed from the collection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The producer thread calls the `CompleteAdding()` method when there are no more
    items to add. This method, in turn, sets the `IsAddingComplete` property of the
    collection to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The consumer thread uses the `IsCompleted` property when the collection is empty
    and `IsAddingComplete` is also `true`. This is an indication that all items have
    been processed and the producer will not add any more items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f457b50-74d7-4398-b66c-af844ec7018e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, after introducing the concurrent collections, in the next section, we will
    try to take the producer-consumer scenario forward and learn about how to deal
    with multiple producers/consumers.
  prefs: []
  type: TYPE_NORMAL
- en: A multiple producer-consumer scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how blocking collections work when there are multiple
    producer and consumer threads. For the sake of understanding, we will create two
    producers and one consumer. The producer threads will produce the items. Once
    all of the producer threads have called `CompleteAdding`, then the consumer will
    start reading items from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a blocking collection with multiple producers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create two producer tasks that will add items to the producers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we will write consumer logic that will try to consume items from
    both producer collections as soon as the items are available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code method, `TryTakeFromAny` tries to read
    the item from multiple producers and return when the item is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4166e62b-2d21-485d-bfc2-406d81970ecb.png)'
  prefs: []
  type: TYPE_IMG
- en: In programming, we often come across a scenario where we need to store data
    concurrently as key-value pairs. For that purpose, the `ConcurrentDictionary`
    collection comes in handy, which we will introduce in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using ConcurrentDictionary<TKey,TValue>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ConcurrentDictionary<TKey,TValue>` represents a thread-safe dictionary. It
    is used to hold key-value pairs that can be read or written in a thread-safe manner.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcurrentDictionary` can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Items can be added to the dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Items can be removed from the dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Items in the dictionary can be updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we will create two producer threads that will add items
    to a dictionary. The producers will create some duplicate items and the dictionary
    will make sure they are added in a thread-safe manner without throwing duplicate
    key errors. Once the producer threads finish, the consumer will read all items
    using the `keys` or `values` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1435d511-3d3f-4889-91a0-923a42be2541.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we learned how concurrent collections can be very handy in
    producer-consumer scenarios. With concurrent collections, the onus is on getting
    code to behave correctly while dealing with multiple tasks without the need for
    custom synchronization overheads.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed thread-safe collections that are part of .NET
    Framework. Concurrent collections are available in the `System.Collection.Concurrent`
    namespace and there are collections for various use cases in programming. Some
    common use cases require collections that include dictionaries, lists, bags, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed a producer and consumer scenario in which data is produced
    by some threads and consumed by other threads at the same time. Usually, in these
    scenarios, there are race conditions, but concurrent collections can deal with
    them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about improving the performance of parallel
    code via lazy initialization patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these is not a concurrent collection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConcurrentQueue<T>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConcurrentBag<T>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConcurrentStack<T>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConcurrentList<T>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a thread can only produce data and another thread can only consume data
    but not both, what is this arrangement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pure producer-consumer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mixed producer-consumer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A queue will perform best when the processing time for items is less in the
    case of a pure producer-consumer scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is not a member of `ConcurrentStack`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Push`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TryPop`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TryPopRange`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TryPush`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
