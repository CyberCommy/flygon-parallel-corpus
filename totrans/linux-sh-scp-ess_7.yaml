- en: Chapter 7. Welcome to the Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A program under execution is known as **process**. When an operating system
    gets booted up, multiple processes get started in order to provide various functionalities
    and user interfaces so that a user can easily perform the required tasks. For
    example, when we start a command line server, we will see a terminal with bash
    or any other shell process that has been started.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, we have full control over processes. It allows us to create, stop,
    and kill processes. In this chapter, we will see how a process is created and
    managed by using commands such as `top`, `ps`, and `kill` and by changing its
    scheduling priority. We will also see how a signal can lead to the sudden termination
    of a process and also the ways to handle signals in a script using the command
    trap. We will also see one of the beautiful features of processes called Inter-process
    communication, which allows them to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Process management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing and monitoring processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process substitution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process scheduling priorities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inter-process Communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing processes is very important because processes are what consumes system
    resources. System users should be careful about the processes they are creating,
    in order to ensure that a process is not affecting any other critical processes.
  prefs: []
  type: TYPE_NORMAL
- en: Process creation and execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In bash, creating a process is very easy. When a program is executed, a new
    process is created. In a Linux or Unix-based system, when a new process is created,
    a unique ID is assigned to it, which is known as PID. A PID value is always a
    positive number starting from `1`. Depending upon a system having `init` or `systemd`,
    they always get the PID value 1 because this will be the first process in a system
    and it is the ancestor of all other processes.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum value of PID is defined in the `pid_max` file, which should be available
    in the `/proc/sys/kernel/` directory. By default, the `pid_max` file contains
    the value `32768` (max PID + 1), which means a maximum of `32767` processes can
    exist in a system simultaneously. We can change the value of the `pid_max` file
    depending upon needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For understanding the process creation better, we will create a new process
    `vi` from bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a new process `vi` that opens the `hello.txt` file in
    editor to read and write text. Calling the `vi` command causes the binary file
    `/usr/bin/vi` to execute and perform the needed tasks. A process that creates
    another process is known as the parent of the process. In this example, `vi` was
    created from bash, so bash is the parent of the process `vi`. The method of creating
    a child process is known as forking. During the process of fork, a child process
    inherits the properties of its parents such as GID, real and effective UID and
    GID, environment variables, shared memory, and resource limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To know the PID of the `vi` process created in the preceding section, we can
    use the commands such as `pidof` and `ps`. For example, run the following command
    in a new terminal to know the pid of the `vi` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once a task is completed, a process gets terminated and PID is free to get assigned
    to a new process based on need.
  prefs: []
  type: TYPE_NORMAL
- en: The detailed information about each process is available in the `/proc/` directory.
    A directory with the PID name gets created for each process in `/proc/` containing
    its detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A process can be in any of the following states during its lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running**: In this state, a process is either running or ready to run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waiting**: A process is waiting for a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopped**: A process has been stopped; for example, after receiving a signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zombie**: A process has exited successfully, but its state change wasn''t
    yet acknowledged by the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process termination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In normal circumstances, after completing tasks, a process terminates and frees
    up the allocated resources. If the shell has forked any subprocesses, then it
    will wait for them to finish their task first (other than a background process).
    In some cases, a process may not behave normally and it can be waiting or consuming
    resources for a longer time than expected. In some other cases, it may happen
    that a process is now no longer required. In such cases, we can kill the process
    from a terminal and free up resources.
  prefs: []
  type: TYPE_NORMAL
- en: To terminate a process, we can use the `kill` command. The `killall` and `pkill`
    commands can also be used if available on a system.
  prefs: []
  type: TYPE_NORMAL
- en: Using the kill command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `kill` command sends the specified signal to the specified processes. If
    no signal is provided, the default `SIGTERM` signal is sent. We will see more
    about signals further down in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax of using the `kill` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: AND
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To kill a process, first get the `PID` of that process as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `SIGSTOP` signal to stop the process instead of killing it.
    To kill, we can use the `SIGKILL` signal or the associated value to this signal,
    which is `9`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the killall command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's easy to remember a process by name rather than by PID. The `killall` command
    makes it easier to kill a process since it takes the command name as a parameter
    to kill a process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax of the `killall` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: AND
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can kill the `firefox` process by name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the pkill command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pkill` command can also be used to kill a process by its name. Unlike the
    `killall` command, by default the `pkill` command finds all the processes beginning
    with the name specified in its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following command demonstrates how `pkill` kills the `firefox`
    process from its partial name specified in an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pkill` command should be used carefully because it will kill all the matching
    processes, which may not be our intention. We can determine which processes are
    going to be killed by `pkill`, using the `pgrep` command with the `-l` option.
    The `pgrep` command finds processes based on its name and attributes. Run the
    following commands to list all process names and its PID whose name begin with
    the `firef` and `fire` strings, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `firefox` is the matching process name and its PID is `8168`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also tell `pkill` to kill a process with exact match of process name
    using the `--exact` or `-x` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The pkill command can also send a specific signal to all matching processes
    with the `-signal_name` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command sends the `SIGKILL` signal to all processes whose name
    begins with `firef`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and monitoring processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a running system, we often notice that suddenly a system is responding slowly.
    This can be because a running application is consuming a lot of memory or a process
    is doing CPU-intensive work. It's hard to predict which application is causing
    the system to respond slower. To know the reason, it is good to know what all
    processes are running and also know the monitoring behavior (such as the amount
    of CPU or memory being consumed) of processes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To know a list of processes running in the system, we can use the `ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of the `ps` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of options to use the `ps` command. The commonly used options
    are explained in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: Simple process selection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following table shows the multiple options that can be clubbed together
    and used to get a better selection of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-A`, `-e` | Selects all processes |'
  prefs: []
  type: TYPE_TB
- en: '| `-N` | Selects all processes that don''t fulfill a condition—that is, negate
    selection |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | Selects the processes associated with the current terminal |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | Restricts selection to only running processes |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | Selects processes that have no controlling terminal such as daemons
    launched during booting |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | Selects the processes on a terminal including all users |'
  prefs: []
  type: TYPE_TB
- en: Process selection by list
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following options accept a single argument in the form of a blank-separated
    or comma-separated list; they can be used multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-C cmdlist` | Selects the process by its name. The list of names for selection
    is provided in `cmdlist`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-g grplist` | Selects the process by an effective group name provided in
    the list of the `grplist` arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `-G grplist` | Selects the process by a real group name provided in the list
    of the `grplist` arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `-p pidlist` | Selects the process by its PID mentioned in `pidlist`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-t ttylist` | Selects the process by a terminal mentioned in `ttylist`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-U userlist` | Selects the process by a real user ID or name mentioned in
    `userlist`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-u userlist` | Selects the process by an effective user ID or name mentioned
    in `userlist`. |'
  prefs: []
  type: TYPE_TB
- en: Output format control
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following options are used to choose how to display the `ps` command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-j` | Shows the job format. |'
  prefs: []
  type: TYPE_TB
- en: '| `-f` | This is used for a full format listing. It also prints the argument
    passed to the command. |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | Displays user-oriented format. |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Displays long format. |'
  prefs: []
  type: TYPE_TB
- en: '| `v` | Displays the virtual memory format. |'
  prefs: []
  type: TYPE_TB
- en: Listing all processes with details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To know all processes on a system, the `-e` option can be used. To have a more
    detailed output, use it with the `u` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Listing all processes with details](img/4335_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the output that all users' processes are displayed. The command
    that is actually displaying the output—that is, **ps -e u | tail -n5**—is also
    mentioned in the `ps` output as two separate running processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In BSD style, use the `aux` option to get the result that we get from `-e u`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: On a Linux-based operating system, aux as well as `-e u` options will work fine.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all processes run by a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To know which processes are being by a specific user, use the `-u` option followed
    by the username. Multiple usernames can also be provided separated by a comma
    (,).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command displays the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing all processes run by a user](img/4335_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see that all processes are running as the user root. The rest of the users'
    processes have been filtered out.
  prefs: []
  type: TYPE_NORMAL
- en: Processes running in the current terminal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is useful to know which processes are running in the current terminal. It
    can help in deciding whether to kill a running terminal or not. We can make a
    list of processes running in the current terminal using the `T` or `t` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the following command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Processes running in the current terminal](img/4335_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the output that `bash` and the `ps uT` command (which we just
    executed to display the result) are only running processes in the current terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Listing processes by a command name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also know process details by its name using the `-C` option followed
    by the command name. Multiple command names can be separated by a comma (`,`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing processes by a command name](img/4335_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tree format display of processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pstree` command displays running processes in a tree structure, which makes
    it very easy to understand the parent and child relationship of processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `pstree` command with the `-p` option shows processes in the tree
    format with its PID number as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Tree format display of processes](img/4335_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the `pstree` output, we see that the parent process of all processes is
    `systemd`. This is started as the first process that is responsible for executing
    the rest of the processes. In parenthesis, the PID number of each process is mentioned.
    We can see that the `systemd` process got PID 1 that is always fixed. On the `init`
    based-operating system, `init` will be the parent of all processes and have PID
    1.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see processes process the tree of a particular PID, we can use `pstree`
    with the PID number as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Tree format display of processes](img/4335_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the `pstree` command with the `-u` option to see when the UID of the process
    and parent differs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Tree format display of processes](img/4335_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that initially, `bash` is being run by the user `skumari` with the
    PID `1627`. Further down in the tree, the `sudo` command is running as a root.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very important to know how much memory and CPU a process is consuming
    while running, in order to ensure there is no leak of memory and over-CPU computation
    happening. There are commands such as `top`, `htop`, and `vmstat` that can be
    used to monitor the memory and CPU consumed by each process. Here, we will discuss
    the `top` command because it is preinstalled in a Linux-based operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The `top` command displays the dynamic real-time usage of the CPU, memory, swap,
    and the number of tasks currently running with their state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `top` without any options gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Monitoring processes](img/4335_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the `top` command output, the first line tells us about the length of time
    since the system last booted, the number of users, and the load average.
  prefs: []
  type: TYPE_NORMAL
- en: The second line tells us about the number of tasks and their statuses—running,
    sleeping, stopped, and zombie.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third line gives us the details of the CPU usage in percentage. The different
    CPU usages are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `us` | % of the CPU time spent in running un-niced user processes |'
  prefs: []
  type: TYPE_TB
- en: '| `sy` | % of the CPU time spent in kernel space—that is running kernel processes
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ni` | % of the CPU time running niced user processes |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | % of the time spent idle |'
  prefs: []
  type: TYPE_TB
- en: '| `wa` | % of the time spent waiting for the I/O completion |'
  prefs: []
  type: TYPE_TB
- en: '| `hi` | % of the time spent servicing the hardware interrupt |'
  prefs: []
  type: TYPE_TB
- en: '| `si` | % of the time spent servicing the software interrupts |'
  prefs: []
  type: TYPE_TB
- en: '| `st` | % of the time consumed by a virtual machine |'
  prefs: []
  type: TYPE_TB
- en: The fourth line tells us about the total, free, used, and buffered RAM memory
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth line tells us about the total, free and used swap memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining lines give the detailed information about running processes.
    The meaning of each column is described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Column | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PID | Process ID |'
  prefs: []
  type: TYPE_TB
- en: '| USER | Effective user name of task''s owner |'
  prefs: []
  type: TYPE_TB
- en: '| PR | Priority of task (lower the value, more is the priority) |'
  prefs: []
  type: TYPE_TB
- en: '| NI | Nice value of task. Negative nice value means more priority and positive
    means lesser priority |'
  prefs: []
  type: TYPE_TB
- en: '| VIRT | Virtual memory size used by process |'
  prefs: []
  type: TYPE_TB
- en: '| RES | Non-swapped physical memory a process |'
  prefs: []
  type: TYPE_TB
- en: '| SHR | Amount of shared memory available to a process |'
  prefs: []
  type: TYPE_TB
- en: '| S | Process status – D (uninterruptible sleep ), R (Running), S(Sleeping),
    T (Stopped by job control signal), t (Stopped by debugger), Z (Zombie) |'
  prefs: []
  type: TYPE_TB
- en: '| %CPU | % of CPU currently used by process |'
  prefs: []
  type: TYPE_TB
- en: '| %MEM | % of Physical memory currently used by process |'
  prefs: []
  type: TYPE_TB
- en: '| TIME+ | CPU Time, hundredths |'
  prefs: []
  type: TYPE_TB
- en: '| COMMAND | Command name |'
  prefs: []
  type: TYPE_TB
- en: 'We can also reorder and modify the output when the top is running. To see help,
    use the *?* or *h* key and the help window will be displayed, which contains following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring processes](img/4335_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To sort on the basis of a specific field, the easiest method is to press the
    *f* key while `top` is running. A new window opens showing all the columns. The
    opened window looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring processes](img/4335_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use the up and down arrows to navigate and select a column. To sort on the basis
    of a particular field, press the *s* key and then press *q* to switch back to
    the top output window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have selected NI and then pressed the *s* key and the *q* key. Now,
    the `top` output will be sorted with `nice` number. The output of the top after
    sorting with the column **NI** looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring processes](img/4335_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Process substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that we can use a pipe to provide the output of a command as an input
    to another command. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `cat` command output—that is, the content of `file.txt`—is passed
    to the less command as an input. We can redirect the output of only one process
    (cat process in this example) as an input to another process.
  prefs: []
  type: TYPE_NORMAL
- en: We may need to feed the output of multiple processes as an input to another
    process. In such a case, process substitution is used. Process substitution allows
    a process to take the input from the output of one or more processes rather than
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using process substitution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To substitute input file(s) by list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: To substitute output file(s) by list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, `list` is a command or a pipeline of commands. Process substitution makes
    a list act like a file, which is done by giving list a name and then substituting
    that name in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Diffing the output of two processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To compare two sets of data, we use the `diff` command. However, we know that
    the `diff` command takes two files as an input for producing diff. So, we will
    have to first save the two sets of data into two separate files and then run `diff`.
    Saving the content for diff adds extra steps, which is not good. To solve this
    problem, we can use the process substitution feature while performing `diff`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we want to know the hidden files in a directory. In a Linux and
    Unix-based system, files that starts with `.` (dot) are known as hidden files.
    To see the hidden files, the `-a` option is used with the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To get only the hidden files in a directory, run the `diff` command on the
    sorted output obtained from the preceding two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Diffing the output of two processes](img/4335_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have fed the commands `ls -l ~ | tr -s " " | sort -k9` and `ls -al
    ~ | tr -s " " | sort -k9` as input data to the `diff` command instead of passing
    the two files.
  prefs: []
  type: TYPE_NORMAL
- en: Process scheduling priorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During a process lifetime, it may need CPU and other resources to keep executing
    normally. We know that multiple processes are running simultaneously in a system
    and they may need a CPU to complete an operation. To share the available CPUs
    and resources, process scheduling is done so that each process gets a chance to
    make use of the CPU. When a process gets created, an initial priority value is
    set. Depending upon the priority value, the process gets the CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: The process scheduling priority range is from `-20` to `19`. This value is also
    called a nice value. The lower the nice value, the higher is the scheduling priority
    of a process. So, the process with `-20` will have the highest scheduling priority
    and the process with the nice value `19` will have the lowest scheduling priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the nice value of a process, the `ps` or `top` command can be used.
    The corresponding nice value of a process is available in the NI column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Process scheduling priorities](img/4335_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the `ps` output, we can see in the `NI` column that the nice value of bash
    and the `ps` processes is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing scheduling priorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every process in a system has some priority assigned that depends upon its nice
    value. Based on priority, the process gets CPU time and other resources to use.
    Sometimes, it may happen that a process needs to be executed quickly, but it is
    waiting for CPU resources to be freed for long time because of a lower scheduling
    priority. In such cases, we may want to increase its scheduling priority in order
    to finish a task sooner. We can change the scheduling priority of a process by
    using the `nice` and `renice` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Using nice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `nice` command launches a process with a user-defined scheduling priority.
    By default, processes created by a user get the nice value `0`. To verify this,
    run the `nice` command without any option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new `firefox` process that actually consumes CPU and resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Using nice](img/4335_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the nice value of `firefox` is `0` and the CPU usage is 8.7%.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will kill the current `firefox` and launch another `firefox` with the
    nice value `10`. This means, `firefox` will have a lower priority than other user-created
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a process with a different nice value, the `-n` option is used with
    `nice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what nice value `firefox` has now, check the `top` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![Using nice](img/4335_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the `firefox` process has the `10` nice value. To provide more
    scheduling priority—that is, setting a negative nice value to a process—root privilege
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example sets the `firefox` process as a higher scheduling priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using renice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `nice` command can only modify a nice value during the launch of a process.
    However, if we want to change a running process scheduling priority, then the
    `renice` command should be used. The `renice` command alters the scheduling priority
    of one or more running processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using `renice` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `-g` option considers succeeding an argument—that is, identifier as
    GIDs.
  prefs: []
  type: TYPE_NORMAL
- en: The `-p` option considers succeeding an argument—that is, identifier as PIDs.
  prefs: []
  type: TYPE_NORMAL
- en: The `-u` option considers succeeding an argument—that is, identifier as usernames
    or UIDs.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the options—`-g`, `-p`, or `-u`—are provided, identifiers are considered
    as PIDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we will change the priority of all the processes belonging to
    a user. Firstly, see the current priority of processes owned by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![Using renice](img/4335_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will modify the priority of all processes using `renice` with the `–u`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s view a new nice value of processes owned by the user `skumari`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![Using renice](img/4335_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To modify the scheduling priority of a few processes, modify using the process''s
    PIDs. The following example modifies the process plasmashell and Firefox having
    the PIDs `1505` and `5969` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![Using renice](img/4335_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can see that the nice values of the process plasmashell and Firefox
    are `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A signal is a software interrupt to notify processes that an external event
    has occurred. In a normal execution, processes keeps running as expected. Now,
    for some reason, a user may want to cancel a running `process`. When the process
    is started from a terminal, it will terminate when we hit the *Ctrl* + *c* keys
    or run the `kill` command.
  prefs: []
  type: TYPE_NORMAL
- en: When we press *Ctrl* + *c* keys while process is running in a terminal, a signal
    `SIGINT` is generated and sent to the process running in foreground. Also, when
    the `kill` command is called on process, the `SIGKILL` signal is generated and
    the process is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Available signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among all available signals, we will discuss the frequently used signals here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Signal name | Value | Default Action | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SIGHUP | 1 | Term | This signal is used to Hangup or death of controlling
    process |'
  prefs: []
  type: TYPE_TB
- en: '| SIGINT | 2 | Term | This signal is used to interrupt from keyboard like ctrl
    + c, ctrl + z |'
  prefs: []
  type: TYPE_TB
- en: '| SIGQUIT | 3 | Core | This signal is used to quit from keyboard |'
  prefs: []
  type: TYPE_TB
- en: '| SIGILL | 4 | Core | It is used to for Illegal instruction |'
  prefs: []
  type: TYPE_TB
- en: '| SIGTRAP | 5 | Core | This signal is used to trace or breakpoint trap |'
  prefs: []
  type: TYPE_TB
- en: '| SIGABRT | 6 | Core | It is used to abort signal |'
  prefs: []
  type: TYPE_TB
- en: '| SIGFPE | 8 | Core | Floating point exception |'
  prefs: []
  type: TYPE_TB
- en: '| SIGKILL | 9 | Term | Process terminates immediately |'
  prefs: []
  type: TYPE_TB
- en: '| SIGSEGV | 11 | Core | Invalid memory reference |'
  prefs: []
  type: TYPE_TB
- en: '| SIGPIPE | 13 | Term | Broken pipe |'
  prefs: []
  type: TYPE_TB
- en: '| SIGALRM | 14 | Term | Alarm signal |'
  prefs: []
  type: TYPE_TB
- en: '| SIGTERM | 15 | Term | Terminate the process |'
  prefs: []
  type: TYPE_TB
- en: '| SIGCHLD | 17 | Ign | Child stopped or terminated |'
  prefs: []
  type: TYPE_TB
- en: '| SIGSTOP | 19 | Stop | This signal is used to stop the process |'
  prefs: []
  type: TYPE_TB
- en: '| SIGPWR | 30 | Term | Power failure |'
  prefs: []
  type: TYPE_TB
- en: 'In the preceding table, we mentioned the signal name and value. Any of them
    can be used while referring to a signal. The meaning of terms used in the **Default
    action** section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Term: Terminate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Core: Terminate the process and dump core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ign: Ignore the signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stop: Stop the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Depending upon what kind of signal it is, any of the following actions can
    be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: A signal can be ignored by a process, which means no action will be taken. Most
    of the signals can be ignored, except `SIGKILL` and `SIGSTOP`. The `SIGKILL` and
    `SIGSTOP` signals can't be caught, blocked, or ignored. This allows the kernel
    to kill or stop any process at any point of time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signal can be handled by writing a signal handler code specifying the required
    action to be taken after a particular signal is received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each signal has a default action, so let the signal perform the default action;
    for example, terminate the process in case the `SIGKILL` signal is sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To know all signals and its corresponding value, use the `kill` command with
    the`–l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![Available signals](img/4335_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `kill` command also provides a way to convert a signal number to a name
    when used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To send a signal to process(es), we can use the `kill`, `pkill`, and `kilall`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Traps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a process is running and in between we kill the process, the process terminates
    instantly without doing anything further. A programmer who writes a program may
    want to do some tasks before a program actually terminates; for example, a clean
    up of the temporary directories created, saving applications' state, saving logs,
    and so on. In such a case, a programmer would like to listen to signals and do
    the required task before actually allowing you to terminate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following shell script example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This program takes an input from a user file and then reverses the file content.
    This script creates a temporary file to keep the reversed content of the file
    and later copies it to the original file. At the end, it deletes the temporary
    file.
  prefs: []
  type: TYPE_NORMAL
- en: When we execute this script, it may be waiting for a user to input a text filename
    or maybe in between reversing the file (a large file takes more time to reverse
    the content). During this, if processes are terminated, then the temporary file
    may not get deleted. It is the programmer's task to make sure that temporary files
    are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: To solve such a problem, we can handle the signal, perform the necessary tasks,
    and then terminate the process. This can be achieved by using the `trap` command.
    This command allows you to execute a command when a signal is received by a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using `trap` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can provide `trap action` to be performed. An action can be an executing
    command (s).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding syntax of `trap`, `signals` refers to providing one or more
    signal names for which an action has to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script demonstrates `how` trap is used to perform tasks
    before a process suddenly exits on receiving a signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this modified script, when any of the signals such as `SIGHUP`, `SIGINT`,
    `SIGABRT`, `SIGTERM`, or `SIGQUIT` are received, then `rm` `$tmpfile; exit` will
    be executed. This means that a temporary file will first be deleted and then you
    can exit from the script.
  prefs: []
  type: TYPE_NORMAL
- en: Inter-process communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A process alone can do a certain things, but not everything. It will be a very
    useful and good resource utilization if two or more processes can communicate
    with each other in the form of sharing results, sending or receiving messages,
    and so on. In a Linux or Unix-based operating system, two or more processes can
    communicate with each other using IPC.
  prefs: []
  type: TYPE_NORMAL
- en: IPC is the technique by which processes communicate with each other and are
    managed by kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'IPC is possible to do by any of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Named pipes**: These allow processes to read from and write into it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared memory**: This is created by one process and is further available
    for read from and write to this memory by multiple processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message queue**: This is a structured and an ordered list of memory segments
    where processes store or retrieve data in queue fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semaphores**: This provides a synchronizing mechanism for processes that
    are accessing the same resource. It has counters that are used to control the
    access to shared resources by multiple processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While discussing named pipes in [Chapter 6](ch06.html "Chapter 6. Working with
    Files"), *Working with Files*, we learned how processes can communicate using
    named pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Information on IPC using ipcs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ipcs` command provides information about IPC facilities for which a calling
    process has the read access. It can provide information on three resources: shared
    memory, message queue, and semaphore.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using `ipcs` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Where options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Displays information for all resources—shared memory, message queue,
    and semaphore |'
  prefs: []
  type: TYPE_TB
- en: '| `-q` | Displays information about active message queues |'
  prefs: []
  type: TYPE_TB
- en: '| `-m` | Displays information about active shared memory segments |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | Displays information about active semaphore sets |'
  prefs: []
  type: TYPE_TB
- en: '| `-i ID` | Shows the detailed information for an ID. Use it with the `-q`,
    `-m` or `-s` option. |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Shows resource limits |'
  prefs: []
  type: TYPE_TB
- en: '| `-p` | Shows PIDs of the resource creator and last operator |'
  prefs: []
  type: TYPE_TB
- en: '| `-b` | Prints sizes in bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `--human` | Print sizes in a human-readable format |'
  prefs: []
  type: TYPE_TB
- en: Listing information provided by IPCs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `ipcs` command without an option or with `–a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![Listing information provided by IPCs](img/4335_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see only the shared memory segment, we can use `ipcs` with the `–m` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![Listing information provided by IPCs](img/4335_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the `--human` option made a size column in a more readable format by providing
    the size in KB and MB instead of giving it in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out detailed information about a resource ID, use `ipcs` with the `-i`
    option followed by the resource ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![Listing information provided by IPCs](img/4335_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Knowing processes' PID who recently did IPCs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can know the PID of the processes that have recently accessed a specific
    IPC resource using the `-p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![Knowing processes'' PID who recently did IPCs](img/4335_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the `cpid` column shows `pid` of the processes that created the shared
    memory resource, and `lpid` refers to the PID of the processes that last accessed
    the shared memory resource.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand what process is in a Linux and
    UNIX-based system. You should now know how to create, stop, terminate, and monitor
    processes. You should also know how to send signals to a process and manage the
    received signals in your shell script with the `trap` command. You have also learned
    how different processes communicate with each other using IPC on mechanism in
    order to share resources or to send and receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the different ways in which tasks
    can be automated and how they run at a specified time without any further human
    intervention. You will also learn how and why start-up files are created, and
    how to embed other programming languages such as Python in a shell script.
  prefs: []
  type: TYPE_NORMAL
