- en: '*Chapter 13*: Anonymous Classes – Bringing Android Widgets to Life'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter could have been called *Even More OOP*, as anonymous classes are
    very much still part of that subject. However, as you will see, anonymous classes
    offer us so much flexibility, especially when it comes to interacting with the
    **User Interface** (**UI**), that I thought they deserved a chapter dedicated
    to them and their key use in Android.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good overview of both the layout and coding of an Android
    app, along with our newly acquired insight into **Object-Oriented Programming**
    (**OOP**), and how we can manipulate the UI from our Java code, we are ready to
    experiment with more widgets from the palette alongside anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is a tricky thing at times, and anonymous classes are known to be a bit
    awkward for beginners. However, by gradually learning these new concepts and then
    practicing them repeatedly, over time, they will become our friends.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will diversify a lot by going back to the Android Studio
    palette and looking at half a dozen widgets that we have either not seen at all
    or have not fully used yet.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have done this, we will put them all into a layout and practice manipulating
    them with Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing layout widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating widgets with just Java code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EditText`, `ImageView`, `RadioButton` (and `RadioGroup`), `Switch`, `CheckBox`,
    and `TextClock` widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WebView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use an anonymous class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a widget demo mini app using all of the preceding widgets and some anonymous
    classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2013.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing the objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that when we call the `setContentView` method from the `onCreate` method,
    Android inflates all the widgets and layouts and turns them into *real* Java objects
    on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we know that to use a widget from the heap, we must first declare
    an object of the correct type and then use it to get a reference to the UI widget
    object on the heap by using its unique `id` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we get a reference to a `TextView` widget with an `id` property
    of `txtTitle` and assign it to a new Java object, called `myTextView`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using our `myTextView` instance variable, we can do anything that the
    `TextView` class was designed to do. For example, we can set the text to show
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can make it disappear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change its text again and make it reappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning we can manipulate any property in Java that we set using
    XML in the previous chapters. Furthermore, we have hinted at – but not actually
    seen – the creation of widgets from nothing, using just Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI widgets from pure Java without XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also create widgets from Java objects that are not a reference to an
    object in our layout. We can declare, instantiate, and set a widget''s attributes
    all in code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a new `Button` by using the `new()` keyword. The
    only caveat is that the `Button` has to be part of a layout before it can be seen
    by the user. So, we could either get a reference to a layout element from our
    XML layout or create a new one, in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assume that we have a `LinearLayout` in our XML with an `id` property
    equal to `linearLayout1`, we could put our `Button` from the earlier line of code
    into it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We could even create an entire layout in pure Java code by, first, creating
    a new layout and then all the widgets we want to add. Then, finally, we call the
    `setContentView` method on the layout that has our widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have created a layout in pure Java, albeit a very
    simple one with a single `Button` inside a `LinearLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is probably obvious – but well worth pointing out – that designing a detailed
    and nuanced layout using only Java is significantly more awkward, harder to visualize,
    and not the way it is usually done. However, there are times when we will find
    it useful to do things this way.
  prefs: []
  type: TYPE_NORMAL
- en: We are getting quite advanced now with layouts and widgets. However, it is evident
    that there are a whole bunch of other widgets from the palette that we have not
    explored or interacted with. So, let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the palette – part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a whirlwind tour of some of those previously unexplored/unused items
    from the palette. Then, we can drag a bunch of them onto a layout and see some
    of the methods they have that might be useful. We can then implement a project
    to put them all to use.
  prefs: []
  type: TYPE_NORMAL
- en: We already explored the `Button` and `TextView` widgets in the last chapter.
    Let's take a closer look at some additional widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The EditText widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EditText` widget does as its name suggests. If we make an `EditText` widget
    available to our users, then they will indeed be able to *edit* the *text* inside
    it. We looked at this in an earlier chapter; however, we didn't actually achieve
    anything with it. What we didn't explore was how to capture the information from
    within it, or where we would type this text-capturing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code assumes that we have declared an object of the
    `EditText` type and used it to get a reference to an `EditText` widget in our
    XML layout. We might write code similar to the following code for a button click,
    for example, a submit button for a form. However, it could go anywhere we deem
    necessary for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will use this in a real-life context in the next mini-app.
  prefs: []
  type: TYPE_NORMAL
- en: The ImageView widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already put an image onto our layout a couple of times so far, but
    we have never got a reference to one from our Java code or done anything with
    it before. The process of getting a reference to an `ImageView` widget is the
    same as any other widget:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get a reference using the `findViewById` method and a valid `id` property,
    such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can go on to do some quite neat things with our image by using code
    that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The odd-looking `f` simply lets the compiler know the value is of the `float`
    type, as required by the `setAlpha` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding, we use the `setAlpha` method on `imageView`. The `setAlpha`
    method takes a value between 0 and 1\. An image that is completely see-through
    is 0, while an image with no transparency at all is 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There is also an overloaded `setAlpha` method that takes an integer value from
    0 (completely see-through) to 255 (no transparency). We can choose whichever is
    the most appropriate at the time. If you want a reminder about method overloading,
    please refer back to [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169),
    *Learning* *Java Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: We will use some of the `ImageView` class' methods in our next app.
  prefs: []
  type: TYPE_NORMAL
- en: Radio buttons and groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `RadioButton` widget is used when there are two or more mutually exclusive
    options for the user to choose from. This means that when one option is chosen,
    the other options are not – just like on an old-fashioned radio. Take a look at
    a simple `RadioGroup` with a few `RadioButton` widgets in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – RadioButton widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.01_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – RadioButton widget
  prefs: []
  type: TYPE_NORMAL
- en: 'As the user selects a choice, the other options will automatically be deselected.
    We control `RadioButton` widgets by placing them within a `RadioGroup` in our
    UI layout. We can, of course, use the visual designer to simply drag a bunch of
    `RadioButtons` onto a `RadioGroup`. When we do so within a `ConstraintLayout`
    layout, the XML will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, as highlighted in the previous code, that each `RadioButton` instance
    has an appropriate `id` attribute set. We can then get a reference to them, as
    we might expect, as this code shows us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In practice, however, as you will see, we can manage almost everything from
    the `RadioGroup` reference alone. Additionally, you will learn that we can assign
    an `id` property to the `RadioGroup` widget for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, how do we know when they have been clicked on? Or, you
    might wonder whether keeping track of the one that has been selected might be
    awkward. We will need some help from the Android API and Java in the form of anonymous
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)*, The Stack, the
    Heap, and the Garbage Collector*, we briefly introduced anonymous classes. Here,
    we will discuss it in a little more detail and examine how they can help us. When
    a `RadioButton` widget is part of a `RadioGroup` widget, the visual appearance
    of them all is coordinated for us. All we need to do is react when any given `RadioButton`
    widget is pressed. Of course, as with any other button, we need to know when they
    have been clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: A `RadioButton` widget behaves differently to a regular `Button`, and simply
    listening for clicks in `onClick` (after implementing `OnClickListener`) will
    not work because `RadioButton` is not designed that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is use another Java feature. We need to implement a class,
    that is, an anonymous class, for the sole purpose of listening for clicks on the
    `RadioGroup` widget. The next block of code assumes that we have a reference to
    a `RadioGroup` widget, called `radioGroup`. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code, specifically, `RadioGroup.OnCheckedChangedListener` from
    its opening `{` to closing `}`, is what is known as an **anonymous** class. This
    is because it has no name.
  prefs: []
  type: TYPE_NORMAL
- en: If we place the preceding code in the `onCreate` method, then, surprisingly,
    the code does not run when `onCreate` is called. It simply prepares the new anonymous
    class to be ready to handle any clicks on `radioGroup`. We will now discuss this
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: This class is more technically known as an **anonymous inner** class because
    it is inside another class. Inner classes can be anonymous or have names. We will
    learn about inner classes with names in [*Chapter 16*](B16773_16_ePub_RK.xhtml#_idTextAnchor285),
    *Adapters and Recyclers*.
  prefs: []
  type: TYPE_NORMAL
- en: I remember the first time I saw an anonymous class, and it made me want to hide
    in a cupboard. However, it is not as complex as it might appear at first.
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing is adding a listener to `radioGroup`. This has, very much,
    the same effect as when we implemented `View.OnClickListener` in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*. However, this time, we are declaring
    and instantiating a listener class, preparing it to listen to `radioGroup`, while
    simultaneously overriding the required method, which, in this case, is `onCheckedChanged`.
    This is like the `RadioGroup` equivalent of `onClick`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s step through the process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we call the `setOnCheckedChangedListener` method on our `radioGroup`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We then provide a new anonymous class implementation that includes the details
    of this class'' overridden method as an argument to the `setOnCheckedChangedListener`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the closing parenthesis of the method along with, of course,
    the semicolon to mark the end of the line of code. The only reason we present
    it on multiple lines is to make it more readable. As far as the compiler is concerned,
    it could be all lumped together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we use the preceding code to create and instantiate a class that listens
    for clicks to our `RadioGroup`, perhaps in the `onCreate` method, it will listen
    and respond for the entire life of the Activity. All we need to learn now is how
    to handle the clicks in the `onCheckedChanged` method that we override.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that one of the parameters of the `onCheckedChanged` method, which is
    passed in when `radioGroup` is pressed, is `int checkedId`. This holds the `id`
    property of the currently selected `RadioButton` widget. This is just what we
    need – well, almost.
  prefs: []
  type: TYPE_NORMAL
- en: It might be surprising to know that `checkedId` is an `int`. Android stores
    all IDs as `int`, even though we declare them with alphanumeric characters such
    as `radioButton1` and `radioGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: All our human-friendly names are converted into integers when the app is compiled.
    So, how do we know which integer value refers to which `id` attribute value such
    as `radioButton1` or `radioButton2`?
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is to get a reference to the actual object that the integer
    is an identifier for. We can do so by using the `int CheckedId` parameter and
    then asking the object for its human-friendly `id` attribute value. We do this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can retrieve the familiar `id` attribute value that we used for the
    currently selected `RadioButton` widget, for which we now have a reference stored
    in `rb`, using the `getId` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We could, therefore, handle any `RadioButton` widget clicks by using a `switch`
    block with a `case`, for each possible `RadioButton` widget that could be pressed,
    and `rb.getId()`, as the `switch` block's expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Th following code shows the entire contents of the `onCheckedChanged` method
    that we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To make this clearer, we will view this in action in the next working app, where
    we can press the buttons in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our palette exploration.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the palette and more anonymous classes – part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how anonymous classes work, specifically with `RadioGroup`
    and `RadioButton`, we can continue to explore the palette and examine how anonymous
    classes work with some more UI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Switch` (not to be confused with the lowercase `switch` Java keyword) widget
    is just like a `Button` widget, except it has two possible states that can be
    read and responded to.
  prefs: []
  type: TYPE_NORMAL
- en: One obvious use for the `Switch` widget is to show or hide something. Remember
    that in our Java Meet UI app, in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*, we used a `Button` widget to
    show and hide a `TextView` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time we hid or showed the `TextView` widget, we changed the `text` property
    on the `Button` widget to make it clear what would happen if it was clicked on
    again. What might have been more intuitive for the user, and more straightforward
    for us as programmers, would have been to use a `Switch` widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Switch widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.02_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Switch widget
  prefs: []
  type: TYPE_NORMAL
- en: The following code assumes that we already have an object called `mySwitch`,
    which is a reference to the `Switch` object in the layout. We could show and hide
    a `TextView` widget just like we did in our Java Meet UI app in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector*.
  prefs: []
  type: TYPE_NORMAL
- en: To listen for and respond to clicks, we, again, use an anonymous class. However,
    this time, we use the `CompoundButton` version of `OnCheckedChangedListener` instead
    of the `RadioGroup` version.
  prefs: []
  type: TYPE_NORMAL
- en: We need to override the `onCheckedChanged` method, and that method has a Boolean
    parameter, called `isChecked`. The `isChecked` variable is simply `false` for
    off and `true` for on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we could, more intuitively, replace that text hiding/showing code
    from [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218), *The Stack, the
    Heap, and the Garbage Collector*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the anonymous class code still looks a little odd, don't worry because it
    will become more familiar as you keep using it. We will do so now when we look
    at the `CheckBox` widget.
  prefs: []
  type: TYPE_NORMAL
- en: CheckBox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a `CheckBox` widget. It is either checked or unchecked. In the following
    screenshot, it is checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – CheckBox widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.03_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – CheckBox widget
  prefs: []
  type: TYPE_NORMAL
- en: 'With a `CheckBox` widget, we can simply detect its state (checked or unchecked)
    at a given moment – for example, at the moment when a specific button is clicked
    on. The following code gives us a glimpse at how this might happen, again using
    an inner class to act as a listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we assume that `myCheckBox` has been declared and initialized.
    Then, we use the same type of anonymous class that we did for `Switch`, in order
    to detect and respond to clicks.
  prefs: []
  type: TYPE_NORMAL
- en: TextClock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our next app, we will use the `TextClock` widget to show off some of its
    features. We will need to add the XML directly, as this widget is not available
    to drag and drop from the palette. The `TextClock` widget looks similar to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – TextClock widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.04_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – TextClock widget
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using `TextClock`. This is how we would set its
    time to the same time as it is in Brussels, Europe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code assumes that `tClock` is a reference to a `TextClock` widget
    in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Using WebView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebView is quite a powerful widget. It can be used to show a web page in your
    app's UI. You can even implement a basic web browser app with just half a dozen
    lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you wouldn't implement an entire web browser; rather, you would use
    the user's preferred web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simply get a reference to a `WebView` widget that is present in the XML
    and display a website, you would only need two lines of code. This code loads
    my website – [https://gamecodeschool.com](https://gamecodeschool.com) – assuming
    that there is a `WebView` widget in the layout with the `id` property set to `webView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With all of this extra information, let's make an app that uses the Android
    widgets more extensively than we have so far.
  prefs: []
  type: TYPE_NORMAL
- en: The Widget Exploration app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have discussed seven widgets: `EditText`, `ImageView`, `RadioButton`
    (and `RadioGroup`), `Switch`, `CheckBox`, `TextClock`, and `WebView`. Let''s make
    a working app and do something real with each of them. We will also use a `Button`
    widget and a `TextView` widget again.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can refer to the completed code in the download bundle. This
    app can be found in [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)`/Widget
    Exploration`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Widget Exploration project and UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will set up a new project and prepare the UI layout. These steps
    will arrange all the widgets on the screen and set the `id` properties, ready
    to grab a reference to them. It is useful to look at the target layout – while
    it is up and running – before we get started. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Widget exploration layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.05_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – Widget exploration layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how this app will demonstrate these widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: The radio buttons allow the user to change the time displayed on the clock to
    a choice of three time zones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TextView` widget (which is on the right) to whatever is currently in the
    `EditText` widget (which is on the left).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three `CheckBox` widgets will add and remove visual effects from the Android
    robot image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Switch` widget will turn on and off the `TextView` widget, which displays
    information entered in the `EditText` widget and is captured at the push of a
    button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `WebView` widget will occupy the full width and bottom half of the app.
    Keep this in mind when adding widgets to the layout; try and get them all in the
    top half.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exact layout positions are not essential, but the `id` properties that are
    specified must match exactly. If you just want to view/use the code, you can find
    all of the files in the [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)`/Widget
    Exploration` folder of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s perform the following steps to set up a new project and prepare
    the UI layout:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project, called `Widget Exploration`. Set the `API 17:Android 4.2
    (Jelly Bean)`. Then, use an Empty Activity and keep all the other settings at
    their defaults. We are using `API 17` because one of the features of the `TextClock`
    widget requires us to. We can still support in excess of 99% of all Android devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the `activity_main.xml` layout file and make sure you are in the design
    view. Delete the default `TextView` widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the drop-down controls that are displayed above the design view (as shown
    in the following screenshot), select a tablet in landscape orientation. I chose
    the **Pixel C** option:![Figure 13.6 – Selecting the orientation options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.06_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – Selecting the orientation options
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For a reminder of how to make a tablet emulator, please refer to [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064),
    *Exploring Android Studio and the Project Structure*. For additional advice on
    how to manipulate the orientation of the emulator, please refer to [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101),
    *Beautiful Layouts with CardView and ScrollView*.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a **Switch** widget from the **Button** category of the palette to near
    the upper-right corner of the layout. Then, just below this, add a **TextView**
    widget. The upper-right corner of your layout should now look similar to the following
    screenshot:![Figure 13.7 – Switch widget to the layout
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.07_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – Switch widget to the layout
  prefs: []
  type: TYPE_NORMAL
- en: Drag three `sym_def_app_icon` to use the Android icon as the image for the `ImageView`.
    The central portion of the layout should now look similar to the following screenshot.
    For more context on the final layout, please refer back to the screenshot showing
    the completed app:![Figure 13.8 – CheckBox widget
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.08_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – CheckBox widget
  prefs: []
  type: TYPE_NORMAL
- en: Drag **RadioGroup** to the upper-left corner of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three **RadioButton** widgets within the **RadioGroup**. This step can be
    easily done using the **Component Tree** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath **RadioGroup**, drag a **Plain Text** widget from the **Text** category
    of the palette. Remember, despite its name, this is a widget that allows the user
    to type some text into it. Later, we will learn how to capture and use the entered
    text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Button** widget underneath the **Plain Text** widget. The left-hand
    side of your layout should look similar to the following screenshot:![Figure 13.9
    – Adding a Button widget
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.09_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.9 – Adding a Button widget
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following attributes to the widgets we have just laid out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that some of the attributes might already be correct by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16773_table_1.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The penultimate widget is a bit different, so I thought we would handle it separately.
    Add another regular `TextView` widget underneath the `Button` widget on the left-hand
    side, and set its `id` property to `textClock`. Remember to keep this widget,
    as with all of the other widgets, above the approximate halfway point vertically.
    Readjust some of the widgets above it if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the code view and find the `TextView` widget that we are working on
    – the one with `textClock` as its `id` property value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the start of the XML code, as shown in the following code snippet,
    with a couple of key parts highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Switch to the **Design** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it's time for the final widget. Drag a `WebView` widget from the `WebView`
    widget is apparently missing. In fact, if you look very carefully, you can see
    a tiny indication that the widget is in the upper-left corner of the layout. We
    will configure the position and size of the `WebView` widget slightly differently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the `WebView` widget is selected in the component tree window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `id` attribute to `webView` (if it isn't this value already).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this next step to work correctly, all the other widgets must be constrained.
    Therefore, click on the **Infer Constraints** button to secure all of the other
    widgets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the moment, our `WebView` widget is not constrained to anything, and it is
    not possible to grab the constraint handles that we need. Now, find the **Layout**
    section in the attributes window, as shown in the following screenshot:![Figure
    13.10 – Adding constraint
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – Adding constraint
  prefs: []
  type: TYPE_NORMAL
- en: Left-click on the add constraint to the bottom button, as highlighted in the
    previous screenshot. Now, we have a constraint where the bottom of the `WebView`
    widget is constrained to the bottom of the layout. This is almost perfect, but
    the default margin is set very high.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `layout_margin_bottom` property in the properties window and change
    it to `0dp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `layout_height` property in the properties window to `400dp`. Note
    that when this project is complete, if your `WebView` widget is too tall or too
    short, then you can come back and tweak this value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tweak your layout to resemble the following reference diagram as much as possible.
    However, if you have the appropriate types of UI with the correct `id` attributes,
    then the code will still work even if the layout isn''t identical. Remember that
    the `WebView` widget is not visible, but it will take up the entire bottom half
    of the screen once we have done some coding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Tweaking layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.11_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.11 – Tweaking layout
  prefs: []
  type: TYPE_NORMAL
- en: We have just laid out and set the required attributes for our layout. There
    is nothing here that we haven't done before, except that some of the widget types
    are new to us and the layout is slightly more intricate.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can get on with using all of these widgets in our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Widget Exploration app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many `import` statements needed for this app. So, let''s add them
    all now to save us from having to mention them all the time. Add the following
    `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's get a reference to all the parts of the UI that we will be using in the
    Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a reference to all the parts of the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This next block of code looks quite long and sprawling, but all we are doing
    is getting a reference to each of the widgets in our layout. When we come to use
    them, we will discuss the code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that is new in this next block of code is that some of the objects
    are declared as `final`. This is needed as they are going to be used within an
    anonymous class.
  prefs: []
  type: TYPE_NORMAL
- en: But doesn't `final` mean that the object cannot be changed?
  prefs: []
  type: TYPE_NORMAL
- en: If you recall [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*, More
    Object-Oriented Programming*, we learned that variables declared as `final` could
    not be changed, that is, they are a constant. So, how are we going to change the
    attributes of these objects? Remember that objects are reference type variables.
    This means that they refer to an object on the heap. They are not the object themselves.
    We can think of them as holding an address of an object. It is the address that
    cannot change. We can still use the address to reference the object on the heap
    and change the actual object as much as we like. Let's take the address analogy
    further. If you live at a particular address and if the address is final, then
    you cannot move to a new house. However, you are unrestricted in what you can
    do at that address. For example, you can still rearrange your house, perhaps repaint
    the living room, and put the bath in the kitchen and the sofa on the roof.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code just after the call to the `setContentView` method
    in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We now have a reference, in our Java code, to all of the UI elements in our
    layout that we need to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the checkboxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we can create an anonymous class to listen for and handle clicks on the
    checkboxes. The next three blocks of code each implement an anonymous class for
    each of the checkboxes in turn. However, what is different in each of the following
    three blocks of code is how we respond to a click; we will discuss each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the transparency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first checkbox is labeled `setAlpha` method in `imageView` to change how
    transparent (or see-through) it is. The `setAlpha` method takes a floating-point
    value between 0 and 1 as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 0 is invisible, and 1 refers to no transparency at all. So, when this checkbox
    is checked, we set the alpha to `.1`, which means that the image is barely visible.
    And when it is unchecked, we set it to `1`, which means that it is completely
    visible with no transparency. The `boolean isChecked` parameter of `onCheckedChanged`
    contains `true` or `false` to show whether the checkbox is checked or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code after the previous block of code in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the next anonymous class, we will handle the checkbox labeled **Tint.**
  prefs: []
  type: TYPE_NORMAL
- en: Changing the color
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the `onCheckedChanged` method, we use the `setColorFilter` method in `imageView`
    to overlay a color layer on the image. When `isChecked` is true, we layer a color,
    and when `isChecked` is false, we remove it.
  prefs: []
  type: TYPE_NORMAL
- en: The `setColorFilter` method takes a color in `argb`, of the `Color` class. The
    four arguments of the `argb` method are, as you might expect, values for alpha,
    red, green, and blue. These four values create a color. In our case, the value
    of `150`, `255`, `0`, `0` creates a strong red tint. Alternatively, the value
    of `0`, `0`, `0`, `0` creates no tint at all.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand more about the `Color` class, check out the Android developer
    site at [http://developer.android.com/reference/android/graphics/Color.html](http://developer.android.com/reference/android/graphics/Color.html).
    Additionally, to understand the RGB color system in more detail, please refer
    to the following Wikipedia page: [https://en.wikipedia.org/wiki/RGB_color_model](https://en.wikipedia.org/wiki/RGB_color_model).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code after the previous block of code in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we will look at how to scale the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the anonymous class that handles the labeled `setScaleX` method to resize
    the robot image. When we call `setScaleX(2)` and `setScaleY(2)` in `imageView`,
    we will double the size of the image, and `setScaleX(1)` and `setScaleY(1)` will
    return it to normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code after the previous block of code in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we will handle the three radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the radio buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As they are part of a `RadioGroup` widget, we can handle them much more succinctly
    than we did the `CheckBox` objects. Here is how we do it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we make sure they are clear to start with, by calling `clearCheck()`
    in `radioGroup`. Then, we create our anonymous class of the `OnCheckedChangedListener`
    type and override the `onCheckedChanged` method.
  prefs: []
  type: TYPE_NORMAL
- en: This method will be called when any `RadioButton` widget from `RadioGroup` is
    clicked on. All we need to do is get the `id` property of the `RadioButton` widget
    that was clicked on and respond accordingly. We can achieve this by using a `switch`
    statement with three possible cases, one for each `RadioButton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will remember that when we first talked about `RadioButton` widgets, we
    mentioned that the value supplied in the `checkedId` parameter of the `onCheckedChanged`
    method is an integer. This is why we must first create a new `RadioButton` instance
    from the `checkedId` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can call `getId` on the new `RadioButton` instance as the condition
    for the `switch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, in each `case` option, we use the `setTimeZone` method with the proper
    Android time zone code as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can view all the Android time zone codes at [https://gist.github.com/arpit/1035596](https://gist.github.com/arpit/1035596).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code, which incorporates everything we just discussed.
    Add it to the `onCreate` method after the previous code that we entered to handle
    the checkboxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now for something a little bit new.
  prefs: []
  type: TYPE_NORMAL
- en: Using an anonymous class for a regular Button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next block of code, we will write and use an anonymous class to handle
    the clicks on a regular `Button`. We call `button.setOnclickListener` just as
    we have done so before. However, this time, instead of passing `this` as an argument,
    we create a brand-new class of the `View.OnClickListener` type and override the
    `onClick` method as the argument – just like we did with our other anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This method is preferable in this situation because there is only one button.
    If we had lots of buttons, then having `MainActivity` implement `View.OnClickListener`,
    and then overriding the `onClick` method to handle all clicks in one method, would
    probably be preferable, as we have done previously.
  prefs: []
  type: TYPE_NORMAL
- en: In the `onClick` method, we use the `setText` method to set the `text` property
    on `textView` and the `getText` method of `editText` to get whatever text is currently
    in the `EditText` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the previous block of code in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Coding the Switch widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we will create yet another anonymous class to listen for and handle changes
    to our `Switch` widget.
  prefs: []
  type: TYPE_NORMAL
- en: When the `isChecked` variable is `true`, we show `textView`; when it is `false`,
    we hide it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the previous block of code in the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we can move on to the `WebView` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Using WebView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your manifest must include the `INTERNET` permission. This is how we add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file, and add the following line of highlighted
    code, which is shown with a bit of context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will add two more lines of code in order to grab a reference to
    the `WebView` widget and load up a website. It should be a relatively straightforward
    process to modify the code in order to load any website that you like. Add the
    following lines of code to the end of the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run our app and try out all the features.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Widget Exploration app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run the app in the usual way, making sure that you use your tablet emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The Android emulators can be rotated into landscape mode by pressing the *Ctrl
    + F11* keyboard combination on a PC or *Ctrl + fn+ F11* on a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the entire app, including the `WebView` widget, which is now visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Final app layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.12_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.12 – Final app layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Try checking the radio buttons to see the time zone change on the clock. In
    the following diagram, I have Photoshopped a few cropped screenshots together
    to show that the time changes when a new time zone is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Time zones'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.13_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.13 – Time zones
  prefs: []
  type: TYPE_NORMAL
- en: 'To test out the **CAPTURE** button, the editable text, and the switch, follow
    these steps (we have also listed them in the adjoining screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: Enter different values into the `EditText` widget (which is on the left).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **CAPTURE** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the `Switch` widget is on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Testing the CAPTURE button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.14_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.14 – Testing the CAPTURE button
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change what the preceding diagram looks like with different combinations
    of checked and unchecked checkboxes, and you can hide and show the `TextView`
    widget by using the switch above it. The following screenshot shows what happens
    to the `ImageView` widget when you have the **Tint** and **Re-size** options selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Testing the ImageView widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.15_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.15 – Testing the ImageView widget
  prefs: []
  type: TYPE_NORMAL
- en: Oops! The size of the icon has been increased so much that it overlaps with
    the **Re-size** checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Transparency doesn't show very clearly in a printed book, so I haven't shown
    a visual example of the **Transparency** box being checked. Be sure to try this
    out on an emulator or real device.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned so much in this chapter, and we have explored a plethora of
    widgets. We learned how to implement widgets in Java code without any XML, and
    we used our first anonymous classes to handle clicks on a widget and put all our
    new widget prowess into a working app.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to look at another way in which we can significantly enhance
    our UIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at a totally new UI element that we can't
    simply drag and drop from the palette, but we will still have plenty of help from
    the Android API. Next up are dialog windows. Additionally, we will also make a
    start on our most significant app so far, the Note to Self app, for memos, to-do
    lists, and personal notes.
  prefs: []
  type: TYPE_NORMAL
