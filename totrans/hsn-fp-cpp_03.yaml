- en: Understanding Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions are the core building blocks of functional programming. They
    are immutable functions, which allow them to be simple and predictable. Writing
    pure functions in C++ is easy, but there are a few things that you'll need to
    be aware of. Since functions in C++ are mutable by default, we need to learn the
    syntax that tells the compiler how to prevent mutations. We'll also explore how
    to separate mutable code from immutable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what a pure function is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing pure functions in C++ and functions that return multiple arguments using
    tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring immutability in C++ pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding why I/O is mutable and needs to be separated from pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a C++ compiler that supports C++ 17\. I'm using GCC version 7.3.0\.
    Code samples are on GitHub ([https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp))
    in the `Chapter02` folder and have a `makefile` file for your convenience.
  prefs: []
  type: TYPE_NORMAL
- en: What is a pure function?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a moment to think about a simple everyday experience. When you
    turn the light switch, one of two things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: If the light is on, it turns off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the light is off, it turns on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The behavior of a light switch is highly predictable. It's so predictable that,
    when the light doesn't turn on, you immediately think that something is wrong—that
    is, with the light bulb, the fuses, or the switch itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the things that you don''t expect to happen when you turn
    the switch on or off:'
  prefs: []
  type: TYPE_NORMAL
- en: Your fridge doesn't go off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your neighbor's lights don't turn on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your bathroom sink water doesn't turn on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your mobile phone doesn't reset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why would all these things happen when you turn the light switch on? That would
    be highly chaotic; we wouldn't want chaos in our lives, right?
  prefs: []
  type: TYPE_NORMAL
- en: Yet, programmers often experience such behaviors in code. Calling a function
    often results in changes to the state of the program; when this happens, we say
    that a function has **side effects**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programming tries to reduce the chaos caused by a state change through
    the extended use of pure functions. Pure functions are functions that have two
    constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: They always return the same output values for the same argument values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't have side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s explore how we would write the code for the light switch. We''ll assume
    that the bulb is an external entity that we can call; think of it as the output
    from **input/output** (**I/O**) for our program. The natural code for a structured/object-oriented
    programmer would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are two things happening with this function. Firstly, it uses an input
    that's not part of the list of parameters, that is, `switchIsOn`. Secondly, it
    directly produces side effects on the bulb.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does a pure function look like? Well, in the first instance, all of
    its parameters are visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we need to get rid of the side effect. How can we do that? Let''s separate
    the computation of the next state from the action of turning the light bulb on
    or off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is now pure, and we''ll discuss this in more detail later; however,
    for now, let''s simplify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make things even clearer (I''ll assume the function is part of a class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is terribly uninteresting: it''s very predictable, it''s easy
    to read, and it doesn''t have side effects. This sounds exactly like a well-designed
    light switch. Moreover, it sounds exactly like what we want when we maintain a
    huge number of lines of code for tens of years.'
  prefs: []
  type: TYPE_NORMAL
- en: We now understand what a pure function is and why it's useful. We also demonstrated
    an example of separating pure functions from side effects (usually I/O). It's
    an interesting concept, but where can it take us? Can we really build complex
    programs using such simple constructs? We'll discuss how to compose pure functions
    in the following chapters. For now, let's focus on understanding how to write
    pure functions in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve already seen, in the preceding example, the basic syntax that we need
    to use for pure functions in C++. You just need to remember the following four
    ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions don't have side effects; if they are part of a class, they can
    be `static` or `const`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions don't change their parameters, so every parameter has to be of
    the `const`, `const&`, or `const* const` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions always return values. Technically, we can return a value through
    an output parameter, but it's usually simpler to just return a value. This means
    that pure functions usually don't have a void return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of the preceding points guarantee the lack of side effects or immutability,
    but they take us close. For example, data members can be marked as mutable and
    the `const` methods could change them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll explore, in the following sections, how to write pure functions both as
    free functions and as class methods. When we go through the examples, remember
    that we are exploring the syntax for now, focusing on how to use the compiler
    to get as close as possible to pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions without arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start simple. Can we use pure functions without arguments? Certainly.
    One example is when we need a default value. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a standalone function. Let''s understand how to write a pure function
    inside a class as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `static` tells us that the function doesn''t change any non-static data
    member. However, this doesn''t prevent the code from changing the value of a `static`
    data member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, we''ll see that we can solve most mutable state problems with
    well-placed `const` keywords. The following case is no exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have gained some understanding of how to write pure functions without
    arguments, it's time to add more arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions with one or more arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with one pure class method with one parameter, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'How about two parameters? Sure, let''s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same with reference types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can do the same with pointer types, albeit with a bit more
    syntactic sugar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations—you now know how to write pure functions in C++!
  prefs: []
  type: TYPE_NORMAL
- en: Well, kind of; unfortunately, immutability is a bit more complex to implement
    in C++ than what we've seen so far. We need to look at various situations in more
    depth.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions and immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 1995 movie, *Apollo 13*, is one of my favorite thrillers. It involves space,
    a real story, and multiple engineering problems. Between many memorable scenes,
    there's one in particular that can teach us a lot about programming. While the
    team of astronauts is preparing a complex procedure, the commander, played by
    Tom Hanks notices, that his colleague placed a sticker on one of the command switches
    saying *Don't flip this.* The commander asks his colleague why he did that, and
    his answer is something along the lines of *My head wasn't clear, and I was afraid
    I would flip this and send you to space. So, I wrote this to remind myself not
    to make this mistake.*
  prefs: []
  type: TYPE_NORMAL
- en: If this technique works for astronauts, it should work for programmers. Fortunately,
    we have the compiler to tell us when we do something wrong. However, we need to
    tell the compiler what we want it to check.
  prefs: []
  type: TYPE_NORMAL
- en: After all, we can write pure functions without any `const` or `static`. Function
    purity is not a matter of syntax, but a concept. Having the right stickers in
    place can prevent us from making mistakes. We'll see, however, that the compiler
    can only go so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another way to implement the increment function that
    we discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a pure function. Can you see why? The answer is on the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`++value` not only increments `value`, but it also changes the input parameter.
    While it''s not a problem in this case (the `value` parameter is passed by value,
    so only its copy is modified), it''s still a side effect. This shows how easy
    it is to write side effects in C++, or in any language that doesn''t enforce immutability
    by default. Fortunately, the compiler can help us, as long as we tell it exactly
    what we want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the previous implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you try to write `++value` or `value++` in the body of this function, the
    compiler will immediately tell you that you're trying to change a `const` input
    parameter. That's very nice of the compiler, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: What about the parameters passed by reference though?
  prefs: []
  type: TYPE_NORMAL
- en: Immutability and passing by reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem could have been worse. Imagine the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re avoiding a pass by value, which involves a few more bytes of memory.
    But what happens with the value? Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `value` parameter started at `0`, but when we called the function, it was
    incremented, so now its `value` is `1`. That''s like every time you turn on the
    light, your refrigerator door opens. Fortunately, if we just add a small `const`
    keyword, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, the compiler is once again nice enough to tell us that we can't use `++value`
    or `value++` in its body.
  prefs: []
  type: TYPE_NORMAL
- en: That's cool, but what about pointer arguments?
  prefs: []
  type: TYPE_NORMAL
- en: Immutability and pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using pointers as input parameters, preventing unwanted changes becomes
    more complex. Let''s see what happens when we try calling this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following things could change:'
  prefs: []
  type: TYPE_NORMAL
- en: The value pointed by `pValue` could change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pointer could change its address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The value pointed by `pValue` can change in similar conditions, as we discovered
    previously. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will change the pointed value as well as return it. To make it impossible
    to change, we need to use a well-placed `const` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes to the pointer address are trickier than you''d expect. Let''s
    take a look at an example that will behave in an unexpected way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this on my laptop gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The address doesn't change, even though we're incrementing it in the function
    by using `++pValue`. The same also happens with `pValue++`, but why is this the
    case?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the pointer address is a value, and it''s passed by value, so any change
    within the function body only applies to the function scope. To make the address
    change, you need to pass the address by reference, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that, fortunately, it''s not easy to write functions that change
    a pointer address. I still feel safer telling the compiler to enforce this rule
    for me:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this doesn''t block you from changing the value pointed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To enforce immutability for both the value and the address, you need to use
    even more `const` keywords, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This covers all types of class functions. However, C++ allows us to write functions
    outside classes. So, does `static` still work in this situation? (Spoiler alert:
    not quite as you would expect).'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability and non-class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the examples so far assume that the functions are part of a class. C++
    allows us to write functions that are not part of any class. For example, we could
    write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that we're not using `static` anymore. You can use `static`,
    but you need to be aware that it has a completely different meaning to the functions
    in a class. `static` applied to a standalone function means that *you can't use
    it from a different translation unit*; so, if you write the function in a CPP
    file, it will just be available in that file and it will be ignored by the linker.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered all types of class and non-class functions. But what about functions
    that have output parameters? As it turns out, they need a bit of work.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability and output parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want a function to change the data that we pass in. There are
    many examples in **Standard Template Library*** (***STL**), and the easiest one
    to provide as an example is `sort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this doesn''t fit the idea of pure functions; a pure equivalent of
    `sort` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I can hear you thinking, *but the STL implementation works in place for optimization
    reasons, so are pure functions less optimized?* Well, as it turns out, pure functional
    programming languages, such as Haskell or Lisp, also optimize such operations;
    a `pureSort` implementation would just move the pointers around and only allocate
    more memory when one of the pointed values is changed. These are, however, two
    different contexts; C++ has to support multiple programming paradigms, while Haskell
    or Lisp optimize for immutability and functional style. We will discuss optimization
    further in [Chapter 10](4612efcd-7520-4ae3-9813-0c42acee664a.xhtml), *Performance
    Optimization*. For now, let's examine how to make these types of functions pure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve discovered how to deal with one output parameter. But how can we write
    pure functions that will have multiple output parameters? Let''s consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple solution to this problem would be to replace the two arguments with `vector<int>`.
    But what happens if the parameters have different types? Then, we could use a
    struct. But what if this is the only time we need it? Fortunately, STL offers
    a solution to this problem, that is, through tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples have a number of advantages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They can be used with multiple values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values can have different data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are easy to build—just one function call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't require an additional data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From my experience, tuples are a great solution when you are trying to render
    a function that has multiple output parameters pure, or a return value and an
    output parameter. However, I often try to refactor them toward named *struct*s
    or data classes after I figure out how to design them. Nonetheless, using tuples
    is a very useful technique; just use them sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: By now, we have used a lot of `static` functions. But aren't they bad practice?
    Well, that depends on a number of things; we'll discuss this in more detail next.
  prefs: []
  type: TYPE_NORMAL
- en: Aren't static functions bad practice?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you may be wondering whether pure functions are good since they contradict
    with the rules of **object-oriented programming** (**OOP**) or clean code, that
    is, to avoid `static`. However, until now, we've only written `static` functions.
    So, are they good or bad?
  prefs: []
  type: TYPE_NORMAL
- en: There are two arguments against using `static` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument against `static` functions is that they hide the global state.
    Since `static` functions can only access `static` values, those values become
    global state. Global state is bad because it's hard to understand who changes
    it, and it's also hard to debug when its value is unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: But remember the rules for pure functions—a pure function should return the
    same output values for the same input values. Therefore, a function is pure if,
    and only if, it does not depend on global state. Even when the program has a state,
    all the necessary values are sent to the pure functions as input parameters. Unfortunately,
    we cannot easily enforce this using the compiler; it has to be the practice of
    the programmer to avoid using any kind of global variable and to turn it into
    a parameter instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an edge case for this situation, specifically when using global constants.
    While constants are an immutable state, it''s important to consider their evolution
    as well. For instance, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, you should know that there will come a time when the constant will become
    a variable, and then you'll have to change a bunch of code to implement the new
    requirement. My advice is that it's usually better to pass in the constants as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument against `static` functions is that they shouldn't be part
    of a class. We will discuss this argument in more detail in the following chapters;
    suffice to say that, for now, classes should group cohesive functions, and, sometimes,
    the pure functions should fit together neatly in a class. There's also an alternative
    to grouping cohesive pure functions in a class—just use a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we don't necessarily have to use `static` functions in classes.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to static functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discovered in the previous section how to write pure functions in a `Number`
    class by using `static` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there''s another alternative; C++ allows us to avoid `static`, but
    keep the functions immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `const` keyword after each function signature just tells us that the function
    can access data members of the `Number` class, but can never change them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change this code slightly, we can ask an interesting question about immutability
    in the context of a class. If we initialize the number with a value and always
    add to the initial value, we obtain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an interesting question: is the `addToInitial` function pure? Let''s
    check the criteria as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it have side effects? No, it doesn't.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it return the same output value for the same input value? This is a tricky
    question because the function has a hidden parameter, that is, the `Number` class
    or its initial value. However, nobody can change `initialValue` from outside the
    `Number` class. In other words, the `Number` class is immutable. Therefore, the
    function will return the same output value for the same `Number` instance and
    the same parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it change the values of its parameters? Well, it only receives one parameter,
    and it doesn't change it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is that the function is, in fact, pure. We will discover in the following
    chapter that it is also a *partially applied function*.
  prefs: []
  type: TYPE_NORMAL
- en: We previously mentioned that everything can be pure inside a program, except
    I/O. So, what do we do with the code that does I/O?
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions and I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following and consider whether the function is pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Well, let's see—it doesn't have arguments, so no value is changed. But something
    is off when compared to our previous example, that is, it doesn't return values.
    Instead, it calls a few functions, of which at least one is pure.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, does it have side effects? Well, yes; one on almost every line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This line of code writes a line of string on the console, which is a side effect!
    `cout` is based on a mutable state, so it's not a pure function. Moreover, due
    to its external dependency, `cout` may fail, leading to exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: We need I/O in our programs though, so what can we do? Well, that's easy—simply
    separate the mutable from the immutable parts. Separate the side effects from
    the non-side effects and reduce the impure functions as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can we make this happen here? Well, there''s a pure function waiting
    to get out of this impure function. The key is to start from the problem; so,
    let''s separate `cout` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We have moved the side effects due to `cout` into another function, and have
    made the intent for the initial function clearer—which is that it's formatting
    something rather than printing. It seems as though we cleanly separated the pure
    function from the impure one.
  prefs: []
  type: TYPE_NORMAL
- en: But did we? Let's check `formatResults` again. It doesn't have side effects,
    as it did before. We are using `stringstream`, which might not be pure, and are
    allocating memory, but all these things are local to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Is memory allocation a side effect? Can a function that allocates memory be
    pure? After all, memory allocation may fail. However, it's virtually impossible
    to avoid some kind of memory allocation in functions. We will accept, therefore,
    that a pure function may fail if there's some kind of memory failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what about its output? Does it change? Well, it has no input parameters,
    but its output can change depending on the memory address allocated by the `new`
    operator. So, it''s not yet a pure function. How do we make it pure? That''s easy—let''s
    pass in a parameter, `pValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we isolated ourselves from the side effects and mutable state. The code
    no longer depends on I/O or the `new` operator. Our function is pure, which brings
    additional benefits—it only does one thing, it's easier to understand what it
    does, it's predictable, and we can test it pretty easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for our function with side effects, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: I think that we can all agree that it's easy to understand what it does, and
    we can safely ignore it as long as all our other functions are pure.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, to obtain code that's more predictable, we should separate pure
    from impure functions, and push the impure functions to the boundaries of the
    system as much as possible. There may be situations when this change is expensive,
    and it's perfectly fine to have impure functions in your code. Just make sure
    you know which are which.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored how to write pure functions in C++. Since there
    are a few tricks that you need to remember, here''s a list of the recommended
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Class functions for pass by value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static int increment(const int value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int increment(const int value) const`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class functions for pass by reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static int increment(const int& value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int increment(const int&value) const`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class functions for pass pointer by value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static const int* increment(const int* const value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int* increment(const int* const value) const`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class functions for pass pointer by reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static const int* increment(const int* const& value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int* increment(const int* const& value) const`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A standalone function for pass by value: ``int increment(const int value)``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A standalone function for pass by reference: `int increment(const int& value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A standalone function for pass pointer by value: `const int* increment(const
    int* value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A standalone function for pass pointer by reference: `const int* increment(const
    int* const& value)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve also discovered that, while the compiler is helpful to reduce side effects,
    it doesn''t always tell us when a function is pure or not. We always need to remember
    the criteria to use when writing a pure function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It always returns the same output values for the same input values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not change the values of the input parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we saw how to separate side effects, usually related to I/O, from our
    pure functions. It's pretty easy, and it usually requires passing in values and
    extracting functions.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to move forward. We can do much more with functions when we treat
    them as first class citizens of our designs. To do that, we need to learn what
    lambdas are and how they are useful. We'll do this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a pure function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is immutability related to pure functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you tell the compiler to prevent changes to a variable that's passed
    by value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you tell the compiler to prevent changes to a variable that's passed
    by reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you tell the compiler to prevent changes to a pointer address that's
    passed by reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you tell the compiler to prevent changes to the value that's pointed
    by a pointer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
