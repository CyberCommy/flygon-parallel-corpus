- en: Chapter 15. Handling Data and Generating Random Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are making good progress. We have a rounded knowledge of both the Android
    UI options and the basics of Kotlin. In the previous few chapters, we started
    bringing these two areas together and we manipulated the UI, including some new
    widgets, using Kotlin code. However, while building the Note to self app, we have
    stumbled upon a couple of blanks in our knowledge. In this chapter, we will fill
    in the first of these blanks, and then, in the next chapter, we will use this
    new information to progress with the app. We currently have no way of managing
    large amounts of related data. Aside from declaring, initializing, and managing
    dozens, hundreds, or even thousands of properties or instances, how will we let
    the users of our app have more than one note? We will also take a quick diversion
    to learn about random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple array mini-app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dynamic array mini-app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArrayLists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashmaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's learn about the `Random` class.
  prefs: []
  type: TYPE_NORMAL
- en: A random diversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we will want a random number in our apps and, for these occasions,
    Kotlin provides us with the `Random` class. There are many possible uses for this
    class, such as if our app wants to show a random tip-of-the-day, or a game that
    has to choose between scenarios, or a quiz that asks random questions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Random` class is part of the Android API and is fully compatible in our
    Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to create random numbers. All the hard work is done
    for us by the `Random` class. First, we need to create a `Random` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use our new object''s `nextInt` function to generate a random number
    between a certain range. The following line of code generates the random number
    using our `randGenerator` object and stores the result in the `ourRandomNumber`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The number that we enter for the range starts from zero. So, the preceding
    line will generate a random number between 0 and 9\. If we want a random number
    between 1 and 10, we just add the increment operator on the end of the same line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `Random` object to obtain other types of random numbers
    using `nextLong`, `nextFloat`, and `nextDouble`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling large amounts of data with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be wondering what happens when we have an app with lots of variables
    to keep track of. What about our Note to self app with 100 notes, or a high-score
    table in a game with the top 100 scores? We can declare and initialize 100 separate
    variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, by using the high scores example we might use something like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately, this code can seem unwieldy, but what about when someone gets
    a new top score, or if we want to let our users sort the order that their notes
    are displayed in? Using the high scores scenario, we must shift the scores in
    every variable down one place. This is the beginning of a nightmare, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There must be a better way of doing this. When we have a whole array of variables,
    what we need is a Kotlin **array**. An array is an object that holds up to a predetermined,
    fixed-maximum number of elements. Each element is a variable with a consistent
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code declares an array that can hold `Int` type variables; such
    as a high-score table or a series of exam grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare arrays of other types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these arrays will need to have a fixed-maximum amount of allocated
    storage space before it is used. Just as we have done with other objects, we must
    initialize arrays before we use them, and we can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code allocates up to a maximum of `100` storage spaces of the
    appropriate type. Think of a long aisle of 100 consecutive storage spaces in our
    variable warehouse. The spaces will probably be labeled `myIntArray[0]`, `myIntArray[1]`,
    and `myIntArray[2]`, with each space holding a single `Int` value. The slightly
    surprising thing here is that the storage spaces start off at zero, not 1\. Therefore,
    in a 100-*wide* array, the storage spaces will run from 0 to 99\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can initialize some of these storage spaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, note that we can only ever put the predeclared type into an array
    and that the type that an array holds can never change, as demonstrated in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when we have an array of `Int` types, what are each of these `Int` variables
    called and how do we access the values stored in them? The array notation syntax
    replaces the name of the variable. Additionally, we can do anything with a variable
    in an array that we can do with a regular variable with a name; this is demonstrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code assigns the value 123 to the 4th position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of using an array just like a normal variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code subtracts the value stored in the 5th position of the array
    from the value stored in the 10th position of the array and assigns the answer
    to the 11th position of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also assign the value from an array to a regular variable of the same
    type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that `myNamedInt` is a separate and distinct variable and any
    changes to it do not affect the value that is stored in the `IntArray` reference.
    It has its own space in the warehouse and is otherwise unconnected to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous examples, we did not examine any Strings or objects. Strings,
    in fact, are objects and when we want to make arrays of objects, we deal with
    them slightly differently; take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares an array of String objects that can hold up to five
    objects. Remember that arrays start from 0, so the valid positions are 0 to 4
    inclusively. If you attempt to use an invalid position, you will get an **ArrayIndexOutOfBoundsException**
    error. If the compiler notices the error, then the code will not compile; however,
    if the compiler cannot spot the error and it happens while the app is executing,
    then the app will crash.
  prefs: []
  type: TYPE_NORMAL
- en: The only way we can avoid this problem is to know the rule – that arrays start
    at 0 and go up to their length minus 1\. So `someArray[9]` is the tenth position
    in the array. We can also use clear readable code where it is easy to evaluate
    what we have done and spot problems more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also initialize the contents of an array at the same time as declaring
    the array, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `arrayOf` built-in Kotlin function to initialize
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: The ways in which you can declare and initialize arrays are extremely flexible
    in Kotlin. We are not close to covering all the ways in which we can use arrays
    and, even by the end of the book, we still won't have covered everything. Let's
    dig a little deeper, however.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of an array variable as an address to a group of variables of a given
    type. For instance, using a warehouse analogy, `someArray` can be an aisle number.
    So, `someArray[0]` and `someArray[1]` are the aisle numbers followed by the position
    number in the aisle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because arrays are also objects, they have functions and properties that we
    can use, as can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we assigned the length (that is, size) of `someArray`
    to the `Int` variable called `howBig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even declare an array of arrays. This is an array where another array
    lurks in each of its positions; this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `Log` code will output the following text to the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's use some arrays in a real app to try and gain an understanding of how
    to use them in real code and what they might be used for.
  prefs: []
  type: TYPE_NORMAL
- en: A simple mini-app array example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make a simple working array example. You can get the completed code for
    this project in the downloadable code bundle. It can be found in the `Chapter15/Simple
    Array Example/MainActivity.kt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with an **Empty Activity** project template and call it `Simple
    Array Example`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare our array, allocate five spaces, and initialize values to
    each of the elements. Then, we output each of the values to the **logcat** window.
  prefs: []
  type: TYPE_NORMAL
- en: This is slightly different to the earlier examples that we have seen because
    we declare the size at the same time as we declare the array itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `onCreate` function just after the call to `setContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add each of the elements of the array together, just as we do with
    ordinary `Int` type variables. Notice that when we add the array elements together,
    we are doing so over multiple lines for clarity. Add the code that we have just
    discussed to `MainActivity.kt`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the example and note the output in the logcat window. Remember that nothing
    will happen on the emulator display as all the output will be sent to the logcat
    window in Android Studio; here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We declare an array called `ourArray` to hold `Int` values, and then allocate
    space for up to five values of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we assign a value to each of the five spaces in `ourArray`. Remember that
    the first space is `ourArray[0]`, and the last space is `ourArray[4]`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we simply print the value in each array location to the logcat window
    and, from the output, we can see they hold the value that we initialized them
    to be in the previous step. Then, we add together each of the elements in `ourArray`
    and initialize their value to the `answer` variable. We then print `answer` to
    the logcat window and we can see that indeed, all the values are added together
    as though they are ordinary `Int` types (which they are), just stored in a different
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting dynamic with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed at the beginning of this section, if we need to declare and
    initialize each element of an array individually, there isn't a huge benefit to
    using an array over regular variables. Let's take a look at an example of declaring
    and initializing arrays dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: A dynamic array example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can get the working project for this example in the download bundle. It
    can be found in the `Chapter15/Dynamic Array Example/MainActivity.kt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with an **Empty Activity** template and call it `Dynamic Array
    Example`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code just after the call to `setContentView` in the `onCreate`
    function. See if you can work out what the output will be before we discuss and
    analyze the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the example app. Remember that nothing will happen on screen as all the
    output will be sent to our logcat window in Android Studio; here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '994 iterations of the loop have been removed for the sake of brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we declared and allocated an array called `ourArray` to hold up to 1,000
    `Int` values. Notice that this time, we performed the two steps in a single line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we used a `for` loop that was set to loop 1,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialized the spaces in the array, from 0 to 999, with the value of `i`
    multiplied by 5, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to demonstrate the value of `i` and the value held in each position of
    the array, we output the value of `i` followed by the value held in the corresponding
    position in the array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All this happened 1,000 times, producing the output that we have seen. Of course,
    we have yet to use this technique in a real-world app, but we will use it soon
    to make our Note to self app hold an almost infinite number of notes.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayLists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `ArrayList` object is like a normal array, but on steroids. It overcomes
    some of the shortfalls of arrays, such as having to predetermine its size. It
    adds several useful functions to make its data easy to manage and it is used by
    many classes in the Android API. This last point means that we need to use `ArrayList`
    if we want to use certain parts of the API. In [Chapter 16](ch16.html "Chapter 16. Adapters
    and Recyclers"), *Adapters and Recyclers*, we will put `ArrayList` to work for
    real. First the theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some code that uses `ArrayList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declared and initialized a new `ArrayList` object
    called `myList`. We can also do this in a single step, as demonstrated by the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this is not particularly interesting, so let''s take a look at what
    we can actually do with `ArrayList`. Let''s use a `String ArrayList` object this
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we saw that we can use some useful functions of the `ArrayList`
    class on our `ArrayList` object; these functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can add an item (`myList.add`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add an entry at a specific location (`myList.add(x, value)`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can check whether the `ArrayList` instance is empty (`myList.isEmpty ()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see how big the `ArrayList` instance is (`myList.size`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can get the current position of a given item (`myList.indexOf...`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are even more functions in the `ArrayList` class, but what we have seen
    so far is enough to complete this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this functionality, all we need now is a way to handle `ArrayList`
    instances dynamically. This is what the condition of an enhanced `for` loop looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The previous example will iterate (step through) all the items in `myList` one
    at a time. At each step, `s` will hold the current `String` entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this code will print all of our eminent programmers from the previous section''s
    `ArrayList` code sample to the logcat window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The way that this works is that the `for` loop iterates through each `String`
    in the `ArrayList` and assigns the current `String` entry to `s`. Then, for each
    in turn, `s` is used in the `Log…` function call. The previous loop will create
    the following output to the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop has output all the names. The reason that Richard Stallman is
    in between Donald Knuth and Rasmus Lerdof is because we inserted him at a specific
    position, (1), which is the second position in the `ArrayList`. An `insert` function
    call does not delete any existing entries but shifts their position instead.
  prefs: []
  type: TYPE_NORMAL
- en: There's an incoming news flash!
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and ArrayLists are polymorphic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that we can put objects into arrays and `ArrayList` objects.
    However, being polymorphic means that they can handle objects of multiple distinct
    types as long as they have a common parent type – all within the same array or
    `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10, Object-Oriented Programming,](ch10.html "Chapter 10. Object-Oriented
    Programming") we learned that polymorphism means many forms. But what does it
    mean to us in the context of arrays and `ArrayList`?
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, it means that any subclass can be used as part of the
    code that uses the super-class.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have an array of `Animals`, we can put any object that is
    a subclass of `Animal` in the `Animals` array, such as `Cat` and `Dog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can write code that is simpler, easier to understand, and easier
    to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can write code for the super-class and rely on the fact that no matter
    how many times it is subclassed, within certain parameters, the code will still
    work. Let''s continue our previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All that we have just discussed is true for `ArrayLists` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Hashmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin `HashMap`s are interesting; they are a type of cousin to `ArrayList`.
    They encapsulate useful data storage techniques that would otherwise be quite
    technical for us to code successfully ourselves. It is worth looking at `HashMap`
    before getting back to the Note to self app.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we want to store the data of lots of characters from a role-playing
    game and each different character is represented by an object of the `Character`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We could use some of the Kotlin tools that we already know about, such as arrays
    or `ArrayList`. However, with `HashMap`, we can give a unique key or identifier
    to each `Character` object, and access any such object using that same key or
    identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term "hash" comes from the process of turning our chosen key or identifier
    into something used internally by the `HashMap` class. The process is called **hashing**.
  prefs: []
  type: TYPE_NORMAL
- en: Any of our `Character` instances can then be accessed with our chosen key or
    identifier. A good candidate for a key or identifier in the `Character` class
    scenario is the character's name.
  prefs: []
  type: TYPE_NORMAL
- en: Each key or identifier has a corresponding object; in this case, of the `Character`
    instance. This is known as a **key-value pair**.
  prefs: []
  type: TYPE_NORMAL
- en: We simply give `HashMap` a key and it gives us the corresponding object. There
    is no need to worry about which index we stored our characters, such as Geralt,
    Ciri, or Triss; simply pass the name to `HashMap` and it will do the work for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some examples. You don't need to type any of this code;
    simply get familiar with how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare a new `HashMap` instance to hold keys and `Character` instances
    like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code assumes that we have coded a class called `Character`. We
    can then initialize the `HashMap` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add a new key and its associated object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the example code assumes that we can somehow give the `Character` instances
    their unique properties to reflect their internal differences elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then retrieve an entry from the `HashMap` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `Character` class''s functions directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The previous code calls the hypothetical `drawSilverSword` and `openFastTravelPortal`
    functions on the `Character` class instance stored in the `HashMap` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this new toolkit of arrays, `ArrayList`, `HashMap`, and the fact
    that they are polymorphic, we can move on to learn about some more Android classes
    that we will soon use to enhance our Note to self app.
  prefs: []
  type: TYPE_NORMAL
- en: The Note to self app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite all we have learned, we are not quite ready to apply a solution to the
    Note to self app. We could update our code to store lots of `Note` instances in
    an `ArrayList`, but before we do, we also need a way to display the contents of
    our `ArrayList` in the UI. It won't look good to throw the whole thing in a `TextView`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is **adapters**, and a special UI layout called `RecyclerView`.
    We will get to them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) How can a computer that can only make real calculations possibly generate
    a genuinely random number?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) In reality, a computer cannot create a number that is truly random, but
    the `Random` class uses a **seed** that produces a number that will stand up as
    genuinely random under close statistical scrutiny. To find out more about seeds
    and generating random numbers, look at the following article: [https://en.wikipedia.org/wiki/Random_number_generation](https://en.wikipedia.org/wiki/Random_number_generation).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to use simple Kotlin arrays to store substantial
    amounts of data provided that it is of the same type. We also used `ArrayList`,
    which is like an array with lots of extra features. Furthermore, we discovered
    that both arrays and `ArrayList` are polymorphic, which means that a single array
    (or `ArrayList`) can hold multiple different objects as long as they are all derived
    from the same parent class.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the `HashMap` class, which is also a data storage solution,
    but which allows access in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about `Adapter` and `RecyclerView` to put
    the theory into practice and enhance our Note to self app.
  prefs: []
  type: TYPE_NORMAL
