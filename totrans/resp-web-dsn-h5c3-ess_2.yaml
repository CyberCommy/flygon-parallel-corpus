- en: Chapter 2. Creating Fluid Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key part of our journey through the essentials of responsive design is laying
    out content on the page—in the early days of the Internet, this was a simple process!
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of mobile devices (and those non-PC devices) that can access
    the Internet, content layout has become ever more critical; for example, how many
    images do we have, or do we include content X, or show a summary instead? These
    are just some of the questions we might ask ourselves. It goes to show that it
    can open a real can of worms!
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the process, we can use grid or fluid-based layouts. Throughout
    the course of this chapter, we'll take a look at using them in more detail; we'll
    start with setting the available viewport, and take it right through to future
    grid-based layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing grid layouts and understanding different types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the available viewport for use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the benefits and mechanics of using grid layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a prebuilt grid layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the future of grid-based template layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curious? Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the exercises have been designed for the Windows platform, as this
    is the authors' platform of choice; alter as appropriate if you use a different
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing flexible grid layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, designers have built layouts of different types; they may be
    as simple as a calling card site, right through to a theme for a content management
    system, such as WordPress or Joomla. The meteoric rise of accessing the Internet
    through different devices means that we can no longer create layouts that are
    tied to specific devices or sizes—we must be flexible!
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this flexibility requires us to embrace a number of changes in our
    design process—the first being the type of layout we should create. A key part
    of this is the use of percentage values to define our layouts; rather than create
    something from the ground up, we can make use of a predefined grid system that
    has been tried and tested, as a basis for future designs.
  prefs: []
  type: TYPE_NORMAL
- en: The irony is that there are lots of grid systems vying for our attention, so
    without further ado, let's make a start by exploring the different types of layouts,
    and how they compare to responsive designs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different layout types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A problem that has faced web designers for some years is the type of layout
    their site should use—should it be fluid, fixed width, have the benefits of being
    elastic, or a hybrid version that draws on the benefits of a mix of these layouts?
  prefs: []
  type: TYPE_NORMAL
- en: The type of layout we choose to use will of course depend on client requirements—making
    it a fluid layout means we are effectively one step closer to making it responsive;
    the difference being that the latter uses media queries to allow resizing of content
    for different devices, not just normal desktops!
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the differences, and how responsive layouts compare, let''s take
    a quick look at each in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fixed width layouts**: These are constrained to a fixed width; a good size
    is around 960px, as this can be split equally into columns, with no remainder.
    The downside is fixed width makes assumptions about the available viewport area,
    and if the screen is too small or large, it results in lots of scrolling which
    affects the user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fluid layouts**: Instead of using static values, we use percentage-based
    units; it means that no matter what the size of the browser window, our site will
    adjust accordingly. This removes the problems that surround fixed layouts at a
    stroke.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic layouts**: They are similar to fluid layouts, but the constraints
    are measured by type or font size, using em or rem units; these are based on the
    defined font size, so 16px is 1 rem, 32px is 2 rem, and so on. These layouts allow
    for decent readability, with lines of 45-70 characters; font sizes are resized
    automatically. We may still see scrollbars appear in some instances, or experience
    some odd effects if we zoom our page content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid layouts**: They combine a mix of two or more of these different layout
    types; this allows us to choose static widths for some elements while others remain
    elastic or fluid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In comparison, responsive layouts take fluid layouts a step further, using media
    queries to not only make our designs resize automatically, but also present different
    views of our content on multiple devices.
  prefs: []
  type: TYPE_NORMAL
- en: How do we set the available space though, and be sure that our content will
    zoom in or out as appropriate? Easy—we can do this by adding the viewport directive
    to our markup; let's go and explore what is required to allow our viewport to
    resize as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the available viewport for use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When viewing a website on different devices, we of course expect it to resize
    to the available device width automatically with no loss of *experience*; unfortunately,
    not every site does this quite the right way or successfully!
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why this is important, let''s assume we operate a desktop version
    of our site (one in the 1280+ group in this screenshot), and a mobile equivalent
    from the 418-768 group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the available viewport for use](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first stage in making our site responsive is to add the viewport directive;
    without it, we are likely to end up with a similar effect to this when resizing
    our sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the available viewport for use](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'See what I mean? It looks awful—text is cut off, we would have to swipe to
    the right...ugh! In stark contrast, adding one line of code can have a dramatic
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the available viewport for use](img/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our example uses the Google Chrome set to emulate an iPhone 6 Plus. The code
    needed to restore sanity to our example can be added to the `<head>` of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once set, we can immediately see the difference. Granted, our demo isn’t going
    to win any style awards, but then it wasn't the aim! It does, however, show that
    the text has been reduced in size to fit the screen, we have a proper border around
    the text—it all looks more pleasing as a display.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see what happens in action, try running the `viewport.html` demo from the
    code download that accompanies this book; you will need to run it in device/responsive
    mode for your browser; remove line 5, and re-add it back in to see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content property in this directive supports using any one of a number of
    different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `width` | The width of the virtual viewport of the device. |'
  prefs: []
  type: TYPE_TB
- en: '| `device-width` | The physical width of the device''s screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `height` | The height of the virtual viewport of the device. |'
  prefs: []
  type: TYPE_TB
- en: '| `device-height` | The physical height of the device''s screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `initial-scale` | The initial zoom when visiting the page; setting 1.0 does
    not zoom. |'
  prefs: []
  type: TYPE_TB
- en: '| `minimum-scale` | The minimum amount the visitor can zoom on the page; setting
    1.0 does not zoom. |'
  prefs: []
  type: TYPE_TB
- en: '| `maximum-scale` | The maximum amount the visitor can zoom on the page; setting
    1.0 does not zoom. |'
  prefs: []
  type: TYPE_TB
- en: '| `user-scalable` | Allows the device to zoom in and out (yes) or remain fixed
    (no). |'
  prefs: []
  type: TYPE_TB
- en: Current versions of MS Edge don't play so well with viewport tags; it is worth
    noting that `@-ms-viewport` needs to be specified in code to ensure our viewport
    widths behave in the same way as other browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Balancing viewport against experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will notice that I italicized the word experience at the start of this section—the
    key point here is that in responsive design, the experience does not have to be
    identical across all devices; it must be useful though, and allow our visitors
    to interact with us as an organization. In other words, if we worked for a theater,
    we might limit our mobile offer to simply booking tickets, and let the main desktop
    site manage everything else.
  prefs: []
  type: TYPE_NORMAL
- en: This is perfectly valid; while limiting a site, mobile ticketing might be considered
    by some as very restrictive. The concept is still technically sound, as long as
    the user experience is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that we could have set a specific width using `width=<value>`.
    This is great if we need a certain width to display our content; if the orientation
    changes from portrait (320px) to landscape (360px) for example, then the viewport's
    content will be automatically scaled up and down to reflect these changes. If,
    however, we had set a device-width as a maximum, this implies that no scaling
    is need and that the browser should adjust the content within it to fit.
  prefs: []
  type: TYPE_NORMAL
- en: Considering viewport units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A key part of responsive design is to make the move away from using pixel values
    to working with em or rem units. In our examples (and the viewport demo from earlier
    in this chapter), we used both pixel and rem units. Although this works well,
    we still have a dependency on parent elements. Instead, we should consider using
    an alternative for working with viewports. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**vw**: viewport width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vh**: viewport height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vmax**: maximum of the viewport''s height and width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vmin**: minimum of the viewport''s height and width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a unit of measure, these equate to 1% of the viewport area that has been
    set; the beauty though is that they remove any dependency elements, and are calculated
    based on the current viewport size. Browser support for them is currently very
    good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Considering viewport units](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [http://caniuse.com/#search=vh](http://caniuse.com/#search=vh)'
  prefs: []
  type: TYPE_NORMAL
- en: Leaving aside the slight quirks with more recent versions of Internet Explorer,
    this is a useful option that combines the ease of units, with the flexibility
    of using percentages, in our designs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on—we’ve introduced flexible grids and explored how setting a viewport
    is critical to displaying content correctly. It’s time we moved on and explore
    some of the benefits of incorporating a grid system into our layout, and dive
    into the internals of how they work as a principle in responsive design.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the benefits of flexible grid layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve been introduced to grid layouts as a tenet of responsive design,
    it''s a good opportunity to explore why we should use them. Creating a layout
    from scratch can be time consuming and needs lots of testing; there are some real
    benefits from using a grid layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grids make for a simpler design**: Instead of trying to develop the proverbial
    wheel, we can focus on providing the content instead; the infrastructure will
    have already been tested by the developer and other users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**They provide for a visually appealing design**: Many people prefer content
    to be displayed in columns, so grid layouts make good use of this concept to help
    organize content on the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grids can of course adapt to different size viewports**: The system they
    use makes it easier to display a single codebase on multiple devices, which reduces
    the effort required for developers to maintain and webmasters to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grids help with the display of adverts**: Google has been known to favor
    sites which display genuine content and not those where it believes the sole purpose
    of the site is for ad generation; we can use the grid to define specific areas
    for adverts, without getting in the way of natural content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, it makes sense to familiarize ourselves with grid layouts; the temptation
    is of course to use an existing library. There is nothing wrong with this, but
    to really get the benefit out of using them, it's good to understand some of the
    basics around the mechanics of grid layouts and how this can help with the construction
    of our site.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look first at how we would calculate the widths of each element,
    an important part of creating any grid layout.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the mechanics of grid layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we explored one of the key critical elements of responsive design, in
    the form of how we would set our available screen estate (or viewport)—as someone
    once said, *it's time...*
  prefs: []
  type: TYPE_NORMAL
- en: 'Absolutely—it''s time we cracked on and explored how grids operate! The trick
    behind grids is nothing special; it boils down to the use of a single formula
    to help define the proportions of each element used in our layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*target ÷ context = result*'
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we have a layout with two columns, and that the container
    (or context) is 960px wide (I will use pixel values purely to illustrate the maths
    involved).
  prefs: []
  type: TYPE_NORMAL
- en: To create our layout, we will make use of the Golden Ratio that we touched on
    in [Chapter 1](ch01.html "Chapter 1. Introducing Responsive Web Design"), *Introducing
    Responsive Web Design*; to recap, we use the ratio of 1.618 to every 1 pixel.
    So, if our layout is 960px wide, we multiply 960 x 0.618 (the difference)—this
    gives 593px (rounded down to the nearest integer). We then simply subtract 593
    from 960, to arrive at 367px for our side column. Easy, when you know how...!
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we can convert these to percentages; `593px` becomes `61.77%`,
    and the side bar will be `38.23%`. Let''s translate this into some sample CSS,
    with values rounded to 2 decimal places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, our target is the `aside` (or sub-element), with context as the container;
    in this case, we've set it to 960px. The section forms a second target; in both
    cases, we've divided the target by the context to arrive at our result. As our
    result figures need to be expressed as percentages, we can simply multiply each
    by 100 to get the figures we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The observant among you will note the presence of `margin: 1.00%`. We must
    allow sufficient space for our margin, so the resulting figures will need to change.
    We''ll keep the section width at `61.77%`, so our margin will need to drop down
    to `34.23%`, to retain a full width of 100% (this allows for the two margins each
    side of the two sub-elements).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we carried this through to its conclusion, we could end up with something
    akin to this screenshot, as an example layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the mechanics of grid layouts](img/image_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Okay, let''s move on. I feel it''s time for a demo! Before we get stuck into
    writing code, there are a few pointers we should take a quick look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Although we've only scraped the surface of how grid layouts work, there is a
    lot more we can do; it will all depend on how many columns your site needs, whether
    the columns should be equal in width, or be merged with others, how big the container
    will be, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are dozens of grid layout frameworks available online. Before getting
    into designing and creating your own from scratch, take a look at what is available;
    it will save you a lot of time!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep it simple; don't try to overcomplicate your layout. You may read stories
    of developers extolling the virtues of flexbox, or that you must use JavaScript
    or jQuery in some form or other; for a simple layout, it isn't necessary. Yes,
    we might use properties such as box sizing, but flexbox-based grid systems can
    become overinflated with CSS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this in mind, it''s time we got stuck into a demo. Before we do though,
    there is something we need to cover, as it will become a recurring theme throughout
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: We will avoid the use of JavaScript or downloading libraries in order to create
    our demos. Yes, you heard right. We're going to attempt to use nothing more than
    plain HTML5 or CSS3 to construct our responsive elements!
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is simple—I maintain that we've become lazy as developers,
    and that sometimes it is good to go back to basics and really appreciate that
    sometimes simple is better. You may hear of singers who want to get back to their
    roots or where they started from; we're simply applying the same principle to
    our responsive development. It does mean that we can't always use the most feature-rich,
    or latest version, but that isn't always a bad thing, right?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a prebuilt grid layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've touched on the basics of creating grids; these can be really time consuming
    to create from scratch, so with so many already available online, it makes better
    sense to use a prebuilt version unless your requirements are such that you can't
    find one that works for you! It is worth spending time researching what is available,
    as no two grids are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of what is available and to prove that we don''t need all the
    bells and whistles that grids can offer, let''s take a look at an example grid,
    in the form of Gridism. We can see an example of how our next demo looks like
    when completed, in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a prebuilt grid layout](img/image_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although this library has been around for two to three years, its simplicity
    proves that we don't need to implement a complex solution in order to create the
    basis for a simple layout. The flexbox attribute in CSS is perfect for creating
    grids, but its flexibility adds a layer of complexity that isn't needed; instead,
    we'll make use of the `box-sizing` attribute, which will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: Created by Cody Chapple, it doesn't make use of flexbox (of which more, anon),
    but does make use of box-sizing as an attribute in the grid. The library can be
    downloaded from [https://github.com/cobyism/gridism/blob/master/gridism.css](https://github.com/cobyism/gridism/blob/master/gridism.css)
    (or installed using Bower), but as it consists of one file only, we can simply
    copy the contents to a text file and save it that way (and still keep to our earlier
    aim of not downloading content).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The demo will use the original example from the Gridism site, but the CSS has
    been reworked to bring it up to date and remove some unnecessary code. For ease
    of convenience, we will assume use of Google Chrome throughout this demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: From the code download that accompanies this book, go ahead and download a copy
    of `gridism.html`, along with `normalize.css`, `gridism.css`, and `style.css`.
    Save the HTML markup at the root of our project area, and the two CSS files within
    the CSS subfolder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try running `gridism.html` in a browser, then enable its device or responsive
    mode (by pressing *Ctrl* + *Shift* + *I* then *Ctrl* + *Shift* + *M*). We should
    see something akin to the screenshot shown at the beginning of this exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The screenshot at the start of this section was taken in Google Chrome, set
    to emulate an iPhone 6 Plus in landscape mode. Now use the orientation tool in
    Chrome:![Implementing a prebuilt grid layout](img/image_02_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To change the orientation to portrait:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Implementing a prebuilt grid layout](img/image_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how the grid has automatically realigned itself? The trick here is not
    in the `style.css` file, but within `gridism.css`; if we open it in a text editor
    and look for this block of code, on or around lines 50-61, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a prebuilt grid layout](img/image_02_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the library makes good use of percentage values to assign a
    width to each block. The real crux of this is not in the widths set, but the size
    of our container; for gridism, this is set to `978px` by default. So, for example,
    if we were to set a cell width of `.one-third`, we would want `33.3332%` of `736px`,
    or `245.33px`. We then ensure all grid cells have the right dimensions by applying
    the box-sizing attribute to each of our grid cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'See how easy that was? In place of having to work out percentages, we simply
    specify the name of the column type we need, depending on how wide we need it
    to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a prebuilt grid layout](img/image_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hold on a moment. How come the screenshot shows `215.33`, and not `245.33`,
    as the calculation indicated it should be?
  prefs: []
  type: TYPE_NORMAL
- en: Aha, this is just something we need to be mindful of; when working with a grid
    system like Gridism, the calculations are based on the full width of our viewport.
    Any padding required will be included within the width calculations of our column,
    so we may need a slightly larger column then we anticipate! It goes to show that
    even though our grid system doesn't have all of the mod-cons of current systems,
    we can still produce a useable grid, as long as we plan it carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's move on. We talked in passing about the fact that many grids use
    flexbox to help control their appearance; this is a great option to use, but can
    require setting a lot of additional properties that would otherwise be unnecessary
    for simple layouts. With careful planning, there is every possibility that we
    can avoid using it, but if we're working on a complex layout with lots of different
    elements, then there will be occasions when using it will avoid a lot of heartache!
    With this in mind, let's take a quick look at the basics of how it works in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the use of flexbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is flexbox?
  prefs: []
  type: TYPE_NORMAL
- en: It's a module that has been designed to provide a more efficient way to layout
    and distribute space around items in a container, particularly if their sizes
    are not yet known. We can set a number of properties to ensure that each item
    best uses the available space around it, even if its size changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, this is a W3C Candidate Recommendation; this means
    that it is effectively on the last call before becoming a browser standard in
    late 2016\. This should be something of a formality though, as most browsers already
    support it as a standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the use of flexbox](img/image_02_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [http://caniuse.com/#search=flexbox](http://caniuse.com/#search=flexbox)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully understand how it all works is outside the scope of this book, but
    to help get started, we can run a quick demo, and explore some of the main features:'
  prefs: []
  type: TYPE_NORMAL
- en: From the code download that accompanies this book, go ahead and extract copies
    of `flexbox.html` and `flexbox.css`; store the HTML markup at the root of our
    project area, and the CSS style sheet in the `css` subfolder of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try previewing `flexbox.html` in a browser. For this, we will need to enable
    the browser''s responsive mode (or device mode, depending on browser); if all
    is well, we should see something akin to this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Exploring the use of flexbox](img/image_02_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The demo is based on a pen created by Irina Kramer, which is available at [https://codepen.io/irinakramer/pen/jcLlp](https://codepen.io/irinakramer/pen/jcLlp);
    for the purposes of our demo, we focus on the example layout taken from that pen.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this demo looks very straightforward. It could certainly use
    some help in the color department, but that's not what is of interest to us at
    the moment. If we dig deeper into the code, we can see that flexbox has been incorporated
    in various places; let's explore its use in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a closer look
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Taking a closer look at our code, we will find that a large part of it uses
    standard attributes, which we might find on any site. The code that is of interest
    to us starts on line 50; to understand its role, we first need to get our heads
    around the basic concept of flex layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking a closer look](img/image_02_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: W3C'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, items are laid out following either the main axis (from main-start
    to main-end) or the cross axis (from cross-start to cross-end):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `main axis` | The primary axis along which flex items are laid out; this
    is dependent on the flex-direction property. |'
  prefs: []
  type: TYPE_TB
- en: '| `main-start &#124;  main-end` | The start and end points of flex items that
    are placed within the container (horizontally). |'
  prefs: []
  type: TYPE_TB
- en: '| `main size` | A flex item''s width or height, whichever is in the main dimension,
    is the item''s main size. The main size property can be the item''s height or
    width size. |'
  prefs: []
  type: TYPE_TB
- en: '| `cross axis` | The axis perpendicular to the main axis. Its direction depends
    on the main axis direction. |'
  prefs: []
  type: TYPE_TB
- en: '| `cross-start &#124; cross-end` | Start and end points for flex lines that
    are filled with items and placed into the container (vertically). |'
  prefs: []
  type: TYPE_TB
- en: '| `cross size` | This is the width or height of a flex item, whichever is in
    the cross dimension. |'
  prefs: []
  type: TYPE_TB
- en: With this in mind, let's explore some of the flexbox terms that have been used
    in our code; the initial few styles are standard rules that could apply to any
    site. The code of interest to us starts on line `29`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we scroll down to that line, we are met with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking a closer look](img/image_02_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our first attribute, `display: flex`, defines the container which contains
    the flex items; here, we''re setting it to show items in rows, and to wrap from
    left to right. If we had a number of columns in our layout, and by this I mean
    more than just two or three, then we might use `align-items` and `justify-content`
    to ensure that each column was evenly spread throughout the row, irrespective
    of the width of each column.'
  prefs: []
  type: TYPE_NORMAL
- en: With the `.grid` defined, we need to style our grid-cells, or the containers
    where we host our content. There are several properties we can apply; the one
    we've used is `flex`, which is shorthand for `flex-grow`, `flex-shrink`, and `flex-basis`.
    In our case, it is recommended that the shorthand version be used, as this will
    set the other values automatically; we've set `flex-grow` to `1`, which indicates
    how much it should grow, in relation to other flexible items in the same container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next property of interest is in the `.nav` rule. Here, we''ve used flex-flow
    again, but this time we also justify-content; the latter controls how items are
    packed on each row (in this case, toward the end of the line):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking a closer look](img/image_02_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our last block of code of particular interest is this section, within the large
    screen media query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking a closer look](img/image_02_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The order property simply specifies the order of each item in our flex container;
    in this case, we have `.aside-1` and `.aside-2` in position 1 and 2 respectively
    (not in shot), with the `.main` in the middle at position 2.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a lot more properties we can set, depending on our requirements. Take
    a look at the source code on the original pen. There are plenty of reference sources
    about flexbox available online—as a start, have a look at Chris Coyier's guide,
    available at [http://bit.ly/1xEYMhF](http://bit.ly/1xEYMhF).
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on. We've explored some examples of what is possible now, but there
    is at least one downside with using flexbox. The technology works very well, but
    can add a fair amount of code and complexity when implementing in a site.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to look for something simpler to use, which doesn't require quite
    the same effort to implement; enter CSS grid templates! This is still an early
    technology, with minimal browser support, but is already easier to implement.
    Let's dive in and take a look in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Visiting the future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have flexbox as a technique for creating grid layouts, but its
    design is meant for simpler, one-dimensional layouts; it doesn't work so well
    if the layout is complicated! Is there an answer, something better, that is designed
    for the job?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately there is; I am of course referring to a relatively new technology,
    named CSS Grid Layout. Support for this is minimal for now, but this is likely
    to change. In a nutshell, it provides a simpler way to create grids in a browser,
    without the plethora of options we saw with flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside of using CSS Grid Layout as a technology is that support for it
    has yet to hit mainstream; it is supported in IE11/Edge, but only under the `-ms-`
    prefix. Opera, Firefox, and Chrome offer support, but all require a flag to be
    enabled to view the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visiting the future](img/image_02_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [CanIUse.com](http://caniuse.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Leaving aside the concerns about support for a moment, it is easy to see why
    CSS Grid Layout will take off as a technique. The whole concept has been designed
    to simplify how we reference cells, rows, and columns; if we compare with flexbox,
    it is more straightforward to apply styles using CSS Grid Layout than with flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you would like to learn more about CSS Grid Layout, then have a look online.
    This article by Chris House explains it well: [http://bit.ly/2bMGlDp](http://bit.ly/2bMGlDp).'
  prefs: []
  type: TYPE_NORMAL
- en: To see how it compares, let's dive in and build a simple demo to illustrate
    some images in a grid layout.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a basic gallery grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our next demo, we''re going to make use of an example created by the developer
    Rachel Andrew, at [http://codepen.io/rachelandrew/full/LGpONE/](http://codepen.io/rachelandrew/full/LGpONE/);
    we''ll be replacing the images with ones from Flickr, depicting pictures of my
    favorite European town, Bruges. No, it''s not to do with the lace, before you
    ask: good food, fine wine, great atmosphere, stunning chocolates for sale...what
    more could you ask for, I wonder?'
  prefs: []
  type: TYPE_NORMAL
- en: 'But I digress. Before we get into creating our code, there are a couple of
    points we must bear in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This demo is cutting edge, it won''t work in all browsers, and for some, it
    requires enabling support within the browser. Take care, it is perfectly okay
    to enable the flag, but make sure you get the right one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Implementing a basic gallery grid](img/image_02_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have to restart Google Chrome in step 1, so make sure you only have the flags
    page displayed at the start of the demo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without further ado, let''s make a start on our demo:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by enabling support in Google Chrome for CSS Grid Layout. To do
    so, browse to `chrome://flags` and search for **Experimental Web Platform features**.
    Click on the enable button to activate it, then hit the blue **Relaunch Now**
    button at the bottom of the page to relaunch Google Chrome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With support enabled, go ahead and extract a copy of `gridtemplate.html` from
    the code download that accompanies this book; save it to the root of our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new text file, add the following styles. We''ll go through them in blocks,
    beginning with some initial styling for our images and labels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up comes the rules needed to set our container; note that the only style
    used that relates to our grid is `box-sizing`, which we set to `border-box`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The real magic starts to happen in a set of media queries; we begin with assigning
    wrapper as our grid container, then set the column and row layout of our grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our second query, we set individual styles for our grid wrapper and list
    items, this time for 640px or greater:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save the file as `gridtemplate.css`, within the `css` subfolder of our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try previewing the results in a browser; if all is well, we should see results
    similar to this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Implementing a basic gallery grid](img/image_02_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Okay, granted. It's probably not what you might expect in terms of styling,
    but this demo isn't about making it look pretty, but the basic grid effect. There
    are nonetheless some important concepts that are good to understand, so let's
    dive in and explore what took place in our demo in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring what happened
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, we explored how flexbox can be used to create a grid
    layout; if we were to compare CSS styling, it is easy to see that on balance,
    we need to provide more styling when using flexbox than using CSS Grid Layout.
  prefs: []
  type: TYPE_NORMAL
- en: The only styling attribute that we've used in our core styles is `box-sizing`,
    which we set to `border-box`. Nothing else has been used at this point—all of
    our CSS Grid Layout styles have been set within two media queries.
  prefs: []
  type: TYPE_NORMAL
- en: Our first media query sets the `.wrapper` class as our grid container. Note
    that we've only need to set it once, as it will cascade through to larger viewports
    that are `500px` or greater in size.
  prefs: []
  type: TYPE_NORMAL
- en: Once the grid container is assigned, we then specify the grid columns for our
    template - the `1fr` value assigned represents the fraction of free white space
    in the grid around each cell's content (hence the `fr` unit). We then finish up
    by specifying `grid-row` or `grid-column` in both media queries - these values
    define a grid item's location within the grid; these two terms are shorthand for
    `grid-row-start`, `grid-row-end`, `grid-column-start` and `grid-column-end` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more detailed explanation of how these terms are used in creating grids,
    refer to the Mozilla Developer Network articles available at [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout).
  prefs: []
  type: TYPE_NORMAL
- en: Taking it further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning a new technology is like putting on new clothes; at some point, we
    will outgrow those clothes, or they no longer present the appeal that attracted
    us to them at the time of purchase.
  prefs: []
  type: TYPE_NORMAL
- en: It's at times like this we need to progress onto something more advanced or
    with additional functionality, otherwise our development will come to a standstill!
    Thankfully, there are literally dozens of options available online that we can
    explore—one might be forgiven for thinking that there are too many and where does
    one start?
  prefs: []
  type: TYPE_NORMAL
- en: A great starting point is a responsive framework such as Bootstrap or Unsemantic;
    these have been made to improve the usability and help speed up the process of
    development. These frameworks were introduced with the aim of providing a grid
    or foundation for rapid prototyping of the various mobile functionalities, layouts
    which allow the designers and developers to better make use of their development
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just one part of what is available to help you along, let''s briefly
    cover a few ideas that might serve as somewhere to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bootstrap** is downloadable from [http://getbootstrap.com/](http://getbootstrap.com/),
    this veteran grid system was first created by Facebook, before becoming a standalone
    product in its own right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to explore something that is more than just a framework, then **Responsive
    Grid System** might be an option; it's available from [http://www.responsivegridsystem.com/](http://www.responsivegridsystem.com/),
    with a SASS version available for those who use that CSS preprocessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of simply downloading a framework, how about generating one online?
    For this, try **Responsify.it** ([http://responsify.it](http://responsify.it/))
    and Gridpak.com ([http://gridpak.com](http://gridpak.com/)) as possible contenders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used a minimal Grid system earlier in the form of Gridfy, there are others
    available, if this one is not to your liking. As an example, try Gridly, which
    can be downloaded from [http://ionicabizau.github.io/gridly/example/](http://ionicabizau.github.io/gridly/example/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's worth noting that not every Grid system is available as a standalone—some
    form part of a component library. A good example is **Formstone**; its grid system
    is available from [https://formstone.it/components/grid/](https://formstone.it/components/grid/).
    For those of you who use the Less CSS preprocessor, this grid comes with a version
    that can be used with this tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staying with the theme of component libraries, why not have a look at **Metro
    UI**? This library, available from [http://metroui.org.ua/grid.html](http://metroui.org.ua/grid.html),
    even has backing from Microsoft; it does require jQuery though!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of you might have heard of the 960.gs grid system, which was available
    a few years ago - it has been replaced by **Unsemantic**, which is available from
    [http://unsemantic.com/](http://unsemantic.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered the use of flexbox as a technology for creating grid-based layouts;
    as a start point, why not have a look at the PureCSS library? This is available
    at [http://purecss.io](http://purecss.io/); it's a good example of using flexbox
    to produce clean layouts without too much fuss.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As developers, this is one area of responsive design where we are spoilt for
    choice; the great thing about open source software is that if a framework we choose
    isn''t right, then we can always try another! To help us make the decision, there
    are a few questions we can ask ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: Do you need a version that works with a CSS preprocessor? Although preprocessed
    CSS is a superset of standard CSS, there are grid systems available that are specifically
    built from a preprocessing technology such as SASS or PostCSS. This is easier
    than trying to convert finished CSS into something that can be compiled by our
    processor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How complex is your site? Is it a single page *calling card* affair, or something
    substantially more complex? There is clearly no point in burdening a simple site
    with a complex grid arrangement; equally if we're building a complex site, then
    our chosen grid system must be up to par.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is browser support an issue? If we can forgo support for some of the older browsers
    (and particularly below IE8), then choosing a CSS-only option is preferable to
    one dependent on using jQuery. The same principle applies if we already have to
    use more than just the occasional external resource. There is no need to add in
    a plugin if using CSS is sufficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does your site need to make use of UI components which need to be styled using
    a themed library? If so, check the library; it may already have a grid system
    built in that we can use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key here is that we shouldn't simply choose the first available option to
    us, but carefully consider what is available and pick something that satisfies
    our requirements where possible. Any styling can of course be overridden—the trick
    here is to choose the right one, so that overriding is minimal or not required
    for our site.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructing the layout grid for any site is key critical to its success; traditionally,
    we may have done this first, but in the world of responsive design, content comes
    first! Throughout the course of this chapter, we've covered a few topics to help
    get you started, so let's take a moment to recap what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off with an introduction to flexible grid layouts, with a mention
    that we may have to change our design process to facilitate creating responsive
    grids. We then moved onto to explore the different types of layout we can use,
    and how responsive layouts compare to these different types.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we began on the most important part of our layout—setting the available
    viewport; this controls how much is visible at any one point. We covered the need
    to set a viewport directive in our code, so that content is correctly displayed;
    we examined how not providing the directive can have a negative impact on the
    appearance of our content! In addition, we covered some of the additional properties
    and units of value we can use, along with balancing the viewport size against
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved onto exploring the benefits of flexible grid layouts, before taking
    a look at how they work in more detail; we then created a simple demo using a
    prebuilt grid system available from the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we then took a look at using flexbox as a technology; we explored
    it through a simple demo, before dissecting some of the issues with using flexbox.
    We then saw how a replacement is in the works. We rounded out the chapter with
    a demo to explore how it can be activated today, and that it is simpler to develop
    solutions for it once it becomes a mainstream standard.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our layout in place, it's time to move on. We need to start
    adding content! It's assumed that text would be added by default, but what about
    media? How do we make it responsive? We'll answer these questions, and more, in
    the next chapter, when we take a look at adding responsive media to our pages.
  prefs: []
  type: TYPE_NORMAL
