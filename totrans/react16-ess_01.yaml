- en: Chapter 1. What's New in React 16
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The release of React 16 includes enough important changes to devote a chapter
    to them. This particular release took a comparatively long time to deliver. This
    is because the reconciliation internals—the part of React that figures out how
    to efficiently render component changes—was rewritten from the ground up. Compatibility
    was another factor: this rewrite has no major breaking API changes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the major changes introduced in React
    16:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The major changes made to the reconciliation internals, and what they mean for
    React projects, going forward
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confining errors to the sections of your application by setting error boundaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating components that render more than one element and components that render
    strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering to portals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rethinking rendering
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You do not need a deep understanding of how the reconciliation internals of
    React work. This would defeat the purpose of React and how it encapsulates all
    of this work for us. However, understanding the motivation for the major internal
    changes that have happened in React 16 and how they work at a higher level will
    help you think about how to best design your components today and for the future
    React applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The status quo
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React has established itself as one of the standards when it comes to choosing
    a library to help build user interfaces. The two key factors for this are its
    simplicity and its performance. React is simple because it has a small API surface
    that's easy to pick up and experiment with. React is performant because it minimizes
    the number of DOM operations it has to invoke by reconciling changes in a render
    tree.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: There's an interplay between these two factors that has contributed to React's
    skyrocketing popularity. The good performance provided by React wouldn't be valuable
    if the API were difficult to use. The overarching value of React is that it's
    simple to use and performs well out of the box.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'With the widespread adoption of React came the realization that its internal
    reconciliation mechanics could be improved. For example, some React applications
    update the component state faster than rendering can complete. Consider another
    example: changes to part of the render tree that aren''t visible on the screen
    should have a lower priority than elements that the user can see. Issues like
    these are enough to degrade the user experience so that it doesn''t feel as fluid
    as it could be.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: How do you address these issues without disrupting the API and render tree reconciliation
    that work so well?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Running to completion
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is single-threaded and run-to-completion. This means that by default,
    any JavaScript code that you run will block any other browser tasks from running,
    such as painting the screen. This is why it's especially important that JavaScript
    code be fast. However, in some cases, even the performance of the React reconciliation
    code isn't enough to mask bottlenecks from the user. When presented with a new
    tree, React has no choice but to block the DOM updates and event listeners while
    it computes the new render tree.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution is to break the reconciliation work into smaller chunks,
    and arrange them in such a way that prevents the JavaScript run-to-completion
    thread from blocking important DOM updates. This would mean that the reconciler
    wouldn't have to render a complete tree, and then have to do it all over again
    because an event took place while the first render was taking place.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a visual example of this problem:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Running to completion](graphics/B05915_01_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: This figure demonstrates that any time state changes in a React component, nothing
    else can happen until rendering has completed. As you can see, reconciling entire
    trees can get expensive as the state changes pile up, and, all the while, the
    DOM is blocked from doing anything.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Reconciling the render tree is in lock-step with the run-to-completion semantics
    of JavaScript. In other words, React cannot pause what it''s doing to let the
    DOM update. Let''s now look at how React 16 is trying to change the preceding
    figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Running to completion](graphics/B05915_01_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: This version of the React render/reconciliation process looks similar to the
    previous version. In fact, nothing about the component on the left has changed—this
    is reflective of the unchanging API in React 16\. There are some subtle but important
    differences though.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the reconciler. Instead of building a new render tree
    every time the component changes state, it renders a partial tree. Putting it
    another way, it performs a chunk of work that results in the creation of part
    of a render tree. The reason it doesn't complete the entire tree is so that the
    reconciliation process can pause and allow any DOM updates to run—you can see
    the difference in the DOM on the right-hand side of the image.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: When the reconciler resumes building the render tree, it first checks to see
    if new state changes have taken place since it paused. If so, it takes the partially
    completed render tree and reuses what it can, based on the new state changes.
    Then, it keeps going until the next pause. Eventually, reconciliation completes.
    During reconciliation, the DOM has been given a chance to respond to events and
    to render any outstanding changes. Prior to React 16, this wasn't possible—you
    would have to wait until the entire tree was rendered before anything in the DOM
    could happen.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: What are fibers?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to separate the job of rendering components into smaller units of work,
    React has created an abstraction called a **fiber**. A fiber represents a unit
    of rendering work that can be paused and resumed. It has other low-level properties
    such as priority and where the output of the fiber should be returned to when
    completed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The code name of React 16 during development was React Fiber, because of this
    fundamental abstraction that enables scheduling pieces of the overall rendering
    work to provide a better user experience. React 16 marks the initial release of
    this new reconciliation architecture, but it's not done yet. For example, everything
    is still synchronous.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Async and the road ahead
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React 16 lays the groundwork for the ultimate goal of asynchronous rendering
    in the next major release. The main reason that this functionality isn't included
    in React 16 is because the team wanted to get the fundamental reconciliation changes
    out into the wild. There are a few other new features that needed to be released
    too, which we'll go over in the following sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Once asynchronous rendering capabilities are introduced into React, you shouldn't
    have to modify any code. Instead, you might notice improved performance in certain
    areas of your application that would benefit from prioritized and scheduled rendering.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Better component error handling
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React 16 introduces better error-handling capabilities for components. The concept
    is called an **error boundary**, and it's implemented as a lifecycle method that
    is called when any child components throw an exception. The parent class that
    implements `componentDidCatch()` is the error boundary. You could have different
    boundaries throughout your application, depending on how your features are organized.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The motivation for this functionality is to give the application an opportunity
    to recover from certain errors. Prior to React 16, if a component threw an error,
    the entire app would stop. This might not be ideal, especially if an issue with
    a minor component stops critical components from working.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `App` component with an error boundary:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `App` component does nothing but render `MyError`—a component that intentionally
    throws an error. When this happens, the `componentDidCatch()` method is called
    with the error as an argument. You can then use this value to change the state
    of the component. In this example, it sets the error message in the `err` state.
    Then, `App` will attempt to re-render.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `this.state.err` is passed to `MyError` as a property. During
    the first render, this value is undefined. When `App` catches the error thrown
    by `MyError`, the error is passed back to the component. Let''s look at `MyError`
    now:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This component throws an error with the message `'epic fail'`. When `App` catches
    this error, it renders `MyError` with an `err` prop. When this happens, it simply
    renders the error string in red. This just happens to be the strategy I've chosen
    for this app; always check for an error state before invoking the errant behavior
    again. In `MyError`, the application as a whole is recovered by not executing
    `throw new Error('epic fail')` for a second time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: With `componentDidCatch()`, you're free; set any strategy you like for error
    recovery. Usually, you can't recover a specific component that fails.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Rendering multiple elements and strings
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since React was first released, the rule was that components could only render
    one element. This has changed in two important ways in React 16\. First, you can
    now return a collection of elements from your component. This simplifies cases
    where rendering sibling elements would drastically simplify things. Second, you
    can now render plain text content.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Both of these changes result in fewer elements on the page. By allowing sibling
    elements to be rendered by components, you don't have to wrap them with an element
    for the sake of returning a single element. By rendering strings, you can render
    test content as the child or another component, without having to wrap it in an
    element.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what rendering multiple elements looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that you have to provide a `key` property for elements in a collection.
    Now let''s add an element that returns a string value:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Label` component simply returns a string as its rendered content. The `p`
    element renders `Label` as a child, adjacent to the `{v}` value. When components
    can return strings, you have more options for composing the elements that make
    up your UI.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Rendering to portals
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final new feature of React 16 that I want to introduce is the notion of
    portals. Normally, the rendered output of a component is placed where the JSX
    element is located within the tree. However, there are times when we have greater
    control over where the rendered output of our components ends up. For example,
    what if you wanted to render a component outside of the root React element?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Portals allow components to specify their container element at render time.
    Imagine that you want to display notifications in your application. Several components
    at different locations on the screen need the ability to render notifications
    at one specific spot on the screen. Let''s take a look at how you can target elements
    using portals:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the constructor of this component, the target element is created and stored
    in the `el` property. Then, in `componentWillMount()`, the element is appended
    to the document body. You don't actually need to create the target element in
    your component—you can use an existing element instead. The `componentWillUnmount()`
    method removes this element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `render()` method, the `createPortal()` function is used to create the
    portal. It takes two arguments—the content to render and the target DOM element.
    In this case, it''s passing its child properties. Let''s take a look at how `MyPortal`
    is used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The end result is that the text that's passed to `MyPortal` is rendered as a
    strong element outside of the root React element. Before portals, you would have
    to resort to some kind of imperative workaround in order for something like this
    to work. Now, we can just render the notification in the same context that it's
    needed in—it just happens to be inserted somewhere else in the DOM in order to
    display correctly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was to introduce you to the substantial changes in
    React 16\. Remarkably, there are almost no compatibility issues with the prior
    React release. This is because most of the changes were internal and didn't require
    changes in the API. A couple of new features were added as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The headline of React 16 is its new reconciliation internals. Rather than trying
    to reconcile everything any time a component changes state, the reconciliation
    work is now broken into smaller units. These units can be prioritized, scheduled,
    paused, and resumed. In the near future, React will take full advantage of this
    new architecture and start rendering units of work asynchronously.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: React 16的头条是它的新协调内部。现在，协调工作被分解成更小的单元，而不是在组件改变状态时尝试协调所有内容。这些单元可以被优先处理、调度、暂停和恢复。在不久的将来，React将充分利用这种新架构，并开始异步地渲染工作单元。
- en: You also learned how to use the new error boundary functionality in React components.
    Using error boundaries allows you to recover from component errors without taking
    down the entire application. Then, you learned that React components can now return
    collections of components. This is just like when you render a collection of components.
    Now you can do this directly from components. Finally, you learned how to render
    components to nonstandard locations using portals.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学会了如何在React组件中使用新的错误边界功能。使用错误边界可以让您从组件错误中恢复，而不会使整个应用程序崩溃。然后，您了解到React组件现在可以返回组件集合。就像渲染一组组件一样。现在您可以直接从组件中执行此操作。最后，您学会了如何使用门户将组件渲染到非标准位置。
- en: In the next chapter, you'll learn how to build reactive components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何构建响应式组件。
