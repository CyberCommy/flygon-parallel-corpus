- en: Process Credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, and the following one, the reader will learn concepts and
    practices regarding process credentials and capabilities. Besides being of practical
    importance to application development in Linux, this chapter, by its very nature,
    delves deeper into an often overlooked but extremely key aspect: security. The
    content of this and the following chapter is very much inter-related.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We divide the coverage of this key area into two major parts, each of which
    is a chapter in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the traditional-style Unix permissions model is discussed in
    some detail, and techniques to run programs with root privileges without requiring
    the root password are shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*,
    the modern approach, the POSIX capabilities model, is discussed in some detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will attempt to clearly show the reader that, while it is important to learn
    about the traditional mechanisms and how they operate, it is also important to
    learn about modern approaches to security. However you look at it, security is
    of paramount importance, especially these days. The advent of Linux running on
    all sorts of devices—from tiny IoT and embedded devices to mobile devices, desktops,
    servers, and super-computing platforms—makes security a key concern for all stakeholders.
    Hence, the modern capabilities approach should be used when developing software.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will broadly cover the traditional Unix permissions model,
    what exactly it is, and how it works to provide security and robustness. A bit
    of hacking is always fun too!
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Unix permission model in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real and effective IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful system calls to query and set process credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hacking attempts (a little bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How `sudo(8)`actually works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saved-set IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important thoughts on security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, several examples allow you to try out concepts in a hands-on
    way, to really understand them.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional Unix permissions model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right from the early 1970, the Unix OS had, as usual, an elegant and powerful
    system in place for managing the security of shared objects on the system. These
    objects included files and directories—perhaps the most commonly thought of ones.
    Files, directories, and symbolic links are filesystem objects; there are several
    others, including memory objects (tasks, pipes, shared memory regions, message
    queues, semaphores, keys, sockets) and pseudo filesystems (proc, sysfs, debugfs,
    cgroupfs, and so on) and their objects. The point is all these objects are shared
    in some manner or other, and thus they require a protection mechanism of some
    sort, to protect them from abuse; this mechanism is called the Unix permission
    model.
  prefs: []
  type: TYPE_NORMAL
- en: You probably don't want others to read, write, and delete your files; the Unix permission
    model makes this possible at various granularity levels; again, taking files and
    directories as a common target, you can set permissions at the level of a directory,
    or indeed on each file (and directory) within that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this clear, let''s consider a typical shared object—a file on a disk.
    Let''s create one called `myfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All output displayed is from an Ubuntu 17.10 x86_64 Linux system; the user is
    logged in as `seawolf`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Permissions at the user level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier we did a quick `ls -l` on the previous `myfile` file; the very first
    character `-` reveals, of course, that it''s a regular file; the next nine characters
    `rw-rw-r--`are the file permissions. If you remember, these are grouped into three
    groups—the **Owner** (**U**), **Group** (**G**), and **Others** (**O**) (or Public)
    permissions, each of which contains three permission bits: **r**, **w**, and **x **(read,
    write and execute access). This table summarizes this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22f3bf7d-102d-4c63-a232-e52f883ff328.png)'
  prefs: []
  type: TYPE_IMG
- en: Interpreting it, we can see that the owner of the file can read and write to
    it, and so can the group members, but others (those who are not the owner and
    do not belong to the group the file belongs to) can only perform a read operation
    on `myfile`. That's security!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take an example: we attempt to write to the file `myfile`, using
    the `echo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Will it work? Well, the answer is, it depends: if the owner or group member
    of the file (in this example, seawolf) is running the echo(1) process, then the
    access category will be accordingly set to U or G, and,  yes, it will succeed
    (as U|G does have write access to the file). But if the process''s access category
    is Others or Public, it will fail.'
  prefs: []
  type: TYPE_NORMAL
- en: How the Unix permission model works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A really important point to understand regarding this topic is this: both the
    shared object that is being worked upon (here, the `myfile` file) and the process
    that is performing some access (rwx) on the object (here, the echo process) matter.
    To be more correct, their attributes with respect to permissions matter. The next
    discussion will help make this clear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider this step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: A user with the login name `seawolf` logs in to the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On success, the system spawns a shell; the user is now at the shell prompt.
    (Here, we consider the traditional case of logging into a **command-line interface**
    (**CLI**) console, not a GUI environment.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Every user has a record; it''s stored in the `/etc/passwd` file. Let''s `grep`
    the file for this user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Generically, just do this: `grep $LOGNAME /etc/passwd`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `passwd` entry is a row with seven columns that are colon-delimited fields;
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A few fields require some explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The second field, `<passwd>`, always shows up as just `x` on modern Linux systems;
    this is for security. Even the encrypted password is never displayed (hackers
    can very possibly break it via a brute-force algorithm; it's in a root-only file
    called `/etc/shadow`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third and fourth fields are the **User IDentifier** (**UID**) and **Group
    IDentifier** (**GID**) of the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seventh field is the program to run on successful login; it's usually the
    shell (as preceding), but it could be anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To programmatically query `/etc/passwd`, check out the `getpwnam[_r](3)`, `getpwent[_r](3)`
    library layer APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last point is a key one: the system spawns a shell for the user who logged
    in. A shell is the **user** i**nterface** (UI) between the human user and the
    system on the CLI environment. After all, it''s a process; on Linux, bash is usually
    the shell we use. The shell you receive when you login is called your login shell.
    It''s important, because its privileges determine the privileges of all processes
    it launches—in effect, the privileges you have when working on the system are
    derived from your login shell.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look up our shell process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There it is; our bash process has a **Process Identifier **(**PID**—a unique
    integer identifying a process) of 13833\. Now, the process has other attributes
    associated with it; for our current purposes, the key ones are the process **User
    Identifier **(**UID**) and the process **Group Identifier **(**GID**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Can one lookup these UID, GID values for a process? Let''s try it out with
    the `id(1)` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `id(1)` command shows us that the process UID is 1000 and the process GID
    also happens to be 1000\. (The username is `seawolf` and this user belongs to
    several groups.) In the previous example, we have logged in as the user `seawolf`; this
    fact is reflected by the `id` command. Note that every process we now run from
    this shell will inherit the privileges of this user account, that is, it will
    run with the same UID and GID as the login shell!
  prefs: []
  type: TYPE_NORMAL
- en: 'You might reasonably ask: where does the process get its UID and GID values
    from? Well, think about it: we logged in as the user `seawolf`, and this account''s
    `/etc/passwd` entry''s third and fourth fields are where the process UID and GID
    come from.'
  prefs: []
  type: TYPE_NORMAL
- en: So, every time we run a process from this shell, that process will run with
    UID 1000 and GID 1000.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to understand how exactly the OS checks whether we can perform an operation
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the key question here is: how exactly, at runtime, when the preceding echo
    process is attempting to write to the `myfile` file, does the kernel determine
    whether the write access is allowed. To do this, the OS must determine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the ownership and group membership of the file in question?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In what access category is the process attempting the access running under (for
    example, is it U|G|O)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For that access category, does the permission bitmask allow access?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To answer the first question: the file's ownership and group membership information
    (and a lot more regarding the file) is carried as attributes of the key data structure
    of the filesystem—the **information node** (**inode**). The inode data structure
    is a per-file structure and lives within the kernel (filesystem; it's read into
    memory when the file is first accessed). User space can of course access this
    information via system calls. So, the file owner ID is stored in the inode—let's
    just call it `file_UID`. Similarly, the `file_GID` will also be present in the
    inode object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the curious reader: you can yourself query any file object''s inode by
    using the powerful `stat(2)` system call. (As usual, look up its man page). In
    fact, we have used `stat(2)` in [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials*.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the access category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second question posed previously: what access category will it run under?
    is important to answer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The access category will be either **Owner** (**U**), **Group** (**G**), or
    **Other** (**O**); they are mutually exclusive. The algorithm used by the OS to
    determine the access category is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, it''s a bit more complex: a process can belong to several groups
    simultaneously. So, at permission checking time, the kernel checks all groups;
    if the process belongs to any one of them, the access category is set to G.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for that access category, check the permission bitmask (rwx); if the
    relevant bit is set, the process will be allowed the operation; if not, it won't
    be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to clarify—the `stat(1)` command (which of course is a wrapper
    over the `stat(2)` system call) show us the inode content of the file `myfile`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, we are highlighting the `file_UID == 1000` and `file_GID == 1000`.
  prefs: []
  type: TYPE_NORMAL
- en: In our echo example, we find that a few scenarios can play out, depending on
    who logs in, the group membership(s), and the file's permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to understand this properly, let''s plant a few scenarios (from now on,
    we shall just refer to the process UID as the `UID` and the process GID value
    as the `GID`, as opposed to `process_UID|GID`):'
  prefs: []
  type: TYPE_NORMAL
- en: '**User logs in as seawolf**: [UID 1000, GID 1000]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User logs in as mewolf**: [UID 2000, GID 1000]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User logs in as cato**: [UID 3000, GID 3000]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User logs in as groupy**: [UID 4000, GID 3000, GID 2000, GID 1000]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once logged in, the user attempts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens? Which will work (permission allowed) and which won''t? Run through
    the previous scenarios with the previous algorithm, to determine the crucial access
    category, and you will see; the following table summarizes the cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Case #** | **Login as** | **(Process)** **UID** | **(Process)** **GID**
    | **Access category** **(U&#124;G&#124;O)** | **Perm** **bitmask** | **Write allowed?**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | seawolf | 1000 | 1000 | U | `r**w**-` | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | mewolf | 2000 | 1000 | G | `r**w**-` | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | cato | 3000 | 3000 | O | `r**-**-` | N |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | groupy | 4000 | 4000,3000, 2000,1000 | G | `r**w**-` | Y |'
  prefs: []
  type: TYPE_TB
- en: The preceding description is still a bit too simplistic, but is a good starting
    point. In reality, there's a lot more happening under the hood; the following
    sections shed light on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to this, we will take a slight detour: the `chmod(1)` command (which
    of course becomes the `chmod(2)` system call) is used to set permissions on an
    object. So, if we do this: `chmod g-w myfile` to remove write permissions from
    the group category, then the previous table will change (the rows that get G access
    will now not be allowed to write).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an interesting observation: processes with the craved-for root access
    are those that have their `UID = 0`; it''s a special value!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to be pedantic, actually the echo command can run in two distinct ways:
    one, as a process when the binary executable (usually `/bin/echo`) runs, and two,
    as a built in shell command; in other words, there is no new process, the shell
    process itself—typically `bash` —runs it.'
  prefs: []
  type: TYPE_NORMAL
- en: Real and effective IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We understand from the preceding section that both the shared object that is
    being worked upon (here, the file myfile) and the process that is performing some
    access (rwx) on the object (here, the echo process) matter in terms of permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's zoom deeper into the process attributes with respect to the permissions
    model. So far, we have learned that each process is associated with a UID and
    a GID, thereby allowing the kernel to run its internal algorithms and determine
    whether access to a resource (or object) should be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look deeper, we find that each process UID is actually not a single integer
    value, but two values:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Real User ID** (**RUID**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Effective User ID** (**EUID**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, the group information is not one integer GID value, rather it''s
    two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Real Group ID** (**RGID**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Effective Group ID** (**EGID**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, with respect to privileges, each process has four integer values associated
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '{RUID, EUID, RGID, EGID};  these are called the **process credentials**.'
  prefs: []
  type: TYPE_NORMAL
- en: Pedantically speaking, process credentials also encompass several other process
    attributes—the process PID, the PPID, PGID, session ID, and the real and effective
    user and group IDs. In our discussions, for clarity, we restrict their meaning
    to the last of these—real and effective user and group IDs.
  prefs: []
  type: TYPE_NORMAL
- en: But what exactly do they mean?
  prefs: []
  type: TYPE_NORMAL
- en: Every process has to run under the ownership and group membership of somebody;
    this somebody is of course the user and group IDs of the person who logs in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real IDs are the original values associated with the user who logged in;
    in effect, they are nothing but the UID:GID pair from the `/etc/passwd` record
    for that user. Recall that the `id(1)` command reveals precisely this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `uid` and `gid` values displayed are obtained from the `/etc/passwd` record
    for seawolf. In reality, the `uid/gid` values become the running process's RUID/RGID
    values respectively!
  prefs: []
  type: TYPE_NORMAL
- en: 'The real numbers reflect who you originally are—your login account information
    in the form of integer identifiers. Another way to put it: the real numbers reflect
    who owns the process.'
  prefs: []
  type: TYPE_NORMAL
- en: What about the effective values?
  prefs: []
  type: TYPE_NORMAL
- en: 'The effective values are to inform the OS as to effectively (at this moment) what
    privileges (user and group) the process is running under. Here are a couple of
    key points:'
  prefs: []
  type: TYPE_NORMAL
- en: When performing permission checks, the OS uses the process's effective values,
    not the real (original) values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EUID = 0` is what the OS actually checks for to determine whether the process
    has root privilege.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The EUID = RUID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EGID = RGID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This implies that, for the preceding example, the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes. This brings up a question (don''t you think?): if the real and effective
    IDs are the same, then why do we require four numbers at all? Two will do, right?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, here''s the thing: they usually (by default) are the same, but they can
    change. Let''s see how this can happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, here is a pedantic note: on Linux, the permission checking on filesystem
    operations is predicated on yet another process credential—the filesystem UID
    (or fsuid; and, analogously, the fsgid). However, it''s always the case that the
    fsuid/fsgid pair shadow the EUID/EGID pair of credentials—thereby, effectively
    rendering them the same. That''s why in our discussion we ignore the `fs[u|g]id`
    and focus on the usual real and effective user and group IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before that, though, think about this scenario: a user is logged in, and is
    on the shell; what are their privileges? Well, just run the `id(1)` program; the
    output will display the UID and GID, which we now know is actually {RUID, EUID}
    and the {RGID, EGID} pair with the same values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of an easier-to-read example, let''s take the liberty of changing
    the GID value from 1000, to, say, 2000\. So, now, if the values are UID=1000 and
    GID=2000, and the user now runs, shall we say, the vi editor, now the situation
    is like this, refer to the given table, process credentials - normal case:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Process credentials** **/ process** | **RUID** | **EUID** | **RGID** |
    **EGID** |'
  prefs: []
  type: TYPE_TB
- en: '| bash | 1000 | 1000 | 2000 | 2000 |'
  prefs: []
  type: TYPE_TB
- en: '| vi | 1000 | 1000 | 2000 | 2000 |'
  prefs: []
  type: TYPE_TB
- en: A puzzle – how can a regular user change their password?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say you''re logged in as `seawolf`. For security reasons, you want to
    update your weak password (`hello123`, whoops!) to a strong secure one. We know
    that the password is stored in the `/etc/passwd` file. Well, we also saw that
    on modern Unixes (including Linux of course), for better security it''s *shadowed*:
    it''s actually stored in a file called `/etc/shadow`. Let''s check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: (Remember that we're on an Ubuntu 17.10 x86_64 system; we often point this out,
    as the exact output might vary on different distributions, and if kernel security
    mechanisms, such as SELinux, are installed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As highlighted, you can see that the file owner is root, the group membership
    is shadow, and the permission bitmask for UGO is `[rw-][r--][---]`. This means
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The owner (root) can perform read/write operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group (shadow) can perform read-only operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The others cannot do anything to the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You probably also know that the utility you use to change your password is called
    `passwd(1)` (of course, it's a binary executable program, and is not to be confused
    with the `/etc/passwd(5)` database).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, think about it, we have a bit of a puzzle here: to change your password,
    you need write access to `/etc/shadow`, but, clearly, only root has write access
    to `/etc/shadow`. So, how does it work? (We know it works. You logged in as a regular
    user, not root. You can change your password using the `passwd(1)` utility—try
    it out and see.) So, that''s a good question.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The clue lies in the binary executable utility itself—`passwd`. Let''s check
    it out; firstly, where''s the utility on disk? Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dig deeper—quote the preceding command and long list it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5b6b6b0-6a8f-4d00-a131-8fc186010ed5.png)'
  prefs: []
  type: TYPE_IMG
- en: Can you spot anything unusual?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s the owner execute bit: it''s not an `x` as you might expect, but an `s`
    ! (Really, this is the reason behind the pretty red coloring of the executable
    name in preceding the long listing.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a special permission bit: for a binary executable file, when there''s
    an `s` in the owner''s execute bit, it''s referred to as a setuid binary. This
    means whenever a setuid program is executed, the resultant process''s **Effective
    Userid** (**EUID**) changes (from the default: the original RUID value) to become
    equal to the owner of the binary executable file; in the previous example, the
    EUID will become root (as the `/usr/bin/passwd` file is owned by root).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we redraw the previous table (Process Credentials - Normal Case) with this
    new information in hand, with respect to the setuid passwd executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Process credentials** **/ process ** | **RUID** | **EUID** | **RGID** |
    **EGID** |'
  prefs: []
  type: TYPE_TB
- en: '| bash | 1000 | 1000 | 2000 | 2000 |'
  prefs: []
  type: TYPE_TB
- en: '| vi | 1000 | 1000 | 2000 | 2000 |'
  prefs: []
  type: TYPE_TB
- en: '| /usr/bin/passwd | 1000 | 0 | 2000 | 2000 |'
  prefs: []
  type: TYPE_TB
- en: 'Table: process credentials - setuid-root case (third row)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this answers how it works: the EUID being the special value **`0`** (root),
    the OS now sees the process as being a root process and allows it to write into
    the `/etc/shadow` database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A program such as `/usr/bin/passwd`, inherits root access by virtue of the
    setuid bit and the fact that the file owner is root: these kinds of programs are
    called setuid root binaries (they''re also called set-user-ID-root programs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To quote a frustrated developer''s reaction to testers everywhere: i*t''s not
    a bug; it''s a feature!* Well, it is: the setuid feature is pretty amazing: with
    no programming whatsoever, you are able to raise the privilege level of a process
    for a temporary duration.'
  prefs: []
  type: TYPE_NORMAL
- en: Think about this. Without this feature, it would be impossible for non-root
    users (the majority) to change their password. Requesting the system administrator
    to do this (picture a large organization with a few thousand employees with Linux
    accounts) would not only have the sysadcontemplate suicide, you would have to
    provide the sysad with your new password, perhaps not exactly a brilliant security
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: The setuid and setgid special permission bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see that setuid program binaries are an important takeaway from the
    preceding discussion; let''s summarize it once more:'
  prefs: []
  type: TYPE_NORMAL
- en: A binary executable file with the owner execute bit set to `s` is called a **setuid
    binary**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the owner of said executable file is root, then it's called a **setuid-root
    binary**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you execute a setuid program, the key point is that the EUID is set to
    the owner of the binary executable file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, with setuid-root binaries, the process will run as root!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, once the process dies, you are back to your shell with your regular
    (default) set of process credentials or privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conceptually similar to setuid is the notion of the setgid special permission
    bit:'
  prefs: []
  type: TYPE_NORMAL
- en: A binary executable file with the group execute bit set to `s` is called a setgid
    binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you execute a setgid program, the key point is that the EGID is set to
    the group membership of the binary executable file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, once the process dies, you are back to your shell with your regular
    (default) set of process credentials or privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, remember that the `set[u|g]id` special permission bits only have
    significance on binary executable files, nothing else. For example, attempting
    to set these bits on a script (bash, Perl, and so on) will have absolutely no
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the setuid and setgid bits with chmod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have perhaps, by now, thought okay, but how exactly do I set these special
    permission bits?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is simple: you use the `chmod(1)` command (or system call); this table
    shows how chmod can be used to set the `setuid/setgid` permission bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **chmod via:** | **Notation for setuid** | **Notation for setgid** |'
  prefs: []
  type: TYPE_TB
- en: '| symbolic notation | `u+s` | `g+s` |'
  prefs: []
  type: TYPE_TB
- en: '| octal notation | `4<octal #> (eg. 4755)` | `2<octal #> (eg. 2755)` |'
  prefs: []
  type: TYPE_TB
- en: 'As a trivial example, take a simple `Hello, world` C program and compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set the setuid bit, then remove it, and set the setgid bit instead (in
    one operation: via the `u-s,g+s` parameter to chmod), then remove the setgid bit,
    all the while long-listing the binary executable so that the permissions can be
    seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (As this `Hello, world` program just trivially prints to stdout and nothing
    more, the setuid/setgid bits have no perceived effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Hacking attempt 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, well, wasn't that discussion on setuid root interesting! For you, the
    reader, who's thinking like a hacker (good for you!), why not do this to gain
    the ultimate prize, a root shell!
  prefs: []
  type: TYPE_NORMAL
- en: Write a C program to spawn a shell (the `system(3)` library API makes this trivial);
    we call the code `rootsh_hack1.c`. We want a root shell as the outcome!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compile it, get `a.out`. If we run `a.out` now, no big deal; we''ll get a shell
    with the same privileges that we already have. So instead try this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change permissions with `chmod(1)` to set the `setuid` bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change ownership with `chown(1)` of `a.out` to root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run it: we should now get a root shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wow! Let's try this out!
  prefs: []
  type: TYPE_NORMAL
- en: The code is simple (we don't show the header inclusion here)*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compile and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As expected, when run with no special `set[u|g]id` permission bits, the a.out
    process runs with normal privileges, spawning a shell under the same ownership
    (seawolf)—exactly what the `id -u` command proves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we attempt our hack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It worked! Well, don''t get too excited: we got it to become a setuid binary,
    but the owner is still `seawolf`; so it won''t make any difference at runtime:
    the process EUID will become that of the owner of the binary executable—`seawolf`
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm. Yes, so what we need to do now is make the owner root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Sorry to burst your bubble, budding hacker: it won''t work. This is the security;
    with `chown(1)`, you can only change ownership of the files (or objects) you own,
    and, guess what? To your own account only! Only root can use `chown` to set an
    object''s ownership to anyone else.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes sense security-wise. It goes even further; watch this: we''ll become
    root and run `chown` (by just `sudo`ing it of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice? Even though the `chown` succeeded, the setuid bit got wiped
    out! That's security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s subvert even that by setting the setuid bit manually on the root-owned
    a.out (note that this isn''t even possible unless we already have root access
    or the password):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah! Now it is a setuid-root binary executable (indeed, you can''t see it here
    but the color of a.out  changed to red). No one''s going to stop us! Take a look
    at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The spawned shell has a (R)UID of 1000, not 0 What happened?
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a surprise! Even with root ownership and the setuid bit we do not get
    a root shell. How come? Because of the security, of course: when run via `system(3)`,
    modern versions of bash refuse to run as root on startup. This screenshot shows
    the relevant part of the man page on `system(3)`—showing the caveat that we''re
    discussing ([http://man7.org/linux/man-pages/man3/system.3.html](http://man7.org/linux/man-pages/man3/system.3.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6be597-f178-489f-9896-f946f56b8a9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second paragraph sums it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: System calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We understand from our previous discussions that every process alive has a set
    of four integer values that effectively determine its privileges, the real and
    effective user and group IDs; they are called the process credentials.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, we refer to them as the {RUID, EUID, RGID, EGID}.
  prefs: []
  type: TYPE_NORMAL
- en: The effective IDs are in bold font, to reiterate the fact that while the real
    IDs identify the original owner and group, when it comes to actually checking
    permissions, the kernel uses the effective IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Where are the process credentials stored? The OS keeps this information as part
    of a rather large process attributes data structure (which is per-process of course);
    it is in kernel memory space.
  prefs: []
  type: TYPE_NORMAL
- en: On Unix, this per-process data structure is called the **Process Control Block** (**PCB**);
    on Linux, it's called the process descriptor or, simply, the task structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point is this: if the data is in kernel address space, the only way to
    get at it (query or set) is via system calls, of course.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying the process credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do you programmatically (in a C program) query the real and effective UIDs
    /GIDs? Here are the system calls to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getuid(2)` returns the real UID; `geteuid(2)` returns the effective UID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getgid(2)` returns the real GID; `getegid(2)` returns the effective GID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid_t` and `gid_t` are glibc typedefs for an unsigned integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a neat tip to figure out the typedef for any given data type: you will
    need to know the header file that contains the definition. Just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ echo | gcc -E -xc -include ''sys/types.h'' - | grep uid_t`'
  prefs: []
  type: TYPE_NORMAL
- en: '`typedef unsigned int __uid_t;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`typedef __uid_t uid_t;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`'
  prefs: []
  type: TYPE_NORMAL
- en: Credit*:* [https://stackoverflow.com/questions/2550774/what-is-size-t-in-c](https://stackoverflow.com/questions/2550774/what-is-size-t-in-c).
  prefs: []
  type: TYPE_NORMAL
- en: 'A question comes up: the preceding system calls do not take any parameters;
    they return the real or effective [U|G]IDs, yes, but for which process? The answer,
    of course, is the calling process, the process that issues the system calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We write a simple C program (`ch7/query_creds.c`); when run, it prints to stdout
    its process credentials (we show the relevant code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Build it and try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first run, the four process credential values are the usual ones (1000,
    in our example). Also, note how by default the EUID = RUID and the EGID = RGID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But on the second run we `sudo` it: once we get the password right, the process
    runs as root, which of course can be literally seen here: the four process credential
    values are now all zeros reflecting root authority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sudo – how it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sudo(8)` utility lets you run a program as another user; without further
    qualification, that other user is root. Of course, for security, you must correctly
    enter the root password (or as several distributions allow for desktop computing,
    the user's own password, if he belongs to a group called sudo).
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up a very interesting point: how exactly does the can-do-anything
    `sudo(8)` program work? It''s simpler than you think! Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We note that the binary executable sudo is really a setuid-root program! So
    think about it: whenever you run a program with sudo, the sudo process runs with
    a root privilege straight away—no password, no fuss. But, of course, for security,
    the user must enter the password; once they enter it correctly, sudo continues
    execution and executes the command you want it to—as root. If the user fails to
    enter the password correctly (within three attempts typically), sudo aborts execution.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a saved-set ID?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The so-called saved-set IDs are a convenience feature; the OS is able to save
    the process's initial effective user id (EUID) value. How does it help? This allows
    us to switch from the original EUID value the process starts with to, say, an
    unprivileged normal value (we'll cover how exactly in a moment), and then from
    the current privileged state back to that saved EUID value (via the `seteuid(2)`
    system call); thus, the initially saved EUID is called the **saved-set ID**.
  prefs: []
  type: TYPE_NORMAL
- en: In effect, we can on demand switch back and forth between a privileged and unprivileged
    state for our process!
  prefs: []
  type: TYPE_NORMAL
- en: After we cover a bit more material, an example will help make things clear.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the process credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that, from the shell, a convenient way of looking up who we are currently
    running as is to run the simple `id(1)` command; it displays the real UID and
    real GID (as well as all supplementary groups we belong to). As we have done earlier,
    let''s try it out while logged in as the user `seawolf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider again the `sudo(8)` utility; to run a program as another user, not
    as root, we can use the `-u` or `--user=` switch to `sudo`. For example, let''s
    run the `id(1)` program as the user `mail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As expected, once we provide the correct password, `sudo` runs the `id` program
    as the mail user, and the output of id now shows us that the (real) user and group
    IDs are now that of the mail user account! (not seawolf), precisely the effect
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: But how did `sudo(8)` do this? We understood from the previous section that,
    when you run sudo (with whatever parameters), it, initially at least, always runs
    as root. Now the question is, how does it run with the credentials of another
    user account?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer: several system calls exist that let you change the process privileges
    (the RUID, EUID, RGID, EGID): `setuid(2)`, `seteuid(2)`, `setreuid(2)`, `setresuid(2)`
    and all their analogs for the GID.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the API signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `setuid(2)` system call allows a process to set its EUID to the value passed.
    If the process has root privileges (later in the next chapter, we shall qualify
    statements such as this a lot better, when we learn about the POSIX capabilities
    model), then the RUID and saved-setuid (explained shortly) are also set to this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: All the `set*gid()` calls are analogous to their UID counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: On the Linux OS, the seteuid and setegid APIs, though documented as system calls,
    are actually wrappers over the `setreuid(2)` and `setregid(2)` system calls.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking attempt 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ah, hacking! Well, let's at least attempt to.
  prefs: []
  type: TYPE_NORMAL
- en: We know that `EUID 0` is a special value—it means we have root privilege. Think
    about it—we have a setuid(2) system call. So, even if we're unprivileged, why
    not just do a quick
  prefs: []
  type: TYPE_NORMAL
- en: '`setuid(0);` become privileged, and hack away as root!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hmm, Linux wouldn''t be a very powerful and popular OS if the above hack were
    to actually work. It won''t work, folks: the above system call invocation would
    fail returning `-1`; `errno` would be set to `EPERM` and the error message (from
    `perror(3)` or `strerror(3)`) would be this: Operation not permitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this? There''s a simple rule within the kernel: an unprivileged process
    can set its effective IDs to its real IDs—no other value is allowed. In other
    words, an unprivileged process can set  the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Its EUID to its RUID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its EGID to its RGID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a (root) privileged process can set its four credentials to any value
    it chooses. There is no surprise there—this is part and parcel of the power of
    being root.
  prefs: []
  type: TYPE_NORMAL
- en: The `seteuid(2)` sets the process effective userid to the value passed; for
    an unprivileged process, it can only set its EUID to its RUID, the EUID, or the
    saved setuid.
  prefs: []
  type: TYPE_NORMAL
- en: The `setreuid(2)` sets the real and effective UIDs to the values passed respectively;
    if `-1` is passed, the corresponding value is left untouched. (This can indirectly
    affect the saved-set value.) The `set[r]egid(2)` calls are identical with respect
    to the group IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s be empirical and try out what we just talked about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run it. This screenshot shows us a virtual machine seawolf, along
    with an `ssh`-connected Terminal window in the lower right (where we''re logged
    in as the user seawolf); see the `rootsh_hack2` program running there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3dee453-cdca-432e-a761-cb3fe1bfbcc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Studying the output of the `ssh` terminal window in the preceding screenshot,
    we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The original bash process (the shell) has the PID 6012.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The id command shows that we're running as (a real) UID = 1000 (which is the
    seawolf user).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We run `rootsh_hack2`; clearly, the `setuid(0)` fails; the error message is
    displayed: operation not permitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nevertheless, it's just a warning message; execution continues, and the process
    spawns another bash process, in effect, another shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its PID is 6726 (proving it's unique from the original shell.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The id(1) is still 1000, proving we have not really achieved anything significant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We exit and are back to our original shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But what if we (or worse, a hacker) could trick this process into running as
    root!? How? By making it a setuid-root executable of course; then we''re in trouble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we just simulate being tricked: here we use sudo(8); we enter the password
    and thus change the binary executable to a setuid-root, a truly dangerous, one.
    It runs, and it spawns what now turns out to be a root shell (notice, the `id(1)`
    command proves this fact); we do a `ps` and then `exit`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It also dawns on us that our previous hacking attempt failed to deliver—the
    system(3) API refused to elevate privileges when a shell was the parameter to
    run—which is great security-wise. But, this hacking attempt (#2) proves that you
    can easily subvert that: just issue a call to `setuid(0)` prior to invoking system
    (`/bin/bash`), and it succeeds in delivering a root shell—of course, if and only
    if the process runs as root in the first place: either via the setuid-root approach
    or by just using sudo(8).'
  prefs: []
  type: TYPE_NORMAL
- en: An aside – a script to identify setuid-root and setgid  installed programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now begin to understand that `setuid/setgid` programs might be convenient,
    but from a security viewpoint, they can be potentially dangerous and must be carefully
    audited. The first step in such an audit is finding out whether and where exactly
    these binaries exist on the Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we write a small shell (bash) script; it will identify and show us
    the installed `setuid-root` and `setgid` programs on the system (as usual, you
    can download and try the script from the book's Git repository).
  prefs: []
  type: TYPE_NORMAL
- en: 'The script performs its work essentially, as shown next (it actually loops
    over an array of directories; for simplicity, we show a direct example of scanning
    the `/bin` directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The output of `ls -l` is piped to `grep(1)`, which uses a regular expression
    designed to match a string if the first character is a `-` (a regular file) and
    if the owner execute bit is s—in other words, a setuid file; the `awk(1)` filter
    ensures that only if the owner is root do we print the resultant string to stdout.
  prefs: []
  type: TYPE_NORMAL
- en: We run the bash script on two Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'On an Ubuntu 17.10 on x86_64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A system information banner is displayed (so that we can glean system details,
    mostly obtained using the `lsb_release` utility). Then, the script scans through
    various system directories printing out all `setuid-root` and `setgid` binaries
    it finds. Familiar examples, `passwd` and `sudo` are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: setgid example – wall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a great example of `setgid` binaries, take a look at the wall(1) utility,
    reproduced from the script''s output for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The wall(1) program is used to broadcast any message to all users console (tty)
    devices (typically the sysad will do this). Now, to write to a `tty` device (recall,
    folks, [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux System
    Architecture*, and the if it''s not a process, it''s a file Unix philosophy),
    what permissions do we require? Let''s take the second terminal `tty2` device
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can see that to write to the preceding device we either require root or we
    must be a member of the `tty` group. Peek again at the wall(1) utility long listing;
    it's a setgid binary-executable file and the group membership is `tty`; so, when
    anyone runs it, the wall process runs with an effective group ID (EGID) of `tty`
    ! That solves the problem—no code. No fuss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot where wall is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0736e00-379a-4550-8e77-0709bca6be26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the foreground, there is an `ssh` connected (to an Ubuntu VM; you can see
    it in the background) terminal window. It issues the `wall` command as a regular
    user: because of the `setgid tty`*,* it works!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can run the earlier script on a Fedora 27 on x86_64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: More setuid-root binaries seem to show up; also, `write(1)` is the equivalent
    (to `wall(1)`) `setgid tty` utility on Fedora.
  prefs: []
  type: TYPE_NORMAL
- en: Giving up privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the previous discussion, it seems as if the `set*id()` system calls (`setuid(2)`,
    `seteuid(2)`, `setreuid(2)`, `setresuid(2)`) are only useful to root, as only
    with root privileges can we use the system calls to change the process credentials.
    Well, that's not really the full truth; there's another important case, for non-privileged
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this scenario: our program specification requires the initialization
    code to run with root privileges; the rest of the code does not. Obviously, we
    don''t want to give the end user root access just to run our program. How do we
    solve this?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the program setuid-root would nicely do the trick. As we''ve seen, a
    setuid-root process will always run as root; but after the initialization work
    is done, we can switch back to the unprivileged normal state. How do we do this?
    Via the `setuid(2)`: recall that setuid for a privileged process sets both the
    EUID and RUID to the value passed; so we pass it the process''s RUID, which we
    obtain via the getuid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a useful semantic (often, the `seteuid(getuid()`) is all we require).
    We use this semantic to become our true selves again—quite philosophical, no?
  prefs: []
  type: TYPE_NORMAL
- en: 'In **information security** (**infosec**) circles, there is an important principle
    followed: reduction of the attack surface. Converting a root privileged process
    to become non-privileged (once its work as root is done) helps toward this goal
    (to some extent at least).'
  prefs: []
  type: TYPE_NORMAL
- en: Saved-set UID – a quick demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we''ve just seen how the useful `seteuid(getuid()`)
    semantic can be used to switch a setuid privileged process to a regular unprivileged
    state (that''s good design and safer). But what if we have this requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To achieve the must-run-as-root semantic initially, we can of course create
    the program to be a setuid-root program. Then, at time t1, we issue the `setuid(getuid()`)
    giving up root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do we regain root privileges at time t2? Ah, that''s where the saved-setuid
    feature becomes precious. What''s more, it''s easy to do; here is the pseudo-code
    to achieve this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We demonstrate the same with an actual C code next. Note that for the demo
    to work as expected, the user must make the binary executable file into a setuid-root
    binary by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code  checks that, at the beginning, the process is indeed running
    as root; if not, it aborts with a message asking the user to make the binary a
    setuid-root binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a sample run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The program fails as it detects that it's not running effectively as root in
    the beginning, implying that it's not a setuid-root binary executable in the first
    place. So, of course, we must make it a setuid-root binary executable by doing
    the `sudo chown ...` followed by the `sudo chmod ...` . (Notice how we've kept
    the code to do so in the Makefile but have commented it out, so that you, the
    reader, can get some practice).
  prefs: []
  type: TYPE_NORMAL
- en: 'This screenshot shows that once we do this, it runs as expected, switching
    back and forth between the privileged and unprivileged states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fda744b4-4daa-439c-b624-92f428e976c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the really crucial system call to switch back and forth is, after
    all, the setuid(2); also notice how the EUID changes at different points in time
    (from 0 at t0, to 1000 at t1, again to 0 at t2 and finally back to 1000 at t3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that, to provide interesting examples, we have been mostly using
    setuid-root binaries. You need not: making the file owner someone else (such as
    the mail user) would then in effect make it a setuid-mail binary executable, meaning
    that, when run, the process RUID would be the usual 1000 (seawolf), but the EUID
    would be that of the mail user''s RUID.'
  prefs: []
  type: TYPE_NORMAL
- en: The setres[u|g]id(2) system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a couple of wrapper calls—the `setresuid(2)` and the `setresgid(2)`;
    their signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This pair of system calls is like a superset of the earlier `set*id()` APIs.
    With the `setresuid(2)` system call, a process can set the RUID, EUID, and saved-set-id
    all at once, with a single system call (the **res** in the system call name stands
    for **real**, **effective**, and **saved**-set-ID, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: A non-privileged (meaning, non-root) process can only use this system call to
    set the three IDs to one of the current RUID, the current EUID, or the current
    saved-set UID, nothing else (the usual security principle at work). Passing `-1`
    implies to leave the corresponding value unchanged. A privileged (root) process
    can use the call to set the three IDs to any values, of course. (As usual, the
    `setresgid(2)` system call is identical except that it sets group credentials).
  prefs: []
  type: TYPE_NORMAL
- en: Some real-world OSS projects indeed use this system call; good examples are
    the OpenSSH project (the Linux port is called OpenSSH-portable) and the well-known sudo(8)
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSSH: from its git repository here: [https://github.com/openssh/openssh-portable/](https://github.com/openssh/openssh-portable/)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`uidswap.c`: `permanently_drop_suid():`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It's interesting to notice the effort taken to ensure that the UID drop was
    successful—more on this next!
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing an `strace(1)` on sudo(8) (notice we have to trace it as root, as
    attempting to strace a setuid program as a regular user does not work as, while
    tracing, the setuid bit is deliberately ignored; this output is from an Ubuntu
    Linux system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, sudo uses the `setresuid(2)` system call to set permissions, credentials,
    really, as appropriate (in the preceding example, the process EUID is being set
    to that of the mail user, the RUID and saved-set-id are being left unchanged).
  prefs: []
  type: TYPE_NORMAL
- en: Important security notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few key points to keep in mind, with regard to security:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of setuid binaries, if poorly designed, is a security risk. Particularly
    and especially for setuid-root programs, they should be designed and tested to
    ensure that, while the process is in an elevated privileged state, it never spawns
    a shell or blindly accepts user commands (which are then internally executed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must check the failure case of any of the `set*id()` system calls `(setuid(2)`,
    `seteuid(2)`, `setreuid(2)`, `setresuid(2)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider this pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Think about this: what if the preceding `setuid(getuid())` call failed (for
    whatever reason) and we did not check? The remaining work would continue to run
    with root access, very possibly courting disaster! (See the sample code from the
    OpenSSH-portable Git repo for a real-world example of careful checking.) Let''s
    take a look at the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setuid(2)` system call is deficient in a sense: if the real UID is root,
    then the saved-set UID is also root; hence, you cannot drop privileges! Obviously,
    this can be dangerous for setuid-root applications and the like. As an alternative,
    use the `setreuid(2)` API to have a root process temporarily drop privileges and
    regain them later (by swapping their RUID and EUID values).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you have system administrator (root) access, you should never log in
    as root! You could be (quite easily) tricked into running dangerous programs as
    root (hackers routinely use this technique to install rootkits onto a system;
    once successful, do consider your system compromised).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a process creates a shared object (say a file), who will own it and what
    will the group be? In other words, what values will the kernel set in the file''s
    inode metadata structure for UID and GID? The answer is this: the file UID will
    be the creator process''s EUID, and the file GID (group membership) will be the
    creator process''s EGID. This will have a subsequent effect on permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We recommend that you, the reader, definitely read [Chapter 9](3b2340aa-4ab7-46e3-93c0-7f7c210f834b.xhtml),
    *Process Execution*, as well! In it, we show how the traditional permissions model
    is flawed in many respects, and why and how you should use the superior Linux
    Capabilities model.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the reader has been taken through many important ideas on the
    design and implementation of the traditional Unix security model. Among other
    things, we have covered the traditional Unix permission model, the concepts of
    process real and effective IDs, APIs to query and set them, `sudo(8)`, saved-set
    IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it bears repeating: we definitely recommend you also read the following
    [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*!
    In it, we show how the traditional permissions model is flawed, and how you should
    use the superior, modern Linux Capabilities model.'
  prefs: []
  type: TYPE_NORMAL
