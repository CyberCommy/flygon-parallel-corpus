- en: Generics in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics is a very important topic in the C# programming language. As far as
    I know, it would be hard to find any modern software written in C# that doesn't
    use generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What are generics?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need generics?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different constraints of generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covariance and Contravariance in generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are generics?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, generics are used to create classes, methods, structs and other components
    that are not specific, but general. This allows us to use the generic component
    for different reasons. For example, if you have a general-purpose soap, you can
    use that soap for any kind of washing. You can use it to wash your hands, to wash
    your clothes, or even to wash your dirty dishes. However, if you have a specific
    category of soap, such as laundry detergent, it can only be used for washing clothes
    and not for any other thing. Consequently, generics give us some extra power of
    re-usability in our code, which is good for an application as there would be less
    code which does similar work. Generics are not newly developed; they has been
    available since C# 2\. So, with so many years of usage, generics have become commonly
    used by programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a `Generic` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/140f13d4-7a65-4ca8-aec5-3d936a425256.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are totally new to the syntax of generics, you might be surprised to
    see the angle brackets, `<>`, next to the `Price` class. You also might be wondering
    what the `T` inside `<>` is. This is the syntax of generics in C#. By putting `<>`
    next to the class name, we are telling the compiler that this is a generic class.
    Furthermore, the `T` inside `<>` is a type parameter. Yes, I know what you are
    asking: *"What is a type parameter?"* A **type parameter** is like any other parameter
    in C# programming, except it passes a type instead of a value or reference. Now,
    let''s analyze the preceding code.'
  prefs: []
  type: TYPE_NORMAL
- en: We created a generic `Price` class. To make it generic, we placed `<T>` next
    to the class name. Here, the `T` is a type parameter, but it's not something fixed
    that you have to use `T` with to represent the type parameter—you can use anything
    to represent it. However, it is traditional to use `T` for the type parameter.
    If there are more type parameters, `V` and `E` are used. There is another popular
    convention when using two or more parameters, which is to name the parameter something
    such as `TValue` and `TKey`, instead of just `V` and `E`, which is done for better
    readability. However, as you can see, we have prefixed `T` before the words `Value`
    and `Key`, which is done to distinguish between a type parameter and a general
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Price<T>` class, we first created a variable named `ob`, which is a
    type of `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we run the preceding code, the type that we pass in the class will be the
    type of this object. Consequently, we can say that `T` is a placeholder, which
    will be replaced with some other concrete C# types (`int`, `double`, `string`,
    or any other complex type) in the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next lines, we created a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we passed a parameter of the `T` type and then assigned
    the value of the passed parameter, `o`, to the local variable, `ob`. We can do
    this assignment as the parameter passed in the constructor is also the `T` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we created a second method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first method prints the type of `T`. This will be helpful for identifying
    the type when we run the program. Another method is to return the local variable, `ob`.
    Here is where we notice that we are returning `T` from the `GetPrice` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we focus on our main method, we will see that in the first line we
    are instantiating our generic class, `Price`, with `int` as a type parameter,
    and passing an integer value, `55`, to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we do this, the compiler treats every `T` in the `Price` class as `int`.
    Consequently, the local parameter, `ob`, will be of the `int` type. When we run
    the `PrintType` method, this should print System.Int32 on the screen, and when
    we run the `GetPrice` method, it should return an `Int` type value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as the `Price` method is generic, we can use this `Price` method for string
    types as well. To do that, we have to set the type parameter as `string`. Let''s
    add some more code into the preceding example, which will create a `Price` object
    that deals with strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dc6301a-d676-4bdc-8179-1c371c2e0321.png)'
  prefs: []
  type: TYPE_IMG
- en: Why do we need generics?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing the previous example, you might wonder why we need generics when
    we can use the `object` type instead. The `object` type can be used for any type
    in C#, and the preceding example can be achieved through the use of an `object`
    type. Yes, the preceding example can be achieved through the use of the object
    type, but there won't be any type-safety. In contrast, generics ensure that the
    type-safety is there when the code gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: If you are like me, you definitely want to know what type-safety is. **Type-safety**
    actually refers to keeping the type secure or unchangeable when executing any
    task in the program. This helps us reduce runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the preceding program, using the object type instead of a
    generic, to see how generics can handle type-safety and object types can''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a223402-1e51-43ed-97e4-ea3c0aea78f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Different constraints of generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different types of constraints available in C# generics:'
  prefs: []
  type: TYPE_NORMAL
- en: Base class constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference type and value type constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common and popular types are base class constraints and interface constraints,
    so we will focus on them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Base class constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of this constraint is that only the classes that extend a base class
    can be used as generic type. For example, if you have a class named `Person` and
    you use this `Person` class as a base for the `Generic` constraint, only the `Person`
    class or any other class that inherits the `Person` class can be used as the type
    argument for that generic class. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Interface constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the Base class constraint, we see the interface constraint when your
    generic class constraint is set as an Interface. Only those classes can be used
    in the generic method that implements that interface.
  prefs: []
  type: TYPE_NORMAL
- en: Reference type and value type constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you want to differentiate between your generic class and reference types
    and value types, you need to use this constraint. When you use a Reference type
    constraint, the generic class will only accept the Reference type objects. To
    achieve that, you have to extend your generic class with a `class` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, when you want to use a value type, you need to write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we know, `class` is a reference type and `struct` is a value type. So, when
    you make a value type constraint, this means that the generic will only work for
    value types such as `int` or `double`. No reference type, such as string or any
    other custom class, will work.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, you can use multiple constraints in a generic class. When you do this,
    you need to take care of the sequence. There is actually no limit to how many
    constraints you can include; you can use as many you need.
  prefs: []
  type: TYPE_NORMAL
- en: Generic methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like the `Generic` class, there can be generic methods, and a generic method
    does not necessarily have to be inside a generic class. A generic method can be
    inside a non-generic class as well. To create a generic method, you have to place
    the type parameter next to the method name and before the parenthesis. The general
    form is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at an example of a generic method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e51e658f-c3b2-4124-afc4-89e61c35953d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that our `Hello` class is not a `Generic` class. However, the
    `Larger` method is a generic method. This method takes two parameters and compares
    them, returning the larger value. This method has also implemented a constraint,
    which is `IComparable<T>`. In the main method, we have called this generic method
    several times, once with `int` values and once with `double` values. In the output,
    we can see that the method was successfully able to compare and return the larger
    value.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have used only one type of parameter, but it is possible
    to have more than one parameter in a generic method. We have also created a `static` method in
    this example code, but a generic method can be non-static as well. Being static/non-static
    doesn't have anything to do with being a generic method.
  prefs: []
  type: TYPE_NORMAL
- en: Type-inferencing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compilers are getting smarter. One such example is type-inferencing in a generic
    method. **Type-inferencing** means calling a generic method without specifying
    the type parameter, and letting the compiler identify which type to use. This
    means that in the previous example, we could not have specified the type parameter
    when calling the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some example code of type-inferencing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/465f1489-acd9-43d6-aaa3-d0ad0c2c2728.png)'
  prefs: []
  type: TYPE_IMG
- en: In this code, we can see that we haven't specified the type parameter in the
    generic method. However, the code still compiles and shows the correct output.
    This is because the compiler used type inferences to figure out the type of arguments
    that were passed in the methods and executed the method as if the parameter type
    was already given to the compiler. Because of that, when you use a type inference,
    it's not allowed to provide different types of arguments in a generic method.
    If you need to pass different types of arguments, you should explicitly do that.
    You can also apply the constraints on a method that can be applied on the classes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance and contravariance in generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have studied delegates, I am sure you have heard about covariance and
    contravariance. These were mainly introduced for non-generic delegates. However,
    from C# 4, these are also available for generic interfaces and delegates. The
    concepts of covariance and contravariance in generics is almost the same as it
    is in delegates. Let's look into this with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This means that the generic interface that has a `T` type parameter can return
    `T` or any class that is derived from `T`. To achieve this, the parameter should
    be used with the `out` keyword. Let''s see the generic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Contravariance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Contravariance is another feature that is implemented in generics. The word
    "Contravariance" might sound a little complex, but the concept behind it is very
    simple. Normally, when creating a generic method, the argument we pass to it is
    the same type as `T`. If you try to pass another type of argument, it will give
    you a compile-time error. However, when using contravariance, you can pass the
    base class, which the type parameter implements. In addition, to use contravariance,
    there is a special syntax we have to follow. Let''s see the generic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you analyze the preceding statement, you will see that there is a keyword
    used before `T`, which is `in`. This keyword tells the compiler that this is contravariance.
    If you don't include the `in` keyword, contravariance will not be applicable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at some example code to make our understanding clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74ef526e-0505-4898-9e7e-e1df617488ad.png)'
  prefs: []
  type: TYPE_IMG
- en: If we now analyze this code, we will see that we have created an Interface named
    `IFood`, which uses contravariance. This means that if this interface is implemented
    in a generic class, that class will allow the **base class** of the provided type
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IFood` interface has a method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, `T` is used as a parameter in the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, a class named `HealthyFood` implements the interface, and the method that
    is implemented in the class only prints a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we created two classes: `Vegetable` and `Potato`. `Potato` extends `Vegetable`.
    Both classes override the `ToString()` method, and return `Potato` if the class
    is `Potato` or `Vegetable` if the class is `Vegetable`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main method, we create an object of the `Potato` class and an object
    of the `Vegetable` class. Both of these are kept in the `IFood<Potato>` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The interesting part here is that the  `mySelf2` variable is of the `IFood<Potato>` type,
    but it holds an object of the `HealthyFood<Vegetable>` type. This is only possible
    because of contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute it, we can see that the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you remove the `in` keyword and try to run the program again, you will fail
    and the compiler will throw an error to say that this is not possible. It was
    only possible to run the code because of contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics in C# is a very powerful feature that reduces code duplication, makes
    the program more structured, and provides extensibility. Some of the important
    data structures are created based on the concept of generics; for example, List
    (collection) is a generic type in C#. This is one of the most heavily used data
    structures in modern-day development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to design and model our software
    using diagrams for better communication. When developing software, if the software
    design is not clearly communicated to the developers, there is a high likelihood
    that the software will not serve the purpose it was built for. Consequently, understanding
    important models and diagrams is very important.
  prefs: []
  type: TYPE_NORMAL
