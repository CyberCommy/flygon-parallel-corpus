- en: Generics in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的泛型
- en: Generics is a very important topic in the C# programming language. As far as
    I know, it would be hard to find any modern software written in C# that doesn't
    use generics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是C#编程语言中非常重要的一个主题。据我所知，很难找到任何不使用泛型的C#编写的现代软件。
- en: 'The topics we will cover in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖的主题如下：
- en: What are generics?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是泛型？
- en: Why do we need generics?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要泛型？
- en: Different constraints of generics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型的不同约束
- en: Generic methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型方法
- en: Covariance and Contravariance in generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型中的协变和逆变
- en: What are generics?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是泛型？
- en: In C#, generics are used to create classes, methods, structs and other components
    that are not specific, but general. This allows us to use the generic component
    for different reasons. For example, if you have a general-purpose soap, you can
    use that soap for any kind of washing. You can use it to wash your hands, to wash
    your clothes, or even to wash your dirty dishes. However, if you have a specific
    category of soap, such as laundry detergent, it can only be used for washing clothes
    and not for any other thing. Consequently, generics give us some extra power of
    re-usability in our code, which is good for an application as there would be less
    code which does similar work. Generics are not newly developed; they has been
    available since C# 2\. So, with so many years of usage, generics have become commonly
    used by programmers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，泛型用于创建不特定但通用的类、方法、结构和其他组件。这使我们能够为不同的原因使用通用组件。例如，如果您有一种通用的肥皂，您可以用它来进行任何类型的清洗。您可以用它来洗手，洗衣服，甚至洗脏碗。但是，如果您有一种特定类别的肥皂，比如洗衣粉，它只能用来洗衣服，而不能用来做其他事情。因此，泛型为我们的代码提供了一些额外的可重用性，这对于应用程序是有益的，因为会有更少的代码来执行类似的工作。泛型并不是新开发的；它们自C#
    2以来就已经可用。因此，经过这么多年的使用，泛型已经成为程序员常用的工具。
- en: 'Let''s take a look at an example of a `Generic` class:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个`Generic`类的例子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/140f13d4-7a65-4ca8-aec5-3d936a425256.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/140f13d4-7a65-4ca8-aec5-3d936a425256.png)'
- en: 'If you are totally new to the syntax of generics, you might be surprised to
    see the angle brackets, `<>`, next to the `Price` class. You also might be wondering
    what the `T` inside `<>` is. This is the syntax of generics in C#. By putting `<>`
    next to the class name, we are telling the compiler that this is a generic class.
    Furthermore, the `T` inside `<>` is a type parameter. Yes, I know what you are
    asking: *"What is a type parameter?"* A **type parameter** is like any other parameter
    in C# programming, except it passes a type instead of a value or reference. Now,
    let''s analyze the preceding code.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对泛型的语法完全不熟悉，您可能会对在`Price`类旁边看到的尖括号`<>`感到惊讶。您可能还想知道`<>`中的`T`是什么。这是C#中泛型的语法。通过将`<>`放在类名旁边，我们告诉编译器这是一个泛型类。此外，`<>`中的`T`是一个类型参数。是的，我知道您在问：“'什么是类型参数？'”**类型参数**就像C#编程中的任何其他参数一样，只是它传递的是类型而不是值或引用。现在，让我们分析前面的代码。
- en: We created a generic `Price` class. To make it generic, we placed `<T>` next
    to the class name. Here, the `T` is a type parameter, but it's not something fixed
    that you have to use `T` with to represent the type parameter—you can use anything
    to represent it. However, it is traditional to use `T` for the type parameter.
    If there are more type parameters, `V` and `E` are used. There is another popular
    convention when using two or more parameters, which is to name the parameter something
    such as `TValue` and `TKey`, instead of just `V` and `E`, which is done for better
    readability. However, as you can see, we have prefixed `T` before the words `Value`
    and `Key`, which is done to distinguish between a type parameter and a general
    parameter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个泛型`Price`类。为了使它成为泛型，我们在类名旁边放置了`<T>`。这里，`T`是一个类型参数，但它并不是固定的，您可以使用任何东西来表示类型参数，而不一定非要使用`T`。但是，传统上使用`T`来表示类型参数。如果有更多的类型参数，会使用`V`和`E`。在使用两个或更多参数时，还有另一种常用的约定，即将参数命名为`TValue`和`TKey`，而不仅仅是`V`和`E`，这样做可以提高可读性。但是，正如您所看到的，我们在`Value`和`Key`之前加了`T`前缀，这是为了区分类型参数和一般参数。
- en: 'In the `Price<T>` class, we first created a variable named `ob`, which is a
    type of `T`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Price<T>`类中，我们首先创建了一个名为`ob`的变量，它是`T`类型的：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we run the preceding code, the type that we pass in the class will be the
    type of this object. Consequently, we can say that `T` is a placeholder, which
    will be replaced with some other concrete C# types (`int`, `double`, `string`,
    or any other complex type) in the runtime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的代码时，我们在类中传递的类型将是这个对象的类型。因此，我们可以说`T`是一个占位符，在运行时将被一些其他具体的C#类型（`int`、`double`、`string`或任何其他复杂类型）替换。
- en: 'On the next lines, we created a constructor:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我们创建了一个构造函数：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the constructor, we passed a parameter of the `T` type and then assigned
    the value of the passed parameter, `o`, to the local variable, `ob`. We can do
    this assignment as the parameter passed in the constructor is also the `T` type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们传递了一个`T`类型的参数，然后将传递的参数`o`的值分配给局部变量`ob`。我们可以这样做是因为在构造函数中传递的参数也是`T`类型。
- en: 'Then, we created a second method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了第二个方法：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the first method prints the type of `T`. This will be helpful for identifying
    the type when we run the program. Another method is to return the local variable, `ob`.
    Here is where we notice that we are returning `T` from the `GetPrice` method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一个方法打印`T`的类型。这将有助于在运行程序时识别类型。另一个方法是返回局部变量`ob`。在这里，我们注意到我们从`GetPrice`方法中返回了`T`。
- en: 'Now, if we focus on our main method, we will see that in the first line we
    are instantiating our generic class, `Price`, with `int` as a type parameter,
    and passing an integer value, `55`, to the constructor:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们专注于我们的主方法，我们会看到在第一行中我们正在用`int`作为类型参数实例化我们的泛型类`Price`，并将整数值`55`传递给构造函数：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we do this, the compiler treats every `T` in the `Price` class as `int`.
    Consequently, the local parameter, `ob`, will be of the `int` type. When we run
    the `PrintType` method, this should print System.Int32 on the screen, and when
    we run the `GetPrice` method, it should return an `Int` type value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as the `Price` method is generic, we can use this `Price` method for string
    types as well. To do that, we have to set the type parameter as `string`. Let''s
    add some more code into the preceding example, which will create a `Price` object
    that deals with strings:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dc6301a-d676-4bdc-8179-1c371c2e0321.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Why do we need generics?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing the previous example, you might wonder why we need generics when
    we can use the `object` type instead. The `object` type can be used for any type
    in C#, and the preceding example can be achieved through the use of an `object`
    type. Yes, the preceding example can be achieved through the use of the object
    type, but there won't be any type-safety. In contrast, generics ensure that the
    type-safety is there when the code gets executed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: If you are like me, you definitely want to know what type-safety is. **Type-safety**
    actually refers to keeping the type secure or unchangeable when executing any
    task in the program. This helps us reduce runtime errors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the preceding program, using the object type instead of a
    generic, to see how generics can handle type-safety and object types can''t:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a223402-1e51-43ed-97e4-ea3c0aea78f4.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Different constraints of generics
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different types of constraints available in C# generics:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Base class constraints
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface constraints
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference type and value type constraints
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple constraints
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common and popular types are base class constraints and interface constraints,
    so we will focus on them in the following sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Base class constraints
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of this constraint is that only the classes that extend a base class
    can be used as generic type. For example, if you have a class named `Person` and
    you use this `Person` class as a base for the `Generic` constraint, only the `Person`
    class or any other class that inherits the `Person` class can be used as the type
    argument for that generic class. Let''s look at an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Interface constraints
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the Base class constraint, we see the interface constraint when your
    generic class constraint is set as an Interface. Only those classes can be used
    in the generic method that implements that interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Reference type and value type constraints
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you want to differentiate between your generic class and reference types
    and value types, you need to use this constraint. When you use a Reference type
    constraint, the generic class will only accept the Reference type objects. To
    achieve that, you have to extend your generic class with a `class` keyword:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Furthermore, when you want to use a value type, you need to write the following
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we know, `class` is a reference type and `struct` is a value type. So, when
    you make a value type constraint, this means that the generic will only work for
    value types such as `int` or `double`. No reference type, such as string or any
    other custom class, will work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Multiple constraints
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, you can use multiple constraints in a generic class. When you do this,
    you need to take care of the sequence. There is actually no limit to how many
    constraints you can include; you can use as many you need.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Generic methods
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like the `Generic` class, there can be generic methods, and a generic method
    does not necessarily have to be inside a generic class. A generic method can be
    inside a non-generic class as well. To create a generic method, you have to place
    the type parameter next to the method name and before the parenthesis. The general
    form is given here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s look at an example of a generic method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e51e658f-c3b2-4124-afc4-89e61c35953d.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that our `Hello` class is not a `Generic` class. However, the
    `Larger` method is a generic method. This method takes two parameters and compares
    them, returning the larger value. This method has also implemented a constraint,
    which is `IComparable<T>`. In the main method, we have called this generic method
    several times, once with `int` values and once with `double` values. In the output,
    we can see that the method was successfully able to compare and return the larger
    value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have used only one type of parameter, but it is possible
    to have more than one parameter in a generic method. We have also created a `static` method in
    this example code, but a generic method can be non-static as well. Being static/non-static
    doesn't have anything to do with being a generic method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Type-inferencing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compilers are getting smarter. One such example is type-inferencing in a generic
    method. **Type-inferencing** means calling a generic method without specifying
    the type parameter, and letting the compiler identify which type to use. This
    means that in the previous example, we could not have specified the type parameter
    when calling the method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some example code of type-inferencing:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/465f1489-acd9-43d6-aaa3-d0ad0c2c2728.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: In this code, we can see that we haven't specified the type parameter in the
    generic method. However, the code still compiles and shows the correct output.
    This is because the compiler used type inferences to figure out the type of arguments
    that were passed in the methods and executed the method as if the parameter type
    was already given to the compiler. Because of that, when you use a type inference,
    it's not allowed to provide different types of arguments in a generic method.
    If you need to pass different types of arguments, you should explicitly do that.
    You can also apply the constraints on a method that can be applied on the classes
    as well.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Covariance and contravariance in generics
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have studied delegates, I am sure you have heard about covariance and
    contravariance. These were mainly introduced for non-generic delegates. However,
    from C# 4, these are also available for generic interfaces and delegates. The
    concepts of covariance and contravariance in generics is almost the same as it
    is in delegates. Let's look into this with examples.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Covariance
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This means that the generic interface that has a `T` type parameter can return
    `T` or any class that is derived from `T`. To achieve this, the parameter should
    be used with the `out` keyword. Let''s see the generic form:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Contravariance
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Contravariance is another feature that is implemented in generics. The word
    "Contravariance" might sound a little complex, but the concept behind it is very
    simple. Normally, when creating a generic method, the argument we pass to it is
    the same type as `T`. If you try to pass another type of argument, it will give
    you a compile-time error. However, when using contravariance, you can pass the
    base class, which the type parameter implements. In addition, to use contravariance,
    there is a special syntax we have to follow. Let''s see the generic syntax:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you analyze the preceding statement, you will see that there is a keyword
    used before `T`, which is `in`. This keyword tells the compiler that this is contravariance.
    If you don't include the `in` keyword, contravariance will not be applicable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at some example code to make our understanding clearer:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74ef526e-0505-4898-9e7e-e1df617488ad.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: If we now analyze this code, we will see that we have created an Interface named
    `IFood`, which uses contravariance. This means that if this interface is implemented
    in a generic class, that class will allow the **base class** of the provided type
    parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IFood` interface has a method signature:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFood`接口有一个方法签名：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `T` is used as a parameter in the method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`T`被用作方法的参数。
- en: 'Now, a class named `HealthyFood` implements the interface, and the method that
    is implemented in the class only prints a string:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个名为`HealthyFood`的类实现了接口，而类中实现的方法只打印一个字符串：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we created two classes: `Vegetable` and `Potato`. `Potato` extends `Vegetable`.
    Both classes override the `ToString()` method, and return `Potato` if the class
    is `Potato` or `Vegetable` if the class is `Vegetable`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了两个类：`Vegetable`和`Potato`。`Potato`扩展`Vegetable`。两个类都重写了`ToString()`方法，并且如果类是`Potato`，则返回`Potato`，如果类是`Vegetable`，则返回`Vegetable`。
- en: 'In the main method, we create an object of the `Potato` class and an object
    of the `Vegetable` class. Both of these are kept in the `IFood<Potato>` variable:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法中，我们创建了一个`Potato`类的对象和一个`Vegetable`类的对象。这两个对象都保存在`IFood<Potato>`变量中：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The interesting part here is that the  `mySelf2` variable is of the `IFood<Potato>` type,
    but it holds an object of the `HealthyFood<Vegetable>` type. This is only possible
    because of contravariance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分在于`mySelf2`变量是`IFood<Potato>`类型，但它持有`HealthyFood<Vegetable>`类型的对象。这只有因为逆变性才可能。
- en: 'Check out the following statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下语句：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we execute it, we can see that the output is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行它时，可以看到输出如下：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you remove the `in` keyword and try to run the program again, you will fail
    and the compiler will throw an error to say that this is not possible. It was
    only possible to run the code because of contravariance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果删除`in`关键字并尝试再次运行程序，您将失败，并且编译器将抛出错误，表示这是不可能的。之所以能够运行代码，仅仅是因为逆变性。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Generics in C# is a very powerful feature that reduces code duplication, makes
    the program more structured, and provides extensibility. Some of the important
    data structures are created based on the concept of generics; for example, List
    (collection) is a generic type in C#. This is one of the most heavily used data
    structures in modern-day development.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的泛型是一个非常强大的功能，它减少了代码重复，使程序更加结构化，并提供了可扩展性。一些重要的数据结构是基于泛型概念创建的；例如，List（集合）是C#中的一种泛型类型。这是现代开发中最常用的数据结构之一。
- en: In the next chapter, we are going to learn how to design and model our software
    using diagrams for better communication. When developing software, if the software
    design is not clearly communicated to the developers, there is a high likelihood
    that the software will not serve the purpose it was built for. Consequently, understanding
    important models and diagrams is very important.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用图表来设计和建模我们的软件，以便更好地进行沟通。在开发软件时，如果软件设计没有清晰地传达给开发人员，那么软件很可能无法达到其建立的目的。因此，理解重要的模型和图表非常重要。
