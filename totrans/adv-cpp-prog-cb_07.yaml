- en: Debugging and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to properly test and debug your C++ applications.
    This is important because without good testing and debugging, it is highly likely
    that your C++ applications will contain hard-to-detect bugs that will reduce their
    overall reliability, stability, and security.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will start with a comprehensive overview of unit testing, which
    is the act of testing code at the unit level, and will also look at how to leverage
    existing libraries to speed up the process of writing tests. Next, it will demonstrate
    how to use the ASAN and UBSAN dynamic analysis tools to check for memory corruption
    and undefined behavior. Lastly, the chapter will conclude with a quick look at
    how to leverage the `NDEBUG` macro in your own code for adding debug logic when
    attempting to resolve issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips with unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ASAN, the address sanitizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with UBSAN, the undefined behavior sanitizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `#ifndef NDEBUG` to conditionally execute additional checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, you must have installed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Code files for the chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter07](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips with unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to unit test our C++ code. There are several
    different ways to ensure that your C++ code executes with reliability, stability,
    security, and to specification.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing, which is the act of testing your code at the fundamental unit
    level, is a key component of any testing strategy. This recipe is important not
    only because it will teach you how to unit test your code, but because it will
    also explain why unit testing is so critical, as well as how to speed up the process
    of unit testing your C++ using existing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps to work through the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply writing your C++ application and hoping it works as expected without
    any testing is guaranteed to result in reliability-, stability-, and security-related
    bugs. This recipe is important because testing your applications prior to release
    ensures that your applications execute as expected, ultimately saving you time
    and money in the future.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different ways to test your code, including system-level,
    integration, long-term stability, and static and dynamic analysis, among others.
    In this recipe, we will focus on **unit testing**. Unit testing breaks an application
    up into functional **units **and tests each unit to ensure that it executes as
    expected. Typically, in practice, each function and object (that is, class) is
    a unit that should be tested independently.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different theories as to how unit testing should be performed,
    with entire books written on the subject. Some believe that every line of code
    within a function or object should be tested, leveraging coverage tools to ensure
    compliance, while others believe that unit testing should be requirement-driven,
    using a black-box approach. A common development process called **test-driven
    development** states that all tests, including unit tests, should be written before
    any source code is written, whereas **behavioral-driven development** takes test-driven
    development a step further with a specific, story-driven approach to unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Every testing model has its pros and cons, and which method you choose will
    be based on the type of application you are writing, the type of software development
    process you adhere to, and any policies you may or may not be required to follow.
    Regardless of this choice, unit testing will likely be a part of your testing
    scheme, and this recipe will provide the foundation for how to unit test your
    C++ applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although unit testing can be done with standard C++ (for example, this is how
    `libc++` is unit tested), unit-test libraries help to simplify this process. In
    this recipe, we will leverage the `Catch2` unit-test library, which can be found
    at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/catchorg/Catch2.git](https://github.com/catchorg/Catch2.git).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we will be reviewing Catch2, the principles that are being discussed
    apply to most of the unit-test libraries that are available, or even standard
    C++, if you choose not to use a helper library. To leverage Catch2, simply execute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can also use CMake's `ExternalProject_Add`, as we did in our examples on
    GitHub to leverage a local copy of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out how to use Catch2, let''s look at the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is run, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82b7302a-7165-4cf8-92f1-83a6491e786f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we start by defining `CATCH_CONFIG_MAIN`. This tells
    the Catch2 library that we want it to create the `main()` function for us. This
    must be defined before we include the Catch2 `include` statement, which we did
    in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to define a test case. Each unit is broken up into test cases
    that test the unit in question. The granularity of each test case is up to you:
    some choose to have a single test case for each unit being tested, while others,
    for example, choose to have a test case for each function being tested. The `TEST_CASE()`
    takes a string that allows you to provide a description of the test case, which
    is helpful when a test fails as Catch2 will output this string to help you identify
    where in your test code the failure occurred. The last step in our simple example
    is to use the `CHECK()` macro. This macro performs a specific test. Each `TEST_CASE()`
    will likely have several `CHECK()` macros designed to provide the unit with a
    specific input and then validate the resulting output.'
  prefs: []
  type: TYPE_NORMAL
- en: Once compiled and executed, the unit-test library will provide some output text
    describing how to execute tests. In this case, the library states that all of
    the tests passed, which is the desired outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how to leverage unit testing in your own code, let''s
    look at the following, more complicated example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Like the previous example, we include Catch2 with the `CATCH_CONFIG_MAIN` macro
    and then define a single test case with a description. In this example, we are
    testing the ability to sort a vector, so this is the description we provide. The
    first thing we do in our test is to create a vector of integers with a predefined
    list of integers.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we do is use the `REQUIRE()` macro to test, making sure that
    the vector has `6` elements in the vector. The `REQUIRE()` macro is similar to
    the `CHECK()` as both check to make sure that the statement inside the macro is
    true. The difference is that the `CHECK()` macro will report an error and then
    continue execution while the `REQUIRE()` macro will stop the execution, halting
    the unit test. This is useful to ensure that the unit test is properly constructed
    based on any assumptions that the test might be making. The use of `REQUIRE()`
    is important as unit tests mature over time, and other programmers add to and
    modify the unit tests, ensuring that bugs are not introduced into the unit tests
    over time, as there is nothing worse than having to test and debug your unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The `SECTION()` macro is used to further break up our tests with better descriptions
    and provide the ability to add common setup code for each test. In the preceding
    example, we are testing the `sort()` function for a vector. The `sort()` function
    can sort in different directions, which this unit test must validate. Without
    the `SECTION()` macro, if a test failed, it would be difficult to know whether
    the failure was from sorting in ascending or descending order. Furthermore, the
    `SECTION()` macro ensures that each test doesn't affect the results of other tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use the `CHECK()` macro to ensure that the `sort()` function worked
    as expected. Unit tests should check for exceptions as well. In the following
    example, we will ensure that exceptions are thrown properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous example, we define the `CATCH_CONFIG_MAIN` macro, add the
    includes that we require, and define a single `TEST_CASE()`. We also define a
    `foo()` function that is thrown if the input to the `foo()` function is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: In our test case, we first test the `foo()` function with a valid input. Since
    the `foo()` function doesn't have an output (that is, the function returns `void`),
    we check to ensure that the function has executed properly by ensuring that no
    exception has been thrown using the `CHECK_NOTHROW()` macro. It should be noted
    that, like the `CHECK()` macro, the `CHECK_NOTHROW()` macro has the equivalent
    `REQUIRE_NOTHROW()`, which will halt the execution if the check fails.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we ensure that the `foo()` function throws an exception when its input
    is invalid. There are several different ways to do this. The `CHECK_THROWS()`
    macro simply ensures that an exception has been thrown. The `CHECK_THROWS_AS()`
    macro ensures that not only has an exception been thrown, but that the exception
    is of the `std::runtime_error` type. Both must be true for the test to pass. Finally,
    the `CHECK_THROWS_WITH()` macro ensures that an exception has thrown and that
    the `what()` string returned what we expect from the exception matches. As with
    the other version of `CHECK()` macros, there are also `REQUIRE()` versions of
    each of these macros.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Catch2 library provides macros that let you dive into the specific
    details of each exception type, it should be noted that the generic `CHECK_THROWS()`
    macro should be used unless the exception type and string are specifically defined
    in your API requirements—for example, the `at()` function is defined by the specification
    to always return an `std::out_of_range` exception when the index is invalid. In
    this case, the `CHECK_THROWS_AS()` macro should be used to ensure that the `at()`
    function matches the specification. The string that this exception returns is
    not specified as part of the specification, and therefore, the `CHECK_THROWS_WITH()`
    should be avoided. This is important, as a common mistake when writing unit tests
    is to write unit tests that are over-specified. Over-specified unit tests must
    often be updated when the code under test is updated, which is not only costly,
    but prone to error.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should be detailed enough to ensure that the unit executes as expected
    but generic enough to ensure that modifications to the source code do not require
    updates to the unit tests themselves, unless the API's requirements change, resulting
    in a set of unit tests that age well while still providing the necessary tests
    for ensuring reliability, stability, security, and even compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a set of unit tests to validate that each unit executes as expected,
    the next step is to ensure that the unit tests are executed whenever the code
    is modified. This can be done manually or it can be done automatically by a **continuous
    integration** (**CI**) server, such as TravisCI; however, when you decide to do
    this, ensure that the unit test returns the proper error code. In the previous
    examples, the unit test itself exited with `EXIT_SUCCESS` when the unit tests
    passed and printed a simple string stating that all of the tests passed. For most
    CIs, this is enough, but in some cases it might be useful to have Catch2 output
    the results in a format that can be easily parsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do this, then we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/181d1cbf-5814-44ae-8f95-b7577da6c8e5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we created a simple test case (the same as our first
    example in this recipe), and instructed Catch2 to output the results of the test
    to XML using the `-r xml` option. Catch2 has several different output formats,
    including XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to output formats, Catch2 can also be used to benchmark our code.
    For example, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create a simple test case that sorts a vector
    with predefined vector numbers. We then sort this list inside a `BENCHMARK()`
    macro, which results in the following output when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ba0ee12-7624-4e52-897e-5182f5487f0e.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, Catch2 executed the function several times,
    taking on average `197` nanoseconds to sort the vector. The `BENCHMARK()` macro
    is useful to ensure that the code not only executes as expected with the proper
    outputs given specific inputs, but also that the code executes given a specific
    amount of time. Paired with a more detailed output format, such as XML or JSON,
    this type of information can be used to ensure that as the source code is modified,
    the resulting code executes in the same amount of time or faster.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how unit testing can truly improve your C++, we will conclude
    this recipe with two additional examples designed to provide more realistic scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, we will create a **vector**. Unlike an `std::vector`,
    which in C++ is a dynamic, C-style array, a vector in mathematics is a point in
    *n*-dimensional space (in our example, we limit this to 2D space), with a magnitude
    that is the distance between the point and the origin (that is, 0,0). We implement
    this vector in our example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do (besides the usual macros and includes) is to define
    a class with `x` and `y` coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add some helper functions and constructors. The default constructor
    makes a vector with no direction or magnitude as *x* and *y* are set to the origin.
    In order to create vectors that have a direction and magnitude, we also provide
    another constructor that allows you to provide the vector''s initial *x* and *y*
    coordinates. To get the vector''s direction, we provide getters that return the
    vector''s *x* and *y* values. Finally, we provide two helper functions. The first
    helper function **translates **the vector, which in mathematics is another term
    for changing a vector''s *x* and *y* coordinates given another vector. The final
    helper function returns the vector''s magnitude, which is the length of the vector''s
    hypotenuse if the vector''s *x* and *y* values were used to construct a triangle
    (that is, we must use Pythagoras''s theorem to calculate a vector''s magnitude).
    Next, we move on to adding operators, which we do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We add some equivalence operators, which can be used to check whether two vectors
    are equal. We also define a vector that represents the origin, which is a vector
    whose *x* and *y* values are 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this vector, we add the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first test ensures that a default constructed vector is in fact the origin.
    Our next test ensures that our global **origin **vector is the origin. This is
    important because we should not assume that the origin is constructed by default—that
    is, it is possible for someone in the future to accidentally change the origin
    to something other than `0,0`. This test case ensures that the origin is in fact
    `0,0`, so that in the future, if someone accidentally changes this, this test
    will fail. Since the origin must result in *x* and *y* both being 0, this test
    is not over-specified.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we test both the translate and magnitude functions. In the magnitude test
    case, we use the `Approx()` macro. This is needed because the magnitude that is
    returned is a floating point, whose size and precision depend on the hardware,
    and is irrelevant to our test. The `Approx()` macro allows us to state the level
    of precision to which we want to validate the result of the `magnitude()` function,
    which uses the `epsilon()` modifier to actually state the precision. In this case,
    we only wish to validate to one decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: The last test case is used to demonstrate how all inputs to these functions
    should be tested. If a function takes an integer, then valid, invalid, and extreme
    inputs should all be tested. In this case, we are passing `INT_MAX` for both *x*
    and *y*. The resulting `magnitude()` function does not provide a valid result.
    This is because the process of calculating the magnitude overflows the integer
    type. This type of error should either be accounted for in the code (that is,
    you should check for possible overflows and throw an exception) or the API's specification
    should call out these types of issues (that is, the C++ specification would likely
    state that the result of this type of input is undefined). Either way, if a function
    takes an integer, then all possible integer values should be tested, and this
    process should be repeated for all input types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of this test are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64400718-2c26-405a-9f0f-f9581dec0119.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, the unit fails the last test. As stated
    previously, to fix this issue, the magnitude function should be changed to either
    throw when an overflow occurs, find a way to prevent the overflow, or remove the
    test and state that such input is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: In our final example, we will demonstrate how to handle functions that do not
    return a value, but instead, manipulate an input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start this example by creating a class that writes to a file and another
    class that uses the first class to write a string to said file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the first class writes to a file called `test.txt`,
    while the second class takes the first class as an input and uses it to write
    a string to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We test the second class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the preceding test is that we do not have any `CHECK()` macros.
    This is because, other than `CHECK_NOTHROW()`, we have nothing to check. In this
    test, we are testing to make sure that the `the_answer{}` class calls `file{}`
    classes and the `write()` function properly. We could open the `test.txt` file
    and check to make sure that it was written with the right string, but this is
    a lot of work. This type of check would also be over-specifying as we are not
    testing the `file{}` class—we are only testing the `the_answer{}` class. If in
    the future we decide that the `file{}` class should write to a network file and
    not a file on disk, the unit test would have to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this issue, we can leverage a concept called **mocking**. A `Mock` class
    is a class that pretends to be the class that is inputted, providing the unit
    test with **seams **that allow the unit test to verify the result of a test. This
    is different from a `Stub`, which provides fake input. Sadly, C++ does not have
    good support for mocking when compared to other languages. Helper libraries, such
    as GoogleMock, attempt to fix this issue at the expense of requiring all of your
    mockable classes to contain a vTable (that is, inheriting pure virtual base classes)
    and define each mockable class twice (once in your code and a second time in your
    test, using a set of APIs defined by Google). This is far from optimal. Libraries
    such as Hippomocks attempt to address these issues at the expense of some vTable
    black magic that only works in certain environments and is nearly impossible to
    debug when things go wrong. Although Hippomocks is likely one of the best options
    (that is, until C++ enables native mocking), the following example is another
    method for mocking using standard C++, with its only downside being verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As with our previous example, we create two classes. The first class writes
    to a file while the second class uses the first class to write a string to said
    file. The difference is that we added the `VIRTUAL` macro. When the code is compiled
    into our application, `VIRTUAL` is set to nothing, meaning that it is removed
    from the code by the compiler. When the code is compiled in our test, however,
    it is set to `virtual`, which tells the compiler to give the class a vTable. Since
    this is only done during our tests, the added overhead is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our class supports inheritance in our test case, we can create a subclassed
    version of our `file{}` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class defines our mock. Instead of writing to a file, our mock
    checks to see whether a specific string is written to our fake file and sets a
    global variable to `true` or `false`, depending on the results of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then test our `the_answer{}` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is executed, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/289a2554-23b1-4e41-9c45-6bc8b34eb163.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we can now check to make sure that our
    class writes to the file as expected. It should be noted that we use the `REQUIRE()`
    macro to ensure that the mock is in the `false` state prior to executing our test.
    This ensures that if our actual test registered as having passed, that it actually
    has passed, instead of registering as a pass because of a bug in our test logic.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ASAN, the address sanitizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to leverage Google's **address sanitizer**
    (**ASAN**)—which is a dynamic analysis tool—to check for memory corruption errors
    in our code. This recipe is important because it provides a simple means to ensure
    that your code is both reliable and stable, with a minimal number of changes to
    your build system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps to follow the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will go through each of these examples and explain what
    each example program does and how it relates to the lessons that are being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google''s address sanitizer is a set of modifications to the GCC and LLVM compilers,
    as well as a set of libraries that must be linked into your application when testing.
    To accomplish this, we must add the following compiler flags when compiling code
    for testing (but do not add these flags to production releases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The most important flag to pay attention to here is the `-fsanitize=address` flag,
    which tells the compiler to enable ASAN. The rest of the flags are required by
    the sanitizer to function properly, with the most notable flags being `-g` and
    `-01`. The `-g` flag enables debugging and the `-O1` flag sets the optimization
    level to 1 to provide some performance improvements. Note that once the ASAN tool
    is enabled, the compiler will automatically attempt to link to the ASAN libraries,
    which must be present on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how this sanitizer works, let's look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leak error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AddressSanitizer` is a dynamic analysis tool that is designed to identify
    memory corruption errors. It is similar to Valgrind, but is built directly into
    your executable. The easiest example to demonstrate this with (and sadly one of
    the most common types of errors) is a memory leak, which is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cdecfde-c17e-47ba-b109-8dd637af2a5d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we allocate an integer in our program using the `new`
    operator, but we will never free this allocated memory prior to exiting the program.
    The ASAN tool is capable of detecting this issue and outputs an error when the
    application completes its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Memory deleted twice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability to detect memory leaks is extremely helpful, but it is not the
    only type of error that can be detected by ASAN. Another common type of error
    is deleting memory twice. For example, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01d887f8-4fcc-4efc-8691-67831ec8b13a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we allocate an integer using the `new` operator and
    then `delete` the integer using the delete operator. Since the pointer to the
    previously allocated memory is still in our `p` variable, we can delete it again,
    which we do before we exit the program. On some systems, this would generate a
    segmentation fault as it is undefined behavior. The ASAN tool is capable of detecting
    this issue and outputs an error message stating that a `double-free` error has
    occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing invalid memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another type of error is attempting to access memory that was never allocated.
    This is usually caused by the code attempting to dereference a null pointer, but
    it could also occur when a pointer is corrupt, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebd30496-bc91-49e1-b20c-1e5f580db297.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we create a pointer to an integer and then provide
    it with a corrupt value of `42` (which is not a valid pointer). We then attempt
    to dereference the corrupt pointer, which results in a segmentation fault. It
    should be noted that the ASAN tool is capable of detecting this issue, but it
    is not capable of providing any useful information. This is because the ASAN tool
    is a library that hooks into memory allocation routines, keeping track of each
    allocation and how the allocations are used. If an allocation never occurs, it
    will not have any information about what happened above and beyond what a typical
    Unix signal handler could already provide, something that other dynamic analysis
    tools, such as Valgrind, are better suited to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Using memory after deleting it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To further demonstrate how the address sanitizer works, let''s look at the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c01185c7-a10c-4464-be43-c60816cfcd63.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example allocates an integer and then deletes the integer. We
    then attempt to use the previously deleted memory. Since this memory location
    was originally allocated, ASAN has the address cached. When the dereference to
    the previously deleted memory occurs, ASAN is capable of detecting the issue as
    a `heap-use-after-free` error. It is only capable of detecting this issue because
    the memory was previously allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting memory that was never allocated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a final example, let''s look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed7e5106-c3d4-478f-8085-45a6ed4f62fb.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we create an integer to a pointer and then provide
    it with a corrupt value again. Unlike our previous example, in this example, we
    attempt to delete the corrupt pointer, which results in a segmentation fault.
    Once again, ASAN is able to detect this issue, but doesn't have any useful information
    as an allocation never occurred.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the C++ Core Guidelines—which is a coding standard for
    modern C++—are incredibly helpful at preventing the types of issues that we previously
    described. Specifically, the Core Guidelines state that `new()`, `delete()`, `malloc()`,
    `free()`, and friends should never be used directly, but instead, `std::unique_ptr`
    and `std::shared_ptr` should be used for *all memory allocations*. These APIs
    allocate and free memory for you, automatically. If we look at the previous examples
    again, it is easy to see how using these APIs to allocate memory instead of using
    `new()` and `delete()` manually can prevent these types of issues from occurring
    as most of the preceding examples were all related to the invalid use of `new()`
    and `delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with UBSAN, the undefined behavior sanitizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the UBSAN dynamic analysis tool with
    our C++ applications, which is capable of detecting undefined behavior. There
    are many different types of errors that can be introduced in our applications,
    and undefined behavior is likely the most common type, as the C and C++ specifications
    define several instances where undefined behavior is possible.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is important because it will teach you how to enable this simple
    feature and how it can be used in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps to work through the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will go through each of these examples and explain what
    each example program does and how it relates to the lessons being taught in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UBSAN tool is capable of detecting several types of undefined behavior,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-bounds errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Division by zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer overflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null-pointer dereferencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed-/unsigned-conversion errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreachable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at a couple of these examples, but to start, we
    must first enable the UBSAN tool in our application. To do this, we must enable
    the following flag in our application''s build system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This flag will tell GCC or LLVM to use the UBSAN tool, which adds additional
    logic to our application as well as links to a UBSAN library. It should be noted
    that the UBSAN tool grows in its capability over time. For this reason, both GCC
    and LLVM have different levels of support for UBSAN. To get the most out of this
    tool, your application should be compiled against both GCC and LLVM, and you should
    use the most up-to-date compiler possible for both of these.
  prefs: []
  type: TYPE_NORMAL
- en: Divide-by-zero errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the easiest examples to demonstrate with UBSAN is the divide-by-zero
    error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is run, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/698ed489-e92b-4080-a0dc-fb224466ddf7.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we create two integers (a numerator and a denominator)
    with the denominator set to `0`. We then divide the numerator and the denominator
    resulting in a divide-by-zero error, which UBSAN detects and outputs as the program
    crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Null-pointer dereferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more common type of problem in C++ is a null-pointer dereference, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61d56d5b-161b-470f-8181-68dafa5ab7ab.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we create a pointer to an integer and set it to `0`
    (that is, a `NULL` pointer). We then dereference the `NULL` pointer and set its
    value, resulting in a segmentation fault, which UBSAN is capable of detecting
    as the program crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-bounds errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both of the preceding examples could have been detected using a Unix signal
    handler. In the next example, we will access an array out of bounds, which is
    undefined in the C++ specification and is a lot more difficult to detect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19eaa37d-90b8-4910-bc6a-bc96ec98f7dd.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, we create an array with `6` elements and
    then attempt to access the 10th element in the array, which doesn't exist. Attempting
    to access this element in the array is not guaranteed to generate a segmentation
    fault. Regardless, UBSAN is capable of detecting this type of error and outputs
    the issue to `stderr` on exiting.
  prefs: []
  type: TYPE_NORMAL
- en: Overflow errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we can also detect signed integer overflow errors, which are undefined in
    C++, but highly unlikely to generate a crash, and instead will cause the program
    to enter a corrupt state (often producing endless loops, out-of-bounds errors,
    and so on). Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0db50c0b-0249-4600-9a72-c62b3fc591b0.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, we create an integer and set it to its maximum
    value. We then attempt to increase this integer, which would normally flip the
    integer's sign, an error that UBSAN is capable of detecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using #ifndef NDEBUG to conditionally execute additional checks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to leverage the `NDEBUG` macro, which stands
    for *no debug*. This recipe is important because most build systems automatically
    define this macro when a *release* or *production* build is compiled, which can
    be leveraged to disable debug logic when such a build is created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including the installation of Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through the following steps to work through the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NDEBUG` macro originates from C and was used to change the behavior of
    the `assert()` function. The `assert()` function can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, if the `__assert()` function is given a Boolean
    that evaluates to `false` (written in C, this is an integer that is equal to `0`),
    an error message is outputted to `stderr` and the application is aborted. The
    `NDEBUG` macro is then used to determine whether the `assert()` function exists,
    and if the application is in release mode, then all of the assert logic is removed,
    reducing the size of the application. When using CMake, we can enable the `NDEBUG`
    flag using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will automatically define the `NDEBUG` macro and enable optimizations.
    To prevent this macro from being defined, we can do the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding CMake code will *not* define the `NDEBUG` macro, and instead will
    enable debugging, as well as disable most optimizations (although this depends
    on the compiler).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our own code, the `assert` macro can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/285a3fe5-641d-4c56-8521-9fe0e4ffbceb.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, we create an application that uses the `assert()`
    macro to check a false statement, which results in the application aborting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `NDEBUG` macro is used by the `assert()` function, you can also
    use it yourself as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, if the application is not compiled in *release* mode
    (that is, if the `NDEBUG` macro is not defined on the command line when compiling),
    then the application will output to `stdout`. This same logic can be used throughout
    your code to create your own debug macros and functions to ensure that your debug
    logic is removed in *release* mode, allowing you to add as much debug logic as
    you need without modifying the resulting application that you deliver to your
    customers.
  prefs: []
  type: TYPE_NORMAL
