- en: Chapter 3. Working with Images and Videos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cropping an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying and pasting sections of the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting image data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to pixel manipulation: inverting image colors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverting video colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting image colors to grayscale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a canvas drawing into a data URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving a canvas drawing as an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the canvas with a data URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pixelated image focus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on yet another very exciting topic of the HTML5 canvas,
    images and videos. Along with providing basic functionality for positioning, sizing,
    and cropping images and videos, the HTML5 canvas API also allows us to access
    and modify the color and transparency of each pixel for both mediums. Let's get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump right in by drawing a simple image. In this recipe, we'll learn how
    to load an image and draw it somewhere on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing an image](img/1369_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow these steps to draw an image in the center of the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the canvas context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `image` object, set the `onload` property to a function that draws
    the image, and then set the source of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw an image, we first need to create an `image` object using new `Image()`.
    Notice that we've set the `onload` property of the `image` object *before* defining
    the source of the image.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's good practice to define what we want to do with the image when it loads
    *before* setting its source. Theoretically, if we were to define the source of
    the image before we define the `onload` property; the image could possibly load
    before the definition is complete (although, it's very unlikely).
  prefs: []
  type: TYPE_NORMAL
- en: 'The key method in this recipe is the `drawImage()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Where `imageObj` is the `image` object, and `destX` and `destY` is where we
    want to position the image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to defining an image position with `destX` and `destY`, we can
    also add two additional parameters, `destWidth` and `destHeight` to define the
    size of our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the most part, it's a good idea to stay away from resizing an image with
    the `drawImage()` method, simply because the quality of the scaled image will
    be noticeably reduced, similar to the result when we resize an image with the
    width and height properties of an HTML image element. If image quality is something
    you're concerned about (why on earth wouldn't you be?), it's usually best to work
    with thumbnail images alongside bigger images if you're creating an application
    that needs scaled images. If, on the other hand, your application dynamically
    shrinks and expands images, using the `drawImage()` method with `destWidth` and
    `destHeight` to scale images is a perfectly acceptable approach.
  prefs: []
  type: TYPE_NORMAL
- en: Cropping an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll crop out a section of an image and then draw the result
    onto the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cropping an image](img/1369_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Follow these steps to crop out a section of an image and draw the result onto
    the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the canvas context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an image object, set the `onload` property to a function that crops
    the image, and then set the source of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the last recipe, we discussed two different ways that we can use the `drawImage()`
    method to draw images on the canvas. In the first case, we can pass an `image`
    object and a position to simply draw an image at the given position. In the second
    case, we can pass an `image` object, a position, and a size to draw an image at
    the given position with the given size. Additionally, we can also add six more
    parameters to the `drawImage()` method if we wanted to crop an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![imagecropping, stepsHow it works...](img/1369_03_02a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `sourceX` and `sourceY` refer to the top-left corner of the
    cropped region in the source image. `sourceWidth` and `sourceHeight` refer to
    the width and height of the cropped image from the source. `destX` and `destY`
    refer to the position of the cropped image on the canvas, and `destWidth` and
    `destHeight` refer to the width and height of the resulting cropped image.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't intend to scale a cropped image, then `destWidth` equals `sourceWidth`
    and `destHeight` equals `sourceHeight`.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and pasting sections of the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll cover yet another interesting usage of the `drawImage()`
    method—copying sections of the canvas. First, we'll draw a spade in the center
    of the canvas, then we'll copy the right side of the spade and then paste it to
    the left, and then we'll copy the left side of the spade and then paste it to
    the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Copying and pasting sections of the canvas](img/1369_03_02b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow these steps to draw a spade in the center of the canvas and then copy-and-paste
    sections of the shape back onto the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the canvas context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw a spade in the center of the canvas using the `drawSpade()` function that
    we created in [Chapter 2](ch02.html "Chapter 2. Shape Drawing and Composites"),
    *Shape Drawing and Composites*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the right half of the spade and then paste it on the canvas to the left
    of the spade using the `drawImage()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the left half of the spade and then paste it on the canvas to the right
    of the spade using the `drawImage()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To copy a section of the canvas, we can pass the `canvas` object to the `drawImage()`
    method instead of an `image` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we'll see in the next recipe, not only can we copy sections of an image or
    a canvas with `drawImage()`, we can also copy sections of HTML5 video.
  prefs: []
  type: TYPE_NORMAL
- en: Working with video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the HTML5 canvas API doesn't provide a direct method for drawing videos
    on the canvas like it does for images, we can certainly work with videos by capturing
    frames from a hidden video tag and then copying them onto the canvas with a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with video](img/1369_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started, let's talk about the supported HTML5 video formats for
    each browser. At the time of writing, the video format war continues to rage on,
    in which all of the major browsers—Chrome, Firefox, Opera, Safari, and IE—continue
    to drop and add support for different video formats. To make things worse, each
    time a major browser adds or drops support for a particular video format, developers
    have to once again re-formulate the minimal set of video formats that's required
    for their applications to work across all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the three major video formats are Ogg Theora, H.264,
    and WebM. For the video recipes in this chapter, we'll be using a combination
    of Ogg Theora and H.264\. When working with video, it's strongly advised that
    you do a search online to see what the current status is for video support as
    it is a subject to change at any moment.
  prefs: []
  type: TYPE_NORMAL
- en: There's more! Once you've decided which video formats to support, you'll probably
    need a video format converter to convert the video file that you have on hand
    to other video formats. One great option for converting video formats is the Miro
    Video Converter, which supports video format conversions for just about any video
    format including Ogg Theora, H.264, or WebM formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Miro Video Converter is probably the most common video converter available
    at the time of writing, although you can certainly use any other video format
    converter of your liking. You can download Miro Video Converter from: [http://www.mirovideoconverter.com/](http://www.mirovideoconverter.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to draw a video onto the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a cross-browser method that requests an animation frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawFrame()` function which copies the current video frame, pastes
    it onto the canvas using the `drawImage()` method, and then requests a new animation
    frame to draw the next frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the canvas context, get the video tag, and draw the first video frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas and the video tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw a video on an HTML5 canvas, we first need to embed a hidden video tag
    in the HTML document. In this recipe, and in future video recipes, I've used the
    Ogg Theora and H.264 (mp4) video formats.
  prefs: []
  type: TYPE_NORMAL
- en: Next, when the page loads, we can use our cross-browser `requestAnimFrame()`
    method to capture the video frames as fast as the browser will allow and then
    draw them onto the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Getting image data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to draw images and videos, let's try accessing the image
    data to see what kind of properties we can play with.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting image data](img/1369_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WARNING: This recipe must run on a web server due to security constraints with
    the `getImageData()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started working with image data, it's important that we cover
    canvas security and the RGBA color space.
  prefs: []
  type: TYPE_NORMAL
- en: So why is canvas security important with respect to accessing image data? Simply
    put, in order to access image data, we need to use the `getImateData()` method
    of the canvas context which will throw a `SECURITY_ERR` exception if we try accessing
    image data from an image residing on a non-web server file system, or if we try
    accessing image data from an image on a different domain. In other words, if you're
    going to try out these demos for yourself, they won't work if your files reside
    on your local file system. You'll need to run the rest of the recipes in this
    chapter on a web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, since pixel manipulation is all about altering the RGB values of pixels,
    we should probably cover the RGB color model and the RGBA color space while we''re
    at it. RGB represents the red, green, and blue components of a pixel''s color.
    Each component is an integer between 0 and 255, where 0 represents no color and
    255 represents full color. RGB values are often times represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some common color values represented with the RGB color model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In addition to RGB, pixels can also have an alpha channel which refers to its
    opacity. An alpha channel of 0 is a fully transparent pixel, and an alpha channel
    of 255 is a fully opaque pixel. RGBA color space simply refers to the RGB color
    model (RGB) plus the alpha channel (A).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful not to confuse the alpha channel range of HTML5 canvas pixels, which
    are integers 0 to 255, and the alpha channel range of CSS colors, which are decimals
    0.0 to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to write out the image data properties of an image:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a canvas context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `image` object, set the `onload` property to a function which draws
    the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the image data, write out its properties, and then set the source of the
    `image` object outside of the `onload` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag into the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea behind this recipe is to draw an image, get its image data, and then
    write out the image data properties to the screen. As you can see from the preceding
    code, we can get the image data using the `getImageData()` method of the canvas
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `getImageData()` method only works with the canvas context and
    not the `image` object itself. As a result, in order to get image data, we must
    first draw an image onto the canvas and then use `getImageData()` method of the
    canvas context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ImageData` object contains three properties: `width`, `height`, and `data`.
    As you can see from the screenshot in the beginning of this recipe, our `ImageData`
    object contains a `width` property of 300, a `height` property of 214, and a `data`
    property which is an array of pixel information, which in this case has a length
    of 256,800 elements. The key to the `ImageData` object, in all honesty, is the
    `data` property. The `data` property contains the RGBA information for each pixel
    in our image. Since our image is made up of 300 * 214 = 64,200 pixels, the length
    of this array is 4 * 64,200 = 256,800 elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduction to pixel manipulation: inverting image colors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to access image data, including the RGBA for every pixel
    in an image or video, our next step is to explore the possibilities of pixel manipulation.
    In this recipe, we'll invert the colors of an image by inverting the color of
    each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to pixel manipulation: inverting image colors](img/1369_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WARNING: This recipe must be run on a web server due to security constraints
    with the `getImageData()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to invert the colors of an image:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the canvas context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `image` object and set the `onload` property to a function that draws
    the image and gets the image data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop through all of the pixels in the image and invert the colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Overwrite the original image with the manipulated image, and then set the source
    of the image outside of the `onload` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag into the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To invert the color of an image using HTML5 canvas, we can simply loop through
    all of the pixels in an image and then invert each pixel using a color inverting
    algorithm. Don''t worry it''s easier than it sounds. To invert a pixel''s color,
    we can invert each of its RGB components by subtracting each value from 255 as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the pixels have been updated, we can redraw the image using the `putImageData()`
    method of the canvas context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method basically allows us to draw an image using image data instead of
    a source image with the `drawImage()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting video colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this recipe is to demonstrate how to perform pixel manipulations
    on videos in much the same way as we did with images. In this recipe, we'll invert
    the colors of a short video clip.
  prefs: []
  type: TYPE_NORMAL
- en: '![drawImage() methodIpixel manipulationworkingnverting video colors](img/1369_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WARNING: This recipe must be run on a web server due to security constraints
    with the `getImageData()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to invert the colors of a video:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a cross-browser method that requests an animation frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `drawFrame()` function that captures the current video frame, inverts
    the colors, draws the frame on the canvas, and then requests a new animation frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the canvas context, get the video tag, and draw the first animation
    frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the video and canvas element into the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similarly to the previous recipe, we can perform pixel manipulations on video
    in much the same way that we did with images because the `getImageData()` method
    gets the image data from the canvas context regardless of how the context was
    rendered. In this recipe, we can simply invert the color of each pixel on the
    canvas for each video frame provided by the `requestAnimFrame()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Converting image colors to grayscale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll explore another common pixel manipulation algorithm, converting
    colors to grayscale.
  prefs: []
  type: TYPE_NORMAL
- en: '![requestAnimFrame() methodConverting image colors to grayscale](img/1369_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WARNING: This recipe must be ran on a web server due to security constraints
    with the `getImageData()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to convert the colors of an image to grayscale:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the canvas context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `image` object and set the `onload` property to a function that draws
    the image and gets the image data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop through the pixels in the image and convert the colors to grayscale using
    the equation for brightness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Overwrite the original image with the manipulated image and then set the image
    source after the `onload` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas element inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert an RGB color into a gradation of gray, we need to obtain the brightness
    of the color. We can use the equation of brightness to obtain the grayscale value
    of a colored pixel. This equation is based on the fact that humans are most sensitive
    to green light, followed by red light, and are least sensitive to blue light:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Brightness = 0.34 * R + 0.5 * G + 0.16 * B`'
  prefs: []
  type: TYPE_NORMAL
- en: To account for physiological effects, notice that we've added more weight to
    the green value (most sensitive) followed by the red value (less sensitive) followed
    by the blue value (least sensitive).
  prefs: []
  type: TYPE_NORMAL
- en: With this equation in hand, we can simply loop through all of the pixels in
    our image, calculate the perceived brightness, assign this value to each of the
    RGB values, and then re-draw the image onto the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a canvas drawing into a data URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to image data, we can also extract an image data URL which is basically
    just a very long text string containing encoded information about the canvas image.
    Data URLs are extremely handy if we want to save the canvas drawing in local storage
    or in an offline database. In this recipe, we'll draw a cloud shape, get its data
    URL, and then insert it into the HTML page so that we can see what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to convert a canvas drawing into a data URL:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the canvas context and draw a cloud shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the data URL of the canvas using the `toDataURL()` method of the `canvas`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the (long) data URL into a `<p>` tag so that we can see it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document and create a `<p>`
    tag which will be used to store the data URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to this recipe is the `toDataURL()` method which converts a canvas
    drawing into a data URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this demo, you''ll see a very long data URL that looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: What you're looking at here is just a small snippet of the entire data URL.
    The important part to pay attention to in the URL is the very beginning, which
    starts with `data:image/png;base64`. This means that the data URL is a PNG image
    which is represented by a base 64 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike image data, which is a native array of pixel data, an image data URL
    is special because it's a string that can be stored with local storage, or it
    can be passed to a web server to be saved in an offline database. In other words,
    image data is useful for inspecting and manipulating each individual pixel that
    makes up an image, while image data URLs are intended to be used for storing the
    canvas drawing and to be passed between the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Saving a canvas drawing as an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to saving the canvas drawing in local storage or in an offline database,
    we can also use an image data URL to save the canvas drawing as an image so that
    a user can then save it to their local computer. In this recipe, we'll get the
    image data URL of the canvas drawing and then set it to the source of an `image`
    object so that a user can right click and download the image as a PNG.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to save a canvas drawing as an image:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the canvas context and draw a cloud shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the data URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the source of an image tag to the data URL so that a user can download
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag in the body of the HTML document and add an image tag
    which will contain the canvas drawing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After drawing something on the canvas, we can create an image that the user
    can save by getting the image data URL using the `toDataURL()` method, and then
    setting the source of an `image` object to the data URL. Once the image has loaded
    (which is nearly instantaneous because the image is being loaded directly and
    doesn't have to make a request to a web server), the user can right click on the
    image to save it to their local computer.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the canvas with a data URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To load the canvas with a data URL, we can extend the previous recipe by creating
    an `image` object with the data URL and then drawing it on the canvas using our
    good friend `drawImage()`. In this recipe, we'll make a simple Ajax call to get
    the data URL from a text file and then use the URL to draw the image on the canvas.
    In the real world of course, you'll probably be fetching the image data URL from
    local storage or by calling a data service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to load a canvas drawing with a data URL:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the `loadCanvas()` function which takes a data URL as input, defines
    a canvas context, creates a new image using the data URL, and then draws the image
    onto the canvas once it has loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Make an AJAX call to get a data URL stored on your server, and then call `loadCanvas()`
    with the response text when the response is received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag inside the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get the image data URL from a web server, we can set up an AJAX call (Asynchronous
    JavaScript and XML) to make a request to a web server and get the data URL as
    a response. When we get a status code of 200, which means that the request and
    response was successful, we can get the image data URL from `request.responseText`,
    and then pass it to the `loadCanvas()` function. This function will then create
    a new `image` object, set its source to the data URL, and then draw the image
    onto the canvas once it has loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pixelated image focus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking for a fancy way to focus an image? How about a pixelated image focus?
    In this recipe, we'll explore the art of image pixelation by looping through an
    algorithm that pixelates an image less and less until it's completely focused.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pixelated image focus](img/1369_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WARNING: This recipe must be run on a web server due to security constraints
    with the `getImageData()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a pixilation function that slowly focuses an image:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the `focusImage()` function which de-pixelates an image based on a pixilation
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the canvas context, fps value that determines how fast or slow the image
    focuses, the corresponding time interval, and the initial pixilation amount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `image` object, set the `onload` property to a function that creates
    a timed loop that calls the `focusImage()` function and decrements the pixilation
    value for each call until the image is focused, and then set the image source
    outside of the `onload` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Embed the canvas tag into the body of the HTML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before jumping into the pixelation algorithm, let's define pixelation. Pixelation
    of an image occurs when the human eye can detect the individual pixels that make
    up the image. Old school video game graphics and small images that have been enlarged
    are good examples of pixilation. In layman terms, if we define pixilation as a
    condition in which the pixels that make up the image are visible, this simply
    means that the pixels themselves are fairly large. In fact, the larger the pixels
    are, the more pixelated the image becomes. We can use this observation to create
    a pixilation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: To create an algorithm that pixelates an image, we can take color samples of
    the image and then draw oversized pixels in its place. As pixels need to be square,
    we can construct pixel sizes of 1 x 1 (standard pixel size), 2 x 2, 3 x 3, 4 x
    4, and so on. The larger the pixels are, the more pixelated the image will look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, our recipes have simply looped through all of the pixels in the
    `data` property and converted them with a simple algorithm, without paying much
    attention to which pixels are being updated. In this recipe, however, we''ll need
    to inspect sample pixels by looking at specific areas in the image based on x,y
    coordinates. We can use the following equations to pick out the RGBA components
    of a pixel based on the x, y coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: With these equations in hand, we can use `setInterval()` to render a series
    of pixelated images over time, in which each successive pixelated image is less
    pixelated than the previous image, until the pixilation value equals 0 and the
    image is restored to its original state.
  prefs: []
  type: TYPE_NORMAL
