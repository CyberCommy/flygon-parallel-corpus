- en: Building a Server from Scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will analyze a more advanced application of concurrent
    programming: building a working non-blocking server from scratch. We will cover
    complex uses of the `socket` module, such as isolating the user business logic
    from callbacks and writing the callback logic with inline generators, both instances
    designed to run concurrently. We will also discuss the use of the `await` and
    `yield` keywords, using an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a comprehensive API from the `socket` module to build a server from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic information on Python generators and asynchronous generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use inline generators with the `await` and `yield` keywords to convert
    a blocking server to a non-blocking one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have Python 3 installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that you have `telnet` installed on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this chapter, we will be working with the subfolder named `Chapter18`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2KrgWwh](http://bit.ly/2KrgWwh)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-level network programming via the socket module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using the `socket` module, which is a built-in library
    in Python, to build our working server. The `socket` module is one of the modules
    that are most frequently used to implement low-level communication protocols,
    while providing intuitive options to control those protocols. In this section,
    we will introduce the process of implementing the underlying low-level architecture
    of a server, as well as the key methods and functionalities of the module that
    will be used in our examples later on.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in order to successfully follow the examples in this chapter, you
    will need to install the telnet program on your system. Telnet is a program that
    provides terminal commands that facilitate protocols for bidirectional, interactive,
    text-based communication. We covered the installation of telnet in [Chapter 11](38f53fa5-cf84-4e0c-897a-bd42fb74e657.xhtml),* Building
    Communication Channels with asyncio*; if you do not already have Telnet installed
    on your system, simply navigate to (and follow the directions in) that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that macOS systems have a preinstalled alternative to Telnet, called Netcat.
    If you do not want Telnet installed on your macOS computer, simply use the command `nc` instead
    of `telnet` in the following examples, and you will achieve the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: The theory of server-side communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 11](38f53fa5-cf84-4e0c-897a-bd42fb74e657.xhtml), *Building Communication
    Channels with asyncio**,* you encountered brief examples of implementing asynchronous
    communication channels at a higher level, using the `aiohttp` module. In this
    section, we will dive deeper into the programming structure of a server-side communication
    channel, and how it can interact with its clients in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: In the field of network programming, a **socket** is defined as a theoretical
    endpoint within a node of a specific computer network. The socket is responsible
    for receiving or sending data from the node that it is in. The fact that the socket
    is unique to the node that owns it means that other nodes in the same computer
    network are theoretically unable to interact with the socket. In other words,
    the socket is only available to its corresponding node.
  prefs: []
  type: TYPE_NORMAL
- en: To open a communication channel from the server-side, a network programmer must
    first create a socket and bind it to a specific address. This address is typically
    a pair of values, containing information about the host and a port for the server.
    Then, through the socket, the server begins to listen to any potential communication
    request created by its clients in the network. Any request from a client to connect
    to the server will thus need to be through the created socket.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving a request to connect from a potential client, the server can
    decide whether to accept that request. A connection will then be established between
    the two systems in the network, which means that they can start to communicate
    and share data with each other. As the client sends a message to the server via
    the communication channel, the server then processes the message and eventually
    sends a response back to the client through the same channel; this process continues
    until the connection between them ends, either through one of them quitting the
    connection channel or through some external factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding is the basic process of creating a server and establishing connections
    with potential clients. There are multiple security measures implemented at each
    stage of the process, though they are not our concern and will not be discussed
    here. The following diagram also maps out the process that was just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce7cc28e-53e8-4f2d-bf59-3d8220b2b9c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Network programming with sockets
  prefs: []
  type: TYPE_NORMAL
- en: Note that in order to create a request to connect to the server, a potential
    client also has to initialize its own socket for the communication channel (as
    shown in the preceding diagram). Again, we are only interested in the server-side
    theory of this process, and thus, we are not discussing client-side elements here.
  prefs: []
  type: TYPE_NORMAL
- en: The API of the socket module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the key API provided by the `socket` module
    to achieve the same functionalities in the process described previously. As we
    have mentioned, the `socket` module comes built-in in any Python 3 distribution,
    so we can simply import the module into our program without having to run installation
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a socket, we will use the `socket.socket()` method, which returns
    a socket object. This object is what we will be working with during most of the
    process of implementing various communication protocols. Additionally, socket
    methods have the following methods that help us control the communication protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.bind()`: This method binds the calling socket to the address that is
    passed to the method. In our examples, we will be passing in a tuple containing
    the address of the host and the port for the communication channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.listen()`: This method allows the server that we create to accept connections
    from potential clients. Another optional positive-integer parameter can be passed
    to the method, to specify the number of allowed unaccepted connections before
    the server refuses new connections. We will be using `5` as an arbitrary number
    for this method in our later examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.accept()`: This method, as the name suggests, accepts a specific connection
    that the calling socket object has. This calling object has to first be bound
    to an address and listening for connections to call this method. In other words,
    this method is to be called after the two preceding methods. The method also returns
    a pair of values, `(conn, address)`, with `conn` being the new socket object that
    has accepted the connection and is able to send and receive data, and `address`
    being the address on the other end of the connection (the client address).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.makefile()`: This method returns a `file` object that is associated
    with the calling `socket` object. We will be using this method to create a file
    that contains the data sent from the accepted clients of our server. This `file`
    object will also need to be closed appropriately, using the `close()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.sendall()`: This method sends the data passed as a parameter to the
    calling `socket` object. We will use this method to send data back to the clients
    connected to our server. Note that this method takes in data in bytes, so we will
    be passing byte strings to this method in our examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.close()`: This method marks the calling `socket` object as closed.
    After this point, all operations applied on the `socket` object will fail. This
    is to be used when we terminate our server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple echo server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to truly understand the use of the methods and functions described
    previously is to see them in action in a sample program. In this section, we will
    build an echo server as our starting example. This server, as the term suggests,
    sends whatever it received from each client back to the client. Through this example,
    you will learn how to set up a functional server, as well as how to handle client
    connections and data from it, and we will build more complex servers in later
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into the code, however, let's discuss the structure of the program
    that will implement the communication logic for this server. First, we will have
    what is called the **reactor**, which sets up the server itself and provides the
    logic whenever a new connection is requested from potential clients. Specifically,
    once the server has been set up, this reactor will go through an infinite loop
    and handle all connection requests that the server receives.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have read the previous chapters on asynchronous programming, it is also
    possible to think of this reactor as an event loop. This event loop goes through
    all of the events that are to be processed (in this case, they are requests),
    and handles them one by one, using an event handler. The following diagram further
    illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0bee377e-3e65-4b5a-bc8e-acf4e81269b6.png)'
  prefs: []
  type: TYPE_IMG
- en: An event loop in network programming
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of our program, then, is the event handler in the event loop
    analogy, which contains the user business logic: how to process the data received
    from clients, and what to send back to each of them. For our current example,
    since it is an echo server, we are only sending back whatever each client sent
    to our server (if the data is valid).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that structure in mind, let''s move on to the actual implementation of
    this server. Download the code for this chapter from the GitHub page, then go
    ahead and navigate to the `Chapter18` folder. The script that we are interested
    in is in the `Chapter18/example1.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The program is structured in the same way that we discussed previously: a reactor
    and a user business logic handler (the `process_request()` function). First, the
    reactor sets up the server (by creating a socket, binding it to the parametric
    host and port address, and calling the `listen()` method). It then goes into an
    infinite loop and facilitates any potential connection with a client, first accepting
    the connection by calling the `accept()` method on the `socket` object, and then
    calling the `process_request()` function. The reactor is also responsible for
    closing the `socket` object if an error occurs during the preceding process.'
  prefs: []
  type: TYPE_NORMAL
- en: The `process_request()` function, on the other hand, will first create a `file`
    object associated with the socket that is passed to it. Again, this `file` object
    is used by our server to read data from its client that is connected via that
    specific socket. Specifically, after making the `file` object, the function will
    go into another infinite loop that keeps reading from the `file` object, using
    the `readline()` function. If the data read from the file is valid, we will send
    back the same data, using the `sendall()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We are also printing out what the server receives from each of its clients as
    the server output, by including the line `print(f'{cli_address} --> {line}')`.
    One more specification is that, if the data read from the file is equal to the
    string `quit`, then we will close the connection with that specific client. After
    a connection is closed, we will need to carefully handle the `socket` object itself,
    and the `file` object associated with it, using the `close()` method for both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at the end of our program, we simply call the `reactor()` function
    and pass it information about our server. In this case, we simply use the loopback
    interface of our server, at port `8080`. Now, we will execute the script to initialize
    our local server. Your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our server is up and running (as indicated in the output). Now,
    we would like to create some clients for this server. To do this, open another
    Terminal window and use the Telnet program to connect to the running server, by
    running `telnet localhost 8080`. Your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This output means that the Telnet client has successfully connected to the server
    that we created. Now, we can test whether the server can handle its requests the
    way that we intended it to. Specifically, enter some data and hit *return* or
    *Enter* to send it to the server, and you will see that the client will receive
    an echoed message from the server, in the way that we implemented in the preceding `process_request()`
    function. Again, a client can stop its connection to this server by sending the
    string `quit` to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows my output when entering a few different phrases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the output of our server, you can also see what was happening during
    this connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The server, as mentioned, is designed to run forever in the reactor as an event
    loop, which can be stopped by a `KeyboardInterrupt` exception.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully implemented our first echo server, using low-level methods
    provided by the `socket` module. In the next section, we will implement a more
    advanced functionality for our server and analyze the process of converting it
    to a non-blocking server that can handle multiple clients at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Building a calculator server with the socket module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionality that we are trying to implement is to have a simple request
    handler that calculates either the sum or the product of a list of integers, and
    that is included in the data sent from the clients. Specifically, if a client
    sends the string `1`, `2` ,`4` to our server, then the server should send back
    `7` if it is to calculate sums, or `8` if it is to calculate products.
  prefs: []
  type: TYPE_NORMAL
- en: Every server implements some form of data processing, in addition to handling
    requests coming in from clients and sending the results of that data processing
    task to those clients. This prototype will therefore serve as a first building
    block for more extensive servers, with further complex functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying calculation logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the `split()` method for Python strings to extract elements
    that are separated by a specific character in a string. Therefore, we will require
    all data coming from clients to be formatted this way (integers separated by commas),
    and, if a client sends in something that is not in this format, we will simply
    send back an error message and require them to make a new message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic calculation logic is included in the `Chapter18/example2.py` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, we are using the `split()` method, with the `','` argument, to extract
    out the individual numbers in a specific string. The `sum()` function is used
    to calculate, evidently, the sum of the parametric list of numbers. To calculate
    the aggregated product, we need to import the `mul()` method (for multiplication)
    from the `operator` module, as well as the `reduce()` method from the `functools`
    module, to apply the multiplication on each of the elements in the list of numbers
    under consideration.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, the third argument passed to the `reduce()` method (the number
    `1`) is the starting value for the reduction process. To learn more about reduction
    operations, read through [Chapter 7](57411004-b747-47de-9337-79f53d675a7d.xhtml), *Reduction
    Operators in **Processes,* if you have not done so already.
  prefs: []
  type: TYPE_NORMAL
- en: As for our actual server, we will also keep track of the **mode of calculation**.
    The mode of calculation, whose default is to execute summation, dictates whether
    the server should perform summation and multiplication on the input list of numbers.
    The mode is also unique to each client connection, and can be switched around
    by that client. Specifically, if the data sent by a specific client is the string
    `sum`, then we will switch the mode of calculation to summation, and the same
    goes for the string `product`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the calculator server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the full implementation of this server in the `Chapter18/example3.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The reactor component of our server remains the same as our previous example,
    since the event loop handles the same type of logic. In our user business logic
    part (the `process_request()` function), we are still using `file` objects returned
    from the `makefile()` method to obtain data sent by the clients of the server.
    If a client sends in the string `quit`, the connection between that client and
    the server will still be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first new thing in this program is the local variable `mode` in the `process_request()`
    function. This variable specifies the mode of calculation that we discussed earlier,
    and has the default value of the string `sum`. As you can see, at the very end
    of the `try` block in the `process_request()` function, this variable decides
    what kind of data is to be sent back to the current client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, if data sent from a client is equal to the string `sum`, then
    the `mode` variable will be set to `sum`, and the same applies for the string
    `product`. The client will also receive a message announcing that the mode of
    calculation has been changed. This logic is included in the following portion
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how this server performs in a real experiment. Execute
    the program to run the server, and you will see output similar to that of the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will be using Telnet to create clients for this server. As you are
    connected to the server through a Telnet client, try to enter some data to test
    out the server logic that we implemented. The following code shows what I obtained
    with various types of input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see that our server can handle the requests as we intended. Specifically,
    it can compute both the sum and the product of a given correctly formatted input
    string; it can appropriately switch the mode of calculation; and it can send error
    messages to its clients if the input strings are not correctly formatted. Again,
    this ever-running server can be stopped with a `KeyboardInterrupt` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Building a non-blocking server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that we will discover is that the server that we currently have is
    not non-blocking. In other words, it cannot handle multiple clients simultaneously.
    In this section, you will learn how to build on the current server to make it
    non-blocking, using Python keywords that facilitate concurrent programming, in
    addition to low-level functionalities from the `socket` module.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the concurrency of the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now illustrate that the server that we currently have cannot have multiple
    clients at the same time. First, execute the `Chapter18/example3.py` file to run
    the server again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we did in the previous examples, let''s now open another Terminal
    and use Telnet into the running server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the second client for this server, open another Terminal and type
    in the same `telnet` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can already see that the server is not handling this second client
    correctly: it is not sending back the welcome message (`<welcome: starting in
    sum mode>`) to this client. If we look at the output of our server, we can also
    see that it is only registering one client—specifically, the first of the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will try to enter input from each of the clients. We will see that
    the server is only successfully handling requests from the first client. Specifically,
    the following is my output from the first client, with various types of input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the first client still maintaining the connection with the server,
    switch to the Terminal of the second client and try to enter its own input. You
    will see that unlike the first client, this client is not receiving any message
    back from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the server output, we will see that the server is only handling
    requests from the first client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The only way for the second client to be able to interact with the server is
    if the first client disconnects from the server—in other words, when we stop the
    connection between the first client and the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you switch to the Terminal of the second client, you will see that
    the client will be flushed with messages from the server that it should have been
    receiving earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the appropriate replies from the server are now present, but they were
    sent all at once, and not after each of the input messages. The same surge of
    information is also illustrated in the output from our server Terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This output makes it seem as if the server only received the connection from
    the second client after the first client had quit, when in reality, we created
    the two clients and had them communicate with the server at the same time. This
    is because our current server is only able to handle one client at a time, and
    only after the current client has quit can it move on to the next client that
    has requested a communication channel. We call this a blocking server.
  prefs: []
  type: TYPE_NORMAL
- en: Generators in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next section, we will discuss how to convert the blocking server that
    we currently have to a non-blocking one, while keeping the calculating functionalities.
    In order to do that, we will first need to look into another concept in Python
    programming, called **generators**. Chances are you have already worked with Python
    generators, but to recap, we will go over the key features of generators in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Generators are functions that return iterators and can be paused and resumed
    dynamically. Return values from generators are often compared to list objects,
    because generator iterators are **lazy** ([https://en.wikipedia.org/wiki/Lazy_evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation))
    and only produce results when explicitly asked. For this reason, generator iterators
    are more efficient in terms of memory management, and are therefore often preferred
    over lists when large amounts of data are involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each generator is defined as a function, but instead of using the keyword `return`
    inside the function block, we use `yield`, which is to indicate that the return
    value is only temporary and the whole generator itself can still be resumed after
    the return value is obtained. Let''s look at how Python generators work in an
    example, included in the `Chapter18/example4.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a generator named `read_data()`, which returns multiples of 2,
    from 0 to 8, in a lazy manner. This is done with the keyword `yield`, which is
    placed in front of what would be the return value in an otherwise normal function:
    `i * 2`. Note that the `yield` keyword is placed in front of the **individual**
    elements in the iterator that should be sent back, which facilitates the lazy
    generation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our main program, we are obtaining the whole iterator and storing it
    in the variable `result`. Then, we loop through that iterator six times, using
    the `next()` function (which, evidently, returns the next element in the iterator
    passed in). After executing the code, your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see that, even though the iterator was generated and returned from the
    `read_data()` generator before we looped through it, the actual instructions inside
    the generator were only executed as we tried to obtain more items from the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is illustrated by the fact that the print statements in the output were
    alternatively placed with each other (one print statement from the outer `for`
    loop and one from the inner `for` loop, alternatively): the execution flow goes
    into the outer `for` loop first, tries to access the next item in the iterator,
    goes into the generator, and goes into its own `for` loop. As soon as the execution
    flow reaches the `yield` keyword, it goes back out to the main program. This process
    continues until one of the `for` loops terminates; in our case, the `for` loop
    in the generator stopped first, and we therefore encountered a `StopIteration`
    error at the end.'
  prefs: []
  type: TYPE_NORMAL
- en: The laziness in the generation of the iterator comes from the fact that the
    generator stops executing when it reaches the `yield` keyword, and only continues
    its execution when asked by outside instructions (in this case, by the `next()`
    function). Again, this form of data generation is significantly more efficient
    in memory management than simply generating everything that might need to be iterated
    over (such as a list).
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous generators and the send method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are generators relevant to our purposes of building an asynchronous server?
    The reason our current server cannot handle multiple clients is because the `readline()`
    function that we are using in the user business logic part, in order to obtain
    client data, is a blocking function that prevents the execution flow from going
    to other potential clients, as long as the current `file` object is still open.
    That is why, when the current client stops its connection with the server, the
    next client immediately receives the surge of information that we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If we could rewrite this function into an asynchronous one that allowed the
    execution flow to switch between different clients while those clients were all
    connecting to the server, that server would then become non-blocking. We will
    do this by using asynchronous generators to concurrently generate data from potentially
    multiple clients at the same time for our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the underlying structure of the asynchronous generator that we will
    use for our server, let''s first consider the `Chapter18/example5.py` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are still considering the task of printing out multiples of 2, between 0
    and 8\. The `process()` function is our asynchronous generator in this example.
    You can see that there is, in fact, no `yield` keyword inside the generator; this
    is because we are using the `await` keyword, instead. This asynchronous generator
    is responsible for printing out the multiples of 2, computed by another generator, `read_data()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `@types.coroutine` decorator is used to convert the generator `read_data()`
    into a coroutine function that returns a generator-based coroutine, which can
    still be used as a regular generator but can also be awaited. This generator-based
    coroutine is the key to converting our blocking server to a non-blocking one.
    The coroutine performs the computation with the `send()` method, which is a way
    to provide a generator with input (in this case, we are providing the `process()`
    generator with multiples of 2).
  prefs: []
  type: TYPE_NORMAL
- en: This coroutine returns a callback, which can be called by our main program later.
    This is why, before looping through `range(5)` in the main program, we need to
    keep track of the `process()` generator itself (stored in the variable `gen`)
    and the callback that is returned (stored in the variable `callback`). The callback,
    specifically, is the return value of `gen.send(None)`, which is used to start
    the execution of the `process()` generator. Finally, we simply loop over the aforementioned
    `range` object and call the `callback` object with the appropriate input.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot has been said about the theory behind this method of using asynchronous
    generators. Now, let''s see it in action. Execute the program, and you should
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the output (specifically, the print statements), we can still observe the
    task switching events that are quintessential for both the asynchronous programming
    that was discussed in earlier chapters and the generators that produce output
    lazily. Essentially, we have achieved the same goal as the previous example (printing
    multiples of 2), but here, we used asynchronous generators (with the `async` and
    `await` keywords) to facilitate task switching events, and we were also able to
    pass specific arguments to generators by using a callback. These techniques, when
    combined, form the basic structure that will be applied to our currently blocking
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Making the server non-blocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we will consider the problem of implementing a non-blocking server
    again. Here, we are applying the asynchronous generators discussed previously
    to facilitate the asynchronous reading and handling of data received from clients
    of the server. The actual code for the server is included in the `Chapter18/example6.py`
    file; we will be going through various parts of it, as it is a relatively long
    program. Let''s turn our attention to the global variables that we will have in
    this program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To be able to successfully facilitate services for multiple clients at the same
    time, we will allow the server to have multiple sessions (one for each client)
    at the same time, and therefore, we will need to keep track of multiple dictionaries,
    each of which will hold one specific piece of information about the current session.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, the `sessions` dictionary maps a client socket connection to a
    `Session` object, which is a Python `namedtuple` object that contains the address
    of the client and the `file` object associated with that client connection. The
    `callback` dictionary maps a client socket connection to a callback that is the
    return value of the asynchronous generator that we will implement later; each
    of these callbacks takes in its corresponding client socket connection and data
    read from that client as arguments. Finally, the `generators` dictionary maps
    a client socket connection to its corresponding asynchronous generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `reactor` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside from what we already had from our previous blocking server, we are adding
    in a number of instructions: we use the `setblocking()` method from the `socket`
    module to potentially make our server asynchronous, or non-blocking; as we are
    starting a server, we also register that specific socket to the `sessions` dictionary,
    with a `None` value for now.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside our infinite `while` loop (the event loop) is part of the new non-blocking
    feature that we are trying to implement. First, we use the `select()` method from
    the `select` module to single out the sockets from the `sessions` dictionary that
    are ready to be read (in other words, the sockets that have available data). Since
    the first argument of the method is for the data to be read, the second is for
    the data to be written, and the third is for exception data, we are only passing
    in the `sessions` dictionary in the first argument. The fourth argument specifies
    the timeout period for the method (in seconds); if unspecified, the method will
    block infinitely, until at least one item in `sessions` becomes available, which
    is not suitable for our non-blocking server.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for every client socket connection that is ready to be read, if the connection
    corresponds to our original server socket, we will accept that connection and
    call the `connect()` function (which we will look at soon). In this `for` loop,
    we will also handle the callback methodologies. Specifically, we will access the
    `file` attribute of the session of the current socket connection (recall that
    each session has an `address` attribute and a `file` attribute) and will read
    data from it using the `readline()` method. Now, if what we read is valid data,
    then we will pass it (along with the current client connection) to the corresponding
    callback; otherwise, we will end the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Note that even though our server is made asynchronous by the socket being set
    to non-blocking, the preceding `readline()` method is still a blocking function.
    The `readline()` function returns when it gets to a carriage return in its input
    data (the `'\r'` character in ASCII). This means that if the data sent by a client
    somehow does not contain a carriage return, then the `readline()` function will
    fail to return. However, since the server is still non-blocking, an error exception
    will be raised so that other clients will not be blocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our new helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `connect()` function, which is to be called when a client connection has
    data that is ready to read, will initiate starting instructions at the beginning
    of a valid connection with a client. First, it initializes the `namedtuple` object
    associated with that specific client connection (we are still using the `makefile()`
    method to create the `file` objects here). The rest of the function is what we
    saw in the usage pattern of asynchronous generators, which we discussed earlier:
    we pass the client connection to `process_request()`, which is now an asynchronous
    generator; register it in the `generators` dictionary; have it call `send(None)`
    to initiate the generator; and store the return value to the `callback` dictionary,
    so that it can be called later (specifically, in the last part of the event loop
    in the reactor that we just saw).'
  prefs: []
  type: TYPE_NORMAL
- en: The `disconnect()` function, on the other hand, facilitates various cleaning
    instructions when a connection with a client stops. It removes the generator associated
    with the client connection from the `generators` dictionary and closes the generator,
    the `file` object stored in the `sessions` dictionary, as well as the client connection
    itself. Finally, it deletes the keys that correspond to the client connection
    from the remaining dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn our attention to the new `process_request()` function, which is
    now an asynchronous generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic that handles client data and performs the computation remains the
    same, and the only differences with this new function are the `async` keyword
    (placed in front of the `def` keyword) and the `await` keyword used with the new
    `readline()` function. These differences, in essence, convert our `process_request()`
    function into a non-blocking one, with the condition that the new `readline()`
    function is also non-blocking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Similar to what we saw in the previous example, we are importing the `types`
    module from Python and using the `@types.coroutine` decorator to make the `readline()`
    function a generator-based coroutine, which is non-blocking. Each time a callback
    (which takes in a client connection and a line of data) is called, the execution
    flow will go into the `inner()` function inside this coroutine and execute the
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, it sends the line of data to the generator, which will enable
    the instructions in `process_request()` to handle it asynchronously and store
    the return value to the appropriate callback—unless the end of the generator has
    been reached, in which case the `disconnect()` function will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last task is to test whether this server is actually capable of handling
    multiple clients at the same time. To do this, execute the following script first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what you saw earlier, open two additional Terminals and use Telnet
    into this running server with both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, both clients are being handled correctly: both are able to
    connect, and both receive the welcome message. This is also illustrated by the
    server output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Further tests could involve sending messages to the server at the same time,
    which it can still handle. The server can also keep track of individual modes
    of calculation that are unique to individual clients (in other words, assuming
    each client has a separate mode of calculation). We have successfully built a
    non-blocking, concurrent server from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More often than not, low-level network programming involves the manipulation
    and handling of sockets (defined as theoretical endpoints within the nodes of
    a specific computer network, responsible for receiving or sending data from the
    nodes that they are in). The architecture of server-side communication consists
    of multiple steps involving socket handling, such as bind, listen, accept, read,
    and write. The `socket` module provides an intuitive API that facilitates these
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: To create a non-blocking server with the `socket` module, asynchronous generators
    need to be implemented, in order for the execution flow to switch between tasks
    and data. This process also involves using callbacks that can be run by the execution
    flow at a later time. These two elements allow for the server to read and handle
    the data coming in from multiple clients at the same time, allowing the server
    to become non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude our book with the next chapter, with practical techniques for
    designing and implementing concurrent programs. Specifically, we will discuss
    how to test, debug, and schedule concurrent applications, methodically and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a socket? How is it relevant to network programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the procedure for server-side communication when a potential client
    makes a request to connect?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some methods provided by the `socket` module to facilitate low-level
    network programming on the server-side?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are generators? What is their advantage over Python lists?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are asynchronous generators? How can they be applied to build a non-blocking
    server?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keynote on Concurrency*, PyBay 2017, Raymond Hettinger ([https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html](https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html))
    [](https://pybay.com/site_media/slides/raymond2017-keynote/async_examples.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A simple Python webserver*, Stephen C. Phillips ([blog.scphillips.com/posts/2012/12/a-simple-python-webserver/](http://blog.scphillips.com/posts/2012/12/a-simple-python-webserver/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to Work with TCP Sockets in Python*, Alexander Stepanov ([steelkiwi.com/blog/working-tcp-sockets/](https://steelkiwi.com/blog/working-tcp-sockets/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Socket Programming in Python*, Nathan Jennings ([realpython.com/python-sockets/#multi-connection-client-and-server](https://realpython.com/python-sockets/#multi-connection-client-and-server))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Python Generators* ([realpython.com/introduction-to-python-generators/](https://realpython.com/introduction-to-python-generators/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
