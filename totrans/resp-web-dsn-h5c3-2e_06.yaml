- en: Chapter 6. Stunning Aesthetics with CSS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aesthetically focused features of CSS3 are so useful in responsive design
    because using CSS3 lets us replace images in many situations. This saves you time,
    makes your code more maintainable and flexible and results in less page 'weight'
    for the end user. Those benefits would be useful even on a typical fixed-width
    desktop design but it's even more important with a responsive design as using
    CSS in these situations makes it trivial to create different aesthetic effects
    at different viewports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create text shadows with CSS3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create box shadows with CSS3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make gradient backgrounds with CSS3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use multiple backgrounds with CSS3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CSS3 background gradients to make patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement high-resolution background images with media queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use CSS filters (and their performance implications)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Vendor prefixes**'
  prefs: []
  type: TYPE_NORMAL
- en: When implementing experimental CSS, just remember to add relevant vendor prefixes
    via a tool, rather than by hand. This ensures the broadest cross-browser compatibility
    and also negates you adding in prefixes that are no longer required. I'm mentioning
    Autoprefixer ([https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer))
    in most chapters as, at the time of writing, I think it's the best tool for the
    job.
  prefs: []
  type: TYPE_NORMAL
- en: Text shadows with CSS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most widely implemented CSS3 features is `text-shadow`. Like `@font-face`,
    it had a previous life but was dropped in CSS 2.1\. Thankfully it''s back and
    widely supported (for all modern browsers and Internet Explorer 9 onwards). Let''s
    look at the basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the values in shorthand rules always go right and then down (or think
    of it as clockwise if you prefer). Therefore, the first value is the amount of
    shadow to the right, the second is the amount down, the third value is the amount
    of blur (the distance the shadow travels before fading to nothing), and the final
    value is the color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shadows to the left and above can be achieved using negative values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The color value doesn''t need to be defined as a HEX value. It can just as
    easily be HSL(A) or RGB(A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, keep in mind that the browser must then also support HSL/RGB color
    modes along with `text-shadow` in order to render the effect.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the shadow values in any other valid CSS length units such
    as em, rem, ch, rem, and so on. Personally, I rarely use em or rem units for `text-shadow`
    values. As the values are always really low, using 1px or 2px generally looks
    good across all viewports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to media queries, we can easily remove text shadows at different viewport
    sizes too. The key here is the none value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an aside, it''s worth knowing that in CSS, where a value starts with a zero,
    such as 0.14s, there is no need to write the leading zero: .14s is exactly the
    same.'
  prefs: []
  type: TYPE_NORMAL
- en: Omitting the blur value when not needed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If there is no blur to be added to a `text-shadow` the value can be omitted
    from the declaration, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That is perfectly valid. The browser assumes that the first two values are for
    the offsets if no third value is declared.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple text shadows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s possible to add multiple text shadows by comma separating two or more
    shadows. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as CSS is forgiving of whitespace, you can lay out the values like this
    if it helps with readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the W3C specification for the `text-shadow` property at [http://www.w3.org/TR/css3-text/](http://www.w3.org/TR/css3-text/).
  prefs: []
  type: TYPE_NORMAL
- en: Box shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Box shadows allow you to create a box-shaped shadow around the outside or inside
    of the element it is applied to. Once text shadows are understood, box shadows
    are a piece of cake; principally, they follow the same syntax: horizontal offset,
    vertical offset, blur, spread (we will get to spread in a moment), and color.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only two of the possible four length values are required (in the absence of
    the last two, the value of color defines the shadow color and a value of zero
    is used for the blur radius). Let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The default `box-shadow` is set on the outside of the element. Another optional
    keyword, `inset` allows the `box-shadow` to be applied inside the element.
  prefs: []
  type: TYPE_NORMAL
- en: An inset shadow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `box-shadow` property can also be used to create an `inset` shadow. The
    syntax is identical to a normal box shadow except that the value starts with the
    keyword `inset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything functions as before but the `inset` part of the declaration instructs
    the browser to set the effect on the inside. If you look at `example_06-01` you''ll
    see an example of each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An inset shadow](img/3777_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multiple shadows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like `text-shadow`, you can apply multiple `box-shadow`. Separate the `box-shadow`
    with a comma and they are applied bottom to top (last to first) as they are listed.
    Remind yourself of the order by thinking that the declaration nearest to the top
    in the rule (in the code) appears nearest to the ''top'' of the order when displayed
    in the browser. As with `text-shadow`, you may find it useful to use whitespace
    to visually stack the different `box-shadow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stacking longer, multiple values, one under the other in the code, has an added
    benefit when using version control systems; it makes it easy to spot differences
    when you 'diff' two versions of a file. That's the primary reason I stack groups
    of selectors one under the other too.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding spread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'll be honest, for literally years I didn't truly understand what the spread
    value of a `box-shadow` actually did. I don't think the name 'spread' is useful.
    Think of it more as an offset. Let me explain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the box on the left in `example_06-02`. This has a standard `box-shadow`
    applied. The one on the right has a negative spread value applied. It''s set with
    the fourth value. Here is the relevant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the effect of each (element with spread value on the right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding spread](img/3777_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The spread value lets you extend or contract the shadow in all directions by
    the amount specified. In this example, a negative value is pulling the shadow
    back in all directions. The result being that we see the shadow at the bottom,
    only instead of seeing the blur 'leak' out on all sides (as the blur is being
    counter-balanced by the negative spread value).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the W3C specification for the `box-shadow` property at [http://www.w3.org/TR/css3-background/](http://www.w3.org/TR/css3-background/).
  prefs: []
  type: TYPE_NORMAL
- en: Background gradients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In days gone by, to achieve a background gradient on an element, it was necessary
    to tile a thin graphical slice of the gradient. As graphics resources go, it's
    quite an economical trade-off. An image, only a pixel or two wide, isn't going
    to break the bandwidth bank and on a single site it can be used on multiple elements.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we need to tweak the gradient it still requires round-trips to the
    graphics editor. Plus, occasionally, content might 'break out' of the gradient
    background, extending beyond the images' fixed size limitations. This problem
    is compounded with a responsive design, as sections of a page may increase at
    different viewports.
  prefs: []
  type: TYPE_NORMAL
- en: With a CSS `background-image` gradient however, things are far more flexible.
    As part of the CSS Image Values and Replaced Content Module Level 3, CSS enables
    us to create linear and radial background gradients. Let's look how we can define
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The specification for CSS Image Values and Replaced Content Module Level 3 can
    be found at [http://www.w3.org/TR/css3-images/](http://www.w3.org/TR/css3-images/).
  prefs: []
  type: TYPE_NORMAL
- en: The linear-gradient notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `linear-gradient` notation, in its simplest form, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create a linear gradient that starts at red (the gradient starts from
    the top by default) and fades to blue.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying gradient direction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, if you want to specify a direction for the gradient, there are a couple
    of ways. The gradient will always begin in the opposite direction to where you
    are sending it. However, when no direction is set, a gradient will always default
    to a top to bottom direction. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, the gradient heads to the top right. It starts red in the
    bottom-left corner and fades to blue at the top right.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re more mathematically minded, you may believe it would be comparable
    to write the gradient like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, keep in mind that on a rectangular box, a gradient that heads 'to top
    right' (always the top right of the element it's applied to) will end in a slightly
    different position than `45deg` (always 45 degrees from its starting point).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth knowing you can also start gradients before they are visible within
    a box. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This would render a gradient as if it had started before it is even visible
    inside the box.
  prefs: []
  type: TYPE_NORMAL
- en: We've actually used a color stop in that last example to define a place where
    a color should begin and end so let's look at those more fully.
  prefs: []
  type: TYPE_NORMAL
- en: Color stops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perhaps the handiest thing about background gradients is color stops. They
    provide the means to set which color is used at which point in a gradient. With
    color stops you can specify something as complex as you are likely to need. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how that `linear-gradient` renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color stops](img/3777_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example (`example_06-03`), a direction has not been specified so the
    default top to bottom direction applies.
  prefs: []
  type: TYPE_NORMAL
- en: Color stops inside a gradient are written comma separated and defined by giving
    first the color, and then the position of the stop. It's generally advisable not
    to mix units in one notation but you can. You can have as many color stops as
    you like and colors can be written as a keyword, HEX, RGBA, or HSLA value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there have been a number of different background gradient syntaxes
    over the years so this is one area that is particularly difficult to write fallbacks
    for by hand. At the risk of sounding like a broken record (kids, if you don't
    know what a 'record' is, ask mom or dad), make your life easier with a tool such
    as Autoprefixer. This lets you write the current W3C standard syntax (as detailed
    earlier) and it will automatically create the prior versions for you.
  prefs: []
  type: TYPE_NORMAL
- en: Read the W3C specification for linear background gradients at [http://www.w3.org/TR/css3-images/](http://www.w3.org/TR/css3-images/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding fallback for older browsers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a simple fallback for older browsers that don''t support background gradients,
    just define a solid background color first. That way older browsers will at least
    render a solid background if they don''t understand the gradient that''s defined
    afterwards. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Radial background gradients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's equally simple to create a radial gradient in CSS. These typically begin
    from a central point and spread out smoothly in an elliptical or circular shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the syntax for a radial background gradient (you can play with it in
    `example_06-04`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Breakdown of the radial-gradient syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After specifying the property (`background:`) we begin the `radial-gradient`
    notation. To start with, before the first comma, we define the shape or size of
    the gradient and the position. We have used 12rem circle for the shape and size
    above but consider some other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`5em` would be a circle 5em in size. It''s possible to omit the ''circle''
    part if giving just a size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`circle` would be a circle the full size of the container (the size of a radial
    gradient defaults to ''farthest corner'' if omitted—more on sizing keywords shortly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`40px 30px` would be a ellipse as if drawn inside a box 40px wide by 30px tall'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ellipse` would create an ellipse shape that would fit within the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, after the size and/or shape, we define the position. The default position
    is center but let''s look at some other possibilities and how they can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**at top right** starts the radial gradient from the top right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**at right 100px top 20px** starts the gradient 100px from the right edge and
    20px from the top edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**at center left** starts it halfway down the left side of the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We end our size, shape, and position 'parameters' with a comma and then define
    any color stops; which work in exactly the same manner as they do with `linear-gradient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the notation: size, shape, and position before the first comma,
    then as many color stops as needed after it (with each stop separated with commas).'
  prefs: []
  type: TYPE_NORMAL
- en: Handy 'extent' keywords for responsive sizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For responsive work, you may find it advantageous to size gradients proportionally
    rather than using fixed pixel dimensions. That way you know you are covered (both
    literally and figuratively) when the size of elements change. There are some handy
    sizing keywords that can be applied to gradients. You would write them like this,
    in place of any size value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what each of them does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`closest-side`: The shape meets the side of the box nearest to the center (in
    the case of circles), or meets both the horizontal and vertical sides that are
    closest to the center (in the case of ellipses)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closest-corner`: The shape meets exactly the closest corner of the box from
    its center'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`farthest-side`: The opposite of `closest-side`, in that rather than the shape
    meeting the nearest size, it''s sized to meet the one farthest from its center
    (or both the furthest vertical and horizontal side in the case of an ellipse)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`farthest-corner`: The shape expands to the farthest corner of the box from
    the center'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cover`: Identical to `farthest-corner`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contain`: Identical to `closest-side`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the W3C specification for radial background gradients at [http://www.w3.org/TR/css3-images/](http://www.w3.org/TR/css3-images/).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The cheat''s way to perfect CSS3 linear and radial gradients**'
  prefs: []
  type: TYPE_NORMAL
- en: If defining gradients by hand seems like hard work, there are some great online
    gradient generators. My personal favorite is [http://www.colorzilla.com/gradient-editor/](http://www.colorzilla.com/gradient-editor/).
    It uses a graphics editor style GUI, allowing you to pick your colors, stops,
    gradient style (linear and radial gradients are supported), and even the color
    space (HEX, RGB(A), HSL(A)) you'd like the final gradient in. There are also loads
    of preset gradients to use as starting points. If that wasn't enough, it even
    gives you optional code for fixing up Internet Explorer 9 to show the gradient
    and a fallback flat color for older browsers. Still not convinced? How about the
    ability to generate a CSS gradient based on upon the gradient values in an existing
    image? Thought that might swing it for you.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating gradients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSS3 also gives us the ability to create repeating background gradients. Let''s
    take a look at how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how that looks (don''t look for long, may cause nausea):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Repeating gradients](img/3777_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Firstly, prefix the `linear-gradient` or `radial-gradient` with repeating, then
    it follows the same syntax as a normal gradient. Here I've used pixel distances
    between the black, orange, and red colors (0px, 5px, and 10px respectively) but
    you could also choose to use percentages. For best results, it's recommended to
    stick to the same measurement units (such as pixels or percentages) within a gradient.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read the W3C information on repeating gradients at [http://www.w3.org/TR/css3-images/](http://www.w3.org/TR/css3-images/).
  prefs: []
  type: TYPE_NORMAL
- en: There's one more way of using background gradients I'd like to share with you.
  prefs: []
  type: TYPE_NORMAL
- en: Background gradient patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although I''ve often used subtle linear gradients in designs, I''ve found less
    practical use for radial gradients and repeating gradients. However, clever folks
    out there have harnessed the power of gradients to create background gradient
    patterns. Let''s look at an example from CSS Ninja, Lea Verou''s collection of
    CSS3 background patterns, available at [http://lea.verou.me/css3patterns/](http://lea.verou.me/css3patterns/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what that gives us in the browser, a `carbon-fibre` background effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Background gradient patterns](img/3777_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How about that? Just a few lines of CSS3 and we have an easily editable, responsive,
    and scalable background pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might find it useful to add `background-repeat: no-repeat` at the end of
    the rule to better understand how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As ever, thanks to media queries, different declarations can be used for different
    responsive scenarios. For example, although a gradient pattern might work well
    at smaller viewports, it might be better to go with a plain background at larger
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can view this example at `example_06-05`.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple background images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although a little out of fashion at the moment, it used to be a fairly common
    design requirement to build a page with a different background image at the top
    of the page than at the bottom. Or perhaps to use different background images
    for the top and bottom of a content section within a page. Back in the day, with
    CSS2.1, achieving the effect typically required additional markup (one element
    for the header background and another for the footer background).
  prefs: []
  type: TYPE_NORMAL
- en: With CSS3 you can stack as many background images as you need on an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the stacking order of multiple shadows, the image listed first appears
    nearest to the top in the browser. You can also add a general color for the background
    in the same declaration if you wish, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Specify the color last and this will show below every image specified above.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When specifying multiple background elements, you don't have to stack the different
    images on different lines; I just find it easier to read code when written this
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers that don't understand the multiple backgrounds rule (such as Internet
    Explorer 8 and below) will ignore the rule altogether, so you may wish to declare
    a 'normal' background property immediately before a CSS3 multiple background rule
    as a fallback for really old browsers.
  prefs: []
  type: TYPE_NORMAL
- en: With the multiple background images, as long as you're using PNG files with
    transparency, any partially transparent background images that sit on top of another
    will show through below. However, background images don't have to sit on top of
    one another, nor do they all have to be the same size.
  prefs: []
  type: TYPE_NORMAL
- en: Background size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set different sizes for each image, use the `background-size` property.
    When multiple images have been used, the syntax works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The size values (first width, then height) for each image are declared, separated
    by commas, in the order they are listed in the background property. As in the
    example above, you can use percentage or pixel values for each image alongside
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`auto`: Which sets the element at its native size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cover`: Which expands the image, preserving its aspect ratio, to cover the
    area of the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contain`: Which expands the image to fit its longest side within the element
    while preserving the aspect ratio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have different background images, at different sizes, the next thing
    you'll want is the ability to position them differently. Thankfully, the `background-position`
    property facilitates that too.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put all this background image capability together, alongside some of the
    responsive units we have looked at in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple space scene, made with a single element and three background
    images, set at three different sizes, and positioned in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see something like this in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Background position](img/3777_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have the stars image at the bottom, then the moon on top, and finally an
    image of the Rosetta space probe on top. View this for yourself in `example_06-06`.
    Notice that if you adjust the browser window, the responsive length units work
    well (`vmax`, `vh`, and `vw`) and retain proportion, while pixel based ones do
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where no `background-position` is declared, the default position of top left
    is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Background shorthand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a shorthand method of combining the different background properties
    together. You can read the specification for it at [http://www.w3.org/TR/css3-background/](http://www.w3.org/TR/css3-background/).
    However, my experience so far has been that it produces erratic results. Therefore,
    I recommend the longhand method and declare the multiple images first, then the
    size, and then the position.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read the W3C documentation on multiple background elements at [http://www.w3.org/TR/css3-background/](http://www.w3.org/TR/css3-background/).
  prefs: []
  type: TYPE_NORMAL
- en: High-resolution background images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to media queries, we have the ability to load in different background
    images, not just at different viewport sizes but also different viewport resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is the official way of specifying a background image for
    a ''normal'' and a high DPI screen. You can find this in `example_06-07`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The media query is written exactly as it is with width, height, or any of the
    other capability tests. In this example, we are defining the minimum resolution
    that `bg@1_5x.jpg` should use as 1.5dppx (device pixels per CSS pixel). We could
    also use **dpi** (**dots per inch**) or **dpcm** (**dots per centimeter**) units
    if preferable. However, despite the poorer support, I find dppx the easiest unit
    to think about; as 2dppx is twice the resolution, 3dppx would be three times the
    resolution. Thinking about that in dpi is trickier. 'Standard' resolution would
    be 96dpi, twice that resolution would be 192dpi and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Support for the 'dppx' unit isn't great right now (check your target browsers
    at [http://caniuse.com/](http://caniuse.com/)) so to get this working everywhere
    smoothly, you'll need to write a few versions of the media query resolution or,
    as ever, rely on a tool to do the prefixing for you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A brief note on performance**'
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that large images can potentially slow down the feel of your site
    and lead to a poor experience for users. While a background image won't block
    the rendering of the page (you'll still see the rest of the site drawn to the
    page while you wait for the background image), it will add to the total weight
    of the page, which is important if users are paying for data.
  prefs: []
  type: TYPE_NORMAL
- en: CSS filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a glaring problem with `box-shadow`. As the name implies, it is limited
    to the rectangular CSS box shape of the element it is applied to. Here''s a screen
    grab of a triangle shape made with CSS (you can view the code in `example_06-08`)
    with a box shadow applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS filters](img/3777_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not exactly what I was hoping for. Thankfully, we can overcome this issue with
    CSS filters, part of the Filter Effects Module Level 1 ([http://www.w3.org/TR/filter-effects/](http://www.w3.org/TR/filter-effects/)).
    They are not as widely supported as `box-shadow`, but work great with a progressive
    enhancement approach. If a browser doesn't understand what to do with the filter
    it simply ignores it. For supporting browsers, the fancy effects are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is that same element with a CSS `drop-shadow` filter applied instead of
    a `box-shadow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS filters](img/3777_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the format for CSS filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After the `filter` property we specify the filter we want to use, `drop-shadow`
    in this example, and then pass in the arguments for the filter. The `drop-shadow`
    follows a similar syntax to `box-shadow` so this one is easy; x and y offset,
    blur, then spread radius (both optional), and finally color (also optional, although
    I recommend specifying a color for consistency).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS filters are actually based upon SVG filters which have a wider support.
    We'll look at the SVG based equivalent in [Chapter 7](ch07.html "Chapter 7. Using
    SVGs for Resolution Independence"), *Using SVGs for Resolution Independence*.
  prefs: []
  type: TYPE_NORMAL
- en: Available CSS filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few filters to choose from. We will look at each. While images of
    most of the filters follow, readers reading a hard copy of this book (with monochrome
    images) may struggle to notice the differences. If you're in that situation, remember
    you can still view the various filters in the browser by opening `example_06-08`.
    I'm going to list each out now with a suitable value specified. As you might imagine,
    more of a value means more of the filter applied. Where images are used, the image
    is shown after the relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: '`filter: url (''./img/filters.svg#filterRed'')`: Lets you specify an SVG filter
    to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: blur(3px)`: Use a single length value (but not as a percentage).![Available
    CSS filters](img/3777_06_09.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: brightness(2)`: Use a value from 0 to 1 or 0% to 100%. 0/0% is black,
    1/100% is ''normal,'' and anything beyond brightens the element further.![Available
    CSS filters](img/3777_06_10.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: contrast(2)`: Use a value from 0 to 1 or 0% to 100%. 0/0% is black,
    1/100% is ''normal,'' and anything beyond raises the color contrast.![Available
    CSS filters](img/3777_06_11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: drop-shadow(4px 4px 6px #333)`: We looked at `drop-shadow` in detail
    earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: grayscale(.8)`: Use a value from 0 to 1, or 0% to 100% to apply varying
    amounts of grayscale to the element. A value of 0 would be no grayscale while
    a value of 1 would be fully grayscale.![Available CSS filters](img/3777_06_12.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: hue-rotate(25deg)`: Use a value between 0 and 360 degrees to adjust
    the colors around the color wheel.![Available CSS filters](img/3777_06_13.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: invert(75%)`: Use a value from 0 to 1, or 0% to 100% to define the
    amount the element has its colors inverted.![Available CSS filters](img/3777_06_14.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: opacity(50%)`: Use a value from 0 to 1, or 0% to 100% to alter the
    opacity of the element. This is similar to the `opacity` property you will already
    be familiar with. However, filters, as we shall see, can be combined and this
    allows opacity to be combined with other filters in one go.![Available CSS filters](img/3777_06_15.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: saturate(15%)`: Use a value from 0 to 1, or 0% to 100% to de-saturate
    an image and anything above 1/100% to add extra saturation.![Available CSS filters](img/3777_06_16.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter: sepia(.75)`: Use a value from 0 to 1, or 0% to 100% to make the element
    appear with a more sepia color. 0/0% leaves the element ''as is'' while anything
    above that applies greater amounts of sepia up to a maximum of 1/100%.![Available
    CSS filters](img/3777_06_17.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining CSS filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also combine filters easily; simply space separate them. For example,
    here is how you would apply `opacity`, `blur`, and `sepia` filters at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Apart from `hue-rotate`, when using filters, negative values are not
    allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: I think you'll agree, CSS filters offer some pretty powerful effects. They are
    also effects we can transition and transform from situation to situation. We'll
    look at how to do that in [Chapter 8](ch08.html "Chapter 8. Transitions, Transformations,
    and Animations"), *Transitions, Transformations, and Animations*.
  prefs: []
  type: TYPE_NORMAL
- en: However, before you go crazy with these new toys, we need to have a grown up
    conversation about performance.
  prefs: []
  type: TYPE_NORMAL
- en: A warning on CSS performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to CSS performance, I would like you to remember this one thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"Architecture is outside the braces, performance is inside."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Ben Frain* |'
  prefs: []
  type: TYPE_TB
- en: 'Let me expand on my little maxim:'
  prefs: []
  type: TYPE_NORMAL
- en: As far as I am able to prove, worrying about whether a CSS selector (the part
    outside the curly braces), is fast or slow is pointless. I set out to prove this
    at [http://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/](http://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/).
  prefs: []
  type: TYPE_NORMAL
- en: However, one thing that really can grind a page to a halt, CSS wise, is 'expensive'
    properties (the parts inside the curly braces). When we use the term 'expensive',
    in relation to certain styles, it simply means it costs the browser a lot of overhead.
    It's something that the browser finds overly taxing to do.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to take a common sense guess about what will likely cause the
    browser extra work. It's basically anything it would have to compute before it
    can paint things to the screen. For example, compare a standard div with a flat
    solid background, against a semi-opaque image, on top of a background made up
    of multiple gradients, with rounded corners and a `drop-shadow`. The latter is
    more expensive; it will result in far more computational work for the browser
    and subsequently cause more overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when you apply effects like filters, do so judiciously and, if possible,
    test whether the page speed suffers on the lowest powered devices you are hoping
    to support. At the least, switch on development tool features such as continuous
    page repainting in Chrome and toggle any affects you think may cause problems.
    This will provide you with data (in the form of a millisecond reading of how long
    the current viewport is taking to paint) to make a more educated decision on which
    effects to apply. The lower the figure, the faster the page will perform (although
    be aware that browsers/platforms vary so, as ever, test on real devices where
    possible).
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on this subject I recommend the following resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/web/fundamentals/performance/rendering/](https://developers.google.com/web/fundamentals/performance/rendering/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A warning on CSS performance](img/3777_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A note on CSS masks and clipping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the near future, CSS will be able to offer masks and clipping as part of
    the CSS Masking Module Level 1\. These features will enable us to clip an image
    with a shape or arbitrary path (specified via SVG or a number of polygon points).
    Sadly, despite the specification being at the more advanced CR stage, as I write
    this, the browser implementations are just too buggy to recommend. However, it's
    a fluid situation so by the time you are reading this, there's every chance the
    implementations will be solid. For the curious, I'll therefore refer you to the
    specification at [http://www.w3.org/TR/css-masking/](http://www.w3.org/TR/css-masking/).
  prefs: []
  type: TYPE_NORMAL
- en: 'I also think Chris Coyier does a great job of explaining where things are at
    support wise in this post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://css-tricks.com/clipping-masking-css/](http://css-tricks.com/clipping-masking-css/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a good overview and explanation of what will be possible is offered
    by Sara Soueidan in this post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://alistapart.com/article/css-shapes-101](http://alistapart.com/article/css-shapes-101)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we've looked at a selection of the most useful CSS features
    for creating lightweight aesthetics in responsive web designs. CSS3's background
    gradients curb our reliance on images for background effects. We have even considered
    how they can be used to create infinitely repeating background patterns. We've
    also learned how to use text-shadows to create simple text enhancements andbox-shadows
    to add shadows to the outside and inside of elements. We've also looked at CSS
    filters. They allow us to achieve even more impressive visual effects with CSS
    alone and can be combined for truly impressive results.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we're going to turn our attention to creating and using
    SVGs as they are more simply called. While it's a very mature technology, it is
    only in the current climate of responsive, and high-performing websites that it
    has really come of age.
  prefs: []
  type: TYPE_NORMAL
