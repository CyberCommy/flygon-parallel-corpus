- en: Starting MyMDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first project we will build is a basic **Internet Movie Database** (**IMDB**)
    clone called **My Movie Database (MyMDB)** written in Django 2.0 that we will
    deploy using Docker. Our IMDB clone will have the following two types of users:
    users and administrators. The users will be able to rate movies, add images from
    movies, and view movies and cast. The administrators will be able to add movies,
    actors, writers, and directors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create our new Django project MyMDB, an IMDB clone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a Django app and create our first models, views, and templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about and use a variety of fields in our models and create relationships
    across models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this project is available online at [https://github.com/tomaratyn/MyMDB](https://github.com/tomaratyn/MyMDB).
  prefs: []
  type: TYPE_NORMAL
- en: By the end, we'll be able to add movies, people, and roles into our project
    and let users view them in easy-to-customize HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: Starting My Movie Database (MyMDB)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s make a directory for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All our future commands and paths will be relative to this project directory.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Django project is composed of multiple Django apps. A Django app can come
    from many different places:'
  prefs: []
  type: TYPE_NORMAL
- en: Django itself (for example, `django.contrib.admin`, the admin backend app)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed Python packages (for example, `django-rest-framework`, a framework
    for creating REST APIs from Django models)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Written as part of the project (the code we'll be writing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, a project uses a mix of all of the preceding three options.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll install Django using `pip`, Python''s preferred package manager and
    track which packages we install in a `requirements.dev.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s install the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Django installed, we have the `django-admin` command-line tool with which
    we can generate our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent of the `settings.py` file is called `config` because we named our
    project `config` instead of `mymdb`. However, letting that top-level directory
    continue to be called `config` is confusing, so let''s just rename it `django`
    (a project may grow to contain lots of different types of code; calling the parent
    of the Django code `django`, again, makes it clear):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at some of these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`settings.py`: This is where Django stores all the configuration for your app
    by default. In the absence of a `DJANGO_SETTINGS` environment variable, this is
    where Django looks for settings by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urls.py`: This is the root `URLConf` for the entire project. Every request
    that your web app gets will get routed to the first view that matches a path inside
    this file (or a file `urls.py` reference).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsgi.py`: **Web Server Gateway Interface** (**WSGI**) is the interface between
    Python and a web server. You won''t touch this file very much, but it''s how your
    web server and your Python code know how to talk to each other. We''ll reference
    it in [Chapter 5](b8fb8fcb-d4d7-439f-abba-f49882ee7598.xhtml), *Deploying with
    Docker*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manage.py`: This is the command center for making non-code changes. Whether
    it''s creating a database migration, running tests, or starting the development
    server, we will use this file often.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note what's missing is that the `django` directory is not a Python module. There's
    no `__init__.py` file in there, and there should *not* be. If you add one, many
    things will break because we want the Django apps we add to be top-level Python
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring database settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Django creates a project that will use SQLite, but that's not usable
    for production, so we'll follow the best practice of using the same database in
    development as in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `django/config/settings.py` and update it to use our Postgres
    server. Find the line in `settings.py` that starts with `DATABASES`. By default,
    it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To use Postgres, change the preceding code to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this will seem familiar if you''ve connected to a database before,
    but let''s review:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DATABASES = {`: This constant is a dictionary of database connection information
    and is required by Django. You can have multiple connections to different databases,
    but, most of the time, you will just need an entry called `default`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''default'': {`: This is the default database connection configuration. You
    should always have a `default` set of connections settings. Unless you specify
    otherwise (and, in this book, we won''t), this is the connection you''ll be using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''ENGINE'': ''django.db.backends.postgresql ''`: This tells Django to use
    the Postgres backend. This in turn uses `psycopg2`, Python''s Postgres library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''NAME'': ''mymdb'',`: The name of the database you want to connect to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`‘USER'': ''mymdb'',`: The username for your connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`‘PASSWORD'': ''development'',`: The password for your database user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`‘HOST'': ''127.0.0.1’,`: The address of the database server you want to connect
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`‘PORT'': ''5432'',`: The port you want to connect to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django apps follow a **Model View Template** (**MVT**) pattern; in this pattern,
    we will note the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Models** are responsible for saving and retrieving data from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views** are responsible for processing HTTP Requests, initiating operations
    on Models, and returning HTTP responses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates** are responsible for the look of the response body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no limit on how many apps you can have in your Django project. Ideally,
    each app should have a tightly scoped and self-contained functionality like any
    other Python module, but at the beginning of a project, it can be hard to know
    where the complexity will lie. That's why I find it useful to start off with a
    `core` app. Then, when I notice clusters of complexity around particular topics
    (let's say, in our project, actors could become unexpectedly complex if we're
    getting traction there), then we can refactor that into its own tightly scoped
    app. Other times, it's clear that a site has self-contained components (for example,
    an admin backend), and it's easy to start off with multiple apps.
  prefs: []
  type: TYPE_NORMAL
- en: Making the core app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make a new Django app, we first have to use `manage.py` to create the app
    and then add it to the list of `INSTALLED_APPS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at what''s inside of the core:'
  prefs: []
  type: TYPE_NORMAL
- en: '`core/__init__.py`: The core is not just a directory, but also a Python module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin.py`: This is where we will register our models with the built-in admin
    backend. We''ll describe that in the *Movie Admin* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apps.py`: Most of the time, you''ll leave this alone. This is where you would
    put any code that needs to run when registering your application, which is useful
    if you''re making a reusable Django app (for example, a package you want to upload
    to PyPi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`migrations`: This is a Python module with database migrations. Database migrations
    describe how to *migrate* the database from one known state to another. With Django,
    if you add a model, you can just generate and run a migration using `manage.py`,
    which you can see later in this chapter in the *Migrating the database* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.py`: This is for models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests.py`: This is for tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views.py`: This is for views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our core app exists, let''s make Django aware of it by adding it to
    the list of installed apps in `settings.py` file. Your `settings.py` should have
    a line that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`INSTALLED_APPS` is a list of Python paths to Python modules that are Django
    apps. We already have apps installed to solve common problems, such as managing
    static files, sessions, and authentication and an admin backend because of Django''s
    Batteries Included philosophy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our `core` app to the top of that list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding our first model – Movie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can add our first model, that is, Movie.
  prefs: []
  type: TYPE_NORMAL
- en: A Django model is a class that is derived from `Model` and has one or more `Fields`.
    In database terms, a `Model` class corresponds to a database table, `Field` classes
    correspond to columns, and instances of a `Model` correspond to rows. Using an
    ORM like Django's, let's take advantage of Python and Django to write expressive
    classes instead of DB writing our models once in Python and again in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit `django/core/models.py` to add a `Movie` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Movie` is derived from `models.Model`, which is the base class for all Django
    models. Next, there''s a series of constants that describe ratings; we''ll take
    a look at that when we look at the `rating` field, but first let''s look at the
    other fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title = models.CharField(max_length=140)`: This will become a `varchar` column
    with a length of 140\. Databases generally require a maximum size for `varchar` columns,
    so Django does too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plot = models.TextField()`: This will become a `text` column in our database,
    which has no maximum length requirement. This makes it more appropriate for a
    field that can have a paragraph (or even pages) of text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`year = models.PositiveIntegerField()`: This will become an `integer` column,
    and Django will validate the value before saving it to ensure that it is `0` or
    higher when you save it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rating = models.IntegerField(choices=RATINGS, default=NOT_RATED)`: This is
    a more complicated field. Django will know that this is going to be an `integer` column.
    The optional argument `choices` (which is available for all `Fields`, not just
    `IntegerField`) takes an iterable (list or tuple) of value/display pairs. The
    first element in the pair is a valid value that can be stored in the database
    and the second is a human-friendly version of the value. Django will also add
    an instance method to our model called `get_rating_display()`, which will return
    the matching second element for the value stored in our model. Anything that doesn''t
    match one of the values in `choices` will be a `ValidationError` on save. The
    `default` argument provides a default value if one is not provided when creating
    the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime = models.PositiveIntegerField()`: This is the same as the `year` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`website = models.URLField(blank=True)`: Most databases don''t have a native
    URL column type, but data-driven web apps often need to store them. A `URLField`
    is a `varchar(200)` field by default (this can be set by providing a `max_length`
    argument). `URLField` also comes with validation, checking whether its value is
    a valid web (`http`/`https`/`ftp`/`ftps`) URL. The `blank` argument is used by
    the `admin` app to know whether to require a value (it does not affect the database).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our model also has a `__str__(self)` method, which is a best practice that helps
    Django convert the model to a string. Django does this in the administrative UI
    and in our own debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Django's ORM automatically adds an autoincrementing `id` column, so we don't
    have to repeat that on all our models. It's a simple example of Django's **Don't
    Repeat Yourself** **(DRY)** philosophy. We'll take a look at more examples as
    we go along.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a model, we will need to create a table in our database that
    matches it. We will use Django to generate a migration for us and then run the
    migration to create a table for our movie model.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Django can create and run migrations for our Django apps, it will not
    create the database and database user for our Django project. To create the database
    and user, we have to connect to the server using an administrator''s account.
    Once we''ve connected we can create the database and user by executing the following
    SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The above SQL statements will create the database and user for our Django project.
    The `GRANT` statement ensures that our mymdb user will have access to the database.
    Then, we set a password on the `mymdb` user (make sure it's the same as in your
    `settings.py` file). Finally, we give the `mymdb` user permission to create new
    databases, which will be used by Django to create a test database when running
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a migration for our app, we''ll need to tell `manage.py` file to
    do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A `migration` is a Python file in our Django app that describes how to change
    the database into a desired state. Django migrations are not tied to a particular
    database system (the same migrations will work across supported databases, unless
    *we* add database-specific code). Django generates migration files that use Django's
    migrations API, which we won't be looking at in this book, but it's useful to
    know that it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that it's *apps* not *projects* that have migrations (since it's *apps*
    that have models).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we tell `manage.py` to migrate our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our table exists in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our database has two tables. The default naming scheme for Django's
    model's tables is `<app_name>_<model_name>`. We can tell `core_movie` is the table
    for the `Movie` model from the `core` app. `django_migrations` is for Django's
    internal use to track the migrations that have been applied. Altering the `django_migrations`
    table directly instead of using `manage.py` is a bad idea, which will lead to
    problems when you try to apply or roll back migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The migration commands can also run without specifying an app, in which case
    it will run on all the apps. Let''s run the `migrate` command without an app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This creates tables to keep track of users, sessions, permissions, and the administrative
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first movie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like Python, Django offers an interactive REPL to try things out. The Django
    shell is fully connected to the database, so we can create, query, update, and
    delete models from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding Django shell session, note that there are a number of attributes
    of `Movie` that we didn''t create:'
  prefs: []
  type: TYPE_NORMAL
- en: '`objects` is the model''s default manager. Managers are an interface for querying
    the model''s table. It also offers a `create()` method for creating and saving
    an instance. Every model must have at least one manager, and Django offers a default
    manager. It''s often advisable to create a custom manager; we''ll see that later
    in the *Adding Person and model relationships* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` is the primary key of the row for this instance. As mentioned in the preceding
    step, Django creates it automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_rating_display()` is a method that Django added because the `rating` field
    was given a tuple of `choices`. We didn''t have to provide `rating` with a value
    in our `create()` call because the `rating` field has a `default` value (`0`).
    The `get_rating_display()` method looks up the value and returns the corresponding
    display value. Django will generate a method like this for each `Field` attribute
    with a `choices` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's create a backend for managing movies using the Django Admin app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating movie admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to quickly generate a backend UI lets users to start building the
    content of the project while the rest of the project is still in development.
    It's a nice feature that helps parallelize progress and avoid a repetitious and
    boring task (read/update views share a lot of functionalities). Providing this
    functionality out of the box is another example of Django's Batteries Included
    philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get Django''s admin app working with our models, we will perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Register our model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a super user who can access the backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the development server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the backend in a browser
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s register our `Movie` model with the admin by editing `django/core/admin.py`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now our model is registered!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a user who can access the backend using `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Django ships with a **development server** that can serve our app, but is not
    appropriate for production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, open it in a browser by navigating to `http://localhost:8000/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5d69a74-d95a-4ac1-bc57-b8f9d2989a81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To access the admin backend, go to `http://localhost:8000/admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e130b85c-4a7d-4ebd-be17-d30cbc878b1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we log in with the credentials, we have to manage users and movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d08ecd07-31c3-428a-b304-eeacc8c92455.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on MOVIES will show us a list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82037e20-995e-44f9-b0dc-c8fa391fc008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the title of the link is the result of our `Movie.__str__` method.
    Clicking on it will give you a UI to edit the movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/458293e5-e7b4-4749-96c4-aee88035d581.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the main admin screen and on the movie list screen, you have links to add
    a new movie. Let''s add a new movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71ba97c6-1365-49c5-a547-f0024f46980b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, our movie list shows both movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6facc9e0-0de1-466b-a991-f78bd53a0662.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a way of letting our team populate the database with movies,
    let's start working on the views for our users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MovieList view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Django gets a request, it uses the path of the request and the `URLConf`
    of the project to match a request to a view, which returns an HTTP response. Django's
    views can be either functions, often referred to as **Function-Based Views** (**FBVs**),
    or classes, often called **Class-Based Views** (**CBVs**). The advantage of CBVs
    is that Django comes with a rich suite of generic views that you can subclass
    to easily (almost declaratively) write views to accomplish common tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a view to list the movies that we have. Open `django/core/views.py` and
    change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`ListView` requires at least a `model` attribute. It will query for all the
    rows of that model, pass it to the template, and return the rendered template
    in a response. It also offers a number of hooks that we may use to replace default
    behavior, which are fully documented.'
  prefs: []
  type: TYPE_NORMAL
- en: How does `ListView` know how to query all the objects in `Movie`? For that,
    we will need to discuss manager and `QuerySet` classes. Every model has a default
    manager. Manager classes are primarily used to query objects by offering methods,
    such as `all()`, that return a `QuerySet`. A `QuerySet` class is Django's representation
    of a query to the database. `QuerySet` has a number of methods, including `filter()`
    (such as a `WHERE` clause in a `SELECT` statement) to limit a result. One of the
    nice features of the `QuerySet` class is that it is lazy; it is not evaluated
    until we try to get a model out of the `QuerySet`. Another nice feature is that
    methods such as `filter()` take *lookup expressions*, which can be field names
    or span across relationship models. We'll be doing this throughout our projects.
  prefs: []
  type: TYPE_NORMAL
- en: All manager classes have an `all()` method that should return an unfiltered
    `Queryset`, the equivalent of writing `SELECT * FROM core_movie;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does `ListView` know that it has to query all the objects in `Movie`?
    `ListView` checks whether it has a `model` attribute, and, if present, knows that
    `Model` classes have a default manager with a `all()` method, which it calls. `ListView`
    also gives us a convention for where to put our template, as follows: `<app_name>/<model_name>_list.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding our first template – movie_list.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django ships with its own template language called the **Django Template language**.
    Django can also use other template languages (for example, Jinja2), but most Django
    projects find using the Django Template language to be efficient and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: In the default configuration that is generated in our `settings.py` file, the
    Django Template language is configured to use `APP_DIRS`, meaning that each Django
    app can have a `templates` directory, which will be searched to find a template.
    This can be used to override templates that other apps use without having to modify
    the third-party apps themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our first template in `django/core/templates/core/movie_list.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Django templates are standard HTML (or whatever text format you wish to use)
    with variables (for example, `object_list` in our example) and tags (for example, `for`
    in our example). Variables will be evaluated to strings by being surrounded with
    `{{ }}`. Filters can be used to help format or modify variables before being printed
    (for example, `yesno`). We can also create custom tags and filters.
  prefs: []
  type: TYPE_NORMAL
- en: A full list of filters and tags is provided in the Django docs ([https://docs.djangoproject.com/en/2.0/ref/templates/builtins/](https://docs.djangoproject.com/en/2.0/ref/templates/builtins/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Django template language is configured in the `TEMPLATES` variable of `settings.py`.
    The `DjangoTemplates` backend can take a lot of `OPTIONS`. In d*evelopment*, it
    can be helpful to add `''string_if_invalid'': ''INVALID_VALUE'',`. Any time Django
    can''t match a variable in a template to a variable or tag, it will print out
    `INVALID_VALUE`, which makes it easier to catch typos. Remember that you should
    not use this setting in *Production*. The full list of options is available in
    Django''s documentation ([https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.django.DjangoTemplates](https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.django.DjangoTemplates)).'
  prefs: []
  type: TYPE_NORMAL
- en: The final step will be to connect our view to a `URLConf`.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests to our view with URLConf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a model, view, and template, we will need to tell Django which
    requests it should route to our `MovieList` View using a URLConf. Each new project
    has a root URLConf that created by Django (in our case it's the `django/config/urls.py`
    file). Django developers have developed the best practice of each app having its
    own URLConf. Then, the root URLConf of a project will include each app's URLConf
    using the `include()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a URLConf for our `core` app by creating a  `django/core/urls.py` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: At its simplest, a URLConf is a module with a `urlpatterns` attribute, which
    is a list of `path` s. A `path` is composed of a string that describes a string,
    describing the path in question and a callable. CBVs are not callable, so the
    base `View` class has a static `as_view()` method that *returns* a callable. FBVs
    can just be passed in as a callback (without the `()` operator, which would execute
    them).
  prefs: []
  type: TYPE_NORMAL
- en: Each `path()` should be named, which is a helpful best practice for when we
    have to reference that path in our template. Since a URLConf can be included by
    another URLConf, we may not know the full path to our view. Django offers a `reverse()`
    function and `url` template tag to go from a name to the full path to a view.
  prefs: []
  type: TYPE_NORMAL
- en: The `app_name` variable sets the app that this `URLConf` belongs to. This way,
    we can reference a named `path` without Django getting confused about other apps
    having a `path` of the same name (for example, `index` is a very common name,
    so we can say `appA:index` and `appB:index` to distinguish between them).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s connect our `URLConf` to the root `URLConf` by changing `django/config/urls.py`
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This file looks much like our file previous `URLConf`, except that our `path()` object
    isn't taking a view but instead the result of the `include()` function. The `include()` function lets
    us prefix an entire `URLConf` with a path and give it a custom namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces let us distinguish between `path` names like the `app_name` attribute
    does, except without modifying the app (for example, a third-party app).
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why we're using `include()` but the Django Admin site is using
    `property`? Both `include()` and `admin.site.urls` return similarly formatted
    3-tuple. However, instead of remembering what each portion of the 3-tuple has
    to have, you should just use `include()`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the development server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django now knows how to route requests to our View, which knows the Models
    that need to be shown and which template to render. We can tell `manage.py` to
    start our development server and view our result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In our browser, go to `http://127.0.0.1:8000/movies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f511e2a-1389-4a8b-949e-ec7496d3e5ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Good job! We made our first page!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created our first model, generated and ran the migration
    for it, and created a view and template so that users can browse it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add a page for each movie.
  prefs: []
  type: TYPE_NORMAL
- en: Individual movie pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our project layout, we can move more quickly. We're already
    tracking information for each movie. Let's create a view that will show that information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add movie details, we''ll need to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `MovieDetail` view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `movie_detail.html` template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reference to our `MovieDetail` view in our `URLConf`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the MovieDetail view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like Django provides us with a `ListView` class to do all the common tasks
    of listing models, Django also provides a `DetailView` class that we can subclass
    to create a view showing the details of a single `Model`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our view in `django/core/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A `DetailView` requires that a `path()` object include either a `pk` or `slug`
    in the `path` string so that `DetailView` can pass that value to the `QuerySet` to
    query for a specific model instance. A **slug** is a short URL-friendly label
    that is often used in content-heavy sites, as it is SEO friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the movie_detail.html template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the View, let's make our template.
  prefs: []
  type: TYPE_NORMAL
- en: Django's Template language supports template inheritance, which means that you
    can write a template with all the look and feel for your website and mark the `block` sections
    that other templates will override. This lets us to create the look and feel of
    the entire website without having to edit each template. Let's use this to create
    a base template with MyMDB’s branding and look and feel and then add a Movie Detail
    template that inherits from the base template.
  prefs: []
  type: TYPE_NORMAL
- en: 'A base template shouldn''t be tied to a particular app, so let''s make a general
    templates directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Django doesn''t know to check our `templates` directory yet, so we will need
    to update the configuration in our `settings.py` file. Find the line that starts
    with `TEMPLATES` and change the configuration to list our `templates` directory
    in the `DIRS` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The only change we've made is that we added our new `templates` directory to
    the list under the `DIRS` key. We have avoided hardcoding the path to our `templates`
    directory using Python's `os.path.join()` function and the already configured
    `BASE_DIR`. `BASE_DIR` is set at runtime to the path of the project. We don't
    need to add `django/core/templates` because the `APP_DIRS` setting tells Django
    to check each app for the `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Although it's very convenient that `settings.py` is the Python file where we
    can use `os.path.join` and all of Python, be careful not to get too clever. `settings.py` needs
    to be easy to read and understand. There's nothing worse than having to debug
    your `settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a base template in `django/templates/base.html` that has a main
    column and sidebar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this HTML is actually bootstrap (HTML/CSS framework) boilerplate, but
    we do have a few new Django tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{% block title %}MyMDB{% endblock %}`: This creates a block that other templates
    can replace. If the block is not replaced, the contents from the parent template
    will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`href="{% url ''core:MovieList'' %}"`: The `url` tag will produce a URL path
    for the named `path`. URL names should be referenced as `<app_namespace>:<name>`;
    in our case, `core` is the namespace of the core app (per `django/core/urls.py`),
    and `MovieList` is the name of the `MovieList` view''s URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This lets us create a simple template in `django/core/templates/core/movie_detail.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This template has a lot less HTML in it because `base.html` already has that.
    All `MovieDetail.html` has to do is provide values to the blocks that `base.html`
    defines. Let''s take a look at some new tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{% extends ''base.html'' %}`: If a template wants to extend another template
    the first line must be an `extends` tag. Django will look for the base template
    (which can `extend` another template) and execute it first, then replace the blocks.
    A template that extends another cannot have content outside of `block`s because
    it''s ambiguous where to put that content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{ object.title }} - {{ block.super }}`: We reference `block.super` inside the `title`
    template `block`. `block.super` returns the contents of the `title` template `block`
    in the base template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{ object.get_rating_display }}`: The Django Template language doesn''t use
    `()` to execute the method, just referencing it by name will execute the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding MovieDetail to core.urls.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we add our `MovieDetail` view to `core/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `MovieDetail` and `MovieList` `path()` calls both look almost the same,
    except for the `MovieDetail` string that has a named parameter. A `path` route
    string can include angle brackets to give a parameter a name (for example, `<pk>`)
    and even define a type that the parameter's content must conform to (for example,
    `<int:pk>` will only match values that parse as an `int`). These named sections
    are captured by Django and passed to the view by name. `DetailView` expects a `pk`
    (or `slug`) argument and uses it to get the correct row from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `python manage.py runserver` to start the `dev` server and take
    a look at what our new template looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3094cb49-5280-4a44-a4b0-437e42dfc6be.png)'
  prefs: []
  type: TYPE_IMG
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we've created a new view, `MovieDetail`, learned about template
    inheritance, and how to pass parameters from a URL path to our view.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll add pagination to our `MovieList` view to prevent it from querying
    the entire database each time.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination and linking movie list to movie details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll update our movie list to provide a link to each movie
    and to have pagination to prevent our entire database being dumped into one page.
  prefs: []
  type: TYPE_NORMAL
- en: Updating MovieList.html to extend base.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our original `MovieList.html` was a pretty sparse affair. Let''s update it
    to look nicer using our `base.html` template and the bootstrap CSS it provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We're also seeing the `url` tag being used with a named argument `pk` because
    the `MovieDetail` URL requires a `pk` argument. If there was no argument provided,
    then Django would raise a `NoReverseMatch` exception on rendering, resulting in
    a `500` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0cc7929-c9da-46a7-afba-de85b9d7d5ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another problem with our current view is that it's not ordered. If the database
    is returning an unordered query, then pagination won't help navigation. What's
    more, there's no guarantee that each time the user changes pages that the content
    will be consistent, as the database may return a differently ordered result set
    for each time. We need our query to be ordered consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering our model also makes our lives as developers easier too. Whether using
    a debugger, writing tests, or running a shell ensuring that our models are returned
    in a consistent order can make troubleshooting simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Django model may optionally have an inner class called `Meta`, which lets
    us specify information about a Model. Let''s add a `Meta` class with an `ordering`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`ordering` takes a list or tuple of, usually, strings that are field names,
    optionally prefixed by a `-` character that denotes descending order. `(''-year'',
    ''title'')` is the equivalent of the SQL clause `ORDER BY year DESC, title`.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding `ordering` to a Model's `Meta` class will mean that `QuerySets` from
    the model's manager will be ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Adding pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our movies are always ordered the same way, let's add pagination. A
    Django `ListView` already has built-in support for pagination, so all we need
    to do is take advantage of it. **Pagination** is controlled by the `GET` parameter
    `page` that controls which page to show.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add pagination to the bottom of our `main` template `block`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at some important points of our `MovieList` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`page_obj` is of the `Page` type, which knows information about this page of
    results. We use it to check whether there is a next/previous page using `has_next()`/`has_previous()`
    (we don''t need to put `()` in the Django template language, but `has_next()`
    is a method, not a property). We also use it to get the `next_page_number()`/`previous_page_number()`.
    Note that it is important to use the `has_*()` method to check for the existence
    of  the next/previous page numbers before retrieving them. If they don''t exist
    when retrieved, `Page` throws an `EmptyPage` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object_list` continues to be available and hold the correct values. Even though
    `page_obj` encapsulates the results for this page in `page_obj.object_list`, `ListView`
    does the convenient work of ensuring that we can continue to use `object_list`
    and our template doesn''t break.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have the pagination working!
  prefs: []
  type: TYPE_NORMAL
- en: 404 – for when things go missing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a couple of views that can't function if given the wrong value in
    the URL (the wrong `pk` will break `MovieDetail`; the wrong `page` will break
    `MovieList`); let’s plan for that by handling `404` errors. Django offers a hook
    in the root URLConf to let us use a custom view for `404` errors (also for `403`,
    `400`, and `500`—all following the same names scheme). In your root `urls.py` file,
    add a variable called `handler404` whose value is a string Python path to your
    custom view.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can continue to use the default `404` handler view and just write
    a custom template. Let''s add a `404` template in `django/templates/404.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Even if another app throws a `404` error, this template will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, if you''ve got an unused URL such as `http://localhost:8000/not-a-real-page`,
    you won''t see our custom 404 template because Django''s `DEBUG` settings is `True`
    in `settings.py`. To make our 404 template visible, we will need to change the
    `DEBUG` and `ALLOWED_HOSTS` settings in `settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`ALLOWED_HOSTS` is a setting that restricts which `HOST` values in an HTTP
    request Django will respond to. If `DEBUG` is `False` and a `HOST` does not match
    an `ALLOWED_HOSTS` value, then Django will return a `400` error (you can customize
    both the view and template for this error as described in the preceding code).
    This is a security feature that protects us and will be discussed more in our
    chapter on security.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our project is configured, let''s run the Django development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With it running, we can use our web browser to open [http://localhost:8000/not-a-real-page](http://localhost:8000/not-a-real-page).
    Our results should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6681144e-cf38-4fe2-9d54-eb011487af6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing our view and template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we now have some logic in our `MoveList` template, let's write some tests.
    We'll talk a lot more about testing in the [Chapter 8](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml),
    *Testing Answerly*. However, the basics are simple and follow the common XUnit
    pattern of the `TestCase` classes holding test methods that make assertions.
  prefs: []
  type: TYPE_NORMAL
- en: For Django's `TestRunner` to find a test, it must be in the `tests` module of
    an installed app. Right now, that means `tests.py`, but, eventually, you may wish
    to switch to a directory Python module (in which case, prefix your test filenames
    with `test` for the `TestRunner` to find them).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a test that performs the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: If there's more than 10 movies, then pagination controls should be rendered
    in the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If there''s more than 10 movies and we don''t provide `page` `GET` parameters,
    consider the following things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `page_is_last` context variable should be `False`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `page_is_first` context variable should be `True`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first item in the pagination should be marked as active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is our `tests.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at some interesting points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class MovieListPaginationTestCase(TestCase)`: `TestCase` is the base class
    for all Django tests. It has a number of conveniences built in, including a number
    of convenient assert methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def setUp(self)`: Like most XUnit testing frameworks, Django''s `TestCase`
    class offers a `setUp()` hook that is run before each test. A `tearDown()` hook
    is also available if needed. The database is cleaned up between each test, so
    we don''t need to worry about deleting any models we added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def testFirstPage(self):`: A method is a test if its name is prefixed with
    `test`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie_list_path = reverse(''core:MovieList'')`: `reverse()` was mentioned
    before and is the Python equivalent of the `url` Django template tag. It will
    resolve the name into a path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request = RequestFactory().get(path=movie_list_path)`: `RequestFactory` is
    a convenient factory for creating fake HTTP requests. A `RequestFactory` has convenience
    methods for creating `GET`, `POST`, and `PUT` requests by its convenience methods
    named after the verb (for example, `get()` for `GET` requests). In our case, the
    `path` object provided doesn''t matter, but other views may want to inspect the
    path of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.assertEqual(200, response.status_code)`: This asserts that the two arguments
    are equal. A response''s `status_code` to check success or failure (`200` being
    the status code for success—the one code you never see when you browse the web).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.assertTrue(response.context_data[''is_paginated''])`: This asserts that
    the argument evaluates to `True`. `response` exposes the context that is used
    in rendering the template. This makes finding bugs much easier as you can quickly
    check actual values used in rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.assertInHTML(`: `assertInHTML` is one of the many convenient methods
    that Django provides as part of its **Batteries Included** philosophy. Given a
    valid HTML string `needle` and valid HTML string `haystack`, it will assert that
    `needle` is in `haystack`. The two strings need to be valid HTML because Django
    will parse them and examine whether one is inside the other. You don''t need to
    worry about spacing or the order of attributes/classes. It''s a very convenient
    assertion when you try to ensure that templates are working right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run tests, we can use `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can be confident that we've got pagination working right.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Person and model relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add relationships between models to our project. People's
    relationship to movies can create a complex data model. The same person can be
    the actor, writer, and director (for example, *The Apostle* (1997) written, directed,
    and starring Robert Duvall). Even leaving out the crew and production teams and
    simplifying a bit, the data model will involve a one-to-many relationship using
    a `ForiengKey` field, a many-to-many relationship using a `ManyToManyField`, and
    a class that adds extra information about a many-to-many relationship using a
    `through` class in a `ManyToManyField`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will do the following things step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Person` model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ForeignKey` field from `Movie` to `Person` to track the director
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ManyToManyField` from `Movie` to `Person` to track the writers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ManyToManyField` with a `through` class (`Actor`) to track who performed
    and in what role in a Movie
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the migration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the director, writer, and actors to the movie details template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `PersonDetail` view to the list that indicates what movies a Person has
    directed, written, and performed in
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a model with relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will need a `Person` class to describe and store a person involved
    in a movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In `Person`, we also see a new field (`DateField`) and a new parameter for fields
    (`null`).
  prefs: []
  type: TYPE_NORMAL
- en: '`DateField` is used for tracking date-based data, using the appropriate column
    type on the database (`date` on Postgres) and `datetime.date` in Python. Django
    also offers a `DateTimeField` to store the date and time.'
  prefs: []
  type: TYPE_NORMAL
- en: All fields support the `null` parameter (`False` by default), which indicates
    whether the column should accept `NULL` SQL values (represented by `None` in Python).
    We mark `died` as supporting `null` so that we can record people as living or
    dead. Then, in the `__str__()` method we print out a different string representation
    if someone is alive or dead.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the `Person` model that can have various relationships with `Movies`.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of relationship fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's ORM has support for fields that map relationships between models, including
    one-to-many, many-to-many, and many-to-many with an intermediary model.
  prefs: []
  type: TYPE_NORMAL
- en: When two models have a one-to-many relationship, we use a `ForeignKey` field,
    which will create a column with a **Foreign Key** (**FK**) constraint (assuming
    that there is database support) between the two tables. In the model without the
    `ForeignKey` field, Django will automatically add a `RelatedManager` object as
    an instance attribute. The `RelatedManager` class makes it easier to query for
    objects in a relationship. We'll take a look at examples of this in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: When two models have a many-to-many relationship, either (but not both) of them
    can get the `ManyToManyField()`; Django will create a `RelatedManager` on the
    other side for you. As you may know, relational databases cannot actually have
    a many-to-many relationship between two tables. Rather, relational databases require
    a *bridging* table with foreign keys to each of related tables. Assuming that
    we don’t want to add any attributes describing the relationship, Django will create
    and manage this bridging table for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want extra fields to describe a many-to-many relationship (for
    example, when it started or ended); for that, we can provide a `ManyToManyField`
    with a `through` model (sometimes called an association class in UML/OO). This
    model will have a `ForeignKey` to each side of the relationship and any extra
    fields we want.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create an example of each of these, as we go along adding directors, writers,
    and actors into our `Movie` model.
  prefs: []
  type: TYPE_NORMAL
- en: Director – ForeignKey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our model, we will say that each movie can have one director, but each director
    can have directed many movies. Let''s use the `ForiengKey` field to add a director
    to our movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at our new field line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`to=''Person''`: All of Django''s relationship fields can take a string reference
    as well as reference to the related model. This argument is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_delete=models.SET_NULL`: Django needs instruction on what to do when the
    referenced model (instance/row) is deleted. `SET_NULL` will set the `director` field
    of all the `Movie`  model instances directed by the deleted `Person` to `NULL`. If
    we wanted to cascade deletes we would use the `models.CASCADE` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`related_name=''directed''`: This is an optional argument that indicates the
    name of the `RelatedManager` instance on the other model (which lets us query
    all the `Movie` model instances a `Person` directed). If `related_name` were not
    provided, then `Person` would get an attribute called `movie_set` (following the `<model
    with FK>_set` pattern). In our case, we will have multiple different relationships
    between `Movie` and `Person` (writer, director, and actors), so `movie_set` would
    become ambiguous, and we must provide a `related_name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is also the first time we're adding a field to an existing model. When
    doing so, we have to *either* add `null=True` or offer a `default` value. If we
    do not, then the migration will force us to. This requirement exists because Django
    has to assume that there are existing rows in the table (even if there aren't)
    when the migration is run. When a database adds the new column, it needs to know
    what it should insert into existing rows. In the case of the `director` field,
    we can accept that it may sometimes be `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: We have now added a field to `Movie` and a new attribute to `Person` instances
    called `directed` (of the `RelatedManager` type). `RelatedManager` is a very useful
    class that is like a model’s default Manager, but automatically manages the relationship
    across the two models.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at `person.directed.create()` and compare it to `Movie.objects.create()`.
    Both methods will create a new `Movie`, but `person.directed.create()` will make
    sure that the new `Movie` has `person` as its `director`. `RelatedManager` also
    offers the `add` and `remove` methods so that we can add a `Movie` to a `directed`
    set of `Person` by calling `person.directed.add(movie)`. There's also a `remove()`
    method that works similarly, but removes a model from the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Writers – ManyToManyField
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two models may also have a many-to-many relationship, for example, a person
    may write many movies and a movie may be written by many people. Next, we''ll
    add a `writers` field to our `Movie` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: A `ManyToManyField` established a many-to-many relationship and acts like a
    `RelatedManager`, permitting users to query and create models. We again use the `related_name`
    to avoid giving `Person` a `movie_set` attribute and instead give it a `writing_credits`
    attribute that will be a `RelatedManager`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a `ManyToManyField`, both sides of the relationship have `RelatedManager`
    s so that `person.writing_credits.add(movie)` has the same effect as writing `movie.writers.add(person)`.
  prefs: []
  type: TYPE_NORMAL
- en: Role – ManyToManyField with a through class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last example of a relationship field we'll look at is used when we want
    to use an intermediary model to describe the relationship between two other models
    that have a many-to-many relationship. Django lets us do this by creating a model
    that describes the *join table* between the two models in a many-to-many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will create a many-to-many relationship between `Movie` and
    `Person` through `Role`, which will have a `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This looks like the preceding `ManyToManyField`, except we have both a `to`
    (referencing `Person` as before) argument and a `through` (referencing `Role`)
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `Role` model looks much like one would design a *join table*; it has a `ForeignKey`
    to each side of the many-to-many relationship. It also has an extra field called `name`
    to describe the role.
  prefs: []
  type: TYPE_NORMAL
- en: '`Role` also has a unique constraint on it. It requires that `movie`, `person`,
    and `billing` all to be unique together; setting the `unique_together` attribute
    on the `Meta` class of `Role` will prevent duplicate data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This user of `ManyToManyField` will create four new `RelatedManager` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '`movie.actors` will be a related manager to `Person`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`person.acting_credits` will be a related manager to `Movie`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie.role_set` will be a related manager to `Role`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`person.role_set` will be a related manager to `Role`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use any of the managers to query models but only the `role_set` managers
    to create models or modify relationships because of the intermediary class. Django
    will throw an `IntegrityError` exception if you try to run `movie.actors.add(person)`
    because there’s no way to fill in the value for `Role.name`. However, you can
    write `movie.role_set.add(person=person, name='Hamlet')`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can generate a migration for our new models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can run our migration so that the changes get applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's make our movie pages link to the people in the movies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PersonView and updating MovieList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a `PersonDetail` view that our `movie_detail.html` template can
    link to. To create our view, we''ll go through a four-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a manager to limit the number of database queries
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create our view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create our template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a URL that references our view
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a custom manager – PersonManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `PersonDetail` view will list all the movies in which a `Person` is acting,
    writing, or directing credits. In our template, we will print out the name of
    each film in each credit (and `Role.name` for the acting credits). To avoid sending
    a flood of queries to the database, we will create new managers for our models
    that will return smarter `QuerySet` s.
  prefs: []
  type: TYPE_NORMAL
- en: In Django, any time we access a property across a relationship, then Django
    will query the database to get the related item (in the case of looping over each
    item `person.role_set.all()`, one for each related `Role`). In the case of a `Person`
    who is in *N* movies, this will result in *N* queries to the database. We can
    avoid this situation with the `prefetch_related()` method (later we will look
    at `select_related()` method). Using the `prefetch_related()` method, Django will
    query all the related data across a single relationship in a single additional
    query. However, if we don't end up using the prefetched data, querying for it
    will waste time and memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `PersonManager` with a new method, `all_with_prefetch_movies()`,
    and make it the default manager for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our `PersonManager` will still offer all the same methods as the default because
    `PersonManager` inherits from `models.Manager`. We also define a new method, which
    uses `get_queryset()` to get a `QuerySet`, and tells it to prefetch the related
    models. `QuerySets` are lazy, so no communication with the database happens until
    the query set is evaluated (for example by, iteration, casting to a bool, slicing,
    or evaluated by an `if` statement). `DetailView` won't evaluate the query until
    it uses `get()` to get the model by PK.
  prefs: []
  type: TYPE_NORMAL
- en: The `prefetch_related()` method takes one or more *lookups*, and after the initial
    query is done, it automatically queries those related models. When you access
    a model related to the one from your `QuerySet`, Django won't have to query it,
    as you will already have it prefetched in the `QuerySet.`
  prefs: []
  type: TYPE_NORMAL
- en: 'A *lookup* is what a Django `QuerySet` takes to express a field or `RelatedManager`
    in a model. A lookup can even span across relationships by separating the name
    of the relationship field (or `RelatedManager`) and the related models field with
    two underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding call will return a `QuerySet` for all the `Movie`  model instances
    in which Morgan Freeman has been an actor.
  prefs: []
  type: TYPE_NORMAL
- en: In our `PersonManager`, we're telling Django to prefetch all the movies that
    a `Person` has directed, written, and had a role in as well as prefetch the roles
    themselves. Using the `all_with_prefetch_movies()` method will result in a constant
    number of queries no matter how prolific the `Person` has been.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PersonDetail view and template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can write a very thin view in `django/core/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This `DetailView` is different because we're not providing it with a `model`
    attribute. Instead, we're giving it a `QuerySet` object from our `PersonManager` class. When `DetailView` uses
    the `filter()` of `QuerySet` and `get()` methods to retrieve the model instance,
    `DetailView` will derive the name of the template from the model instance's class
    name just as if we had provided model class as an attribute on the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our template in `django/core/templates/core/person_detail.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Our template doesn't have to do anything special to make use of our prefetching.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should give the `MovieDetail` view the same benefit that our `PersonDetail`
    view received.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MovieManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a `MovieManager` in `django/core/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `MovieManager` introduces another new method, called `select_related()`.
    The `select_related()` method is much like the `prefetch_related()` method but
    it is used when the relation leads to only one related model (for example, with
    a `ForeignKey` field). The `select_related()` method works by using a `JOIN` SQL
    query to retrieve the two models in one query. Use `prefetch_related()` when the
    relation *may* lead to more than one model (for example, either side of a `ManyToManyField` or
    a `RelatedManager` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can update our `MovieDetail` view to use the query set instead of the
    model directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The view renders exactly the same, but it won't have to query the database each
    time a related  `Person` model instance is required, as they were all prefetched.
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we created the `Person` model and established a variety of
    relationships between the `Movie` and `Person` models. We created a one-to-many
    relationship with a `ForeignKey` field class, a many-to-many relationship using
    the `ManyToManyField` class,  and used an intermediary (or association) class
    to add extra information for a many-to-many relationship by providing a `through`
    model to a `ManyToManyField`. We also created a `PersonDetail` view to show a
    `Person` model instance and used a custom model manager to control the number
    of queries Django sends to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created our Django project and started our `core` Django
    app. We saw how to use Django's Model-View-Template approach to create easy-to-understand
    code. We created concentrated database logic near the model, pagination in views,
    and HTML in templates following the Django best practice of *fat models, thin
    views,* and *dumb templates*.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to add users who can register and vote on their favorite movies.
  prefs: []
  type: TYPE_NORMAL
