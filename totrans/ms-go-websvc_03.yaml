- en: Chapter 3. Routing and Bootstrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the last two chapters, you should be comfortable with creating an API
    endpoint, the backend database to store your most pertinent information, and mechanisms
    necessary to route and output your data via HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: For the last point, other than our most basic example, we've yielded to a library
    for handling our URL multiplexers. This is the Gorilla web toolkit. As fantastic
    as this library (and its related frameworks) is, it's worth getting to know how
    to handle requests directly in Go, particularly to create more robust API endpoints
    that involve conditional and regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: While we've briefly touched on the importance of header information for the
    web service consumer, including status codes, we'll start digging into some important
    ones as we continue to scale our application.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of controlling and dictating state is critical for a web service,
    especially (and paradoxically) in stateless systems such as REST. We say this
    is a paradox because while the server should provide little information about
    the state of the application and each request, it's important to allow the client
    to understand this based on the absolute minimal and standard mechanisms that
    we're afforded.
  prefs: []
  type: TYPE_NORMAL
- en: For example, while we may not give a page number in a list or a GET request,
    we want to make sure that the consumer knows how to navigate to get more or previous
    result sets from our application.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we may not provide a hard error message although it exists, but our
    web services should be bound to some standardization as it relates to feedback
    that we can provide in our headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending Go's multiplexer to handle more complex requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at more advanced requests in Gorilla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing RPC and web sockets in Gorilla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors in our application and requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also create a couple of consumer-friendly interfaces for our web application,
    which will allow us to interact with our social network API for requests that
    require `PUT`/`POST`/`DELETE`, and later on, `OPTIONS`.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be comfortable with writing routers in
    Go as well as extending them to allow more complex requests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom routers in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, until this point, we've focused on using the Gorilla Web
    Toolkit for handling URL routing and multiplexers, and we've done that primarily
    due to the simplicity of the `mux` package within Go itself.
  prefs: []
  type: TYPE_NORMAL
- en: By simplicity, we mean that pattern matching is explicit and doesn't allow for
    wildcards or regular expressions using the `http.ServeMux` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking directly into the following setup of the `http.ServeMux` code, you
    can see how this can use a little more nuance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The key part here is the `!pathMatch` function, which calls another method
    that specifically checks whether a path literally matches a member of a `muxEntry`
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, one of the best things about having access to this code is that it
    is almost inconsequential to take it and expand upon it.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of doing this. The first is to write your own package, which
    will serve almost like an extended package. The second is to modify the code directly
    in your `src` directory. This option comes with the caveat that things could be
    replaced and subsequently broken on upgrade. So, this is an option that will fundamentally
    break the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we'll go with the first option. So, how can we extend the
    `http` package? The short answer is that you really can't without going into the
    code directly, so we'll need to create our own that inherits the most important
    methods associated with the various `http` structs with which we'll be dealing.
  prefs: []
  type: TYPE_NORMAL
- en: To start this, we'll need to create a new package. This should be placed in
    your Golang `src` directory under the domain-specific folder. In this case, we
    mean domain in the traditional sense, but by convention also in the web directory
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve ever executed a `go get` command to grab a third-party package,
    you should be familiar with these conventions. You should see something like the
    following screenshot in the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing custom routers in Go](img/1304OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our case, we'll simply create a domain-specific folder that will hold our
    packages. Alternatively, you can create projects in your code repository of choice,
    such as GitHub, and import the packages directly from there via `go get`.
  prefs: []
  type: TYPE_NORMAL
- en: For now though, we'll simply create a subfolder under that directory, in my
    case `nathankozyra.com`, and then a folder called `httpex` (a portmanteau of `http`
    and `regex`) for the `http` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your installation and operating system, your import directory may
    not be immediately apparent. To quickly see where your import packages should
    be, run the `go env` internal tool. You will find the directory under the `GOPATH`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you find your `go get` commands return the `GOPATH not set` error, you'll
    need to export that `GOPATH` variable. To do so, simply enter `export` `GOPATH=/your/directory`
    (for Linux or OS X). On Windows, you'll need to set an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: One final caveat is that if you're using OS X and have difficulty in getting
    packages via `go get`, you may need to include the `-E` flag after your `sudo`
    call to ensure that you're using your local user's variables and not those of
    the root.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of saving space, we won''t include all of the code here that is
    necessary to retrofit the `http` package that allows regular expressions. To do
    so, it''s important to copy all of the `ServeMux` structs, methods, and variables
    into your `httpex.go` file. For the most part, we''ll replicate everything as
    is. You''ll need a few important imported packages; this is what your file should
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The critical change happens with the `pathMatch()` function, which previously
    required a literal match of the longest possible string. Now, we will change any
    `==` equality comparisons to regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If all of this seems like reinventing the wheel, the important takeaway is that—as
    with many things in Go—the core packages provide a great starting point for the
    most part, but you shouldn't hesitate to augment them when you find that certain
    functionality is lacking.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one other quick and dirty way of rolling your own `ServeMux` router,
    and that''s by intercepting all requests and running a regular expression test
    on them. Like the last example, this isn''t ideal (unless you wish to introduce
    some unaddressed efficiencies), but this can be used in a pinch. The following
    code illustrates a very basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we include the `regexp` package so that we can do regular expression
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of giving each match a specific handler, we test within a single
    handler for the `testing[3 digits]` matches and then react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we tell the client that there''s nothing unless they match the
    pattern. This pattern will obviously work for a `/testing123` request and fail
    for anything that doesn''t match this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we start our web server.
  prefs: []
  type: TYPE_NORMAL
- en: Using more advanced routers in Gorilla
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've played around a bit with extending the multiplexing of the built-in
    package, let's see what else Gorilla has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to simple expressions, we can take a URL parameter and apply it
    to a variable to be used later. We did this in our earlier examples without providing
    a lot of explanation of what we were producing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how we might parlay an expression into a variable for
    use in an `httpHandler` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both could be approached as `GET` requests for a specific entity within our
    `users` table. We could handle either with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we need to preserve the last value for use in our query. To do so,
    Gorilla allows us to set that expression to a key in a map. In this case, we''d
    address this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This would allow us to extract that value in our handler via the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll note that we used `"key"` here instead of an expression. You can do
    both here, which allows you to set a regular expression to a key. For example,
    if our user key variable consisted of letters, numbers, and dashes, we could set
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in our `UserRetrieve` function, we''d be able to pull that key (or any
    other that we added to the `mux` package) directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using Gorilla for JSON-RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall from [Chapter 2](ch02.html "Chapter 2. RESTful Services in Go"),
    *RESTful Services in Go*, that we touched on RPC briefly with the promise of returning
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: With REST as our primary method for delivery of the web service, we'll continue
    to limit our knowledge of RPC and JSON-RPC. However, this is a good time to demonstrate
    how we can create RPC services very quickly with the Gorilla toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we''ll accept a string and return the number of total characters
    in the string via an RPC message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One important note about the RPC method is that it needs to be exported, which
    means that a function/method must start with a capital letter. This is how Go
    treats a concept that is vaguely analogous to `public`/`private`. If the RPC method
    starts with a capital letter, it is exported outside of that package's scope,
    otherwise it's essentially `private`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Gorilla for JSON-RPC](img/1304OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, if you called the method `stringService` instead of `StringService`,
    you'd get the response **can't find service stringService**.
  prefs: []
  type: TYPE_NORMAL
- en: Using services for API access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the issues we'll quickly encounter when it comes to building and testing
    our web service is handling the `POST`/`PUT`/`DELETE` requests directly to ensure
    that our method-specific requests do what we expect them to.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways that exist for handling this easily without having to move
    to another machine or build something elaborate.
  prefs: []
  type: TYPE_NORMAL
- en: The first is our old friend cURL. By far the most popular method for making
    networked requests over a variety of protocols, cURL is simple and supported by
    almost any language you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no single built-in cURL component in Go. However, this largely follows
    the ethos of slim, integrated language design that Go's developers seem to be
    most interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, a few third-party solutions you can look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go-curl`, a binding by ShuYu Wang is available at [https://github.com/andelf/go-curl](https://github.com/andelf/go-curl).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go-av`, a simpler method with `http` bindings is available at [https://github.com/go-av/curl](https://github.com/go-av/curl).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purpose of testing things out though, we can use cURL very simply and
    directly from the command line. It's simple enough, so constructing requests should
    be neither difficult nor arduous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example call we can make to our create method at `/api/users` with
    a `POST` `http` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Keeping in mind that we already have this user in our database and it''s a
    unique database field, we return an error by simply modifying our `UserCreate`
    function. Note that in the following code, we change our response to a new `CreateResponse`
    struct, which for now includes only an error string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we call it. If we get an error from our database, we''ll include it
    in our response, at least for now; shortly, we''ll look at translations. Otherwise,
    it will be blank and we can (for now) assume that the user was successfully created.
    We say *for now* because we''ll need to provide more information to our client
    depending on whether our request succeeds or fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how it looks if we try to create a duplicate user via a cURL request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using a simple interface for API access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way in which we can swiftly implement an interface for hitting our API
    is through a simple web page with a form. This is, of course, how many APIs are
    accessed—directly by the client instead of being handled server-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'And although we''re not suggesting this is the way our social network application
    should work in practice, it provides us an easy way to visualize the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When this is rendered, we'll have a quick basic visual form for getting data
    into our API as well as returning valuable error information and feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Due to cross-domain restrictions, you may wish to either run this from the
    same port and domain as our API server, or include this header with every request
    from the server file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, `http://localhost:9000` represents the originating server for the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our rendered HTML presentation looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a simple interface for API access](img/1304OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Returning valuable error information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we returned errors in our last request, we simply proxied the MySQL error
    and passed it along. This isn't always helpful though, because it seems to require
    at least some familiarity with MySQL to be valuable information for the client.
  prefs: []
  type: TYPE_NORMAL
- en: Granted, MySQL itself has a fairly clean and straightforward error messaging
    system, but the point is it's specific to MySQL and not our application.
  prefs: []
  type: TYPE_NORMAL
- en: What if your client doesn't understand what a "duplicate entry" means? What
    if they don't speak English? Will you translate the message or will you tell all
    of your dependencies what language to return with each request? Now you can see
    why this might get arduous.
  prefs: []
  type: TYPE_NORMAL
- en: Most APIs have their own system for error reporting, if for no other reason
    than to have control over messaging. And while it's ideal to return the language
    based on the request header's language, if you can't, then it's helpful to return
    an error code so that you (or another party) can provide a translation down the
    road.
  prefs: []
  type: TYPE_NORMAL
- en: And then there are the most critical errors which are returned via HTTP status
    codes. By default, we're producing a few of these with Go's `http` package, as
    any request to an invalid resource will provide a standard 404 **not found** message.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are also REST-specific error codes that we''ll get into shortly.
    For now, there''s one that''s relevant to our error: 409.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As per W3C''s RFC 2616 protocol specification, we can send a 409 code that
    indicates a conflict. Here''s what the spec states:'
  prefs: []
  type: TYPE_NORMAL
- en: The request could not be completed due to a conflict with the current state
    of the resource. This code is only allowed in situations where it is expected
    that the user might be able to resolve the conflict and resubmit the request.
    The response body SHOULD include enough information for the user to recognize
    the source of the conflict. Ideally, the response entity would include enough
    information for the user or user agent to fix the problem; however, that might
    not be possible and is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Conflicts are most likely to occur in response to a `PUT` request. For example,
    if versioning were being used and the entity being `PUT` included changes to a
    resource which conflict with those made by an earlier (third-party) request, the
    server might use the 409 response to indicate that it can't complete the request.
    In this case, the response entity would likely contain a list of the differences
    between the two versions in a format defined by the response `Content-Type`.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's first detect an error that indicates an existing record
    and prevents the creation of a new record.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Go does not return a specific database error code along with
    the error, but at least with MySQL it's easy enough to extract the error if we
    know the pattern used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following code, we''ll construct a parser that will split a MySQL
    error string into its two components and return an integer error code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also augment our `CreateResponse` struct with an error status code,
    represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also take our MySQL response and message it into a `CreateResponse`
    struct by changing our error response behavior in the `UsersCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll note the `dbErrorParse` function, which we defined earlier. We take
    the results from this and inject it into an `ErrorMessages` function that returns
    granular information about any given error and not database errors exclusively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For now, this is pretty lean, dealing with a single type of error. We'll expand
    upon this as we go along and add more error handling mechanisms and messages (as
    well as taking a stab at translation tables).
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one last thing we need to do with regard to the HTTP status code.
    The easiest way to set the HTTP status code is through the `http.Error()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we put this in our error conditional block, we''ll return any status code
    we receive from the `ErrorMessages()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this again with cURL and the verbose flag (`-v`) will give us additional
    information about our errors, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Returning valuable error information](img/1304OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling binary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll need to create a new field in MySQL to accommodate the image
    data. In the following case, we can go with `BLOB` data, which accepts large amounts
    of arbitrary binary data. For this purpose, we can assume (or enforce) that an
    image should not exceed 16 MB, so `MEDIUMBLOB` will handle all of the data that
    we throw at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With our image column now in place, we can accept data. Add another field to
    our form for image data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And in our server, we can make a few quick modifications to accept this. First,
    we should get the file data itself from the form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to read this entire file and convert it to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll pack it into a `base64` encoded text representation of our image
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And then finally, we prepend our query with the inclusion of the new user image
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll come back to a couple of these SQL statements that are assembled here
    in our last chapter on security.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three chapters in and we've got the skeleton of a simple social networking application
    that we can replicate in REST as well as JSON-RPC. We've also spent some time
    on properly relaying errors to the client in REST.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, *Designing APIs in Go*, we'll really begin to flesh out
    our social network as well as explore other Go packages that will be relevant
    to have a strong, robust API.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we'll bring in a few other libraries and external services to help
    give verbose responses to connections between our users and their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also start to experiment with web sockets for a more interactive client
    experience on the Web. Finally, we'll handle binary data to allow our clients
    to upload images through our API.
  prefs: []
  type: TYPE_NORMAL
