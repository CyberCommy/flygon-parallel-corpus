- en: Chapter 10. Supercharging Your React Architecture with Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of building a web application has one quality that somewhat mirrors
    the process of evolution of life itself—it never ends. Unlike building a bridge,
    building a web application has no natural state that represents the end of the
    development process. It's up to you or your team to decide when you should stop
    the development process and release what you've already built.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we've reached the point at which we can stop developing Snapterest.
    Right now, we have a small React.js application with a basic functionality that
    simply works.
  prefs: []
  type: TYPE_NORMAL
- en: Isn't that enough?
  prefs: []
  type: TYPE_NORMAL
- en: Not exactly. Earlier in this book, we discussed how the process of maintaining
    your web application is much more expensive in terms of time and effort than the
    process of developing it. If we choose to finish developing Snapterest at its
    current state, we'll also choose to start the process of maintaining it.
  prefs: []
  type: TYPE_NORMAL
- en: Are we ready to maintain Snapterest? Do we know if its current state will allow
    us to introduce new functionality later on without any significant code refactoring?
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing your web application's architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To answer these questions, let''s zoom out from the implementation details
    and explore our application''s architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The `app.js` file renders our `Application` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Application` component manages a collection of tweets and renders our `Stream`
    and `Collection` components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Stream` component receives the new tweets from the `SnapkiteStreamClient`
    library and renders the `StreamTweet` and `Header` components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Collection` component renders the `CollectionControls` and `TweetList`
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stop right there. Can you tell how data flows inside our application? Do you
    know where it enters our application? How does a new tweet end up in our collection?
    Let''s examine our data flow more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `SnapkiteStreamClient` library to receive a new tweet inside a `Stream`
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This new tweet is then passed from `Stream` to the `StreamTweet` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `StreamTweet` component passes it to the `Tweet` component, which renders
    the tweet image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A user clicks on that tweet image to add it to its collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Tweet` component passes the `tweet` object to the `StreamTweet` component
    via the `handleImageClick(tweet)` callback function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `StreamTweet` component passes that `tweet` object to the `Stream` component
    via the `onAddTweetToCollection(tweet)` callback function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Stream` component passes that `tweet` object to the `Application` component
    via the `onAddTweetToCollection(tweet)` callback function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Application` component adds `tweet` to the `collectionTweets` object and
    updates its state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state update triggers the `Application` component to re-render, which in
    turn re-renders the `Collection` component with an updated collection of tweets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the child components of the `Collection` component can mutate our collection
    of tweets as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you feel confused? Can you rely on this architecture in the long run? Do
    you think it's easily maintainable? I don't think so.
  prefs: []
  type: TYPE_NORMAL
- en: Let's identify the key problems with our current architecture. We can see that
    the new data enters our React application via the `Stream` component. It then
    travels all the way down to the `Tweet` component in the component hierarchy.
    Then, it travels all the way up to the `Application` component, where it's stored
    and managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we store and manage our collection tweets in the `Application` component?
    Because `Application` is a parent component for two other components: `Stream`
    and `Collection`. Both of them need to be able to mutate our collection tweets.
    In order to accommodate this, our `Application` component needs to pass callback
    functions to both the components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Stream` component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Collection` component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Stream` component gets the `onAddTweetToCollection()` function to add a
    tweet to the collection. The `Collection` component gets the `onRemoveTweetFromCollection()`
    function to remove a tweet from the collection, and the `onRemoveAllTweetsFromCollection()`
    function to remove all the tweets from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'These callback functions are then propagated down to the component hierarchy
    until they reach some component that actually calls them. In our application,
    the `onAddTweetToCollection()` function is only called in the `Tweet` component.
    Let''s take a look at how many times it needs to be passed from one component
    to another before it can be called in a `Tweet` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `onAddTweetToCollection()` function is not used in the `Stream` and `StreamTweet`
    components, yet both of them get it as a property for the purpose of passing it
    down to their child components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Snapterest is a small React application, so this problem is rather an inconvenience,
    but later on, if you decide to add new features, this inconvenience will quickly
    become a maintenance nightmare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent this from happening, we''re going to solve two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll change how the new data enters our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll change how the components get and set data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll rethink of how data flows inside our application with the help of Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Flux** is the application architecture from Facebook that complements React.
    It''s not a framework or a library, but rather a solution to a common problem—how
    to build scalable client-side applications.'
  prefs: []
  type: TYPE_NORMAL
- en: With the Flux architecture, we can rethink how data flows inside of our application.
    Flux makes sure that all our data flows only in a **single direction**. This helps
    us to reason about how our application works, regardless of how small or large
    it is. With Flux, we can add new functionality without exploding our application's
    complexity or its mental model.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that both React and Flux share the same core concept—one-way
    data flow. This is why they naturally work well together. We know how data flows
    inside of a React component, but how does Flux implement the one-way data flow?
  prefs: []
  type: TYPE_NORMAL
- en: 'With Flux, we separate the concerns of our application into four logical entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions** are objects that we create when we want to change our application''s
    state. For example, when our application receives a new tweet, we create a new
    action. An action object has a `type` property that identifies what action it
    is and any other properties that our application needs to transition to a new
    state. Here is an example of an action object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is an action of the `receive_tweet` type, and it has the
    `tweet` property, which is a new tweet object that our application has received.
    You can guess what change in your application's state this action represents by
    looking at the action's type. For each new tweet that our application receives,
    it creates a `receive_tweet` action.
  prefs: []
  type: TYPE_NORMAL
- en: Where does this action go? What part of our application gets this action? Actions
    are dispatched to stores.
  prefs: []
  type: TYPE_NORMAL
- en: Stores are responsible for managing your application's data. They provide methods
    for accessing that data, but not for changing it. If you want to change data in
    stores, you have to create and dispatch an action.
  prefs: []
  type: TYPE_NORMAL
- en: We know how to create an action, but how do you dispatch it? As the name suggests,
    you can use a dispatcher for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dispatcher is responsible for dispatching all the actions to all stores:'
  prefs: []
  type: TYPE_NORMAL
- en: All store register with a dispatcher. They provide a callback function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All actions are dispatched by a dispatcher to all stores that did register with
    a dispatcher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how data flow looks like in the Flux architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the dispatcher plays a role of a central element in our data
    flow. All actions are dispatched by it. Stores register with it. All the actions
    are dispatched synchronously. You can't dispatch an action in the middle of the
    previous action dispatch. No action can skip the dispatcher in the Flux architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dispatcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s implement this data flow. We''ll start by creating a dispatcher
    first. Facebook offers us its implementation of a dispatcher that we can reuse.
    Let''s take advantage of this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `~/snapterest` directory and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `flux` module comes with a `Dispatcher` function that we'll be reusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new folder called `dispatcher` in our project''s `~/snapterest/source/dispatcher`
    directory. Now create the `AppDispatcher.js` file in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we import `Dispatcher` provided by Facebook, then create, and export
    a new instance of it. Now we can use this instance in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a convenient way of creating and dispatching actions. For each
    action, let's create a function that creates and dispatches that action. In the
    Flux architecture, these functions are called action creator functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an action creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new folder called `actions` in our project''s `~/snapterest/source/actions`
    directory. Then, we''ll create the `TweetActionCreators.js` file in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our action creators will need a dispatcher to dispatch the actions. We will
    import `AppDispatcher` that we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create our first action creator `receiveTweet()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `receiveTweet()` function takes the `tweet` object as an argument, and creates
    the `action` object with a `type` property set to `receive_tweet`. It also adds
    the `tweet` object to our `action` object, and now every store will receive this
    `tweet` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `receiveTweet()` action creator dispatches our `action` object
    by calling the `dispatch()` method on the `AppDispatcher` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `dispatch()` method dispatches the `action` object to all the stores registered
    with the `AppDispatcher` dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then export our `receiveTweet` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So far, we've created `AppDispatcher` and `TweetActionCreators`. Next, let's
    create our first store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned earlier, stores manage data in your Flux architecture. They provide
    that data to the React components. We'll create a simple store that manages a
    new tweet that our application receives from Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `stores` in our project''s `~/snapterest/source/stores`
    directory. Then, create the `TweetStore.js` file in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TweetStore.js` file implements a simple store. We can break it into four
    logical parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing dependency modules and creating private data and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `TweetStore` object with public methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an action handler and registering a store with a dispatcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning `dispatchToken` to our `TweetStore` object and exporting it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the first logical part of our store, we''re simply importing the dependency
    modules that our store needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our store will need to register with a dispatcher, we import the `AppDispatcher`
    module. Next, we import the `EventEmitter` class to be able to add and remove
    event listeners from our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we import all the dependencies, we then define the data that our store
    manages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `TweetStore` object manages a simple tweet object that we initially set
    to `null` to identify that we didn't receive the new tweet yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the two private methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `setTweet()` function updates `tweet` with a `receiveTweet` object. The
    `emitChange` function emits the `change` event on the `TweetStore` object. These
    methods are private to the `TweetStore` module and they're not accessible outside
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second logical part of the `TweetStore.js` file is creating the `TweetStore`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We want our store to be able to notify other parts of our application when
    its state has changed. We''ll use events for this. Whenever our store updates
    its state, it emits the `change` event. Anyone interested in changes in the store''s
    state can listen to this `change` event. They need to add their event listener
    function that our store will trigger on every `change` event. For this, our store
    defines the `addChangeListener()` method that adds the event listener, which listens
    to the `change` event, and the `removeChangeListener()` method that removes the
    `change` event listener. However, `addChangeListener()` and `removeChangeListener()`
    depend on methods provided by the `EventEmitter.prototype` object. So we need
    to copy the methods from the `EventEmitter.prototype` object to our `TweetStore`
    object. This is what the `Object.assign()` function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Object.assign()` copies the properties owned by `sourceObject1` and `sourceObject2`
    to `targetObject` and then it returns `targetObject`. In our case, `sourceObject1`
    is `EventEmitter.prototype`, and `sourceObject2` is an object literal that defines
    our store''s methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Object.assign()` method returns `targetObject` with the properties copied
    from all the source objects. This is what our `TweetStore` object does.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed that we define the `getTweet()` function as a method of our
    `TweetStore` object, whereas we don't do that with the `setTweet()` function.
    Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we'll export the `TweetStore` object, which means that all its properties
    will be available for other parts of our application to use. We want them to be
    able to get the data from `TweetStore`, but not to update that data directly by
    calling `setTweet()`. Instead, the only way to update data in any store is to
    create an action and dispatch it (using a dispatcher) to stores that have registered
    with that dispatcher. When the store gets that action, it can decide how to update
    its data.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important aspect of the Flux architecture. Stores are in full
    control of managing their data. They only allow other parts in our application
    to read that data, but never write to it directly. Only actions should mutate
    data in the stores.
  prefs: []
  type: TYPE_NORMAL
- en: The third logical part of the `TweetStore.js` file is creating an action handler
    and registering the store with a dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the action handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `handleAction()` function takes an `action` object as a parameter and checks
    its type property. In Flux, all stores get all the actions, but not all stores
    are interested in all the actions, so each store must decide what actions it's
    interested in. For this, a store must check for the action type. In our `TweetStore`
    store, we check whether the action type is `receive_tweet`, which means that our
    application has received a new tweet. If that's the case, then our `TweetStore`
    calls its private `setTweet()` function to update the `tweet` object with a new
    one that comes from the `action` object, that is, `action.tweet`. When the store
    changes its data, it needs to tell everyone who is interested in the data change.
    For this, it calls its private `emitChange()` function that emits the `change`
    event and triggers all the event listeners created by other parts in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to register the `TweetStore` store with a dispatcher. To register
    a store with a dispatcher, you need to call a dispatcher's `register()` method
    and pass the store's action handler function to it as a callback function. Whenever
    the dispatcher dispatches an action, it calls that callback function and passes
    the action object to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We call the `register()` method on the `AppDispatcher` object and pass the `handleAction`
    function as an argument. The `register()` method returns a token that identifies
    the `TweetStore` store. We save that token as a property of our `TweetStore` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth logical part of the `TweetStore.js` file is exporting the `TweetStore`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you create a simple store. Now, since we have implemented our first
    action creator, dispatcher, and store, let''s revisit the Flux architecture and
    take a look at a bigger picture of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: The stores register themselves with a dispatcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Action creators create and dispatch actions to the stores via a dispatcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stores check for relevant actions and change their data accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stores notify everyone who is listening about the data change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well that makes sense, you may say, but what triggers action creators? Who is
    listening to store updates? These are very good questions to ask. And the answers
    are awaiting you in our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you analyzed our React application's architecture. You learned
    the core concepts behind the Flux architecture, and you implemented a dispatcher,
    an action creator, and a store.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll integrate them into our React application and get
    our architecture ready for the maintenance paradise.
  prefs: []
  type: TYPE_NORMAL
