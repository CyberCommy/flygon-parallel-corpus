- en: Chapter 9. Advanced Contract Programming with Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive deeper into contract programming with interfaces.
    We will have a better understanding of how interfaces work as types. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with methods receiving interfaces as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downcast with interfaces and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand boxing and unboxing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treat instances of an interface type as a different subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of default methods in interfaces in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with methods receiving interfaces as arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created the following five interfaces: `DrawableInComic`,
    `DrawableInGame`, `Hideable`, `Powerable`, and `Fightable`. Then, we created the
    following classes that implemented different interfaces, and, many of them, also
    inherited from superclasses: `SpiderDog`, `WonderCat`, `HideableWonderCat`, `PowerableWonderCat`,
    and `FightableWonderCat`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in JShell to check all the types we have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the results of executing the previous command
    in JShell. JShell enumerates the five interfaces and the five classes we have
    created in the session.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with methods receiving interfaces as arguments](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When we work with interfaces, we use them to specify the argument types instead
    of using class names. Multiple classes might implement a single interface, and
    therefore, instances of different classes might qualify as an argument of a specific
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will create additional instances of the previously mentioned classes
    and we will call methods that specified their required arguments with interface
    names instead of class names. We will understand what happens under the hood when
    we use interfaces as types for arguments in methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, the first two lines create two instances of the `SpiderDog`
    class named `teddy` and `winston`. Then, the code calls the two versions of the
    `drawSpeechBalloon` method for `teddy`. The second call to this method passes
    `winston` as the `DrawableInComic` argument because `winston` is an instance of
    `SpiderDog`, which is a class that implements the `DrawableInComic` instance.
    The code file for the sample is included in the `java_9_oop_chapter_09_01` folder,
    in the `example09_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following code creates an instance of the `WonderCat` class named `oliver`.
    The value specified for the `nickName` argument in the constructor is `"Oliver"`.
    The next line calls the `drawSpeechBalloon` method for the new instance to introduce
    `Oliver` in the comic strip, and then `teddy` calls the `drawSpeechBalloon` method
    and passes `oliver` as the `DrawableInComic` argument because `oliver` is an instance
    of `WonderCat`, which is a class that implements the `DrawableInComic` instance.
    Hence, we can also use instances of `WonderCat` whenever we need a `DrawableInComic`
    argument. The code file for the sample is included in the `java_9_oop_chapter_09_01`
    folder, in the `example09_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following code creates an instance of the `HideableWonderCat` class named
    `misterHideable`. The value specified for the `nickName` argument in the constructor
    is `"Mr. Hideable"`. The next line checks whether the call to the `isIntersectingWith`
    method with `oliver` as a parameter returns `true`. The method requires a `DrawableInComic`
    argument, and therefore, we can use `oliver`. The method will return `true` because
    the `x` and `y` fields of both instances have the same value. The line within
    the `if` block calls the `setLocation` method for `misterHideable`. Then, the
    code calls the `show` method. The code file for the sample is included in the
    `java_9_oop_chapter_09_01` folder, in the `example09_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The following code creates an instance of the `PowerableWonderCat` class named
    `merlin`. The value specified for the `nickName` argument in the constructor is
    `"Merlin"`. The next lines call the `setLocation` and `draw` methods. Then, the
    code calls the `useSpellToHide` method with `misterHideable` as the `Hideable`
    argument. The method requires a `Hideable` argument, and therefore, we can use
    `misterHideable`, which is the previously created instance of `HideableWonderCat`
    that implements the `Hideable` interface. Then, a call to the `show` method for
    `misterHideable` makes the `Hideable` with three eyes appear again. The code file
    for the sample is included in the `java_9_oop_chapter_09_01` folder, in the `example09_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The following code creates an instance of the `FightableWonderCat` class named
    `spartan`. The value specified for the `nickName` argument in the constructor
    is `"Spartan"`. The next lines call the `setLocation` and `draw` methods. Then,
    the code calls the `unsheathSword` method with `misterHideable` as a parameter.
    The method requires a `Hideable` argument, and therefore, we can use `misterHideable`,
    the previously created instance of `HideableWonderCat` that implements the `Hideable`
    interface. The code file for the sample is included in the `java_9_oop_chapter_09_01`
    folder, in the `example09_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the code calls the `drawThoughtBalloon` and `drawSpeechBalloon` methods
    for `misterHideable`. We can call these methods because `misterHideable` is an
    instance of `HideableWonderCat`, and this class inherits the implementation of
    the `DrawableInComic` interface from its superclass: `WonderCat`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to the `drawSpeechBalloon` method passes `spartan` as the `DrawableInComic`
    argument because `spartan` is an instance of `FightableWonderCat`, which is a
    class that also inherits the implementation of the `DrawableInComic` interface
    from its superclass: `WonderCat`. Hence, we can also use instances of `FightableWonderCat`
    whenever we need a `DrawableInComic` argument, as done in the next lines. The
    code file for the sample is included in the `java_9_oop_chapter_09_01` folder,
    in the `example09_01.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After we execute all the previously explained code snippets in JShell, we will
    see the following text output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Downcasting with interfaces and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DrawableInComic` interface defines one of the method requirements for
    the `drawSpeechBalloon` method with `destination` as an argument of the `DrawableInComic`
    type, which is the same type that the interface defines. The following is the
    first line in our sample code that called this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We called the method implemented in the `SpiderDog` class because `teddy` is
    an instance of `SpiderDog`. We passed a `SpiderDog` instance, `winston`, to the
    `destination` argument. The method works with the `destination` argument as an
    instance that implements the `DrawableInComic` interface. Hence, whenever we reference
    the `destination` variable, we will only be able to see what the `DrawableInComic`
    type defines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily understand what happens under the hood when Java downcasts a
    type from its original type to a target type, such as an interface to which the
    class conforms. In this case, `SpiderDog` is downcasted to `DrawableInComic`.
    If we enter the following code in JShell and press the *Tab* key, JShell will
    enumerate the members for the `SpiderDog` instance named `winston`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will display the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we ask JShell to list the members, it will include the following members
    inherited from `java.lang.Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the previously entered code (`winston.`). If we enter the following
    code in JShell and press the *Tab* key, the `DrawableInComic` interface type enclosed
    in parentheses as a prefix for the `winston` variable forces the downcast to the
    `DrawableInComic` interface type. Hence, JShell will only enumerate the members
    for the `SpiderDog` instance named `winston` that are required members in the
    `DrawableInComic` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will display the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the difference between the results when we entered `winston.`
    and pressed the *Tab* key, and the latest results. The displayed members in the
    last list don''t include the two methods that are defined in the `SpiderDog` class
    but aren''t required in the `DrawableInComic` interface: `speak` and `think`.
    Hence, when Java downcasts `winston` to `DrawableInComic`, we can only work with
    the members required by the `DrawableInComic` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we work with any IDE that supports auto-completion features, we will notice
    that same difference in the enumeration of the members when we use the auto-completion
    features instead of pressing the *Tab* key in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will analyze another case in which we downcast an instance to one of
    the interfaces that it implements. The `DrawableInGame` interface defines a method
    requirement for the `isIntersectingWith` method with `otherDrawableInGame` as
    an argument of the `DrawableInGame` type, which is the same type that the interface
    defines. The following is the first line in our sample code that called this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We called the method defined within the `WonderCat` class because `misterHideable`
    is an instance of `HideableWonderCat` that inherits the implementation of the
    `isIntersectingWith` method from the `WonderCat` class. We passed a `WonderCat`
    instance, `oliver`, to the `otherDrawableInGame` argument. The method works with
    the `otherDrawableInGame` argument as an instance that implements the `DrawableInGame`
    instance. Hence, whenever we reference the `otherDrawableInGame` variable, we
    will only be able to see what the `DrawableInGame` type defines. In this case,
    `WonderCat` is downcasted to `DrawableInGame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we enter the following code in JShell and press the *Tab* key, JShell will
    enumerate the members for the `WonderCat` instance named `oliver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will display the following members for `oliver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the previously entered code (`oliver.`). If we enter the following code
    in JShell and press the *Tab* key, the `DrawableInGame` interface type enclosed
    in parentheses as a prefix for the `oliver` variable forces the downcast to the
    `DrawableInGame` interface type. Hence, JShell will only enumerate the members
    for the `WonderCat` instance named `oliver` that are required members in the `DrawableInGame`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will display the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the difference between the results when we entered `oliver.`
    and pressed the *Tab* key, and the latest results. When Java downcasts `oliver`
    to `DrawableInGame`, we can only work with the members required by the `DrawableInGame`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a similar syntax to force a cast of the previous expression to the
    original type, that is, to the `WonderCat` type. If we enter the following code
    in JShell and press the *Tab* key, JShell will enumerate all the members for the
    `WonderCat` instance named `oliver`, again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will display the following members, that is, all the members that JShell
    enumerated when we entered `oliver.` without any kind of casting and pressed the
    *Tab* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Treating instances of an interface type as a different subclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](part0069_split_000.html#21PMQ2-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 7. Members Inheritance and Polymorphism"), *Members Inheritance and Polymorphism*,
    we worked with polymorphism. The next example doesn't represent a best practice
    because polymorphism is the way to make it work. However, we will write some code
    that doesn't represent a best practice just to understand a bit more about typecasting.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create a method called `doSomethingWithWonderCat` in JShell.
    We will use this method to understand how we can treat an instance received with
    an interface type as a different subclass. The code file for the sample is included
    in the `java_9_oop_chapter_09_01` folder, in the `example09_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `doSomethingWithWonderCat` method receives a `WonderCat` instance in the
    `wonderCat` argument. The method evaluates many expressions that use the `instanceof`
    keyword to determine whether the instance received in the `wonderCat` argument
    is an instance of `HideableWonderCat`, `FightableWonderCat`, or `PowerableWonder`.
  prefs: []
  type: TYPE_NORMAL
- en: In case `wonderCat` is an instance of `HideableWonderCat` or of any potential
    subclass of `HideableWonderCat`, the code declares a `HideableWonderCat` local
    variable named `hideableCat` to save the reference of `wonderCat` casted to `HideableWonderCat`.
    Then, the code calls the `hideableCat.show` method.
  prefs: []
  type: TYPE_NORMAL
- en: In case `wonderCat` is not an instance of `HideableWonderCat`, the code evaluates
    the next expression. In case `wonderCat` is an instance of `FightableWonderCat`
    or of any potential subclass of `FightableWonderCat`, the code declares a `FightableWonderCat`
    local variable named `fightableCat` to save the reference of `wonderCat` casted
    to `FightableWonderCat`. Then, the code calls the `fightableCat.unsheathSword`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In case `wonderCat` is not an instance of `FightableWonderCat`, the code evaluates
    the next expression. In case `wonderCat` is an instance of `PowerableWonderCat`
    or of any potential subclass of `PowerableWonderCat`, the code declares a `PowerableWonderCat`
    local variable named `powerableCat` to save the reference of `wonderCat` casted
    to `PowerableWonderCat`. Then, the code uses the results returned by the `powerableCat.getSpellPower()`
    method to print the spell power value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the last expression evaluates to `false`, it means that the `wonderCat`
    instance just belongs to `WonderCat`, and the code prints a message indicating
    that `WonderCat` isn't cool.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case we have to do something similar to the code shown in this method, we
    must take advantage of polymorphism instead of using the `instanceof` keyword
    to run code based on the class to whom an instance belongs. Remember that we are
    using the example to learn a bit more about typecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will make many calls to the recently coded `doSomethingWithWonderCat`
    method in JShell. We will call this method with instances of `WonderCat` and its
    subclasses that we created before we declared this method. We will call the `doSomethingWithWonderCat`
    method with the following values for the `wonderCat` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '`misterHideable`: An instance of the `HideableWonderCat` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spartan`: An instance of the `FightableWonderCat` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merlin`: An instance of the `PowerableWonderCat` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oliver`: An instance of the `WonderCat` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following four lines call the `doSomethingWithWonderCat` method in JShell
    with the previously enumerated arguments. The code file for the sample is included
    in the `java_9_oop_chapter_09_01` folder, in the `example09_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output generated in JShell for the previous
    lines. Each call triggers a different type cast and calls a method of the typecasted
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Treating instances of an interface type as a different subclass](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Taking advantage of default methods in interfaces in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the `SpiderDog` and `WonderCat` classes implement the `DrawableInComic`
    interface. All the classes that inherit from the `WonderCat` class, inherit the
    implementation of the `DrawableInComic` interface. Imagine that we have to add
    a new method requirement to the `DrawableInComic` interface and that we will create
    new classes that implement this new version of the interface. We will add a new
    `drawScreamBalloon` method that draws a scream balloon, also known as scream bubble,
    with a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the implementation of the new method in the `SpiderDog` class.
    However, imagine that we cannot make changes to the code in one of the classes
    that implement the `DrawableInComic` interface: `WonderCat`. We have a big problem
    because as soon as we change the code for the `DrawableInComic` interface, the
    Java compiler will generate a compile error for the `WonderCat` class and we won''t
    be able to compile this class and its subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the default methods for interfaces introduced in Java 8 and
    also available in Java 9 are extremely useful. We can declare a default implementation
    for the `drawScreamBalloon` method and include it in the new version of the `DrawableInComic`
    interface. This way, the `WonderCat` class and its subclasses will be able to
    use the default implementation for the method provided in the interface and they
    will comply with the requirements specified in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The following UML diagram shows the new version of the `DrawableInComic` interface
    with the default method named `drawScreamBalloon` and the new version of the `SpiderDog`
    class that overrides the default method. Notice that the `drawScreamBalloon` method
    is the only one that doesn't use italic text because it is not an abstract method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking advantage of default methods in interfaces in Java 9](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines show the code that declares the new version of the `DrawableInComic`
    interface that includes a method requirement for the `drawScreamBalloon` method
    with a default implementation. Notice the `default` keyword before the method's
    return type to indicate that we are declaring a default method. The default implementation
    calls the `drawSpeechBalloon` method that each class that implements the interface
    will declare. This way, by default, the classes that implement this interface
    will draw a speech balloon when they receive the request to draw a scream balloon.
  prefs: []
  type: TYPE_NORMAL
- en: The code file for the sample is included in the `java_9_oop_chapter_09_01` folder,
    in the `example09_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we create the new version of the interface, JShell will reset all the
    variables that hold references of instances of classes that implement the `DrawableInComic`
    interface to `null`. Hence, we won't be able to use the instances we have been
    creating to test the changes in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the new version of the `SpiderDog` class
    with the new `drawScreamBalloon` method. The new lines are highlighted. The code
    file for the sample is included in the `java_9_oop_chapter_09_01` folder, in the
    `example09_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `SpiderDog` class overrides the default implementation of the `drawScreamBalloon`
    method with a new version that calls the protected `scream` method that prints
    the received `message` with a specific format that includes the `nickName` value
    as a prefix. This way, this class won't use the default implementation declared
    in the `DrawableInComic` interface and will use its own implementation instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the first lines create an instance of the new version
    of the `SpiderDog` class named `rocky`, and an instance of the new version of
    the `FightableWonderCat` class named `maggie`. Then, the code calls the `drawScreamBalloon`
    method with a message for the two created instances: `rocky` and `maggie`. The
    code file for the sample is included in the `java_9_oop_chapter_09_01` folder,
    in the `example09_03.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `rocky.drawScreamBalloon`, Java executes the overridden implementation
    for this method declared in the `SpiderDog` class. When we call `maggie.drawScreamBalloon`,
    Java executes the default method declared in the `DrawableInComic` interface because
    neither the `WonderCat` nor the `FightableWonderCat` classes override the default
    implementation for this method. Don''t forget that `FightableWonderCat` is a subclass
    of `WonderCat`. The following screenshot shows the results of executing the previous
    lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking advantage of default methods in interfaces in Java 9](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A default method allows us to declare:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A default constructor for an interface that Java will use when the class that
    implements the interface doesn't declare a constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method that will be called before any method is executed for the instance
    of a class that implements the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A default implementation for a method in an interface that Java will use when
    a class that implements the interface doesn't provide its own implementation of
    this method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider that we have an existing interface that many classes implement and
    all the classes compile without errors. If we add a default method to this interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The classes that implement the interface won't compile until they provide an
    implementation for the new method requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The classes that implement the interface won't compile until they provide an
    implementation for the new constructor requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The classes that implement the interface will compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following keywords allow us to determine whether an instance is
    an instance of a class that implements a specific interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`instanceof`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`isinterfaceimplementedby`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`implementsinterface`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following code snippets forces the downcast of the `winston` variable
    to the `DrawableInComic` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(winston as DrawableInComic)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`((DrawableInComic) < winston)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`((DrawableInComic) winston)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following code snippets forces the downcast of the `misterHideable`
    variable to the `HideableWonderCat` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(misterHideable as HideableWonderCat)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`((HideableWonderCat) < misterHideable)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`((Hid``eableWonderCat) misterHideable)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what happens under the hood when a method receives
    an argument of an interface type. We worked with methods that received arguments
    of interface types and we downcasted with interfaces and classes. We understood
    how we could treat an object as an instance of different compatible types and
    what happens when we do this. JShell allowed us to easily understand what happens
    when we use typecasting.
  prefs: []
  type: TYPE_NORMAL
- en: We took advantage of default methods in interfaces. We could add a new method
    to an interface and provide a default implementation to avoid breaking existing
    code that we couldn't edit.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned advanced scenarios in which we worked with interfaces,
    we are ready to maximize code reuse with generics in Java 9, which is the topic
    we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
