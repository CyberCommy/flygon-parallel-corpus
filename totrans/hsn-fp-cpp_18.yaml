- en: Lazy Evaluation Using the Ranges Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed at length in this book how to think in terms of functions, and
    how function chaining and composition helps to create designs that are modular
    and composable. Yet, we hit a problem—with our current approach, a lot of data
    needs to be copied from one collection to another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Eric Niebler took it upon himself to work on a library that enables
    a solution available in purely functional programming languages—lazy evaluation.
    The library, called **ranges**, was then officially accepted into the C++ 20 standard.
    In this chapter, we will see how to take advantage of it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Why and when lazy evaluation is useful
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the ranges library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use lazy evaluation using the ranges library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.4.0.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The code can be found on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter14` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the ranges library
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ranges library offers a variety of helpful new tools for the C++ programmer.
    All of them are useful, but many are particularly so for our functional programming
    needs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s see how to set it up. To use the ranges library with C++
    17, you need to use the instructions from [https://ericniebler.github.io/range-v3/](https://ericniebler.github.io/range-v3/).
    Then, you just need to include the `all.hpp` header file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As for C++ 20, you just need to include the `<ranges>` header since the library
    was included in the standard:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, if you get a compilation error when trying out the previous line of
    code, don't be surprised. At the time of writing, the latest version of g++ is
    9.1, but the ranges library hasn't yet been included in the standard. Due to its
    size, the implementations are expected to be quite late. Until then, if you want
    to try it out, you can still use Eric Niebler's version.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the ranges library offer? Well, it all starts from the concept
    of range. A range is formed by a begin and an end iterator. This allows us, for
    starters, to add a range on top of an existing collection. Then, we can pass a
    range to an algorithm that requires a begin and end iterator (such as `transform`,
    `sort`, or `accumulate`), hence removing the inconvenient calls to `begin()` and
    `end()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'With ranges, we can build views. Views specify that we are interested in a
    partial or full collection through the two iterators, but also to allow lazy evaluation
    and composability. Since views are just lightweight wrappers on top of a collection,
    we can declare a chain of operations without actually executing them until the
    result is needed. We will see in detail how this works in the next section, but
    here''s a simple example composing two operations that will filter all numbers
    from a collection that are multiples of six by filtering first *all of the even
    numbers*, followed by filtering the numbers that are *multiples of 3*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Mutations are also possible on ranges, with the help of actions. Actions are
    similar to views, except that they mutate the underlying container in-place rather
    than creating a copy. As we''ve discussed many times previously, we prefer not
    to mutate data in functional programming; however, there are cases when we can
    optimize performance with this solution, so it''s worth mentioning. Here''s an
    example of an action in...well, in action:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `|` operator is very interesting for functional programmers, since it's
    a kind of functional composition operator. It's also natural to use for Unix/Linux
    users, who are very used to composing operations. As we've seen in [Chapter 4](d361a3f0-acc7-4e77-9387-2b563fac2f09.xhtml),
    *The Idea of Functional Composition*, such an operator would be very useful. Unfortunately,
    it doesn't yet support the composition of any two functions—just views and actions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the ranges library supports custom views. This opens up possibilities
    such as data generation, which is useful for many things, but [Chapter 11](56c096aa-67a7-48ad-bf22-a78367941a26.xhtml),
    *Property-Based Testing,* in particular.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Let's visit the features of the range library in more detail and with examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen, in past chapters, how to structure code in a functional way,
    by taking advantage of small transformations on data structures. Let''s take a
    simple example—compute the sum of all even numbers from a list. The structured
    programming approach would be to write a loop that goes over the whole structure
    and adds all elements that are even:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The test for this function runs correctly on a simple example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Of course, this method mutates data and we have seen that it''s not always
    a good idea. It also does too many things at once. We''d rather compose more functions.
    The first function needed decides whether a number is even:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second picks the numbers from a collection that satisfy a predicate:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The third computes the sum of all elements from a collection:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This leads us to the final implementation, which composes all of these functions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And then it passes the test, like the structured solution:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The functional solution has distinct advantages—it's simple, composed of small
    functions that can be recombined, and it's immutable, which also means it can
    run in parallel. However, it does have a disadvantage—it copies data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We've seen in [Chapter 10,](4612efcd-7520-4ae3-9813-0c42acee664a.xhtml) *Performance
    Optimization*, how to deal with this issue, but the truth is that the simplest
    solution is lazy evaluation. Imagine what it would mean if we could chain the
    function calls, but the code wouldn't actually execute until the moment we need
    its result. This solution opens the possibility of writing the code we need to
    write, and how we need it, with the compiler optimizing, to the maximum, the chain
    of functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: That's what the ranges library is doing and other things on top.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation using the ranges library
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ranges library offers a facility called **views**. Views allow the construction
    of immutable and cheap data ranges from iterators. They don''t copy the data—they
    just refer to it. We can use `view` to filter all of the even numbers from our
    collection:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Views can be composed without any copying and by using the composition operator, `|`.
    For example, we can obtain the list of numbers divisible by `6` by composing two
    filters: the first one on even numbers, and the second on numbers divisible by
    `3`. Given a new predicate that checks whether a number is multiple of `3`, we
    use the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We obtain the list of numbers divisible by `6` through the following composition:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s important to notice that nothing was actually computed when writing this
    code. The views were initialized and are waiting for a command. So, let''s compute
    the sum of the elements from the views:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ranges::accumulate` function is a special implementation of accumulate
    that knows how to work with the views. Only when calling `accumulate` is the view
    acting; moreover, no data is actually copied—instead, the ranges use smart iterators
    to compute the result.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also see the result of composing the views. As expected, the sum of
    all numbers from the vector that are divisible by `6` is `18`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What a nice way of writing code! It is much easier than both previous options,
    while having a low memory footprint.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: But that's not all ranges can do.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Mutable changes with actions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to views, the ranges library offers actions. Actions allow eager,
    mutable operations. For example, to sort the values in the same vector, we can
    use the following syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `|=` operator is similar to the `ranges::action::sort(numbers)` call, sorting
    the vector in place. Actions are also composable, either through a direct method
    call or with the `|` operator. This allows allows us to write code that sorts
    and keeps the unique items from a container through composition of the `sort`
    and `unique` actions with the `|` operator:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Still, that's not everything ranges can do.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Infinite series and data generation
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since views are lazy evaluated, they allow us to create infinite series. For
    example, to generate a series of integers, we can use the `view::ints` function.
    Then, we need to limit the series so we can use `view::take` to keep the first
    five elements from the series:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Additional data generation can be done using `view::iota` for any type that
    allows increments, for example, for `chars`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In addition, you can generate linearly distributed values with the `linear_distribute`
    view. Given a value interval and a number of items to include in the linear distribution,
    the view includes both interval boundaries, plus enough values from inside the
    interval. For example, taking five linearly distributed values from the [`1`,
    `10`] interval leads to the values `{1, 3, 5, 7, 10}`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What if we need more complex data generators? Fortunately, we can create custom
    ranges. Let''s say that we want to create a list of each tenth power of `2` starting
    from `1` (that is, *2¹*, *2^(11)*, *2^(21)* , and so on). We could do that with
    a transform call; however, we can also do this using the `yield_if` function in
    combination with the `for_each` view. The line in bold from the following code
    shows you exactly how to use these two together:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We first generate an infinite series of integers starting from `1`. Then, for
    each of them, we check whether the value divided by `10` has the remainder `1`.
    If it does, we return `2` to that power. To obtain a finite vector, we pipe the
    previous infinite series into the `take` view, which keeps only the first four
    elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this type of generation is not optimal. For every useful number,
    we need to visit `10`, and it would be better to start from a range that goes
    `1`, `11`, `21`, and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth mentioning here that an alternative to writing this code is to
    use the stride view. The `stride` view takes every n^(th) element from a series,
    exactly as we need it to. In combination with the `transform` view, we can achieve
    exactly the same result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By now, you've probably realized that data generation is very interesting for
    testing, in particular, property-based testing (as we discussed in [Chapter 11](56c096aa-67a7-48ad-bf22-a78367941a26.xhtml),
    *Property-Based Testing*). For testing, however we often need to generate strings.
    Let's see how.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Generating strings
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate strings, first, we need to generate characters. For ASCII characters,
    we can start from a range of integers from `32` to `126`, that is, the ASCII code
    for the interesting, printable characters. We take a random sample and transform
    the code into characters. How do we take a random sample? Well, there''s a view
    for that called `view::sample`, which, given a number of items, takes a random
    sample from the range. Finally, we just need to turn it into a string. This is
    how we get a random string of the length `10` formed out of ASCII characters:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here are a few samples resulted from running this code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, these are interesting strings to use in our tests. Moreover,
    we can vary the size of the strings by changing the argument of `view::sample`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: This example is limited to ASCII characters. However, with support for UTF-8
    now being part of the C++ standard, it should be easy to expand to support special
    characters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eric Niebler's ranges library is a rare feat in software engineering. It manages
    to simplify the use of existing STL high-order functions, while adding lazy evaluation,
    with a topping of data generation. Not only is it part of the C++ 20 standard,
    but it is also useful for older versions of C++.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Eric Niebler的ranges库在软件工程中是一个罕见的成就。它成功地简化了现有STL高阶函数的使用，同时添加了惰性评估，并附加了数据生成。它不仅是C++
    20标准的一部分，而且也适用于较旧版本的C++。
- en: Even if you don't use a functional style of structuring your code, and whether
    you prefer mutable or immutable code, the ranges library allows you to make it
    elegant and composable. Therefore, I advise you to play with it and try for yourself
    how it changes your code. It's definitely worth it, and it's an enjoyable exercise.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不使用函数式的代码结构，无论您喜欢可变的还是不可变的代码，ranges库都可以让您的代码变得优雅和可组合。因此，我建议您尝试一下，看看它如何改变您的代码。这绝对是值得的，也是一种愉快的练习。
- en: We're closing in on the end of this book. It's now time to have a look at STL
    and the language standard support functional programming, and what we can expect
    from C++ 20, and this will be the topic of the next chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束本书。现在是时候看看STL和语言标准对函数式编程的支持，以及我们可以从C++ 20中期待什么，这将是下一章的主题。
