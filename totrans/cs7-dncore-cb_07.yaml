- en: Making Apps Responsive with Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to asynchronous programming. It will cover
    the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Return types of asynchronous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling tasks in asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling in asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is an exciting feature in C#. It allows you to continue
    program execution on the main thread while a long-running task finishes its execution.
    When this long-running task is complete, a thread from the thread pool will return
    to the method containing so that the long-running task can continue execution.
    The best way to learn and understand asynchronous programming is to experience
    it. The following recipes will illustrate some of the basics to you.
  prefs: []
  type: TYPE_NORMAL
- en: Return types of asynchronous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In asynchronous programming, the `async` methods can have three possible return
    types. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task<TResult>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take a look at each return type in the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What could be the use of a `void` return type in asynchronous methods? Generally,
    `void` is used with event handlers. Just bear in mind that `void` returns nothing,
    so you can't wait for it. Therefore, if you call a `void` return type asynchronous
    method, your calling code should be able to continue executing code without having
    to wait for the asynchronous method to complete.
  prefs: []
  type: TYPE_NORMAL
- en: With asynchronous methods that have a return type of `Task`, you can utilize
    the `await` operator to pause the execution of the current thread until the called
    asynchronous method has completed. Keep in mind that an asynchronous method that
    returns a type of `Task` basically does not return an operand. Therefore, if it
    was written as a synchronous method, it would be a `void` return type method.
    This statement might be confusing, but it will become clear in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, asynchronous methods that have a `return` statement have a return type
    of `TResult`. In other words, if the asynchronous method returns a boolean, you
    would create an asynchronous method with a return type of `Task<bool>`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `void` return type asynchronous method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new Windows forms project in Visual Studio called `winformAsync`. We will
    be creating a new Windows forms application so that we can create a button-click
    event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the winformAsync Forms Designer, openToolbox and select the Button control,
    which is found under the All Windows Forms node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag the Button control onto the Form1 designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the Button control selected, double-click on the control to create the
    click event in the code behind. Visual Studio will insert the event code for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning an asynchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new class called `AsyncDemo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method to add to the `AsyncDemo` class is the asynchronous method
    that returns `TResult` (in this case, a boolean). This method simply checks whether
    the current year is a leap year. It then returns a boolean to the calling code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method to add is the `void` returning method that returns a `Task`
    type so that it allows you to `await` the method. The method itself does not return
    any result, making it a `void` returning method. However, in order to use the
    `await` keyword, you to return the `Task` type from this asynchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a method that will call the previous asynchronous methods and
    display the result of the leap year check. You will notice that we are using the
    `await` keyword with both method calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the button click, add the following code that calls the long-running task
    asynchronously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your application will display the Windows forms application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_13.png)'
  prefs: []
  type: TYPE_IMG
- en: Before clicking on the button1 button, ensure that the Output window is visible.
    To do this, click on View and then Output. You can also just hold down *Ctrl* + *W*
    + *O*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_14.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the Output window will allow us to see the `Console.Writeline()`
    outputs that we added to the code in the `AsyncDemo` class and in the Windows
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clicking on the button1 button will display the outputs to our Output window.
    Throughout this code execution, the form remains responsive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_15-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you can also use the `await` operator in separate calls. Modify the
    code in the `LongTask()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding code, we saw the `void` returning type asynchronous method
    that was used in the `button1_Click` event. We also created a `Task` returning
    method that returns nothing (that would be a `void` if used in synchronous programming),
    but returning a `Task` type allows us to `await` the method. Finally, we created
    a `Task<TResult>` returning method that performs a task and returns the result
    to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: Handling tasks in asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Task-based Asynchronous Pattern** (**TAP**) is now the recommended method
    to create asynchronous code. It executes asynchronously on a thread from the thread
    pool and does not execute synchronously on the main thread of your application.
    It allows us to check the task''s state by calling the `Status` property.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a task to read a very large text file. This will be accomplished
    using an asynchronous `Task`. Be sure that you have added the `using System.IO;`
    namespace to your Windows forms application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a large text file (we called ours `taskFile.txt`) and place it in a
    folder called `C:\temp\taskFile\`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `AsyncDemo` class, create a method called `ReadBigFile()` that returns
    a `Task<TResult>` type, which will be used to return an integer of bytes read
    from our big text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to open and read the file bytes. You will see that we
    are using the `ReadAsync()` method that asynchronously reads a sequence of bytes
    from the stream and advances the position of that stream by the number of bytes
    read from that stream. You will also notice that we are using a buffer to read
    those bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The exceptions you can expect to handle from the `ReadAsync()` method are `ArgumentNullException`,
    `ArgumentOutOfRangeException`, `ArgumentException`, `NotSupportedException`, `ObjectDisposedException`,
    and `InvalidOperatorException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the final section of code just after the `var readBytes = bigFile.ReadAsync(bigFileBuffer,
    0, (int)bigFile.Length);` line that uses a lambda expression to specify the work
    that the task needs to perform. In this case, it is to read the bytes in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve not done so in the previous recipe, add a button to your Windows
    forms application''s Forms Designer. In the winformAsync Forms Designer, open
    Toolbox and select the Button control, which is found under the All Windows Forms
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag the Button control onto the Form1 designer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the Button control selected, double-click on the control to create the
    click event in the code behind. Visual Studio will insert the event code for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning asynchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make sure that you add code to call the `AsyncDemo` class''s `ReadBigFile()`
    method asynchronously. Remember to read the result from the method (which are
    the bytes read) into an integer variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your application will display the Windows forms application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_13-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before clicking on the button1 button, ensure that the Output window is visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_14.png)'
  prefs: []
  type: TYPE_IMG
- en: From the View menu, click on the Output menu item or type *Ctrl* + *W * + *O* to
    display the Output window. This will allow us to see the `Console.Writeline()`
    outputs that we added to the code in the `AsyncDemo` class and in the Windows
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clicking on the button1 button will display the outputs to our Output window.
    Throughout this code execution, the form remains responsive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_17.png)'
  prefs: []
  type: TYPE_IMG
- en: Take note, though, that the information displayed in your Output window will
    differ from the screenshot. This is because the file you used is different from
    mine.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The task is executed on a separate thread from the thread pool. This allows
    the application to remain responsive while the large file is being processed.
    Tasks can be used in multiple ways to improve your code. This recipe is but one
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling in asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling in asynchronous programming has always been a challenge.
    This was especially true in the catch blocks. The following feature (introduced
    in C# 6.0) allows you to write asynchronous code inside the `catch` and `finally`
    blocks of your exception handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application will simulate the action of reading a log file. Assume that
    a third-party system always makes a backup of the log file before processing it
    in another application. While this processing is happening, the log file is deleted
    and recreated. Our application, however, needs to read this log file on a periodic
    basis. We therefore need to be prepared for the case where the file does not exist
    in the location we expect it in. Therefore, we will purposely omit the main log
    file so that we can force an error.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a text file and two folders to contain the log files. We will, however,
    only create a single log file in the `BackupLog` folder. Name your text file `taskFile.txt`
    and copy it to the `BackupLog` folder. The `MainLog` folder will remain empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our `AsyncDemo` class, write a method to read the log file in the folder
    specified by the `enum` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `enum` value as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then create a main `ReadLogFile()` method that tries to read the main
    log file. As we have not created the log file in the `MainLog` folder, the code
    will throw a `FileNotFoundException`. It will then run the asynchronous method
    and `await` it in the `catch` block of the `ReadLogFile()` method (something that was
    impossible in the previous versions of C#), returning the bytes read to the calling
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve not done so in the previous recipe, add a button to your Windows
    forms application''s Forms Designer. On the winformAsync Forms Designer, open
    Toolbox and select the Button control, which is found under the All Windows Forms
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_08-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag the Button control onto the Form1 designer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the Button control selected, double-click on the control to create the
    click event in the code behind. Visual Studio will insert the event code for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning an asynchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will write the code to create a new instance of the `AsyncDemo` class
    and attempt to read the main log file. In a real-world example, it is at this
    point that the code does not know that the main log file does not exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your application will display the Windows forms application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_13-1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before clicking on the button1 button, ensure that the Output window is visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_14.png)'
  prefs: []
  type: TYPE_IMG
- en: From the View menu, click on the Output menu item or type *Ctrl* + *W* + *O* to
    display the Output window. This will allow us to see the `Console.Writeline()`
    outputs that we added to the code in the `AsyncDemo` class and in the Windows
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To simulate a file not found exception, we deleted the file from the `MainLog`
    folder. You will see that the exception is thrown, and the `catch` block runs
    the code to read the backup log file instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_07_19.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that we can await in `catch` and `finally` blocks allows developers
    much more flexibility because asynchronous results can consistently be awaited
    throughout the application. As you can see from the code we wrote, as soon as
    the exception was thrown, we asynchronously read the file read method for the
    backup file.
  prefs: []
  type: TYPE_NORMAL
