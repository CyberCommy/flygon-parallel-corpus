- en: Metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using type vector of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating vector of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a function's result type at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a higher-order metafunction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating metafunctions lazily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting all the tuple elements to string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating heterogeneous containers in C++14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is devoted to some cool and hard to understand metaprogramming
    methods. These methods are not for everyday use, but they may be of real help
    for the development of generic libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks*, already covered the basics of metaprogramming. Reading it is recommended
    for better understanding. In this chapter, we''ll go deeper and see how multiple
    types can be packed in a single tuple like type. We''ll make functions for manipulating
    collections of types, we''ll see how types of compile-time collections may be
    changed, and how compile-time tricks can be mixed with runtime. All this is metaprogramming.'
  prefs: []
  type: TYPE_NORMAL
- en: Fasten your seat belts and get ready, lets go...!
  prefs: []
  type: TYPE_NORMAL
- en: Using type vector of types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are situations when it would be great to work with all the template parameters
    like they were in a container. Imagine that we are writing something, such as
    `Boost.Variant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the place where all the following interesting tasks start
    to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we remove constant and volatile qualifiers from all the types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we remove duplicate types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we get the sizes of all the types?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we get the maximum size of the input parameters?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these tasks can be easily solved using `Boost.MPL`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic knowledge of [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks*, is required for this recipe. Accumulate some courage before
    reading--there will be a lot of metaprogramming in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw how a type can be manipulated at compile time. Why can't we go
    further and combine multiple types in an array and perform operations for each
    element of that array?
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s pack all the types in one of the `Boost.MPL` type''s container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make our example less abstract and see how it works if we specify types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We may check everything at compile time. Let''s assert that types is not empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also check that, for example, the `non_declared` types is still at index
    `4` position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And that the last type is still `std::string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We may carry out some transformations. Let''s start with removing constant
    and volatile qualifiers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we can remove the duplicate types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We may check that the vector contains only `5` types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we can compute sizes of each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to get the maximum size from the `sizes_type` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We may assert that the maximum size of the type is equal to the declared size
    of the structure, which must be the biggest one in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::mpl::vector` class is a compile-time container that holds types.
    To be more precise, it is a type that holds types. We do not make instances of
    it; instead, we are just using it in `typedef`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the standard library containers, the `Boost.MPL` containers have no
    member methods. Instead, methods are declared in a separate header. So to use
    some methods, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the correct header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call that method, usually by specifying the container as a first parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already saw metafunctions in [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks*. We were using some metafunctions (such as `boost::is_same`)
    from the familiar `Boost.TypeTraits` library.
  prefs: []
  type: TYPE_NORMAL
- en: So, in *step* *3*, *step* *4*, and *step* *5* we are just calling metafunctions
    for our container type.
  prefs: []
  type: TYPE_NORMAL
- en: The hardest part is coming up!
  prefs: []
  type: TYPE_NORMAL
- en: 'Placeholders are widely used by the `Boost.MPL` library for combining the metafunctions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `boost::mpl::_1` is a placeholder and the whole expression means, for
    each type in `types`, do `boost::remove_cv<>::type` and push back that type to
    the resulting vector. Return the resulting vector via `::type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move to *step* *7*. Here, we specify a comparison metafunction for `boost::mpl::unique`
    using the `boost::is_same<boost::mpl::_1, boost::mpl::_2>` template parameter,
    where `boost::mpl::_1` and `boost::mpl::_2` are placeholders. You may find it
    similar to `boost::bind(std::equal_to(), _1, _2)`, and the whole expression in
    *step* *7* is similar to the following pseudo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There is something interesting, which is required for better understanding,
    in *step* *9*. In the preceding code, `sizes_types` is not a vector of values,
    but rather a vector of integral constants-types representing numbers. The `sizes_types
    typedef` is actually a following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The final step must be clear now. It just gets the maximum element from the
    `sizes_types` `typedef`.
  prefs: []
  type: TYPE_NORMAL
- en: We may use the `Boost.MPL` metafunctions at any place where typedefs are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.MPL` library usage results in longer compilation times, but gives
    you the ability to do everything you want with types. It does not add runtime
    overhead and won't even add a single instruction to the resulting binary. C++17
    has no `Boost.MPL` classes, and `Boost.MPL` does not use features of modern C++,
    such as the variadic templates. This makes the `Boost.MPL` compilation times not
    as short as possible on C++11 compilers, but makes the library usable on C++03
    compilers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks* for information basics of metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Manipulating vector of types* recipe will give you even more information
    about metaprogramming and the `Boost.MPL` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the official documentation of `Boost.MPL` for more examples and full reference
    at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating a vector of types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The task of this recipe is to modify the content of one `boost::mpl::vector`
    function depending on the content of a second `boost::mpl::vector` function. We''ll
    be calling the second vector as the vector of modifiers and each of those modifiers
    may have the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, where shall we start from?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic knowledge of `Boost.MPL` is required. Reading the *Using type vector
    of types* recipe and [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks,* may help.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is similar to the previous one, but it also uses conditional compile-time
    statements. Get ready, it won't be easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall start with headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s put all the metaprogramming magic inside the structure, for simpler
    reuse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a good thought to check that the passed vectors have the same size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take care of the modifying metafunction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And the final step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now run some tests and make sure that our metafunction works great:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In step *3,* we assert that sizes are equal, but we do it in an unusual way.
    The `boost::mpl::size<Types>::type` metafunction actually returns an integral
    constant `struct boost::mpl::long_<4>`, so in a static assertion, we actually
    compare two types, not two numbers. This can be rewritten in a more familiar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `typename` keyword we use. Without it, the compiler won't be able
    to decide if `::type` is actually a type or some variable. Previous recipes did
    not require it, because parameters for the metafunction were fully known at the
    point where we were using them. But in this recipe, parameter for the metafunction
    is a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a look at *step 5*, before taking care of *step 4*. In *step 5*,
    we provide the `Types`, `Modifiers`, and `binary_operator_t` parameters from *step
    4* to the `boost::mpl::transform` metafunction. This metafunction is rather simple--for
    each passed vector, it takes an element and passes it to a third parameter--a
    binary metafunction. If we rewrite it in pseudo code, it will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Step 4* may make someone''s head hurt. At this step, we write a metafunction
    that is called for each pair of types from the `Types` and `Modifiers` vectors
    (see the preceding pseudo code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we already know, `boost::mpl::_2` and `boost::mpl::_1` are placeholders.
    In this recipe, `_1` is a placeholder for a type from the `Types` vector and `_2`
    is a placeholder for a type from the `Modifiers` vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the whole metafunction works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Compares the second parameter passed to it (via `_2`) with an `unsigned` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If types are equal, makes the first parameter passed to it (via `_1`) unsigned
    and returns that type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, it compares the second parameter passed to it (via `_2`) with a constant
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If types are equal, it makes the first parameter passed to it (via `_1`) constant
    and, returns that type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, it returns the first parameter passed to it (via `_1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to be very careful while constructing this metafunction. Additional
    care should be taken as to not call `::type` at the end of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call `::type`, the compiler will attempt to evaluate the binary operator
    at this point, and this leads to a compilation error. In pseudo code, such an
    attempt would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with metafunctions requires some practice. Even your humble servant
    cannot write some functions correctly from the first attempt (second and third
    attempts are also not good though). Do not be afraid or confused to experiment!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boost.MPL` library is not a part of C++17 and does not use modern C++
    features, but it can be used with C++11 variadic templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Just as always, metafunctions do not add a single instruction to the resulting
    binary file and do not make performance worse. However, using them you may make
    your code more tuned to a specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this chapter from the beginning to get more simple examples of the `Boost.MPL`
    usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks*, especially the *Selecting an optimal operator for a template parameter*
    recipe, which contains code similar to the `binary_operator_t` metafunction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official documentation of `Boost.MPL` has more examples and a full table of
    contents at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a function's result type at compile time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many good features were added to C++11 to simplify the metaprogramming. One
    such feature is the alternative function syntax. It allows deducing the result
    type of a template function. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It allows us to write generic functions more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: But, Boost has a lot of functions like these and it does not require C++11 to
    work. How is that possible and how can we make a C++03 version of the `my_function_cpp11`
    function?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ and templates is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++11 greatly simplifies metaprogramming. A lot of code must be written in
    C++03 to make something close to the alternative functions syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to include the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s make a metafunction in the `result_of` namespace for any types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And specialize it for types `s1` and `s2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to write the `my_function_cpp03` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Now, we can use this function like a C++11 one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea of this recipe is that we may make a special metafunction that
    deduces the resulting type. Such a technique can be seen all around the Boost
    libraries, for example, in the `Boost.Variant`'s implementation of `boost::get<>`
    or in almost any function from `Boost.Fusion`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move step-by-step. The `result_of` namespace is just some kind of
    a tradition, but you may use your own and it does not matter. The `boost::common_type<>`
    metafunction deduces a type common of several types, so we use it for a general
    case. We also added two template specializations of the `result_of::my_function_cpp03`
    structures for the `s1` and `s2` types.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of writing metafunctions in C++03 is that sometimes we are
    required to write a lot. Compare the amount of code for `my_function_cpp11` and
    `my_function_cpp03` including the `result_of` namespace to feel the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the metafunction is ready, we may deduce the resulting type without C++11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This technique does not add runtime overhead but it may slow down compilation
    a little bit. You may use it on modern C++ compilers as well.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes *Enabling the usage of templated functions for integral types*,
    *Disabling templated function usage for real types*, and *Selecting an optimal
    operator for a template parameter* recipes from [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks*, will give you much more information about `Boost.TypeTraits`
    and metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the official documentation of `Boost.TypeTraits` for more information
    about ready metafunctions at [http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a higher-order metafunction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions that accept other functions as an input parameter or functions that
    return other functions are called **higher-order** functions. For example, the
    following functions are higher order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We already saw higher-order metafunctions in the recipes *Using type vector
    of types* and *Manipulating vector of types* recipes from this chapter, where
    we used `boost::mpl::transform`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll try to make our own higher-order metafunction named
    `coalesce`, which accepts two types and two metafunctions. The `coalesce` metafunction
    applies the first type-parameter to the first metafunction and compares the resulting
    type with the `boost::mpl::false_` type. If the resulting type is the `boost::mpl::false_`
    type, it returns the result of applying the second type-parameter to the second
    metafunction, otherwise, it returns the first resulting type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe (and chapter) is a tricky one. Reading this chapter from the beginning
    is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.MPL` metafunctions are actually structures that can be easily passed
    as a template parameter. The hard part is to use it correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the following headers to write a higher-order metafunction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to evaluate our functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to choose the correct result type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! We have completed a higher-order metafunction! Now, we may use
    it just like that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main problem with writing the higher-order metafunctions is taking care
    of the placeholders. That's why we shall not call `Func1<Param1>::type` directly.
    Instead of that, we must use the `boost::mpl::apply` metafunction, which accepts
    one function and up to five parameters that shall be passed to this function.
  prefs: []
  type: TYPE_NORMAL
- en: You may configure `boost::mpl::apply` to accept even more parameters, defining
    the `BOOST_MPL_LIMIT_METAFUNCTION_ARITY` macro to the required amount of parameters,
    for example, to 6.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 has nothing close to the `Boost.MPL` library to apply a metafunction.
  prefs: []
  type: TYPE_NORMAL
- en: Modern C++ has a bunch of features that may help you achieve the `Boost.MPL`
    functionality. For example, C++11 has a `<type_traits>` header and **basic** **constexpr**
    support. C++14 has an **extended constexpr** support, in C++17 there's an `std::apply`
    function that works with tuples and is usable in constant expressions. Also, in
    C++17 lambdas are constexpr by default and there is an **if constexpr** (expr).
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own solution would waste a lot of time and probably would not work
    on older compilers. So, `Boost.MPL` still remains one of the most suitable solutions
    for metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the official documentation, especially the *Tutorial* section, for more
    information about `Boost.MPL` at [http://boost.org/libs/mpl](http://boost.org/libs/mpl).
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating metafunctions lazily
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy evaluation means that the function is not called until we really need its
    result. Knowledge of this recipe is highly recommended for writing good metafunctions.
    The importance of lazy evaluation will be shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we are writing some metafunction that accepts a function `Func`,
    a parameter `Param`, and a condition `Cond`. The resulting type of that function
    must be a `fallback` type if applying the `Cond` to `Param` returns `false`, otherwise
    the result must be a `Func` applied to `Param`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This metafunction is the place where we cannot live without lazy evaluation,
    because it may be impossible to apply `Func` to `Param` if the `Cond` is not met.
    Such attempts will always result in compilation failure and `Fallback` is never
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks*, is highly recommended. However, a good knowledge of metaprogramming
    should be enough.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keep an eye on the small details, like not calling `::type` in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The beginning of the function is simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall be careful here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional care must be taken when evaluating an expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Now we are free to use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main idea of this recipe is that we must not execute the metafunction if
    the condition is `false`, because when the condition is `false`, there is a chance
    that the metafunction for that type can''t be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So, how do we evaluate a metafunction lazily?
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler does look inside the metafunction if there is no access to the
    metafunction''s internal types or values. In other words, the compiler tries to
    compile the metafunction when we try to get one of its members via `::`. This
    can be a call to `::type` or `::value`. That is how an incorrect version of `apply_if`
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This differs from our example, where we did not call `::type` at *step 3* and
    implemented *step 4* using `eval_if_c`, which calls `::type` only for one of its
    parameters. The `boost::mpl::eval_if_c` metafunction is implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `boost::mpl::eval_if_c` calls `::type` for a succeeded condition and
    `fallback` has no `::type`, we were required to wrap `fallback` into the `boost::mpl::identity`
    class. This class is very simple, but useful structure that returns its template
    parameter via a `::type` call and does nothing more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already mentioned, C++11 has no classes of `Boost.MPL`, but we may use
    `std::common_type<T>` with a single argument just like `boost::mpl::identity<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Just as always, metafunctions do not add a single line to the output binary
    file, you can use metafunctions as many times as you want. The more you do at
    compile time, the less remains for the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::mpl::identity` type can be used to disable **Argument Dependent
    Lookup** (**ADL**) for template functions. See sources of `boost::implicit_cast`
    in the `<boost/implicit_cast.hpp>` header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading this chapter from the beginning and the official documentation of `Boost.MPL`
    at [http://boost.org/libs/mpl](http://boost.org/libs/mpl) may help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting all the tuple elements to strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe and the next one are devoted to a mix of compile time and runtime
    features. We'll be using the `Boost.Fusion` library and see what it can do.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we were talking about tuples and arrays in the first chapter?
    Now, we want to write a single function that can stream elements of tuples and
    arrays to strings.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should be aware of the `boost::tuple` and `boost::array` classes and of
    the `boost::lexical_cast` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know almost all the functions and classes that will be used in this
    recipe. We just need to gather all of them together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to write a functor that converts any type to string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And now is the tricky part of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! Now, we may convert anything we want to string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main problem of the `stringize` function is that neither `boost::tuple`
    nor `std::pair` have `begin()` or `end()` methods, so we cannot call `std::for_each`.
    This is where the `Boost.Fusion` steps in.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Fusion` library contains lots of terrific algorithms that may manipulate
    structures at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::fusion::for_each` function iterates through elements of sequence
    and applies a functor for each of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is required because by default `Boost.Fusion` works only with its own
    classes. `Boost.Fusion` has its own tuple class, `boost::fusion::vector`, which
    is quite close to `boost::tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: But `boost::fusion::vector` is not as simple as `boost::tuple`. We'll see the
    difference in the *Splitting tuples* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one fundamental difference between `boost::fusion::for_each` and `std::for_each`.
    The `std::for_each` function contains a loop inside it and determinates at runtime,
    how many iterations must be done. However, `boost::fusion::for_each()` knows iterations
    count at compile time and fully unrolls the loop. For the `boost::tuple<cat, int,
    std::string> tup2`, the `boost::fusion::for_each(tup2, functor)` call is equivalent
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: C++11 contains no `Boost.Fusion` classes. All the methods of `Boost.Fusion`
    are very effective. They do as much as possible at compile time and have some
    very advanced optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++14 adds `std::integer_sequence` and `std::make_integer_sequence` to simplify
    for with variadic templates. Using those entities it is possible to hand write
    the `boost::fusion::for_each` functionality and implement the `stringize` function
    without `Boost.Fusion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you may see a lot of code was written to do that and such code is not simple
    to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideas on adding something close to a `constexpr for` to the C++20 Standard
    are discussed in the C++ Standardization Working Group. With that feature, some
    day we could write the following code (syntax may change!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Until then, `Boost.Fusion` seems to be the most portable and simple solution.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Splitting tuples* recipe will give more information about the true power
    of `Boost.Fusion`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official documentation of `Boost.Fusion` contains some interesting examples
    and full references, which can be found at [http://boost.org/libs/fusion](http://boost.org/libs/fusion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show a tiny piece of the `Boost.Fusion` library's abilities.
    We'll be splitting a single tuple into two tuples, one with arithmetic types and
    the other with all other types.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires knowledge of `Boost.MPL`, placeholders, and `Boost.Tuple`.
    Reading this chapter from the beginning is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is possibly one of the hardest recipes in this chapter. The resulting
    types are determined at compile time and values for those types are filled at
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement that mix, we need the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to make a function that returns non-arithmetic types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And a function that returns arithmetic types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Now, we are capable of doing the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind `Boost.Fusion` is that the compiler knows the structure layout
    at compile time and whatever the compiler knows at compile time, we may change
    at the same time. The `Boost.Fusion` allows us to modify different sequences,
    adding and removing fields, and changing field types. This is what we did in *step
    2* and *step 3*; we removed the non-required fields from the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a very close look at `get_nonarithmetics`. First of all, its
    result type is deduced using the following construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This must be familiar to us. We saw something like this in the *Getting function
    result type at compile-time* recipe in this chapter. The `Boost.MPL`'s placeholder
    `boost::mpl::_1` works well with the `boost::fusion::result_of::remove_if` metafunction
    that returns a new sequence type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move inside the function and we watch the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the compiler knows all the types of `seq` at compile time. This
    means that `Boost.Fusion` may apply metafunctions for different elements of `seq`
    and get the metafunction results for them. This also means that `Boost.Fusion`
    knows how to copy required fields from the old structure to the new one.
  prefs: []
  type: TYPE_NORMAL
- en: However, `Boost.Fusion` tries not to copy fields as long as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The code in *step 3* is very similar to the code in *step 2*, but it has a negated
    predicate for removing non-required types.
  prefs: []
  type: TYPE_NORMAL
- en: Our functions can be used with any type supported by `Boost.Fusion` and not
    just with `boost::fusion::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may use `Boost.MPL` functions for the `Boost.Fusion` containers. You just
    need to include `#include <boost/fusion/include/mpl.hpp>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We used `boost::fusion::result_of::value_at_c` instead of `boost::fusion::result_of::at_c`
    because `boost::fusion::result_of::at_c` returns the exact return type of the
    `boost::fusion::at_c` call, which is a reference. `boost::fusion::result_of::value_at_c`
    returns type without a reference.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Fusion` and `Boost.MPL` libraries are not a part of C++17\. `Boost.Fusion`
    is extremely fast. It has many optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that we saw only a tiny part of the `Boost.Fusion` abilities.
    A separate book can be written about it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good tutorials and full documentation for `Boost.Fusion` is available at [http://boost.org/libs/fusion](http://boost.org/libs/fusion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also wish to see an official documentation for `Boost.MPL` at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating heterogeneous containers in C++14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the metaprogramming tricks that we saw in this chapter were invented
    long before C++11\. Probably, you've already heard about some of that stuff.
  prefs: []
  type: TYPE_NORMAL
- en: How about something brand new? How about implementing the previous recipe in
    C++14 with a library that puts the metaprogramming upside down and makes your
    eyebrows go up? Fasten your seatbelts, we're diving into the world of `Boost.Hana`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires knowledge of C++11 and C++14, especially lambdas. You will
    need a truly C++14 compatible compiler to compile the example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s make everything in the `Boost.Hana` way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with including the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an `is_arithmetic_` functional object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we implement the `get_nonarithmetics` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Let's define `get_arithmetics` the other way around. Just for fun!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now, we can use these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code may seem simple at first glance, but that's not true. The `Boost.Hana`
    puts the metaprogramming the other way around! In the previous recipes, we were
    working with types directly, but `Boost.Hana` makes a variable that holds a type
    and works with variable most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `typeid_` call in *step 2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It actually returns a variable. Information about the type is now hidden inside
    the `type` variable and could be extracted by calling `decltype(type)::type`.
  prefs: []
  type: TYPE_NORMAL
- en: But let's move line by line. In *step 2,* we store the generic lambda into the
    `is_arithmetic_` variable. From this point, we can use that variable as a functional
    object. Inside the lambda, we create a `type` variable that now holds information
    about the type of the `v`. The next line is a special wrapper around `std::is_arithmetic`
    that extracts information about the `v` type from the `type` variable and passes
    it to the `std::is_arithmetic` trait. Result of that call is a Boolean integral
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, the magic part! Lambda stored inside the `is_arithmetic_` variable
    is actually never called by `boost::hana::remove_if` and `boost::hana::filter`
    functions. All the `Boost.Hana`''s functions that use it only need the result
    type of the lambda function, but not its body. We can safely change the definition
    and the whole example will continue to work well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In *steps 3* and *4,* we call `boost::hana::remove_if` and `boost::hana::filter`
    functions, respectively. In *step 3,* we used `is_arithmetic_` inside the lambda.
    In *step 4,* we used it directly. You can use any syntax you'd like, it's just
    a matter of habit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally in `main()`, we check that everything works as expected and that the
    element in tuple by index 0 is equal to `8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The best way to understand the `Boost.Hana` library is to experiment with it.
    You can do it online at [http://apolukhin.github.io/Boost-Cookbook/](http://apolukhin.github.io/Boost-Cookbook/).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a small detail left undescribed. How does the tuple access by `operator[]`
    work? It is impossible to have a single function that returns different types!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very interesting if you meet this trick at first time. `Boost.Hana`''s
    `operator ""_c` works with literals and constructs different types depending on
    the literal:'
  prefs: []
  type: TYPE_NORMAL
- en: If you write `0_c`, then `integral_constant<long long, 0>` is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you write `1_c`, then `integral_constant<long long, 1>` is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you write `2_c`, then `integral_constant<long long, 2>` is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boost::hana::tuple` class actually has many `operator[]` overloads, accepting
    different types of `integral_constant`. Depending on the value of integral constant
    the correct tuple element is returned. For example, if you write `some_tuple[1_c]`
    then `tuple::operator[](integral_constant<long long, 1>)` is called the the element
    by index `1` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.Hana` is not a part of C++17\. However, the author of the library participates
    in the C++ Standardization meetings and proposes different interesting things
    for inclusion into the C++ Standard.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are expecting order of magnitude better compile times from `Boost.Hana`
    than from `Boost.MPL` then don't. Currently compilers do not handle the `Boost.Hana`
    approach extremely well. This may change some day.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth looking at the source codes of the `Boost.Hana` library to discover
    new interesting ways of using C++14 features. All the Boost libraries could be
    found at GitHub [https://github.com/boostorg.](https://github.com/boostorg)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation has more examples, a full reference section, some more
    tutorials, and a compile-time performance section. Enjoy the `Boost.Hana` library
    at [http://boost.org/libs/hana.](http://boost.org/libs/hana)
  prefs: []
  type: TYPE_NORMAL
