- en: Chapter 13. Bringing Android Widgets to Life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good overview of both the layout and coding of an Android
    app, as well as our newly acquired insight into **object-oriented programming**
    (**OOP**) and how we can manipulate the UI from our Kotlin code, we are ready
    to experiment with more widgets from the Android Studio palette.
  prefs: []
  type: TYPE_NORMAL
- en: At times, OOP is a tricky thing, and this chapter introduces some topics that
    can be awkward for beginners. However, by gradually learning these new concepts
    and practicing them repeatedly, they will, over time, become our friend.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will diversify a lot by going back to the Android Studio
    palette and looking at half a dozen widgets that we have either not seen at all
    or have not used fully yet.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have done so, we will put them all into a layout and practice manipulating
    them with our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Refresh our memories on declaring and initializing layout widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to create widgets with just Kotlin code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at the `EditText`, `ImageView`, `RadioButton` (and `RadioGroup`),
    `Switch`, `CheckBox`, and `TextClock` widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a widget demo mini app using all the preceding widgets and plenty of lambda
    expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing the objects from the layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that when we call `setContentView` in the `onCreate` function, Android
    inflates all the widgets and layouts, and turns them into *real* instances on
    the Heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that to use a widget from the Heap, we must have an object of the correct
    type by using its unique `id` property. Sometimes, we must specifically obtain
    a widget from a layout. For example, to get a reference to a `TextView` class
    with an `id` property of `txtTitle` and assign it to a new object called `myTextView`,
    we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The left-hand side of the declaration of the `myTextView` instance should look
    familiar to all the instances of other classes that we declared throughout the
    previous three chapters. What is new here is that we are relying on the return
    value of a function to supply the instance. The `findViewById` function does indeed
    return an instance that was created on the Heap when the layout was inflated.
    The required instance is identified by the function argument that matches the
    `id` property of the widget in the layout. The curious-looking `<TextView>` syntax
    is a **cast** or conversion to `TextView` because the function returns the super-class
    type, `View`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using our `myTextView` instance variable, we can do anything that the
    `TextView` class was designed to do; for example, we can set the text to appear
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can make it disappear like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change its text again and make it reappear, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that we can manipulate any property in Kotlin that we
    can set using XML code in the previous chapters. Furthermore, we have hinted at,
    but not actually seen, that we can create widgets from nothing, using just code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI widgets from pure Kotlin without XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also create widgets from Kotlin objects that are not a reference to
    an object in our layout. We can declare, instantiate, and set a widget''s attributes,
    all in code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a new `Button` instance. The only caveat is that
    the `Button` instance must be part of a layout before it can be seen by the user.
    So, we can either get a reference to a layout element from our XML layout in the
    same way that we previously did using the `findViewById` function, or we can create
    a new one in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assume that we have a `LinearLayout` in our XML with an `id` property
    equal to `linearLayout1`, we can incorporate our `Button` instance from the preceding
    line of code in it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can even create an entire layout in pure Kotlin code by first creating a
    new layout, then all the widgets that we want to add, and finally calling `setContentView`
    on the layout that has our required widgets in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following piece of code, we create a layout in pure Kotlin, albeit a
    very simple one with a single `Button` instance inside a `LinearLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is probably obvious, but it is still worth mentioning that designing a detailed
    and nuanced layout in Kotlin only is significantly more awkward, harder to visualize,
    and not the way it is most commonly done. There are times, however, when we will
    find it useful to do things this way.
  prefs: []
  type: TYPE_NORMAL
- en: We are getting quite advanced now with layouts and widgets. It is evident, however,
    that there are a lot of other widgets (and UI elements) from the palette that
    we have not explored or interacted with (other than just dumping them in a layout
    and not doing anything with them); so, let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the palette – part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a whirlwind tour of some of the previously unexplored and unused
    items from the palette, and then we can drag a number of them onto a layout and
    see what useful functions they might have. We can then implement a project to
    put them all to use.
  prefs: []
  type: TYPE_NORMAL
- en: We have already explored `Button` and `TextView` in the previous chapter. Now
    let's take a closer look at some more widgets alongside them.
  prefs: []
  type: TYPE_NORMAL
- en: The EditText widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EditText` widget does as its name suggests. If we make an `EditText` widget
    available to our users, then they will indeed be able to *edit* the *text* in
    it. We saw this in an earlier chapter, but we didn't achieve anything with it.
    What we didn't see was how to capture the information from within it, or where
    we could type this text-capturing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next block of code assumes that we have declared an object of type `EditText`
    and have used it to get a reference to an `EditText` widget in our XML layout.
    We might write something similar to the following code for a button click, perhaps
    a "submit" button for a form, but it can go anywhere we deem it necessary in our
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will see an `EditText` widget in a real context in the next app.
  prefs: []
  type: TYPE_NORMAL
- en: The ImageView widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already put an image onto our layout a couple of times so far, but
    we haven''t got a reference to one from our code or done anything with it before.
    The process of getting a reference to an `ImageView` widget is the same as it
    is to any other widget:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get a reference using the `findViewById` function and a valid `id` property,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can go on to do some interesting things with our image by using code
    that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The odd-looking `f` value simply lets the compiler know that the value is type
    `Float`, as required by the `alpha` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we use the `alpha` property from `imageView`. The `alpha`
    property requires a value between 0 and 1\. 0 is completely transparent, while
    1 indicates no transparency at all. We will use some of the features of `ImageView`
    in our next app.
  prefs: []
  type: TYPE_NORMAL
- en: RadioButtons and RadioGroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `RadioButton` widget is used when there are two or more mutually exclusive
    options for the user to choose from. This means that when one option is chosen,
    the other options are not; such as on an old-fashioned radio. Take a look at a
    simple `RadioGroup` widget with a few `RadioButton` widgets in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RadioButtons and RadioGroups](img/B12806_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user makes a choice, the other options will automatically be deselected.
    We control `RadioButton` widgets by placing them within a `RadioGroup` widget
    in our UI layout. We can, of course, use the visual designer to simply drag a
    bunch of `RadioButtons` onto a `RadioGroup`. When we do, the XML code will look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice, as highlighted in the previous code, that each `RadioButton` widget
    and the `RadioGroup` widget has an appropriate `id` attribute set. We can then
    get a reference to them as we might expect, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In practice, however, we can manage almost everything from the `RadioGroup`
    reference alone.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking how do we know when they have been clicked on, or that
    keeping track of which one is selected might be awkward? We need some help from
    the Android API and Kotlin in the form of **lambdas**.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a `RadioButton` widget is part of `RadioGroup,` the visual appearance of
    them is coordinated for us. All we need to do is react when any given `RadioButton`
    widget is pressed. Of course, as with any other button, we need to know when they
    have been clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: A `RadioButton` widget behaves differently to a regular `Button` widget and
    simply listening for clicks in `onClick` (after implementing `OnClickListener`)
    will not work because the `RadioButton` class is not designed that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is use another Kotlin feature. We need an instance of a
    special interface, for the sole purpose of listening for clicks on `RadioGroup`.
    The next block of code assumes that we have a reference to a `RadioGroup` instance
    called `radioGroup`; here is the code to examine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code, specifically `setOnChekedChangeListener` from its opening
    curly brace (`{`) to the closing curly brace (`}`), is what is known as a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas are a wide-ranging topic and they will be further explored as we progress.
    They are used in Kotlin to avoid unnecessary typing. The compiler knows that `setOnCheckedChangeListener`
    requires a special interface as an argument, and it handles this for us behind
    the scenes. Furthermore, the compiler knows that the interface has one abstract
    function that we must override. The code that is between the opening and closing
    curly brackets is where our implementation of the function goes. The curious-looking
    `group, checkedId ->` parameters are the parameters of this function.
  prefs: []
  type: TYPE_NORMAL
- en: Assume, for the purpose of further discussion, that the preceding code was written
    in the `onCreate` function. Note that the code within the curly braces does not
    run when `onCreate` is called; it simply prepares the instance (`radioGroup`)
    so that it is ready to handle any clicks. We will now discuss this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This unseen interface is known as an **anonymous** class.
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing is adding a listener to `radioGroup`, which has very much
    the same effect as when we implemented `View.OnClickListener` in [Chapter 12,](ch12.html
    "Chapter 12. Connecting Our Kotlin to the UI and Nullability") *Connecting Our
    Kotlin to the UI and Nullability*. Only this time, we are declaring and instantiating
    a listener interface, and preparing it to listen to `radioGroup`, while simultaneously
    overriding the required function, which, in this case (although we can't see the
    name), is `onCheckedChanged`. This is like the `RadioGroup` equivalent of `onClick`.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the preceding code to create and instantiate a class that listens
    for clicks to our `RadioGroup`, in the `onCreate` function, it will listen and
    respond for the entire life of the Activity. All we need to learn about now is
    how to handle the clicks in the `onCheckedChanged` function that we are overriding.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some students find the preceding code straightforward and others find it a
    little overwhelming. It is not an indication of your intelligence level that determines
    the way that you perceive it, but a matter of how your brain likes to learn. There
    are two ways that you can tackle the information in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept that the code works, move on, and revisit exactly how things work later
    in your programming career.
  prefs: []
  type: TYPE_NORMAL
- en: Insist on becoming expert on the topics in this chapter and devote a lot of
    time to mastering them before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly recommend option 1\. Some topics can't be mastered until other topics
    are understood. But a problem arises when, to move on to the latter, you first
    need to have an introduction to the former. The problem becomes circular and unsolvable
    if you insist on complete mastery at all times. Sometimes, it is important to
    just accept that there is more under the surface. If you can simply accept that
    the code we just looked at does work behind the scenes, and that the code within
    the curly braces is what happens when the radio button is clicked on; then, you
    are ready to proceed. You can now go and do a web search for lambdas; however,
    be prepared for many hours of theory. We will revisit lambdas again in this chapter
    and throughout the book while focusing on practical application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the code for the overridden function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that one of the parameters of this function that is passed in when the
    `radioGroup` instance is pressed is `checkedId`. This parameter is an `Int` type
    and it holds the `id` property of the currently selected `RadioButton`. This is
    just what we need – almost.
  prefs: []
  type: TYPE_NORMAL
- en: It might be surprising that `checkedId` is an `Int` type. Android stores all
    IDs as `Int`, even though we declare them with alphanumeric characters such as
    `radioButton1` or `radioGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: All our human-friendly names are converted to `Int` when the app is compiled.
    So, how do we know which `Int` type refers to an ID such as `radioButton1` or
    `radioButton2`?
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is get a reference to the actual object that the `Int` type
    is an ID for, using the `Int id` property and then ask the object for its human-friendly
    `id` value. We will do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can retrieve the familiar `id` property that we used for the currently-selected
    `RadioButton` widget, for which we now have a reference stored in `rb`, with the
    `id` property''s getter function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We could, therefore, handle `RadioButton` clicks by using a `when` block with
    a branch for each possible `RadioButton` that could be pressed, and `rb.id` as
    the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the entire contents of the `onCheckedChanged` function
    that we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Seeing this in action in the next working mini-app, where we can press the buttons
    for real, will make this clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our palette exploration.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the palette – part 2, and more lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how lambdas and anonymous classes and interfaces work,
    specifically with `RadioGroup` and `RadioButton`, we can now continue exploring
    the palette and look at working with some more UI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The Switch widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Switch` widget is just like a `Button` widget except that it has two fixed
    states that can be read and responded to.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious use for the `Switch` widget is to show and hide something. Remember
    that in our Kotlin Meet UI app in [Chapter 12](ch12.html "Chapter 12. Connecting
    Our Kotlin to the UI and Nullability"), *Connecting Our Kotlin to the UI and Nullability*
    we used a `Button` to show and hide a `TextView` widget?
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time we hid or showed the `TextView` widget, we changed the `text` property
    on the `Button` to make it evident what would happen if it was clicked on again.
    What might have been more intuitive for the user, and more straightforward for
    us as programmers, would have been to use a `Switch` widget, as illustrated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Switch widget](img/B12806_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following code assumes that we already have an object called `mySwitch`,
    which is a reference to a `Switch` object in the layout. We could show and hide
    a `TextView` widget just as we did in our *Kotlin Meet UI* app in [Chapter 12](ch12.html
    "Chapter 12. Connecting Our Kotlin to the UI and Nullability").
  prefs: []
  type: TYPE_NORMAL
- en: To listen for, and respond to, clicks/switching, we again use an anonymous class.
    This time, however, we use the `CompoundButton` version of `OnCheckedChangeListener`.
    As before, these details are inferred, and we can use very similar and simple
    code as when we handled the radio button widgets.
  prefs: []
  type: TYPE_NORMAL
- en: We need to override the `onCheckedChanged` function and that function has a
    `Boolean` parameter, `isChecked`. The `isChecked` variable is simply false for
    off and true for on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can more intuitively replace this text by hiding or showing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the anonymous class or lambda code still looks a little odd, don't worry
    because it will become more familiar the more we use it. And we will do so again
    now when we look at `CheckBox`.
  prefs: []
  type: TYPE_NORMAL
- en: The CheckBox widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a `CheckBox` widget, we simply detect its state (checked or unchecked)
    at a given moment – such as at the moment when a specific button is clicked on.
    The following code gives us a glimpse of how this might happen, again using an
    anonymous class and lambda to act as a listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we assume that `myCheckBox` has been declared and initialized,
    and then use the same type of anonymous class as we did for `Switch` to detect
    and respond to clicks.
  prefs: []
  type: TYPE_NORMAL
- en: The TextClock widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our next app, we will use the `TextClock` widget to show off some of its
    features. We will need to add the XML code directly to the layout as this widget
    is not available to drag and drop from the palette. This is what the `TextClock`
    widget looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TextClock widget](img/B12806_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As an example of using `TextClock`, this is how we will set its time to the
    same time as it is in Brussels, Europe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous code assumes that `tClock` is a reference to a `TextClock` widget
    in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: With all this extra information, let's make an app to use the Android widgets
    more practically than what we have so far.
  prefs: []
  type: TYPE_NORMAL
- en: The widget exploration app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just discussed six widgets – `EditText`, `ImageView`, `RadioButton`
    (and `RadioGroup`), `Switch`, `CheckBox`, and `TextClock`. Let's make a working
    app and do something practical with each of them. We will also use a `Button`
    widget and a `TextView` widget again as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this layout, we will use `LinearLayout` as the layout type that holds everything,
    and within `LinearLayout`, we will use multiple `RelativeLayout` instances.
  prefs: []
  type: TYPE_NORMAL
- en: '`RelativeLayout` has been superseded by `ConstraintLayout`, but they are still
    commonly used and are worth playing around with. You will see as you build layouts
    within `RelativeLayout` that the UI elements behave very much the same as `ConstraintLayout`,
    but that the underlying XML is different. It is not necessary to learn this XML
    in detail, rather, using `RelativeLayout` will allow us to show the interesting
    way that Android Studio enables you to convert these layouts to `ConstraintLayout`.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can refer to the completed code in the download bundle. This
    app can be found in the `Chapter13/Widget Exploration` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the widget exploration project and UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will set up a new project and prepare the UI layout. These steps
    will get all the widgets on the screen and the `id` properties set, ready to grab
    a reference to them. It will help to have a look at the target layout up and running,
    before we get started, and it is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the widget exploration project and UI](img/B12806_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is how this app will demonstrate these widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: The radio buttons allow the user to change the time that is displayed on the
    clock to a choice of four time zones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Capture** button, when clicked on, will change the `text` property of
    the `TextView` widget (on the right) to whatever is currently in the `EditText`
    widget (on the left).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three `CheckBox` widgets will add and remove visual effects from the Android
    robot image. In the previous screenshot, the image is resized (made bigger) and
    has a color tint applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Switch` widget will turn on and off the `TextView` widget that displays
    information entered in the `EditText` widget (which is captured at the click of
    a button).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The exact layout positions are not essential, but the `id` properties specified
    must match exactly. So, let''s perform the following steps to set up a new project
    and prepare the UI layout:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project called `Widget Exploration` and use the **Empty Activity**
    project template with its usual settings except for one small change. Set the
    **Minimum API level** option to `API 17: Android 4.2 (Jelly Bean)` and keep all
    the other settings at their default settings. We are using API 17 because one
    of the features of the `TextClock` widget requires us to. We still support in
    excess of 98% of all Android devices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's create a new layout file as we want our new layout to be based on `LinearLayout`.
    Right-click on the `layout` folder in the project explorer and select **New**
    | **Layout resource file** from the pop-up menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New resource file** window, enter `exploration_layout.xml` in the **File
    name** field and then enter `LinearLayout` in the **Root element** field; now
    click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Attributes** window, change the `orientation` property of the `LinearLayout`
    to **horizontal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the drop-down controls above the design view, make sure you have selected
    a tablet in landscape orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a reminder of how to make a tablet emulator, refer to [Chapter 3,](ch03.html
    "Chapter 3. Exploring Android Studio and the Project Structure") *Exploring Android
    Studio and the Project Structure*. For advice on how to manipulate the orientation
    of the emulator, refer to [Chapter 5,](ch05.html "Chapter 5. Beautiful Layouts
    with CardView and ScrollView") *Beautiful Layouts with CardView and ScrollView*.
  prefs: []
  type: TYPE_NORMAL
- en: We can now begin to create our layout. Drag and drop three **RelativeLayout**
    layouts from the **Legacy** category of the palette onto the design to create
    the three vertical divisions of our design. You will probably find it easier to
    use the **Component Tree** window for this step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **weight** property for each of the `RelativeLayout` widgets in turn
    to `.33`. We now have three equal vertical divisions, just like in the following
    screenshot:![Setting up the widget exploration project and UI](img/B12806_13_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the **Component Tree** window looks like the following screenshot:![Setting
    up the widget exploration project and UI](img/B12806_13_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use `ConstraintLayout` instead of `RelativeLayout`, then the
    following instructions will be nearly identical. Just remember to set the final
    position of your UI by clicking the **Infer Constraints** button, or by setting
    the constraints manually, as discussed in [Chapter 4,](ch04.html "Chapter 4. Getting
    Started with Layouts and Material Design") *Getting Started with Layouts and Material
    Design*. Alternatively, you can build the layout exactly as detailed in this tutorial
    and you can use the **Convert to Constraint layout** feature that is discussed
    later in this chapter. This is excellent for using layouts you have and want to
    use, but prefer to use the faster-running `ConstraintLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a **Switch** widgetnear the top-center of the right-hand `RelativeLayout`
    widget and just below, drag a **TextView** from the palette. The right-hand side
    of your layout should now look like the following screenshot:![Setting up the
    widget exploration project and UI](img/B12806_13_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag three **CheckBox** widgets, one above the other, and then an **ImageView**
    widget underneath them onto the central `RelativeLayout`. In the resulting pop-up
    **Resources** dialog window, choose **Project** | **ic_launcher** to use the Android
    icon as the image for the `ImageView` widget. The central column should now appear
    as follows:![Setting up the widget exploration project and UI](img/B12806_13_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **RadioGroup** widget to the left-hand `RelativeLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add four **RadioButton** widgets within the **RadioGroup** widget. This step
    will be easier by using the **Component Tree** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the **RadioGroup** widget, drag a **Plain Text** widget from the
    **Text** category of the palette. Remember, despite its name, that this is a widget
    that allows the user to type some text into it. Soon, we will see how to capture
    and use the entered text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Button** widget to the right of the **Plain Text** widget. Your left-hand
    `RelativeLayout` should look like this screenshot:![Setting up the widget exploration
    project and UI](img/B12806_13_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Component Tree** window will look like the following screenshot at this
    stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the widget exploration project and UI](img/B12806_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now add the following attributes to the widgets that we have just laid out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that some of the attributes might already be correct by default.
  prefs: []
  type: TYPE_NORMAL
- en: '| Widget type | Property | Value to set to |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RadioGroup | `id` | `radioGroup` |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (top) | `id` | `radioButtonLondon` |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (top) | `text` | `London` |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (top) | `checked` | Select the "tick" icon for true |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (second) | `id` | `radioButtonBeijing` |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (second) | `text` | `Beijing` |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (third) | `id` | `radioButtonNewYork` |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (third) | `text` | `New York` |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (bottom) | id | `radioButtonEuropeanEmpire` |'
  prefs: []
  type: TYPE_TB
- en: '| RadioButton (bottom) | text | `European Empire` |'
  prefs: []
  type: TYPE_TB
- en: '| EditText | id | `editText` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | id | `button` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | text | `Capture` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (top) | text | `Transparency` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (top) | id | `checkBoxTransparency` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (middle) | text | `Tint` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (middle) | id | `checkBoxTint` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (bottom) | text | `Resize` |'
  prefs: []
  type: TYPE_TB
- en: '| CheckBox (bottom) | id | `checkBoxReSize` |'
  prefs: []
  type: TYPE_TB
- en: '| ImageView | id | `imageView` |'
  prefs: []
  type: TYPE_TB
- en: '| Switch | id | `switch1` |'
  prefs: []
  type: TYPE_TB
- en: '| Switch | enabled | Select the "tick" icon for true |'
  prefs: []
  type: TYPE_TB
- en: '| Switch | clickable | Select the "tick" icon for true |'
  prefs: []
  type: TYPE_TB
- en: '| TextView | id | `textView` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView | textSize | `34sp` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView | layout_width | `match_parent` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView | layout_height | `match_parent` |'
  prefs: []
  type: TYPE_TB
- en: 'Now switch to the **Text** tab to view the XML code for the layout. Find the
    end of the first (left-hand) `RelativeLayout` column as shown in the following
    code listing. I have added an XML comment and highlighted it in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `<!--Insert TextClock Here-->` comment, insert the following XML
    code for the `TextClock` widget. Note that the comment was added by me in the
    previous listing to show you where to put the code. The comment will not be present
    in your code. We did things this way because `TextClock` is not available directly
    from the palette. Here is the code to add after the comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Switch to the **Design** tab and tweak your layout to resemble the following
    reference diagram as closely as possible, but if you have the appropriate types
    of UI with the correct `id` attributes, then the code will still work even if
    the layout isn't identical:![Setting up the widget exploration project and UI](img/B12806_13_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have just set the required attributes for our layout. There is nothing new
    that we haven't done before, except that some of the widget types are new to us
    and the layout is slightly more intricate.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can get on with using all these widgets with our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the widget exploration app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first part of the Kotlin code that we need to change is to make sure that
    our new layout is displayed. We can do so by changing the call to the `setContentView`
    function in the `onCreate` function to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many `import` statements that are needed for this app, so let''s
    add them all up front to save us from having to keep mentioning them as we proceed.
    Add the following `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code also includes the `…exploration_layout.*` code (as highlighted
    in the preceding code) to automatically enable us to use the `id` attributes that
    we have just configured as the instance names in our Kotlin code. This saves us
    from using the `findViewByID` function multiple times. It will not always be possible
    to do things this way and knowing how to use the `findViewByID` function as we
    discussed earlier in the Declaring and initializing the objects from the layout
    section will sometimes be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the CheckBox widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can create a lambda to listen for and handle clicks on the checkboxes.
    The following three blocks of code implement an anonymous class for each of the
    checkboxes in turn. What is different in each of them, however, is how we respond
    to a click, and we will discuss each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Changing transparency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first checkbox is labeled **Transparency** and we use the `alpha` property
    on the `imageView` instance to change how transparent (that is, see-through) it
    is. The `alpha` property requires a floating-point value between 0 and 1 as an
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 0 is invisible and 1 has no transparency at all. So, when this checkbox is checked,
    we set the `alpha` property to `.1`, so that the image is barely visible; then,
    when it is unchecked, we set it to `1`, which is completely visible with no transparency.
    The `Boolean isChecked` parameter of `onCheckedChanged` function contains a true
    or false value as to whether the checkbox is checked or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the call to the `setContentView` function in the
    `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the next anonymous class, we handle the checkbox labeled **Tint**.
  prefs: []
  type: TYPE_NORMAL
- en: Changing color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `onCheckedChanged` function, we use the `setColorFilter` function on
    `imageView` to overlay a color layer on the image. When `isChecked` is true, we
    layer a color, and when `isChecked` is false, we remove it.
  prefs: []
  type: TYPE_NORMAL
- en: The `setColorFilter` function takes a color in the **ARGB** (**alpha**, **red**,
    **green**, and **blue**) format as an argument. The color is provided by the `argb`
    function of the `Color` class. The four arguments of the `argb` function are values
    for alpha, red, green, and blue. These four values create a color. In our case,
    the `150, 255, 0, 0` value creates a strong red tint, while the `0, 0, 0, 0` value
    creates no tint at all.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand more about the `Color` class, check out the Android developer
    site at [http://developer.android.com/reference/android/graphics/Color.html](http://developer.android.com/reference/android/graphics/Color.html),
    and to understand the RGB color system more, take a look at Wikipedia here: [https://en.wikipedia.org/wiki/RGB_color_model](https://en.wikipedia.org/wiki/RGB_color_model).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the previous block of code in the `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now we will see how to scale the UI by playing with the size of the `ImageView`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: Changing size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the anonymous class that handles the **Resize** labeled checkbox, we use
    the `scaleX` and `scaleY` properties to resize the robot image. When we set `scaleX`
    to 2 and `scaleY` to 2on `imageView`, we will double the size of the image, while
    setting the values to 1 will return the image to its normal size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the previous block of code in the `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now we will handle the three radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the RadioButton widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As they are part of a `RadioGroup` widget, we can handle them much more succinctly
    than we did with the `CheckBox` objects.
  prefs: []
  type: TYPE_NORMAL
- en: First, we make sure they are clear to start with by calling `clearCheck()` on
    the `radioGroup` instance. Then, we create our anonymous class of the `OnCheckedChangeListener`
    type and override the `onCheckedChanged` function with a short and sweet lambda.
  prefs: []
  type: TYPE_NORMAL
- en: This function will be called when any `RadioButton` from the `RadioGroup` widget
    is clicked on. All we need to do is get the `id` property of the `RadioButton`
    widget that was clicked on and respond accordingly. We will achieve this by using
    a `when` statement with three possible paths of execution – one for each `RadioButton`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that when we first discussed `RadioButton,` the `id` property supplied
    in the `checkedId` parameter of `onCheckedChanged` was an `Int` type. This is
    why we must first create a new `RadioButton` object from `checkedId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the `id` property''s getter of the new `RadioButton` object
    as the condition for `when`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then, in each branch, we use the `timeZone` property's setter with the correct
    Android time zone code as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see all the Android time zone codes at [https://gist.github.com/arpit/1035596](https://gist.github.com/arpit/1035596).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code, which incorporates everything that we have just discussed.
    Add it in the `onCreate` function after the previous code that we entered for
    handling the checkboxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time for something a little bit new.
  prefs: []
  type: TYPE_NORMAL
- en: Using a lambda for handling clicks on a regular Button widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next block of code that we will write, we will use a lambda to implement
    an anonymous class to handle the clicks on a regular `Button` widget. We call
    `button.setOnclickListener`, as we have done previously. This time, however, instead
    of passing `this` as an argument, we create a brand-new class of the type `View.OnClickListener`
    and override the `onClick` function as the argument, just as we did with our other
    anonymous classes. In the same way as our previous classes, the code is inferred
    and we have short, snappy code where our code isn't cluttered with too many details.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is preferable in this situation because there is only one button.
    If we had lots of buttons, then having `MainActivity` implement `View.OnClickListener`
    and then overriding `onClick` to handle all clicks in one function would probably
    be preferable, as we have done previously.
  prefs: []
  type: TYPE_NORMAL
- en: In the `onClick` function, we use the `text` property's setter to set the `text`
    property on `textView`, and then the getter of the `text` property of the `editText`
    instance to get whatever text (if any) the user has entered in the `EditText`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the previous block of code in the `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will handle the Switch widget.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Switch widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we create yet another anonymous class to listen for and handle changes
    to our `Switch` widget.
  prefs: []
  type: TYPE_NORMAL
- en: When the `isChecked` variable is `true`, we show the `TextView` widget, and
    when it is false, we hide it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code after the previous block of code in the `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run our app and try out all the features.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android emulators can be rotated into landscape mode by pressing the *Ctrl*
    +*F11* keyboard combination on Windows, or *Ctrl* +*fn*+*F11* on a macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Widget Exploration app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try checking the radio buttons to see the time zone change on the clock. In
    the following image, I have photoshopped a few cropped screenshots to show that
    the time changes when a new time zone is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the Widget Exploration app](img/B12806_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter different values into the `EditText` widget, and then click the button
    to see it grab the text and display it on itself, as demonstrated in the screenshot
    at the start of this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change what the image in the app looks like with different combinations of
    checked and unchecked checkboxes and hide and show the `TextView` widget by using
    the `Switch` widget above it. The following screenshot displays two combinations
    of the checkboxes and the switch widget photoshopped together for demonstration
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the Widget Exploration app](img/B12806_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transparency doesn't show very clearly in a print book, so I didn't check that
    box. Be sure to try this out on an emulator or real device.
  prefs: []
  type: TYPE_NORMAL
- en: Converting layouts to ConstraintLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, as promised, this is how we can convert the layout to the faster-running
    `ConstraintLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch back to the **Design** tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the parent layout – in this case, `LinearLayout` – and select
    **Convert LinearLayout to ConstraintLayout**, as shown in the following screenshot:![Converting
    layouts to ConstraintLayout](img/B12806_13_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can convert any old `RelativeLayout` layouts to the newer and faster
    `ConstraintLayout` widget, as well as build your own `RelativeLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned a lot in this chapter. As well as exploring a plethora of widgets,
    we learned how to implement widgets in Kotlin code without any XML, we used our
    first anonymous classes using short, snappy code in the form of a lambda to handle
    clicks on a selection of widgets, and we put all our new widget prowess into a
    working app.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to look at another way that we can significantly enhance our
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see a completely new UI element that we can't just
    drag and drop from the palette, but we will still have plenty of help from the
    Android API. We will learn about **dialog windows**. We will also make a start
    on our most significant app to date called Note to self. It is a memo, to-do,
    and personal note app.
  prefs: []
  type: TYPE_NORMAL
