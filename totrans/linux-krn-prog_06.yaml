- en: Writing Your First Kernel Module - LKMs Part 2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is the second half of our coverage regarding the **Loadable Kernel
    Module** (**LKM**) framework and how to write kernel modules using it.To get the
    most out of it, I expect you to complete the previous chapter and try out the
    code and questions there before tackling this one.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we continue from the point where we left off in the previous
    one. Here, we cover making use of a 'better' Makefile for LKMs, cross-compiling
    a kernel module for the ARM platform (as a typical example), what module stacking
    is and how to do it, and how to set up and use module parameters. Along the way,
    among several other things, you will learn about the kernel API/ABI stability
    (or rather, the lack thereof!), the key differences between writing userspace
    and kernel code, auto-loading a kernel module at system boot, and security concerns
    and how they can be addressed. We end with information on the kernel documentation
    (including coding style) and contributing to mainline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A "better" Makefile template for your kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-compiling a kernel module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering minimal system information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Licensing kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating "library-like" features for kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to a kernel module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating point not allowed in the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-loading modules on system boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel modules and security - an overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding style guidelines for kernel developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contributing to the mainline kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements – the software packages required – for this chapter
    are identical to what was shown in the *Technical requirements* section in [Chapter
    4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml), *Writing Your First Kernel Module
    – LKMs Part 1*; please refer to it. As always, you can find the source code for
    this chapter in this book''s GitHub repository. Clone it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code displayed in the book is often just a relevant snippet. Follow along
    with the full source code from the repository. For this chapter (and those that
    follow), more on the technical requirements is found in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: A "better" Makefile template for your kernel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding chapter introduced you to the Makefile used to generate the kernel
    module from source, to install and clean it up. However, as we briefly mentioned
    there, I will now introduce what is, in my opinion, a superior, a "better" Makefile,
    and explain how it's better.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, we all have to write better and more secure code – both user and
    kernel-space. The good news is, there are several tools that help improve your
    code's robustness and security posture, static and dynamic analyzers being among
    them (as several have already been mentioned in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml),* Kernel
    Workspace Setup,* I won't repeat them here).
  prefs: []
  type: TYPE_NORMAL
- en: 'I have devised a simple yet useful Makefile "template" of sorts for kernel
    modules that includes several targets that help you run these tools. These targets
    allow you to perform valuable checks and analysis very easily; *stuff you might
    otherwise forget or ignore or put off for ever!* These targets include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The "usual" ones – the `build`, `install`, and `clean` targets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel coding style generation and checking (via `indent(1)` and the kernel's `checkpatch.pl` script,
    respectively).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel static analysis targets (`sparse`, `gcc`, and `flawfinder`), with a mention
    of **Coccinelle**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A couple of "dummy" kernel dynamic analysis targets (`KASAN` and `LOCKDEP /
    CONFIG_PROVE_LOCKING`), encouraging you to configure, build, and use a "debug"
    kernel for all your test cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple `tarxz-pkg` target that tars and compresses the source files into the
    preceding directory. This enables you to transfer the compressed `tar-xz` file
    to any other Linux system, and extract and build the LKM there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A "dummy" dynamic analysis target, pointing out how you should invest time in
    configuring and building a "debug" kernel and using it to catch bugs! (More on
    this follows shortly.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code (along with a `README` file as well) in the `ch5/lkm_template`
    directory. To help you understand its use and power and to help you get started,
    the following figure simply shows a screenshot of the output the code produces
    when run with its `help` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e357b706-c9dd-4dee-8bad-ac4ef8eb037a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The output of the helptarget from our "better" Makefile
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5.1*, we first do `make`, followed by pressing the *Tab* key twice,
    thus having it display all available targets. Do study this carefully and use
    it! For example, running `make sa` will cause it to run all its **static analysis**
    (`sa`) targets on your code!
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to note that using this Makefile will require you to have
    installed a few packages/ apps on the system; these include (for a base Ubuntu
    system) `indent(1)`, `linux-headers-$(uname -r)`, `sparse(1)`, `flawfinder(1)`,
    `cppcheck(1)`, and `tar(1)`. ([Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel
    Workspace Setup*, already specified that these should be installed.)
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the so-called **dynamic analysis** (`da`) targets mentioned in
    the Makefile are merely dummy targets that don't do anything other than print
    a message. They are there *to **remind you *to thoroughly test your code by running
    it on an appropriately configured "debug" kernel!
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of a 'debug' kernel, the next section shows you how to configure one.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a "debug" kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (For details on configuring and building the kernel, look back to [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 1*, and [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 2*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running your code on a *debug kernel* can help you uncover hard-to-spot bugs
    and issues. I highly recommend doing so, typically during development and testing! Here,
    I minimally expect you to configure your custom 5.4 kernel to have the following
    kernel debug config options turned on (within the `make menuconfig` UI, you will
    find most of them under the `Kernel Hacking` sub-menu; the following list is with
    respect to Linux 5.4.0):'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_INFO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_FS` (the `debugfs` pseudo filesystem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_MAGIC_SYSRQ` (the Magic SysRq hotkeys feature)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_KERNEL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_MISC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory debugging:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_SLUB_DEBUG`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_MEMORY_INIT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_KASAN`: this is the **Kernel Address Sanitizer** port; however, as
    of the time of writing, it only works on 64-bit systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_SHIRQ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_SCHED_STACK_END_CHECK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lock debugging:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_PROVE_LOCKING`: the very powerful `lockdep` feature to catch locking
    bugs! This turns on several other lock debug configs as well, explained in [Chapter
    13](4cdb6ffc-0afc-4031-a20e-1f1a0170a163.xhtml), *Kernel Synchronization - Part
    2*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_LOCK_STAT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_ATOMIC_SLEEP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_STACKTRACE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_BUGVERBOSE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_FTRACE` (`ftrace`: within its sub-menu, turn on at least a couple of
    "tracers")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_BUG_ON_DATA_CORRUPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB` (kernel GDB; optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_UBSAN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_EARLY_PRINTK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_BOOT_PARAMS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_UNWINDER_FRAME_POINTER` (selects `FRAME_POINTER` and `CONFIG_STACK_VALIDATION`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A couple of things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Don't worry too much right now if you don't get what all the previously mentioned
    kernel debug config options do; by the time you're done with this book, most of
    them will be clear.
  prefs: []
  type: TYPE_NORMAL
- en: b) Turning on some `Ftrace` tracers (or plugins), such as `CONFIG_IRQSOFF_TRACER`,
    would be useful as we actually make use of it in our *Linux Kernel Programming
    (Part 2)* book in the *Handling Hardware Interrupts* chapter; (note that though
    Ftrace itself may be enabled by default, all its tracers aren't).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that turning on these config options *does* entail a performance hit,
    but that''s okay. We''re running a "debug" kernel of this sort for the express
    purpose of *catching errors and bugs *(especially the hard-to-uncover kind!).
    It can indeed be a life-saver! On your project, *your workflow should involve
    your code being tested and run on both of the following*:'
  prefs: []
  type: TYPE_NORMAL
- en: The *debug* kernel system, where all required kernel debug config options are
    turned on (as previously shown minimally)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *production* kernel system (where all or most of the preceding kernel debug
    options will be turned off)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needless to say, we will be using the preceding Makefile style in all the subsequent
    LKM code in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, now that you're all set, let's dive into an interesting and practical
    scenario – compiling your kernel module(s) for another target (typically ARM).
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling a kernel module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building the 5.x
    Linux Kernel from Source - Part 2*, in the *Kernel build for the Raspberry Pi*
    section,we showed how you can cross-compile the Linux kernel for a "foreign" target
    architecture (such as ARM, PowerPC, MIPS, and so on). Essentially, the same can
    be done for a kernel module as well; you can easily cross-compile a kernel module
    by setting up the "special" `ARCH` and `CROSS_COMPILE` environment variables appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's imagine we are working on an embedded Linux product; the
    target device on which our code will run has an AArch32 (ARM-32) CPU. Why not
    take an actual example. Let's cross-compile our *Hello, world* kernel module for
    the Raspberry Pi 3 **Single-Board Computer** (**SBC**)!
  prefs: []
  type: TYPE_NORMAL
- en: This is interesting. You will find that although it appears simple and straightforward,
    we will end up taking four iterations before we succeed. Why? Read on to find
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the system for cross-compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prerequisites to cross-compile a kernel module are quite clear:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the *kernel source tree for the target system* installed as part of
    the workspace on our host system, typically an x86_64 desktop (for our example,
    using the Raspberry Pi as a target, please refer to the official Raspberry Pi
    documentation here: [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now need a cross toolchain. Typically, the host system is an x86_64 and here,
    as the target is an ARM-32, we will need an *x86_64-to-ARM32 cross toolchain*.
    Again, as is clearly mentioned in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building
    the 5.x Linux Kernel from Source - Part 2*, *Kernel Build for the Raspberry Pi*, you
    must download and install the Raspberry Pi-specific x86_64-to-ARM toolchain as
    part of the host system workspace (refer to [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 2*, to learn how to install
    the toolchain).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, from this point on, I will assume that you have an x86_64-to-ARM cross
    toolchain installed. I will also assume the *toolchain prefix* is  `arm-linux-gnueabihf-`; we
    can quickly check that the toolchain is installed and its binaries added to the
    path by trying to invoke the `gcc` cross-compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It works – it's just that we have not passed any C program as a parameter to
    compile, hence it complains.
  prefs: []
  type: TYPE_NORMAL
- en: You can certainly look up the compiler version as well with the `arm-linux-gnueabihf-gcc
    --version` command.
  prefs: []
  type: TYPE_NORMAL
- en: Attempt 1 – setting the "special" environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Actually, cross-compiling the kernel module is very easy (or so we think!).
    Just ensure that you set the "special" `ARCH` and `CROSS_COMPILE` environment
    variables appropriately. Follow along with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s re-build our very first *Hello, world* kernel module for the Raspberry
    Pi target. Here''s how to build it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do so without corrupting the original code, we make a new folder called `cross` with
    a copy of the (`helloworld_lkm`) code from [Chapter 4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml), *Writing
    your First Kernel Module - LKMs Part 1*, to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<dest-dir>` is the root of the book's GitHub source tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But it doesn''t work (or it may work; please see the following info box) straight
    off the bat. We get compile failures, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Why did it fail?
  prefs: []
  type: TYPE_NORMAL
- en: Assuming all tools are set up as per the technical requirements discussed earlier,
    the cross-compile should work. This is because the `Makefile` provided in the
    book's repository is a proper working one, the Raspberry Pi kernel has been correctly
    configured and built, the device is booted off this kernel, and the kernel module
    is compiled against it. The purpose here, in this book, is to explain the details;
    thus, we begin with no assumptions, and guide you through the process of correctly
    performing the cross-compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The clue as to why the preceding cross-compilation attempt failed lies in the
    fact that it is attempting to use – *build against* – the kernel source of the
    current *host system* and not the target''s kernel source tree. So, *we need to
    modify the* *Makefile to point it to the correct kernel source tree for the target*.
    It''s really quite easy to do so. In the following code, we see the typical way
    that the (corrected) Makefile code is written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Look carefully at the (new and "better," as explained in the preceding section) Makefile and
    you will see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, we conditionally set the `KDIR` variable to point to the correct
    kernel source tree, depending on the value of the `ARCH` environment variable (of
    course, I've used some pathname to kernel source trees for  the ARM[64] and PowerPC
    as examples; do substitute the pathname with the actual path to your kernel source
    trees)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As usual, we set `obj-m += <module-name>.o`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also set `CFLAGS_EXTRA` to add the `DEBUG` symbol (so that the `DEBUG` symbol is
    defined in our LKM and even the `pr_debug()/pr_devel()` macros work).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@echo '<...>'` line is equivalent to the shell's `echo` command; it just
    emits some useful information while building (the `@` prefix hides the echo statement
    itself from displaying).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we have the "usual" Makefile targets: `all`, `install`, and `clean` –
    these are the same as earlier *except for* this important change: **we make it
    change directory** (via the `-C` switch) to the value of `KDIR`!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though not shown in the preceding code, this "better" Makefile has several additional
    useful targets. You should definitely take the time to explore and use them (as
    explained in the preceding section; to start, simply type `make help`, study the
    output and try things out).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having done all this, let's retry the cross-compile with this version and see
    how it goes.
  prefs: []
  type: TYPE_NORMAL
- en: Attempt 2 – pointing the Makefile to the correct kernel source tree for the
    target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So now, with the *enhanced* Makefile described in the previous section, it
    *should* work. In our new directory where we will try this out – `cross` (as we''re
    cross-compiling, not that we''re angry!) – follow along with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempt the build (for a second time) with the `make` command appropriate for
    cross-compilation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The actual reason it failed is that the Raspberry Pi kernel that we're compiling
    our kernel module against is still in a "virgin" state. It does not even have
    the `.config` file present (among other required headers, as the preceding output
    informs us) in its root directory, which it requires to (at least) be configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, switch to the root of your Raspberry Pi kernel source tree and
    follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that these steps are really quite equivalent to performing a partial
    build of the Raspberry Pi kernel! Indeed, if you have already built (cross-compiled)
    this kernel as explained earlier in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building
    the 5.x Linux Kernel from Source - Part 2*, then the kernel module cross-compilation
    should just work without the intervening steps seen here.
  prefs: []
  type: TYPE_NORMAL
- en: Attempt 3 – cross-compiling our kernel module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a configured Raspberry Pi kernel source tree (on the host
    system) and the enhanced Makefile (see the *Attempt 2 – pointing the Makefile
    to the correct kernel source tree for the target* section), it *should* work.
    Let''s retry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We (again) attempt to build (cross-compile) the kernel. Issue the `make` command,
    passing along the `ARCH` and `CROSS_COMPILE` environment variables as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The build is successful! The `helloworld_lkm.ko` kernel module has indeed been
    cross-compiled for the ARM architecture (using the Raspberry Pi cross toolchain
    and kernel source tree).
  prefs: []
  type: TYPE_NORMAL
- en: We can ignore the preceding warning regarding the `Module.symvers` file for
    now. It isn't present as (here) the entire Raspberry Pi kernel hasn't been built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, FYI, on recent hosts running GCC 9.x or later and kernel versions 4.9
    or later, there are some compiler attribute warnings emitted. When I tried cross-compiling
    this kernel module using `arm-linux-gnueabihf-gcc` version 9.3.0 and the Raspberry
    Pi kernel version 4.14.114, warnings such as this were emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./include/linux/module.h:131:6: warning: ‘init_module’ specifies less restrictive
    attribute than its target ‘helloworld_lkm_init’: ‘cold’ [-Wmissing-attributes]`'
  prefs: []
  type: TYPE_NORMAL
- en: Miguel Ojeda points this out ([https://lore.kernel.org/lkml/CANiq72=T8nH3HHkYvWF+vPMscgwXki1Ugiq6C9PhVHJUHAwDYw@mail.gmail.com/](https://lore.kernel.org/lkml/CANiq72=T8nH3HHkYvWF+vPMscgwXki1Ugiq6C9PhVHJUHAwDYw@mail.gmail.com/))
    and has even generated a patch to handle this issue ([https://github.com/ojeda/linux/commits/compiler-attributes-backport](https://github.com/ojeda/linux/commits/compiler-attributes-backport)).
    As of the time of writing, the patch is applied in the kernel mainline and in *recent *Raspberry
    Pi kernels (so, the `rpi-5.4.y` branch works fine but earlier ones such as the
    `rpi-4.9.y` branch don't seem to have it)! Hence the compiler warnings... effectively,
    if you do see these warnings, update the Raspberry Pi branch to `rpi-5.4.y` or
    later (or, for now, just ignore them).
  prefs: []
  type: TYPE_NORMAL
- en: 'The proof of the pudding is in the eating though. So, we fire up our Raspberry
    Pi, `scp(1)` across our cross-compiled kernel module object file to it, and, as
    follows (within an `ssh(1)` session on the Raspberry Pi), try it out (the following
    output is directly from the device):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, `insmod(8)` in the preceding code fails! *It's important to understand
    why.*
  prefs: []
  type: TYPE_NORMAL
- en: It's really to do with a *mismatch in the kernel version* that we're attempting
    to load the module on and the kernel version the module has been compiled against.
  prefs: []
  type: TYPE_NORMAL
- en: 'While logged in to the Raspberry Pi, print out the current Raspberry Pi kernel
    version we''re running on and use the `modinfo(8)` utility to print out details
    regarding the kernel module itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, clearly, here we're running the `4.19.75-v7+` kernel
    on the Raspberry Pi. This, in fact, is the kernel I inherited when I installed
    the *default *Raspbian OS on the device's microSD card (it's a deliberate scenario
    introduced here, at first *not* using the 5.4 kernel we built earlier for the
    Raspberry Pi). The kernel module, on the other hand, reveals that it's been compiled
    against the `5.4.51-v7+` Linux kernel (the `vermagic` string from `modinfo(8)`
    reveals this). *Clearly, there's a mismatch.* Well, so what?
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux kernel has a rule, part of the *kernel* **Application Binary Interface** (**ABI**):
    **it will only ever insert a kernel module into kernel memory if that kernel module
    has been built against it** – the precise kernel version, build flags, and even
    the kernel configuration options matter!'
  prefs: []
  type: TYPE_NORMAL
- en: The *built against* kernel is the kernel whose source location you specified
    in the Makefile (we did so via the `KDIR` variable previously).
  prefs: []
  type: TYPE_NORMAL
- en: In other words, kernel modules are **not binary-compatible with kernels other
    than the one they have been built against***. *For example, if we build a kernel
    module on, say, an Ubuntu 18.04 LTS box, then it will *only* *work on a system
    running this precise environment* (libraries, kernel, or toolchain)! It will *not*
    work on a Fedora 29 or an RHEL 7.x, a Raspberry Pi, and so on. Now – and again,
    think about this – this does not mean that kernel modules are completely incompatible.
    No, they are *source-compatible across different architectures *(at least they
    can or *should* be written that way). So, assuming you have the source code, you
    can always *rebuild* a kernel module on a given system and then it will work on
    that system. It's just that the *binary image *(the `.ko` file) is incompatible
    with kernels other than the precise one it's built against.
  prefs: []
  type: TYPE_NORMAL
- en: 'Relax, this issue is actually easy to spot. Look up the kernel log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On the device, the currently running kernel is this: `4.19.75-v7+`. The kernel
    literally tells us that our kernel module has been built against the `5.4.51-v7+` kernel
    version (it also shows some of the expected kernel config) and what it should
    be. There is a mismatch! Hence the failure to insert the kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though we don''t use this approach here, there is a way to ensure the successful
    build and deployment of third-party out-of-tree kernel modules (as long as their
    source code is available), via a framework called **DKMS** (**Dynamic Kernel Module
    Support**)*.* The following is a quote directly from it:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>Dynamic Kernel Module Support (DKMS) is a program/framework that enables
    generating Linux kernel modules </q><q>whose sources generally reside outside
    the kernel source tree. The concept is to have DKMS modules </q><q>automatically
    rebuilt when a new kernel is installed.</q>
  prefs: []
  type: TYPE_NORMAL
- en: As an example of DKMS usage, the Oracle VirtualBox hypervisor (when running
    on a Linux host) uses DKMS to auto-build and keep up to date its kernel modules.
  prefs: []
  type: TYPE_NORMAL
- en: Attempt 4  – cross-compiling our kernel module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, now that we understand the issue, there are two possible solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: We must use the required custom configured kernel for the product and build
    all our kernel modules against it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, we could rebuild the kernel module to match the current kernel the
    device happens to be running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, in typical embedded Linux projects, you will almost certainly have a custom
    configured kernel for the target device, one that you must work with. All kernel
    modules for the product will/must be built against it. Thus, we follow the first
    approach – we must boot the device with our custom configured and built (5.4!)
    kernel, and since our kernel module is built against it, it should certainly work
    now.
  prefs: []
  type: TYPE_NORMAL
- en: We (briefly) covered the kernel build for the Raspberry Pi in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 2.* Refer back there for the
    details if required.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I will have to assume that you've followed the steps (covered in [Chapter
    3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building the 5.x Linux Kernel
    from Source - Part 2*) and have by now configured and built a 5.4 kernel for the
    Raspberry Pi. The nitty-gritty details regarding how to copy our custom `zImage`
    onto the microSD card of the device and so on is not covered here. I refer you
    to the official Raspberry Pi documentation here: [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, we will point out a convenient way to switch between kernels
    on the device (here, I assume the device is a Raspberry Pi 3B+ running a 32-bit
    kernel):'
  prefs: []
  type: TYPE_NORMAL
- en: Copy your custom-built `zImage` kernel binary into the device's microSD card's
    `/boot` partition. Save the original Raspberry Pi kernel image – the Raspbian
    one – as `kernel7.img.orig`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy (`scp`) the just-cross-compiled kernel module (`helloworld_lkm.ko` for
    ARM, done in the previous section) from your host system onto the microSD card
    (typically into `/home/pi`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, again on the device''s microSD card, edit the `/boot/config.txt` file,
    setting the kernel to boot via the `kernel=xxx` line. A snippet from this file
    on the device shows this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once saved and rebooted, we log in to the device and retry our kernel module.
    Figure 5.2 is a screenshot showing the just-cross-compiled `helloworld_lkm.ko` LKM
    being used on the Raspberry Pi device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d9aae0b-cd43-4afc-9080-0936ceeb5098.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The cross-compiled LKM being used on a Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Ah, it worked! Notice how, this time, the current kernel version (`5.4.51-v7+`)
    precisely matches that of the kernel the module was built against – in the `modinfo(8)` output,
    we can see that the `vermagic` string shows it's `5.4.51-v7+`.
  prefs: []
  type: TYPE_NORMAL
- en: If you do see an issue with `rmmod(8)` throwing a non-fatal error (though the
    cleanup hook is still called), the reason is that you haven't yet fully set up
    the newly built kernel on the device. You will have to copy in all the kernel
    modules (under `/lib/modules/<kernel-ver>`) and run the `depmod(8)` utility there.
    Here, we will not delve further into these details – as mentioned before, the
    official documentation for the Raspberry Pi covers all these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the Raspberry Pi is a pretty powerful system; you can install the
    (default) Raspbian OS along with development tools and kernel headers and thus
    compile kernel modules on the board itself! (No cross-compile required.) Here,
    though, we have followed the cross-compile approach as this is typical when working
    on embedded Linux projects.
  prefs: []
  type: TYPE_NORMAL
- en: The LKM framework is a rather large piece of work. Plenty more remains to be
    explored. Let's get to it. In the next section, we will examine how you can obtain
    some minimal system information from within a kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering minimal system information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our simple demo from the previous section (`ch5/cross/helloworld_lkm.c`),
    we have hard-coded a `printk()` to emit a `"Hello/Goodbye, Raspberry Pi world\n"` string, regardless
    of whether or not the kernel module actually runs on a Raspberry Pi device. For
    a better, though still quite simplistic, way to "detect" some system details (such
    as the CPU or OS), we refer you to our sample `ch5/min_sysinfo/min_sysinfo.c` kernel
    module. In the following code snippet, we show only the relevant function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: (Additional details that this LKM shows you - like the size of various primitive
    data types plus word ranges - is not shown here; please do refer to the source
    code from our GitHub repository and try it out for yourself.) The preceding kernel
    module code is instructive as it helps demonstrate how you can write portable
    code. Remember, the kernel module itself is a binary non-portable object file,
    but its source code could (perhaps, should, depending on your project) be written
    in such a manner so that it's portable across various architectures. A simple
    build on (or for) the target architecture would then have it ready for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: For now, please ignore the `EXPORT_SYMBOL()` macro used here. We will cover
    its usage shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building and running it on our now familiar x86_64 Ubuntu 18.04 LTS guest,
    we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Similarly (as demonstrated earlier), we can *cross-compile* this kernel
    module for ARM-32 (Raspberry Pi), then transfer (`scp(1)`) the cross-compiled
    kernel module to our Raspberry Pi target and run it there (the following output
    is from a Raspberry Pi 3B+ running the 32-bit Raspbian OS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This, in fact, reveals something interesting; the Raspberry Pi 3B+ has a native
    *64-bit CPU*, but by default (as of the time of writing) runs a 32-bit OS, hence
    the preceding output. We will leave it to you to install a 64-bit Linux OS on
    a Raspberry Pi (or other) device and re-run this kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: The powerful *Yocto Project* ([https://www.yoctoproject.org/](https://www.yoctoproject.org/))
    is one (industry-standard) way to generate a 64-bit OS for the Raspberry Pi. Alternatively
    (and much easier to quickly try), Ubuntu provides a custom Ubuntu 64-bit kernel
    and root filesystem for the device ([https://wiki.ubuntu.com/ARM/RaspberryPi](https://wiki.ubuntu.com/ARM/RaspberryPi)).
  prefs: []
  type: TYPE_NORMAL
- en: Being a bit more security-aware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security, of course, is a key concern these days. Professional developers are
    expected to write secure code. In recent years, there have been many known exploits
    against the Linux kernel (see the *Further reading* section for more on this).
    In parallel, many efforts toward improving Linux kernel security are in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our preceding kernel module (`ch5/min_sysinfo/min_sysinfo.c`), be wary of
    using older-style routines (like the `sprintf`, `strlen`, and so on; yes, they''re
    present within the kernel)! *Static analyzers* can greatly aid in catching potential
    security-related and other bugs; we highly recommend you use them. [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml),*Kernel*
    *Workspace Setup*, mentions several useful static analysis tools for the kernel.
    In the following code, we use one of the `sa` targets within our our "better" Makefile to
    run a relatively simple static analyzer: `flawfinder(1)` (written by David Wheeler):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Look carefully at the warning emitted by `flawfinder(1)` regarding the `strlen()` function
    (among the many it generates!). It is indeed the case we face here! Remember, uninitialized local
    variables (such as our `msg` buffer) have *random content* when declared. Thus,
    the `strlen()` function may or may not yield the value we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of `flawfinder` even mentions the **CWE** number (here, CWE-126)
    of the *generalized class *of security issue that is being seen here; (do google
    it and you will see the details. In this instance, CWE-126 represents the buffer
    over-read issue: [https://cwe.mitre.org/data/definitions/126.html](https://cwe.mitre.org/data/definitions/126.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we avoid the use of `strncat()` and replace it with the `strlcat()`
    function. So, taking security concerns into account, we rewrite the code of the `llkd_sysinfo()` function
    as `llkd_sysinfo2()`.
  prefs: []
  type: TYPE_NORMAL
- en: We also add a few lines of code to show the *range *(min, max) of both unsigned
    and signed variables on the platform (in both base 10 and 16). We leave it to
    you to read through. As a simple assignment, run this kernel module on your Linux
    box(es) and verify the output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to discuss a little bit regarding the licensing of the Linux
    kernel and kernel module code.
  prefs: []
  type: TYPE_NORMAL
- en: Licensing kernel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As is well known, the Linux kernel code base itself is licensed under the GNU
    GPL v2 (aka GPL-2.0; **GPL** stands for **General Public License**), and as far
    as most people are concerned, will remain that way. As briefly mentioned before,
    in [Chapter 4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml),* Writing Your First
    Kernel Module – LKMs Part 1, *licensing your kernel code is required and important.
    Essentially, what the discussion, at least for our purposes, boils down to is
    this: if your intention is to directly use kernel code and/or contribute your
    code upstream into the mainline kernel (a few notes on this follow), you *must *release
    the code under the same license that the Linux kernel is released under: the GNU
    GPL-2.0\. For a kernel module, the situation is still a bit "fluid," shall we
    say. No matter, to engage the kernel community and have them help (a huge plus),
    you should, or are expected to, release the code under the GNU GPL-2.0 license
    (though dual-licensing is certainly possible and acceptable).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The license(s) is specified using the `MODULE_LICENSE()` macro. The following
    comment reproduced from the `include/linux/module.h` kernel header clearly shows
    what license "idents" are acceptable (notice the dual-licensing). Obviously, the
    kernel community would highly recommend releasing your kernel module under the
    GPL-2.0 (GPL v2) and/or another, such as BSD/MIT/MPL. If you are intending to
    contribute code upstream to the kernel mainline, it goes without saying that the
    GPL-2.0 alone *is* the license to release under:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'FYI, the kernel source tree has a `LICENSES/` directory under which you will
    find detailed information on licenses; a quick `ls` on this folder reveals the
    sub-folders therein:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We'll leave it to you to take a look, and with this, will leave the discussion
    on licensing at that; the reality is that it's a complex topic requiring legal
    knowledge. You would be well advised to consult specialist legal staff (lawyers)
    within your company (or hire them) with regard to getting the legal angle right
    for your product or service.
  prefs: []
  type: TYPE_NORMAL
- en: 'While on the topic, in order to be consistent, recent kernels have a rule:
    every single source file''s first line must be an SPDX license identifier (see
    [https://spdx.org/](https://spdx.org/) for details). Of course, scripts will require
    the first line to specify the interpreter. Also, some answers to FAQs on the GPL
    license are addressed here: [https://www.gnu.org/licenses/gpl-faq.html](https://www.gnu.org/licenses/gpl-faq.html).'
  prefs: []
  type: TYPE_NORMAL
- en: More on licensing models, not abusing the `MODULE_LICENSE` macro, and particularly
    the multi-licensing/dual-licensing one, can be found at the link provided in the
    *Further reading* section of this chapter. Now, let's get back to the technical
    stuff. The next section explains how you can effectively emulate a library-like
    feature in kernel space.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating "library-like" features for kernel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the major differences between user-mode and kernel-mode programming
    is the complete absence of the familiar "library" concept in the latter. Libraries
    are essentially a collection or archive of APIs, conveniently allowing developers
    to meet the important goals, typically: *do not reinvent the wheel, software reuse,
    modularity*, and the like. But within the Linux kernel, libraries just do not
    exist.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news, though, is that broadly speaking, there are two techniques by
    which you can achieve a "library-like" functionality in kernel space for our kernel
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first technique: explicitly "link in" multiple source files – including
    the "library" code – to your kernel module object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is called module stacking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do read on as we discuss these techniques in more detail. A spoiler, perhaps,
    but useful to know right away: the first of the preceding techniques is often
    superior to the second. Then again, it does depend on the project. Do read the
    details in the next section; we list out some pros and cons as we go along.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing library emulation via multiple source files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have dealt with very simple kernel modules that have had exactly
    one C source file. What about the (quite typical) real-world situation where there
    is *more than one C source file for a single kernel module*? All source files
    will have to be compiled and then linked together as a single `.ko` binary object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we''re building a kernel module project called `projx`. It
    consists of three C source files: `prj1.c, prj2.c`, and `prj3.c`. We want the
    final kernel module to be called `projx.ko`. The Makefile is where you specify
    these relationships, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, note how the `projx` label has been used after the `obj-m`
    directive *and* as the prefix for the
  prefs: []
  type: TYPE_NORMAL
- en: '`-objs` directive on the next line. Of course, you can use any label. Our preceding
    example will have the kernel build system compile the three individual C source
    files into individual object (`.o`) files, and will then *link them all together
    to form the final binary kernel module object file,* `projx.ko`, just as we desire.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage this mechanism in building a small "library" of routines within
    our book''s source tree (the source files for this ''kernel library'' are in the
    root of the source tree here: `klib_llkd.h` and `klib_llkd.c`). The idea is that
    other kernel modules can use the functions within here by linking into them! For
    example, in the upcoming [Chapter 7](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml)*,
    Memory Management Internals - Essentials, *we have our `ch7/lowlevel_mem/lowlevel_mem.c` kernel
    module code invoke a function that resides in our library code, `../../klib_llkd.c`. 
    The "linking into" our so-called "library" code is achieved by putting the following
    into the `lowlevel_mem` kernel module''s Makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The second line specifies the source files to build (into object files); they
    are the code of the `lowlevel_mem.c` kernel module and the `../../klib_llkd` library
    code. Then, it *links *both into a single binary kernel module, `lowlevel_mem_lib.ko`,
    achieving our objective. (Why not work on the assignment 5.1 specified in the
    *Questions* section at the end of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding function and variable scope in a kernel module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before delving further, a quick re-look at some basics is a good idea. When
    programming with C, you should understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables declared locally within a function are obviously local to it and only have
    scope within that function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and functions prefixed with the `static` qualifier have scope only
    within the current "unit"; effectively, the file they have been declared within.
    This is good as it helps reduce namespace pollution. Static (and global) data
    variables retain their value within that function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prior to 2.6 Linux (that is, <= 2.4.x, ancient history now), kernel module
    static and global variables, as well as all functions, were automatically visible
    throughout the kernel. This was, in retrospect, obviously not a great idea. The
    decision was reversed from 2.5 (and thus 2.6 onward, modern Linux): **all kernel
    module variables (static and global data) and functions are by default scoped
    to be private to their kernel module only, and are thus invisible outside it**.
    So, if two kernel modules, `lkmA` and `lkmB`  have a global named `maya`, it''s
    unique to each of them; there is no clash.'
  prefs: []
  type: TYPE_NORMAL
- en: To change the scope, the LKM framework provides the `EXPORT_SYMBOL()` macro.
    Using it, you can declare a data item or function to be *global* in scope – in
    effect, visible to all other kernel modules as well as to the kernel core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple example. We have a kernel module called `prj_core` that
    contains a global and a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Though both are usable within this kernel module itself, neither can be seen
    outside it. This is intentional. To make them visible outside this kernel module,
    we can *export *them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, both have scope outside this kernel module (notice how, in the preceding
    code block, the `static` keyword has been deliberately removed). *Other kernel
    modules (as well as the core kernel) can now "see" and use them*. Precisely, this
    idea is leveraged in two broad ways:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the kernel exports a well-thought-out subset of global variables and
    functions that form a part of its core functionality, as well as that of other
    subsystems. Now, these globals and functions are visible and thus usable from
    kernel modules! We will see some sample uses shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, kernel module authors (often device drivers) use this very notion to
    export certain data and/or functionality so that other kernel modules, at a higher
    abstraction level, perhaps, can leverage this design and use this data and/or
    functionality – this concept is called *module stacking *and we will delve into
    it shortly with an example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the first use case, for example, a device driver author might want to
    handle a hardware interrupt from a peripheral device. A common way to do so is
    via the `request_irq()` API, which, in fact, is nothing but a thin (inline) wrapper
    over this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Precisely because the `request_threaded_irq()` function is *exported*,it can be
    called from within a device driver, which is very often written as a kernel module.
    Similarly, developers often require some "convenience" routines – for example,
    string processing ones. The Linux kernel, in `lib/string.c`, provides an implementation
    of several common string processing functions (that you expect to be present): `str[n]casecmp`, `str[n|l|s]cpy`, `str[n|l]cat`, `str[n]cmp`, `strchr[nul]`, `str[n|r]chr`, `str[n]len`,
    and so on. Of course, these are all *exported* via the `EXPORT_SYMBOL()` macro
    so as to make them visible and thus available to module authors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we used the `str[n|l|s]cpy` notation to imply that the kernel provides
    the four functions: `strcpy`, `strncpy`, `strlcpy`, and `strscpy`. Note that some
    interfaces may be deprecated (`strcpy()`, `strncpy()`, and `strlcpy()`). In general,
    always avoid using deprecated stuff documented here: *Deprecated Interfaces, Language
    Features, Attributes, and Conventions* ([https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, let''s glance at a (tiny) bit of the core **CFS** (**Completely
    Fair Scheduler**) scheduling code deep within the kernel core. Here, the `pick_next_task_fair()` function is
    the one invoked by the scheduling code when we need to find another task to context-switch
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t really want to study scheduling here ([Chapter 10](5391e3c1-30ad-4c75-a106-301259064881.xhtml),
    *The CPU Scheduler - Part 1*, and [Chapter 11](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml),
    *The CPU Scheduler - Part 2*, take care of it), the point here is this: as the
    preceding function is *not *marked with the `EXPORT_SYMBOL()` macro, it cannot
    ever be invoked by a kernel module. It remains *private* to the core kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also mark data structures as exported with the same macro. Also, it
    should be obvious that only globally scoped data – not local variables – can be
    marked as exported.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see how the `EXPORT_SYMBOL()` macro works, please refer to the *Further
    reading *section of this chapter, which links to the book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall our brief discussion on the licensing of kernel modules. The Linux kernel
    has a, shall we say, interesting,proposition: there is also a macro called `EXPORT_SYMBOL_GPL()`.
    It''s just like its cousin, the `EXPORT_SYMBOL()` macro, except that, yes, the
    data item or function exported will only be visible to those kernel modules that
    include the word `GPL` within their `MODULE_LICENSE()` macro! Ah, the sweet revenge
    of the kernel community. It is indeed used in several places in the kernel code
    base. (I''ll leave this as an exercise to you to find occurrences of this macro
    in the code; on the 5.4.0 kernel, a quick search with `cscope(1)` revealed "just"
    14,000 odd usage instances!)'
  prefs: []
  type: TYPE_NORMAL
- en: To view all exported symbols, navigate to the root of your kernel source tree
    and issue the `make export_report` command. Note though that this works only upon
    a kernel tree that has been configured and built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at another key approach to realizing a library-like kernel
    feature: module stacking.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding module stacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second important idea here – *module stacking* – is what we will now delve
    further into.
  prefs: []
  type: TYPE_NORMAL
- en: Module stacking is a concept that provides a "library-like" feature to kernel
    module authors, to a degree. Here, we typically architect our project or product
    design in such a manner that we have one or more "core" kernel modules, whose
    job is to act as a library of sorts. It will include the data structures and functionality
    (functions/APIs) that will be *exported* to other kernel modules (the preceding
    section discussed the exporting of symbols).
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this, let''s look at a couple of real examples. To begin
    with, on my host system, an Ubuntu 18.04.3 LTS native Linux system, I ran a guest
    VM(s) over the *Oracle VirtualBox 6.1* hypervisor application*.* Okay, performing
    a quick `lsmod(8)` on the host system while filtering for the string `vbox` reveals
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Recall from our earlier discussion that the third column is the *usage count*.
    It's `0` in the first row but has a value of `3` in the third row. Not only that,
    but also the `vboxdrv` kernel module has two kernel modules listed to its right
    (after the usage count column). If any kernel modules show up after the third
    column, they represent **dependencies**; read it this way:the kernel modules displayed
    on the right *depend on* the kernel module on the left.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the preceding example, the `vboxnetadp` and `vboxnetflt` kernel modules
    depend on the `vboxdrv` kernel module. *Depend on it* in what way? They use data
    structures and/or functions (APIs) within the `vboxdrv` core kernel module, of
    course! In general, kernel modules showing up on the right of the third column
    imply they are using one or more data structures and/or functions of the kernel
    module on the left (leading to an increment in the usage count; this usage count
    is a good example of a *reference counter* (here, it's actually a 32-bit atomic
    variable)*,* something we delve into in the last chapter). In effect, the `vboxdrv` kernel
    module is akin to a "library" (in a limited sense, with none of the usual userspace
    connotations associated with user-mode libraries except that it provides modular
    functionality). You can see that, in this snapshot, its usage count is `3` and
    the kernel modules that depend on it are stacked on top of it – literally! (You
    can see them in the preceding two lines of `lsmod(1)` output.) Also, notice that
    the `vboxnetflt` kernel module has a positive usage count (`1`) but no kernel
    modules show up on its right; this still implies that something is using it at
    the moment, typically a process or thread.
  prefs: []
  type: TYPE_NORMAL
- en: FYI, the **Oracle VirtualBox** kernel modules we see in this example are actually
    the implementation of the **VirtualBox Guest Additions**. They are essentially
    a para-virtualization construct, helping to accelerate the working of the guest
    VM. Oracle VirtualBox provides similar functionality for Windows and macOS hosts
    as well (as do all the major virtualization vendors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of module stacking, as promised: running the powerful **LTTng**
    (**Linux Tracing Toolkit next generation**) framework enables you to perform detailed
    system profiling. The LTTng project installs and uses a fairly large number of
    kernel modules (typically 40 or more). Several of these kernel modules are "stacked,"
    allowing the project to leverage precisely the "library-like" feature we have
    been discussing here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure (having installed LTTng on a Ubuntu 18.04.4 LTS system),
    see a partial screenshot of the `lsmod | grep --color=auto "^lttng"` output pertaining
    to its kernel modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/581dd594-9e25-4e31-a8ea-701dec0f1e30.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Heavy module stacking within the LTTng product
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen, the `lttng_tracer` kernel module has 35 kernel modules on its
    right side, indicating that they are "stacked" upon it, using functionality that
    it provides (similarly, the `lttng_lib_ring_buffer` kernel module has 23 kernel
    modules that "depend" on it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some quick scripting magic to see all kernel modules whose usage count
    is non-zero (they often – but not always – have some dependent kernel modules
    show up on their right):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'An implication of module stacking: you can only successfully `rmmod(8)` a kernel
    module if its usage count is `0`;  that is, it is not in use. Thus, for the preceding
    first example, we can only remove the `vboxdrv` kernel module after removing the
    two dependent kernel modules that are stacked on it (thus getting the usage count
    down to `0`).'
  prefs: []
  type: TYPE_NORMAL
- en: Trying out module stacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s architect a very simple proof-of-concept code for module stacking. To
    do so, we will build two kernel modules:'
  prefs: []
  type: TYPE_NORMAL
- en: The first we will call `core_lkm`; its job is to act as a "library" of sorts,
    making available to the kernel and other modules a couple of functions (APIs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our second kernel module, `user_lkm`, is the 'user' (or consumer) of the 'library';
    it will simply invoke the functions (and use some data) residing within the first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do so, our pair of kernel modules will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The core kernel module must use the `EXPORT_SYMBOL()` macro to mark some data
    and functions as being *exported*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user kernel module must declare the data and/or functions that it expects
    to use as being external to it, via the C `extern` keyword (remember, exporting
    data or functionality merely sets up the appropriate linkage; the compiler still
    needs to know about the data and/or functions being invoked).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With recent toolchains, marking the exported function(s) and data items as `static` is
    allowed. A warning results, though; we don't use the `static` keyword for exported
    symbols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit the custom Makefile to build both kernel modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code follows; first, the core or library kernel module. To (hopefully)
    make this more interesting, we will copy the code of one of our previous module''s
    functions – `ch5/min_sysinfo/min_sysinfo.c:llkd_sysinfo2()` – into this kernel
    module and *export* it, thus making it visible to our second "user" LKM, which
    will invoke that function:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we do not show the full code; you can refer to the book's GitHub repo
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the `user_lkm` kernel module, the one "stacked" on top of the `core_lkm` kernel
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The Makefile remains largely identical to our earlier kernel modules, except
    that this time we need two kernel module objects to be built, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build the kernel modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're building our kernel modules against our custom 5.4.0 kernel.
    Do notice its full version is `5.4.0-llkd02-kasan`; this is deliberate. This is
    the "debug kernel" that I have built and am using as a test-bed!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s perform a quick series of tests to demonstrate the *module stacking *proof
    of concept. Let''s first do it *wrongly*: we will first attempt to insert the `user_lkm`kernel
    module before inserting the `core_lkm`module.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will fail – why? You will realize that the exported functionality (and
    data) that the `user_lkm` kernel module depends on is not (yet) available within
    the kernel. More technically, the symbols will not be located within the kernel''s
    symbol table as the `core_lkm`kernel module that has them hasn''t been inserted
    yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As expected, as the required (to-be-exported) symbols are unavailable, `insmod(8)` fails
    (the precise error message you see in the kernel log may vary slightly depending
    on the kernel version and debug config options set).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s do it right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It works as expected! Check out the modules listing with `lsmod(8)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, for the `core_lkm` kernel module, the usage countcolumn has incremented
    to `1` *and *we can now see that the `user_lkm` kernel module depends on the `core_lkm` one.
    Recall that the kernel module(s) displayed in the extreme-right columns of `lsmod`'s
    output depend on the one in the extreme-left column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s remove the kernel modules. Removing the kernel modules has an *ordering
    dependency* as well (just as with insertion). Attempting to remove the `core_lkm`one
    first fails, as obviously, there is another module still in kernel memory relying
    upon its code/data; in other words, it''s still in use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that if the modules are *installed* onto the system, then you could use
    the `modprobe -r <modules...>` command to remove all related modules; we cover
    this topic in the *Auto-loading modules on system boot *section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding `rmmod(8)` failure message is self-explanatory. So, let''s do
    it right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There, done!
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that in the code of the `user_lkm`kernel module, the license
    we release it under is in a conditional `#if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that it''s released (by default) under the *Dual MIT/GPL* license;
    well, so what? Think about it: in the code of the `core_lkm`kernel module, we
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exp_int` integer is *only visible to those kernel modules that run under
    a GPL license. *So, try this out: change the `#if 1` statement in `core_lkm` to `#if
    0`, thus now releasing it under an MIT-only license. Now, rebuild and retry. It
    *fails* at the build stage itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The license does matter! Before we wind up this section, here''s a quick list
    of things that can go wrong with module stacking; that is, things to check:'
  prefs: []
  type: TYPE_NORMAL
- en: The wrong order of kernel modules specified at insertion/at removal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attempting to insert an exported routine that is already in kernel memory –
    a namespace collision issue:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: License issues caused by the usage of the `EXPORT_SYMBOL_GPL()` macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always look up the kernel log (with `dmesg(1)` or `journalctl(1)`). It often
    helps to show what actually went awry.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s summarize: for emulating a library-like feature within the kernel
    module space, we explored two techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: The first technique we used works by *linking multiple source files together
    into a single kernel module*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is as opposed to the *module stacking* technique, where we actually build
    multiple kernel modules and "stack" them on top of each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not only does the first technique work well, it also has these advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We do *not* have to explicitly mark (via `EXPORT_SYMBOL()`) every data/function
    symbol that we use as exported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions are only available to the kernel module to which it is actually
    linked to (and not the *entire* *kernel, including other modules*). This is a
    good thing! All this at the cost of slightly tweaking the Makefile – well worth
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A downside to the "linking" approach: when linking multiple files, the size
    of the kernel module can grow to be large.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes your learning a powerful feature of kernel programming – the
    ability to link multiple source files together to form one kernel module, and/or
    leveraging the module stacking design, both allowing you to develop more sophisticated
    kernel projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we dive into the details of how you can pass parameters
    to a kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to a kernel module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common debugging technique is to *instrument* your code; that is, insert
    prints at appropriate points such that you can follow the path the code takes.
    Within a kernel module, of course, we would use the versatile `printk`function for
    this purpose. So, let''s say we do something like the following (pseudo-code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, great. But we don''t want the debug prints to appear in a production
    (or release) version. That''s precisely why we''re using the `pr_debug()` : it
    emits a printk only when the symbol `DEBUG` is defined! Indeed, but what if, interestingly,
    our customer is an engineering customer and wants to *dynamically turn on or turn
    off these debug prints*? There are several approaches you might take; one is as
    in the following pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Ah, that's nice. So, what we're getting at really is this: *what if we can make
    the *`debug_level`* module variable**a parameter to our kernel module?* Then,
    a powerful thing, the user of your kernel module has control over which debug
    messages appear or not.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and using module parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Module parameters are passed to a kernel module as *name=value* pairs at module
    insertion (`insmod`) time. For example, assume we have a *module parameter* named
    `mp_debug_level`; then, we could pass its value at `insmod(8)` time, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `mp` prefix stands for module parameter. It's not required to name
    it that way, of course, it is pedantic, but might  just makes it a bit more intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: That would be powerful. Now, the end user can decide at exactly what *verbosity* they
    want the *debug-level* messages. We can even easily arrange for the default value
    to be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder: kernel modules have no `main()` function and hence no conventional `(argc,
    argv)` parameter list, so how exactly, then, do you pass parameters along? The
    fact is, it''s a bit of linker trickery; just do this: declare your intended module
    parameter as a global (`static`) variable, then specify to the build system that
    it''s to be treated as a module parameter by employing the `module_param()` macro.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easy to see with our first module parameter''s demo kernel module (as
    usual, the full source code and Makefile can be found in the book''s GitHub repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `static int mp_debug_level;` statement, there is no harm in changing
    it to `static int mp_debug_level = 0; `, thus explicitly initializing the variable
    to 0, right? Well, no: the kernel''s `scripts/checkpatch.pl` script output reveals
    that this is not considered good coding style by the kernel community:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERROR: do not initialise statics to 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#28: FILE: modparams1.c:28:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`+static int mp_debug_level = 0;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code block, we have declared two variables to be module parameters
    via the `module_param()` macro. The `module_param()` macro takes three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter: the variable name (which we would like treated as a module
    parameter). This should be declared using the `static` qualifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second parameter: its data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third parameter: permissions (really, its visibility via `sysfs`; this
    is explained as follows).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `MODULE_PARM_DESC()` macro allows us to "describe" what the parameter represents.
    Think about it, this is how you inform the end user of the kernel module (or driver)
    and what parameters are actually available. The lookup is performed via the `modinfo(8)` utility.
    Furthermore, you can specifically print only the information on parameters to
    a module by using the `-p` option switch, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `modinfo(8)` output displays available module parameters, if any. Here,
    we can see that our `modparams1.ko` kernel module has two parameters, their name,
    description, and data type (within parentheses; `charp` is character pointer,
    a string) is shown. Right, let''s now give our demo kernel module a quick spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see from the `dmesg(1)` output that, as we did not explicitly pass
    any kernel module parameters, the module variables obviously retain their default
    (original) values. Let''s redo this, this time passing explicit values to the
    module parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It works as expected. Now that we've seen how to declare and pass along some
    parameters to a kernel module, let's look at retrieving or even modifying them
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Getting/setting module parameters after insertion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look carefully at the `module_param()` macro usage in our preceding `modparams1.c`
    source file again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the third parameter, the *permissions* (or *mode*): it''s `0660` (which,
    of course, is an *octal* number, implying read-write access for the owner and
    group and no access for others). It''s a bit confusing until you realize that
    if the permissionsparameter is specified as non-zero, pseudo-file(s) get created
    under the `sysfs` filesystem, representing the kernel module parameter(s), here: `/sys/module/<module-name>/parameters/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sysfs` is usually mounted under `/sys`. Also, by default, all pseudo-files
    will have the owner and group as root.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for our `modparams1` kernel module (assuming it''s loaded into kernel memory),
    let''s look them up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, there they are! Not only that, the real beauty of it is that these "parameters"
    can now be read and written at will, at any time (though only with root permission,
    of course)!
  prefs: []
  type: TYPE_NORMAL
- en: 'Check it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the current value of our `mp_debug_level` kernel module parameter is indeed `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dynamically change it to `0`, implying that no "debug" messages will
    be emitted by the `modparams1` kernel module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Voilà, done. You can similarly get and/or set the `mp_strparam` parameter;
    we will leave it to you to try this as a simple exercise. This is powerful stuff:
    you could write simple scripts to control a device (or whatever) behavior via
    kernel module parameters, get (or cut off) debug info, and so on; the possibilities
    are quite endless.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, coding the third parameter to `module_param()` as a literal octal
    number (such as `0660`) is not considered best programming practice in some circles.
    Specify the permissions of the `sysfs` pseudo-file via appropriate macros (specified
    in `include/uapi/linux/stat.h`), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, having said this, our "better" Makefile''s *checkpatch* target (which,
    of course, invokes the kernel''s `scripts/checkpatch.pl` "coding-style" Perl script
    checker) politely informs us that simply using octal permissions is better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So, the kernel community disagrees. Hence, we will just use the "usual" octal
    number notation of `0660`.
  prefs: []
  type: TYPE_NORMAL
- en: Module parameter data types and validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our preceding simple kernel module, we set up two parameters of the integer
    and string data types (`charp`). What other data types can be used? Several, as
    it turns out: the `moduleparam.h` include file reveals all (within a comment,
    duplicated as follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can even define your own data types, if required. Usually, though, the standard
    types more than suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Validating kernel module parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All kernel module parameters are *optional *by default; the user may or may
    not explicitly pass them. But what if our project requires thatthe user *must
    explicitly pass* a value for a given kernel module parameter? We address this
    here: let''s enhance our previous kernel module, creating another (`ch5/modparams/modparams2`),
    the key difference being that we set up an additional parameter called `control_freak`.
    Now, we *require* that the user *must* pass this parameter along at module insertion
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up the new module parameter in code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we achieve this "mandatory passing"? Well, it''s a bit of a hack really:
    just check at insertion time whether the value is the default (`0`, here). If
    so, then abort with an appropriate message (we also do a simple validity check
    to ensure that the integer passed is within a given range). Here''s the init code
    of `ch5/modparams/modparams2/modparams2.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Also, as a quick demo, notice how we emit a printk, showing the module parameter
    values only if `mp_debug_level` is positive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, on this topic, the kernel framework provides a more rigorous way to
    "get/set" kernel (module) parameters and perform validity checking on them via
    the `module_parm_cb()` macro (`cb` for callbacks). We will not delve into this
    here; I refer you to a blog article mentioned in the *Further reading* document
    for details on using it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's move on to how (and why) we can override a module parameter's name.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the module parameter's name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To explain this feature, let''s take an example from the (5.4.0) kernel source
    tree: the direct mapping buffered I/O library driver, `drivers/md/dm-bufio.c`,
    has a need to use the `dm_bufio_current_allocated` variable as a module parameter.
    However, this name is really that of an *internal variable* and is not highly
    intuitive to a user of this driver. The authors of this driver would much prefer
    to use another name – `current_allocated_bytes` – as an *alias* or *name override.*
    Precisely this can be achieved via the `module_param_named()` macro, overriding
    and completely equivalent to the internal variable name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when the user performs `insmod` on this driver, they can do stuff like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Internally, the actual variable, `dm_bufio_current_allocated`, will be assigned
    the value `4096`.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware-related kernel parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For security reasons, module or kernel parameters that specify hardware-specific
    values have a separate macro – `module_param_hw[_named|array]()`. David Howells
    submitted a patch series for these new hardware parameters kernel support on 1
    December 2016\. The patch email [[https://lwn.net/Articles/708274/](https://lwn.net/Articles/708274/)]
    mentions the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our discussion on kernel module parameters. Let's move on to
    a peculiar aspect – that of floating-point usage within the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point not allowed in the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Years ago, when working on a temperature sensor device driver, I had an amusing
    experience (though it wasn''t quite so amusing at the time). Attempting to express
    a temperature value in millidegrees Celsius as a "regular" temperature value in
    degrees Celsius, I did something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It all went bad from there!
  prefs: []
  type: TYPE_NORMAL
- en: The venerable LDD (*Linux Device Drivers*, by *Corbet, Rubini, and G-K-Hartman*)
    book pointed out my error – **floating-point** (FP) arithmetic is not allowed
    in kernel space! It's a conscious design decision – saving processor (FP) state,
    turning on the FP unit, working on and then turning off and restoring the FP state
    is just not considered a worthwhile thing to do while in the kernel. The kernel
    (or driver) developer is well advised *to* just not attempt performing FP work
    while in kernel space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, then, you ask, how can you do the (in my example) temperature conversion?
    Simple: pass the *integer* millidegrees Celsius value *to userspace* and perform
    the FP work there!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, there is apparently a way to force the kernel to perform
    FP: put your floating-point code between the `kernel_fpu_begin()` and `kernel_fpu_end()` macros.
    There are a few places where precisely this technique is used within the kernel
    code base (typically, some code paths covering crypto/AES, CRC, and so on). Regardless,
    the recommendation is that the typical module (or driver) developer *performs
    only integer arithmetic within the kernel*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, to test this whole scenario (always remember, *the* *empirical
    approach – actually trying things out – is the only realistic way forward!*)*,* we
    write a simple kernel module that attempts to perform some FP work. The key part
    of the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It actually works, *until* *we attempt to display the FP value via* `printk()`!
    At that point, it goes quite berserk. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63160f27-b5bc-47f0-9d4d-2b10782e941b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The output of WARN_ONCE() when we try and print an FP number in
    kernel space
  prefs: []
  type: TYPE_NORMAL
- en: The key line is `Please remove unsupported %f in format string`.
  prefs: []
  type: TYPE_NORMAL
- en: This tells us the story. The system does not actually crash or panic as this
    is a mere `WARNING`, spat out to the kernel log via the `WARN_ONCE()` macro. Do
    realize, though, that on a production system, the `/proc/sys/kernel/panic_on_warn` pseudo-file will,
    in all probability, be set to the value `1`, causing the kernel to (quite rightly)
    panic.
  prefs: []
  type: TYPE_NORMAL
- en: The section in the preceding screenshot (Figure 5.3) beginning with `Call Trace:`
    is, of course, a peek into the current state of the *kernel-mode stack* of the
    process or thread that was "caught" in the preceding `WARN_ONCE()` code path (hang
    on, you will learn key details regarding the user- and kernel-mode stacks and
    so on in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml), *Kernel Internals
    Essentials – Processes and Threads*). Interpret the kernel stack by reading it
    in a bottom-up fashion; so here, the `do_one_initcall` function called `fp_in_lkm_init`
    (which belongs to the kernel module in square brackets, `[fp_in_lkm_init]`), which
    then calls `printk()`, which then ends up causing all kinds of trouble as it attempts
    to print a FP (floating point) quantity!
  prefs: []
  type: TYPE_NORMAL
- en: 'The moral is clear: *avoid using floating-point math within kernel space*.
    Let''s now move on to the topic of how you can install and auto-load kernel modules
    on system startup.'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-loading modules on system boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have written simple "out-of-tree" kernel modules that reside in
    their own private directories and have to be manually loaded up, typically via
    the `insmod(8)` or `modprobe(8)` utilities. In most real-world projects and products,
    you will require your out-of-tree kernel module(s) *to be* *auto-loaded at boot*.
    This section covers how you can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider we have a kernel module named `foo.ko`. We assume we have access to
    the source code and Makefile. In order to have it *auto-load *on system boot,
    you need to first *install* the kernel module to a known location on the system.
    To do so, we expect that the Makefile for the module contains an `install` target,
    typically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is not something new; we have been placing the `install`target within the
    `Makefile`'s of our demo kernel modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this "auto-load" procedure, we have shown the set of steps to
    follow in order to actually *install and auto-load on boot* our `ch5/min_sysinfo`
    kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, change directory to the module''s source directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it''s important to first build the kernel module (with `make`), and,
    on success, install it (as you''ll soon see, our ''better'' Makefile makes the
    process simpler by guaranteeing that the build is done first, followed by the
    install and the `depmod`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming it builds, the `sudo make install` command then *installs* the kernel
    module here, `/lib/modules/<kernel-ver>/extra/`, as expected (do see the following
    info box and tips as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: During `sudo make install`, it's possible you might see (non-fatal) errors regarding
    SSL; they can be safely ignored. They indicate that the system failed to "sign"
    the kernel module. More on this in the note on security coming up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, just in case you find that `sudo make install` fails, try the following
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Switch to a root shell (`sudo -s`) and within it, run the `make ; make install`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'b) A useful reference: *Makefile: installing external Linux kernel module,
    StackOverflow, June 2016* ([https://unix.stackexchange.com/questions/288540/makefile-installing-external-linux-kernel-module](https://unix.stackexchange.com/questions/288540/makefile-installing-external-linux-kernel-module)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another module utility, called `depmod(8)`, is then typically invoked by default
    within `sudo make install` (as can be seen from the preceding output). Just in
    case (for whatever reason) this has not occurred, you can always manually invoke `depmod`:
    its job is essentially to resolve module dependencies (see its man page for details):
    `sudo depmod`. Once you install the kernel module, you can see the effect of `depmod(8)` with
    its `--dry-run` option switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Auto-load the kernel module on boot: One way is create the `/etc/modules-load.d/<foo>.conf` config
    file (of course, you will need root access to create this file); the simple case:
    just put the kernel module''s `foo` name inside, that''s it. Any line starting
    with a `#` character is treated as a comment and ignored. For our `min_sysinfo`
    example, we have the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: FYI, another (even simpler) way to inform systemd to load up our kernel module
    is to enter the *name* of the module into the (preexisting) `/etc/modules-load.d/modules.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: Reboot the system with `sync; sudo reboot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the system is up, use `lsmod(8)` and look up the kernel log (with `dmesg(1)`, perhaps).
    You should see relevant info pertaining to the kernel module loading up (in our
    example, `min_sysinfo`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'There, it''s done: our `min_sysinfo` kernel module has indeed been auto-loaded
    into kernel space on boot!'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you just learned, you must first build your kernel module and then perform
    the install; to help automate this, our ''better'' Makefile has the following
    in it''s module installation `install` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It ensures that, first, the build is done, followed by the install and (explicitly)
    the `depmod(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if your auto-loaded kernel module requires some (module) parameters passed
    at load time? There are two ways to assure that this happens: via a so-called
    modprobe config file (under `/etc/modprobe.d/`) or, if the module''s built-in
    to the kernel, via the kernel command line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we show the first way: simply setup your modprobe configuration file (as
    an example here, we use the name `mykmod` as the name of our LKM; again, you require
    root access to create this file): `/etc/modprobe.d/mykmod.conf`; in it, you can
    pass parameters like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, the `/etc/modprobe.d/alsa-base.conf` modprobe config file on
    my x86_64 Ubuntu 20.04 LTS system contains the lines (among several others):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: A few more points on kernel module auto-loading related items follow.
  prefs: []
  type: TYPE_NORMAL
- en: Module auto-loading – additional details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a kernel module has been installed on a system (via `sudo make install`,
    as shown previously), you can also insert it into the kernel interactively (or
    via a script) simply by using a "smarter" version of the `insmod(8)` utility,
    called `modprobe(8)`. For our example, we could first `rmmod(8)` the module and
    then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As an interesting aside, consider the following. In cases where there are several
    kernel module objects to load (for example, the *module stacking* design), how
    does `modprobe` know the *order* in which to load up kernel modules? When performing
    a build locally, the build process generates a file called `modules.order`. It
    tells utilities such as `modprobe` the order in which to load up kernel modules
    such that all dependencies are resolved. When kernel modules are *installed *into
    the kernel (that is, into the `/lib/modules/$(uname -r)/extra/`, or similar, location),
    the `depmod(8)` utility generates a `/lib/modules/$(uname -r)/modules.dep` file. This
    contains the dependency information – it specifies whether a kernel module depends
    on another. Using this information, modprobe then loads them up in the required
    order. To flesh this out, let''s install our module stacking example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, the two kernel modules from our module stacking example (`core_lkm.ko`
    and `user_lkm.ko`) are now installed under the expected location, `/lib/modules/$(uname
    -r)/extra/`. Now, check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of output after `grep` is relevant: `depmod` has arranged for
    the `modules.dep` file to show that the `extra/user_lkm.ko` kernel module depends
    on the `extra/core_lkm.ko` kernel module (via the `<k1.ko>: <k2.ko>...` notation,
    implying that the `k1.ko` module depends on the `k2.ko` module). Thus, modprobe,
    seeing this, loads them in the required order, avoiding any issues.'
  prefs: []
  type: TYPE_NORMAL
- en: (FYI, while on this topic, the generated `Module.symvers` file has information
    on all exported symbols.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, recall the new(ish) `init` framework on Linux, *systemd*. The fact is,
    on modern Linux systems, it's actually systemd that takes care of auto-loading
    kernel modules at system boot, by parsing the content of files such as `/etc/modules-load.d/*` (the
    systemd service responsible for this is `systemd-modules-load.service(8)`. For
    details, refer to the man page on `modules-load.d(5)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, sometimes you might find that a certain auto-loaded kernel module
    is misbehaving – causing lockups or delays, or it simply doesn''t work – and so
    you want to definitely disable loading it. This can be done by *blacklisting*the
    module. You can specify this either on the kernel command line (convenient when
    all else fails!) or within the (previously mentioned) `/etc/modules-load.d/<foo>.conf`
    config file. On the kernel command line, via `module_blacklist=mod1,mod2,...`,
    the kernel docs shows us the syntax/explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: You can look up the current kernel command line by doing `cat /proc/cmdline`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While on the topic of the kernel command line, several other useful options
    exist, enabling us to use the kernel''s help for debugging issues concerned with
    kernel initialization. As an example, among several others, the kernel provides
    the following parameters in this regard (source: [https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: FYI, and as mentioned earlier in this chapter, there is an alternate framework
    for third-party kernel module auto-rebuilding, called **Dynamic Kernel Module
    Support** (**DKMS**).
  prefs: []
  type: TYPE_NORMAL
- en: The *Further reading *document for this chapter also provides some helpful links.
    In conclusion, auto-loading kernel modules into memory on system startup is a
    useful and often required functionality in a product. Building high-quality products
    requires a keen understanding of, and the knowledge to build in, *security*; that's
    the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel modules and security – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ironic reality is that enormous efforts spent on improving *user space* security
    considerations have resulted in a pretty large payoff over recent years. A malicious
    user performing a viable **Buffer Overflow** (**BoF**) attack was well within
    the realms of possibility a couple of decades back, but today is really hard to
    do. Why? Because there are many layers of beefed-up security mechanisms to prevent
    many of these attack classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly name a few countermeasures: compiler protections (`-fstack-protector[...],'
  prefs: []
  type: TYPE_NORMAL
- en: -Wformat-security, -D_FORTIFY_SOURCE=2`, partial/full RELRO, better sanity and
    security checker tools (`checksec.sh`, the address sanitizers, paxtest, static
    analysis tools, and so on), secure libraries, hardware-level protection mechanisms
    (NX, SMEP, SMAP, and so on), [K]ASLR, better testing (fuzzing), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The irony is that *kernel-space *attacks have become increasingly common over
    the last few years! It has been demonstrated that revealing even a single valid
    kernel (virtual) address (and it''s corresponding symbol) to a clever attacker
    can allow her to figure the location of some key internal kernel structures, paving
    the way to carry out all kinds of **privilege escalation** (**privesc**) attacks.
    Thus, even revealing a single innocent-looking piece of kernel information (such
    as a kernel address and the symbol it''s associated with) is a potential **information
    leak** (or info-leak) and must be prevented on production systems. Coming up,
    we will enumerate and briefly describe a few security features that the Linux
    kernel provides. However, ultimately, the kernel developer – you! – have a large
    role to play: writing secure code, to begin with! Using our ''better'' Makefile
    is a great way to get started - several targets within it are concerned with security
    (all the static analysis ones, for example).'
  prefs: []
  type: TYPE_NORMAL
- en: Proc filesystem tunables affecting the system log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We directly refer you to the man page on `proc(5)` – very valuable! – to glean
    information on these two security-related tunables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dmesg_restrict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kptr_restrict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, `dmesg_restrict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The default (on both our Ubuntu and Fedora platforms) is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Linux kernels use the powerful fine-granularity POSIX *capabilities* model.
    The `CAP_SYS_ADMIN` capability essentially is a catch-all for what is traditionally *root
    (superuser/sysadmin) *access. The `CAP_SYSLOG` capability gives the process (or
    thread) the capability to perform privileged `syslog(2)` operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned, "leaking" a kernel address and the symbol it''s associated
    with might result in an info-leak-based attack. To help prevent these, kernel
    and module authors are advised to always print kernel addresses using a new `printf`-style
    format: instead of the familiar `%p` or `%px` to print a kernel address, you should
    use the newer **`%pK`** format specifier for printing an address. (Using the `%px`
    format specifier ensures the actual address is printed; you''ll want to avoid
    this in production). How does this help? Read on...'
  prefs: []
  type: TYPE_NORMAL
- en: The `kptr_restrict`tunable (2.6.38 onward) affects the `printk()` output when
    printing kernel addresses; doing `printk("&var = **%pK**\n", &var);`
  prefs: []
  type: TYPE_NORMAL
- en: 'and not the good old `printk("&var = %p\n", &var);` is considered a security
    best practice. Understanding how exactly the `kptr_restrict` tunable works is
    key to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The default (on both our recent-enough Ubuntu and Fedora platforms) is `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You can – rather, *must* – change these tunables on production systems to a
    secure value (1 or 2) for security. Of course, security measures only work when
    developers make use of them; as of the 5.4.0 Linux kernel, there is a total of
    (just!) 14 uses of the `%pK` format specifier in the entire Linux kernel code
    base (out of a total of about 5,200-odd uses of printk employing the `%p`, and
    around 230 explicitly employing the `%px` format specifier).
  prefs: []
  type: TYPE_NORMAL
- en: a) As `procfs` is, of course, a volatile filesystem, you can always make the
    changes permanent by using the `sysctl(8)` utility with the `-w` option switch
    (or by directly updating the `/etc/sysctl.conf` file).
  prefs: []
  type: TYPE_NORMAL
- en: b) For the purpose of debugging, if you must print an actual kernel (unmodified)
    address, you're advised to use the `%px` format specifier; do remove these prints
    on production systems!
  prefs: []
  type: TYPE_NORMAL
- en: c) Detailed kernel documentation on `printk` format specifiers can be found
    at [https://www.kernel.org/doc/html/latest/core-api/printk-formats.html#how-to-get-printk-format-specifiers-right](https://www.kernel.org/doc/html/latest/core-api/printk-formats.html#how-to-get-printk-format-specifiers-right);
    do browse through it.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of hardware-level defects in early 2018 (the now well-known *Meltdown,
    Spectre,* and other processor speculation security issues), there was a sense
    of renewed urgency in *detecting information leakage, *thus enabling developers
    and administrators to block them off.
  prefs: []
  type: TYPE_NORMAL
- en: A useful Perl script, `scripts/leaking_addresses.pl`, was released in mainline
    in 4.14 (in November 2017; I am happy to have lent a hand in this important work: [https://github.com/torvalds/linux/commit/1410fe4eea22959bd31c05e4c1846f1718300bde](https://github.com/torvalds/linux/commit/1410fe4eea22959bd31c05e4c1846f1718300bde)),
    with more checks being made for detecting leaking kernel addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The cryptographic signing of kernel modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a malicious attacker gets a foothold on a system, they will typically attempt
    some kind of privesc vector in order to gain root access. Once this is achieved,
    the typical next step is to install a *rootkit*: essentially, a collection of
    scripts and kernel modules that will pretty much take over the system (by "hijacking"
    system calls, setting up backdoors and keyloggers, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it's not easy – the security posture of a modern production quality
    Linux system, replete with **Linux Security Modules** (**LSMs**), and so on, means
    it's not at all a trivial thing to do, but for a skilled and motivated attacker,
    anything's possible. Assuming they have a sufficiently sophisticated rootkit installed,
    the system is now considered compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting idea is this: even with root access, do not allow `insmod(8)`
    (or `modprobe(8)`, or even the underlying `[f]init_module(2)` system calls) to
    insert kernel modules into kernel address space **unless they are cryptographically
    signed with a security key** that is in the kernel''s keyring*.* This powerful
    security feature was introduced with the 3.7 kernel (the relevant commit is here:
    [https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=106a4ee258d14818467829bf0e12aeae14c16cd7](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=106a4ee258d14818467829bf0e12aeae14c16cd7)).'
  prefs: []
  type: TYPE_NORMAL
- en: The details on performing cryptographic signing of kernel modules is beyond
    the scope of this book; you can refer to the official kernel documentation here: [https://www.kernel.org/doc/html/latest/admin-guide/module-signing.html](https://www.kernel.org/doc/html/latest/admin-guide/module-signing.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'A few relevant kernel configuration options concerned with this feature are
    `CONFIG_MODULE_SIG`, `CONFIG_MODULE_SIG_FORCE`, `CONFIG_MODULE_SIG_ALL`, and so
    on. To help understand what exactly this means, see the `Kconfig ''help''` section
    for the first of them, as follows (from `init/Kconfig`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MODULE_SIG_FORCE` kernel config is a Boolean value (defaults to `n`).
    It only comes into play if `MODULE_SIG` is turned on. If `MODULE_SIG_FORCE` is
    set to `y`, then kernel modules *must* have a valid signature in order to be loaded.
    If not, loading will fail. If its value is left as `n`, this implies that even
    kernel modules that aren''t signed will be loaded into the kernel, but the kernel
    will be marked as tainted. This tends to be the default on a typical modern Linux
    distribution. In the following code block, we look up these kernel configs on
    our x86_64 Ubuntu 20.04.1 LTS guest VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The cryptographic signing of kernel modules is encouraged on production systems
    (in recent years, with (I)IoT edge devices becoming more prevalent, security is
    a key concern).
  prefs: []
  type: TYPE_NORMAL
- en: Disabling kernel modules altogether
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Paranoid folks might want to completely disable the loading (and unloading)
    of kernel modules. Rather drastic, but hey, this way you can completely lock down
    the kernel space of a system (as well as render any rootkits pretty much harmless).
    This can be achieved in two broad ways:'
  prefs: []
  type: TYPE_NORMAL
- en: First, by setting the `CONFIG_MODULES` kernel config to off (it's on, of course,
    by default) during kernel config prior to building. Doing this is pretty drastic
    – it makes the decision a permanent one!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, assuming `CONFIG_MODULES` is turned on, module loading can be dynamically
    turned off at runtime via the `modules_disabled` `sysctl`tunable; take a look
    at this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s *off* (`0`) by default, of course. As usual, the man page on `proc(5)` tells
    us the story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In conclusion, of course, kernel security hardening and malicious attacks are
    a cat-and-mouse game. For example, (K)ASLR (we talk about what (K)ASLR means in
    the chapters to come on Linux memory management) is quite regularly defeated.
    Also, see this article – *Effectively bypassing kptr_restrict on Android*: [http://bits-please.blogspot.com/2015/08/effectively-bypassing-kptrrestrict-on.html](http://bits-please.blogspot.com/2015/08/effectively-bypassing-kptrrestrict-on.html). Security
    is not easy; it''s always a work in progress. It (almost) goes without saying:
    developers – in both user and kernel space – *must* write code that is security-aware
    and use tools and testing on a continuous basis*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let's complete this chapter with topics on coding style guidelines for the Linux
    kernel, accessing kernel documentation, and how you can go about contributing
    to the mainline kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Coding style guidelines for kernel developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many large projects specify their own set of coding guidelines; so does the
    Linux kernel community. Adhering to the Linux kernel *coding style* guidelines
    is a really good idea. You can find them officially documented here: [https://www.kernel.org/doc/html/latest/process/coding-style.html](https://www.kernel.org/doc/html/latest/process/coding-style.html) (please
    do read it!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, as part of the (quite exhaustive) code-submission checklist(s)
    for developers like you wanting to upstream your code, you are expected to run
    your patch through a Perl script that checks your code for congruence with the
    Linux kernel coding style: `scripts/checkpatch.pl`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, this script only runs on a well-formatted `git` patch. It''s possible
    to run it against standalone C code (as in your out-of-tree kernel module code),
    as follows (as our ''better'' Makefile indeed does):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this as a habit on your kernel code is helpful, enabling you to catch
    those annoying little issues – plus more serious ones! – that might otherwise
    hold your patch up. Again, we remind you: our "better" Makefile''s `indent` and
    `checkpatch` targets are geared toward this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides coding style guidelines, you will find that every now and then, you
    need to dig into the elaborate and useful kernel documentation. A gentle reminder:
    we covered locating and using the kernel documentation in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml),
    *Kernel Workspace Setup*, under the *Locating and Using the Linux Kernel Documentation*
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now complete this chapter by making a brief mention of how you can
    get started on a noble objective: contributing code to the mainline Linux kernel
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: Contributing to the mainline kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we typically perform kernel development *outside *the kernel source
    tree, via the LKM framework. What if you are writing code *within *the kernel
    tree, with the explicit goal of *upstreaming* your code to the kernel mainline?
    This is a laudable goal indeed – the whole basis of open source stems from the
    community's willingness to put in work and contribute it upstream to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with contributing to the kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most frequently asked question, of course, is *how do I get started*?To
    help with precisely this, a long and very detailed answer lies within the kernel
    documentation here: *HOWTO do Linux kernel development*: [https://www.kernel.org/doc/html/latest/process/howto.html#howto-do-linux-kernel-development](https://www.kernel.org/doc/html/latest/process/howto.html#howto-do-linux-kernel-development).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a matter of fact, you can generate the full Linux kernel documentation (via
    the `make pdfdocs` command, in the root of the kernel source tree); once successful,
    you will find this PDF document here: `<root-of-kernel-source-tree>/Documentation/output/latex/development-process.pdf`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a very detailed guide to the Linux kernel development process, including
    guidelines for code submission. A cropped screenshot of this document is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b621a0c-964d-4b25-8c8b-9a63ad58ae79.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – (Partial) screenshot of the kernel development docs just generated
  prefs: []
  type: TYPE_NORMAL
- en: As part of this kernel development process, to maintain quality standards, a
    rigorous and *must-be-followed* checklist – a long recipe of sorts! – is very
    much part of the kernel patch submission process. The official checklist resides
    here: *Linux Kernel patch submission checklist*: [https://www.kernel.org/doc/html/latest/process/submit-checklist.html#linux-kernel-patch-submission-checklist](https://www.kernel.org/doc/html/latest/process/submit-checklist.html#linux-kernel-patch-submission-checklist).
  prefs: []
  type: TYPE_NORMAL
- en: Though it may seem an onerous task for a kernel newbie, carefully following
    this checklist lends both rigor and credibility to your work and ultimately results
    in superior code. I strongly encourage you to read through the kernel patch submission
    checklist and try out the procedures mentioned therein.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a really practical hands-on tip, an almost guaranteed way to become
    a kernel hacker? Of course, keep reading this book! Ha ha, yes, besides, do partake
    in the simply awesome **Eudyptula Challenge** ([http://www.eudyptula-challenge.org/](http://www.eudyptula-challenge.org/)) Oh,
    hang on, it's – very unfortunately, and as of the time of writing – closed down.
  prefs: []
  type: TYPE_NORMAL
- en: Fear not; here's a site with all the challenges (and solutions, but don't cheat!)
    posted. Do check it out and try the challenges. This will greatly accelerate your
    kernel hacking skills: [https://github.com/agelastic/eudyptula](https://github.com/agelastic/eudyptula).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the second of two on writing a kernel module using the LKM framework,
    we covered several (remaining) areas pertaining to this important topic: among
    them, using a "better" Makefile for your kernel module,  tips on configuring a
    debug kernel (it''s very important!), cross-compiling a kernel module, gathering
    some minimal platform information from within a kernel module, and even a bit
    on the licensing of kernel modules. We also looked at emulating library-like features
    with two different approaches (one - preferred - the linking approach, and two,
    the module stacking approach), using module parameters, avoiding floating-point,
    the auto-loading of your kernel modules, and so on. Security concerns and how
    they can be addressed are important. Finally, we wrapped up this chapter by covering
    kernel coding style guidelines, kernel documentation, and how you can get started
    with contributing to the mainline kernel. So, congratulations! You now know how
    to develop a kernel module and can even get started on the journey to kernel upstream
    contribution.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into an interesting and necessary topic.
    We will begin our exploration in some depth into the *internals *of both the Linux
    kernel and its memory management subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To aid you in delving deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times even books)
    in a *Further reading* markdown document – organized by chapter – in this book's
    GitHub repository. The *Further reading* document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  prefs: []
  type: TYPE_NORMAL
