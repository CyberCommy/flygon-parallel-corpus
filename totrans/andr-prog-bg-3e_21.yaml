- en: '*Chapter 21*: Threads and Starting the Live Drawing App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get started on our next app. This app will be a kid's
    drawing app where the user can draw on the screen with their finger. This drawing
    app will be slightly different, however. The lines that the user draws will comprise
    particle systems that explode into thousands of pieces. We will call the project
    Live Drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get started with the Live Drawing app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about real-time interaction, sometimes called a game loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code a real-time system ready to draw with in the next chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2021](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2021).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Live Drawing project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, create a new project in Android Studio and call it `Live Drawing`.
    Use the **Empty Activity** project.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will consider the name of the files and the screen real estate. In this
    project, we will learn something new. It is not always appropriate to use the
    default name for our Activity class. In this project, the Activity class isn't
    going to be the most significant class and `MainActivity` doesn't seem like an
    appropriate name. Let's rename it.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring MainActivity to LiveDrawingActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a good practice to use meaningful names for all the different parts of
    our code. For this project, I think `MainActivity` is a bit vague and inconclusive.
    We could make do with it, but let's rename it to something more meaningful. This
    will also let us see how we can use the `MainActivity` filename to `LiveDrawingActivity`,
    Android Studio will change the name of the file as well as some code in the `AndroidManifest.xml`
    file and the `MainActivity.java` (soon to be `LiveDrawingActivity.java`) file.
  prefs: []
  type: TYPE_NORMAL
- en: In the project panel, right-click the `MainActivity` file and select **Refactor**
    | **Rename**. In the pop-up window, change **MainActivity** to **LiveDrawingActivity**.
    Leave all the other options as their defaults and left-click the **Refactor**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the filename in the project panel has changed as expected but also multiple
    occurrences of `MainActivity` have been changed to `LiveDrawingActivity` in the
    `AndroidManifest.xml` file as well as an instance in the `LiveDrawingActivity.java`
    file. You can scan these files now to see this if you are interested, but we will
    go into more detail about both files in the upcoming sections anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring is an important tool and understanding that there is more going
    on behind the scenes is vital to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Locking the game to fullscreen and landscape orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to use every pixel that the user's Android device has to offer so we
    will make changes to the `AndroidManifest.xml` file, which allows us to use a
    style for our app that hides all the default menus from the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AndroidManifest.xml` file from the `manifests` folder. In the `AndroidManifest.xml`
    file, locate the following line of code: `android:name=".LiveDrawingActivity">.`'
  prefs: []
  type: TYPE_NORMAL
- en: Place the cursor before the closing `>` shown previously. Tap the *Enter* key
    a couple of times to move the `>` a couple of lines below the rest of the line
    shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately below `".LiveDrawingActivity"` but before the newly positioned `>`,
    type or copy and paste this next line of code to make the game run without the
    default user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the line of code is shown on two lines because it is too long to
    fit on a printed page, but in Android Studio you should enter it as one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fiddly set of steps so here I am showing you a bigger range of this
    file with the code we just added highlighted among it for extra context. As mentioned
    previously, I have had to show some lines of code over two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now our app will use all the screen space the device makes available without
    any extra menus. We will also see some new Java code to make our app dominate
    every pixel of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Making some placeholder classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This app consists of Java files only. The Java files with all the code up to
    the end of this chapter can all be found in the [*Chapter 21*](B16773_21_ePub_RK.xhtml#_idTextAnchor366)
    folder of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create empty classes that we will code throughout the project
    over the next two chapters. Create a new class called `LiveDrawingView`, a new
    class called `ParticleSystem`, and a new class called `Particle`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look ahead a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead at the Live Drawing app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As this app is more in-depth and needs to respond in real-time, it is necessary
    to use a slightly more in-depth structure. At first, this seems like a complication
    but in the long run, it can even make our code simpler and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have four classes in the Live Drawing app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LiveDrawingActivity`: The `Activity` class provided by the Android API is
    the class that interacts with the operating system. We have already seen how the
    OS interacts with `onCreate` when the user clicks the app icon to start an app.
    Rather than have a class called `MainActivity` that does everything, we will have
    an Activity-based class that just handles the startup and shutdown of our app
    as well as helping a bit with initialization by getting the screen resolution.
    It makes sense that this class will be of type `Activity`. However, as you will
    soon see, we will delegate interacting with touches to another class, the same
    class that will also handle almost every aspect of the app. This will introduce
    us to some interesting concepts that will be new to us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveDrawingView`: This is the class that will be responsible for doing the
    drawing and creating the real-time environment, which allows the user to interact
    at the same time as their creations are moving and evolving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParticleSystem`: This is the class that will manage up to thousands of instances
    of the `Particle` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Particle`: This class will be the simplest of them all. It will have a location
    onscreen and a heading. It will update itself around 60 times per second when
    prompted to by the `LiveDrawingView` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the LiveDrawingActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started with coding the `Activity` based class. We called this class
    `LiveDrawingActivity` when we refactored `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the contents of the `LiveDrawingActivity` class (excluding the package
    declaration) with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code shows some errors and we will talk about them shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first new line of code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This line of code removes the title from the user interface. The screen will
    be completely empty when we run this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code gets the number of pixels (wide and high) for the device in the following
    way. Look again at the next new line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We create an object of type `Display` called `display` and initialize it with
    the result of calling both `getWindowManager` then `getDefaultDisplay` methods
    in turn, which are part of the `Activity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create a new object called `size` of the `Point` type. We send `size`
    as an argument to the `display.getSize` method. The `Point` type has an `x` and
    `y` member variable, and therefore, so does the `size` object, which after the
    third line of code now holds the width and height (in pixels) of the display.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the screen resolution in `x` and `y` variables hidden away in the
    `size` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next new thing is that we are declaring an instance of our `LiveDrawingView`
    class. Currently, this is an empty class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next in the `onCreate` method, we initialize `mLiveDrawingView` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing is passing three arguments to the `LiveDrawingView` constructor.
    We have obviously not coded a constructor yet and as we know the default constructor
    takes zero arguments. Therefore, this line will cause an error until we fix it.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments passed in are interesting. First, `this`, which is a reference
    to the `LiveDrawingActivity` class. The `LiveDrawingView` class will need to use
    methods that it needs this reference for.
  prefs: []
  type: TYPE_NORMAL
- en: The second and third arguments are the horizontal and vertical screen resolution.
    It makes sense that our app will need these to perform tasks such as detecting
    the edge of the screen and scaling the drawing objects to an appropriate size.
    We will discuss these arguments further when we get to coding the `LiveDrawingView`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, take a look at the line that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is where, in the Canvas Demo app, we set the `ImageView` as the content
    for the app. Remember that the `Activity` class's `setContentView` method must
    take a `View` object and `ImageView` is a `View`. This previous line of code seems
    to be suggesting that we will use our `LiveDrawingView` class as the visible content
    for the app. But `LiveDrawingView`, despite its name, isn't a `View`. Not yet
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: We will fix the constructor and the not a `View` problem after we add a few
    more lines of code to `LiveDrawingActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Reader challenge
  prefs: []
  type: TYPE_NORMAL
- en: Can you guess which OOP concept the solution might be?
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these two overridden methods and then we will talk about them. Add them
    below the closing curly brace of the `onCreate` method but before the closing
    curly brace of the `LiveDrawingActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is to override two more of the methods of the `Activity` class.
    We will see why we need to do this and what we will do inside these methods. The
    point to note here is that by adding these overridden methods, we are giving the
    OS the opportunity to notify us of the user's intentions in two more situations.
    Much as we did when saving and loading our data in the Note to Self app.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense at this point to move on to the `LiveDrawingView` class, the
    main class of this app. We will come back to the `LiveDrawingActivity` class near
    the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the LiveDrawingView class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we will do is solve the problem of our `LiveDrawingView` class
    not being of type `View`. Update the class declaration as highlighted, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will need to import the `android.view.SurfaceView` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`SurfaceView` is a descendant of `View` and now `LiveDrawingView` is, by inheritance,
    also a type of `View`. Look again at the `import` statement that has been added.
    This relationship is made clear as highlighted next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that it is because of polymorphism that we can send descendants of
    `View` to the `setContentView` method in the `LiveDrawingActivity` class and it
    is because of inheritance that the `LiveDrawingView` class is now a type of `SurfaceView`.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few descendants of `View` that we could have extended to fix
    this initial problem, but we will see as we continue that the `SurfaceView` class
    has some very specific features that are perfect for real-time-interactive apps
    that made this choice the right one for us.
  prefs: []
  type: TYPE_NORMAL
- en: We still have errors in both this class and the `LiveDrawingActivity` class.
    Both are due to the lack of a suitable constructor method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot showing the error in the `LiveDrawingView` class since
    we extended `SurfaceView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 21.1 – The error in the LiveDrawingView class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_21.1_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 21.1 – The error in the LiveDrawingView class
  prefs: []
  type: TYPE_NORMAL
- en: The error in `LiveDrawingActivity` is more obvious; we are calling a method
    that doesn't exist. However, the error shown in the previous screenshot is less
    easily understood. Let's discuss the error in the `LiveDrawingView` class declaration
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The `LiveDrawingView` class, now it is a `SurfaceView`, must be supplied with
    a constructor because, as mentioned in the OOP chapters, once you have provided
    your own constructor the default (no parameter) one ceases to exist. As the `SurfaceView`
    class implements several different constructors, we must specifically implement
    one of these or write our own. Hence the previous error.
  prefs: []
  type: TYPE_NORMAL
- en: As none of the `SurfaceView` provided constructors are exactly what we need,
    we will provide our own.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are wondering how on earth you know what constructors are supplied and
    any other details you need to find out about an Android class, just Google it.
    Type the class name followed by `API`. Google will almost always supply as the
    top result a link to the relevant page on the Android developer''s website. Here
    is a direct link to the `SurfaceView` page: [https://developer.android.com/reference/android/view/SurfaceView.html](https://developer.android.com/reference/android/view/SurfaceView.html).
    Look under the **Public constructors** heading, and you will see that some constructors
    are optionally made available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LiveDrawingActivity` also requires us to create a constructor that matches
    the way we try to initialize it in this line of code from the `LiveDrawingActivity`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a constructor that matches the call from `LiveDrawingActivity` that
    passes in `this` and the screen resolution and solve both problems at once.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the LiveDrawingView class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember that the `LiveDrawingView` class cannot see the variables in the `LiveDrawingActivity`
    class. By using the constructor, `LiveDrawingActivity` is providing `LiveDrawingView`
    with a reference to itself (`this`) as well as the screen size in pixels contained
    in `size.x` and `size.y`. Add this constructor to the `LiveDrawingView.java` file.
    The code must go within the opening and closing curly braces of the class. It
    is a convention but not required to place constructors above other methods but
    after member variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Context` class with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.content.Context;`'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have no errors in our `LiveDrawingView` class or the `LiveDrawingActivity`
    class that initializes it.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we could run the app and see that using `LiveDrawingView` as
    the `View` in `setContentView` has worked and we have a beautiful blank screen,
    ready to draw our particle systems on. Try this if you like, but we will be coding
    the `LiveDrawingView` class so that it does something, including adding code to
    the constructor, next.
  prefs: []
  type: TYPE_NORMAL
- en: We will be returning to this class constantly over the course of this project.
    What we will do right now is get the fundamentals set up ready to add the `ParticleSystem`
    instances after we have coded them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, first, we will add a bunch of member variables, then we will
    add some code inside the constructor to set the class up when it is instantiated/created
    by `LiveDrawingActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Following on, we get to code the `draw` method, which will reveal the new steps
    that we need to take to draw on the screen 60 times per second and we will also
    see some familiar code that uses our old friends `Canvas`, `Paint`, and `drawText`
    from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to discuss some more theory – things such as how we will
    time the animations of the particles and how we lock these timings without interfering
    with the smooth running of Android. These last two topics, the **game loop** and
    **threads**, will then allow us to add the final code of the chapter and witness
    our particle system painting app in action – albeit with just a bit of text.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A game loop is a concept that describes allowing virtual systems to update and
    draw themselves at the same time as allowing them to be altered/interacted with
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the member variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the variables as shown below, after the `LiveDrawingView` declaration but
    before the constructor, then import the necessary extra classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `import` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to study the code and then we can talk about it.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the naming convention of adding `m` before the member variable
    names. As we add local variables in the methods, this will help distinguish them
    from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that all the variables are declared `private`. You could happily
    delete all the `private` access specifiers and the code would still work but as
    we have no need to access any of these variables from outside of this class, it
    is sensible to guarantee it can never happen by declaring them `private`.
  prefs: []
  type: TYPE_NORMAL
- en: The first member variable is `DEBUGGING`. We have declared this as `final` because
    we don't want to change its value during the app's execution. Note that declaring
    it `final` does not preclude us from switching its value manually when we wish
    to switch between debugging and not debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three classes we declared instances of will handle the drawing on
    the screen. Notice the new one we have not seen before that I have highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `SurfaceHolder` class is required to enable drawing to take place. It literally
    is the object that *holds* the drawing surface. We will see the methods it allows
    us to use to draw on the screen when we code the `draw` method in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two variables give us a bit of insight into what we will need to achieve
    our smooth and consistent animation. Here they are again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `mFPS` variable is of type `long` because it will be holding a huge number.
    Computers measure time in milliseconds since 1970 – more on that when we talk
    about the game loop. But for now, we need to know that monitoring and measuring
    the speed of each frame of animation is how we will make sure that the particles
    move exactly as they should.
  prefs: []
  type: TYPE_NORMAL
- en: The first `mFPS` will be reinitialized every frame of animation, around 60 times
    per second. It will be passed into each of the particle system (every frame of
    animation) so that it knows how much time has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: The `MILLIS_IN_SECOND` variable is initialized to `1000`. There are indeed `1000`
    milliseconds in a second. We will use this variable in calculations as it will
    make our code clearer than if we used the literal value `1000`. It is declared
    `final` because the number of milliseconds in a second will obviously never change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next piece of the code we just added is shown again here for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The variables `mScreenX` and `mScreenY` will hold the horizontal and vertical
    resolution of the screen. Remember that they are being passed in from `LiveDrawingActivity`
    into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The next two, `mFontSize` and `mMarginSize`, will be initialized based on the
    screen size in pixels, to hold a value in pixels to make the formatting of our
    text neat and more concise than constantly doing calculations for each bit of
    text.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can begin to initialize some of these variables in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the LiveDrawingView constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the highlighted code to the constructor. Be sure to study the code as well
    and then we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code we just added to the constructor begins by using the values passed
    in as parameters (`x` and `y`) to initialize `mScreenX` and `mScreenY`. Our entire
    `LiveDrawingView` class now has access to the screen resolution whenever it needs
    it. Here are the two lines again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initialize `mFontSize` and `mFontMargin` as a fraction of the screen
    width in pixels. These values are a bit arbitrary, but they work, and we will
    use various multiples of these variables to align text neatly on the screen. Here
    are the two lines of code I am referring to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on, we initialize our `Paint` and `SurfaceHolder` objects. `Paint` uses
    the default constructor as we have done previously but `mHolder` uses the `getHolder`
    method, which is a method of the `SurfaceView` class. The `getHolder` method returns
    a reference that is initialized to `mHolder` so `mHolder` is now that reference.
    In short, `mHolder` is now ready to be used. We have access to this handy method
    because `LiveDrawingView` is a `SurfaceView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will need to do more preparation in the `draw` method before we can use our
    `Paint` and `Canvas` classes as we have done before. We will see exactly what
    very soon. Notice the comments indicating where we will eventually get around
    to initializing the particle systems as well as two control buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get ready to draw.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the draw method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the `draw` method shown next immediately after the constructor method.
    There will be a couple of errors in the code. We will deal with them, then we
    will go into detail about how the `draw` method will work in relation to the `SurfaceView`
    class because there are some completely alien-looking lines of code in there as
    well as some familiar ones. This is the code to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two errors. One is that the `Color` class needs importing. You can
    fix this in the usual way or add the next line of code manually. Whichever method
    you choose, the following extra line needs to be added to the code at the top
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's deal with the other error.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the printDebuggingText method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second error is the call to `printDebuggingText`. The method doesn't exist
    yet. Let's add that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code after the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The previous code uses the local variable `debugSize` to hold a value that is
    half that of the member variable `mFontSize`. This means that as `mFontSize` (which
    is used for the HUD) is initialized dynamically based on the screen resolution,
    `debugSize` will always be half that. The `debugSize` variable is then used to
    set the size of the font before we start drawing the text. The `debugStart` variable
    is just a guess at a good position vertically to start printing the debugging
    text.
  prefs: []
  type: TYPE_NORMAL
- en: These two values are then used to position a line of text on the screen that
    shows the current frames per second. As this method is called from `draw`, which
    in turn will be called from the game loop, this line of text will be constantly
    refreshed up to 60 times per second.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that on very high- or very low-resolution screens, you might
    need to experiment with the text size to find something more appropriate for your
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore those new lines of code in the `draw` method and exactly how we
    can use `SurfaceView`, from which our `LiveDrawingView` class is derived, to handle
    all our drawing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the draw method and the SurfaceView class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting in the middle of the method and working outwards for a change, we
    have a few familiar things such as the calls to the `drawColor`, `setTextSize`,
    and `drawText` methods. We can also see the comment that indicates where we will
    eventually add code to draw the particle systems and the HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: The `drawColor` code clears the screen with a solid color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setTextSize` method sets the size of the text for drawing the HUD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will code drawing the HUD once we have explored particle systems a little
    more. We will let the player know how many particles and systems their drawing
    comprises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is totally new, however, is the code at the very start of the `draw` method.
    Here it is again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement contains a call to `getSurface` and chains it with a call
    to `isValid`. If this line returns `true`, it confirms that the area of memory
    that we want to manipulate to represent our frame of drawing is available, and
    the code continues inside the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: What goes on inside those methods (especially the first) is quite complex. They
    are necessary because all our drawing and other processing (such as moving the
    objects) will take place asynchronously with the code that detects the user input
    and listens to the operating system for messages. This wasn't an issue in the
    previous project because our code just drew a single frame and then sat there
    waiting.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to execute the code 60 times a second, we are going to need to confirm
    that we have access to the memory – before we access it.
  prefs: []
  type: TYPE_NORMAL
- en: This raises more questions about how this code runs asynchronously. That will
    be answered when we discuss threads shortly. For now, just know that the line
    of code checks if some other part of our code or Android itself is currently using
    the required portion of memory. If it is free, then the code inside the `if` statement
    executes.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the first line of code to execute inside the `if` statement calls
    the `lockCanvas` method so that if another app or Android tries to access the
    memory while our code is accessing it, it won't be able to. Then we do all our
    drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the `draw` method, there is this next line (plus comments) right
    at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `unlockCanvasAndPost` method sends our newly decorated `Canvas` object (`mCanvas`)
    for drawing to the screen and releases the lock so that other areas of code can
    use it again – albeit very briefly before the whole process starts again. This
    process happens in every single frame of animation.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand the code in the `draw` method; however, we still don't have
    the mechanism that calls the `draw` method over and over. In fact, we don't even
    call the `draw` method once. We need to talk about game loops and threads.
  prefs: []
  type: TYPE_NORMAL
- en: The game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a game loop anyway? Almost every live drawing/graphics game has a game
    loop. Even games you might suspect do not, such as turn-based games, still need
    to synchronize player input with drawing and AI while following the rules of the
    underlying operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a constant need to update the objects in the app, perhaps by moving
    them, drawing everything in its current position at the same time as responding
    to user input. A diagram might help:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 21.2 – Game loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_21.2_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 21.2 – Game loop
  prefs: []
  type: TYPE_NORMAL
- en: 'Our game loop comprises three main phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Update all game/drawing objects by moving them, detecting collisions, and processing
    AI such as the particle movements and state changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the just-updated data, draw the frame of animation in its latest state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Respond to screen touches from the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already have a `draw` method for handling that part of the loop. This suggests
    that we will have a method to do all the updating as well. We will soon code the
    outline of an `update` method. In addition, we know that we can respond to screen
    touches although we will need to adapt slightly from all the previous projects
    because we are not working inside an Activity or using conventional UI widgets
    in a layout anymore.
  prefs: []
  type: TYPE_NORMAL
- en: There is a further issue in that (as I briefly mentioned) all the updating and
    drawing happens asynchronously to the detection of screen touches and listening
    to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Just to be clear, asynchronous means that it does not occur at the same time.
    Our game code will work by sharing execution time with Android and the user interface.
    The CPU will very quickly switch back and forth between our code and Android/user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: But how exactly will these three phases be looped through? How will we code
    this asynchronous system within which the `update` and `draw` methods can be called
    and how will we make the loop run at the correct speed (frame rate)?
  prefs: []
  type: TYPE_NORMAL
- en: As we can probably guess, writing an efficient game loop is not as simple as
    a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Our game loop will, however, also contain a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: We need to consider timing, starting and stopping the loop, as well as not causing
    the OS to become unresponsive because we are monopolizing the entire CPU within
    our loop.
  prefs: []
  type: TYPE_NORMAL
- en: But when and how do we call our `draw` method? How do we measure and keep track
    of the frame rate? With these things in mind, our finished game loop can probably
    be better represented by this next diagram. Notice the introduction of the concept
    of **threads**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 21.3 – Finished game loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_21.3_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 21.3 – Finished game loop
  prefs: []
  type: TYPE_NORMAL
- en: Now we know what we want to achieve, let's learn about threads.
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is a thread? You can think of threads in programming in the same way
    you do threads in a story. In one thread of a story, we might have the primary
    character battling the enemy on the frontline while in another thread the soldier's
    family is getting by, day to day. Of course, a story doesn't have to have just
    two threads; we could introduce a third thread. Perhaps the story also tells of
    the politicians and military commanders making decisions. And these decisions
    then subtly, or not so subtly, affect what happens in the other threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming threads are just like this. We create parts/threads in our program
    that control different aspects for us. In Android, threads are especially useful
    when we need to ensure that a task does not interfere with the main (UI) thread
    of the app or if we have a background task that takes a long time to complete
    and must not interrupt the main thread of execution. We introduce threads to represent
    these different aspects because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They make sense from an organizational point of view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are a proven way of structuring a program that works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of the system we are working on forces us to use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Android, we use threads for all three reasons simultaneously. It makes sense,
    it works, and we must because the design of the Android system requires it.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we use threads without knowing about it. This happens because we use
    classes that use threads on our behalf. All the animations we coded in [*Chapter
    19*](B16773_19_ePub_RK.xhtml#_idTextAnchor331), *Animations and Interpolations*,
    were all running in threads. Another such example in Android is the `SoundPool`
    class, which loads sound in a thread. We will see or rather hear `SoundPool` in
    action in [*Chapter 23*](B16773_23_ePub_RK.xhtml#_idTextAnchor400)*, Supporting
    Different Versions of Android, Sound Effects, and Spinner Widget*, and we saw
    and will see again that our code doesn't have to handle the aspects of threads
    we are about to learn about because it is all handled internally by the class.
    In this project, however, we need to get a bit more involved.
  prefs: []
  type: TYPE_NORMAL
- en: In real-time systems, think about a thread that is receiving the player's button
    taps for moving left and right at the same time as listening for messages from
    the OS such as calling `onCreate` (and other methods we will see soon) as one
    thread, and another thread that draws all the graphics and calculates all the
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs with multiple threads can have problems. Like the threads of a story
    in which if proper synchronization does not occur, things can go wrong. What if
    our soldier went into battle before the battle or the war even existed? Weird.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that we have a variable `int x` that represents a key piece of data
    that, say, three threads of our program use. What happens if one thread gets slightly
    ahead of itself and makes the data "wrong" for the other two. This problem is
    the problem of **correctness** caused by multiple threads racing to completion
    oblivious—because after all, they are just dumb code.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of correctness can be solved by the close oversight of the threads
    and locking. **Locking** means temporarily preventing execution in one thread
    to be sure things are working in a synchronized manner – kind of like freezing
    a soldier from boarding a ship to war until the ship has docked and the gangplank
    has been lowered, avoiding an embarrassing splash.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem with programs with multiple threads is the problem of `int
    x`, but that moment never comes, and eventually, the entire program grinds to
    a halt.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that it was the solution to the first problem (correctness)
    that is the cause of the second problem (deadlock).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the problem has been solved for us. Just as we use the `Activity`
    class and override `onCreate` to know when we need to create our app, we can also
    use other classes to create and manage our threads. Just as with `Activity`, we
    only need to know how to use them – not exactly how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why did I tell you all this stuff about threads when you didn''t need to
    know, you rightly ask. Simply because we will be writing code that looks different
    and is structured in an unfamiliar manner. If we can do the following, then we
    will have no sweat writing our Java code to create and work within our threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the general concept of a thread, which is just the same thing as
    a story thread, which happens almost simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the few rules of using a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few different Android classes that handle threads. Different thread
    classes work best in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: All we need to remember is that we will be writing parts of our program that
    run at *almost* the same time as each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: What do you mean almost? What is happening is that the CPU switches between
    threads in turn/asynchronous. However, this happens so fast that we will not be
    able to perceive anything but simultaneity/synchronous. Of course, in the story
    thread analogy, people do act entirely synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a glimpse at what our thread code will look like. Don''t add any
    code to the project just yet. We can declare an object of type `Thread` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize and start it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more conundrum to this thread stuff. Look at the constructor that
    initializes the thread. Here is the line of code again for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Look at the highlighted argument that is passed to the constructor. We pass
    in `this`. Remember that the code is going inside the `LiveDrawingView` class,
    not `LiveDrawingActivity`. We can, therefore, surmise that `this` is a reference
    to a `LiveDrawingView` class (which extends `SurfaceView`).
  prefs: []
  type: TYPE_NORMAL
- en: It seems very unlikely that when the nerds at Android HQ wrote the `Thread`
    class they would have been aware that one day we would be writing our `LiveDrawingView`
    class. So how can this work?
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread` class needs an entirely different type to be passed into its constructor.
    The `Thread` constructor needs an object of type `Runnable`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm this fact by looking at the `Thread` class on the Android developer''s
    website here: [https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable](https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember we talked about interfaces in [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201),
    *More Object-Oriented Programming*? As a reminder, we can implement an interface
    using the `implements` keyword and the interface name after the class declaration,
    like in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We must then implement the abstract methods of the interface. `Runnable` has
    just one. It is the `run` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm this last fact by looking at the `Runnable` interface on the
    Android developer''s website here: [https://developer.android.com/reference/java/lang/Runnable.html](https://developer.android.com/reference/java/lang/Runnable.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the Java `@override` keyword to change what happens when the
    operating system allows our thread object to run its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the overridden `run` method, we will call two methods: one that we have
    started already, `draw`, and the other is `update`. The `update` method is where
    all our calculations and artificial intelligence will go. The code will look a
    bit like this – don''t add it yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When appropriate, we can also stop our thread like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now everything that is in the `run` method is executing in a separate thread,
    leaving the default or UI thread to listen for touches and system events. We will
    see how the two threads communicate with each other in the drawing project shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that exactly where all these parts of the code will go into our app has
    not been explained because it is so much easier to show you in the real project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the game loop with a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have learned about the game loop and threads, we can put it all together
    to implement our game loop in the Living Drawing project.
  prefs: []
  type: TYPE_NORMAL
- en: We will add the entire code for the game loop, including writing two methods
    in the `LiveDrawingActivity` class to start and stop the thread, which will control
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Can you guess how the Activity based class will start and stop the thread in
    the `LiveDrawingView` class?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Runnable and providing the run method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Update the class declaration by implementing `Runnable`, just like we discussed
    we would need to and as shown in this next highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have a new error in the code. Hover the mouse pointer over the
    word `Runnable` and you will see a message informing you that we need to implement
    the `run` method, again, just as we discussed during the discussion on interfaces.
    Add the empty `run` method, including the `@override` label as shown in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t matter where you add it if it is within the `LiveDrawingView` class''s
    curly braces and not inside another method. I added mine right after the constructor
    method because it is near the top and easy to get to. We will be editing this
    quite a bit in this chapter. Add the empty `run` method as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The error is gone and now we can declare and initialize a `Thread` object.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declare some more member variables and instances, as shown next, underneath
    all our other members in the `LiveDrawingView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start and stop the thread. Have a think about where we might do this.
    Remember that the app needs to respond to the operating system starting and stopping
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and stopping the thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to start and stop the thread. We have seen the code we need but
    when and where should we do it? Let''s write two methods, one to start and one
    to stop, and then we can consider further when and from where to call these methods.
    Add these two methods inside the `LiveDrawingView` class. If their names sound
    familiar, it is not by chance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: What is happening is slightly given away by the comments – did you read the
    comments? We now have a `pause` and `resume` method, which stop and start the
    `Thread` object using the same code we discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the new methods are `public` and therefore accessible from outside the
    class to any other class that has an instance of `LiveDrawingView`. Remember that
    `LiveDrawingActivity` has the fully declared and initialized instance of `LiveDrawingView`?
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the Android Activity lifecycle to call these two new methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Activity lifecycle to start and stop the thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Update the overridden `onResume` and `onPause` methods in `LiveDrawingActivity`
    as shown next with the highlighted lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now our thread will be started and stopped when the operating system is resuming
    and pausing our app. Remember that `onResume` is called after `onCreate` the first
    time an app is created, not just after resuming from a pause. The code inside
    `onResume` and `onPause` uses the `mLiveDrawingView` object to call its `resume`
    and `pause` methods, which in turn has the code to start and stop the thread.
    This code then triggers the thread's `run` method to execute. It is in this `run`
    method (in `LiveDrawingView`) that we will code our game loop. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the run method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although our thread is set up and ready to go, nothing happens because the
    `run` method is empty. Code the `run` method as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice there are two errors in Android Studio. This is because we have not
    written the `update` method yet. Let''s quickly add an empty method (with a comment)
    for it. I added mine after the `run` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now let's discuss in detail how the code in the `run` method achieves the aims
    of our game loop by looking at the whole thing a bit at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first part initiates a `while` loop with the condition `mDrawing` and
    it wraps the rest of the code inside `run` so the thread will need to be started
    (for `run` to be called) and `mDrawing` will need to be true for the `while` loop
    to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of code inside the `while` loop declares and initializes a local
    variable `frameStartTime` with whatever the current time is. The static method
    `currentTimeMillis` of the `System` class returns this value. If later, we want
    to measure how long a frame has taken, then we need to know what time it started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, still inside the `while` loop, we check whether the app is paused and
    only if the app is not paused does this next code get executed. If the logic allows
    execution inside this block, then `update` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside of the previous `if` statement, the `draw` method is called to draw
    all the objects in the just-updated positions. At this point, another local variable
    is declared and initialized with the length of time it took to complete the entire
    frame (updating and drawing). This value is calculated by getting the current
    time, once again with `currentTimeMillis`, and subtracting `frameStartTime` from
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The next `if` statement detects whether `timeThisFrame` is greater than zero.
    It is possible for the value to be zero if the thread runs before objects are
    initialized. If you look at the code inside the `if` statement, it calculates
    the frame rate by dividing the elapsed time by `MILLIS_IN_SECOND`. If you divide
    by zero, the app will crash, which is why we do the check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `mFPS` gets the value assigned to it, we can use it in the next frame
    to pass to the `update` method of all the particles, which we will code in the
    next chapter. They will use the value to make sure they move by precisely the
    correct amount based on their target speed and the length of time the frame has
    taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the calculation that initializes `mFPS` in each frame is that
    `mFPS` will hold a fraction of 1\. Therefore, when we use this value inside each
    of the particle objects, we will be able to use this calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In order to determine the elapsed time on any given frame, as the frame rate
    fluctuates, `mFPS` will hold a different value and supply the game objects with
    the appropriate number to calculate each move.
  prefs: []
  type: TYPE_NORMAL
- en: Running the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click the play button in Android Studio and the hard work and theory of the
    last two chapters will spring to life. Here are the beginnings of our app running
    on a tablet emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 21.4 – Running the app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_21.4_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 21.4 – Running the app
  prefs: []
  type: TYPE_NORMAL
- en: You can see we now have a real-time system created with our game loop and a
    thread. If you run this on a real device, you will easily achieve 60 frames per
    second at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was probably the most technical chapter so far. Threads, game loops, timing,
    using interfaces along with the Activity lifecycle, and so on… it's an awfully
    long list of topics to cram in.
  prefs: []
  type: TYPE_NORMAL
- en: If the exact interrelationships between these things are not entirely clear,
    it is not a problem. All you need to know is that when the user starts and stops
    the app, the `LiveDrawingActivity` class will handle starting and stopping the
    thread by calling the `LiveDrawingView` class's `pause` and `resume` methods.
    It achieves this via the overridden `onPause` and `onResume` methods, which are
    called by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Once the thread is running the code inside, the `run` method executes alongside
    the UI thread that is listening for user input. As we call the `update` and `draw`
    methods from the `run` method at the same time as keeping track of how long each
    frame is taking, our app is ready to rock and roll.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to allow the user to add some particles to their artwork, which
    we can then update in each call to the `update` method and draw in each call to
    the `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be coding, updating, and drawing both the `Particle`
    and the `ParticleSytem` classes. In addition, we will be writing code for the
    user to interact (do some drawing) with the app.
  prefs: []
  type: TYPE_NORMAL
