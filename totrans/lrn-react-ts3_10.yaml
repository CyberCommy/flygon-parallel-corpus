- en: Interacting with GraphQL APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL is an open source web API language for reading and writing data that
    is maintained by Facebook. It allows the client to specify exactly what data is
    returned and request multiple data areas in a single request. This efficiency
    and flexibility makes it a compelling alternative to a REST API. GraphQL also
    supports both reading and writing data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll start by experimenting with some GraphQL queries against
    GitHub to get familiar with the syntax by using the *GitHub GraphQL API* explorer.
    We'll explore how we both read and write GraphQL data and how to specify exactly
    the way we want the data in the response returned to us.
  prefs: []
  type: TYPE_NORMAL
- en: We'll then consume the GitHub GraphQL server in a React and TypeScript application
    to build a little app that searches for a GitHub repository and returns some information
    about it. We'll use our knowledge from the last chapter on `axios` to interact
    with the GitHub GraphQL server to start off with. We'll then switch to using Apollo,
    which is a client library that makes interacting with GraphQL servers a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL query and mutation syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using axios as a GraphQL client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Apollo GraphQL client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with cached data in Apollo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least at version 5.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub**: We''ll need a GitHub account. We can sign up at the following link
    if we haven''t got an account: [https://github.com/join](https://github.com/join).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub GraphQL API Explorer**: We''ll use this tool to play with the syntax
    of GraphQL queries and mutations. The tool is at [https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/10-GraphAPIs](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/10-GraphAPIs).
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL query and mutation syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use the GitHub GraphQL API explorer to start to get familiar
    with the syntax for interacting with a GraphQL server, starting with reading data
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reading GraphQL data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to read GraphQL data, we make what is called a query. In this section,
    we'll start by covering the basic GraphQL syntax and move on to how to include
    nested objects in a query result, and then how we can create reusable queries
    by allowing parameters to be passed into them.
  prefs: []
  type: TYPE_NORMAL
- en: Basic query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll use the GitHub GraphQL API explorer to get information
    about our GitHub user account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the following URL in a browser to open the tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://developer.github.com/v4/explorer/](https://developer.github.com/v4/explorer/).'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to be signed in to our GitHub account if we aren't already.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the panel in the top-left corner, let''s enter the following and click the
    Execute Query button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our first GraphQL query. Here are some key points:'
  prefs: []
  type: TYPE_NORMAL
- en: We prefix a query with the `query` keyword. This is actually optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewer` is the name of the object we want to get.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` is a field within `viewer` that we want to return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The query result will appear on the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e28c0b49-4f11-4210-95b6-0f3054189947.png)'
  prefs: []
  type: TYPE_IMG
- en: The data we requested is returned as a JSON object. The JSON contains a `data`
    object that contains a `viewer` object containing the `name` field. The `name`
    value should be our name, since this is the name stored in our GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side of the results pane there is a Docs link. If we click
    this link, a Documentation Explorer appears:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7cbedebe-ec72-4b09-943f-c263da3b8b0f.png)'
  prefs: []
  type: TYPE_IMG
- en: If we then click on the Query link, all the objects are shown that can be queried,
    including `viewer`, which is the one we just queried. If we click into this, we
    see all the fields that are available within `viewer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `avatarUrl` to our query, as this is an additional field available
    to us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, we simply add the `avatarUrl` field inside the `viewer` object with a carriage
    return between the `name` and `avatarUrl` fields. If we execute the query, we
    see `avatarUrl` added to the JSON result. This should be a path to an image of
    us.
  prefs: []
  type: TYPE_NORMAL
- en: So, we are already seeing how flexible GraphQL is with being able to specify
    exactly which fields we want returned in the response. In the next section, we'll
    take this further by specifying the nested objects we want to return.
  prefs: []
  type: TYPE_NORMAL
- en: Returning nested data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make a far more complex query in this section. We''ll search for a GitHub
    repository, return information about it, including the number of stars it has
    and the last issues that have been raised as a nested array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by entering the following query and executing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This time, we are asking for the `repository` object, but passing two parameters
    for the `owner` and `name` of the repository. We are asking for the `name` and
    `description` of the repository to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that the repository and fields we asked for are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/820b1074-0293-4302-9c53-61794fbc8f16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now request the number of stars against the repository. To do this,
    we ask for the `totalCount` field within the `stargazers` nested object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the query, we see these results returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/66b94c04-5c0b-48b1-8c09-29d091fb8cdd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now add an alias to `totalCount` within `stargazers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the query, we see the stars count is returned against the alias
    we specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to requesting the last `5` issues within the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We request the `issues` object by passing `5` into the last parameter. We then
    request an `edges` object containing a `node` object that in turn contains the
    issue fields we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are the `edges` and `node` objects? Why can't we just request the fields
    we want directly? Well, this structure is in place to facilitate cursor-based
    pagination.
  prefs: []
  type: TYPE_NORMAL
- en: If we execute the query, we get the last `5` issues included in our result.
  prefs: []
  type: TYPE_NORMAL
- en: So, GraphQL allows us to make a single web request for different bits of data
    returning just the fields we require. Doing a similar thing with the GitHub REST
    API would probably require multiple requests and we'd get a lot more data than
    we need returned to us. It is these types of queries where GraphQL shines over
    REST.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The query we have just made is hardcoded to get data for a specific repository.
    In this section, we''ll define variables in the query, which essentially allow
    parameters to be passed into it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add query variables in parentheses after the `query` keyword, separated
    by commas. Each parameter is defined by declaring its name with its type after
    a semicolon. This is similar to defining parameters in a TypeScript function with
    type annotations. The variable names need to be prefixed with `$`. The `!` after
    the type signifies that this is required. So, in our case, both variables are
    required in order for the query to be executed. The variables can then be referenced
    within the query, which, in our case, is where we request the repository object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we execute the query, we need to specify the variable values. We do
    this in the Query Variables pane in the bottom-left corner in a JSON object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the query, we get the results for the repository we asked for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d36c468d-b097-46fb-84b8-70003a910a11.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now getting comfortable with reading data from a GraphQL server. But
    how can we create new data items or update data? We'll find out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing GraphQL data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s turn our attention to writing to a GraphQL server now. We do this with
    what are called mutations. In this section, we''ll create a `mutation` to add
    a GitHub star to a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to star a repository, we need the repository `id`. So, let''s add
    this to the query we have been working on to get this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s copy the `id` that is returned in the result. The `id` for the React
    repository is the shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now write our first `mutation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some key points on this `mutation`:'
  prefs: []
  type: TYPE_NORMAL
- en: We prefix a mutation with the `mutation` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We put parameters to be passed into the `mutation` after the `mutation` keyword
    in parentheses. In our case, we have a single parameter for the repository `id`
    we want to star.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addStar` is the `mutation` function we are calling, which has a parameter
    called `input` that we need to pass to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input` is actually an object that has a field called `starrableId` we need
    to include. The value of this is the repository `id` we want to star, so we set
    it to our repository `id` variable `$repoId`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `mutation` parameters, we can specify what we want returned in the
    response. In our case, we want to return the number of stars on the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can specify the parameter value for the repository `id` in the Query Variables
    pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the `mutation`, the star will be added to the repository and
    the new total number of stars will be returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/752ea09d-7729-43ef-b88a-b1ad8cb04a40.png)'
  prefs: []
  type: TYPE_IMG
- en: We have a good grasp on both GraphQL queries and mutations now. In the next
    section, we'll start to interact with a GraphQL server from a React and TypeScript
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Using axios as a GraphQL client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with a GraphQL server is done via HTTP. We learned in [Chapter 9](c4badffb-0c23-40cc-878c-8b598d427227.xhtml),* Interacting
    with Restful APIs*, that `axios` is a great HTTP client. So, in this chapter,
    we'll cover how to interact with a GraphQL server using `axios`.
  prefs: []
  type: TYPE_NORMAL
- en: To help us learn, we'll create a React and TypeScript app to return information
    about our GitHub account. So, our first tasks are to get a token that will give
    us access to query the GitHub GraphQL server and scaffold a React and TypeScript
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a GitHub personal access token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GitHub GraphQL server requires a bearer token for us to interact with it.
    So, let''s go and generate a personal access token:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's sign in to our GitHub account and go to our Settings page by opening the
    menu under our avatar and choosing Settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left-hand menu, we then need to choose the Developer settings option.
    This will take us to the Developer settings page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then choose the Personal access tokens option in the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then see a Generate new token button that we can click to generate our
    bearer token. We will likely be prompted to input our password after clicking
    the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before the token is generated, we are asked to specify the scopes. Let's enter
    a token description, tick repo and user, and then click the Generate token button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The token is then generated and displayed in the page for us to copy and use
    in our React app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our bearer token, let's scaffold a React and TypeScript app
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll follow the usual steps for scaffolding a React and TypeScript app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open Visual Studio Code in a folder of our choice and open the terminal.
    Let''s enter the following command to create a new React and TypeScript project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the version of React we use needs to be at least version `16.7.0-alpha.0`.
    We can check this in the `package.json` file. If the version of React in `package.json`
    is less than `16.7.0-alpha.0`, then we can install this version using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After the project is created, let''s add TSLint as a development dependency
    to our project, along with some rules that work well with React and Prettier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add a `tslint.json` file containing some rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open `App.tsx`, there is a linting error. So, let''s resolve this by
    adding `public` as the modifier on the `render` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can install `axios` using `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start our app running before we continue with the developments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do a little more in our app before we make our first GraphQL query in
    `axios`. Let''s create a new file called `Header.tsx` in the `src` directory containing
    the following `import`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This component will eventually contain our name and avatar from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return nothing from our `Header` component for the time being:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go back to `App.tsx` and import the `Header` component we have just
    created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now adjust the JSX in `App.tsx`, including our `Header` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As our final task in this section, let''s change the `App-Header` CSS class
    in `App.css` so that the header isn''t so tall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Querying the GraphQL server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our React and TypeScript project in place, let''s make a GraphQL
    query using `axios`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Header.tsx`, we''ll start by creating two interfaces for the GraphQL query
    response and the viewer data within it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create some state within our `Header` component for the `viewer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s nearly time to make the GraphQL query. We are going to do this when the
    component has just been mounted. We can use the `useEffect` function to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We pass an empty array as the second parameter so that the query only executes
    when the component is mounted and not on each render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `axios` then to make the GraphQL query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are doing an HTTP `POST` even though we are reading data. GraphQL
    requires us to use an HTTP `POST` because the details of the query are in the
    request body.
  prefs: []
  type: TYPE_NORMAL
- en: We are also using the interface we used earlier, `IQueryResult`, for the response
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we need to pass our bearer token in the HTTP Authorization
    header. So, let''s do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we need to substitute in our real bearer token that we obtained earlier
    from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'We aren''t handling the response yet, so let''s do that and set the `viewer`
    state variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the data in state from the GraphQL query, let''s render our
    avatar and name along with our app title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the avatar CSS class we just referenced into `App.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the running app, we should see our avatar and name in our app
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c79a089-47eb-4047-a948-bf5126dc206f.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we've just interacted with a GraphQL server using an HTTP library. All GraphQL
    requests are made using the HTTP POST method, even for reading data. All GraphQL requests
    are made to the same endpoint as well. The resource we want data from isn't in
    the URL, it's in the request body. So, whilst we can use an HTTP library, like
    `axios`, for querying GraphQL servers, it feels a little strange.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at a GraphQL client that will help us query
    a GraphQL server in a more natural way.
  prefs: []
  type: TYPE_NORMAL
- en: Using Apollo GraphQL client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apollo client is a client library for interacting with GraphQL servers. It has
    many benefits over using a generic HTTP library like `axios`, such as being able
    to read and write data declaratively with React components right in our JSX and
    having caching switched on right out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll refactor what we built in the last section with `axios`
    to use Apollo, and then extend our app a little more to include a GitHub repository
    search.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Apollo client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first job is to install Apollo into our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Apollo client to our project, let''s install the following packages
    via `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`apollo-boost` contains everything we need to set up our Apollo client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-apollo` contains React components we are going to use to interact with
    the GraphQL server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql` is a core package that we''ll use to parse GraphQL queries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll also install some TypeScript types as well for `graphql`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make sure TypeScript includes the `es2015` and `esNext` libraries
    when it compiles our code. So, let''s add the following `lib` field to `tsconfig.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We now have everything in place to start interacting with the GitHub GraphQL
    server with Apollo.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from axios to Apollo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have installed all the Apollo bits and pieces, let's migrate our
    `axios` code to Apollo.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Apollo provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start in `App.tsx`, where we will define our Apollo client
    and *provide* it to all the components beneath the `App` in the component hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `App.tsx`, let''s import `apollo-boost`, along with the `ApolloProvider`
    component from `react-apollo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Just above the `App` class component, let''s create our `ApolloClient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we need to substitute in our real bearer token we obtained earlier
    from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to use the `ApolloProvider` component to provide the `ApolloClient`
    we have created to all the other components in our app. We do this by putting
    `ApolloProvider` as the root component and passing it our `ApolloClient` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `ApolloClient` is set up, we can start interacting with the GraphQL
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Using the query component to query GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to use the `Query` component to get our GitHub name and avatar,
    replacing the `axios` code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by removing the `axios` import statement and instead of having
    the following imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `IViewer` interface will remain the same, but we need to tweak our `IQueryResult`
    interface slightly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to define our GraphQL query next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, we set the query to a `GET_VIEWER` variable and we have defined our query
    in a template literal. However, the `gql` function just before the template literal
    is a little odd. Shouldn't the template literal be in parentheses? This is actually
    called a tagged template literal, where the `gql` function from the core GraphQL
    library parses the template literal next to it. We end up with a query in `GET-VIEWER`
    that Apollo can use and execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to start to define our query. We can define our query directly
    in JSX using the `Query` component from `react-apollo`. However, in order to add
    some type safety, we are going to create a new component called `GetViewerQuery`
    that inherits from `Query` and defines the result type as a generic parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We don't need any state anymore, so we can remove the `viewer` and `setViewer`
    variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also remove the `useEffect` function call that makes the `axios` query
    because we are going to do our query in JSX now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, let''s use our `GetViewerQuery` component to invoke our query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We pass the `GetViewerQuery` component our query we created earlier in a `query`
    prop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query result is returned in the children function of `GetViewerQuery`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The children function argument contains an object containing the data in a `data`
    property. We destructure this data into a `data` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there isn't any data, we escape early and return `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have data, we then return the JSX for our avatar and name referencing
    the `data` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we look at our running app, it should look exactly the same as the `axios`
    version. We may need to `npm start` the app again if it's showing an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s other information that we can get from the children function argument.
    One piece of useful information is whether the data is being loaded. Let''s use
    this to display a loading message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful piece of information that we can get from the children function
    argument is information about an error that has occurred. Let''s use this to display
    the error message, if there is one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This Apollo implementation is really elegant. It's clever how the `Query` component
    makes the web request at the correct point in the component lifecycle and allows
    us to feed the rest of the component tree the data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll continue to enhance our app with Apollo.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a repository search component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll add a component to search for a GitHub repository and
    return some information about it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new file called `RepoSearch.tsx` containing the
    following imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to take in `ApolloClient` as a prop. So, let''s add an interface
    for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll scaffold our component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s reference this in our `App` component, now in `App.tsx`, by first importing
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add this under the app header passing in `ApolloClient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Our repository `search` component is nicely set up now. In the next, section
    we can implement a search form.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the search form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement a search form that allows the user to supply an organization
    name and repository name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `RepoSearch.tsx`, let''s start to define the state for the search fields,
    starting with the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a variable to hold our `search` state, along with a function
    to set it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `search` form in our JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We've referenced a few bits that aren't implemented yet. So, we'll implement
    this one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `repo-search` class we referenced in `App.css`. We''ll also
    style the labels and inputs along with the Search button as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s implement the input change handlers that simply update the `search`
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The final bit we need to implement is the `search` handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We call `preventDefault` on the event argument to stop a full postback occurring.
  prefs: []
  type: TYPE_NORMAL
- en: So, that's the search form started. We'll implement the GraphQL query in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the search query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now at the point where we need to make the GraphQL query to do the actual
    search:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating an interface for the repository data we expect to
    get back from the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is the structure we got back from the GitHub GraphQL Explorer in an earlier
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to need a default value for this state. So, let''s define this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define an interface for the query result as a whole:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create the query itself using a tagged template literal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is the query we made in the GitHub GraphQL Explorer in an earlier section.
    Unlike our previous queries, this one has parameters that we'll need to include
    when we execute the query a little later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to store the data we get from the query in state. So, let''s create
    a state variable called `repo`, along with a function to set it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to store any problems with the `search` in state as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update the `handleSearch` arrow function to clear any search error state
    before we do the `search`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go on and use `ApolloClient` passed in as a prop to make the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'There is more work to do here, though. First, we need to pass in the `query`
    parameters for the organization name and repository name from the values we have
    in our `search` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to handle the response in the `then` method and set the `repo`
    state to the data in the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also handle any errors in the `catch` method and update the `searchError`
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If we try a `search` in the running app, the query will be made okay, but we
    are not showing the results yet. Let's do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the search result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s render the data we have got from the repository query:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s render the repository name with its number of stars, along with its
    description, under the `search` form if we have a search result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also render the last `5` repository issues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If a problem has occurred, let''s render the error message we have captured
    in state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a bit of CSS in `App.css` for the title of the repository in the
    search result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If we search for a repository, we should now see information about the repository
    rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c544071-6f5f-4299-b1fe-60604a62c400.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now getting comfortable querying a GraphQL server with Apollo. In the
    next section, we'll tackle mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a mutation with Apollo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s allow users to star a GitHub repository in our app. This will involve
    sending a `mutation` via Apollo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import the `Mutation` component from `react-apollo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the `mutation`. The is the same query we executed in the
    GitHub GraphQL Explorer earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the JSX, under where we render the description, let''s place the `Mutation`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We only render the `mutation` if the `viewer` hasn't already starred the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Mutation` component takes in the mutation we just defined along with the
    variables, which is the repository `id` in our case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Mutation` component has a children function that gives us access to the
    `addStar` function. So, let''s render a Star! button that calls `addStar` when
    clicked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Mutation` component also tells us when the `mutation` is being executed
    via a `loading` property in a second argument in the children function. Let''s
    use this to disable the button and inform the user that the star is being added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Mutation` component also tells us when there is an error. So, let''s use
    this and render the error if one happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If we try to add a star to a repository, the star should be successfully added.
    We can go to the GitHub repository in [github.com](http://github.com) to verify
    this.
  prefs: []
  type: TYPE_NORMAL
- en: So, we are really getting to grips with Apollo now that we've implemented both
    queries and a `mutation`. There is one thing that was a little odd, though, that
    we may have spotted. The number of stars doesn't update in our app after we star
    a repository. Even if we search for the repository again, the number of stars
    is the number before we started it. However, if we refresh the browser and search
    for the repository again, we do get the correct number of stars. So, what's going
    on here? We'll find out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with cached data in Apollo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We ended the last section with a bit of a mystery. Why aren't we getting the
    up-to-date number of stars in a repository `search` after we've started it? The
    answer is that Apollo caches the repository data after the initial `search`. When
    the same query is executed, it gets the results from its cache, rather than getting
    the data from the GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s double-check that this is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to our app and open Developer tools on the Network tab and clear
    any previous requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d4bd5ab2-fc05-49c9-a31f-82612fa19b0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s do a search. We''ll see a couple of requests to the GitHub GraphQL server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0230f74a-065e-4dbc-97e3-304efea83194.png)'
  prefs: []
  type: TYPE_IMG
- en: Under the Developer tools, Network tab, let's clear the requests, and then in
    our app let's click the Search button again. We'll see that no network requests
    will be made, but the data is rendered. So, the data must be coming from a local
    cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, our `ApolloClient` that we configured using `apollo-boost` automatically
    caches queries in an in-memory cache. In the next section, we'll learn how to
    clear the cache so that our app shows the correct number of stars after a repository
    has been starred.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the caching using refetchQueries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a way of clearing the cached query result after a `mutation` has happened.
    One way of doing this is to use the `refetchQueries` prop on the `Mutation` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give this a go. The `refetchQueries` prop takes in an array of objects
    that contain the queries with the corresponding variable values that should be
    removed from the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If we star a repository now, the number of stars doesn't update straight away.
    However, if the Search button is pressed, the stars are updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, the cache was cleared but the experience still isn't ideal. Ideally, we
    want the number of stars to be updated immediately after the Star! button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: If we think through what we have just done, we are trying to bypass the cache.
    However, the cache is in place to help our app perform well.
  prefs: []
  type: TYPE_NORMAL
- en: So, this approach doesn't feel great. The user experience still isn't ideal,
    and we have just made our app less performant. There must be a better way! We'll
    explore a different approach in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the cache after a Mutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s think through the problem one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: We have some information about a repository in a cache that includes the number
    of stars it has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we star the repository, we want to see that the number of stars has been
    incremented by one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if we could just increment the number of stars in the cache by one? This
    should hopefully resolve the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s give this a go and update the cache after the `mutation` has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's remove the `refetchQueries` prop we implemented in the last section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is an `update` prop on the `Mutation` component that we can leverage
    to update the cache. So, let''s start to implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we need to implement an arrow function that updates the cache that is available
    as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: So, the cache has a `readQuery` function that we can use to get the cached data.
    If no data is found in the cache then we can exit the function without doing anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we have the data from the cache, we can increment the number of
    stars. To do this, we create a new object and spread the props from the cached
    repository into it and overwrite it with the incremented number of stars and the
    fact that the viewer has starred the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then update the cache with its `writeQuery` function. We pass in the
    query with the variable values and the new data to store in the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one more job to do, which is to update the `repo` state so that the
    number of stars updates immediately onscreen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: That should be it. If we try to star a repository in our app again, we should
    see that the number of stars is immediately incremented.
  prefs: []
  type: TYPE_NORMAL
- en: Caching is one of the great features that Apollo gives us out-of-the-box. The
    `update` prop on the `Mutation` component gives us a precise way to update our
    cache. The `refetchQueries` prop on the `Mutation` component is a more heavy-handed
    and less efficient way of forcing a cache to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraphQL shines over REST because it allows us to efficiently get the data we
    need in the shape we need with far less effort. The GitHub GraphQL Explorer is
    a great tool for getting comfortable with the syntax. There are two main types
    of requests we can make to a GraphQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: We can execute a `query` to read data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can execute a `mutation` to write data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries allow us to specify the objects and fields we want in the response.
    We can rename them by using aliases. We can parameterize a query by defining variables.
    We can give variables types and specify whether each one is required or not with `!`
    at the end. There are query features that we didn't cover in this chapter, such
    as conditionally including fields and the powerful paging capability. In summary,
    it's an extremely powerful query language!
  prefs: []
  type: TYPE_NORMAL
- en: Mutations share some of the same features as queries, such as being able to
    pass parameters into them. It's great how we get to control what data is included
    in the response as well.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL operates over HTTP with HTTP `POST` requests to a single URL. The HTTP
    body contains the query or `mutation` information. We can use an HTTP client to
    interact with a GraphQL server, but we'll probably be more productive with a library
    like Apollo that is built specifically to interact with GraphQL servers.
  prefs: []
  type: TYPE_NORMAL
- en: React Apollo is a set of React bits and pieces that work with the core Apollo
    library. It gives us nice `Query` and `Mutation` React components for including
    queries and mutations right in our JSX, making our code arguably easier to read.
    Before we can use these components, we need to set up our `ApolloClient` object
    with the URL to the GraphQL server and any credentials. We also need to include
    an `ApolloProvider` component high in our component tree, above all the components
    that need GraphQL data.
  prefs: []
  type: TYPE_NORMAL
- en: Caching is switched on out-of-the-box when we scaffold our project with `apollo-boost`.
    The `Mutation` component gives us `update` and `refetchQueries` props to manage
    cache updates.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, GraphQL is a very productive way to interact with backends, and
    it works really nicely with React and TypeScript apps.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've learned many different aspects of React and TypeScript in this book
    so far. One big topic that we haven't covered yet is how we can robustly test
    the apps we build. We'll cover this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a go at some questions to test our knowledge on what we have just
    learned:'
  prefs: []
  type: TYPE_NORMAL
- en: In the GitHub GraphQL Explorer, create a query to return the last five open
    issues in the React project. Return the issue title and the URL in the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enhance the last query and make the number of issues that are returned a parameter
    and make this default to five.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `mutation` in the GitHub GraphQL Explorer to unstar a starred repository.
    The `mutation` should take a required repository `id` in as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What part of the HTTP request does the GraphQL query go in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What part of the HTTP request does the GraphQL `mutation` go in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we make the response from the `react-apollo` `Query` component type
    safe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is caching on or off by default when you scaffold a project with `react-boost`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What prop can we use on the `Mutation` component to update the local cache?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links are good resources of further information on GraphQL in
    general, along with React and Apollo:'
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL docs are at [https://graphql.org/learn/](https://graphql.org/learn/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Apollo docs are at [https://www.apollographql.com/docs/](https://www.apollographql.com/docs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The React section of the Apollo docs is at [https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
