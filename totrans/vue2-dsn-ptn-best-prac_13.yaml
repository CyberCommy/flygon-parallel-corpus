- en: Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll look at a variety of anti-patterns within Vue.js and
    review concepts at a high level that we've learned throughout the book. We'll
    look at various patterns and anti-patterns and how we can write code that is consistent
    across teams and your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Before defining anything as a *pattern* or *anti-pattern*, it's important to
    accurately define both for the reader. If something is to be considered a pattern,
    this means that this is a recommended practice in the vast majority of cases.
    On the contrary, if I've defined it as an anti-pattern, then it's most likely
    not a recommended practice in a vast majority of cases. For further information
    on this, a good source of patterns and guidelines can be found at [https://github.com/pablohpsilva/vuejs-component-style-guide](https://github.com/pablohpsilva/vuejs-component-style-guide).
  prefs: []
  type: TYPE_NORMAL
- en: Software development is an opinionated field with a variety of ways to solve
    the same problem, so there may be ideologies that are classified as something
    you don't agree with, and that's okay. At the end of the day, each team has their
    own style, but developers should seek to stick to patterns that reduce friction
    and speed up development where possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Common patterns and anti-patterns within Vue projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container/presentational components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write testable Vue.js components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways for components to communicate within Vue, such as the use
    of props, events, and store-based scenarios. Vue also gives us access to `$parent`
    and `$children` objects, which allow us to interact with parent/child components.
    Let's take a look at this and see why it shouldn't be used.
  prefs: []
  type: TYPE_NORMAL
- en: Communication – Anti-pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that we had our familiar `TodoList` example, and within the `TodoItem`
    component, we want the ability to complete a particular Todo. If we wanted to
    keep our todos within the `TodoList` and thus call the completed method from `TodoItem`,
    we could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a bad idea for numerous reasons, mostly because we're tightly coupling
    these two components together and assuming that there will always be a `completeTodo`
    method on the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: What can we change about this to make it better?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m not saying that parent/child components can''t communicate, but you should
    aim to design components in such a way that they''re flexible. Use events or the
    Vuex store depending on the structure of your application. Here''s an example
    using an event instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Children mutating props – Anti-pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important that we won't modify props inside our child components. Props
    should be considered the source of truth when passed down to a component and thus,
    change the value from within a child component is typically bad practice. There
    are some unique case scenarios however where it may be appropriate to do so, like
    when using the `.sync` modifier to achieve two-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use our previous example and change the todos prop from within the child,
    we''ll get a warning inside the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What should we do instead?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to work with the prop inside the child component, it''s best to
    save the prop as a new variable inside the `data` option. This allows you to then
    mutate a new version of the prop, local to this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then access and mutate `personAge` without worrying about any side effects.
    Another example can be seen when creating a filterable search box, where instead
    of mutating the prop directly, make a `computed` property that performs the required
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Mutating property arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important consideration to make when passing down arrays and objects as
    properties within JavaScript is the fact that they are passed by reference. This
    means that any changes to the original array within the child will also spill
    over into the parent component. Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a component (`App.vue`) that contains an array that we''re displaying
    on screen and passing down into the child component. We''ll display the same array
    on screen inside the child component, but also give the child a button to add
    a new item into the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we add a new person to our friends'' list, this is our result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0d2c36e1-e927-4e12-b168-b6b066a619e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, both components have the same array! This isn''t what we want. If for
    some reason we wanted to do an action like this, it would be wiser to keep a copy
    of the friends'' list and mutate that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using data as an object - Anti-Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating components with Vue, it's important that the data option is a
    function that returns a new object holding data, rather than just a plain data
    object.
  prefs: []
  type: TYPE_NORMAL
- en: If you simply use a data object that's not a function, all instances of the
    component will share the same data. This is bad because as you may be able to
    imagine, all instances of the component will be updated with the same data any
    time it changes. It's important to ensure that each component is capable of managing
    its own data rather than sharing data across the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this by doing this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By creating the `return` statement, it allows each instance created to have
    its own object rather than a shared one. This then allows the code to be used
    multiple times without the conflict of shared data.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's take a look at best practices for naming our components.
  prefs: []
  type: TYPE_NORMAL
- en: Naming components – Anti-pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not a good idea to name components in single words as it has the chance
    to conflict with native HTML elements. Let's say we had a signup form and a component
    named `Form.vue`; what would be an appropriate name when using this inside our
    template?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, as you might imagine, having a component named `<form>` will conflict
    with the `<form>`, so it''s a best practice to have components that are named
    with more than one word. A better example can be the name of `signup-form`, `app-signup-form`,
    or `app-form`, depending on preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Template expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often times, when we''re displaying items on the screen, we may have to compute
    values and call functions to change the way our data looks. Instead of doing this
    work inside the template, it''s advised to move this out into a `computed` property,
    as this is much easier to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This means any changes in our template are much easier to handle because the
    output is mapped to a computed property.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern – Container/Presentational components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important part of the component design is ensuring that your components are
    testable. You should think of each component as a standalone module in your application
    that could be switched in/out, as necessary; as a result, it should not be tightly
    coupled with another component.
  prefs: []
  type: TYPE_NORMAL
- en: The best way is to ensure that your components are testable after ensuring that
    light coupling is to have a well-defined public API via component props and then
    use events to communicate between the parent/child component. This also helps
    us when testing, as we're able to mock components much easier.
  prefs: []
  type: TYPE_NORMAL
- en: A common pattern to use when following this model is the container/presentational
    components. This means we keep all of our business logic and state inside the
    "container" and then pass the state down to the "presentational" component to
    display on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The presentational component can still communicate with other components, if
    necessary, with the use of events, but it shouldn't modify or hold state outside
    inbound props. This ensures that we have a common data flow between our components,
    and it means that our applications are easier to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an explicitly named component—`DogContainer.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The container component has handed down the dog''s name (and any other items)
    as a property into the presentational component. The container component is also
    listening for an event named `woof` on this component and is taking action by
    calling the `woof` method when it has been emitted. Here''s our presentational
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our component's concerns are now clearly separated, and we have a clear communication
    path between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This composition can be visualized in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88c31e61-8f44-4bc8-a702-5768fe482873.png)Composing components'
  prefs: []
  type: TYPE_NORMAL
- en: Prop validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we should seek to communicate between child components via props, it''s
    important to be verbose when validating properties by considering types, requirements,
    defaults, and so on. Throughout the book, I''ve used a mix of both techniques
    for brevity, but in production, props should be appropriately validated. Let''s
    start out by looking at some examples of property types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We also have various other types available such as Boolean, function, or any
    other constructor function (that is, type of Person). By accurately defining the
    types we expect, this allows us (and our team) to reason better about what we
    can expect within this component.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, we can also ensure that props are required. This should be
    done where necessary, allowing us to ensure that whenever the component is used,
    no required props are missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We should always seek to give our props default values where possible, as this
    reduces necessary configurations but still allows the component to be customized
    if a developer wants. When dealing with objects and arrays, a function is used
    as a default parameter to avoid issues where instances share the same value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also assign a custom `validator` function for our properties. Let''s
    say that we have a slot `machine` component that is only rendered if the user
    is `18` years or older:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Understanding reactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve discussed reactivity and how it can be used in the previous chapters,
    but it''s important to reconsider. When we''re creating reactive data objects
    within Vue, it takes each property and adds appropriate getters/setters using
    `Object.defineProperty`. This allows Vue to handle changes to the object and notifies
    watchers, subsequently updating the component [https://vuejs.org/v2/guide/reactivity.html](https://vuejs.org/v2/guide/reactivity.html).
    This can be visualized like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19fa61cd-d221-4b75-9d73-262ea5d107a8.png)Visualizing Reactivity'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that any property defined in the data option is automatically reactive.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` property is reactive inside this Vue instance, but if we were to
    add another property outside of the Vue instance, this would not be reactive.
    Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our `groceries` component has an items array that contains various objects.
    Every object has a quantity apart from the `Bananas` object, but we'd like to
    set the quantity for this. When using `v-for` it's important to include `v-bind:key`
    (or the shorthand `:key`) as it acts as a unique identifier for each item and
    by doing so allows for reuse and reordering of each node. Whilst `key` may be
    an attribute for `v-for` keep in mind it does have other use case scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we then head over to our browser, and proceed to use the dev tools to access
    the `console` we can see that the quantity has been set to hold a value for our
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/798a236b-ab31-40b6-9a58-52bccc0adba1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note how there are reactive getters and setters for the quantity objects that
    contain quantity when defined inside the data object. Adding a property to the
    items after the fact means Vue doesn''t add the appropriate getters/setters. If
    we wanted to do this, we''d have to use `Vue.set` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, there are getters/setters for every property inside our instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19cca632-7a91-4a97-baad-a18ac0e6a363.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we looked at anti-patterns and patterns, and we have expanded
    our knowledge as to not only what they are, but also when it is appropriate to
    use them to coincide with best practices. Not only that, we also reviewed a lot
    of the concepts that we learned throughout the book in this chapter, along with
    considering some new ideas and techniques of what can be used going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting on the previous chapters, we can look back and see how much ground
    we've covered. Practicing the techniques covered in this book will allow you to
    create scalable applications with Vue.js and build on what you've learned. Another
    important thing to remember is that **web development is always evolving**, the
    amount of *practical applications* for Vue continues to grow and *so should you*.
  prefs: []
  type: TYPE_NORMAL
- en: What next? Try new things! Build new projects, attend Vue.js meetings and conferences
    - find new ways of applying your skills to teach others. Not only will you have
    a positive impact on others, but you'll reaffirm your skills as a developer.
  prefs: []
  type: TYPE_NORMAL
