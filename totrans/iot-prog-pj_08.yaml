- en: Reading Raspberry Pi GPIO Sensor Data Using Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](4c4cf44d-ff8a-4cb4-9d8c-85530b0d873b.xhtml), *Setting U**p a
    Raspberry Pi Web Server*, we used the GPIO Zero library to turn on servos and
    light up LEDs. In this chapter, we will use GPIO Zero to read inputs from the
    GPIO port. First, we will start with a simple button, before moving on to **Passive
    Infrared** (**PIR**) motion sensors and buzzers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Having the ability to read sensory data from the GPIO will allow us to build
    our IoT home security dashboard. By the end of this chapter, we should become
    very familiar with programming the Raspberry Pi with components connected to the
    GPIO.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Reading the state of a button
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the state from an infrared motion sensor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying `Hello LED` using an infrared sensor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create two different types of alarm system. We will
    start by learning how to read GPIO sensory data from a push-button. We will then
    learn how to interact with a PIR sensor and distance sensor. Lastly, we will learn
    how to hook up an active buzzer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: This chapter should take about 3 hours to complete.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this project, the following will be required:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A Raspberry Pi Model 3 (2015 model or newer)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB power supply
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer monitor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB keyboard
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB mouse
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PIR sensor
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A distance sensor
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A active buzzer
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An LED
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A push-button (momentary)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A push-button (latching)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key switch (optional)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the state of a button
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Button`, from the `GPIO Zero` library, gives us an easy way to interact with
    a typical button connected to the GPIO. We will cover the following in this section:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Using GPIO Zero with a button
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Sense HAT emulator and GPIO Zero button together
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggling an LED with a long button press
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GPIO Zero with a button
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connecting a push-button is relatively easy with the GPIO. The following is
    the connection diagram showing the process:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d70e80e0-3c45-4b64-acf3-417770f347c0.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Connect the push-button so that one end is connected to ground using a jumper.
    Connect the other end to GPIO 4 on the Raspberry Pi.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'In Thonny, create a new file and call it `button_press.py`. Then, type following
    into the file and run it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should now see the message `"The Button on GPIO 4 has been pressed"` in
    the shell whenever you push the button. The code will run continuously until you
    click on the Reset button.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code. We start by importing `Button` from `GPIO Zero`,
    and `sleep` from the `time` library:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then create a new `button` object and assign it to GPIO pin `4` with the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our continuous loop checks to see whether the button is currently pressed,
    and prints out a statement to our shell if it is:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the Sense HAT emulator and GPIO Zero button together
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use push-buttons every day, whether that be in selecting a floor in an elevator
    or starting our car. Modern technology allows us to separate the push-button from
    the physical device that it controls. In other words, pushing a button can set
    in motion many different events that really have nothing to do with the button.
    We can emulate this detachment with our push-button and the Sense HAT emulator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: I can just picture some of you wondering what separating a button from what
    it is controlling actually means. To help you visualize it, picture a latching
    push-button that controls a light. When the button is pressed down, the circuit
    is completed and electricity runs through the leads on the push-button. With the
    use of controllers and computers such as the Raspberry Pi, all that the push-button
    is required to do is change its state. The controller or computer takes that state
    and performs actions that are completely separated from the push-button itself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the Sense HAT emulator from the Programming menu in Raspbian. Create a
    new Python file in Thonny and call it `sense-button.py`. Enter the following code
    into the file, and then click on the Run icon when done:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38d82455-991a-4e29-8de5-31d33de635a7.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you do not have any errors in your code, you should see that the display
    on the Sense HAT emulator changes to a red `X` on a white background when you
    press the button:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain the preceding code a bit. We start off by importing the libraries
    we need for our code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then create new button and Sense HAT emulator objects. Our `button` is once
    again connected to GPIO pin `4`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `display_x_mark` method creates an `X` in the display by using the `SenseHat`
    method `set_pixels`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `X` and `O` variables are used to hold color codes, with `(255,0,0)` being
    red, and `(255,255,255)` as white. The variable `x_mark` creates an 8 x 8 pattern
    that matches the resolution of the Sense HAT emulator screen. `x_mark` is passed
    into the `set_pixels` method of the `SenseHAT` object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Our continuous loop checks the `is_pressed` status of the button and calls the
    `display_x_mark` method if the status returns `true`. This method then prints
    a red `X` against a white background.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'The display is cleared with `sense.clear()` when the button is not in the pressed
    state:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Toggling an LED with a long button press
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `GPIO Zero` library, we can not only detect when a button has been
    pressed, but can also detect how long it has been pressed for. We will use the
    `hold_time` property and the `when_held` method to determine whether the button
    has been pressed for a certain duration. If this duration time has been exceeded,
    then we will turn an LED on and off.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the circuit diagram for our program. Keep the push-button
    wired to GPIO pin 4\. Use GPIO pin 17 for the LED, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e895d707-f0b5-45aa-85f4-b08962d1569d.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Create a new file in Thonny and call it `buttonheld-led.py`. Type in the following
    and click on Run:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Hold down the push-button for `5` seconds. You should see the LED toggle on.
    Now hold it again for another `5` seconds. The LED should toggle off.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve covered the first four lines of the code in previous examples. Let''s
    look at where the hold time for the button is set:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This line sets the hold time for the button at `5` seconds. The `when_held`
    method is called in our continuous loop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using lambda, we are able to create an anonymous function so that we may call
    `toggle()` on the `LED` object, `led`. This toggles the LED both on and off.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Reading the state from an infrared motion sensor
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alarm systems using motion sensors are a ubiquitous part of our society. With
    our Raspberry Pi, they are incredibly easy to build. We will cover the following
    in this section:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: What is a PIR sensor?
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `GPIO buzzer` class
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a basic alarm system
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a PIR sensor?
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PIR sensors, a type of motion sensor, are used to detect motion. Applications
    for PIR sensors are pretty much based on detecting motion for security systems.
    PIR stands for passive infrared, and PIR sensors contain a crystal that detects
    low-level radiation. PIR sensors are actually constructed in two halves, as it
    is the difference between the halves that detects motion. The following is a photo
    of an inexpensive PIR sensor:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/80f92423-d6d9-4649-b969-40074ac2036a.png)In the preceding photo,
    we can see the positive (**+**), negative (**-**), and signal (**S**) pins. This
    particular PIR sensor sits well on a breadboard.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the wiring diagram of our PIR circuit. The positive pin connects
    to the 5 V DC output on the Raspberry Pi. The negative pin connects to ground
    (GND), and the signal connects to GPIO pin 4:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d056ccfc-b83f-47cb-b414-f5e204570fd2.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Create a new Python file in Thonny and call it `motion-sensor.py`. Type in
    the following code and run it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should see a message reading `Detected Motion!` when you get close to the
    PIR sensor. Try staying still and see whether you can get the message `No Motion
    Detected!` to display in the shell.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code begins by importing the `MotionSensor` class from the `GPIO Zero`
    library:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After importing the `sleep` class, we create a new `MotionSensor` object, called
    `motion_sensor`, with the number `4` appended in order to make our program look
    for the signal on GPIO pin 4:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our continuous loop, we check the `motion_sensor` for motion with this line:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From here on in the code, we define the messages to print to the shell.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Using the GPIO Zero buzzer class
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally, there are two types of electronic buzzers: active and passive. An
    active buzzer has an internal oscillator and will make a sound when a direct current,
    or DC, is applied to it. A passive buzzer requires an alternating current, or
    AC, in order for it to make a sound. Passive buzzers are basically small electromagnetic
    speakers. The easiest way to tell the difference is to apply a DC supply and listen
    for a sound. For the purposes of our code, we will be using an active buzzer,
    as shown in the following photo:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9cabbcd7-9a5f-476a-a961-170e92323f84.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'There is a `buzzer` class in the `GPIO Zero` library. We will use this class
    to generate a piercing alarm sound with our active buzzer. Configure the circuit
    as shown in the following diagram. The positive wire on the active buzzer connects
    to GPIO pin 17:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c1e46b62-c411-4348-beb9-266ae3e17aba.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'Create a new Python file in Thonny and call it `buzzer-test1.py`. Type in the
    following code and run it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Depending on the active buzzer you chose, you should hear a piercing sound
    for two seconds followed by 2 seconds of silence. The following line turns on
    the buzzer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Likewise, this line in the preceding code turns off the buzzer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code may be simplified by using the `toggle` method on the `buzzer` object.
    Create a new Python file in Thonny. Call it `buzzer-test2.py`. Type in the following
    and run it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should get the same results. A third way to do the same thing would be
    to use the `beep` method from the `buzzer` object. Create a new Python file in
    Thonny. Call it `buzzer-test3.py`. Type in the following and run it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `buzzer` should turn on for `2` seconds, and then off for `2` seconds,
    and repeat this for a total of `10` times. The `beep` method takes the following
    four parameters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`on_time`: This is the number of seconds the sound is on. The default is `1`
    second.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`off_time`: This is the number of seconds the sound is off. The default is
    `1` second.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n`: This is the number of times the process will run. The default is `None`,
    which means forever.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`background`: This determines whether or not to start a background thread to
    run the process. A `True` value runs the process in a background thread and returns
    right away. When set to `False`, return does not happen until the process is finished
    (please note that when `n` is `None`, the method never returns).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a basic alarm system
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s build a basic alarm system around the buzzer. Hook up the PIR sensor
    to GPIO pin 4, and a latching push-button to GPIO pin 8\. The following is the circuit
    diagram for our system:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2227e962-05f3-42cd-8afd-f285c678cb38.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Create a new file in Thonny and call it `basic-alarm-system.py`. Type in the
    following and click on Run:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What we have done here is create an alarm system with our components. We are
    using a latching push-button to turn the alarm system on and off. We could easily
    replace the latching push-button with a key switch. The following picture shows
    this change:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7850b80f-1614-4439-91b0-8dd9269c8ade.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: This circuit can easily be transferred to a project box for use as an alarm
    system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Hello LED using infrared sensor
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue our exploration of sensors by modifying our original `Hello
    LED` code. In this project, we will combine a distance sensor with our PIR sensor,
    and flash an LED based on the values of these sensors. This circuit will not only
    tell us that someone is approaching, but will also give us an indication of how
    close they are.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following in this section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a distance sensor
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking `Hello LED` to another level
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a distance sensor
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by configuring the distance sensor and running some code. The
    following is a circuit diagram of our distance sensor circuit:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0566f96-1a30-491c-97be-90aff92585be.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'The following are the connections to be made:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: VCC from the motion sensor connects to the 5 V DC output from the Raspberry
    Pi
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPIO pin 17 connects to Trig on the distance sensor
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Echo on the distance sensor connects to a 330 Ohm resistor
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND on the distance sensor connects to GND on the Raspberry Pi and a 470 Ohm
    resistor
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other end of the 330 Ohm resistor, from the echo pin on the distance sensor,
    connects to the 470 Ohm resistor (the two resistors create a voltage divider circuit)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPIO pin 18 from the Raspberry Pi connects to the intersection of the resistors
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of note in this circuit is the voltage divider that is created by the two resistors.
    We use this divider to connect GPIO pin 18.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python file in Thonny and call it `distance-sensor-test.py`. Type
    in the following code and run it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see an output similar to following screenshot. As you place your
    hand, or any other object, in front of the distance sensor, the value printed
    to the Shell should change, as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/998c5ae2-fac9-47bf-80e5-508593e35f36.png)Be sure to have the distance
    sensor on a secure, non-moving surface, such as a breadboard.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Taking Hello LED to another level
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our original `Hello LED!` system was a simple circuit, which involved making
    an LED, connected to the GPIO port, blink on and off. We have covered so much
    more since creating that circuit. We will take what we've learned and create a
    new `Hello LED` circuit. With this circuit, we will create an alarm system where
    the distance from the alarm is indicated by the blinking frequency of the LED.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the circuit diagram for our new `Hello LED` system:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/91600d51-e1a3-4ba4-8942-ac3b62b33e2e.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'This may look a little complex, with wires going every which way; however,
    it is quite a simple circuit. The distance sensor part is the same as it was previously.
    For the other components, connect as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The PIR sensor's positive pin connects to 5V DC on the breadboard
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PIR sensor's negative pin connects to GND on the breadboard
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PIR sensor's signal pin connects to GPIO pin 4
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LED's positive pin connects to GPIO pin 21 through a 220 Ohm resistor
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LED's negative pin connects to GND on the breadboard
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new Python file in Thonny and call it `hello-led.py`. Type in the
    following code and run it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The LED should start blinking as soon as motion is detected. The frequency of
    the LED's blinking will speed up as you place your hand closer and closer to the
    distance sensor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should now be quite familiar with interacting with sensors and our Raspberry
    Pi. This chapter should be considered an exercise in creating sensory circuits
    using our Raspberry Pi with ease.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: We will use this knowledge in [Chapter 9](1a50006e-75d3-4dc1-96db-82114b437795.xhtml),
    *Building a Home Security Dashboard*, where we will create an IoT home security
    dashboard.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between an active buzzer and a passive buzzer?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? We check the `button.is_pressed` parameter to confirm whether
    or not our push-button has been pressed.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? We require a voltage divider circuit in order to connect our
    PIR sensor.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three different methods we can use to have our active buzzer beep
    on and off?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? Push-buttons must connect directly to a circuit in order to be
    useful.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？按键必须直接连接到电路才能发挥作用。
- en: Which `DistanceSensor` parameter do we use to check the distance of an object
    from the distance sensor?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪个`DistanceSensor`参数来检查物体与距离传感器的距离？
- en: Which method from the Sense HAT emulator do we use to print pixels to the screen?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Sense HAT模拟器的哪个方法来将像素打印到屏幕上？
- en: How would we set up our `MotionSensor` to read from GPIO pin 4?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何设置我们的`MotionSensor`来从GPIO引脚4读取？
- en: True or false? Basic alarm systems are far too complicated for our Raspberry
    Pi to create.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？基本的报警系统对于我们的树莓派来说太复杂了。
- en: True or false? The Sense HAT emulator may be used to interact with outside sensors
    connected to the GPIO.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？Sense HAT模拟器可以用来与连接到GPIO的外部传感器进行交互。
- en: Further reading
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Consult the GPIO Zero documentation [https://gpiozero.readthedocs.io/en/stable/](https://gpiozero.readthedocs.io/en/stable/)
    for further information on using this library.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅GPIO Zero文档[https://gpiozero.readthedocs.io/en/stable/](https://gpiozero.readthedocs.io/en/stable/)，了解如何使用这个库的更多信息。
