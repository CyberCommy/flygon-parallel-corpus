- en: Chapter 8. Object-oriented Programming with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In 1995, the **Gang of Four** (**GoF**), published a book named *Design Patterns:
    Elements of Reusable Object-Oriented Software*. In it, the authors, Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, describe a number of classic
    software design patterns. These patterns present simple and elegant solutions
    to common software problems. If you have never heard of design patterns such as
    the Factory pattern, Composite pattern, Observer pattern, or Singleton pattern,
    then going through this GoF book is highly recommended.'
  prefs: []
  type: TYPE_NORMAL
- en: The Design patterns presented by the GoF have been reproduced in many different
    programming languages, including Java and C#. Mark Torok has even ported these
    patterns to TypeScript, and his GitHub repository can be found at [https://github.com/torokmark/design_patterns_in_typescript](https://github.com/torokmark/design_patterns_in_typescript).
    We have already explored one of these patterns, the Factory Design Pattern, in
    [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and Generics"), *Interfaces,
    Classes and Generics*, and Mark's work provides a quick and simple reference implementation
    of all of the GoF patterns in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Simon Timms has also published a book called *Mastering JavaScript Design Patterns*,
    *Packt Publishing* ([https://www.packtpub.com/application-development/mastering-javascript-design-patterns](https://www.packtpub.com/application-development/mastering-javascript-design-patterns)),
    which walks the reader through each of these patterns, when to use them, and how
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will not cover the standard GoF design patterns, but instead
    take a look at two other popular design patterns and how they can be implemented
    in TypeScript. We will discuss Dependency Injection using a Service Locator Pattern,
    and then see how these techniques can be used to build a Domain Event Pattern
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Program to an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary notions that the GoF adhere to, is the idea that programmers
    should "program to an interface, and not an implementation". This means that programs
    are built using interfaces as the defined interaction between objects. By programming
    to an interface, client objects are unaware of the internal logic of their dependent
    objects, and are much more resilient to change.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript language brings with it the `interface` keyword, allowing us
    to write object-oriented code against interfaces in a much easier way than with
    standard JavaScript. Remember, though, that interfaces are a TypeScript concept
    only, and are compiled away in the generated JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note that many other languages have the concept of being able to interrogate
    an object to see which interfaces they implement, a process called **reflection**.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An extension of the "program to an interface" principle, is what has been coined
    as SOLID design principles, based on the ideas of Robert Martin. This is an acronym
    for five different programming principles, and deserves a mention whenever object-oriented
    programming is discussed. Each of the letters in the word SOLID relate to an object-oriented
    principle, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'S: Single Responsibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'O: Open Closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'L: Liskov Substitution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I: Interface Segregation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'D: Dependency Inversion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind the Single Responsibility principle is that an object should
    have just a single responsibility, or a single reason to exist. In other words,
    do one thing and do it well. We have seen examples of this principle in the previous
    chapter, in our work with Backbone. A Backbone model class is used to represent
    a single model. A Backbone collection class is used to represent a collection
    of these models, and a Backbone view class is used to render models or collections.
  prefs: []
  type: TYPE_NORMAL
- en: Open Closed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind the Open Closed principle states that an object should be open
    to extension, but closed for modification. In other words, once an interface has
    been designed for a class, changes that occur over time to this interface, should
    be implemented through inheritance, and not by modifying the interface directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you are writing libraries that are consumed by third-parties via
    an API, then this principle is essential. Changes to an API should only be made
    through a new, versioned release, and should not break the existing API or interface.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Liskov Substitution principle states that if one object is derived from
    another, then these objects can be substituted for each other without breaking
    functionality. While this principle seems fairly easy to implement, it can get
    pretty hairy when dealing with subtyping rules that relate to more complex types,
    such as lists of objects or actions on objects—which are most often found in code
    that works with generics. In these instances, the concept of variance is introduced,
    and objects can be either covariant, contravariant, or invariant. We will not
    discuss the finer points of variance here, but keep this principle in mind when
    writing libraries or code using generics.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind the Interface Segregation principle is that many interfaces
    are better than one general-purpose interface. If we tie this principle in with
    the Single Responsibility principle, we will start to look at our interfaces as
    smaller pieces of the puzzle, which will be put together to create broader application
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Dependency Inversion principle states that we should depend on abstractions
    (or interfaces) rather than instances of concrete objects. Again, this is the
    same principle as "program to an interface, and not an implementation".
  prefs: []
  type: TYPE_NORMAL
- en: Building a Service Locator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of the Service Location Pattern is that some areas of an application
    can be broken down into services. Each service should adhere to our SOLID design
    principles, and provide a small external interface that acts as a service API.
    Each service used by an application is then registered with a service locator.
    When a specific piece of information or functionality is required by the application,
    it can query this service locator to find the correct service, based on the service
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The problem space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we explored Backbone, where our application was broken
    down into models, collections, and views. Outside of these elements, we also had
    an application class to coordinate the loading of data via a collection, and the
    rendering of this collection using a view. Once our application classes were built,
    the last piece of the puzzle was putting together the `require.config` object,
    in order to coordinate the loading of our AMD modules, any HTML that we needed
    in our application, and our jQuery plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a look at a visual representation of which aspect of the application
    loaded which files, we come up with something that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The problem space](img/9665OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Application object dependency tree
  prefs: []
  type: TYPE_NORMAL
- en: We start at the top with an HTML page named `ContactViewApp.html`, which is
    the main entry page for our application, and which will be served up to the web
    browser. This HTML page then loads the Require library, which in turn loads our
    `AppConfig.ts` file containing the `require.config` section. This `require.config`
    section then instructs Require to load various scripts from the `/Scripts/` directory,
    as well as a snippet of HTML via the Text plugin. Once all files have been loaded
    by Require, the last portion of the `AppConfig.ts` file then loads the `ContactViewApp.ts`,
    which in turn loads our `ContactCollection.ts` and `ContactCollectionView.ts`
    files. These last two files then instruct Require to load the module files named
    `ContactModel.ts` and `ContactItemView.ts` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If we take a closer look at this hierarchy, it is quite feasible to imagine
    that in a large application, we would have a large amount of collections, models,
    views, and item views. It may be that we are loading collections of collections,
    and views containing sub-views that contain further sub-views. Each of these views
    will require some HTML to be loaded via the Text plugin, in order to use our template
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at how we loaded and used an HTML snippet in our
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The problem space](img/9665OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dependency tree with usage of global variable
  prefs: []
  type: TYPE_NORMAL
- en: In this diagram, we can see that we loaded an HTML snippet via the Text plugin,
    within the `AppConfig.ts` file, and then stored it into a global variable named
    `CONTACT_ITEM_SNIPPET`. The only code that used this global variable was the `ContactItemView`
    class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using a global variable breaks our Dependency Inversion principle, in that we
    are programming to a concrete instance of a global variable, instead of an interface.
    This global variable can also be inadvertently changed by any running code, which
    may cause our views to stop functioning. Another problem that we faced when running
    our test suite, was that changing the original HTML template broke some of our
    unit tests. While we were able to modify the tests slightly in order to pass,
    this broken test highlighted that we had broken the Open Closed principle somewhere
    along the line.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will solve the problem of using a global variable to store HTML snippets
    in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s define a service to replace our global variables—a `SnippetService`.
    This service will have a very simple interface, and will be only responsible for
    two things: storing an HTML snippet and retrieving an HTML snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we need a mechanism to get hold of this `SnippetService`, both at
    the point in our code where we store the snippet (in `AppConfig.ts)`, and also
    at the point where we use the snippet (in `ContactItemView.ts)`. We will use a
    Service Locator at both of these touch-points a bit later, but for now, let's
    flesh out a design for our snippet service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing a `SnippetService` changes our dependency diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Service](img/9665OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dependency tree using a service to store HTML snippets
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we have now abstracted away the use of our global variable.
    We still have a global area to store these HTML snippets, i.e. the Snippet Storage
    area, but we are now programming against an interface—that the `SnippetService`
    provides—and not against a concrete implementation. Our application is now guarded
    against any changes to the internal storage of these HTML snippets. As an example,
    we may decide to change our implementation from using HTML files, to storing HTML
    snippets in a database. In this case, only the internals of the `SnippetService`
    would need to be modified, and our code could carry on without needing to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we will need some sort of key to allow us to store more than one
    snippet, but should the `SnippetService` be responsible for defining this key
    or not? Think Single Responsibility. Is the `SnippetService` really responsible
    for managing the keys that relate to the snippets? In other words, does it need
    to add or remove these keys? Not really. A smaller enum class would prove quite
    useful here, and favors numerous smaller interfaces over one general-purpose interface
    – think Interface Segregation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these things in mind, we can define the interface for our `SnippetService`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we define an `enum` named `SnippetKey` to store all the keys to be
    used by the `SnippetService`. Secondly, we define the interface for the actual
    `SnippetService`, named `ISnippetService`, which has two functions. The first
    function will be a method to store a snippet, and is named `storeSnippet`. This
    function has two arguments, the first being a `SnippetKey` enum value, and the
    second argument is, of course, the HTML snippet itself. Similarly, the second
    function, named `retrieveSnippet` uses a single `SnippetKey` argument to retrieve
    the HTML snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined an interface, we can create the structure of our `SnippetService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a class named `SnippetService` that implements our `ISnippetService`
    interface. We have created the two methods defined in the interface, but have
    not yet provided an implementation. We will use this opportunity to follow TDD
    principles and write a failing unit test before writing the code that makes the
    tests pass. Our unit test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we simply create an instance of the `SnippetService`, store a
    snippet with the key of `SnippetKey.CONTACT_ITEM_SNIPPET`, and then call `retrieveSnippet`
    with the same key, verifying the string value returned. Bear in mind that this
    is a simulated test, and in the real application, the `storeSnippet` call will
    occur during application initialization, and the `retrieveSnippet` call will occur
    at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now flesh out the `SnippetService` so that the tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our `SnippetService` class now has an internal array of strings named `snippetArray`,
    marked as `private`, which will hold our HTML snippet values. Our `storeSnippet`
    and `retrieveSnippet` functions are now simply storing or retrieving values from
    this array. With this code in place, our test will now pass and our simple `SnippetService`
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thus far, we have refactored our code to be dependent on an interface instead
    of a concrete object. This is all well and good, but begs the question: "how do
    we get hold of an interface?" – or more correctly – "how do we get hold of the
    concrete class that is currently implementing this interface?". This is the essential
    question that Dependency Injectors seek to answer.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different ways in which a class can get hold of another
    class that implements an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Service Location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the class itself requests a concrete object based on an interface, then this
    process is called "**Service Location**". In other words, the class is using a
    registry or helper to locate the service it requires. You could also describe
    this technique as "dependency requesting". A central registry holds a lookup table
    with all registered classes against their respective interfaces. When the interface
    is requested, the Service locator simply looks up what class instance is stored
    against the interface in its table, and returns the object from its registry.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the act of creating an instance of a class can be handed over to some sort
    of framework, then this framework can work out what interfaces a class needs,
    and "inject" these dependencies during class instantiation. This injection of
    dependencies is also called **assembly**. In this case, an assembler class or
    framework would need to be able to query an object to find out what interfaces
    it is dependent on. Unfortunately, we do not have this ability in JavaScript or
    TypeScript, as all interfaces are compiled away. So, we cannot use TypeScript
    interfaces by themselves to implement dependency injection. If we were to implement
    dependency injection in TypeScript or JavaScript, we would need some sort of naming
    convention to flag to the assembler framework that we need a concrete object to
    replace an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection is also referred to as Inversion of Control—as we are handing
    over control of creation of our classes, and the resolution of their dependencies—to
    a third party. By the time we receive an instance of our class, all of the services
    or dependencies have been "magically" filled in.
  prefs: []
  type: TYPE_NORMAL
- en: Service Location versus Dependency Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ideas around the Service Location pattern were first introduced by Martin
    Fowler around 2004, in a blog titled *Inversion of Control Containers and the
    Dependency Injection pattern* ([http://martinfowler.com/articles/injection.html](http://martinfowler.com/articles/injection.html)).
    However, in his book, *Dependency Injection in .NET*, Mark Seeman argues that
    the Service Location pattern is in fact an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Mark's take on Martin's original ideas are that it is too easy to introduce
    runtime errors, or to misunderstand the usage of a particular class, when Service
    Location is used. This is because figuring out what services a class uses, means
    reading through the entire class. He argues that a better way of using Dependency
    Injection, is to list all dependencies in the constructor function of a class,
    and let the service locator resolve each dependency, during class constructon.
    Most of Mark's examples seem to revolve around building and using APIs, where
    internals of a particular class cannot simply be read from the code, and using
    a class without knowing what services it depends on, can easily cause runtime
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: While his ideas do certainly hold true, the solutions to this problem are all
    relevant to the .NET language—which has a key language feature that is unavailable
    in JavaScript— called Reflection. Reflection is the ability of a program—at runtime—to
    interrogate an object for information about itself, such as what properties it
    has, and what interfaces it implements or expects. Even though TypeScript provides
    the interface keyword, and does compile-time checking on these interfaces, all
    interfaces are compiled away in the resultant JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: This provides us with a serious problem. If a class is dependent on an interface,
    we cannot use this interface at runtime to look up the concrete implementation
    for the interface—because at runtime, this interface simply does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Angular uses a naming convention (a `$` prefix) to provide dependency injection
    capabilities. This has been rather successful, although there are caveats and
    some work-arounds when using minification routines. Angular 2.0 also solves this
    problem by providing a custom syntax to denote places where dependencies need
    to be injected. Other JavaScript frameworks—such as ExtJs—provide a mechanism
    to create objects by using a global creation routine, which then allows the framework
    to inject dependencies. This ExtJs technique, unfortunately, is not very compatible
    with the TypeScript language syntax (see [Chapter 5](ch05.html "Chapter 5. Third
    Party Libraries"), *Third Party Libraries* where we discuss ExtJs).
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we are not using Angular, Angular 2.0, ExtJs, or any other framework,
    then Dependency Injection is just slightly out of reach in standard JavaScript.
    Service Location, on the other hand, can be accomplished, and combined with TypeScript
    interfaces, can bring us all of the benefits of dependency resolution and therefore,
    modular programming.
  prefs: []
  type: TYPE_NORMAL
- en: We can also make a compromise in order to incorporate the ideas that Mark suggests—and
    limit our Service Location to object constructors. When writing libraries that
    use Service Location, we would need to clearly document what dependencies a particular
    class has—and how they need to be registered. Even popular .NET Dependency injection
    frameworks such as StructureMap still allow for Service Location techniques—although
    they are being deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, then, let's explore how to write a simple Service
    Locator and use it in our code to build a more modular application, and leave
    the argument about pattern versus anti-pattern to those languages that have the
    features to implement Dependency Injection naturally.
  prefs: []
  type: TYPE_NORMAL
- en: A Service Locator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get back to the crux of our problem: given an interface, how do we obtain
    a concrete implementation of a class that is currently implementing it?'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and Generics"), *Interfaces,
    Classes and Generics*, we wrote a generic class named `InterfaceChecker` that
    did a runtime evaluation of a class, to check whether it implemented a specific
    set of methods and properties. The basic idea behind this `InterfaceChecker` was
    that if we provided a metadata class that listed the expected properties and methods
    of an interface, we could then interrogate a class at runtime against this metadata.
    If the class had all of the required properties and methods, then it was said
    to implement the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we now have a mechanism—at runtime—to ensure that a class implements an
    interface: not a TypeScript interface, mind you, but a metadata-defined interface.
    If we extend this idea, and give each of our metadata interfaces a unique name,
    we have the concept of a "named interface". As long as these interface names are
    unique across our application, we now have a mechanism to query a class—at runtime—and
    see whether it implements a named interface.'
  prefs: []
  type: TYPE_NORMAL
- en: If a class implements a named interface, we can then use a registry to store
    an instance of this class against its named interface. Any other code that needs
    an instance of a class that is implementing this named interface, simply has to
    query the registry, supply the interface name, and the registry will be able to
    return the class instance.
  prefs: []
  type: TYPE_NORMAL
- en: As long as we ensure that our TypeScript interfaces match the named interface
    definitions, we are all good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Named interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and Generics"),
    *Interfaces, Classes and Generics*, we wrote an interface named `IInterfaceChecker`
    that we could use as a standard template for our metadata. Let''s update this
    interface and give it a required `className` property—so that we can use it as
    a named interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We still have the optional arrays of `methodNames` and `propertyNames`, but
    now every class that implements this interface will also require a `className`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, given the following TypeScript interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our named interface metadata class to match this TypeScript interface would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This `IHasIdProperty` interface has a single property named `id`, which is of
    type `number`. We then create a class named `IIHasIdProperty` to act as a named
    interface definition. This class implements our updated `IInterfaceChecker` interface
    and must, therefore, provide a `className` property. The `propertyNames` property
    has a single array entry named `id`, and will be used by our `InterfaceChecker`
    class to match against the `id` property of our TypeScript interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note the naming convention of this class—it is the same name as the interface
    but adds an extra `I`. This double `I` convention will help us to tie the TypeScript
    interface named `IHasIdProperty` with its `IIHasIdProperty` metadata named interface
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a normal TypeScript class that implements the `IHasIdProperty`
    TypeScript interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have all of the pieces in place to start building a Service Locator:'
  prefs: []
  type: TYPE_NORMAL
- en: A TypeScript interface named `IHasIdProperty`. This will provide compile-time
    type checking against a class implementing this interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A named interface or metadata class called `IIHasIdProperty`. This will provide
    runtime type checking against a class, and it also has a unique name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class that implements the TypeScript interface `IHasIdProperty`. This class
    will pass the runtime type checks, and an instance of this class can be registered
    with our Service Locator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering classes against named interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With these metadata classes in place, we can now create a central repository
    to act as a Service Locator. This class has static functions for registering classes,
    as well as resolving interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This class, named `TypeScriptTinyIoC`, has a single static property named `registeredClasses`,
    which is an array of type `any`. This array is essentially our registry. As we
    do not know what type of class we are going to store in this array, the use of
    the `any` type in this instance is correct.
  prefs: []
  type: TYPE_NORMAL
- en: This class then provides two primary static functions, named `register` and
    `resolve`. The `register` function takes a `targetObject` as its first parameter,
    and then a class definition of a named interface—i.e. a class derived from `IInterfaceChecker`.
    Note the syntax of the `targetInterface` argument—it is the same as the generic
    syntax that we used in [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and
    Generics"), *Interfaces, Classes and Generics,* to denote a class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is actually easier to understand these function signatures if we take a
    look at an example of their usage, so let''s write a quick test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This test first creates an instance of the `PropertyOne` class, which implements
    the `IHasIdProperty` interface. This class is the one that we would like to register.
    The test then calls the register function of `TypeScriptTinyIoC` with two parameters.
    The first parameter is the class instance itself, and the second parameter is
    the class definition for the associated named interface—`IIHasIdProperty`. We
    have seen this type of syntax before, when we discussed creating instances of
    classes using generics, but its signature is also available on nongeneric functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without using the `targetInterface: { new (): IInterfaceChecker; }` signature,
    we would have to call this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But with this signature in place, we can defer the creation of the `IIHasIdProperty`
    named interface class to the register function—and drop the new syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our test then calls the `resolve` function on `TypeScriptTinyIoC`, and again
    passes the class definition of our named interface as the lookup key. Finally,
    we check whether the class that is returned is in fact an instance of the `PropertyOne`
    class that we registered initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, our test will fail dramatically, so let''s flesh out the `TypeScriptTinyIoC`
    class, starting with the `register` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This `register` function firstly creates an instance of the `InterfaceChecker`
    class, and then creates an instance of the class definition passed in, through
    the `targetInterface` argument. This `targetInterface` is the named interface
    or metadata class. We then call the `implementsInterface` function of `interfaceChecker`
    to ensure that the `targetObject` implements the interface described by `targetInterface`.
    If it passes this check, we then add it to our internal array named `registeredClasses`,
    using the `className` property as a key.
  prefs: []
  type: TYPE_NORMAL
- en: Again, using our `InterfaceChecker` gives us runtime type checking—so that we
    can be sure that any class we are registering does in fact implement the correct
    named interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can flesh out the `resolve` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `resolve` function only has one parameter—the definition of our named interface.
    Again, we are using the `new`–able syntax that we have seen previously. This function
    simply creates an instance of the `targetInterface` class, and then uses the `className`
    property as the key into the `registeredClasses` array. If an entry is found,
    we simply return it; otherwise, we throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final function on our `TypeScriptTinyIoC` class is the `clearAll` function,
    and it is used primarily in testing to clear out our registered classes array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our service locator is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Service Locator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now update our dependency tree to see how the `TypeScriptTinyIoC` service
    locator would be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Service Locator](img/9665OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dependency diagram with a service locator pattern
  prefs: []
  type: TYPE_NORMAL
- en: Our `AppConfig.ts` code will now create an instance of the `SnippetService`,
    and register it with `TypeScriptTinyIoC` using a named interface—`IISnippetService`.
    Our `ContactItemView` constructor will then be updated to resolve an instance
    of the `IISnippetService` named interface from the registry. In this way, we are
    now programming to an interface—the `IISnippetService` interface. We use this
    named interface when we register our service with the service locator, and again
    when we resolve the service later on. Our `ContactItemView`, then, is asking the
    service locator to give us the current object that is implementing the `IISnippetService`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this change, we will firstly need a named interface to match the
    `ISnippetService` TypeScript interface. As a refresher, our `ISnippetService`
    was defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using our naming rules, our named interface definition would be called `IISnippetService`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `methodNames` array contains two entries that match our TypeScript
    interface. By convention, we have also specified a `className` property, so that
    we can use this class as a named interface. Using the name of the class (`IISnippetService`)
    as the `className` property will also ensure a unique name, as TypeScript will
    not allow multiple class definitions with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now focus on our test suite. Remember that our `TestConfig.ts` file is
    almost identical to our `AppConfig.ts` file, but starts the Jasmine test suite
    instead of running our app. We will modify this `TestConfig.ts` file to include
    our `SnippetService` and `TypeScriptTinyIoC` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we have included an entry for `tinyioc` and `snippetservice` in our
    paths property, to ensure that Require will load our files from the specified
    directory. We then update the call to the require function to include both the
    `tinyioc` and `snippetservice` in both of the arguments. Our anonymous function
    then creates a new instance of the `SnippetService` and stores the snippet that
    is loaded by Text, using the `CONTACT_ITEM_SNIPPET` key. We then register the
    instance of this `SnippetService` with `TypeScriptTinyIoC` using the named interface
    `IISnippetService`. If we run our test suite now, we should get a few failing
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Service Locator](img/9665OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unit test failures
  prefs: []
  type: TYPE_NORMAL
- en: 'This failure is caused because the `ContactItemView` still references the `CONTACT_ITEM_SNIPPET`
    global variable. Let''s now modify this view''s constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the constructor calls the `TypeScriptTinyIoC.resolve` function
    with the definition of the named interface, `IISnippetService`. The result of
    this call is stored in the `snippetService` variable, which is strongly typed
    to the `ISnippetService` interface. This is the essence of the service locator
    pattern: we are programming to an interface (`ISnippetService`) and also locating
    this interface via our service locator. Once we have an instance of the class
    providing the interface, we can simply call `retrieveSnippet` with the required
    key to load our template.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have updated and fixed our tests, we will just need to modify our
    `AppConfig.ts` file in the same way that we modified the `TestConfig.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are programming against a defined interface, we can start to test
    our code in different ways. In a test, we can now substitute the actual `SnippetService`
    for another service that throws an error when we call `retrieveSnippet`. For this
    test, lets create a class named `SnippetServiceRetrieveThrows` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This class can be registered against the `IISnippetService` named interface,
    as it correctly implements the TypeScript interface `ISnippetService`. The `retrieveSnippet`
    function, however, simply throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tests, then, can easily register this version of the service, and then
    create a `ContactItemView` class instance in order to see what happens, should
    the call to the `retrieveSnippet` function fail. Note that we have not modified
    our `ContactItemView` class in any way—we are simply registering a different class
    against the `IISnippetService` named interface. Our test, in this case, would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we are registering our throwing version of the `SnippetService`
    in our `beforeAll` function, and then testing the rendering capability of the
    `ContactItemView`. Running this test will cause an error to be thrown when the
    `ContactItemView` calls `retrieveSnippet`. To enable this test to pass, we need
    to update the `ContactItemView` to handle an error gracefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have simply surrounded the call to `retrieveSnippet` with a `try` `catch`
    block. If an error occurs, we are then modifying the snippet to be a standard
    error message. By putting a test like this in place, we are further solidifying
    our code to be able to handle various errors.
  prefs: []
  type: TYPE_NORMAL
- en: So what have we accomplished thus far? We have built a service to provide HTML
    snippets, and we have built a Service Locator that can register an instance of
    this service for use throughout our code. By registering different variations
    of this service during testing, we can also further bug-proof our code by simulating
    common errors, and testing our components under these circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: The Domain Events Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most JavaScript frameworks have the concept of an event bus. An event bus is
    simply a method of publishing events to a global bus, so that other parts of your
    application that are subscribed to these events will receive a message, and be
    able to react to them. The use of an event-based architecture helps to decouple
    our applications, making them resilient to change and easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: A Domain Event is an event that happens specific to our application domain.
    Something like "when an error occurs, log it to the console", or "when a menu
    button is clicked, change the sub-menu panel to reflect this option". A Domain
    Event can be raised anywhere in your code. Any class can register an event handler
    against this event, and will then be notified when this event is raised. There
    can be many event handlers for a single Domain Event.
  prefs: []
  type: TYPE_NORMAL
- en: Martin Fowler first blogged about the concept of a Domain Event in 2005 in a
    blog found at [http://martinfowler.com/eaaDev/DomainEvent.html](http://martinfowler.com/eaaDev/DomainEvent.html).
    Udi Dahan then showed how to implement a simple domain event pattern in C# in
    another blog found at [http://www.udidahan.com/2009/06/14/domain-events-salvation/](http://www.udidahan.com/2009/06/14/domain-events-salvation/).
    Mike Hadlow also blogged about Separation of Concerns with Domain Events, and
    this blog can be found at [http://mikehadlow.blogspot.com.au/2010/09/separation-of-concerns-with-domain.html](http://mikehadlow.blogspot.com.au/2010/09/separation-of-concerns-with-domain.html).
  prefs: []
  type: TYPE_NORMAL
- en: Mike argues that a piece of code that raises an event should not be concerned
    with what happens after that—we should have separate handlers to handle these
    events—which are not coupled to anything actually raising the events.
  prefs: []
  type: TYPE_NORMAL
- en: While there are a number of JavaScript libraries that handle events—Postal for
    example—most of these libraries send strings or simple JavaScript objects as the
    message packet. There is no way of ensuring that the sender of the message is
    filling in all of the properties that the handler of the message is expecting.
    In other words, these messages are not strongly typed—and could easily cause runtime
    errors—by trying to fit a "square peg" message into a "round hole" event handler.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will build a strongly typed Domain Event message bus, and
    show how both sides—the event raiser and the event handler—can ensure that the
    event that is raised has all of the properties that are expected in the event
    handler. We will also show how to ensure that the event handlers are written correctly—and
    registered correctly —so that events are delivered in a strongly typed manner.
  prefs: []
  type: TYPE_NORMAL
- en: Problem space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we have the following business requirement: "If an error
    occurs, show the user an error message in a notification pop up. This pop up should
    show for two seconds and then fade away, allowing the user to continue working."'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our current application, there are a number of places where errors could
    occur—when loading JSON through the `ContactCollection`, for instance—or when
    rendering a `ContactItemView`. These errors could occur quite deep down in our
    class hierarchy. In order to achieve our stated requirements, we will need to
    handle these errors at the `ContactViewApp` level. Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Problem space](img/9665OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dependency tree with domain event handlers and event raisers.
  prefs: []
  type: TYPE_NORMAL
- en: Our `ContactViewApp` will register an event handler with `TypeScriptTinyIoC`,
    specifying which event type it is interested in. When an event of this type is
    raised by any one of our modules, our message bus will direct the message to the
    correct handler, or group of handlers. In the preceding diagram, the `ContactCollection`
    and the `ContactItemView` classes are shown to be raising an `ErrorEvent` via
    `TypeScriptTinyIoC`.
  prefs: []
  type: TYPE_NORMAL
- en: Message and Handler Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two key sets of information that we need in order to register and
    raise strongly typed messages. The first is an interface describing the message
    itself, which is paired with its named interface. The second is an interface describing
    the message handler function, again which is paired with its named interface.
    Our TypeScript interface gives us compile-time checking of messages and handlers,
    and our named interfaces (implementing `IInterfaceChecker`) give us runtime type
    checking of messages and handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, the interfaces for our message are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We start with the TypeScript interface `IErrorEvent`. This interface has two
    properties, `Message` and `Description`, which are both strings. We then create
    our `IIErrorEvent` class, which is an instance of our named interface – again
    with the `propertyNames` array matching our TypeScript interface property names.
    The `className` property is also set to be the name of the class, `IIErrorEvent`,
    to ensure uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interfaces for our event handlers are then as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript interface `IErrorEvent_Handler` contains a single method, named
    `handle_ErrorEvent`. This handler method has a single parameter, `event`, which
    is again strongly typed to be our event interface, `IErrorEvent`. We then construct
    a named interface called `IIErrorEvent_Handler`, and match the TypeScript interface
    through the `methodNames` array. Again, we provide a unique `className` property
    for this named interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these two interfaces and named interfaces in place, we can now create
    the actual `ErrorEvent` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The class definition for `ErrorEvent` implements the `IErrorEvent` interface,
    thereby making it compatible with our event handler. Note the `constructor` of
    this class. We are forcing users of this class to provide both a `message` and
    `description` parameter in the constructor – thereby using TypeScript compile-time
    checking to ensure that we construct this class correctly, no matter where it
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create a class that implements the `IErrorEvent_Handler` interface,
    which will receive the event itself. As a quick example, consider the following
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This class implements the `IErrorEvent_Handler` TypeScript interface, and therefore
    the compiler will force the class to define a `handle_ErrorEvent` function with
    the correct signature, in order to receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Event Handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to register multiple events, and have multiple event handlers per
    event, we will need an array of events, each of which will, in turn, hold an array
    of handlers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple Event Handlers](img/9665OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Class structure for registering multiple event handlers per event.
  prefs: []
  type: TYPE_NORMAL
- en: Our `TypeScriptTinyIoC` class will have an array called `events`, which uses
    the name of the event as its key. This name will be drawn from our named interface
    for the event – again because TypeScript interfaces are compiled away. To help
    with managing multiple event handlers per event, we will create a new class called
    `EventHandlerList` that will facilitate the registration of multiple event handlers.
    An instance of this `EventHandlerList` class will be stored in our `events` array
    for each named event that we have registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with this list of event handlers, and implement our `EventHandlerList`
    class. At this stage, all we need is an internal array to store handlers, named
    `eventHandlers`, along with a `registerHandler` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `registerHandler` function is again using the `{ new(): IInterfaceChecker
    }` syntax for the `interfaceType` argument, thereby allowing us to use a type
    name for this function call. A quick unit test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We start this test with an `import` statement for our event classes, and then
    a class named `EventHandlerTests_ErrorHandler`. This class will be used as a registered
    event handler just for this test suite. The class implements the `iee.IErrorEvent_Handler`
    and, as such, will generate a compile error if we do not have a `handle_ErrorEvent`
    function that accepts an `IErrorEvent` as its only parameter. Just by using TypeScript
    interfaces, we have already ensured that this class has the correct function name
    and function signature to accept `ErrorEvent` messages.
  prefs: []
  type: TYPE_NORMAL
- en: Our test then starts by declaring a variable named `testHandler` to store an
    instance of our `EventHandlerTests_ErrorHandler` class. The `beforeEach` function
    will create this instance, and assign it to our `testHandler` variable. The test
    itself then creates an instance of the `EventHandlerList` class, calls the `registerHandler`,
    and then expects the `length` of the internal `eventHandlers` property to be the
    value of one.
  prefs: []
  type: TYPE_NORMAL
- en: Note again the syntax of the call to `registerHandler`. We are passing in our
    `testHandler` instance as the first argument, and then specifying the named interface
    `IIErrorEvent_Handler` class type. As we saw with the service locator pattern,
    we are again using the same class name syntax for our named interface, instead
    of having to call `new()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now fill in the code to make the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our `registerHandler` function firstly creates an instance of the `InterfaceChecker`
    class, and then calls `implementsInterface` to make sure, at runtime, that the
    handler object that is passed in does indeed have all of the method names defined
    by our named interface. If the `implementsInterface` function returns `true`,
    we can simply push this handler onto our internal array.
  prefs: []
  type: TYPE_NORMAL
- en: If the handler does not implement the named interface, we throw an error. For
    completeness, this error contains the `className` property of the named interface,
    so we first have to new up an instance of this named interface class, before we
    can extract the `className` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a test that will deliberately fail our `implementsInterface`
    check and ensure that an error is in fact thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We start with the class definition of the `No_ErrorHandler` class that obviously
    does not implement our named interface. Our test then sets up the `EventHandlerList`
    class, and calls the `registerHandler` function, using a new instance of the `No_ErrorHandler`
    class, and our `IIErrorEvent_Handler` named interface. We are then expecting a
    specific error message— one that should include the name of our named interface,
    `IIErrorEvent_Handler`.
  prefs: []
  type: TYPE_NORMAL
- en: Firing an event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now turn our attention to raising an event. To do this, we will need
    to know what the actual function name of the event handler is. We will make a
    slight change to our `EventHandlerList`, and pass in the event name to the constructor
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Our constructor is now expecting a `handleEventMethodName` as a required parameter,
    and we are storing this in a property named `handleEventMethod`. Remember that
    all of the handlers that are registered with an instance of this class are responding
    to the same event – and as such will all have the same method name – enforced
    by the TypeScript compiler. We have also defined a `raiseEvent` function, and
    since we do not know what event this class will be handling, the event is of type
    `any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a unit test that will fail, as the `raiseEvent` function
    is not actually doing anything as yet. Before we do this, lets update our test
    handler class, `EventHandlerTests_ErrorHandler,` to store the last event fired
    in a property that we can access later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We have updated this class definition with a property named `LastEventFired`,
    and set this property inside the `handle_ErrorEvent` function. With this change
    in place, when an event is fired, we can interrogate the `LastEventFired` property
    to see what event was fired last. Let''s now write a test that calls the `raiseEvent`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with a variable named `eventHandlerList` that holds an instance of
    our `EventHandlerList` class, and pass in the name of the function to be called
    via the constructor. We then call `registerHandler` with this `testHandler` instance.
    Now, we can call the `raiseEvent` function, passing in a `new ErrorEvent`. As
    the constructor of our `ErrorEvent` class requires two parameters, we have just
    passed in `"test"` for each of these arguments. Finally, we are expecting that
    the `LastEventFired` property of our event handler to be set correctly. Running
    our test at this stage will fail, so let''s implement the `raiseEvent` method
    on our `EventHandlerList` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of this `raiseEvent` function is relatively simple. We just
    iterate through our `eventHandlers` array, and then get a reference to each of
    the event handlers using an index. The line to note here is how we execute the
    handler function: `handler[this.handleEventMethod](event)`. This takes advantage
    of JavaScript''s ability to calling a function using a string value that matches
    the function''s name. In our tests, this would be equivalent to `handler[''handle_ErrorEvent''](event)`,
    which in JavaScript is equivalent to `handler.handle_ErrorEvent(event)`—an actual
    call to the handler function. With this JavaScript magic in place, our events
    are being fired, and our unit tests run through correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Registering an Event handler for an Event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a working, tested class to manage multiple event handlers responding
    to a specific event, we can turn our attention back to the `TypeScriptTinyIoC`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did for our Service Locator pattern, we will need to register an instance
    of an object to handle a specific event. The method signature for registering
    our event handler will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This `registerHandler` function takes three arguments. The first is the instance
    of the object implementing the handler. The second argument is the named interface
    class for our handler—so that we can check this class at runtime to ensure that
    it implements the handler interface. The third argument is the named interface
    for the event itself. This `register` function is also what binds an event to
    its handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we put together a unit test, we will need another static function to
    raise an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This `raiseEvent` function on the `TypeScriptTinyIoC` class will call the `raiseEvent`
    function on the `EventHandlerList` class instance for this event. We will also
    do an `interfaceChecker` test here, in order to ensure that the event being raised
    matches our named interface class for the event—before we actually raise the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for our unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This test is very similar to the test that we wrote for our `EventHandlerList`
    class, except we are calling the `registerHandler` and `raiseEvent` methods on
    the `TypeScriptTinyIoC` class, instead of a specific `EventHandlerList`. With
    this failing test in place, we can now fill out the `registerHandler` and `raiseEvent`
    functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we have added a static property called `events`, which is an array
    of `EventHandlerList` instances. We will add to this array using the `className`
    of our named event interface as a key. Our `registerHandler` function firstly
    creates instances of both named interface classes that are passed in via the `handlerInterface`
    and `eventInterface` arguments. We are then checking to see whether our internal
    array already has an `EventHandlerList` instance for this event, keyed via the
    `className` property of our named event interface. If we have an entry already,
    we can simply call the `registerHandler` function on the existing `EventHandlerList`
    instance. If this event has not been registered, we simply create a new instance
    of an `EventHandlerList` class, call `registerHandler`, and then add this entry
    to our internal array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how we figured out what the actual name of the event handler function
    call is. We are simply using the first method name found in our method names array:
    `handlerInterfaceInstance.methodNames[0]`, which will return a string. In our
    samples, this would return the `''handle_ErrorEvent''` string, which is the method
    name that we will need to invoke when invoking handler functions for an event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can focus on the `raiseEvent` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This function first creates an instance of an `InterfaceChecker` class, and
    then ensures that the event being raised conforms to the named interface that
    we provide as the second parameter. Again, this is a runtime type check to ensure
    that the event we are attempting to raise is in fact of the correct type. If the
    event is valid, we fetch the instance of the `EventHandlerList` class that is
    registered for this event, and then call its `raiseEvent` function.
  prefs: []
  type: TYPE_NORMAL
- en: Our strongly typed Domain Event mechanism is now complete. We are using both
    compile-time TypeScript interface checking, and runtime type checking in two ways.
    Firstly, when registering a handler, we do an interface check, and then when we
    fire an event, we do another interface check. This means that both sides—registering
    and firing—of events are strongly typed, both at compile time and also at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying error notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our `TypeScriptTinyIoC` event mechanism in place, we can focus
    on solving the business problem of showing error notifications when errors occur.
    Notify is a jQuery plugin that suits our needs perfectly ([http://notifyjs.com/](http://notifyjs.com/)).
    We could install the JavaScript library from NuGet (Install the `jQuery.notify`
    package), but the default version of this package relies on another package named
    Bootstrap for its styling. Notify, however, also provides an option on their website
    to download a custom notify.js script that has all of these styles built-in to
    the library. We will use this custom version, as our project is not using the
    Bootstrap package.
  prefs: []
  type: TYPE_NORMAL
- en: The definition file for Notify can be downloaded from DefinitelyTyped ([https://github.com/borisyankov/DefinitelyTyped/tree/master/notify](https://github.com/borisyankov/DefinitelyTyped/tree/master/notify)).
    At the time of writing, however, there seems to be two versions of the Notify
    library, one named Notify and the other named Notify.js. Use the Notify version
    as it seems to be more up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simulate an error, let''s tag onto the `ContactItemView onClicked` function,
    where we are currently executing a flip, and raise a dummy error whenever someone
    clicks on one of our contact links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After our call to flip, we are simply creating an instance of the `ErrorEvent`
    class, with its two required parameters. We then call the `raiseEvent` function
    on `TypeScriptTinyIoC` with this `errorEvent` instance, and the named interface
    for the type of event that we are raising. It's as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can modify our `ContactViewApp` to register a handler for this event
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, have made a few changes to our `ContactViewApp` class. Firstly, we implement
    the `IErrorEvent_Handler` TypeScript interface, which will force us to include
    the `handle_ErrorEvent` function within our class. We have also defined a `constructor`,
    and within this, we are registering the class instance as a handler using our
    two named interfaces: `IIErrorEvent_Handler`, and `IIErrorEvent`.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the `handle_ErrorEvent` function, we are calling `$.notify`—the Notify
    jQuery plugin. Note that the type of the `event` argument passed into the `handle_ErrorEvent`
    function, is of type `IErrorEvent`. This means that we can safely use any properties
    or methods of the `IErrorEvent` interface within our event handler function, as
    we have already ensured, during event raising, that this event implements the
    interface correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our call to Notify is just using a message that is built up from our `ErrorEvent`.
    The following screenshot shows the results of this Notify call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying error notifications](img/9665OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of application showing an error notification
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of this Service Locator pattern and the strongly typed Domain
    Events pattern that we have worked through in this chapter are available on the
    GitHub project *typescript-tiny-ioc* ([https://github.com/blorkfish/typescript-tiny-ioc](https://github.com/blorkfish/typescript-tiny-ioc)).
    This project has further code samples as well as a full suite of unit tests for
    both AMD and normal JavaScript usage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at object-oriented programming, beginning with
    the SOLID Design principles. We then reviewed the application that we had built
    in [Chapter 7](ch07.html "Chapter 7. Modularization"), *Modularization*, with
    regards to these principles. We discussed various methods of Dependency Injection,
    and then built a mechanism that is based on our `InterfaceChecker` from [Chapter
    3](ch03.html "Chapter 3. Interfaces, Classes and Generics"), *Interfaces, Classes
    and Generics*, to obtain an instance of a named interface. We used this principle
    to build a Service Locator and then extended this principle to build a strongly
    typed event bus for the Domain Event pattern. Finally, we incorporated Notify
    into our application for simple notifications in response to these error events.
    In our next and final chapter, we will put all of the principles we have learned
    so far into practice, and build an application from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
