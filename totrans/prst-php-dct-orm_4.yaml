- en: Chapter 4. Building Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we added commenting and tagging support to our blog
    software. Although it works fine, some of the features can be enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will leverage some very important parts of Doctrine: **Doctrine
    Query Language** (**DQL**), entity repositories, and the Query Builder. We will
    cover the following aspects in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the Comment feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a page to filter the posts with the help of tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the number of comments of a post on the home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding DQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DQL is the acronym of Doctrine Query Language. It's a domain-specific language
    that is very similar to SQL, but is not SQL. Instead of querying the database
    tables and rows, DQL is designed to query the object model's entities and mapped
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'DQL is inspired by and similar to HQL, the query language of Hibernate, a popular
    ORM for Java. For more details you can visit this website: [http://www.hibernate.org/](http://www.hibernate.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Learn more about domain-specific languages at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Domain-specific_language](http://en.wikipedia.org/wiki/Domain-specific_language)'
  prefs: []
  type: TYPE_NORMAL
- en: To better understand what it means, let's run our first DQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doctrine command-line tools are as genuine as a Swiss Army knife. They include
    a command called `orm:run-dql` that runs the DQL query and displays it''s result.
    Use it to retrieve `title` and all the comments of the post with `1` as an identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like a SQL query, but it''s definitely not a SQL query. Examine the
    `FROM` and the `JOIN` clauses; they contain the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: A fully qualified entity class name is used in the `FROM` clause as the root
    of the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the `Comment` entities associated with the selected `Post` entities are
    joined, thanks to the presence of the `comments` property of the `Post` entity
    class in the `JOIN` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, data from the entities associated with the main entity can be
    requested in an object-oriented way. Properties holding the associations (on the
    owning or the inverse side) can be used in the `JOIN` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Despite some limitations (especially in the field of subqueries), which we will
    see how to get around in [Chapter 5](ch05.html "Chapter 5. Going Further"), *Going
    Further*, DQL is a powerful and flexible language to retrieve object graphs. Internally,
    Doctrine parses the DQL queries, generates and executes them through **Database
    Abstraction Layer (DBAL)** corresponding to the SQL queries, and hydrates the
    data structures with results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now, we only used Doctrine to retrieve the PHP objects. Doctrine is able
    to hydrate other types of data structures, especially arrays and basic types.
    It's also possible to write custom hydrators to populate any data structure.
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely at the return of the previous call of `orm:run-dql`, you'll
    see that it's an array, and not an object graph, that has been hydrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all the topics covered in this book, more information about built-in
    hydration modes and custom hydrators is available in the Doctrine documentation
    on the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/en/latest/reference/dql-doctrine-query-language.html#hydration-modes](http://docs.doctrine-project.org/en/latest/reference/dql-doctrine-query-language.html#hydration-modes)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the entity repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entity repositories are classes responsible for accessing and managing entities.
    Just like entities are related to the database rows, entity repositories are related
    to the database tables.
  prefs: []
  type: TYPE_NORMAL
- en: We have already used default entity repositories provided by Doctrine to retrieve
    the entities in the previous chapters. All the DQL queries should be written in
    the entity repository related to the entity type they retrieve. It hides the ORM
    from other components of the application and makes it easier to re-use, refactor,
    and optimize the queries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Doctrine entity repositories are an implementation of the Table Data Gateway
    design pattern. For more details, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://martinfowler.com/eaaCatalog/tableDataGateway.html](http://martinfowler.com/eaaCatalog/tableDataGateway.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A base repository, available for every entity, provides useful methods for
    managing the entities in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find($id)`: It returns the entity with `$id` as an identifier or `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is used internally by the `find()` method of the Entity Managers. We used
    this shortcut many times in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '`findAll()`: It retrieves an array that contains all the entities in this repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findBy([''property1'' => ''value'', ''property2'' => 1], [''property3'' =>
    ''DESC'', ''property4'' => ''ASC''])`: It retrieves an array that contains entities
    matching all the criteria passed in the first parameter and ordered by the second
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findOneBy([''property1'' => ''value'', ''property2'' => 1])`: It is similar
    to `findBy()` but retrieves only the first entity or `null` if none of the entities
    match the criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Entity repositories also provide shortcut methods that allow a single property
    to filter entities. They follow this pattern: `findBy*()` and `findOneBy*()`.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, calling `findByTitle('My title')` is equivalent to calling `findBy(['title'
    => 'My title'])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature uses the magical `__call()` PHP method. For more details visit
    the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://php.net/manual/en/language.oop5.overloading.php#object.call](http://php.net/manual/en/language.oop5.overloading.php#object.call)'
  prefs: []
  type: TYPE_NORMAL
- en: As seen in [Chapter 3](ch03.html "Chapter 3. Associations"), *Associations*,
    these shortcut methods don't join the related entities unless we add a `fetch="EAGER"`
    attribute to the association annotation in the entity class. Another SQL query
    will be issued if (and only if) a related entity (or a collection of entities)
    is requested through a method call.
  prefs: []
  type: TYPE_NORMAL
- en: In our blog app, we want to display comments in the detailed post view, but
    it is not necessary to fetch them from the list of posts. Eager loading through
    the `fetch` attribute is not a good choice for the list, and Lazy loading slows
    down the detailed view.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this would be to create a custom repository with extra methods
    for executing our own queries. We will write a custom method that collates comments
    in the detailed view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom entity repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom entity repositories are classes extending the base entity repository
    class provided by Doctrine. They are designed to receive custom methods that run
    the DQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we will use the mapping information to tell Doctrine to use a custom
    repository class. This is the role of the `repositoryClass` attribute of the `@Entity`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kindly perform the following steps to create a custom entity repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen the `Post.php` file at the `src/Blog/Entity/` location and add a `repositoryClass`
    attribute to the existing `@Entity` annotation like the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Doctrine command-line tools also provide an entity repository generator. Type
    the following command to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open this new empty custom repository, which we just generated in the `PostRepository.phpPostRepository.php`
    file, at the `src/Blog/Entity/` location. Add the following method for retrieving
    the posts and comments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our custom repository extends the default entity repository provided by Doctrine.
    The standard methods, described earlier in the chapter, are still available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Query Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QueryBuilder` is an object designed to help build the DQL queries through
    a PHP API with a fluent interface (to find out more about fluent interfaces, see
    [Chapter 2](ch02.html "Chapter 2. Entities and Mapping Information"), *Entities
    and Mapping Information*). It allows us to retrieve the generated DQL queries
    through the `getDql()` method (useful for debugging) or directly use the `Query`
    object (provided by Doctrine).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To increase performance, `QueryBuilder` caches the generated DQL queries and
    manages an internal state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full API and states of the DQL query are documented on the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We will give an in-depth explanation of the `findWithComments()` method that
    we created in the `PostRepository` class.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, a `QueryBuilder` instance is created with the `createQueryBuilder()`
    method inherited from the base entity repository. The `QueryBuilder` instance
    takes a string as a parameter. This string will be used as an alias of the main
    entity class. By default, all the fields of the main entity class are selected
    and no other clauses except `SELECT` and `FROM` are populated.
  prefs: []
  type: TYPE_NORMAL
- en: The `leftJoin()` call creates a `JOIN` clause that retrieves comments associated
    with the posts. Its first argument is the property to join and its second is the
    alias; these will be used in the query for the joined entity class (here, the
    letter `c` will be used as an alias for the `Comment` class).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless the SQL `JOIN` clause is used, the DQL query automatically fetches the
    entities associated with the main entity. There is no need for keywords like `ON`
    or `USING`. Doctrine automatically knows whether a join table or a foreign-key
    column must be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `addSelect()` call appends comment data to the `SELECT` clause. The alias
    of the entity class is used to retrieve all the fields (this is similar to the
    `*` operator in SQL). As in the first DQL query of this chapter, specific fields
    can be retrieved with the notation `alias.propertyName`.
  prefs: []
  type: TYPE_NORMAL
- en: You guessed it, the call to the `where()` method sets the `WHERE` part of the
    query.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Doctrine uses prepared SQL statements. They are more efficient
    than the standard SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` parameter will be populated by the value set by the call to `setParameter()`.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks again to prepared statements and this `setParameter()` method, SQL Injection
    attacks are automatically avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQL Injection Attacks are a way to execute malicious SQL queries using user
    inputs that have not escaped. Let''s take the following example of a bad DQL query
    to check if a user has a specific role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This DQL query will be translated into SQL by Doctrine. If someone types the
    following username:'
  prefs: []
  type: TYPE_NORMAL
- en: '`" OR "a"="a`'
  prefs: []
  type: TYPE_NORMAL
- en: the SQL code contained in the string will be injected and the query will always
    return some results. The attacker has now gained access to a private area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proper way should be to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to prepared statements, special characters (like quotes) contained in
    the username are not dangerous, and this snippet will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The `orderBy()` call generates an `ORDER BY` clause that orders results as per
    the publication date of the comments, older first.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most SQL instructions also have an object-oriented equivalent in DQL. The most
    common join types can be made using DQL; they generally have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: The `getQuery()` call tells the Query Builder to generate the DQL query (if
    needed, it will get the query from its cache if possible), to instantiate a Doctrine
    `Query` object, and to populate it with the generated DQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generated DQL query will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Query` object exposes another useful method for the purpose of debugging:
    `getSql()`. As its name implies, `getSql()` returns the SQL query corresponding
    to the DQL query, which Doctrine will run on DBMS. For our DQL query, the underlying
    SQL query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `getOneOrNullResult()` method executes it, retrieves the first result, and
    returns it as a `Post` entity instance (this method returns `null` if no result
    is found).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the `QueryBuilder` object, the `Query` object manages an internal state
    to generate the underlying SQL query only when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Performance is something to be very careful about while using Doctrine. When
    set in production mode (see [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Doctrine 2"), *Getting Started with Doctrine 2*), ORM is able to cache the
    generated queries (DQL through the `QueryBuilder` objects, SQL through the `Query`
    objects) and results of the queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM must be configured to use one of the blazing, fast, supported systems (APC,
    Memcache, XCache, or Redis) as shown on the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/en/latest/reference/caching.html](http://docs.doctrine-project.org/en/latest/reference/caching.html)'
  prefs: []
  type: TYPE_NORMAL
- en: We still need to update the view layer to take care of our new `findWithComments()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `view-post.php` file at the `web/`location, where you will find the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding line of code with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Filtering by tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To discover a more advanced use of the QueryBuilder and DQL, we will create
    a list of posts having one or more tags.
  prefs: []
  type: TYPE_NORMAL
- en: Tag filtering is good for Search Engine Optimization and allows the readers
    to easily find the content they are interested in. We will build a system that
    is able to list posts that have several tags in common; for example, all the posts
    tagged with Doctrine and Symfony.
  prefs: []
  type: TYPE_NORMAL
- en: 'To filter our posts using tags kindly perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another method to our custom `PostRepository` class (`src/Blog/Entity/PostRepository.php`)
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method is a bit more complex. It takes in a parameter as an array of tag
    names and returns an array of posts that has all these tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The query deserves some explanation, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The main entity class (automatically set by the inherited `createQueryBuilder()`
    method) is `Post` and its alias is the letter `p`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We join the associated tags through a `JOIN` clause; the `Tag` class is aliased
    by `t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to `where()` being called, we retrieve only the posts tagged by one of
    the tags passed in the parameter. We use an awesome feature of Doctrine that allows
    us to directly use an array as a query parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Results of `where()` are grouped by `id` with the call to `groupBy()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the aggregate function `COUNT()` in the `HAVING` clause to filter the
    posts that are tagged by some tags of the `$tagNames` array, but not all of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `index.php` file in `web/` to use our new method. Here, you will find
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace the preceding code with the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, when a `GET` parameter called `tags` exists in the URL, it is used to filter
    posts. Better, if several comma-separated tags are passed in, only posts with
    all these tags will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Type `http://localhost:8000/index.php?tags=tag4,tag5` in your favorite browser.
    Thanks to the fixtures we have created in the previous chapter, posts 5 and 10
    should be listed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the same file, find the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the list of tags as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A smart list of tags with links to the tag page is displayed. You can copy
    this code and then paste it in the `view-post.php` file in the `web/` location;
    or better, *don''t repeat yourself*: create a small helper function to display
    the tags.'
  prefs: []
  type: TYPE_NORMAL
- en: Counting comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still need to make some cosmetic changes. Posts with a lot of comments interest
    many readers. It would be better if the number of comments for each post was available
    directly from the list page. Doctrine can populate an array containing the result
    of the call to an `aggregate` function as the first row and hydrated entities
    as the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method, for retrieving posts with the associated comments,
    to the `PostRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the `GROUP BY` clause and the call to `addSelect()`, this method
    will return a two-dimensional array instead of an array of the `Post` entities.
    Arrays in the returned array contain two values, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our `Post` entity at the first index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of the `COUNT()` function of DQL (the number of comments) at the
    second index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `index.php` file at the `web/` location, find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace the preceding code with the following code to use our new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To match the new structure returned by `findWithCommentCount()`, find the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace the preceding code with the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As seen previously, the use of a custom hydrator is a better practice while
    handling such cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also take a look at Custom AST Walker as shown on the following
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.doctrine-project.org/en/latest/cookbook/dql-custom-walkers.html](http://docs.doctrine-project.org/en/latest/cookbook/dql-custom-walkers.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace the preceding code with the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to display the number of comments. Insert the following code after
    the tag list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `index.php` file at the `web/` location also uses the `findHavingTags()`
    method to display the list of tagged articles, we need to update this method too.
    This is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about DQL, its differences from SQL, and its
    Query Builder. We also learned about the concept of entity repositories and how
    to create custom ones.
  prefs: []
  type: TYPE_NORMAL
- en: Even if there is a lot more to learn from these topics and from Doctrine in
    general, our knowledge should be sufficient to start developing complete and complex
    applications using Doctrine as a persistent system.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Going Further"), *Going Further*, the last
    chapter of this book, we will go a step further and cover some more advanced topics,
    including how to handle inheritance, how to make native SQL queries, and the basics
    of the event system.
  prefs: []
  type: TYPE_NORMAL
