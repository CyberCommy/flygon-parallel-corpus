- en: Modular Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using jdeps to find dependencies in a Java application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple modular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a modular JAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a module JAR with pre-Project Jigsaw JDK applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottom-up migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-down migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using services to create loose coupling between the consumer and provider modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom modular runtime image using jlink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling for older platform versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multi-release JARs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Maven to develop a modular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your library module-path-friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to open a module for reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modular programming enables one to organize code into independent, cohesive
    modules, which can be combined to achieve the desired functionality. This allows
    us to create code that is:'
  prefs: []
  type: TYPE_NORMAL
- en: More cohesive, because the modules are built with a specific purpose, so the
    code that resides there tends to cater to that specific purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulated, because modules can interact with only those APIs that have been
    made available by the other modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliable, because the discoverability is based on the modules and not on the
    individual types. This means that if a module is not present, the dependent module
    cannot be executed until it is discoverable by the dependent module. This helps
    to prevent runtime errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled. If you use service interfaces, the module interface and the
    service interface implementation can be loosely coupled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the thought process in designing and organizing the code will now involve
    identifying the modules, code, and configuration files that go into the module
    and the packages in which the code is organized within the module. After that,
    we have to decide upon the public APIs of the module, thereby making them available
    for use by dependent modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming to the development of the **Java Platform Module System**, it is being
    governed by **J****ava Specification Request** (**JSR**) 376 ([https://www.jcp.org/en/jsr/detail?id=376](https://www.jcp.org/en/jsr/detail?id=376)).
    The JSR mentions that a module system should address the following fundamental
    issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliable configuration**: Provide an alternative to the classpath for declaring
    dependency between components such that developers can prevent their applications
    from throwing surprises on runtime due to missing dependencies in the classpath.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong encapsulation**: Provide more strict access-control such that something
    private to a component is private in true sense i.e not accessible even via Reflection
    and allow the developer to selectively expose parts in the component for use by
    other components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JSR lists the advantages that result from addressing the preceding issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A scalable platform**: The specification in JSR 376 will allow leveraging
    the different profiles introduced in JSR 337 in the right way by allowing the
    creation of profiles using different components/modules created in the new platform.
    This modular platform will also allow other developers to package different components
    of the Java Platform to create custom runtime thereby giving them an option to
    create runtime just enough for their use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Greater platform integrity**: The strong encapsulation will prevent the purposeful
    or accidental use of the Java internal APIs thereby giving greater platform integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved performance**: With the clear dependency between components, it
    now becomes much easier to optimize the individual components based on the components
    they interact within in the Java SE platform and outside of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will look at a few important recipes that will help you
    get started with modular programming.
  prefs: []
  type: TYPE_NORMAL
- en: Using jdeps to find dependencies in a Java application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in modularizing your application is to identify its dependencies.
    A static analysis tool called `jdeps` was introduced in JDK 8 to enable developers
    to find the dependencies of their applications. There are multiple options supported
    in the command, which enables developers to check for dependencies in the JDK
    internal APIs, show the dependencies at the package level, show the dependencies
    at the class level, and filter the dependencies, among other options.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at how to make use of the `jdeps` tool by exploring
    its functionality and using the multiple command-line options it supports.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a sample application that we can run against the `jdeps` command to
    find its dependencies. So, we thought of creating a very simple application that
    uses the Jackson API to consume JSON from the REST API: [http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users).'
  prefs: []
  type: TYPE_NORMAL
- en: In the sample code, we also added a call to the deprecated JDK internal API,
    called `sun.reflect.Reflection.getCallerClass()`. This way, we can see how `jdeps`
    helps in finding dependencies for the JDK internal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to set up the prerequisites for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: You can get the complete code for the sample from `Chapter03/1_json-jackson-sample`.
    We have built this code against Java 9 and also using Java 8, and it compiles
    well. So, you only need to install Java 9 to compile it. If you try to compile
    with JDK 11, you will face an error due to the deprecated internal API, which
    is no longer available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have the code, compile it by using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: If your `javac` is pointing to JDK 11, you can declare environment variables
    such as `JAVA8_HOME` or `JAVA9_HOME`  that are pointing to your JDK 8 and JDK9
    installations, respectively. This way, you can compile using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You will see a warning for the use of an internal API, which you can safely
    ignore. We added this with a purpose to demonstrate the capability of `jdeps`.
    Now, you should have your compiled class files in the classes directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an executable JAR and run the sample program by running the
    JAR using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have provided the `run.bat` and `run.sh` scripts in `Chapter03/1_json-jackson-sample`.
    You can compile and run using these scripts as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `sample.jar` file gets created in the current directory if you have used `run.bat`
    or `run.sh` or the preceding commands to create JAR. If the JAR hasn't been created,
    you can use the `build-jar.bat` or `build.-jar.sh` script to compile and build
    the JAR.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a sample non-modular application that we will analyze using `jdeps`
    to find its dependencies, and also the names of the modules it possibly depends
    on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to use `jdeps` is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3c8f969-df9f-43a6-826c-ace8f1ea5606.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding command, we use `jdeps` to list the dependencies for the class
    file, `Sample.class`, at the package level. We have to provide `jdeps` with the
    path to search for the dependencies of the code being analyzed. This can be done
    by setting the `-classpath`, `-cp`, or `--class-path` option of the `jdeps` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `-verbose:package` option lists the dependencies at the package level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list the dependencies at the class level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a210b16-f42b-4e6f-b5af-7ed6d664521f.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we make use of the `-verbose:class` option to list the dependencies
    at the class level, which is why you can see that the `com.packt.Sample` class
    depends on `com.packt.model.Company`, `java.lang.Exception`, `com.fasterxml.jackson.core.type.TypeReference`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get the summary of the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebc43ab3-e07e-4853-bc4f-a86864ee9961.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check for the dependency on the JDK internal API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f7a9c3e-554a-46d7-b7fd-6920ddf9b0ae.png)'
  prefs: []
  type: TYPE_IMG
- en: The StackWalker API is the new API for traversing the call stack, which was
    introduced in Java 9\. This is the replacement for the `sun.reflect.Reflection.getCallerClass()`
    method. We will discuss this API in [Chapter 11](d8d77bf4-a30b-4474-95ca-0a166aef48c0.xhtml), *Memory
    Management and Debugging*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `jdeps` on the JAR file, `sample.jar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f30a59fd-1ed6-4b4c-8ea2-e4c3bf8fc189.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding information obtained after investigating the `sample.jar` using
    `jdeps` is quite useful. It clearly states the dependencies of our JAR files and
    is very useful when we try to migrate this application to a modular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find whether there are any dependencies on a given package name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/593012f7-f4cf-4d5c-b331-485c571a9205.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `-p` option is used to find dependencies on the given package name. So,
    we get to know that our code depends on the `java.util` package. Let''s try this
    with another package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is no output, which means that our code doesn't depend on the `java.util.concurrent`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would want to run the dependency check only for our code. Yes, this is possible.
    Suppose we run `jdeps -cp lib/* sample.jar`; you will see even the library JARs
    being analyzed. We wouldn''t want that, right? Let''s just include the classes
    of the `com.packt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfb4eb40-2b7b-4516-939f-6ba305d424e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check whether our code is dependent on a specific package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c77a08a3-044a-4c1d-ae1d-636d2331977d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use `jdeps` to analyze the JDK modules. Let''s pick the `java.httpclient`
    module for analysis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09e20526-032c-4210-952a-8c9283d429ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also find out whether a given module is dependent on another module
    by using the `--require` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82ffa439-4881-4ad7-b4a8-9e169b4ed907.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding command, we tried to find out whether the `java.sql` module
    is dependent on the `java.logging` module. The output we get is the dependency
    summary of the `java.sql` module and the packages in the `java.sql` module, which
    make use of the code from the `java.logging` module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `jdeps` command is a static-class dependency analyzer and is used to analyze
    the static dependencies of the application and its libraries. The `jdeps` command, by
    default, shows the package-level dependencies of the input files, which can be
    `.class` files, a directory, or a JAR file. This is configurable and can be changed
    to show class-level dependencies. There are multiple options available to filter
    out the dependencies and to specify the class files to be analyzed. We have seen
    a regular use of the `-cp` command-line option. This option is used to provide
    the locations to search for the analyzed code's dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have analyzed the class file, JAR files, and the JDK modules, and we also
    tried out different options of the `jdeps` command. There are a few options, such
    as `-e`, `-regex`, `--regex`, `-f`, `--filter`, and `-include`, which accept a
    regular expression (regex). It''s important to understand the output of the `jdeps`
    command. There are two parts of information for every class/JAR file being analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The summary of the dependency for the analyzed file (JAR or class file). This
    consists of the name of the class or the JAR file on the left and the name of
    the dependent entity on the right. The dependent entity can be a directory, a
    JAR file, or a JDK module, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A more verbose dependency information of the contents of the analyzed file
    at the package or class level (depending on the command-line options). This consists
    of three columns—column 1 contains the name of the package/class, column 2 contains
    the name of the dependent package, and column 3 contains the name of the module/JAR
    where the dependency is found. A sample output looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen quite a few options of the `jdeps` command. There are a few more
    related to filtering the dependencies and filtering the classes to be analyzed.
    Apart from that, there are a few options that deal with module paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the options that can be tried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e`, `-regex`, `--regex`: These find dependencies matching the given pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`, `-filter`: These exclude dependencies matching the given pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-filter:none`: This allows no filtering that''s applied via `filter:package`
    or `filter:archive`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-filter:package`: This excludes dependencies within the same package. This
    is the default option. For example, if we added `-filter:none` to `jdeps sample.jar`,
    it would print the dependency of the package to itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-filter:archive`: This excludes dependencies within the same archive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-filter:module`: This excludes dependencies in the same module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P`, `-profile`: This is used to show the profile of the package, whether
    it is in compact1, compact2, compact3, or full JRE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-R`, `-recursive`: These recursively traverse all the runtime dependencies;
    they are equivalent to the `-filter:none` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple modular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should be wondering what this modularity is all about, and how to create
    a modular application in Java. In this recipe, we will try to clear up the confusion
    around creating modular applications in Java by walking you through a simple example.
    Our goal is to show you how to create a modular application; hence, we picked
    a simple example so as to focus on our goal.
  prefs: []
  type: TYPE_NORMAL
- en: Our example is a simple advanced calculator, which checks whether a number is
    prime, calculates the sum of prime numbers, checks whether a number is even, and
    calculates the sum of even and odd numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will divide our application into two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: The `math.util` module, which contains the APIs for performing the mathematical
    calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `calculator` module, which launches an advanced calculator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement the APIs in the `com.packt.math.MathUtil` class, starting
    with the `isPrime(Integer number)` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `sumOfFirstNPrimes(Integer count)` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a function to check whether the number is even:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The negation of `isEven` tells us whether the number is odd. We can have functions
    to find the sum of the first *N* even numbers and the first *N* odd numbers, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the preceding APIs that the following operations are repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: An infinite sequence of numbers starting from `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the numbers based on some condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the stream of numbers to a given count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the sum of numbers thus obtained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on our observation, we can refactor the preceding APIs and extract these
    operations into a method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `count` is the limit of numbers we need to find the sum of, and `filter`
    is the condition for picking the numbers for summing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the APIs based on the refactoring we just did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You must be wondering about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IntStream` class and the related chaining of the methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `->` in the code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the `IntPredicate` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are indeed wondering, then you need not worry, as we will cover these
    things in [Chapter 4](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml), *Going Functional,*
    and [Chapter 5](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml), *Streams and Pipelines*.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen a few APIs around mathematical computations. These APIs
    are part of our `com.packt.math.MathUtil` class. The complete code for this class
    can be found at `Chapter03/2_simple-modular-math-util/math.util/com/packt/math`,
    in the codebase downloaded for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this small utility class part of a module named `math.util`. The
    following are some conventions we use to create a module:'
  prefs: []
  type: TYPE_NORMAL
- en: Place all the code related to the module under a directory named `math.util`
    and treat this as our module root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the root folder, insert a file named `module-info.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the packages and the code files under the root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What does `module-info.java` contain? The following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The packages it exports, that is, the one it makes available for other modules
    to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules it depends on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services it uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service for which it provides implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](4dbea9e1-3ed8-4fcc-8e46-8a12457e3434.xhtml), *Installation
    and a Sneak Peek into Java 11*, the JDK comes bundled with a lot of modules, that
    is, the existing Java SDK has been modularized! One of those modules is a module
    named `java.base`. All of the user-defined modules implicitly depend on (or require)
    the `java.base` module (think of every class implicitly extending the `Object`
    class).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `math.util` module doesn''t depend on any other module (except, of course,
    the `java.base` module). However, it makes its API available for other modules
    (if not, then this module''s existence is questionable). Let''s go ahead and put
    this statement into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are telling the Java compiler and runtime that our `math.util` module is
    *exporting* the code in the `com.packt.math` package to any module that depends
    on `math.util`.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this module can be found at `Chapter03/2_simple-modular-math-util/math.util`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create another module calculator that uses the `math.util` module.
    This module has a `Calculator` class whose work is to accept the user''s choice
    for which mathematical operation to execute and then the input required to execute
    the operation. The user can choose from five available mathematical operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Prime number check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even number check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum of *N* primes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum of *N* evens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum of *N* odds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for each of the choices, we accept the required input and invoke the
    corresponding `MathUtil` API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for the `Calculator` class can be found at `Chapter03/2_simple-modular-math-util/calculator/com/packt/calculator/Calculator.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the module definition for our `calculator` module in the same
    way we created it for the `math.util` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding module definition, we mentioned that the `calculator` module
    depends on the `math.util` module by using the `required` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this module can be found at `Chapter03/2_simple-modular-math-util/calculator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command has to be executed from `Chapter03/2_simple-modular-math-util`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you should have the compiled code from across both the modules, `math.util`
    and `calculator`, in the `mods` directory. Just a single command and everything
    including the dependency between the modules is taken care of by the compiler.
    We didn't require build tools such as `ant` to manage the compilation of modules.
  prefs: []
  type: TYPE_NORMAL
- en: The `--module-source-path` command is the new command-line option for `javac`,
    specifying the location of our module source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `--module-path` command, similar to `--classpath`, is the new command-line
    option  `java`, specifying the location of the compiled modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the preceding command, you will see the calculator in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11c0340c-401d-4a57-b8af-614a95011b6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! With this, we have a simple modular application up and running.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided scripts to test out the code on both Windows and Linux platforms.
    Please use `run.bat` for Windows and `run.sh` for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have been through the example, we will look at how to generalize
    it so that we can apply the same pattern in all our modules. We followed a particular
    convention to create the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We place the module-specific code within its folders with a corresponding `module-info.java` file
    at the root of the folder. This way, the code is organized well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into what `module-info.java` can contain. From the Java language
    specification ([http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html](http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html)),
    a module declaration is of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the syntax, explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{Annotation}`: This is any annotation of the form `@Annotation(2)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open`: This keyword is optional. An open module makes all its components accessible
    at runtime via reflection. However, at compile-time and runtime, only those components
    that are explicitly exported are accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: This is the keyword used to declare a module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModuleName`: This is the name of the module that is a valid Java identifier
    with a permissible dot (`.`) between the identifier names—similar to `math.util`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ModuleStatement}`: This is a collection of the permissible statements within
    a module definition. Let''s expand this next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A module statement is of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The module statement is decoded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`requires`: This is used to declare a dependency on a module. `{RequiresModifier}`
    can be **transitive**, **static**, or both. Transitive means that any module that
    depends on the given module also implicitly depends on the module that is required
    by the given module transitively. Static means that the module dependence is mandatory
    at compile time, but optional at runtime. Some examples are `requires math.util`,
    `requires transitive math.util`, and `requires static math.util`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exports`: This is used to make the given packages accessible to the dependent
    modules. Optionally, we can force the package''s accessibility to specific modules
    by specifying the module name, such as `exports com.package.math to claculator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opens`: This is used to open a specific package. We saw earlier that we can
    open a module by specifying the `open` keyword with the module declaration. But
    this can be less restrictive. So, to make it more restrictive, we can open a specific
    package for reflective access at runtime by using the `opens` keyword—`opens com.packt.math`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uses`: This is used to declare a dependency on a service interface that is
    accessible via `java.util.ServiceLoader`. The service interface can be in the
    current module or in any module that the current module depends on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provides`: This is used to declare a service interface and provide it with
    at least one implementation. The service interface can be declared in the current
    module or in any other dependent module. However, the service implementation must
    be provided in the same module; otherwise, a compile-time error will occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at the `uses` and `provides` clauses in more detail in the *Using
    services to create loose coupling between the consumer and provider modules* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The module source of all modules can be compiled at once using the `--module-source-path`
    command-line option. This way, all the modules will be compiled and placed in
    their corresponding directories under the directory provided by the `-d` option.
    For example, `javac -d mods --module-source-path . $(find . -name "*.java")` compiles
    the code in the current directory into a `mods` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code is equally simple. We specify the path where all our modules
    are compiled into using the command-line option `--module-path`. Then, we mention
    the module name along with the fully qualified main class name using the command-line
    option `-m`, for example, `java --module-path mods -m calculator/com.packt.calculator.Calculator`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Compiling and running a Java application* recipe in [Chapter 1](4dbea9e1-3ed8-4fcc-8e46-8a12457e3434.xhtml),
    *Installation and a Sneak Peek into Java 11*
  prefs: []
  type: TYPE_NORMAL
- en: Creating a modular JAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiling modules into a class is good, but it is not suitable for sharing binaries
    and deployment. JARs are better formats for sharing and deployment. We can package
    the compiled module into JARs, and the JARs that contain `module-info.class` at
    its top level are called **modular JARs**. In this recipe, we will look at how
    to create modular JARs, and we'll also look at how to execute the application,
    which is composed of multiple modular JARs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen and created a simple modular application in the *Creating a simpler
    modular application* recipe. In order to build a modular JAR, we will make use
    of the sample code available at `Chapter03/3_modular_jar`. This sample code contains
    two modules: `math.util` and `calculator`. We will create modular JARs for both
    the modules.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile the code and place the compiled classes in a directory, say, `mods`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Build a modular JAR for the `math.util` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget the dot (`.`) at the end of the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a modular JAR for the `calculator` module, specifying the main class
    to make the JAR executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The critical piece in the preceding command is the `--main-class` option. This
    enables us to execute the JAR without providing the main class information during
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have two JARs in the `mlib` directory: `math.util@1.0.jar` and `calculator@1.0.jar`.
    These JARs are called modular JARs. If you want to run the example, you can use
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A new command-line option for the JAR command has been introduced in Java 9,
    called `-d` , or  `--describe-module`. This prints the information about the module
    that the modular JAR contains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `jar -d` for `calculator@1.0.jar` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `jar -d` for `math.util@1.0.jar` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We have provided the following scripts to try out the recipe code on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile-math.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compile-calculator.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar-math.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar-calculator.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have provided the following scripts to try out the recipe code on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar-math.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar-calculator.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to run the scripts in the order they have been listed.
  prefs: []
  type: TYPE_NORMAL
- en: Using a module JAR with pre-Project Jigsaw JDK applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be amazing if our modular JARs could be run with pre-Project Jigsaw JDK applications.
    This way, we will not be concerned with writing another version of our API for
    pre-JDK 9 applications. The good news is that we can use our modular JARs just
    as if they were ordinary JARs, that is, JARs without `module-info.class` at their
    root. We will see how to do so in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will need a modular jar and a non-modular application.
    Our modular code can be found at `Chapter03/4_modular_jar_with_pre_java9/math.util` (this
    is the same `math.util` module that we created in our *Creating a simple modular
    application* recipe). Let''s compile this modular code and create a modular JAR
    by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also provided a `jar-math.bat` script at `Chapter03/4_modular_jar_with_pre_java9`,
    which can be used to create modular JARs on Windows. We have our modular JAR.
    Let''s verify it by using the `-d` option of the `jar` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create a simple application, which is non-modular. Our application
    will consist of one class named `NonModularCalculator`, which borrows its code
    from the `Calculator` class, in the *Creating a simple modular application* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the `NonModularCalculator` class definition in the `com.packt.calculator`
    package under the  `Chapter03/4_modular_jar_with_pre_java9/calculator` directory.
    As it is non-modular, it doesn't need a `module-info.java` file. This application
    makes use of our modular JAR `math.util.jar` to execute some mathematical calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A modular JAR named `math.util@1.0.jar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-modular application consisting of the `NonModularCalculator` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we need to compile our `NonModularCalculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the previous command, you will see a list of errors saying that
    the `com.packt.math` package doesn''t exist, the `MathUtil` symbol cannot be found, and
    so on. You''ve guessed it; we didn''t provide the location of our modular JAR
    for the compiler. Let''s add the modular `jar` location using the `--class-path`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have successfully compiled our non-modular code, which was dependent
    on the modular JAR. Let''s run the compiled code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have successfully used your modular JAR with a non-modular
    application. Amazing, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided the following scripts at `Chapter03/4_modular_jar_with_pre_java9` to
    run the code on the Windows platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile-calculator.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottom-up migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Java 9 is out of the door, the much-awaited modularity feature is
    now available to be adopted by developers. At some point or another, you will
    be involved in migrating your application to Java 9 and, hence, trying to modularize
    it. A change of such magnitude, which involves third-party libraries and rethinking
    the code structure, would require proper planning and implementation. The Java
    team has suggested two migration approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Bottom-up migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-down migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before going into learning about bottom-up migration, it's important to understand
    what an unnamed module and an automatic module are. Suppose you are accessing
    a type that's not available in any of the modules; in such a case, the module
    system will search for the type on the classpath, and if found, the type becomes
    part of an unnamed module. This is similar to the classes we write that do not
    belong to any package, but Java adds them to an unnamed package so as to simplify
    the creation of new classes.
  prefs: []
  type: TYPE_NORMAL
- en: So, an unnamed module is a catch-all module without a name that contains all
    those types that are not part of any modules, but are found in the classpath.
    An unnamed module can access all the exported types of all the named modules (user-defined
    modules) and built-in modules (Java platform modules). On the other hand, a named
    module (user-defined module) will not be able to access the types in the unnamed
    module. In other words, a named module cannot declare dependency on an unnamed
    module. If you want to declare a dependency, how would you do that? An unnamed
    module doesn't have a name!
  prefs: []
  type: TYPE_NORMAL
- en: With the concept of unnamed modules, you can take your Java 8 application as
    is and run it on Java 9 (except for any deprecated internal APIs, which might
    not be available for user code in Java 9).
  prefs: []
  type: TYPE_NORMAL
- en: You may have seen this if you have tried out the *Using jdeps to find dependencies
    in a Java application* recipe, where we had a non-modular application and were
    able to run it on Java 9\. However, running as is on Java 9 would defeat the purpose
    of introducing the modular system.
  prefs: []
  type: TYPE_NORMAL
- en: If a package is defined in both named and unnamed modules, the one in the named
    module would be given preference over the one in the unnamed module. This helps
    to prevent package conflicts when they come from both named and unnamed modules.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic modules are those that are automatically created by the JVM. These
    modules are created when we introduce the classes packaged in JARs in the module
    path instead of the classpath. The name of this module will be derived from the
    name of the JAR without the `.jar` extension and, hence, is different from unnamed
    modules. Alternatively, one can provide the name for these automatic modules by
    providing the module name against `Automatic-Module-Name` in the JAR manifest
    file. These automatic modules export all the packages present in it and also depend
    on all the automatic and named (user/JDK) modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this explanation, modules can be classified into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unnamed modules**: The code available on the classpath and not available
    on the module path is placed in an unnamed module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Named modules**: All those modules that have a name associated with them—these
    can be user-defined modules and JDK modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic modules**: All those modules that are implicitly created by JVM
    based on the JAR files present in the module path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit modules**: Modules which are implicitly created. They are the same
    as automatic modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit modules**: All modules which are created explicitly by the user
    or JDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the unnamed module and automatic module are a good first step to start your
    migration. So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a non-modular application that we will eventually modularize. We have
    already created a simple application, whose source code is available at `Chapter03/6_bottom_up_migration_before`.
    This simple application has three parts to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A math utility library that contains our favorite mathematical APIs: prime
    checker, even number checker, sum of primes, sum of evens, and sum of odds. The
    code for this is available at `Chapter03/6_bottom_up_migration_before/math_util`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A banking utility library that contains APIs to compute simple interest and
    compound interest. The code for this is available at `Chapter03/6_bottom_up_migration_before/banking_util`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our calculator app helps us with our mathematical and banking calculations.
    To make this more interesting, we will output the results in JSON and for this,
    we will make use of Jackson JSON API. The code for this is available at  `Chapter03/6_bottom_up_migration_before/calculator`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After you have copied or downloaded the code, we will compile and build the
    respective JARs. So, use the following commands to compile and build the JARs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create a JAR for this (we will make use of the JAR to build the
    dependency graph, but not for running the app):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that our Jackson JARs are in the calculator/lib, so you don''t
    need to worry about downloading them. Let''s run our calculator using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You will see a menu asking for the choice of operation, and then you can play
    around with different operations. Now, let's modularize this application!
  prefs: []
  type: TYPE_NORMAL
- en: We have provided `package-*.bat` and run.bat to the package and run the application
    on Windows. You can use `package-*.sh` and `run.sh` for the package and run the
    application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in modularizing your application is to understand its dependency
    graph. Let''s create a dependency graph for our application. For that, we make
    use of the `jdeps` tool. If you are wondering what the `jdeps` tool is, stop right
    now and read the *Using jdeps to find dependencies in a Java application* recipe.
    OK, so let''s run the `jdeps` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We are asking `jdeps` to give us a summary of the dependencies of our `calculator.jar`
    and then do this recursively for each dependency of `calculator.jar`. The output
    we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output is hard to understand and the same can be diagrammatically,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93b83846-6af9-420c-b832-333dbaa80c30.png)'
  prefs: []
  type: TYPE_IMG
- en: In bottom-up migration, we start by modularizing the leaf nodes. In our graph,
    the `java.xml`, `java.sql`, `java.base`, and `java.logging` leaf nodes are already
    modularized. Let's modularize `banking.util.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: All the code for this recipe is available at `Chapter03/6_bottom_up_migration_after`.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing banking.util.jar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copy `BankUtil.java` from `Chapter03/6_bottom_up_migration_before/banking_util/src/com/packt/banking`
    to `Chapter03/6_bottom_up_migration_after/src/banking.util/com/packt/banking`.
    There are two things to take a note of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have renamed the folder from `banking_util` to `banking.util`. This is to
    follow the convention of placing module-related code under the folder bearing
    the module name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have placed the package directly under the `banking.util` folder and not
    under `src`. Again, this is to follow the convention. We will be placing all our
    modules under the `src` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the module definition file `module-info.java` under `Chapter03/6_bottom_up_migration_after/src/banking.util` with
    the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'From within the `6_bottom_up_migration_after` folder, compile the java code
    of the modules by running the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the java code in the module `banking.util` is compiled into
    the mods directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a modular JAR for this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering what a modular JAR is, feel free to read through the *Creating
    a modular JAR*recipein this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have modularized `banking.util.jar`, let''s use this modular `jar`
    in place of the non-modular JAR used in the *Getting ready* section earlier. You
    should execute the following from the `6_bottom_up_migration_before` folder because
    we haven''t yet completely modularized the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `--add-modules` option tells the Java runtime to include the modules either
    by module name or by predefined constants, namely `ALL-MODULE-PATH`, `ALL-DEFAULT`,
    and `ALL-SYSTEM`. We made use of `ALL-MODULE-PATH` to add the module that is available
    on our module path.
  prefs: []
  type: TYPE_NORMAL
- en: The `--module-path` option tells the Java runtime the location of our modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that our calculator is running as usual. Try out a simple interest
    calculation, a compound interest calculation, to check if the `BankUtil` class
    is found. So, our dependency graph now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d708231d-d5e9-4fea-b1ab-44d956a531c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Modularizing math.util.jar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copy `MathUtil.java` from `Chapter03/6_bottom_up_migration_before/math_util/src/com/packt/math`
    to `Chapter03/6_bottom_up_migration_after/src/math.util/com/packt/math`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the module definition file, `module-info.java`, under `Chapter03/6_bottom_up_migration_after/src/math.util` with
    the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'From within the `6_bottom_up_migration_after` folder, compile the Java code
    of the modules by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the Java code in the `math.util` and `banking.util` modules
    is compiled into the `mods` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a modular JAR for this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering what a modular `jar` is, feel free to read through the *Creating
    a modular JAR* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have modularized `math.util.jar`, let''s use this modular `jar`
    in place of the non-modular `jar` that we used in the *Getting ready* section
    earlier. You should execute the following from the `6_bottom_up_migration_before`
    folder because we haven''t completely modularized the app yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app is running fine, and the dependency graph looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a82c6458-5c5b-4270-a8a5-308a39b9eb12.png)'
  prefs: []
  type: TYPE_IMG
- en: We cannot modularize `calculator.jar` because it depends on another non-modular
    code, `jackson-databind`, and we cannot modularize `jackson-databind` as it is
    not maintained by us. This means that we cannot achieve 100% modularity for our
    application. We introduced you to Unnamed modules at the beginning of this recipe.
    All our non-modular code in the classpath are grouped in unnamed modules, which
    means all jackson-related code can still remain in the unnamed module and we can
    try to modularize `calculator.jar`. But we cannot do so because `calculator.jar` cannot
    declare a dependency on `jackson-databind-2.8.4.jar` (because it is an unnamed
    module and named modules cannot declare dependency on unnamed modules).
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to get around this is to make the jackson-related code as automatic modules.
    We can do this by moving the jars related to jackson:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jackson-databind-2.8.4.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jackson-annotations-2.8.4.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jackson-core-2.8.4.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll move them under the `6_bottom_up_migration_after` folder using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The reason for renaming the jars is that the name of the module has to be a
    valid identifier (should not be only numeric, should not contain `-`, and other
    rules) separated with `.`. As the names are derived from the name of the JAR files,
    we had to rename the JAR files to conform to the Java identifier rules.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `mlib` directory, if it is not present, under `6_bottom_up_migration_after`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run our calculator program again using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will run as usual. You will notice that our `-cp` option value
    is getting smaller as all the dependent libraries have been moved as modules in
    the module path. The dependency graph now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/235a1fd5-2c09-4046-8c84-fb0abafd266b.png)'
  prefs: []
  type: TYPE_IMG
- en: Modularizing calculator.jar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step in the migration is to modularize `calculator.jar`. Follow these
    steps to modularize it:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `com` folder from `Chapter03/6_bottom_up_migration_before/calculator/src`
    to `Chapter03/6_bottom_up_migration_after/src/calculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the module definition file, `module-info.java`, under `Chapter03/6_bottom_up_migration_after/src/calculator`,
    with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'From within the `6_bottom_up_migration_after` folder, compile the Java code
    of the modules by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the Java code in all our modules is compiled into the mods
    directory. Please note that you should have the automatic modules (that is, jackson-related
    JARs) already placed in the `mlib` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a modular JAR for this module and also mention which is the `main`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a modular JAR for our calculator module, which is our main module
    as it contains the `main` class. With this, we have also modularized our complete
    application. Let''s run the following command from the folder: `6_bottom_up_migration_after`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have seen how to modularize a non-modular application using a bottom-up
    migration approach. The final dependency graph looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68490d34-cdaf-44a0-b7bd-02e6754c10bf.png)'
  prefs: []
  type: TYPE_IMG
- en: The final code for this modular application can be found at `Chapter03/6_bottom_up_migration_after`.
  prefs: []
  type: TYPE_NORMAL
- en: We could have done modification in line, that is, modularize the code in the
    same directory, `6_bottom_up_migration_before`. But we prefer to do it separately
    in a different directory, `6_bottom_up_migration_after`, so as to keep it clean
    and not disturb the existing codebase.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of unnamed modules helped us to run our non-modular application
    on Java 9\. The use of both module path and classpath helped us to run the partly
    modular application while we were doing the migration. We started with modularizing
    those codebases that were not dependent on any non-modular code, and any codebase
    that we couldn't modularize, we converted into automatic modules, thereby enabling
    us to modularize the code which was dependent on such a code base. Eventually,
    we ended up with a completely modular application.
  prefs: []
  type: TYPE_NORMAL
- en: Top-down migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other technique for migration is  top-down migration. In this approach,
    we start with the root JAR in the dependency graph of the JARs.
  prefs: []
  type: TYPE_NORMAL
- en: JARs indicate a codebase. We have assumed that the codebase is available in
    the form of JARs and hence the dependency graph that we get has nodes, which are
    JARs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modularizing the root of the dependency graph would mean that all other JARs
    on which this root depends have to be modular. Otherwise, this modular root cannot
    declare a dependency on unnamed modules. Let''s consider the example non-modular
    application we introduced in our Bottom-Up Migration recipe. The dependency graph
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90299e09-6b9c-4e5e-a65f-e6e31db6158d.png)'
  prefs: []
  type: TYPE_IMG
- en: We extensively make use of automatic modules in top-down migration. Automatic
    modules are modules that are implicitly created by the JVM. These are created
    based on the non-modular JARs available in the module path.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make use of the calculator example that we introduced in the previous
    recipe, *Bottom-up migration*. Go ahead and copy the non-modular code from `Chapter03/7_top_down_migration_before`.
    Use the following commands if you wish to run it and see whether it''s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We have provided `package-*.bat` and `run.bat` to the package and run the code
    on Windows, and used `package-*.sh` and `run.sh` on the package and run the code
    on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be modularizing the application under the `Chapter03/7_top_down_migration_after` directory.
    Create two directories, `src` and `mlib`, under `Chapter03/7_top_down_migration_after`.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing the calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cannot modularize the calculator until we have modularized all its dependencies.
    But modularizing its dependencies might be easier at times and not so at other
    times, especially in cases where the dependency is from a third party. In such
    scenarios, we make use of automatic modules. We copy the non-modular JARs under
    the folder `mlib` and ensuring that the name of the JAR is in the form `<identifier>(.<identifier>)*`, 
    where `<identifier>` is a valid Java identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We have provided the `copy-non-mod-jar.bat` and `copy-non-mod-jar.sh` scripts
    to copy the jars easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we copied into `mlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`banking.util.jar` and `math.util.jar` will exist only if you have compiled
    and JAR-ed the code in the `Chapter03/7_top_down_migration_before/banking_util`
    and `Chapter03/7_top_down_migration_before/math_util` directories. We did this
    in the *Getting ready*section earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `calculator` folder under `src`. This will contain the code for
    the `calculator` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `module-info.java` under the `Chapter03/7_top_down_migration_after/src/calculator`
    directory that contains the following**:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Copy the `Chapter03/7_top_down_migration_before/calculator/src/com` directory
    and all the code under it to `Chapter03/7_top_down_migration_after/src/calculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the calculator module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the modular JAR for the `calculator` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `calculator` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We will see that our calculator is executing correctly. You can try out different
    operations to verify if all of them are executing correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing banking.util
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As this doesn''t depend on other non-module code, we can directly convert this
    into a module by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `banking.util` folder under `src`. This will contain the code for
    the `banking.util` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `module-info.java` under the `Chapter03/7_top_down_migration_after/src/banking.util`directory**, **which
    contains the following**:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Copy the `Chapter03/7_top_down_migration_before/banking_util/src/com` directory
    and all the code under it to `Chapter03/7_top_down_migration_after/src/banking.util`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a modular JAR for the `banking.util` module. This will replace the non-modular
    `banking.util.jar` already present in `mlib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `calculator` module to test whether the `banking.util` modular JAR
    has been created successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You should see the calculator getting executed. Play around with different operations
    to ensure that there are no "class not found" issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modularizing math.util
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `math.util` folder under `src`. This will contain the code for
    the `math.util` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `module-info.java` under the `Chapter03/7_top_down_migration_after/src/math.util`directory,
    which contains the following**:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Copy the `Chapter03/7_top_down_migration_before/math_util/src/com` directory
    and all the code under it to `Chapter03/7_top_down_migration_after/src/math.util`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a modular JAR for the `banking.util` module. This will replace the non-modular
    `banking.util.jar` already present in `mlib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Run the `calculator` module to test whether the `math.util` modular JAR has
    been created successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You should see the calculator getting executed. Play around with different operations
    to ensure that there are no *class not found* issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we have completely modularized the application, baring the Jackson
    libraries which we have converted to automatic modules.
  prefs: []
  type: TYPE_NORMAL
- en: We prefer the top-down approach for migration. This is because we don't have
    to deal with classpath and module-path at the same time. We can make everything
    into automatic modules and then use the module-path as we keep migrating the non-modular
    JARs into modular JARs.
  prefs: []
  type: TYPE_NORMAL
- en: Using services to create loose coupling between the consumer and provider modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, in our applications, we have some interfaces and multiple implementations
    of those interfaces. Then, at runtime, depending on certain conditions, we make
    use of specific implementations. This principle is called **Dependency Inversion**.
    This principle is used by dependency injection frameworks, such as Spring, to
    create objects of concrete implementations and assign (or inject) into the references
    of the abstract interface type.
  prefs: []
  type: TYPE_NORMAL
- en: For a long time, Java (since Java 6) has supported service-provider loading
    facilities via the `java.util.ServiceLoader` class. Using Service Loader, you
    can have a **service provider interface** (**SPI**) and multiple implementations
    of the SPI simply called service provider. These service providers are located
    in the classpath and loaded at runtime. When these service providers are located
    within modules, and as we no longer depend on the classpath scanning to load the
    service provider, we need a mechanism to tell our modules about the service provider
    and the service provider interface for which it is providing an implementation.
    In this recipe, we will look at this mechanism by using a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is nothing specific we need to set up for this recipe. In this recipe,
    we will take a simple example. We have one `BookService` abstract class, which
    supports CRUD operations. Now, these CRUD operations can work on a SQL DB, MongoDB,
    a filesystem, and so on. This flexibility can be provided by using the service
    provider interface and the `ServiceLoader` class to load the required service
    provider implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have four modules in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`book.service`: This is the module that contains our service provider interface,
    that is, the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mongodb.book.service`: This is one of the service provider modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqldb.book.service`: This is the other service provider module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book.manage`: This is the service consumer module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how to make use of `ServiceLoader` to achieve
    loose coupling:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `book.service` folder under the `Chapter03/8_services/src` directory.
    All our code for the `book.service` module will be under this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new package, `com.packt.model`, and a new class, `Book`, under the
    new package. This is our model class, which contains the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new package, `com.packt.service`, and a new class, `BookService`,
    under the new package. This is our main service interface, and the service providers
    will provide an implementation for this service. Apart from the abstract methods
    for CRUD operations, one method worth mentioning is `getInstance()`. This method
    uses the `ServiceLoader` class to load any one service provider (the last one,
    to be specific) and then use that service provider to get an implementation of `BookService`.
    Let''s see the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The first `while` loop is just for demonstrating that the `ServiceLoader` loads
    all the service providers and we pick one of the service providers. You can conditionally
    return the service provider as well, but that all depends on the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important part is the actual service provider interface. The responsibility
    of this is to return an appropriate instance of the service implementation. In
    our recipe, `BookServiceProvider` in the `com.packt.spi` package is a service
    provider interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We create `module-info.java` under the `Chapter03/8_services/src/book.service` directory,
    which contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `uses` statement in the preceding module definition specifies the service
    interface that the module discovers using `ServiceLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create a service provider module called `mongodb.book.service`. This
    will provide an implementation for our `BookService` and `BookServiceProvider`
    interface in the `book.service` module. Our idea is that this service provider
    will implement the CRUD operations using the MongoDB datastore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `mongodb.book.service` folder under the `Chapter03/8_services/src` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `MongoDbBookService` class in the `com.packt.mongodb.service` package,
    which extends the `BookService` abstract class and provides an implementation
    of our abstract CRUD operation methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MongoDbBookServiceProvider` class in the `com.packt.mongodb` package,
    which implements the `BookServiceProvider` interface. This is our service-discovery
    class. Basically, it returns a relevant instance of the `BookService` implementation.
    It overrides the method in the `BookServiceProvider` interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The module definition is quite interesting. We have to declare in the module
    definition that this module is a service provider for the `BookServiceProvider` interface,
    and that can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `provides .. with ..` statement is used to specify the service interface
    and one of the service providers.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create a service consumer module called `book.manage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `book.manage` folder under `Chapter03/8_services/src` which will
    contain the code for the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new class called `BookManager` in the `com.packt.manage` package.
    The main aim of this class is to get an instance of `BookService` and then execute
    its CRUD operations. The instance returned is decided by the service providers
    loaded by the `ServiceLoader`. The `BookManager` class looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run our main module by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, the first line states the service providers that are
    available and the second line states which `BookService` implementation we are
    using.
  prefs: []
  type: TYPE_NORMAL
- en: 'With one service provider, it looks simple. Let''s go ahead and add another
    module, `sqldb.book.service`, whose module definition would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SqlDbBookServiceProvider` class in the `com.packt.sqldb` package is an
    implementation of the `BookServiceProvider` interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of CRUD operations is done by the `SqlDbBookService` class
    in the package `com.packt.sqldb.service` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s compile and run the main module, this time with two service providers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines print the class names of the available service providers
    and the third line prints which `BookService` implementation we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom modular runtime image using jlink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java comes in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java runtime only, also known as JRE: This supports the execution of Java applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java development kit with Java runtime, also called JDK: This supports the
    development and execution of Java applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from this, there were three compact profiles introduced in Java 8 with
    the aim of providing runtimes with a smaller footprint in order to run on embedded
    and smaller devices shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee1d7126-b787-41bf-8b20-96920bb76650.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows the different profiles and the features supported
    by them.
  prefs: []
  type: TYPE_NORMAL
- en: A new tool, called `jlink` was introduced in Java 9 that enables the creation
    of modular runtime images. These runtime images are nothing but a collection of
    a set of modules and their dependencies. There is a Java enhancement proposal,
    JEP 220, governing the structure of this runtime image.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use `jlink` to create a runtime image consisting of
    our `math.util`, `banking.util`, and `calculator` modules, along with the Jackson
    automatic modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Creating a simple modular application* recipe, we created a simple
    modular application consisting of the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`math.util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculator`: Consists of the main class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will reuse the same set of modules and code to demonstrate the use of the `jlink`
    tool. For the convenience of our readers, the code can be found at `Chapter03/9_jlink_modular_run_time_image`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s compile the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the modular JAR for all the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use `jlink` to create a runtime image consisting of the `calculator` and `math.util` modules
    and their dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The runtime image gets created at the location specified with the `--output`
    command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The runtime image created under the directory image contains the `bin` directory,
    among other directories. This `bin` directory consists of a shell script named `calculator`.
    This can be used to launch our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We cannot create a runtime image of modules that contain automatic modules.
    Jlink gives an error if the JAR files are not modular or if there is no `module-info.class`.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling for older platform versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have, at some point, used the `-source` and `-target` options to create a
    java build. The `-source` option is used to indicate the version of Java language accepted
    by the compiler, and the `-target` option is used to indicate the version supported
    by the class files. Often, we forget to use the `-source` option and by default,
    `javac` compiles against the latest available Java version. Due to this, there
    are chances of newer APIs being used and as a result, the build doesn't run as
    expected on the target version.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the confusion of providing two different command-line options, a
    new command-line option, `--release`, was introduced in Java 9\. This acts as
    a substitute to the `-source`, `-target` and `-bootclasspath` options. `-bootclasspath`
    is used to provide the location of the bootstrap class files for a given version, *N*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created a simple module, called demo, that contains a very simple class
    called `CollectionsDemo` that just puts a few values in the map and iterates over
    them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run it to see its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now let's compile this to run on Java 8 and then run it on Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the older versions of Java, Java 8 and before, don''t support modules, so
    we would have to get rid of  `module-info.java` if we were compiling on an older
    version. That is why we did not include `module-info.java` during our compilation.
    We compiled using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we are using the `--release` option, targeting Java 8 and not
    compiling `module-info.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a JAR file because it becomes easier to transport the java build
    instead of copying all the class files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the preceding JAR in Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the JAR in Java 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we did not use the `-release` option while building on Java 9? Let''s
    try that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile without using the `--release` option and create a JAR out of the resulting
    class files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the JAR on Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: It works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the JAR on Java 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: It is clearly stating that there is a mismatch in the version of the class file.
    As it was compiled for Java 9 (version 53.0), it doesn't run on Java 8 (version
    52.0).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data required for compiling to a target older version is stored in the `$JDK_ROOT/lib/ct.sym`
    file. This information is used by the `--release` option to locate `bootclasspath`. The
    `ct.sym` file is a ZIP file containing stripped-down class files corresponding
    to class files from the target platform versions (taken verbatim from [http://openjdk.java.net/jeps/247](http://openjdk.java.net/jeps/247)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating multi-release JARs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, it was hard for the developers of a library to adopt the new
    features introduced in the language without releasing a new library version. But
    in Java 9, multi-release JARs provide such a functionality where you can bundle
    certain class files to run when a higher version of Java is being used.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to create such a multi-release JAR.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the required Java code for the Java 8 platform. We will add two classes, `CollectionUtil.java`
    and `FactoryDemo.java`, in the `src8compackt` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We wish to make use of the `Collection` factory methods that were introduced
    in Java 9\. So, we will create another subdirectory under `src` to place our Java-9-related
    code: `src9compackt`. This is where we will add another `CollectionUtil` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the Java 9 collection factory methods. Compile the
    source code using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Make a note of the `--release` option that's used to compile the code for different
    java versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the multi-release JAR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: While creating the JAR, we have also mentioned that, when running on Java 9,
    we make use of the Java-9-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run `mr.jar` on Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run `mr.jar` on Java 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the layout of the content in `mr.jar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the JAR is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea10f27a-5853-477a-a589-4beba6202ae3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding layout, we have `META-INF/versions/9`, which contains the
    Java 9-specific code. Another important thing to note is the contents of the `META-INF/MANIFEST.MF`
    file. Let''s extract the JAR and view its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The new `Multi-Release` manifest attribute is used to indicate whether the JAR
    is a multi-release JAR.
  prefs: []
  type: TYPE_NORMAL
- en: Using Maven to develop a modular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at using Maven, the most popular build tool in
    the Java ecosystem, to develop a simple modular application. We will reuse the
    idea we introduced in the *Services* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the following modules in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`book.manage`: This is the main module that interacts with the data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book.service`: This is the module that contains the service-provider interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mongodb.book.service`: This is the module that provides an implementation
    to the service-provider interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqldb.book.service`: This is the module that provides another implementation
    to the service-provider interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the course of this recipe, we will create a maven project and include the
    preceding JDK modules as maven modules. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a folder to contain all the modules. We have called it `12_services_using_maven`
    with the following folder structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pom.xml` for the parent is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the structure for the `book-service` Maven module as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `pom.xml` for the `book-service` Maven module is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `module-info.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `Book.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `BookService.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `BookServiceProvider.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: On similar lines, we define the other three Maven modules, `mongodb-book-service`,
    `sqldb-book-service`, and `book-manager`. The code for this can be found at `Chapter03/12_services_using_maven`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compile the classes and build the required JAR files using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: We have provided `run-with-mongo.*` to use `mongodb-book-service` as the service-provider
    implementation and `run-with-sqldb.*` to use `sqldb-book-service` as the service-provider
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this recipe can be found at `Chapter03/12_services_using_maven`.
  prefs: []
  type: TYPE_NORMAL
- en: Making your library module-path-friendly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an application to be fully modular, it should have itself modularized as
    well as its dependents. Now, making a third party modular is not in the hands
    of the application developer. One approach is to include the third-party `jar`
    in the module path and use the name of the `jar` as the name of the module to
    declare the dependency. In such cases, the `jar` becomes an automatic module.
    This is OK, but often the name of the `jar` is not module-name-friendly or doesn't
    conform to the syntax of a valid module name. In such cases, we make use of another
    support added in JDK 9 wherein one can define the name of the `jar` in the `MANIFEST.mf`
    file of the `jar`, and the library consumer can then declare a dependency on the
    defined name. This way, in the future, the library developer can modularize their
    library while still using the same module name.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to provide a  name for the automatic module
    created from the non-modular `jar`. First, we will show you how to achieve this
    using maven and then in the *There's more...* section, we will see how to create
    a JAR without using any build tools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You would need at least JDK 9 to run this recipe, but we will be using JDK 11
    in the Maven build plugin. You will also need to install Maven to be able to use
    it. You can search on the internet to find the installation procedure for Maven.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generate an empty project using Maven:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the dependencies in the `pom.xml` file located in the `13_automatic_module` directory
    by copying the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to configure `maven-compiler-plugin` to be able to compile for JDK
    11\. So, we will add the following plugin configuration right after `<dependencies></dependencies>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure `maven-jar-plugin` to provide the automatic module name by providing
    the name in the  new `<Automatic-Module-Name>` tag, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add an API to calculate simple interest in the `com.packt.banking.Banking`
    class, which is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We also added a test, which you can find at `Chapter03\13_automatic_module\src\test\java\com\packt\banking`
    in the code downloaded for this chapter. Let''s run the `mvn package` command
    to build a JAR. If everything goes fine, you will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/20cf9b91-b447-44bd-be79-2ae8dc64ce9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use any compression utility, such as 7z, to view the contents of the
    JAR, especially the `Manifest.MF` file, whose contents are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The code for these steps can be found at `Chapter03\13_automatic_module`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created a Java library JAR with an automatic module name. Now,
    let's see how to use this non-modular JAR as an automatic module in a modular
    application. The complete code for this can be found at `Chapter03\13_using_automatic_module`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's copy the `jar` file created in the How to do it... section, which you
    can find in `13_automatic_module\target\13_automatic_module-1.0.jar`, into the `13_using_automatic_module\mods` folder.
    This enables our upcoming modular application to make use of the `com.packt.banking`
    module that was shipped with the `jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After copying the jar, we need to create a module definition for our module
    and declare its dependencies in `module-info.java`, placed in `13_using_automatic_module\src\banking.demo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to create the main `com.packt.demo.BankingDemo` class, which will make
    use of the banking utilities. This will be created in the `13_using_automatic_module\src\banking.demo\com\packt\demo` path,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compile the preceding code using the following command, executed from `13_using_automatic_module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run the preceding code using the following command, executed from
    the same location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: You can make use of the `run.bat` or `run.sh` scripts to compile and
    run the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with this, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a non-modular JAR with an automatic module name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used the non-modular JAR as an automatic module by declaring a dependency on
    it by using its automatic module name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also see that we have totally removed the use of classpath, instead
    of using only the module path; this is our first step toward a completely modular
    application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will show you how to create a JAR of your banking utility, along with the
    automatic module name if you don't use Maven. The code for this can be found at `Chapter03\13_automatic_module_no_maven`.
    We will still have the same `Banking .java` copied into the `13_automatic_module_no_maven\src\com\packt\banking` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define a `manifest.mf` manifest file that will contain the
    following automatic module name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compile the preceding class by issuing the following command from `Chapter03\13_automatic_module_no_maven`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'And then build a `jar` by issuing the following command from the same location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: We have also provided scripts for creating your `jar`. You can use `build-jar.bat`
    or `build-jar.sh` to compile and create a `jar`. Now, you can copy `banking-1.0.jar`
    to `Chapter03\13_using_automatic_module\mods` and replace `13_automati_module-1.0.jar`.
    Then, run the code in `Chapter03\13_using_automatic_module` using the `run.bat`
    or `run.sh` scripts, depending on your platform. You will still see the same output
    as in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: How to open a module for reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module system introduces strict encapsulation of classes within its module
    and a strictness level that, if the class isn't explicitly allowed for reflection,
    then its private members cannot be accessed via reflection. Most of the libraries,
    such as hibernate and Jackson, rely on reflection to achieve their purpose. A
    strict encapsulation offered by the module system would break these libraries
    on the new JDK 9 and later right away.
  prefs: []
  type: TYPE_NORMAL
- en: In order to support such important libraries, the Java team decided to introduce
    features wherein the module developer can declare a few packages or complete packages
    that are open for inspection by reflection. In this recipe, we will look at how
    exactly to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need JDK 9 or later installed. We will be using the Jackson API in this
    recipe, and its `jar` files can be found at `Chapter03/14_open_module_for_rflxn/mods`
    of the code download for this book. These `jar` files are important as we will
    create a JSON string from a Java object using the Jackson API. These Jackson APIs
    will be used as automatic modules.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `Person` class in `14_open_module_for_rflxn/src/demo/com/packt/demo`
    with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `OpenModuleDemo` class that creates an instance of the `Person` class
    and uses `com.fasterxml.jackson.databind.ObjectMapper` to serialize it into JSON.
    The serialization of the new date-time APIs requires some configuration changes
    to the `ObjectMapper` instance, which has also been done in the static initialization
    block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `module-info.java` in `14_open_module_for_rflxn/src/demo`, which declares
    the name of the module, its dependencies, and another interesting thing called
    `opens`. `opens` is the solution to allow reflection from external libraries,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways of opening up a module for inspection by reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring open on the module level:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring opens on the individual package level:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The latter is more restrictive (that is, making only a package available for
    reflection) than the former. There is another way to achieve this, and that is
    by exporting the specific package to the right Jackson package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
