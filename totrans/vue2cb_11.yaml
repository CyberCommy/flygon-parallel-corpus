- en: Integrating with Other Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building universal applications with Electron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vue with Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a real-time app with Feathers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a reactive app with Horizon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue is powerful, but if you need a backend, it can't do much alone; at a minimum
    you will need a server to deploy your software. In this section, you will actually
    build small, but complete and working, applications with popular frameworks. Electron
    is used to bring Vue apps to the desktop. Firebase is a modern cloud backend and,
    finally, FeatherJS is a minimalistic but full-featured JavaScript backend. When
    you are finished with these, you will have all the tools required to interact
    with them and quickly build professional applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building universal applications with Electron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Electron is a framework for creating universal applications that run on Mac,
    Linux, and Windows. At it's core is a stripped down version of a web browser.
    It has been used to create widely used applications such as Slack and Visual Studio
    Code, among others. In this recipe, you'll build a simple app with Electron.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build this app, we will use only basic Vue functionalities. Electron is out
    of scope for this book, but for this recipe no knowledge of Electron is required;
    in fact, this is a good starting point to learn more about Electron.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will build a small but complete app--a pomodoro application.
    A pomodoro is an interval of about 25 units of time, in which you should concentrate
    on doing work. It's called this because you usually use a tomato-shaped kitchen
    timer to measure that. This app will track the time instead, so you don't have
    to buy an expensive kitchen timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to spin up a Vue project with Electron is to use the Electron-Vue
    boilerplate (you don''t say!). This can be easily achieved with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can answer with the default values, but when asked which plugin to install,
    just select `vue-electron` . Install all the dependencies with `npm intall` and,
    if you like, you can keep the application open with hot-reloading while you make
    the necessary modifications with `npm run dev` . You can hide the dev tools by
    just clicking on the *x* in the corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00178.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First of all, we want our app to be small-ish. Let''s go to the `app/src/main/index.js`
    file; this file controls the life cycle of our application. Change the window
    size to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we don''t really want the boilerplate components in the `app/src/render/components`
     folder, so you can delete everything. Instead, create a `Pomodoro.vue` file and
    put this template inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it work, we also have to write the JavaScript part, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This way, clicking on the start button in the program will subtract 1 second
    every second. Clicking on the stop button will clear the timer and reset the remaining
    time to 1500 seconds (25 minutes). The timer object is basically the result of
    the `setInterval` operation, and `clearInterval` just stops whatever the timer
    was doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our template, we want a `formattedTime`  method in the sense that we''d
    like to see the time in `mm:ss` format, which is much more human-readable than
    just the number of remaining seconds (even if that''s more geeky), so we need
    to add the computed function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To add this component to the app, go to the `App.vue` file and edit the following
    lines, replacing the `landingPage`  placeholder element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Launching the app with `npm run dev` , you should now be able to track the
    time while working or studying:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00179.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can even build a distributable version of the application with the `npm
    run build`  command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way we implemented the timer is not particularly accurate for time tracking.
    Let''s review the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This means that we decrease the remaining time every second. The problem is
    that the `setInterval` function itself is not 100% accurate and may fire the function
    a bit before or after 1000 milliseconds, depending on the machine's computational
    load; this way, the margin of error can accumulate and become a considerable amount.
    A better approach would be to check the clock every time the function gets called
    and adjust for the error at each loop, though we won't cover that here.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vue with Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Vue with Firebase as a backend is very easy, thanks to VueFire--a plugin
    that contains bindings for Firebase. In this recipe, you will develop a fully
    functional database of smells.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is out of the scope of this book, but I will assume, for this recipe,
    that you have a familiarity with the basic concepts. Except for this, there is
    really not much you need to know, as we will build a very basic Vue application
    on top of that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting to write code, we need to create a new Firebase application.
    To do this, you have to log in at [https://firebase.google.com/](https://firebase.google.com/)
    and create a new application. In our case, it will be called `smell-diary` . You
    will also need to take note of your API key, which is found in the project settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00180.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you will need to disable authentication; go to the Database section and,
    in the Rules tab, set both read and write to true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are finished with the Firebase configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a clean HTML5 boilerplate or JSFiddle, with `Vue` as a library. We will
    need the following dependencies expressed as script tags inside the head of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'VueFire will automatically detect Vue (so the order is important) and install
    itself as a plugin. We will build a very simple database to keep track of the
    odor of things that surround us. The following is the HTML layout of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the JavaScript part of our app, we need to specify the API key to authenticate
    with Firebase, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we feed the configuration to Firebase and get a hold of the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be done outside the `Vue` instance. The VueFire plugin installs a
    new option in the `Vue` instance, named `firebase` ; we have to specify that we
    want to access the `/items` in the Firebase app with the `item` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newItem` and `newSmell` variables will temporarily hold the values we
    entered in the input boxes; then, the `addItem` and `removeItem` methods will
    publish and remove data from our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you launch your app now, you''ll already be able to add your favorite scents
    and what to sniff to find them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00181.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firebase works as a simple key value store. In our case, we are never storing
    values but always adding children; you can take a look at what you''ve created
    in the Firebase console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00182.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The keys are created automatically and they contain empty values and 32 levels
    of nested data. We are using one level of nesting to insert the name and the smell
    for each object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a real-time app with Feathers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern applications are real time, not in the traditional sense, but in
    the sense that they don't need the page to reload for them to be updated. The
    most common way to implement this is through WebSockets. In this recipe, we will
    leverage Feathers and Socket.io to build a cat database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no prerequisite for this recipe, but you can complete the *Createing
    a REST client (and server!)*  recipe before starting this one if you want to have
    more context.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this recipe, you''ll need the Feathers'' command line; install
    it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run `feathers generate` , which will create all the boilerplate for you.
    When asked about the API, select Socket.io :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00183.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All the other questions can be left to the default value. While still in the
    Feather console, type `generate service`  to create a new service. You can call
    it cats and leave the other questions to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `public` folder, open `index.html` and delete everything except
    a HTML5 boilerplate. You will need three dependencies in the head:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the HTML layout, as follows, in the `body` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first `<div>`  tag is a gallery of cats. Then, build a form to add new images
    of the cats you collect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `body` tag, you can always configure the Feathers service with the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is for configuring the client for the browser that will connect to the
    WebSockets. The `catService`  method is a handle to the cat database. Next, we
    write the `Vue` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to ask for all the cats in the database on startup, while
    installing a listener in case new cats are created (even by other users):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run your application with `npm start` , you can navigate to the URL
    written in the console to view your new app. Open another browser window and see
    how it changes in real-time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00184.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seeing the cats added in real time is clearly the way to go for modern applications. Feathers
    lets you create them in a snap and with a fraction of the code, thanks to the
    underlying Socket.io, which in turn uses WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets are really not that complex and what Feathers does in this case is
    just listen for messages in the channel and associate them with actions like adding
    something to the database.
  prefs: []
  type: TYPE_NORMAL
- en: The power of Feathers is visible when you can just swap database and WebSocket
    provider, or switch to REST, without even touching your Vue code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reactive app with Horizon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Horizon is a platform to build reactive, real-time scalable apps. It uses RethinkDB
    internally and is immediately compatible with Vue. In this recipe, you'll build
    an automatic personal diary.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe just requires a bit of Vue fundamentals, but really not much else.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting though, ensure that you install RethinkDB. You can find more
    info on this on their website ([https://www.rethinkdb.com/docs/install/](https://www.rethinkdb.com/docs/install/)
    ). If you have Homebrew, you can install it with `brew install rethinkdb` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you will need a Clarifai token. To get one for free, go to [https://developer.clarifai.com/](https://developer.clarifai.com/)
    and sign up. You''ll be presented with the code you are supposed to write in your
    application, like in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00185.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In particular, you will need the `clientId` and the `clientSecret` , which
    are displayed in this fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Take note of this code or be ready to copy and paste it in to your application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a journal is a difficult task, you have to write a lot every day. In
    this recipe, we'll build an automatic journal that will write for us, based on
    pictures we take during the day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Horizon will help us to memorize everything and to sync the diary between our
    devices. After installing RethinkDB, install Horizon with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll have the new command, `hz` , available. Check it by typing `hz
    -h` ; you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00186.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create the directory that will host our new app, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then, enter the newly create `vue_app` directory and take a look at the `index.html`
    in the `dist` folder. This is the file that will be the entry point to our server,
    open it with an editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can clear everything and leave only an empty HTML5 boilerplate with an
    empty `<head>` and `<body>` . In the head section, we need to declare dependencies
    on Vue, Horizon, and Clarifai, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just note how Horizon doesn't come from a CDN but from a local dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by laying out a template for our journal. We have two parts. In the
    first, we will list what we did in the past. Write the following in the body of
    the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second part, we will enter new entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After this, open a `<script>` tag in which we'll write all of the following JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to log in to Clarifai:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you want to enter your `clientId` and `clientSecret` from Clarifai.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to spin up Horizon and have a handle to the `entries`  collection
    that we will create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we finally write our `Vue` instance with three state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `tentativeEntries` array will contain a list of possible entries for the
    diary we can choose from; `data_uri` will contain the (`base64` code of the) image
    we want to use as a reference for what we did today;  `entries` are all the past
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we load an image, we ask Clarifai to come up with possible entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then when we press the send button, we tell the Horizon collection of entries
    to store this new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to ensure that we have the last ten entries on the screen
    when the page loads and that every time a new entry is added, it pops up in real
    time. Add the following hook inside the Vue instance, after the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the Horizon server, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00187.jpg)Go to the specified address (the first line, not the
    admin interface), and you will see the following:![](img/Image00188.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will note that if you have other browser windows open, they will be updated
    in real time. Now you can finally write a journal every day without typing!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application uses a pattern called reactive. Its core can be clearly seen
    in the handle created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first line returns what is called an observable in reactive. An observable
    can be thought of as a source of events. Every time an event is fired, the subscriber
    to that source will process it. In our case, we are taking the whole entries collection
    and the events thrown are modifications to that collection. Every time we receive
    an event of this type, we update the `entries` array.
  prefs: []
  type: TYPE_NORMAL
- en: I will not provide a deep explanation of reactive programming here, but I would
    like to highlight that this pattern is very helpful for scalability because of
    the ease with which you can implement controls for your data flow; `limit(10)`
    is an example this.
  prefs: []
  type: TYPE_NORMAL
