- en: Chapter 8. The Snake Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get straight down to designing and implementing a clone
    of the highly addictive *Snake* game. We will look at the design of the game and
    learn how to animate some bitmaps. Then we will look at a few aspects of the code
    that are new, such as our coordinate system. After that, we will whiz through
    the implementation of the game. Finally, we will look at how we could enhance
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the design of our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the coordinate system of our *Snake* game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the code structure so that when we come to implement the game, it will
    be more straightforward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about animation with sprite sheets at the same time as implementing the
    home screen of our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break the code for the *Snake* game into manageable chunks and run through its
    full implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhance the game a little
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you haven''t played the excellent *Snake* game before, here is an explanation
    of how it works. You control a very small snake. In our version, there is just
    a head, one body segment, and a tail. Here is a screenshot of our snake, made
    out of three segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the three segments individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, here is the thing; our snake is very hungry and also a very quick grower.
    Every time he eats an apple, he grows a body segment. This is a screenshot of
    the apple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Life is great! Our snake just eats and grows! The problem that the player of
    our game needs to solve is that the snake is a little hyperactive. It never stops
    moving! What exacerbates this problem is that if the snake touches the side of
    the screen, it dies.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, this doesn''t seem like too much of a problem, but as he grows longer
    and longer, he can''t just keep going around in circles because he will bump inevitably
    into himself. This would again result in his demise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For each apple eaten, we add an increasingly large amount to the score. Here
    is a sneak peek at what the game will look like after the basic implementation
    and before the enhancements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game design](img/8859OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The player controls the snake by tapping on the left or the right side of the
    screen. The snake will respond by turning left or right. The turn directions are
    relative to the direction the snake is traveling, which adds to the challenge
    because the player needs to think like a snake—kind of!
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we will also take a brief look at enhancing the game,
    use that enhanced version in the next chapter to publish it to the Google Play
    Store, and add leaderboards and achievements.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we drew all our game objects directly to points on
    the screen, and we used real screen coordinates to detect collisions, bounces,
    and so on. This time, we will be doing things slightly differently. This is partly
    out of necessity, but as we will see, collision detection and keeping track of
    our game objects will also get simpler. This might be surprising when we think
    about the potential of our snake to be many blocks long.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of the snake segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep track of all the snake segments, we will first define a block size
    to define a portion of a grid for the entire game area. Every game object will
    reside at an (x,y) coordinate, based not on the pixel resolution of the screen
    but on a position within our virtual grid. In the game, we define a grid that
    is 40 blocks wide, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So we know that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The height of the game screen in blocks will then simply be calculated by dividing
    the height of the screen in pixels by the previously determined value of `blockSize`
    minus a bit of space at the top for the score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This then allows us to keep track of our snake using two arrays for *x* and
    *y* coordinates, where element zero is the head and the last used element is the
    tail, a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as we have a system for moving the head, perhaps something similar
    to the squash ball but based on our new game grid, we can do the following to
    make the body follow the head:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code simply starts at the back section of the snake and creates
    its location in the grid irrespective of what the section in front of it was.
    It proceeds up the body doing the same until everything has been moved to the
    location of the section that used to be just ahead of it.
  prefs: []
  type: TYPE_NORMAL
- en: This also makes collision detection (even for a very long snake) nice and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using our grid based on `blockSize`, we can detect a collision, for example,
    with the right side of the screen, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous code simply checks whether the first element of our array, which
    holds the *x* coordinate of the snake, is equal to or greater than the width of
    our game grid in blocks. Try to work out the code for collision with the left,
    top, and bottom before we see it during the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Detecting the event of the snake bumping into itself is quick too. We just
    need to check whether the first element of our array (the head) is in exactly
    the same position as any of the other sections, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the snake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We simply draw every section of the snake relative to its grid location multiplied
    by the size in pixels of a block. The `blockSize` variable handles the entire
    challenge of making the game work on different screen sizes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, there are probably more questions about how our implementation will
    work, but they are probably best answered by actually building the game.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can easily follow along by either writing the code or just reading
    from the completed project. Let's take a look at the overall structure of our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will have two activities, one for the menu screen and one for the game screen.
    The menu screen activity will be called `MainActivity`, and the game screen activity
    will be called `GameActivity`. You can find all the completed code files as well
    as all the assets such as images, sprite sheets, and sound files in the `Chapter8/Snake`
    folder in the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: MainActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast to our other projects, the menu screen will not have a UI designed
    in the Android Studio UI designer. It will consist of an animated snake head,
    a title, and a high score. The player will proceed to `GameActivity` by tapping
    anywhere on the screen. As we need to accomplish animations and user interactions,
    even the home screen will have a thread, a view object, and methods normally associated
    with our game screens, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will not go deeper into the menu screen for now because at the end of this
    section, we will implement it line by line.
  prefs: []
  type: TYPE_NORMAL
- en: GameActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game screen structure has many similarities to our Squash game and to the
    structure of the menu screen, although the internals of this structure vary a
    lot (as we have discussed and as we will see). There are some differences towards
    the end of the structure, most notably, a `loadSound` method and a `configureDisplay`
    method. Here is the structure (we will see afterwards why the two extra methods
    are there):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tidying up onCreate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the first things you might notice when you examine the code from the
    `GameActivity` class we will soon implement is just how short the `onCreate` method
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have written two methods, `loadSound` and `configureDisplay`. They do most
    of the initialization and setup present in our squash game. This makes our code
    less cluttered. All that is left in `onCreate` is the initialization of our `SnakeView`
    object and a call to `setContentView`.
  prefs: []
  type: TYPE_NORMAL
- en: We will look in detail at our `loadSound` and `configureDisplay` methods when
    we implement them.
  prefs: []
  type: TYPE_NORMAL
- en: As we have had advanced sight of the structure as well as previous experience
    of this type of implementation, we will just go through all of the implementation
    of our game activity in one phase.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly implement the menu screen.
  prefs: []
  type: TYPE_NORMAL
- en: Animation, sprite sheets, and the Snake home screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used a bitmap to draw text, a circle, a line, and
    a single pixel on the blank bitmap we created in Java code. We then displayed
    the bitmap with all of its doodling using the `Canvas` class. Now we will look
    at a technique to draw two dimensional images, sometimes referred to as sprites.
    These are made from predrawn images. The images can be as simple as a plain pong
    ball or as complex as a glorious two-dimensional character with muscle definition,
    elaborate clothing, weapons, and hair.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have animated with unchanging objects, that is, we have moved a static
    unchanging image around the screen. In this section, we will see how to not only
    display a predrawn bitmap image on the screen but also continually alter it to
    create the illusion of on-the-spot animation.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the ultimate combination would be to animate the bitmap both by changing
    its image and moving it around at the same time. We will see that briefly when
    we look at an enhanced version of this chapter's *Snake* game, but will not be
    analyzing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this on-the-spot bitmap animation, we need some bitmaps, as you might
    expect. For example, to draw a snake''s tail swishing back and forth, we would
    need at least two frames of animation, showing the tail in different positions.
    In the following screenshot, the flower''s head is towards the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation, sprite sheets, and the Snake home screen](img/8859OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot, the flower has been flipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation, sprite sheets, and the Snake home screen](img/8859OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the two bitmaps were shown one after the other, repeatedly, they would create
    the basic effect of a flower blowing in the wind. Of course, two frames of animation
    aren't going to contest for any animation awards, and there is another problem
    with these images as well, as we will learn, so we should add in more frames to
    make the animation as life-like as is practical.
  prefs: []
  type: TYPE_NORMAL
- en: We have just one more thing to discuss before we make an animated snake head
    for our game's home screen. How do we get Android to switch between these bitmaps?
  prefs: []
  type: TYPE_NORMAL
- en: Animating with sprite sheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, we need to present the frames in a manner that is easy to manipulate
    in code. This is where sprite sheets come in. The following image shows some frames
    from a basic snake head animation that we will use on our game home screen. This
    time, they are presented in a strip of frames. All of them are parts of the same
    image, a bit like a series of images in a film. Also, notice in the following
    image that the frames are centered relative to each other and are exactly equal
    in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating with sprite sheets](img/8859OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we were to actually show the two previous flower images consecutively, they
    would not only would they sway but also jump around from one side to another on
    their stems, which is probably not the effect we were looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, with regard to the snake sprite sheet, as long as we show one frame after
    another, we will create a basic animation.
  prefs: []
  type: TYPE_NORMAL
- en: So how do we make our code jump from one part of the sprite sheet to the next?
    Each frame is exactly the same size, 64 x 64 pixels in this case, so we just need
    a way to display pixels from 0 to 63, then 64 to 127, then 128 to 192, and so
    on. As each frame of the sprite sheet image is subtly different, it allows us
    to use one image file with multiple frames to create our animation. Fortunately,
    we have a class to handle this, which is nothing quite as luxurious as a specific
    sprite sheet class but almost.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regarding sprite sheet classes, such a thing does exist, although not in the
    regular Android classes. An API specifically designed for two-dimensional games
    will usually contain classes for sprite sheets. We will look at examples of this
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Rect` class holds the coordinates of a rectangle. Here, we create a new
    object of the `Rect` type, and initialize it to start at 0, 0 and end at 63, 63:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Canvas` class can then actually use our `Rect` object to define a portion
    of a previously loaded bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is much simpler than it looks. First, we see `canvas.drawBitmap`.
    We are using the `drawBitmap` method of the `Canvas` class just as we have before.
    Then we pass `headAnimBitmap`, which is our sprite sheet containing all the frames
    we want to animate, as an argument. Rect `rectToBeDrawn` represents the coordinates
    of the currently relevant frame within `headAnimationBitmap`. `destRect` simply
    represents the screen coordinates at which we want to draw the current frame,
    and of course, `paint` is our object of the `Paint` class.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do now is change the coordinates of `rectToBeDrawn` and control
    the frame rate with a thread and we are done! Let's do that and create an animated
    home screen for our *Snake* game.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Snake home screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the background information we just covered and our detailed look at the
    structure of the code we are about to write, there shouldn''t be any surprises
    in this code. We will break things up into chunks just to make sure we follow
    exactly what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project of API level 13\. Call it `Snake`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the activity full screen as we have done before, and put your graphics
    into the `drawable/mdpi` folder. Of course, you can use my graphics as usual.
    They are supplied in the code download in the `graphics` folder of the `Snake`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, you will find our `MainActivity` class declaration and member variables.
    Notice the variables for our `Canvas` and `Bitmap` class as well, we are declaring
    variables to hold frame size (width and height) as well as the number of frames.
    We also have a `Rect` object to hold the coordinates of the current frame of the
    sprite sheet. We will see these variables in action soon. Type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the implementation of the overridden `onCreate` method. We
    get the screen dimensions in the usual way. We load our sprite sheet into the
    `headAnimBitmap` Bitmap. Finally, we create a new `SnakeAnimView` and set it as
    the content view. Type the following code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the declaration of our `SurfaceView` class, called `SnakeAnimView`,
    along with its member variables. Notice that it extends `SurfaceView` and implements
    `Runnable`. All its methods follow in the next steps. Type this code after the
    code from the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the constructor that gets the `frameWidth` value by dividing the bitmap
    width by the number of frames, and the `frameHeight` value using the `getHeight`
    method. Type this code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we implement the short but crucial `run` method. It calls each of the key
    methods of this class one after the other. These three methods are implemented
    in the following three steps after this step. Type the following code after the
    code from the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `update` method. It tracks and chooses the frame number that needs
    to be displayed. Each time through the `update` method, we calculate the coordinates
    of the sprite sheet to be drawn using `frameWidth`, `frameHeight`, and `frameNumber`.
    If you are wondering why we subtract `1` from each horizontal coordinate, it is
    because like the screen coordinates, bitmaps start their coordinates at 0, 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the `draw` method, which does nothing new until the end, when it calculates
    the place on the screen to draw the bitmap by dividing the `screenHeight` and
    `screenWidth` variables by 2\. These coordinates are then saved in `destRect`.
    Both `destRect` and `rectToDraw` are then passed to the `drawBitmap` method, which
    draws the frame required at the location required. Type this code after the code
    from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our trusty old `controlFPS` method ensures that our animation appears at a
    sensible rate. The only change in this code is that the initialization of `timeTosleep`
    is changed to create a 500-millisecond pause between each frame. Type the following
    code after the code from the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next are our `pause` and `resume` methods, which work with the Android lifecycle
    methods to start and stop our thread. Type this code after the code from the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For our `SnakeAnimView` class and our `onTouchEvent` method, which simply starts
    the game when the screen is touched anywhere, we enter the following code. Obviously,
    we don''t have a `GameActivity` yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, back in the `MainActivity` class, we handle some Android lifecycle
    methods. We also handle what happens when the player presses the back button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you must temporarily comment out this line from step 4 to test the animation.
    The reason for this is that it causes an error until we implement the `GameActivity`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Test the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncomment the line from step 14 when we have implemented the `GameActivity`
    class. Here is our completed home screen:![Implementing the Snake home screen](img/8859OS_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we set up a class that extended `SurfaceView`, just like we
    did for our squash game. We had a `run` method, which controlled the thread, as
    well as an `update` method, which calculated the coordinates of the current animation
    within our sprite sheet. The `draw` method simply drew to the screen using the
    coordinates calculated by the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: As in the squash game, we had an `onTouchUpdate` method, but the code this time
    was very simple. As a touch of any type in any location was all we needed to detect,
    we added just one line of code to the method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Snake game activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all of this code is new. In fact, we have either used most of it before
    or discussed it earlier in the chapter. However, I wanted to present every line
    to you in order and in context with at least a brief explanation, even when we
    have seen it before. Having said that, I haven't included the long list of imports
    as we will either be prompted to add them automatically or we can just press *Alt*
    + *Enter* when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we can remind ourselves how the whole thing comes together without
    any blanks in our understanding. As usual, I will summarize as we proceed through
    the implementation, and go into a few bits of extra depth at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an activity called `GameActivity`. Select a blank activity when asked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the activity full screen as we have done before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, create some sound effects or use mine. Create an `assets` directory
    in the `main` directory in the usual way. Copy and paste the sound files (`sample1.ogg`,
    `sample2.ogg`, `sample3.ogg`, and `sample4.ogg`) into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create individual non-sprite-sheet versions of graphics or use mine. Copy and
    paste them in the `res/drawable-mdpi` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the `GameActivity` class declaration with the member variables. There
    is nothing new here until we declare our arrays for our snake (`snakeX` and `snakeY`).
    Also, notice our variables used to control our game grid (`blockSize`, `numBlocksHigh`,
    and `numBlocksWide`). Now type this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As explained previously, our new, small `onCreate` method has very little to
    do because much of the work is done in the `loadSound` and `configureDisplay`
    methods. Type this code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the class declaration, member variables, and constructor for our `SnakeView`
    class. We allocate 200 `int` variables to the `snakeX` and `snakeY` arrays, and
    call the `getSnake` and `getApple` methods, which will place an apple and our
    snake on the screen. This is just what we want when the class is constructed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we spawn a snake and an apple in our coordinate system. In the
    `getSnake` method, we place the snake''s head in the approximate center of the
    screen by initializing `snakeX[0]` and `snakeY[0]` to the number of blocks high
    and wide divided by 2\. We then place a body segment and the tail segment immediately
    behind. Notice that we don''t need to make any special arrangement for the different
    types of segments. As long as the drawing code *knows* that the first segment
    is a head, the last segment is a tail, and everything in between is a body, then
    that will do. In the `getApple` method, the integer variables `appleX` and `appleY`
    are initialized to random locations within our game grid. This method is called
    from the constructor, as we saw in the previous step. It will also be called to
    place a new apple every time our snake manages to eat an apple, as we will see.
    Type this code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the `run` method, which controls the flow of the game. Type the
    following code after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will look at `updateGame`, the most complex method of the entire app.
    Having said that, it is probably slightly less complex than the same method in
    our squash game. This is because of our coordinate system, which leads to simpler
    collision detection. Here is the code for `updateGame`. Study it carefully, and
    we will dissect it line by line at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have worked out where our game objects are on the screen, so now we can
    draw them. This code is easy to understand as we have seen most of it before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `controlFPS` method, unchanged from our squash game''s `controlFPS`
    method, except that we have a different target frame rate. Type this code after
    the code from the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are our unchanged `pause` and `resume` methods. Type the following code
    after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the `onTouchEvent` method, similar to that of our squash game.
    There are no new concepts here, but the way it works in this game is as follows.
    We switch on the `ACTION_UP` event. This is broadly the same as detecting a click.
    We then check whether the press was on the left or the right. If it was on the
    right, we increment `directionOfTravel`. If it was on the left, we decrement `directionOfTravel`.
    If you looked carefully at the `updateGame` method, you would have seen that `directionOfTravel`
    indicates the direction in which to move the snake. Remember, the snake never
    stops. This is why we did it differently from our squash game. Type this code
    after the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `GameActivity` class, we now handle the Android lifecycle methods
    and the "back" button functionality. Type this code after the code from the preceding
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `loadSound` method, which simply tidies up the `onCreate` method
    by moving all of the sound initialization to here. Type this code after the code
    from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the `configureDisplay` method, which is called from `onCreate`
    and does the entire setup of bitmaps and screen size calculations. We will look
    at this in more detail later. Type the following code after the code from the
    previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now run the app. The game is much more playable on an actual device than it
    is on the emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We covered the code as we progressed, but as usual, here is a piece-by-piece
    dissection of a few of the more complicated methods, starting with the `updateGame`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check whether the player has eaten an apple. More specifically, is
    the snake''s head in the same grid location as the apple? The `if` statement checks
    whether this has occurred, and then does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Increases the length of the snake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Puts another apple on the screen by calling `getApple`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a value to the player's score, relative to the length of the snake, making
    each apple worth more than the previous one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plays a beep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code for the actions that we have just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we simply move each segment of the snake, starting from the back, to the
    position of the segment in front of it. We do this with a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we better move the head too! We move the head last because the leading
    section of the body would move to the wrong place if we move the head earlier.
    As long as the entire move is made before any drawing is done, all will be well.
    Our `run` method ensures that this is always the case. Here is the code to move
    the head in the direction determined by `directionOfTravel`. As we saw, `directionOfTravel`
    is manipulated by the player in the `onTouchEvent` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we check for a collision with a wall. We saw this code when we looked
    at collision detection earlier. Here is the complete solution, starting with the
    left wall, then right, then top, and then bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we check whether the snake has collided with itself. Initially, this seemed
    awkward, but as we previously saw, we just loop through our snake array to check
    whether any of the segments are in the same place as the head, in both *x* and
    *y* coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If any part of our collision detection code sets `dead` to `true`, we simply
    play a sound, set the `score` to `0`, and get a new baby snake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we take a closer look at the `drawGame` method. First, we get ready to
    draw by clearing the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we draw the text for the player''s score, just above `topGap` that we define
    in `configureDisplay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using `drawLine`, we draw a visible border around our game grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we draw the snake''s head:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The snake''s head will be followed by all the body segments. Look at the condition
    of the `for` loop. This starts at `1`, which means it is not redrawing the head
    position, and ends at `snakeLength - 1`, which means it is not drawing the tail
    segment. Here is the code used to draw the body section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we draw the tail of the snake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we draw the apple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will go through the `configureDisplay` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the screen resolution and store the results in `screenWidth`
    and `screenHeight` as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a gap called `topGap`. It will be a space at the top of the
    screen and will not be a part of the game area. This gap is used for the score.
    We saw `topGap` used fairly extensively in the `drawGame` method. After this,
    we calculate the width and height of the remaining area in blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following part of the code, we load all our image files into `Bitmap`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we scale each bitmap to be the same width and height as `blockSize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now we can take a quick look at a few different ways we can improve the game.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a series of questions and answers to lead us to an improved version
    of our *Snake* game. It doesn't matter if you can't answer some (or even all)
    of the questions. Just take a look at the questions and answers, after which you
    can take a look at the new game and the code.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1) What can be used to provide a visual improvement for our game screen? Can
    we use a nice light green, grassy background instead of just black?
  prefs: []
  type: TYPE_NORMAL
- en: Q2) How about some nice flowers?
  prefs: []
  type: TYPE_NORMAL
- en: Q3) If you're feeling brave, make the flowers sway. Think about what we have
    learned about sprite sheets. The theory is exactly the same as that of the animated
    snake head. We just need a few lines of code to control the frame rate separately
    from the game frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Q4) We could set up another counter and use our snake head animation in `GameActivity`,
    but it wouldn't be that useful because the subtle tongue movements would be barely
    visible at the smaller size. But could we swish the tail segment?
  prefs: []
  type: TYPE_NORMAL
- en: Q5) Here is a slightly trickier enhancement. You can't help notice that when
    the snake sprites are headed in three out of the four possible directions, they
    don't look right. Can you fix this?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the end of yet another successful game project. You now know how to
    create and animate sprite sheets to add more realism to our games. Now we have
    an enhanced *Snake* game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how simple it is to add leaderboards and achievements.
    This will make our game social and compelling by letting the player see the high
    scores and achievements of their friends and compare them with their own.
  prefs: []
  type: TYPE_NORMAL
