- en: File Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to file manipulation. As in *everything is a file*system,
    file manipulation is considered one of the most important aspects of working with
    Linux. We will start by exploring common file operations, such as creating, copying,
    and deleting files. We will continue with a bit on archiving, another important
    tool when working on the command line. The last part of this chapter will be devoted
    to finding files on the file system, another important skill in the toolset of
    a shell scripter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `cp`, `rm`, `mv`,
    `ln`, `tar`, `locate`, and `find`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Common file operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will practice file manipulation using the virtual machine we created in [Chapter
    2](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml), *Setting Up Your Local Environment*.
    No further resources are needed at this point.
  prefs: []
  type: TYPE_NORMAL
- en: Common file operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have mainly introduced commands related to navigation on the Linux
    filesystem. In earlier chapters, we already saw that we can use `mkdir` and `touch`
    to create directories and empty files, respectively. If we want to give a file
    some meaningful (text) content, we use `vim` or `nano`. However, we have not yet
    talked about removing files or directories, or copying, renaming, or creating
    shortcuts. Let's start with copying files.
  prefs: []
  type: TYPE_NORMAL
- en: Copying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In essence, copying a file on Linux is really simple: use the `cp` command,
    followed by the filename-to-be-copied to the filename-to-copy-to. It looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in this example we copied an (empty) *file* that was already
    *owned by us*, while we were *in the same directory* as the file. This might raise
    some questions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we always need to be in the same directory as the source and destination
    file?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about the permissions of the file?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we also copy directories with `cp`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you might expect, as with many things under Linux, the `cp` command is also
    very versatile. We can indeed copy files not owned by us; we do not need to be
    in the same directory as the file, and we can also copy directories! Let''s try
    a few of these things out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what happened? We used `cd` to change the directory to `/var/log/`. We
    listed the files there using `ls` with the *long* option. We copied a file with
    a relative path that we were able to read, but that was owned by `root:root`,
    to the fully qualified `/home/reader/` directory. When we listed `/home/reader/`
    with the fully qualified path, we saw that the copied file was now owned by `reader:reader`.
    When we tried to do the same for the `tallylog` file, we got the error `cannot
    open ''tallylog'' for reading: Permission denied`. This should not be unexpected,
    since we do not have any read permissions on that file, so copying would be hard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This should answer two of the three questions. But what about directories?
    Let''s try to copy the `/tmp/` directory into our `home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For such a simple exercise, a lot actually happened! First, we navigate back
    to our `home` directory using `cd` without any arguments; a neat little trick
    in itself. Next, we try to copy the entire `/tmp/` directory to `.` (which, as
    you should remember, is shorthand for *current directory*). However, this fails
    with the error `-r not specified; omitting directory '/tmp/'`. We list the directory
    to check this, and indeed, it seems like nothing happened. When we add the `-r`,
    as specified by the error, and retry the command, we get some `Permission denied`
    errors. This is not unexpected, since not all files *inside* the `/tmp/` directory
    will be readable to us. Even though we got the errors, when we now check the contents
    of our `home` directory, we can see the `tmp` directory there! So, using the `-r`
    option, which is short for `--recursive`, allows us to copy directories and everything
    that's in them.
  prefs: []
  type: TYPE_NORMAL
- en: Removing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After copying some files and directories into our `home` directory (which is
    a safe bet, because we know for sure that we can write there!), we''re left with
    a little mess. Instead of only creating files, let''s use the `rm` command to
    remove some duplicate items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `rm` followed by a filename deletes it. As you might notice, there is
    no Are you sure? prompt. This can actually be enabled by using the `-i` flag,
    but by default this is not the case. Consider that `rm` also allows you to use
    wildcards, such as `*` (which matches everything), which will delete every file
    that is matched (and can be deleted by the user). In short, this is a great way
    to lose your files really quickly! When we tried to use `rm` with the name of
    a directory, however, it gave the error `cannot remove ''tmp/'': Is a directory`.
    This is very similar to the `cp` command, and luckily for us, the remediation
    is also the same: add `-r` for a *recursive* delete! Again, this is a great way
    to lose files; a single command lets you delete your entire `home` directory and
    everything in it, without so much as a warning. Consider **this** your warning!
    Especially when using in combination with the `-f` flag, which is short for `--force`,
    which will ensure that `rm` *never prompts* and starts deleting right away.'
  prefs: []
  type: TYPE_NORMAL
- en: Renaming, moving, and linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we do not just want to create or delete a file, we might need to
    rename one. Weirdly, Linux does not have anything that sounds like rename; however,
    the `mv` command (for **m**o**v**e) does accomplish the functionality that we
    want. Similar to the `cp` command, it takes a source file and destination file
    as arguments, and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `mv` command is really simple to use. It even works for
    directories, without needing a special option such as the `-r` we saw for `cp`
    and `rm`. It does, however, get a little more complex when we introduce wildcards,
    but don't worry about that for now. The commands we used in the preceding code
    are relative, but they work just as well fully qualified or mixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you''ll want to move a file from one directory into another. If
    you think about it, this is actually a rename of the fully qualified file name!
    No data is being touched, but you just want to reach the file somewhere else.
    So, using `mv umaskfile umaskdir/` will move the `umaskfile` into `umaskdir/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `ln` command, which stands for **l**i**n**king. This is
    the Linux way of creating links between files, which are closest to the shortcuts
    that Windows uses. There are two types of links: symbolic links (also called soft
    links) and hard links. The difference is found deeper in the filesystem workings:
    a symbolic link refers to the filename (or directory name), whereas a hard link
    links to *inode* that stores the contents of the file or directory. For scripting,
    if you''re using links, you''re probably using symbolic links, so let''s see those
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We created two types of symbolic link using `ln -s` (which is short for `--symbolic`):
    to the `/var/log/auth.log` file first, and to the `/tmp/` directory after. We
    are seeing two different ways of using `ln -s`: without a second argument, it
    creates the link with the same name as the thing we''re linking to; otherwise,
    we can give our own name for the link as the second argument (as can be seen with
    the `link-to-auth.log` and `link-to-tmp/` links). We can now read the contents
    of `/var/log/auth.log` by either interacting with `/home/reader/auth.log` or `/home/reader/link-to-auth.log`.
    If we want to navigate to `/tmp/`, we can now use either `/home/reader/tmp/` or
    `/home/reader/link-to-tmp/` in combination with `cd`. While this example isn''t
    particularly useful in your day to day work (unless typing `/var/log/auth.log`
    instead of `auth.log` saves you tons of time), linking prevents duplicate copies
    of files while maintaining easy access.'
  prefs: []
  type: TYPE_NORMAL
- en: An important concept in linking (and Linux filesystems in general) is the **inode**.
    Every file (whatever the type, so including directories) has an inode, which describes
    the attributes and *disk block locations* of that file. In this context, attributes
    include things like ownership and permissions, as well as last change, access
    and modification timestamps. In linking, *soft links* have their own inodes, while
    *hard link*s refer to the same inode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing with the next part of this chapter, clean up the four links
    and the copied `dpk.log` file by using `rm`. If you''re in doubt about how to
    do this, check out the man page for `rm`. A little tip: removing symbolic links
    is as simple as `rm <name-of-link>`!'
  prefs: []
  type: TYPE_NORMAL
- en: Archiving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a grasp on common file operations in Linux, we'll move on to
    archiving. While it might sound fancy, archiving refers simply to **creating archives**.
    An example most of you will be familiar with is creating a ZIP file, which is
    an archive. ZIP is not Windows-specific; it is an *archive file format* with different
    implementations for Windows, Linux, macOS, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, there are many archive file formats. On Linux, the most
    commonly used is the **tarball**, which is created by using the `tar` command
    (which is derived from the term **t**ape **ar**chive)*.* A tarball file, which
    ends in `.tar`, is uncompressed. In practice, tarballs will almost always be compressed
    with Gzip, which stands for **G**NU **zip**. This can be done either directly
    with the `tar` command (most common) or afterwards using the `gzip` command (less
    common, but can be used to compress files other than tarballs as well). Since
    `tar` is a complicated command, we''ll explore the most commonly used flags in
    more detail (descriptions are taken from the `tar` manual page):'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-c`, `--create` |  Create a new archive. Arguments supply the names of the
    files to be archived. Directories are archived recursively, unless the `--no-recursion`
    option  is given. |'
  prefs: []
  type: TYPE_TB
- en: '| `-x`, `--extract`, `--get` |  Extract files from an archive. Arguments are
    optional.  When given, they specify names of the archive members to be extracted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-t`, `--list` | List the contents of an archive. Arguments are optional.
    When given, they specify the names of the members to list. |'
  prefs: []
  type: TYPE_TB
- en: '| `-v`, `--verbose` |  Verbosely list files processed. |'
  prefs: []
  type: TYPE_TB
- en: '| `-f`, `--file=ARCHIVE` |  Use archive file or device ARCHIVE. |'
  prefs: []
  type: TYPE_TB
- en: '| `-z`, `--gzip`, `--gunzip`, `--ungzip` |  Filter the archive through Gzip.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-C`, `--directory=DIR` | Change to DIR before performing any operations. 
    This option is order-sensitive, that is, it affects all options that follow. |'
  prefs: []
  type: TYPE_TB
- en: 'The `tar` command is pretty flexible about how we specify these options. We
    can present them one by one, all together, with and without a hyphen, or with
    the long or short option. This means that the following ways to create an archive
    are all correct and would all work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tar czvf <archive name> <file1> <file2>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -czvf <archive name> <file1> <file2>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -c -z -v -f <archive name> <file1> <file2>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar --create --gzip --verbose --file=<archive name> <file1> <file2>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While this seems to be helpful, it can also be confusing. Our suggestion: pick
    one of the formats and stick with it. In this book, we will use the shortest form,
    so this is all short options without dashes. Let''s use this form to create our
    first archive!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this command, we **v**erbosely **c**reated a g**z**ipped **f**ile with
    the name `my-first-archive.tar.gz`, containing the files `nanofile.txt umaskfile`,
    and `renamedtestfile`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we only archived files. In practice, it is often nice to archive
    an entire directory. The syntax for this is exactly the same, only instead of
    a filename you will give a directory name. The whole directory will be archived
    (and, in the case of the `-z` option, compressed as well). When you unpack a tarball
    that archived a directory, the entire directory will be extracted again, not just
    the contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see if unpacking it gives us back our files! We move the gzipped
    tarball to `renamedtestdir`, and use the `tar xzvf` command to unpack it there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we got our files back in the `renamedtestdir`! Actually, we
    never removed the original files, so these are copies. You might want to know
    what''s inside a tarball before you go to the trouble of extracting it and cleaning
    up everything. This can be accomplished by using the `-t` option instead of `-x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last interesting option that''s widely used for `tar` is the `-C`, or `--directory`
    option. This command ensures that we do not have to move the archive around before
    we extract it. Let''s use it to extract `/home/reader/renamedtestdir/my-first-archive.tar.gz`
    into `/home/reader/umaskdir/` from our `home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By specifying `-C` with a directory argument after the archive name, we made
    sure that `tar` extracts the contents of the gzipped tarball into that specified
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'That covers the most important aspects of the `tar` command. However, one little
    thing remains: cleaning up! We''ve made a nice mess of our `home` directory, and
    we do not have any files there that actually do anything. The following is a practical
    example showing how dangerous the wildcard with the `rm -r` command can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'One simple command, no warning, and all files, including directories with more
    files, are gone! And should you be wondering: no, Linux does not have a Recycle
    Bin either. These files are gone; only advanced hard disk recovery techniques
    *might* still be able to recover these files.'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you perform the preceding command, just to get a feeling for
    how destructive `rm` can be. Before you do, however, ensure that you are in your
    `home` directory and that you do not accidentally have any files there that you
    do not want to delete. If you followed our examples, this should not be the case,
    but if you've done anything else, be sure about what you're doing!
  prefs: []
  type: TYPE_NORMAL
- en: Finding files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After learning about common file operations and archiving, there is one vital
    skill in file manipulation we have not yet covered: finding files. It''s very
    neat that you know how to copy or archive files, but if you cannot find the file
    you want to manipulate, you''re going to have a hard time completing your task.
    Fortunately, there are tools devoted to finding and locating files on a Linux
    filesystem. And, to keep things simple, these are called `find` and `locate`.
    The `find` command is more complex, but more powerful, while the `locate` command
    is easier to use when you know exactly what you''re looking for. First, we''ll
    show you how to use `locate`, before moving on to the more extensive capabilities
    of `find`.'
  prefs: []
  type: TYPE_NORMAL
- en: locate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the man page for locate, the description could not be more fitting: `locate
    - find files by name`. The `locate` command is installed by default on your Ubuntu
    machine and the basic functionality is as simple as using `locate <filename>`.
    Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we looked for the filename `fstab`. We might have
    remembered that we need to edit this file for filesystem changes, but we were
    not sure where we could find it. `locate` presented us with all locations on disk
    which contain `fstab`. As you can see, it does not have to be an exact match;
    everything that contains the `fstab` string will be printed.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the `locate` command completes almost instantly.
    That is because it uses a database for all files which is updated periodically,
    instead of going through the whole filesystem at runtime. Because of this, the
    information is not always accurate, since changes are not synchronized to the
    database in real-time. To ensure that you are talking to the database with the
    latest state of the filesystem, be sure to run `sudo updatedb` (requires root
    privileges) before running `locate`. This is also required before the first run
    of `locate` on a system, because otherwise there is no database to query!
  prefs: []
  type: TYPE_NORMAL
- en: Locate has some options, but in our experience, you only use it if you know
    the exact (or an exact part of the) filename. For other searches, defaulting to
    the `find` command is a much better idea.
  prefs: []
  type: TYPE_NORMAL
- en: find
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find is a very powerful, but complicated command. You can do any of the following
    things with `find`:'
  prefs: []
  type: TYPE_NORMAL
- en: Search on a filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search on permissions (both user and group)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search on ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search on file type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search on file size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search on timestamps (created, last-modified, last-accessed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search only in certain directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would take a full chapter to explain all of the functionality in the `find`
    command. We will only be describing the most common use cases. The real lesson
    here is being aware of the advanced functionalities of `find`; if you ever need
    to look for files with a specific set of attributes, always think of the `find`
    command first and check out the `man file` page to see if you can utilize find
    for your search (spoiler alert: this is **almost always** the case!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basic use of find: `find <location> <options and arguments>`.
    Without any options and arguments, find will print every file it finds within
    the location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have been under the impression that your `home` directory was empty.
    It actually contains quite a number of hidden files or directories (which start
    with a dot), which `find` has found for us. Now, let''s apply a filter with the
    `-name` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to what you might have expected, `find` works differently from `locate`
    with regards to partly matched files. Unless you add wildcards around the argument
    to `-name`, it will only match on the full filename, not on partly matched files.
    This is definitely something to keep in mind. Now, what about looking only for
    files, instead of directories as well? For this, we can use the `-type` option
    with the `d` argument for directories or `f` for files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first result presents all directories within `/home/reader/` (including
    `/home/reader/!`), while the second result prints all files. As you can see, there
    is no overlap, since a file under Linux is *always of only one type*. We can also
    combine multiple options, such as `-name` and `-type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We start by looking for *files* in `/home/reader/` which contain the string
    cache. The `find` command does not print anything, which means we did not find
    anything. If we look for *directories* with the cache string, however, we are
    shown the `/home/reader/.cache/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last example, let''s look at how we can use `find` to distinguish between
    files of different sizes. To do this, we''ll create an empty file using `touch`
    and a non-empty file using `vim` (or `nano`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the `0` and `23` on-screen, `emptyfile` contains 0 bytes,
    whereas `textfile.txt` contains 23 bytes (which, not entirely coincidental, contains
    a sentence of 23 characters). Let''s see how we can use the `find` command to
    find both files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this, we use the `-size` option. We give it the number we''re looking
    for, followed by a letter which indicates which range we''re dealing with. `c`
    is used for bytes, `k` for kilobytes, `M` for megabytes, and so on. You can find
    these values on the manual page. As the results show, there are three files which
    are exactly 0 bytes: our `emptyfile` is one of them. These is one file which is
    exactly 23 bytes: our `textfile.txt`. You might think: 23 bytes, that''s very
    specific! How will we ever know how many bytes a file is exactly? Well, you won''t.
    The creators of `find` have also implemented a *greater than* and *lower than*
    construct, which we can use to give us a little more flexibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's say we're looking for a file that's at least larger than 10 bytes. We
    use the `+` option on the argument, which only prints the files that are larger
    than 10 bytes. However, we still see too many files. Now, we expect the file to
    also be smaller than 30 bytes. We add another `-size` option, this time specifying
    `-30c`, meaning that the file will be less than 30 bytes. And, not entirely unexpectedly,
    our 23 byte `testfile.txt` is found!
  prefs: []
  type: TYPE_NORMAL
- en: All of the preceding options and more can be combined to form a very powerful
    search query. Are you looking for a *file*, which is *at least* 100 KB but *not
    more than* 10 MB, located *somewhere in* `/var/`, that was created *in the last
    week*, and is *readable* to you? Just combine the options in `find` and you will
    definitely find that file in no time!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described file manipulation in Linux. We started with common file
    operations. We explained how to we can copy files in Linux with `cp` and how we
    can move or rename files with `mv`. Next, we discussed how we can remove files
    and directories with `rm` and how we can create *shortcuts* under Linux with symbolic
    links by using the `ln -s` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second part of this chapter, we discussed archiving. While there are
    many different tools that allow archiving, we focused on the most commonly used
    one in Linux: `tar`. We showed you how to create and extract archives, both in
    the current working directory and to somewhere else on the filesystem. We described
    that both files and whole directories can be archived by `tar`, and that we can
    see what''s inside a tarball without actually extracting it by using the `-t`
    option.'
  prefs: []
  type: TYPE_NORMAL
- en: We ended this chapter with finding files using `file` and `locate`. We explained
    that `locate` is a simple command that is useful under certain circumstances,
    while `find` is a more complicated but very powerful command that can provide
    great benefits to those who master it.
  prefs: []
  type: TYPE_NORMAL
- en: The following commands were introduced in this chapter: `cp`, `rm`, `mv`, `ln`,
    `tar`, `locate`, and `find`.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which command do we use to copy files in Linux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between moving and renaming files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `rm` command, which is used to remove files under Linux, potentially
    dangerous?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a hard link and a symbolic (soft) link?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three most important operating modes of `tar`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which option is used by `tar` to select the output directory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the biggest difference between `locate` and `find` when searching on
    filenames?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many options of `find` can be combined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File manipulation**: [https://ryanstutorials.net/linuxtutorial/filemanipulation.php](https://ryanstutorials.net/linuxtutorial/filemanipulation.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tar tutorial**: [https://www.poftut.com/linux-tar-command-tutorial-with-examples/](https://www.poftut.com/linux-tar-command-tutorial-with-examples/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find practical examples**: [https://www.tecmint.com/35-practical-examples-of-linux-find-command/](https://www.tecmint.com/35-practical-examples-of-linux-find-command/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
