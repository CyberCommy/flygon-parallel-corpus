- en: Chapter 4. Using Actors, Classes, and Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have our environment set up with all of the essential actors and objects
    placed. There are other equally, if not more, important types of objects (or actors),
    without which the game would not be complete. These are Visual and Basic classes
    and Volumes, which are actors with special properties. Some are vital to the game,
    while some add special features. In this chapter, we will be looking at some of
    these volumes and classes and how they affect the game. We will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will kick off with an introduction to basic classes. These can be accessed
    in the **Modes** panel under the **Basic** section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic classes](img/image00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This contains the most basic classes that are essential to every almost all
    games, regardless of their type or genre. Let us go over them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty Actor**: An Actor is any object that is placed in the game world. All
    objects, lights, cameras, volumes, and so on are actors. An empty actor is an
    empty entity that you can place in your level. It does not have any inherent properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Empty Character**: An **Empty Character** does not have a mesh or any animations—just
    a collision capsule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Empty Pawn**: A **Pawn** is an actor that can be possessed (in other words,
    controlled) by a player or the AI. The game''s characters, all of the enemies,
    allies, and NPCs in the game are all pawns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Start**: As the name suggests, **Player Start** is where the player
    spawns when playing the game. If there is no Player Start actor in the level,
    the player will spawn at the origin of the world (`0`,`0`,`0`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point Light**: As mentioned in the previous chapter, **Point Light** is the
    most basic and most widely used source of lighting. You can also add the Point
    Light actor from here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cube**: This adds a cube primitive (static mesh) to the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sphere**: This adds a sphere primitive to the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cylinder**: This adds a cylinder primitive to the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cone**: This adds a cone primitive to the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Box trigger / Sphere trigger**: The next two actors have been clubbed together
    since they serve the same purpose; the only difference is their shapes. Triggers,
    simply put, add interactivity to the game. You can add an event for the trigger
    (for instance, if the player touches it, hits a specific key, and so on), which,
    when fulfilled, carries out a specific action as set by the developer. For example,
    you can have a trigger, which when the player touches, turns on a light, and so
    on. UE4 offers two default shapes: box and sphere. You can also create custom
    shape triggers, but more on that later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding basic class actors to the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you are acquainted with the basic classes, let us go ahead and add
    some to our level.
  prefs: []
  type: TYPE_NORMAL
- en: Placing the Player Start actor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing that we are going to place is the Player Start actor. Its placement
    is vital and should be decided beforehand. In our game, we would want our player
    to start in the first room. Keeping that in mind, drag the Player Start actor
    and place it in the first room, away from the door.
  prefs: []
  type: TYPE_NORMAL
- en: '![Placing the Player Start actor](img/image00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The actor is represented by a gamepad with a flag next to it. As you can see,
    there is a capsule-shaped volume around it. This capsule is there to give you
    an idea about the size of the character as well as its placement when the game
    starts. So make sure that the capsule does not overlap any other actor or surface,
    as doing so will change the icon into a sign saying **Bad Size**. You can resize
    this capsule by using the **Scale** tool so that it fits with the character.
  prefs: []
  type: TYPE_NORMAL
- en: '![Placing the Player Start actor](img/image00296.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You may have also noticed a blue arrow along with the icon. The direction in
    which the arrow points is where the character will face when the game starts (remember,
    *W* is for the translate tool, *E* is for the rotation tool, and *R* is for the
    scaling tool). You can change this direction with the help of the rotation action.
    If you were to click on the **Play** button, the character would spawn where the
    actor is placed, facing the direction of the arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Adding triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we are going to add triggers. We are going to keep things simple by using
    only Box triggers. To place a Box trigger, simply drag it from the **Modes** panel
    and place it on the level. What we will do with the triggers we will cover in
    the next chapter. For now, you can simply place the triggers in the locations
    mentioned in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Always name your actors, be it triggers, lights, characters, or so on. It is
    not only considered good practice but it will make your project easier to read
    and will keep everything organized and is easier to track.
  prefs: []
  type: TYPE_NORMAL
- en: Room 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the first room, place the first trigger near the key cube. This trigger will
    be used to interact with the key cube. The placement and dimensions of this trigger
    (or any trigger for that matter) are important, since they determine how far the
    player can interact with the key cube. For example, if the trigger is too large,
    the player will be able to pick up the key cube from afar, which is not what we
    want. We want the player to be relatively close to or adjacent to the key cube
    before they can pick it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping that in mind, place the trigger and set the dimensions such that it
    encapsulates the entire key cube (so that the player can pick it up from any direction),
    and make it taller (so that the player does not have to look directly at the key
    cube to pick it up; otherwise, it will get annoying). Finally, make the trigger
    bigger than the key cube. Once set, it should look something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 1](img/image00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Add the next trigger in this room on the pedestal. This is where the player
    will have to place the key cube in order to open the door.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, drag and drop a Box Trigger, and place it on top of the pedestal.
    Again, as we did with the trigger for the key cube, set this trigger's dimensions
    such that the player can interact with it from any direction and does not have
    to be standing right next to it in order to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 1](img/image00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To check the placement of the trigger and whether its position and dimensions
    are correctly set, you can first unhide the trigger actor by unchecking the **Actor
    Hidden in Game** option—found in the trigger's **Details** panel and then play
    the level. For now, this will do in terms of trigger placement. Let us now move
    on to the second room.
  prefs: []
  type: TYPE_NORMAL
- en: Room 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the second room, place the first trigger near the large door in the middle
    of the room. Now, we would want the player to be able to open the door from anywhere.
    Keeping that in mind, place the trigger such that it covers the entire door lengthwise
    and widthwise. Again, adjust the width, keeping in mind how close you want the
    player to be in order to interact with the door.
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 2](img/image00299.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, place the next two triggers that on the pedestal, similar to that in the
    other rooms. Since the pedestals have similar dimensions, you can place the triggers
    by duplicating them in the previous room.
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 2](img/image00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are not going to place any triggers on the key cubes as we did in the previous
    room. The reason behind this will be explained in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Room 3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the third room, we have a couple of pedestals upon which there will be buttons.
    Therefore, we will require triggers for interactivity. Again, do not place triggers
    on the key cube.
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 3](img/image00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Room 4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, in the fourth room, as with the previous rooms, place triggers on all
    of the pedestals and doors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 4](img/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have now placed most of the triggers we need for our game. We will add more
    later. And with that, we are done placing Basic classes into our level. Let us
    now move on to the Visual Effects class and see how it affects our game.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already covered the Light class in the previous chapter, we are
    going to skip it and move straight to the Visual Effects class. The Visual Effects
    class contains actors that affect the visuals of the game. Although not necessary
    components of a game, they help improve its overall quality.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, they do not require a lot of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual Effects](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are various actors in Visual Effects classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Post Process Volume**: This is an actor that can be used to manipulate the
    look and feel of the game. The effects will take place while the player is in
    the volume. There are many effects available. Some examples include **Anti-Aliasing**
    (removes hard edges of actors, giving them a smoother finish), **Bloom** (can
    be seen in real life when looking at a bright object against a darker background),
    **Depth of Field** (blurs objects based on their distance from a focal point),
    and much more. There are several effects that you can add to your game by using
    **Post Process Volume**; so experiment with the volume to see everything you can
    do with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atmospheric Fog**: In an outdoor level, just having a skylight is not enough
    to provide a realistic outdoor scene. In reality, the light coming from the sun
    scatters and spreads because of the earth''s atmosphere. To have that effect in
    the game, you need to add the **Atmospheric Fog** actor to the level. You can
    set properties such as **Sun Multiplier** (to brighten the fog as well as the
    sky), **Default Brightness** (to set the brightness of the **Fog**), **Default
    Light Color** (to set the color of the atmosphere), and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exponential Height Fog**: You can use this actor to add fog and mist to your
    level. This is also used mostly in outdoor scenes. You can set properties such
    as the **Fog** density, the color of the **Fog**, the **Fog Height Falloff** (how
    the density of the fog decreases as we go up), and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sphere Reflection Capture**: This is another useful tool. The **Sphere Reflection
    Capture** actor takes the lighting information and provides a realistic reflective
    effect, giving materials a glossy finish. Metallic materials and similar rely
    on this actor to provide a realistic finish. In the actor''s setting panel, you
    will see something called the **Influence Radius**, which is the volume in which
    the actor has influence. You can increase or decrease it. Below that are the **Brightness**
    settings, which you can use to set how bright you want the reflections to be.
    Keep in mind that if you change the lighting in the level (by moving it, changing
    the brightness, changing the color, and so on) or move the actors around, the
    **Sphere Reflection Capture** actor will not update. You will have to update it
    manually, which you can do with the help of the **Update Capture** button that
    is located above the **Influence Radius** option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Box Reflection Capture**: This is similar to **Sphere Reflection Capture**.
    The only difference is that while the **Sphere Reflection Capture** actor has
    a spherical influence area, the Box Reflection Capture actor has a cubical area
    of influence, making it relatively less effective than a **Sphere Reflection Capture**
    actor. This actor is best used in hallways or cubical rooms. Its settings are
    the same as the **Sphere Reflection Capture** actor, only instead of an Influence
    Radius, it has a **Box Transition Distance**, which can be used to either increase
    or decrease its area of influence. Again, as with the **Sphere Reflection Capture**
    actor, if you change the lighting or the objects in the game, you will have to
    click on the **Update Captures** button to update the reflections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deferred Decal**: The **Deferred Decal** actor provides an easy and inexpensive
    way of adding decals onto objects. It is a great way of adding effects such as
    blood splatter. You can pick which material you want for the decal and place it
    on the level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Visual Effect actors to the game – Post Process Volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we are going to add to the level is a Post Process Volume. When
    the player picks up a key cube, we want to give them a visual indicator that they
    have picked it up. The visual indicator, in this case, is a flash on the screen.
    To add the actor, simply drag it from the panel and drop it on the level, over
    the key cube. The post process volume is represented by a light pink cube.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Visual Effect actors to the game – Post Process Volume](img/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After the Post Process Volume has been placed, let us set some properties in
    the **Details** panel. In this panel, you will see quite a lot of options. All
    of them are categorized based on the type of effect they create. One thing to
    note is that some of the effects are not available on mobile.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are just going to tweak the **Global Illumination** setting. In the **Details**
    panel, go to the **Global Illumination** section, where you will see two settings:
    **Indirect Lighting Color** and **Indirect Lighting Intensity**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Visual Effect actors to the game – Post Process Volume](img/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: First, enable both effects by selecting them. Then, in the **Indirect Lighting
    Color** option, set the color to anything you like. In our case, we are going
    to set the color to blue. You can also set the Indirect Lighting Intensity option
    to anything you want, but we are just going to leave it at **1**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once set, if you move inside the volume, you will find everything turned blue.
    This is going to be our effect for when we pick up our cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Visual Effect actors to the game – Post Process Volume](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if you were to test the game and walk inside the cube, everything would
    turn blue and remain blue unless you stepped out of the volume. We do not want
    that. We only want the screen to turn blue for a brief moment—when the player
    picks up the key cube—and then fade away. We need to change another setting. We
    want the volume to be disabled when the game starts and only be triggered when
    the player picks up the key cube. We will cover how to enable this setting in
    the next chapter. For now, go to the **Details** panel, and in the **Post Process
    Volume** section, you will find the **Enabled** option checked. Simply uncheck
    it; this will disable the **Post Process Volume**. If you were to check it now,
    you would see that the screen no longer turns blue. Finally, duplicate and place
    **Post Process Volumes** over all the key cubes in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Volumes are actors that have special properties. They can be seen as invisible
    triggers, each doing something different (depending on the type of volume) when
    the player enters them. There are various types of **Volume** actors available;
    each has a different property upon entering it. Volumes are only visible in the
    **Editor** mode and not in the actual game itself. Therefore, they are usually
    accompanied by another actor. For example, a Volume called **Pain Causing Volume**,
    as the name suggests, causes the player to take damage when it is entered into.
    It is obvious that developers would use this volume when the player walks through
    something hazardous, such as fire, electricity, and so on. Therefore, the volume
    would be placed around it. The fire would act as a visual cue indicating that
    the area is unsafe to go through, and the **Pain Causing Volume** would take care
    of the rest (cause damage to the player).
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of volumes available to users. Let us take a look
    at them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Volumes](img/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Audio Volume**: Audio Volume allows you to control the audio within the game
    by tweaking its settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocking Volume**: The **Blocking Volume** acts as an invisible wall, which
    prevents certain types of actors from going through it. You can set what types
    of actors can and cannot pass through in the **Details** panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera Blocking Volume**: This prevents camera actors from passing through
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cull Distance Volume**: This is an optimizing tool that does not render objects
    smaller or equal to a set value (set by the developer), based on their distance
    from the camera. This is an important tool, especially if you have a vast outdoor
    scene, since it will not render objects far away, therefore saving memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kill ZVolume**: This destroys any actor that enters it, including the player.
    This can be used in cases when the player falls off the edge of a cliff, into
    a pit, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level Streaming Volume**: This is another optimizing tool that you can use
    to set the part (s) of the level you want to be visible to the player. This is
    really useful when you have huge levels. You can use this volume to hide parts
    of the level that the player cannot see from his/her current location or parts
    that are far away from him/her.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightmass Character Indirect Detail Volume**: This takes the lighting information
    and generates indirect light maps inside the volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightmass Importance Volume**: Yet another optimizing tool, the Lightmass
    Importance Volume is used to generate lighting information within it (indirect
    lighting, shadows, and so on). It is advisable to place a Lightmass Importance
    Volume around your game level for faster light building.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nav Mesh Bounds Volume and Nav Modifier Volume**: The Nav Mesh Bounds Volume
    is used for the AI to move around in the level. When placed, the AI character
    will move anywhere within the volume (provided the area is accessible in the first
    place).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Nav Modifier Volume** is used to modify **Nav Mesh Bounds Volume**. You
    can set it so that a certain area inside the **Nav Mesh Volume** can be blocked
    off and the AI character will not be able to traverse through it
  prefs: []
  type: TYPE_NORMAL
- en: '**Pain Causing Volume**: This causes damage to any player that enters it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics Volume**: This in which certain physical properties of a physics
    object can be altered. For example, you can enable/disable a setting called **Water
    Volume**: This, when enabled, simulates the character moving through a watery
    area, such as a swamp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post Process Volume**: This is the same as the volume found in the **Visual
    Effects** section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Precomputed Visibility Override Volume**: Using this volume, you can manually
    override the visibility of the actors in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Precomputed Visibility Volume**: This volume has a similar function as the
    **Precomputed Visibility Override Volume**, the only difference being that this
    volume automatically stores the visibility of the actors in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger Volume**: This is the same as the trigger actors, which were discussed
    earlier. One of the differences is that that while trigger actors come in a predefined
    shape, you can alter the shape of a trigger Volume using the **Edit Geometry**
    Mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One more thing that you should know about volumes is that just like with BSP
    brushes, you can edit their shapes to create your own custom shaped volume. The
    way to edit is the same as that of BSP brushes. In the **Modes** panel, clicking
    on the **Edit Geometry** mode will switch to the editing mode. Once done, you
    can click on any volume you want in order to change and make the desired changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Volumes to the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know what Volumes are and the types of Volumes available, let us
    go ahead and add a few of them to our level.
  prefs: []
  type: TYPE_NORMAL
- en: Lightmass Importance Volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is advisable to use the Lightmass Importance Volume, since it reduces the
    rendering time (light building time). We are going to set its dimensions so that
    it encapsulates all of the four rooms in the game. Simply drag the actor from
    the **Modes** panel and drop it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Lightmass Importance Volume](img/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Lightmass Importance Volume is represented by a yellow colored cube. Set
    its dimensions such that it encapsulates all of the four rooms in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Lightmass Importance Volume](img/image00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you were to build the lighting now, you would notice that the building process
    takes relatively less time, and the areas outside the rooms are now completely
    dark. The engine now focuses mainly on what is inside the volume to produce high-quality
    lighting, and anything outside of it will be of lower quality, in terms of lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Nav Mesh Bounds Volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, add the **Nav Mesh Bounds Volume**. If you wish to have an AI character
    in your game, a **Nav Mesh Bounds Volume** is an important component. As mentioned
    previously, this volume is basically one within which the AI character moves and
    interacts with the world. When designing your game, you should know where all
    the AI-controlled characters will move around in the game and what objects they
    can interact with, and then place your volume accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Grab the **Nav Mesh Bounds Volume** and drag it into the screen. We are going
    to require the volume in room 3 and room 4\. The volume is represented by a gray
    cube.
  prefs: []
  type: TYPE_NORMAL
- en: Room 3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Place the **Nav Mesh Bounds** **Volume** on and near the pit, opposite the pedestals
    with the switches.
  prefs: []
  type: TYPE_NORMAL
- en: 'When placing this volume, it is advisable to turn on **Navigation** in the
    **Show** menu. In the **Viewport Toolbar**, click on **Show** and check the **Navigation
    option** to have it appear in the Viewport. Once toggled, you will see that any
    surface, actor, or any other physical object (or parts of them) inside the volume
    will have a bright green color on them. This is a visual indicator of where the
    AI will be active. It will ignore anything outside of itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 3](img/image00310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned earlier, any part of a surface or object that the volume overlaps
    with will be green. Let us move on to room 4.
  prefs: []
  type: TYPE_NORMAL
- en: Room 4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In room 4, we are going to need a big Nav Mesh Bounds Volume, one that covers
    almost the whole room. Place the Volume and move its sides using the Geometry
    Editing mode. After setting the dimensions, it should look something like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 4](img/image00311.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our AI character will now know where to move about in the level (The area highlighted
    in green).
  prefs: []
  type: TYPE_NORMAL
- en: All Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, we have the **All Classes** section, in which all of the classes and
    volumes we have discussed so far are listed. Additionally, there are certain actors
    that are not displayed in the previous three sections and are only accessible
    via the **All Classes** section.
  prefs: []
  type: TYPE_NORMAL
- en: '![All Classes](img/image00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many such actors, some of which are beyond the scope of this guide.
    We will only talk about some of the actors that are in the **All Classes** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ambient Sound Actor**: This is an actor that you can use to play audio or
    sound effects in your game. It also emulates real-world sounds, in that the closer
    you are to the source, the louder the sound will get, and conversely, the further
    you are from the source, the fainter it will get.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera**: A **Camera** actor is one through which you see the virtual world.
    By default, your character class already has a camera, but if you want to import
    your own character, a **Camera** actor is an essential component. It is also used
    in cutscenes, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default Pawn**: A **Default Pawn** actor is a simple spherical actor with
    built-in flying mechanics, static mesh, spherical collision, and so on, which
    you can use for simple AI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Landscape**: A different way of switching to the landscape mode can be found
    here. If you drag the landscape actor from here and drop it on the screen, the
    mode will change to Landscape mode, wherein you can place your terrain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level Bounds**: A **Level Bounds** actor, when placed in the level, automatically
    updates and resizes to encapsulate the entire world. It can be used to calculate
    the size of the level and the world. Just keep in mind that if your level has
    a skybox or a skydome, the volume will resize and include that as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matinee Actor**: Matinee is a powerful tool used to create cinematics, set
    pieces, and so on. There are two ways of adding a Matinee actor. The first way
    is through the Viewport Toolbar. Simply click on **Matinee**, and select **Add
    Matinee** when the menu opens. The other way is with this option. You can drag
    the actor from the **Modes** panel and drop it on the level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nav Link Proxy**: The **Nav Link Proxy** actor is used if an AI character
    has to perform actions, such as dropping off or jumping off a ledge, jumping between
    gaps, and so on. It allows the AI character to leave the Nav Mesh temporarily.
    (We will return to this in the next chapter, when we talk about AI.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target Point**: **Target Point** actors are used to get the coordinates of
    a particular point in the level. They can also be used for AI characters. If you
    want to have your AI character follow a particular path, or have it patrol a certain
    area, you should use target points. Also, keep in mind that Target Points should
    be placed inside the Nav Mesh Bounds Volume, otherwise the AI actor will ignore
    them, even if you have it scripted to move towards the said Target Point. Target
    points can also be used if you want your character to teleport to a particular
    destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text Render**: The **Text Render** actor, as the name might suggest, is used
    to render text in the game. If you want your game to have popup text (for tutorials
    or something similar), this is what you should use. You can import your own font
    and create your own text render.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Blueprints**: Although not a single specific actor per se, all of the
    Class Blueprints that you create in your project are displayed here. What a Class
    Blueprint exactly is will be discussed in the next chapter. For now, the only
    thing you need to know and remember is that all of the classes you create are
    also accessible from here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding actors from All Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have discussed some of the actors found in All Classes, let us go
    ahead and add a few of them to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we are going to add is a Camera Actor. As a part of the **tutorial**,
    we are going to have a small cut-scene in which we will show the door opening
    when the player has placed the key cube on the pedestal (so that the player understands
    what the key cube is for and what it does).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, drag the **CameraActor** from the All Classes panel and place it on the
    level. Once done, set it in such a way that it faces the door. The following screenshot
    is an example of where you can place your camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Camera](img/image00313.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The small window on the bottom-right corner of the screen shows the view from
    the second camera, which you can use to properly adjust its position until you
    can see the door clearly. Any time you select any **CameraActor**, the window
    opens, showing you the view from the selected **CameraActor**. We are going to
    need this when we create our cut-scene in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Matinee actors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are also going to place several Matinee actors. Instead of moving our doors
    and platforms for our AI characters via scripting (or in this case, blueprint),
    we are going to implement said features with the help of Matinee. We will animate
    the opening of the door and the drawing of the animation in **Unreal Matinee**
    and call it whenever the player interacts with the appropriate trigger.
  prefs: []
  type: TYPE_NORMAL
- en: To add a Matinee actor, drag it from the **Modes** panel and place it near the
    door.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although where you place the Matinee actor does not matter, to prevent confusion
    and to make things more convenient, you should place it near the actor(s) you
    want to move or edit using Matinee.
  prefs: []
  type: TYPE_NORMAL
- en: '![Matinee actors](img/image00314.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Just place the Matinee actors like this for all the doors. We still have to
    place more Matinee actors, but we will do so later.
  prefs: []
  type: TYPE_NORMAL
- en: Target Point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next up, we are going to place a couple of Target Point actors. As mentioned
    previously, Target Points are useful for moving AI characters. We will have a
    fairly simple AI, one which moves in a specified path, stops when it hits a switch,
    and respawns if it falls in the pit.
  prefs: []
  type: TYPE_NORMAL
- en: Room 3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In room 3, place two target points: one where the AI character will be initially
    and the other where the switch will be. When the AI character falls into the pit,
    it will respawn at the first Target Point. When the player activates it, the AI
    character will go to the second Target Point.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 3](img/image00315.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The actors are depicted by a small target icon. Let us now place them in room
    4.
  prefs: []
  type: TYPE_NORMAL
- en: Room 4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In room 4, we are going to place a couple of Target Point actors, since the
    AI character will take a more nonlinear route.
  prefs: []
  type: TYPE_NORMAL
- en: '![Room 4](img/image00316.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is the top view of room 4\. The player will start from
    the left-hand side and will have to direct the AI character towards the right.
    Also, as you can see, we have placed seven Target Point actors. The path the AI
    character will take is shown by the red line. With that done, we have fully placed
    our Target Point actors. With that, we have placed all of the classes, volumes,
    and other actors in our level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the actors present in the Modes panel
    that are vital to the functionality of the game, and some that enhance the overall
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from talking about them, we also placed some of them in our level. We
    are now close to making our game. In the next chapter, we are going to talk about
    Blueprints—probably the most important topic we will be covering in our guide.
    Without them, there would be no interactivity in the game. So, let us start scripting
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
