- en: Starting Out with Functions - A Core Concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml), *Thinking Functionally
    - A First Example*, we went over an example of FP thinking, but let''s now go
    to the basics, and review functions. In [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml),
    *Becoming Functional - Several Questions*, we mentioned that two important JS
    features were functions as first-class objects and closures. Now, in this chapter,
    let''s:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine some key ways of defining functions in JS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go in detail regarding arrow functions, which are closest to the lambda calculus
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce the concept of *currying*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisit the concept of functions as first-class objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll also consider several FP techniques, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Injection, as needed for sorting with different strategies and other uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks and promises, introducing the *continuation passing* style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Polyfilling* and *stubbing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediate invocation schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All about functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with a short review of functions in JS and their relationship
    to FP concepts. We can start something we mentioned in previous chapters, about
    functions as first-class objects, and then go on to several considerations about
    their usage in JS.
  prefs: []
  type: TYPE_NORMAL
- en: Of lambdas and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In lambda calculus terms, a function can look like *λx.2*x*. The understanding is
    that the variable after the *λ* character is the parameter for the function, and
    the expression after the dot is where you would replace whatever value is passed
    as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you sometimes wonder about the difference between arguments and parameters,
    a mnemonic with some alliteration may help: *Parameters are Potential, Arguments
    are Actual.* Parameters are placeholders for potential values that will be passed,
    and arguments are the actual values passed to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying a function means that you provide an actual argument to it, and that
    is written in the usual way, by using parentheses. For example,  *(λx.2*x)(3)*
    would be calculated as 6\. What's the equivalent of these lambda functions in
    JS? That's an interesting question! There are several ways of defining functions,
    and not all have the same meaning.
  prefs: []
  type: TYPE_NORMAL
- en: A good article showing the many ways of defining functions, methods, and more,
    is *The Many Faces of Functions in JavaScript*, by Leo Balter and Rick Waldron,
    at [https://bocoup.com/blog/the-many-faces-of-functions-in-javascript](https://bocoup.com/blog/the-many-faces-of-functions-in-javascript)--give
    it a look!
  prefs: []
  type: TYPE_NORMAL
- en: 'In how many ways can you define a function in JS? The answer is, *probably
    in more ways than you thought!* At the very least, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a named function declaration: `function first(...) {...};`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'an anonymous function expression: `var second = function(...) {...};`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a named function expression: `var third = function someName(...) {...};`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'an immediately-invoked expression: `var fourth = (function() { ...; return
    function(...) {...}; })();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a function constructor: `var fifth = new Function(...);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'an arrow function: `var sixth = (...) => {...};`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, if you wanted, you could add object method declarations, since they actually
    imply functions as well, but that's enough.
  prefs: []
  type: TYPE_NORMAL
- en: JS also allows defining generator functions as in `function*(...) {...}` that
    actually return a `Generator` object and `async` functions that really are a mix
    of generators and promises. We won't be using these kinds of functions, but read
    more about them at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*) and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)--they
    can be useful in other contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the difference between all these ways of defining functions, and why
    should we care? Let''s go over them, one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: The first definition, a standalone declaration starting with the `function`
    keyword, is probably the most used in JS and defines a function named `first`(that
    is, `first.name=="first"`). Due to *hoisting*, this function will be accessible
    everywhere in the scope where it's defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about hoisting at [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
    and keep in mind that it applies only to declarations, but not to initializations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second definition, assigning a function to a variable, also produces a
    function, but an *anonymous*(that is, no name) one. However, many JS engines are
    capable of deducing what the name should be, and set `second.name=="second"`(check
    the following code, which shows a case where the anonymous function gets no name
    assigned). Since the assignment isn''t hoisted, the function will only be accessible
    after the assignment has been executed. Also, you''d probably prefer defining
    the variable with `const` rather than`var` because you wouldn''t (*shouldn''t*)
    be changing the function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The third definition is the same as the second, except that the function now
    has its own name: `third.name === "someName"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a function is relevant when you want to call it, and also if you
    plan to do recursive calls; we'll come back to this in [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml),
    *Designing Functions - Recursion*. If you just want a function for, say, a callback,
    you can do without a name. However, note that named functions are more easily
    recognized in an error traceback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth definition, with an immediately-invoked expression, lets you use
    a closure. An inner function can use variables or other functions, defined in
    its outer function, in a totally private, encapsulated, way. Going back to the
    counter making function that we saw in the *Closures section*of [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml),
    *Becoming Functional - Several Questions*, we could write something like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Study the code carefully: the outer function receives an argument (77, in this
    case) that is used as `count`''s initial value (if no initial value is provided,
    we start at zero). The inner function can access `count` (because of the closure),
    but the variable cannot be accessed anywhere else. In all aspects, the returned
    function is a common function; the only difference is its access to private elements.
    This is also the base of the *module* pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth definition isn''t safe, and you shouldn''t use it! You pass the arguments
    names, and then the actual function body as a string in the last argument -- and
    the equivalent of `eval()` is used to create the function, which could allow for
    many dangerous hacks, so don''t do this! Just to whet your curiosity, let''s see
    an example, rewriting the very simple  `sum3()` function we saw back in the *Spread*
    section of [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming
    Functional - Several Questions*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This sort of definition is not only unsafe, but has some other quirks, such
    as not creating closures with their creation contexts, and always being global
    instead. See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    for more on this, but remember that using this way of creating functions isn't
    a good idea!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last definition using an arrow `=>` definition is the most compact
    way to define a function and the one we'll try to use whenever possible. We'll
    get into more detail in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions - the modern way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if arrow functions pretty much work as the other functions, there are some
    important differences with usual functions. These functions can implicitly return
    a value, the value of `this` is not bound, and there is no `arguments` object.
    Let's go over these three points.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some extra differences: arrow functions cannot be used as constructors,
    they do not have a `prototype` property, and they cannot be used as generators
    because they don''t allow the `yield` keyword. For more details on these points,
    see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this).'
  prefs: []
  type: TYPE_NORMAL
- en: Returning values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In lambda style, functions only consist of a result. For the sake of brevity,
    the new arrow functions provide a syntax for this. When you write something like
    `(x,y,z) =>` followed by an expression, a return is implied. For instance, the
    following two functions actually do the same as the `sum3()` function we showed
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you want to return an object, then you must use parentheses, or otherwise,
    JS will assume code is meant.
  prefs: []
  type: TYPE_NORMAL
- en: '"A matter of style: when you define an arrow function with only one parameter,
    you can omit the parentheses around it. For consistency, I prefer always including
    them. However, the formatting tool I use, prettier, doesn''t approve. Feel free
    to choose your style!"r!'
  prefs: []
  type: TYPE_NORMAL
- en: Handling the this value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A classic problem with JS is the handling of `this` -- whose value isn''t always
    what you expect it to be. ES2015 solved this with arrow functions, which inherit
    the proper `this` value, so problems are avoided. To see an example of the possible
    problems, in the following code, by the time the timeout function is called, `this`
    will point to the global (`window`) variable instead of the new object, so you''ll
    get an *undefined* in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two classic ways of solving this with old-fashioned JS5, plus the
    arrow way of working:'
  prefs: []
  type: TYPE_NORMAL
- en: One solution uses a closure, and defines a local variable (usually  named `that`or
    sometimes `self`), which will get the original value of `this` so it won't be undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way uses `.bind()`, so the timeout function will be bound to the
    correct value of `this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the third, more modern way, just uses an arrow function, so `this` gets the
    correct value (pointing to the object) without further ado
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also be using `.bind()`.  See the Of lambdas and etas section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the three solutions in actual code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Working with arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional
    - Several Questions*, and [Chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml),
    *Thinking Functionally - A First Example*, we saw some uses of the spread ( `...`)
    operator. However, the most practical usage we''ll be making of it, has to do
    with working with arguments; we''ll see some cases of this in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*. Let''s review our `once()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Why are we writing `return (...args) =>` and afterwards `func(...args)`? The
    key has to do with the more modern way of handling a variable number (possibly
    zero) of arguments. How did you manage such kinds of code in older versions of
    JS? The answer has to do with the `arguments` object (*not* an array!) that lets
    you access the actual arguments passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: For more on this, read  [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments.](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments)
  prefs: []
  type: TYPE_NORMAL
- en: 'In JS5 and earlier, if we wanted a function to be able to process any number
    of arguments, we had to write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first log shows that `arguments` is actually an object; the second log corresponds
    to a simple array. Also, note the complicated way needed to call `somethingElse()`,
    which requires using `.apply()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would be the equivalent code in ES8? The answer is much shorter, and that''s
    why we''ll be seeing several examples of usage of the spread operator throughout
    the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The points to remember are:'
  prefs: []
  type: TYPE_NORMAL
- en: By writing `listArguments2(...args)` we immediately and clearly express that
    our new function receives several (possibly zero) arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need not do anything to get an array. The console log shows that `args`
    is really an array without any further ado.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing `somethingElse(...args)` is much more clear than the alternative way
    (using `.apply()`) that we had to use earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the way, the `arguments` object is still available in ES8\. If you want
    to create an array from it, you have two alternative ways of doing so, without
    having to recur to the `Array.prototype.slice.call` trick:'
  prefs: []
  type: TYPE_NORMAL
- en: use the `.from()` method, and write`var myArray=Array.from(arguments)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or even more simply, say `var myArray=[...arguments]`, which shows yet another
    type of usage of the spread operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we get to higher-order functions, writing functions that deal with other
    functions, with a possibly unknown number of parameters, will be commonplace.
    ES8 provides a much shorter way to do so, and that's why you'll have to get accustomed
    to this usage; it's worth it!
  prefs: []
  type: TYPE_NORMAL
- en: One argument or many?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's also possible to write functions that return functions, and in [Chapter
    6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions - Higher-Order
    Functions*, we will be seeing more of this. For instance, in the lambda calculus,
    you don't write functions with several parameters, but only with one, by applying
    something called *currying*(why would you do this? Hold that thought; we'll come
    to that).
  prefs: []
  type: TYPE_NORMAL
- en: Currying gets its name in memory of Haskell Curry, who developed the concept.
    Note that he is also remembered in the name of an FP language, *Haskell*; double
    recognition!
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the function we saw previously that sums three numbers, would
    be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Why did I change the function''s name? Simply put, because this is *not* the
    same function as previously. As is, though it can be used to produce the very
    same results as our earlier function, it differs in an important way: how do you
    use it? Say, to sum the numbers 1, 2, and 3? You would have to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Test yourself before reading on, and mull on this: what would have been returned
    if you had written `altSum3(1,2,3)` instead?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: It would not be a number! For the full answer, keep reading.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this work? Separating it in many calls can help; this would be the
    way the previous expression is actually calculated by the JS interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Think functionally! The result of calling `altSum3(1)` is, according to the
    definition, a function, which in virtue of a closure resolves to be equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `altSum3()`function is meant to receive a single argument, not three! The
    result of this call, `fn1`, is also a single argument function. When you do  `fn1(2)`,
    the result is again a function, also with a single parameter, equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And when you calculate `fn2(3)`, a value is finally returned; great! As we said,
    the function does the same kind of calculations as we had earlier seen, but in
    an intrinsically different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think currying is just a peculiar trick: who would want to only use
    single-argument functions? You''ll see the reasons for this, when we consider
    how to join functions together in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, or [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types*, where it won''t be feasible
    to pass more than one parameter from one step to the next.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of *first-class objects*means that functions can be created, assigned,
    changed, passed as parameters, or returned as result of yet other functions, in
    the very same way that you can do with, say, numbers or strings. Let''s start
    with their definition. When you define a function in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is (almost) equivalent to writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Except for *hoisting*. JS moves all definitions to the top of the current scope,
    but not assignments; so, with the first definition you can invoke `xyzzy(...)`
    from any place in your code, but with the second you cannot invoke the function
    until the assignment has been executed.
  prefs: []
  type: TYPE_NORMAL
- en: See the parallel with the Colossal Cave Adventure Game? Invoking `xyzzy(...)`anywhere
    won't always work! And, if you never played that famous interactive fiction game,
    try it online -- for example, at [http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure](http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure) or [http://www.amc.com/shows/halt-and-catch-fire/colossal-cave-adventure/landing](http://www.amc.com/shows/halt-and-catch-fire/colossal-cave-adventure/landing).
  prefs: []
  type: TYPE_NORMAL
- en: 'The point we want to make, is that a function can be assigned to a variable
    -- and can also be reassigned, if desired. In a similar vein, we can define functions
    *on the spot*, when they are needed. We can even do this without naming them:
    as with common expressions, if used only once, then you don''t need to name it
    or store it in a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: A React+Redux reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see another example that involves assigning functions. As we mentioned earlier
    in this chapter, React+Redux works by dispatching actions that are processed by
    a reducer. Usually, the reducer includes code with a switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Providing `initialState` as a default value for `state` is a simple way of initializing
    the global state the first time around. Pay no attention to that default; it's
    not relevant for our example, and I included it just for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: 'By taking advantage of the possibility of storing functions, we can build a
    *dispatch table*and simplify the preceding code. First, we would initialize an
    object with the code for the functions for each action type. Basically, we are
    just taking the preceding code, and creating separate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have stored the different functions that process each type of action, as
    attributes in an object that will work as a dispatcher table. This object is created
    only once and is constant during the execution of the application. With it, we
    can now rewrite the action processing code in a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze it: given the action, if `action.type` matches an attribute
    in the dispatching object, we execute the corresponding function, taken from the
    object where it was stored. If there isn''t a match, we just return the current
    state, as Redux requires. This kind of code wouldn''t be possible if we couldn''t
    handle functions (storing and recalling them) as first-class objects.'
  prefs: []
  type: TYPE_NORMAL
- en: An unnecessary mistake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is, however, a common (though in fact, harmless) mistake usually done.
    You often see code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What does this code do? The idea is that a remote URL is fetched, and when the
    data arrives, a function is called -- and this function itself calls `processResult`
    with `data` as an argument. That is to say, in the `then()` part, we want a function
    that, given `data`, calculates `processResult(data)`... don't we already have
    such a function?
  prefs: []
  type: TYPE_NORMAL
- en: 'A small bit of theory: In lambda calculus terms, we are replacing λx.func x
    by simply a function -- this is called an eta conversion, more specifically an
    eta reduction. (If you were to do it the other way round, it would be an eta abstraction.)
    In our case, it could be considered a (very, very small!) optimization, but its
    main advantage is shorter, more compact code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, the rule we can apply is that whenever you see something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You may replace it with just `someOtherFunction`. So, in our example, we can
    directly write what follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code is exactly equivalent to the previous way (or, infinitesimally quicker,
    since you avoid one function call) but simpler to understand... or not?
  prefs: []
  type: TYPE_NORMAL
- en: 'This programming style is called pointfree style or *tacit* style, and its
    main characteristic is that you never specify the arguments for each function
    application. An advantage of this way of coding, is that it helps the writer (and
    the future readers of the code) think about the functions themselves and their
    meanings, instead of working at low level, passing data around and working with
    it. In the shorter version of the code, there are no extraneous or irrelevant
    details: if you understand what the called function does, then you understand
    the meaning of the complete piece of code. In our text, we''ll often (but not
    necessarily always) work in this way.'
  prefs: []
  type: TYPE_NORMAL
- en: Unix/Linux users may already be accustomed to this style, because they work
    in a similar way when they use pipes to pass the result of a command as an input
    to another. When you write something as ls | grep doc | sort the output of ls
    is the input to grep, and the latter's output is the input to sort -- but input arguments
    aren't written out anywhere; they are implied. We'll come back to this in the *PointFree
    Style* section of [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting
    Functions - Pipelining and Composition*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is, however, a case you should be aware of: what happens if you are calling
    an object''s method? If your original code had been something along the lines
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the seemingly obvious transformed code would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Why? The reason is that in the original code, the called method is bound to
    an object (`myObject`) but in the modified code, it isn''t bound, and it is just
    a `free`function. We can then fix it in a simple way by using `bind()` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a general solution. When dealing with a method, you cannot just assign
    it; you must use `.bind(`so the correct context will be available. Code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Should be converted to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Read more on `.bind()` at[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind).
  prefs: []
  type: TYPE_NORMAL
- en: This looks rather awkward, and not too elegant, but it's required so the method
    will be associated to the correct object. We will see one application of this
    when we *promisify* functions in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing
    Functions - Higher-Order Functions*. Even if this code isn't so nice to look at,
    whenever you have to work with objects (and, remember, we didn't say that we would
    be trying to aim for fully FP code and that we would accept other constructs if
    they made things easier) you'll have to remember to bind methods before passing
    them as first-class objects, in pointfree style.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions in FP ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several common coding patterns that actually take advantage of FP
    style, even if you weren't aware of it. Let's then get to examine them, and point
    out the functional aspects of the code, so you can get more accustomed to this coding
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Injection - sorting it out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A first example of passing functions as parameters is provided by the `Array.prototype.sort()`
    method. If you have an array of strings, and you want to sort it, you can just
    use something like the following code. For example, to alphabetically sort an
    array with the colors of the rainbow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we didn't have to provide any parameters to the `.sort()` call, but
    the array got sorted perfectly well. By default, this method sorts strings according
    to their ASCII internal representation. So, if you use this method to sort an
    array of numbers, it will fail, since it will decide that 20 must be between 100
    and 3, because *100* precedes *20* --taken as strings!-- and the latter precedes
    *3*... this needs fixing! The code below shows the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But, let''s forget numbers for a while, and keep to sorting strings. We want
    to ask ourselves: what would happen if we wanted to sort some Spanish words (*palabras*)
    -- but following the appropriate locale rules? We would be sorting strings, but
    results wouldn''t be correct, anyhow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For language or biology buffs, `"ñandú"` in English is `"rhea"`, a running bird
    somewhat similar to ostriches. There aren't many Spanish words beginning with
    "ñ", and we happen to have these birds in my country, Uruguay, so that's the reason
    for the odd word!
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops! In Spanish, `"ñ"` comes between `"n"` and `"o"`, but `"ñandú"` got sorted
    at the end. Also, `"mítico"` (in English, `"mythical"`; note the accented `"i"`)
    should appear between `"mano"` and`"musical"`, because the tilde should be ignored.
    The appropriate way of solving this is by providing a comparison function to `sort()`.
    In this case, we can use the `localeCompare()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `a.localeCompare(b,"es")` call compares strings `a` and `b`, and returns
    a negative value if `a` should precede `b`, a positive value if `a` should follow
    `b`, and 0 if `a` and `b` are the same -- but, according to Spanish (`"es"`) ordering
    rules. Now things are right! And the code could become clearer by introducing
    a new function, with an understandable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In upcoming chapters we will be discussing how FP lets you write code in a
    more declarative fashion, producing more understandable code, and this sort of
    small change helps: readers of the code, when they get to the sort, will immediately
    deduce what is being done, even if the comment wasn''t present.'
  prefs: []
  type: TYPE_NORMAL
- en: This way of changing the way the `sort()` function works by injecting different
    comparison functions, is actually a case of the *Strategy*design pattern. We'll
    be seeing more about this in [Chapter 11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml),
    *Implementing Design Patterns - The Functional Way*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Providing a sort function as a parameter (in a very FP way!) can also help
    with several other problems, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sort()` only works with strings. If you want to sort numbers (as we tried
    to do earlier above) you have to provide a function that will compare numerically.
    For example, you would write something like `myNumbers.sort((a,b) => a-b)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to sort objects by a given attribute, you will use a function that
    compares to it. For example, you could sort people by age with something along
    the lines of ``myPeople.sort((a,b) => a.age - b.age)``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on the `localeCompare()` possibilities, see[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
    You can specify which locale rules to apply, in which order to place upper/lower
    case letters, whether to ignore punctuation and much more -- but be careful; not
    all browsers may support the needed extra parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example, that you have probably used before -- but it's an
    FP pattern, after all. Let's move on to an even more common usage of functions
    as parameters, when you do Ajax calls.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks, promises, and continuations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the most used example of functions passed as first-class objects has
    to do with callbacks and promises. In Node.JS, reading a file is accomplished
    asynchronically with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `readFile()` function requires a callback, which in this example is just
    an anonymous function, that gets called when the file reading operation is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a more modern programming style, you would use promises or async/await..
    For instance, when doing an Ajax web service call, using the more modern `fetch()`
    function, you could write something along the lines of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you had defined appropriate `processData(data)` and `processError(error)`
    functions, the code could have been shortened to `fetch("some/remote/url").then(processData).catch(processError)`
    along the lines that we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: Continuation Passing Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code, in which you call a function but also pass another function
    that is to be executed when the input/output operation is finished, can be considered
    a case of CPS - *Continuation Passing Style*. What is this way of coding? A way
    of putting it, is by thinking about this question: how would you program if using
    the `return` statement was forbidden?'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, this may appear to be an impossible situation. We can get
    out of our fix, however, if we grant this: you are allowed to pass a callback
    to the called function, so when that procedure is ready to return to the caller,
    instead of actually returning, it shall invoke the passed callback. In these terms,
    the callback provides the called function with the way to continue the process,
    and thus the name *Continuation*. We won''t get into this now, but in [Chapter
    9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing Functions - Recursion*,
    we will study it in depth. In particular, CPS will help to avoid an important
    recursion restriction, as we''ll see.'
  prefs: []
  type: TYPE_NORMAL
- en: Working out how to use continuations is sometimes challenging, but always possible.
    An interesting advantage of this way of coding, is that by specifying yourself
    how the process is going to continue, you can go beyond all the usual structures
    (`if`, `while`, `return`, and so on) and implement whatever mechanisms you may
    want. This can be very useful in some kinds of problems, where the process isn't
    necessarily linear. Of course, this can also lead to you inventing any kind of
    control structures, far worse than the possible usage of `GOTO` statements that
    you might imagine! Figure 3.1 shows the dangers of that practice!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/577e359e-169d-429c-b927-d468d5aa63fd.png)Figure 3.1: What''s the
    worse that could happen if you start messing with the program flow?'
  prefs: []
  type: TYPE_NORMAL
- en: '(Note: This XKCD comic is available online at https://xkcd.com/292/.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are not limited to passing a single continuation. As with promises, you
    can provide two or more alternate callbacks. And this, by the way, can provide
    a solution to another problem: how would you work with exceptions? If we simply
    allowed a function to throw an error, it would be an implied return to the caller
    -- and we don''t want this. The way out is to provide an alternative callback
    (that is, a different continuation) to be used whenever an exception would be
    thrown (in [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building
    Better Containers - Functional Data Types*, we''ll find another solution, with *Monads*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Polyfills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to assign functions dynamically (in the same way you can assign different
    values to a variable) also allows you to work more efficiently when defining *polyfills*.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Ajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back a bit to the times when Ajax started to appear. Given those
    different browsers implemented Ajax calls in distinct fashions, you would always
    have to code around those differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This worked but implied that you would re-do the Ajax check for each and every
    call -- even though the results of the test wouldn''t ever change. There''s a
    more efficient way to do so, and it has to do with using functions as first-class
    objects. We could define *two* different functions, test for the condition only
    once, and then assign the correct function to be used later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code shows two important concepts. First, we can dynamically
    assign a function: when this code runs, `window.getAjax` (that is, the global
    `getAjax` variable) will get one of three possible values, according to the current
    browser. When you later call `getAjax()` in your code, the right function will
    execute, without needing to do any further browser detection tests.'
  prefs: []
  type: TYPE_NORMAL
- en: The second interesting idea is that we define the `initializeGetAjax` function,
    and immediately run it -- this pattern is called IIFE, standing for *Immediately
    Invoked Function Expression*. The function runs, but *cleans after itself*, for
    all its variables are local, and won't even exist after the function runs. We'll
    see more about this later.
  prefs: []
  type: TYPE_NORMAL
- en: Adding missing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This idea of defining a function on the run, also allows us to write *polyfills*that
    provide otherwise missing functions. For example, let''s say that instead of writing
    code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You''d very much prefer using the newer, clearer way, and just write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: What happens if your browser doesn't provide `.includes()`? Once again, we can
    define the appropriate function *on the run*, but only if needed. If `.includes()` is
    available, you need do nothing, but if it is missing, you then define a polyfill
    that will provide the very same workings.
  prefs: []
  type: TYPE_NORMAL
- en: You can find polyfills for many modern JS features at Mozilla's developer site.
    For example, the polyfill we used for includes was taken directly from [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When this code runs, it checks whether the `String` prototype already has the
    includes method. If not, it assigns a function to it that does the same job, so
    from that point onward, you'll be able to use `.includes()` without further worries.
  prefs: []
  type: TYPE_NORMAL
- en: Directly modifying a standard type's prototype object is usually frowned upon,
    because in essence, it's equivalent to using a global variable, and thus prone
    to errors. However, in this case, writing a polyfill for a well established and
    known function, is quite unlikely to provoke any conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you happened to think that the Ajax example shown previously was
    old hat, consider this: if you want to use the more modern `fetch()` way of calling
    services, you will also find that not all modern browsers support it (check[http://caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)
    to verify that) and you''ll have to use a polyfill too, such as the one at[https://github.com/github/fetch](https://github.com/github/fetch).
    Study the code, and you''ll see it basically uses the same method as described
    previously, to see if a polyfill is needed, and to create it.'
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a use case similar in some aspects to polyfill: having a function do
    different work depending on the environment. The idea is to do *stubbing*, an
    idea from testing, which means replacing a function with another that does a simpler
    job, instead of doing the actual work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common case is the usage of logging functions. You may want the application
    to do detailed logging when in development, but not to say a peep when in production. A
    common solution would be writing something along the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This works, but as in the example about Ajax detection, it does more work than
    it
  prefs: []
  type: TYPE_NORMAL
- en: 'about Ajax detection, it does more work than it needs since it checks every
    time if the application is in development. We could simplify the code (and get
    a really, really tiny performance gain!) if we stub out the logging function,
    so it won''t actually log anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even do better with the ternary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit more cryptic, but I prefer it, because it uses a `const`, which
    cannot be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Given that JS allows calling functions with more parameters than arguments,
    and that we aren't doing anything in `myLog()`when we are not in development,
    we could have also written `() => {}` and it would have worked fine. I do prefer,
    however, keeping the same signature, and that's why I specified the `someText`
    argument, even if it wouldn't be used; your call!
  prefs: []
  type: TYPE_NORMAL
- en: Immediate invocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s yet another common usage of functions, usually seen in popular libraries
    and frameworks, that lets you bring into JS (even the older versions!) some modularity
    advantages from other languages. The usual way of writing this is something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Another equivalent style is `(function(){ ... }())` -- note the different placement
    of the parentheses for the function call. Both styles have their fans; pick whichever
    suits you, but just follow it consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also have the same style, but passing some arguments to the function,
    which will be used as the initial values for its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you could also return something from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern itself is called, as we mentioned, *Immediately Invoked Function
    Expression*-- usually simplified to IIFE, pronounced *iffy*. The name is easy
    to understand: you are defining a function and calling it right away, so it gets
    executed on the spot. Why would you do this, instead of simply writing the code
    inline? The reason has to do with scopes.'
  prefs: []
  type: TYPE_NORMAL
- en: Note the parentheses around the function. This helps the parser understand that
    we are writing an expression. If you were to omit the first set of parentheses,
    JS would think you were writing a function declaration instead of an invocation. 
    The parentheses also serve as a visual note, so readers of your code will immediately
    recognize the IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define any variables or functions within the IIFE, because of JS''s
    function scope, those definitions will be internal, and no other part of your
    code will be able to access it. Imagine you wanted to write some complicated initialization,
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'What could go wrong? The problem hinges on the fact that you could (by accident)
    have some function with the same name of any of the three here, and hoisting would
    imply that the *latter* function would be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! If you had used an IIFE, the problem wouldn''t have happened. Also, the
    three inner functions wouldn''t even be visible for the rest of the code, which
    helps keeping the global namescape less polluted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To see an example involving returned values, we could revisit the example from
    [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional
    - Several Questions*, and write the following, which would create a single counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Then, every call `myCounter()` would return an incremented count -- but there
    is no chance that any other part of your code will overwrite the inner `count`
    variable because it's only accessible within the returned function.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3.1 **Uninitialized object?**React+Redux programmers usually code *action creators*to
    simplify the creation of actions that will later be processed by a reducer. Actions
    are objects, which must include a `type` attribute that is used to determine what
    kind of action you are dispatching.  The following code supposedly does that,
    but can you explain the unexpected results?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 3.2\. **Are arrows allowed?** Would everything be the same if you defined `listArguments()`and
    `listArguments2()` using arrow functions, instead of the *classic*way we used,
    with the `function` keyword?
  prefs: []
  type: TYPE_NORMAL
- en: '3.3\. **One liner.**Some line-of-codes-thrifty programmer suggested rewriting
    `doAction2()` as a one-liner... though formatting doesn''t let it look so! What
    do you think: is it correct or isn''t it?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over several ways of defining functions in JS, focusing
    mainly on arrow functions, which have several advantages over standard functions,
    including being more terse. We showed the concept of *currying* (which we'll be
    revisiting later), considered some aspects of functions as first class objects,
    and we finally considered several JS techniques that happen to be fully FP in
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving Properly
    - Pure Functions*, let's delve even more deeply into functions, and thus introduce
    the concept of *pure functions*, which will lead us to even better style programming.
  prefs: []
  type: TYPE_NORMAL
