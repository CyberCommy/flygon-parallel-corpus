- en: '*Chapter 7*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Collections Framework and Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use collections to process data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare objects in different ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort collections of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use collections to build efficient algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the best-suited collection for each use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous lessons, you learned how objects can be grouped together in arrays
    to help you process data in batches. Arrays are really useful but the fact that
    they have a static length makes them hard to deal with when loading an unknown
    amount of data. Also, accessing objects in the array requires you to know the
    array's index, otherwise traversing the whole array is necessary to find the object.
    You also learned briefly about ArrayList, which behaves like an array that can
    dynamically change its size to support more advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In this lesson, you'll learn how ArrayList actually works. You'll also learn
    about the Java Collections Framework, which includes some more advanced data structures
    for some more advanced use cases. As part of this journey, you'll also learn how
    to iterate on many data structures, compare objects in many different ways, and
    sort collections in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also learn about generics, which is a powerful way of getting help from
    the compiler on using collections and other special classes.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Data from Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin, let's go through some fundamentals that we're going to be using
    in the next sections of this lesson.
  prefs: []
  type: TYPE_NORMAL
- en: Binary versus Text Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many types of files in your computer: executable files, configuration
    files, data files, and so on. Files can be split into two basic groups: binary
    and text.'
  prefs: []
  type: TYPE_NORMAL
- en: Binary files are used when human interaction with the files will only be indirect,
    such as executing an application (an executable file), or a spreadsheet file that
    loads inside Excel. If you try to look inside these files, you'll see a bunch
    of unreadable characters. This type of file is very useful because they can be
    made compact to take up less space and be structured so that computers can read
    them quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Text files, on the other hand, contain readable characters. If you open them
    with a text editor, you can see what's in there. Not all of them are meant for
    humans to read and some formats are almost impossible to understand. But the majority
    of text files can be read and easily edited by humans.
  prefs: []
  type: TYPE_NORMAL
- en: CSV Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A comma-separated value (CSV) file is a very common type of text file that
    is used to transport data between systems. CSVs are useful because they are easy
    to generate and easy to read. The structure of such a file is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: One record per line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line is the header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each record is a long string where values are separated from others using a
    comma (values can also be separated by other delimiters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a piece of a file that was extracted from the sample data
    we''ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Reading Files in Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Java has two basic sets of classes that are used to read files: `Stream`, to
    read binary files, and `Reader`, to read text files. The most interesting part
    of how the `io` package is designed is that `Stream` and `Reader` can be combined
    to incrementally add functionality on top of each other. This capability is called
    piping because it resembles the process of connecting multiple pipes to one another.'
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be using a simple example to explain these, along with the help
    of `FileReader` and `BufferedReader`.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileReader` reads characters one at a time. `BufferedReader` can buffer these
    characters to read one line at a time. That simplifies things for us when reading
    a CSV because we can just create a `FileReader` instance, then wrap it with `BufferedReader`,
    and then read line by line from the CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Illustration of the process of reading from a CSV file](img/C09581_Figure_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Illustration of the process of reading from a CSV file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 22: Reading a CSV File'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, you''ll use `FileReader` and `BufferedReader` to read lines
    from a CSV file, split them, and process them like a record:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `ReadCSVFile.java` and add a class with the same name,
    and add a `main` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To start, you need to add a String variable that will get the name of the file
    to be loaded from the command-line argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you create a new `FileReader` and pipe it into `BufferedReader` inside
    a try-with-resource, as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have a file open to read, you can read it line by line. `BufferedReader`
    will give you a new line all the way to the end of the file. When the file ends,
    it will return `null`. Because of that, we can declare a variable line and set
    it in the `while` condition. Then, we need to immediately check whether it''s
    null. We also need a variable that will count the number of lines we read from
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, you increment the line count and ignore line zero, which is
    the header. That''s why we initialized `lineCounter` with `-1` instead of zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you split the line using the `split` method from the `String` class.
    That method receives a separator, which in our case is a comma:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can see how `FileReader` is passed into `BufferedReader` and then never
    accessed again. That's because we only want the lines and we don't care about
    the intermediate process of transforming characters into lines.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You wrote an application that can read and parse a CSV. Feel
    free to dig deeper into this code and understand what happens when you change
    the initial line count value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Building a CSV Reader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you know how to read data from a CSV, we can start thinking about
    abstracting that logic away into its own pipe. Just like `BufferedReader` allows
    you to read a text file line-by-line, the CSV reader allows you to read a CSV
    file record by record. It builds on top of the `BufferedReader` functionality
    and adds the logic of splitting the line using a comma as the separator. The following
    diagram shows how our new pipeline will look with the CSV reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: CSVReader can be added to the chain to read records one by one](img/C09581_Figure_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: CSVReader can be added to the chain to read records one by one'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 23: Building a CSV Reader'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll follow the piping pattern and build a simple `CSVReader`
    that we''ll be using throughout the rest of this lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `CSVReader.java` and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, create a public class that is called `CSVReader` and implements
    the `Closeable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two fields, one field to store `BufferedReader` as `final` where we''re
    going to read from, and another to store the line count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a constructor that receives `BufferedReader` and set it to the field.
    This constructor will also read and discard the first line of the passed-in reader,
    since that is the header and we don''t care about them in this lesson:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `close` method by just calling the `close` method from the underlying
    reader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as `BufferedReader` has a `readLine` method, our `CSVReader` class will
    have a `readRecord` method, which will read the line from `BufferedReader` and
    then return that string, split by a comma. In this method, we''ll keep track of
    how many lines we have read so far. We also need to check whether the reader returned
    a line or not since it can return null, which means it''s finished reading the
    file and has no more lines to give us. If that''s the case, we''ll just follow
    the same pattern and return null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a more elaborate implementation, we could store the header to expose extra
    functionalities for the user of the class, such as fetch value by header name.
    We could also do some tidying and validation on the line to ensure no extra spaces
    are wrapping the values and that they contain the expected amount of values (same
    as the header count).
  prefs: []
  type: TYPE_NORMAL
- en: 'Expose `linecount` with a getter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now your new `CSVReader` is ready to be used! Create a new file called `UseCSVReaderSample.java`,
    with a class of the same name and a `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same pattern we used before to read the lines from the CSV, now
    you can use your `CSVReader` class to read from the CSV file, adding the following
    to your `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: From the preceding snippet, you can see that your code is now much simpler.
    It's focused on delivering the business logic (printing the second value with
    line count) and doesn't care about reading a CSV. This is a great practical example
    of how to create your readers to abstract away logic about processing the data
    coming from files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code to compile, you''ll need to add the imports from the `java.io`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you have already learned from previous lessons, arrays are really powerful,
    but their static nature makes things difficult. Suppose you have a piece of code
    that loads users from some database or CSV file. The amount of data that will
    come from the database or file is unknown until you finish loading all the data.
    If you're using an array, you would have to resize the array on each record read.
    That would be too expensive because arrays can't be resized; they need to be copied
    over and over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some code that illustrates resizing an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To be more efficient, you could initialize the array with a specified capacity
    and trim the array after finishing reading all the records to ensure that it doesn't
    contain any extra empty rows in it. You would also need to ensure that the array
    has enough capacity while you're adding new records into it. If not, you'll have
    to make a new array with enough room and copy data over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 24: Reading Users from a CSV File into an Array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, you''ll learn how to use an array to store an unlimited amount
    of data coming from a data source. In our case, we''ll be using the same users
    CSV that we''ve been using throughout the previous sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `User.java` and add a class with the same name. This class
    will have three fields: `id`, `name`, and `email`. It will also have a constructor
    that can initialize it with all three values. We''ll use this class to represent
    a `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the `User` class, add a `static` method that will create
    a user from values coming as an array of strings. This will be useful when creating
    a `User` from the values read from a CSV:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another file called `IncreaseOnEachRead.java` and add a class with the
    same name and a `main` method that will pass the first argument from the command
    line to another method called `loadUsers`. Then, print the number of users loaded,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this same file, add another method called `loadUsers`, which will return
    an array of users and receive a String called `fileToRead`, which will be the
    path to the CSV file to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, start by creating an empty users array and returning it at
    the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Between those two lines, add the logic to read the CSV record by record using
    your `CSVReader`. For each record, increase the size of the array by one and then
    add a newly created `User` to the last position on the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You now can read from the CSV file and have a reference to all users loaded
    from it. This implements the approach of increasing the array on each record read.
    How would you go about implementing the more efficient approach of initializing
    the array with some capacity and increasing it as needed and trimming it at the
    end?
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 27: Read Users from CSV Using Array with Initial Capacity'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity you're going to read users from the CSV similar to how you
    did in the previous exercise, but instead of growing the array on every read,
    create the array with an initial capacity and grow it as necessary. At the end,
    you'll need to check if the array has empty spaces left and shrink it to return
    an array with exact size as the number of users loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this activity you''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an array with an initial capacity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the CSV from the path passed in from the command line in a loop, create
    users and add them to the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep track of how many users you loaded in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before adding Users to the array, you'll need to check the size of the array
    and grow it if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end, shrink the array as necessary to return the exact number of users
    loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 345.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Collections Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building complex applications, you need to manipulate collections of objects
    in different ways. Initially, the core Java library was limited to only three
    options: Array, Vector, and Hashtable. All of them are powerful in their own way,
    but with time, it became clear that wasn''t enough. People started building their
    own frameworks to deal with more complex use cases such as grouping, sorting,
    and comparing.'
  prefs: []
  type: TYPE_NORMAL
- en: The Java Collections Framework was added to Java Standard Edition to reduce
    programming effort and improve the performance and interoperability of Java applications
    by providing data structures and algorithms that are efficient and easy to use.
    This set of interfaces and implementing classes were designed to provide an easy
    way for Java developers to build APIs that could be shared and reused.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vectors solve the problem of arrays being static. They provide a dynamic and
    scalable way of storing many objects. They grow as you add new elements, can be
    prepared to receive large numbers of elements, and it is easy to iterate over
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take care of the internal array without having to resize it unnecessarily,
    a vector initializes it with some capacity and keeps track of what position the
    last element was added to using a pointer value, which is just an integer that
    marks that position. By default, the initial capacity is 10\. When you add more
    than the capacity of the array, the internal array is copied over to a new one
    that is bigger by some factor, leaving more empty space open so that you can add
    extra elements. The copying process is just like you did manually with the array
    in *Exercise 24*: *Reading Users from a CSV File into an Array*. The following
    is an illustration of how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Illustration of Vectors](img/C09581_Figure_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Illustration of Vectors'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using vectors was the way to get dynamic arrays in Java before the Java Collections
    Framework. However, there were two major problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Lack of a defined interface that was easy to understand and extend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully synchronized, which means it is protected against multi-threaded code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the Java Collections Framework, vectors were retrofitted to comply with
    the new interfaces, solving the first problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 25: Reading Users from a CSV File into a Vector'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since a vector solves the problem of growing and shrinking as needed, in this
    exercise, we''ll rewrite the previous exercise, but instead of handling the size
    of the array, we''ll delegate to a vector. We''ll also start building a `UsersLoader`
    class, which we''ll share in all the future exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `UsersLoader.java` and add a class with the same name
    in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll use this class to add the shared methods so that you can load users
    from CSV files in future lessons. The first one you''ll write is going to load
    users from a CSV into a vector. Add a public static method that returns a Vector.
    In this method, instantiate `Vector` and return it at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Between creating `Vector` and returning it, load the data from the CSV and
    add it to `Vector`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the imports that are required for this file to compile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `ReadUsersIntoVector.java` and add a class with the same
    name and a `main` method in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` method, similar to what we did in the array case, call the method
    that loads users from a CSV into `Vector` and then print the size of `Vector`.
    In this case, use the `loadUsersInVector()` method we created in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the imports for this file to compile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations on finishing one more exercise! This time, you can see that
    your code is much simpler since most of the logic of loading the CSV, splitting
    it into values, creating a user, and resizing arrays is now abstracted away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 28: Reading a Real Dataset Using Vector'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity you'll download a CSV with income information from the United
    States census and do some calculation over the values in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, go to this page: [https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data](https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data).
    To download the CSV you can click on **Adult_Data**. It will open the data file
    in the browser. Download the file and save it to some place in your computer.
    The extension is irrelevant but you''ll need to remember the name of the file
    and the path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about the format of the data in the website or just by opening
    it as a text file. Two things to keep in mind while working with this file:'
  prefs: []
  type: TYPE_NORMAL
- en: There's an extra empty line at the end of the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This file has no header line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an application that will calculate the minimum, maximum and average
    wage in this file. After reading all rows, your application should print these
    results. To accomplish this you''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Load all wages from the file into a Vector of integers using your `CSVReader`.
    You can modify your `CSVReader` to support files without headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate over the values in the Vector and keep track of three values: minimum,
    maximum and sum.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the results at the end. Remember, the average is just the sum divided
    by the size of the Vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 347.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with arrays, you have two ways of iterating over them: you can
    use a `for` loop with an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also iterate using a `for-each` loop, where you don''t have access
    to the index of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When you need to iterate over a vector, you can use the loop with an index,
    just like an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `Vector` in a `for-each` loop, just like an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because `Vector` implements `Iterable`. Iterable is a simple interface
    that tells the compiler that the instance can be used in a `for-each` loop. In
    fact, you could change your `CSVReader` to implement Iterable and then use it
    in a `for-each` loop, just like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterable is a very simple interface; it has only one method that you need to
    implement: `iterator()`. That method returns an iterator. An iterator is another
    simple interface that only has two methods to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hasNext()`: Returns `true` if the iterator still has elements to return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next()`: Fetches the next record and returns it. It will throw an exception
    if `hasNext()` returns `false` before calling this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An iterator represents a simple way of getting things out of a collection. But
    it also has another method that is important in some more advanced contexts, `remove()`,
    which removes the current element that was just fetched from calling `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: This `remove` method is important because when you're iterating on a collection,
    you cannot modify it. This means that if you write a `for-each` loop to read elements
    from the vector and then inside this loop you call `remove(Object)` to remove
    an element from it, `ConcurrentModificationException` would be thrown. So, if
    you want to iterate over a collection using a loop and in this loop you need to
    remove an element from vector, you'll have to use an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must be thinking, "why would it be designed to work like this?" Because
    Java is a multi-threaded language. You won''t learn how to create threads or use
    them in this book because it''s an advanced topic. But the idea behind multi-threading
    is that a piece of data in memory can be accessed by two pieces of code at the
    exact same time. This is possible because of the multi-core capabilities of modern
    computers. With collections and arrays, you have to be very careful when working
    on multi-threaded applications. The following is an illustration of how that happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Illustration of how ConcurrentModificationException occurs.](img/C09581_Figure_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Illustration of how ConcurrentModificationException occurs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`ConcurrentModificationException` is more common than we expect. The following
    is a sample for loop using an iterator that avoids this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 29: Iterating on a Vector of Users'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have a method to load all users from the CSV file, and you know
    how to iterate on a vector, write an application that prints the names and emails
    of all users in the file. To complete this activity, you''ll need to follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java application that loads data from a CSV file in a vector. The
    file will be specified from the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the users in the vector and print a string that is a concatenation
    of their names and emails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 349.
  prefs: []
  type: TYPE_NORMAL
- en: Hashtable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays and vectors are great when dealing with many objects that are to be processed
    in sequence. But when you have a group of objects that need to be indexed by a
    key, for example, some kind of identification, then they become cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter hashtables. They are a very old data structure that was created to solve
    exactly this problem: given a value, quickly identifying it and finding it in
    an array. To solve this, hash tables use a hashing function to uniquely identify
    objects. From that hash, they can use another function (normally a remainder of
    a division) to store the values in an array. That makes the process of adding
    an element to the table deterministic and fetching it very fast. The following
    is an illustration of the process of how a value gets stored in a hashtable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The process behind storing and fetching a value from a hash table](img/C09581_Figure_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The process behind storing and fetching a value from a hash table'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A hashtable uses an array to internally store an entry, which represents a key-value
    pair. When you put a pair in the hashtable, you provide the key and the value.
    The key is used to find where in the array the entry will be stored. Then, an
    entry holding the key and value is created and stored in the position specified.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch the value, you pass in the key from which the hash is calculated and
    the entry can be quickly found in the array.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting feature you get for free from this process is de-duplication.
    Because adding a value with the same key will generate the same hash, when you
    do that, it will overwrite whatever was stored in there previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with vectors, the `Hashtable` class was added to Java before the Collections
    Framework. It suffered from the same two problems that vectors suffered from:
    lack of defined interfaces and being fully synchronized. It also breaks the Java
    naming convention by not following CamelCase for word separation.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, as with vectors, after the introduction of the Collections Framework,
    hashtables was retrofitted to comply with the new interfaces, making them a seamless
    part of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 26: Writing an Application that Finds a User by Email'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, you''ll write an application that reads the users from a
    specified CSV file into a hashtable, using their email as a key. They then receive
    an email address from the command line and search for it in the hashtable, printing
    its information or a friendly message if this isn''t found:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `UsersLoader.java` file, add a new method that will load users into
    a hashtable using the email as a key. Create a `Hashtable` at the beginning and
    return it at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Between creating `Hashtable` and returning it, load the users from the CSV
    and put them in `Hashtable` using `email` as the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Import `Hashtable` so that the file compiles correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `FindUserHashtable.java` and add a class with the same
    name and add a `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In your `main` method, load the users into a `Hashtable` using the method we
    created in the previous steps and print the number of users found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Print some text to inform the user that you''re waiting for them to type in
    an email address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the input from the user by using `Scanner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the email address is in `Hashtable`. If not, print a friendly
    message and exit the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If found, print some information about the user that was found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the necessary imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output in the first case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output in the second case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! In this exercise, you used `Hashtable` to quickly find a user
    by email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 30: Using a Hashtable to Group Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One very common usage of Hashtable, is to group records based on some key. In
    this activity you'll use this to calculate the minimum, maximum and average wages
    from the file downloaded on the previous activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already, go to this page: [https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data](https://github.com/TrainingByPackt/Java-Fundamentals/tree/master/Lesson07/data).
    To download the CSV you can click on **Adult_Data**. As explained before, this
    file contains income data from the United States census.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many attributes that are associated with each wage. For this exercise,
    you'll group the records by the education attribute. Then, as you did before,
    print the minimum, maximum and average wages, but now, for each grouped set wages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this activity you''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the `adult.data` CSV file using the `CSVReader`. This time, you'll load
    the data into a Hashtable where the keys are Strings and the values are Vectors
    of integers. The key is going to be the education attribute and in the vector,
    you'll store all the wages associated with that education.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With all the wages grouped inside the Hashtable, now you can iterate over the
    entries, key-value pairs, and do the same calculation you did in the previous
    activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each entry, print the minimum, maximum and average wages for each education
    level found in the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 351.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes that work with other classes in a generic way, like Vector, didn't have
    a way to explicitly tell the compiler that only one type was accepted. Because
    of that, it uses Object everywhere and runtime checks like `instanceof` and casting
    were necessary everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, Generic was introduced in Java 5\. In this section you'll
    understand better the problem, the solution and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: What was the Problem?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When declaring an array, you tell the compiler what type of data goes inside
    the array. If you try to add something else in there, it won''t compile. Look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say you try to do something similar with `Vector`, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will not help you at all. The same thing goes for `Hashtable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This also occurs when fetching data. When fetching from an array, the compiler
    knows what type of data is in there, so you don''t need to cast it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To fetch data from a collection, you need to cast data. A simple example is
    adding the following code after adding the two elements to the previous `usersVector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It will compile, but it will throw a `ClassCastException` at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This was a big source of bugs for a long time in the Java world. And then generics
    came along and changed everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generics is a way for you to tell the compiler that a generic class will only
    work with a specified type. Let''s have a look at what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic class**: A generic class is a class that has a generic functionality
    which works with different types, like a Vector, that can store any type of object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specified type**: With generics, when you instantiate a generic class, you
    specify what type that generic class will be used with. For example, you can specify
    that you only want to store users in your Vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compiler**: It is important to highlight that a generic is a compile time-only
    feature. There''s no information about generic type definition at runtime. At
    runtime, everything behaves like it was before generics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generic classes have a special declaration that exposes how many types it requires.
    Some generic classes require multiple types, but most only require one. In the
    Javadocs for generic classes, there''s a special angle brackets arguments list
    that specifies how many type parameters it requires, such as in `<T, R>`. The
    following is a screenshot of the Javadoc for `java.util.Map`, which is one of
    the interfaces in the Collections Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Screenshot of the Javadoc for java.util.Map, where it shows the
    generic type declaration](img/C09581_Figure_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Screenshot of the Javadoc for java.util.Map, where it shows the
    generic type declaration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: How to Use Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use generics, when declaring an instance of a generic class, you specify
    what type will be used for that instance using angle brackets. The following is
    how you declare a vector that only handles users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For a hashtable, you need to specify the types for the key and value. For a
    hashtable that would store users with their IDs as keys, the declaration would
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Just declaring the generic types with the correct parameters will solve the
    problems we described earlier. For example, let''s say you are declaring a vector
    so that it only handles users. You would try and add a String to it, as in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this would result in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the compiler ensures that nothing except users will be added to the
    vector, you can fetch data from it without having to cast it. The compiler will
    automatically convert the type for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 27: Finding a User by Text in a Name or Email'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, you''ll write an application that reads users from a CSV
    file into a vector like you did before. You''ll then be asked for a string that
    will be used to filter the users. The application will print some information
    about all the users that contained the passed-in string in their name or email:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `UsersLoader.java` file and set all the methods to use generic versions
    of collections. Your `loadUsersInHashtableByEmail` should look as follows (only
    showing the lines that have changed):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `loadUsersInVector` should look as follows (only showing lines that have
    changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Note:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You don't have to change other places where you called these methods because
    using them as the non-generic version still works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `FindByStringWithGenerics.java` and add a class with the
    same name and a `main` method, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a call to the `loadUsersInVector` method to your `main` method, storing
    the value in a vector with the specified generic type. Print the number of users
    loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, ask the user to type a string and store that in a variable after
    transforming it to lowercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the try-with-resource block, create a variable to count the number of
    users found. Then, iterate over the users from the vector we loaded previously
    and search for the string in the email and name for each user, making sure to
    set all strings to lowercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if `totalFound` is zero, meaning no users were found, print a friendly
    message. Otherwise, print the number of users you found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the first case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the second case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! Now you understand how generics can help you write safe and
    easy code using your collections.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and Comparing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our day-to-day lives, we compare things all the time: cold/hot, short/tall,
    thin/thick, big/small. Objects can be compared using different spectrums. You
    can compare them by color, size, weight, volume, height, width, and so on. When
    comparing two objects, you''re normally interested in finding which one is more
    something (or less something) than the other or whether they are equal on whatever
    measure you''re using.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic scenarios where comparing objects is important: finding
    the maximum (or minimum) and sorting.'
  prefs: []
  type: TYPE_NORMAL
- en: When finding the maximum or minimum, you compare all objects with each other
    and then pick the winner in whatever regard you were looking at. Everything else
    can be ignored. You don't need to keep track of the others, as long as you can
    be sure you're not infinitely comparing the same two objects over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting, on the other hand, is more complicated. You have to keep track of all
    the elements that you have compared so far and you also need to make sure that
    you keep them sorted along the way.
  prefs: []
  type: TYPE_NORMAL
- en: The Collections Framework includes a few interfaces, classes, and algorithms
    that can help you with all of this.
  prefs: []
  type: TYPE_NORMAL
- en: Comparables and Comparators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java, there is an interface that describes how objects can be compared to
    each other. The `java.lang.Comparable` interface is a generic interface that has
    only one method that needs to be implemented: `compareTo(T)`. From the Javadocs,
    `compareTo` should return "a negative integer, zero, or a positive integer as
    this object is less than, equal to, or greater than the specified object".'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how it works, let''s take a String as an example. String implements
    `java.lang.Comparable<String>`, which means you can compare two strings, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If the first object on the comparison is "less" than the second, then it will
    return a negative number (it can be any number and the size means nothing). If
    both are the same, then it will return zero. If the first is more than the second,
    then it will return a positive number (again, size means nothing).
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all well and good until you stumble onto something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: When you go to read the String Javadoc, its `compareTo` method says that it
    "compares two strings lexicographically". This means that it uses the character
    code to check which string comes first. The difference here is that the character
    codes have all the uppercase letters first, then all the lowercase ones. Because
    of that, "A" comes after "B", since B's character code is before A's.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to compare strings alphabetically and not lexicographically?
    As mentioned before, objects can be compared in many different spectrums. Because
    of that, Java provides another interface that can be used to compare two objects:
    `java.util.Comparator`. Classes can implement a comparator using the most common
    use case, like numbers can be compared using their natural order. Then, we can
    create another class that implements `Comparator` to compare objects using some
    other custom algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 28: Creating a Comparator that Compares Strings Alphabetically'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, you''ll create a class that implements `java.util.Comparator<String>`
    and can be used to compare strings alphabetically, and not lexicographically:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `AlphabeticComparator.java` and add a class with the same
    name that implements `java.util.Comparator<String>` (don''t forget the import):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `compareTo` method, you just turn both strings into lowercase and then
    compare them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `UseAlphabeticComparator.java` and add a class with
    the same name with a `main` method in so that you can test your new comparator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now instantiate your class and write some test cases to make sure that your
    class is working as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You wrote your first comparator. Now, let's move on and see
    what else you can do with Comparables and Comparators.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have collections of objects, it's very common to want to sort them
    in some way or other. Being able to compare two objects is the basis for all sorting
    algorithms. Now that you know how to compare objects, it's time to use that to
    add sorting logic to your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many sorting algorithms out there, each one with its own strengths
    and weaknesses. For simplicity, we''ll discuss only two: bubble sort, because
    of its simplicity, and merge sort, because of its stable performance, which is
    why it was picked by the Java core implementers.'
  prefs: []
  type: TYPE_NORMAL
- en: Bubble Sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most naive sorting algorithm is bubble sort, but it's also the simplest
    to understand and implement. It works by iterating over each element and comparing
    it with the next element. If it finds two elements that are not sorted, it swaps
    them and moves on to the next. When it gets to the end of the array, it checks
    how many elements were swapped. It continues this cycle until the number of swapped
    elements in a cycle is zero, which means that the whole array or collection has
    been sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an illustration of how sorting an array with seven elements
    using bubble sort would happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Illustration showing how bubble sort works](img/C09581_Figure_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Illustration showing how bubble sort works'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bubble sort is very space efficient since it doesn't need any extra arrays or
    a place to store variables. However, it uses a lot of iterations and comparisons.
    In the example from the illustration, there's a total of 30 comparisons and 12
    swaps.
  prefs: []
  type: TYPE_NORMAL
- en: Merge Sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bubble sort works, but as you may have noticed, it is really naive and it feels
    like there are a lot of wasted cycles. Merge sort, on the other hand, is much
    more efficient and is based on the divide-and-conquer strategy. It works by recursively
    splitting the array/collection in half until you end up with multiple pairs of
    one element. Then, it merges them back together while sorting at the same time.
    You can see how this works in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Illustration of the merge sort algorithm](img/C09581_Figure_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Illustration of the merge sort algorithm'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In comparison to bubble sort, the number of comparisons for merge sort is much
    smaller – only 13 for the illustrated example. It uses more memory space since
    every merge step needs an extra array to store the data that is being merged.
  prefs: []
  type: TYPE_NORMAL
- en: One good thing that is not explicit in the preceding illustration is that merge
    sort has stable performance since it will always execute the same amount of steps;
    it doesn't matter how shuffled or sorted the data is. Compared to bubble sort,
    the number of swaps can get very high if you get a situation where the array/collection
    is sorted backwards.
  prefs: []
  type: TYPE_NORMAL
- en: Stability is very important for a core library such as the Collections Framework,
    and that's why merge sort was the algorithm that was picked as the implementation
    for sorting in the `java.util.Collections` utility class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 31: Sorting Users'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Write three user comparators: one to compare by ID, one to compare by name,
    and one to compare by email. Then, write an application that loads the unique
    users and prints the users sorted by a field that was picked from an input from
    the command line. To complete this activity, you will need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write three classes that implement `java.util.Comparator<User>`. One that compares
    by ID, one that compares by name, and one that compares by email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the users from the CSV using the method that returns a `Hashtable` instance
    so that you have a collection with unique users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the values from `Hashtable` into a vector so that you can keep them in
    a specified order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read input from the command line to decide what field will be used to sort.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the correct comparator to sort the vector using the `java.util.Collections`
    sort method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 354.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most fundamental part of building applications is processing data. The
    way you store the data is influenced by the way you''ll need to read and process
    it. Data structures define the way you store data. Different data structures optimize
    for different use cases. So far, we have mentioned two ways of accessing data:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequentially, as with an array or vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-value pairs, as with a hashtable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following sections, we'll discuss the basic data structure of interfaces
    that have been added to the Collections Framework and how they differ from each
    other. We'll also dive deeper into each implementation and the use cases they
    solve.
  prefs: []
  type: TYPE_NORMAL
- en: Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most generic interface that is the base for all collections except
    Map. The documentation describes it as representing a collection of objects called
    elements. It declares the basic interface for all collections with the following
    most important methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add(Element)`: Adds an element to the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: Removes all elements from the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains(Object)`: Checks whether an object is in the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(Object)`: Removes the specified element from the collection, if present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()`: Returns the number of elements stored in the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The list interface represents a sequential collection of elements that can grow
    indefinitely. Elements in a list can be accessed by their index, which is the
    position that they were put in, but can change if elements are added between other
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: When iterating over a list, the order that the elements will be fetched in is
    deterministic and will always be based on the order of their indexes, just like
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, Vector was retrofitted to support the Collections
    Framework and it implements the list interface. Let's take a look at the other
    implementations that are available.
  prefs: []
  type: TYPE_NORMAL
- en: '`List` extends `Collection`, so it inherits all the methods we mentioned previously
    and adds some other important methods, mostly associated with position-based access:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add(int, Element)`: Adds an element at the specified position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(int)`: Returns the element at the specified position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf(Object)`: Returns the index of the object or `-1` if not present in
    the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(int, Element)`: Replaces the element at the specified position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subList(int, int)`: Creates a sublist from the original list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArrayList
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like Vector, ArrayList wraps an array and takes care of scaling it as needed,
    behaving just like a dynamic array. The major difference between the two is that
    vectors are fully synchronized. This means that they protect you from concurrent
    access (multi-threaded applications). It also means that on non-concurrent applications,
    which occurs in the majority of the cases, Vector is slower because of the locking
    mechanisms that are added to it. For that reason, it is recommended that you use
    ArrayList, unless you really need a synchronized list.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, for all purposes, ArrayList and Vector can be used
    interchangeably. Their functionality is the same and both implement the same interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedList
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LinkedList is an implementation of List that does not store elements in an
    underlying array, like ArrayList or Vector. It wraps each value in another object
    called a node. A node is an internal class that contains two references to other
    nodes (the next node and the previous node) and the value being stored for that
    element. This type of list is known as a double-linked list because each node
    is linked twice, once in each direction: from the previous to the next and from
    the next to the previous.'
  prefs: []
  type: TYPE_NORMAL
- en: Internally, LinkedList stores a reference to the first and last nodes, so it
    can only traverse the list starting from the beginning or the end. It is not good
    for random or position-based access as with arrays, ArrayLists, and vectors, but
    it is good when adding an undetermined number of elements very fast.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedList also stores a variable that keeps track of the size of the list.
    That way, it doesn't have to traverse the list every time to check the size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration shows how LinkedList is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: How a LinkedList works under the hood.](img/C09581_Figure_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: How LinkedList works under the hood'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you need to store elements associated with keys, you use Maps. As we saw
    previously, Hashtable is a powerful mechanism for indexing objects by some key,
    and after the addition of the Collections Framework, Hashtable was retrofitted
    to implement Map.
  prefs: []
  type: TYPE_NORMAL
- en: The most fundamental property of maps is that they cannot contain duplicate
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maps are powerful because they allow you to see the dataset from three different
    perspectives: keys, values, and key-value pairs. After adding your elements to
    a map, you can iterate over them from any of those three perspectives, giving
    you extra flexibility when fetching data from it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important methods in the `Map` interface are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()`: Remove all keys and values from the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containsKey(Object)`: Check whether the key is present in the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containsValue(Object)`: Check whether the value is present in the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entrySet()`: Return a set of entries with all the key-value pairs in the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(Object)`: Return the value associated with the specified key if present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getOrDefault(Object, Value)`: Return the value associated with the specified
    key if present, otherwise return the specified value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keySet()`: A set containing all keys in the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put(Key, Value)`: Add or replace a key-value pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putIfAbsent(Key, Value)`: Same as the previous method, but won''t replace
    if the key is already present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()`: The number of key-value pairs in this map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()`: Return a collection with all the values present in this map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like `Hashtable`, `HashMap` implements a hash table to store the entries
    of key-value pairs, and it works exactly the same way. Just as Vector is to ArraySet,
    Hashtable is so to `HashMap`. `Hashtable` existed before the Map interface, so
    HashMap was created as a non-synchronous implementation of the hash table.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned before, hash tables, and consequently HashMap, are very fast
    to find elements by key. They are great to use as an in-memory cache where you
    load data that''s been keyed by some field, like you did in *Exercise 26*: *Writing
    an Application that Finds a User by Email*.'
  prefs: []
  type: TYPE_NORMAL
- en: TreeMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TreeMap` is an implementation of Map that can keep key-value pairs sorted
    by key or by a specified comparator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name implies, TreeMap uses a tree as the underlying storage mechanism.
    Trees are very special data structures that are used to keep data sorted as insertions
    happen and at the same time, fetch data with very few iterations. The following
    illustration shows what a tree looks like and how a fetch operation can quickly
    find an element, even in very large trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: A tree data structure being traversed to fetch element](img/C09581_Figure_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: A tree data structure being traversed to fetch an element'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Trees have nodes that represent the branches. Everything starts from a root
    node and expands into multiple branches. At the ends of the leaf nodes, there
    are nodes with no children. TreeMap implements a specific type of tree called
    a red-black tree, which is a binary tree, so each node can have only two children.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedHashMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name of the `LinkedHashMap` class is a bit cryptic because internally it
    uses two data structures to support some use cases that HashMap didn''t support:
    a hash table and a linked list. The hash table is used to quickly add and fetch
    elements from the map. The linked list is used when iterating over the entries
    by whatever means: key, value, or key-value pair. This gives it the ability to
    iterate over the entries in a deterministic order, which is whatever order they
    were inserted in.'
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main characteristic of sets is that they contain no duplicate elements.
    Sets are useful when you want to collect elements and at the same time eliminate
    duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: Another important characteristic about sets is that the order that you fetch
    elements from them varies based on the implementation. This means that if you
    want to eliminate duplicates, you have to think about how you're going to read
    them afterward.
  prefs: []
  type: TYPE_NORMAL
- en: All set implementations in the Collections Framework are based on their corresponding
    Map implementation. The only difference is that they handle the values in the
    set as the keys in the map.
  prefs: []
  type: TYPE_NORMAL
- en: HashSet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By far the most common of all the sets, HashSet uses a HashMap as the underlying
    storage mechanism. It stores its elements in a random order, based on the hashing
    function used in HashMap.
  prefs: []
  type: TYPE_NORMAL
- en: TreeSet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Backed by a TreeMap, `TreeSet` is really useful when you want to store unique
    elements sorted by their natural order (comparables) or using a comparator.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedHashSet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Backed by `LinkedHashMap`, `LinkedHashSet` will keep the insertion order and
    remove duplicates as you add them to the set. It has the same advantages as LinkedHashSet:
    fast insertion and fetching like HashSet, and fast iteration like LinkedList.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 29: Using TreeSet to Print Sorted Users'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Activity 31*: *Sorting Users*, you wrote three comparators that can be
    used to sort users. Let''s use them and TreeSet to make an application that prints
    the sorted users in a much more efficient way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method to your `UsersLoader` class that can load the users into `Set`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Import `Set` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `SortUsersTreeSet.java` and add a class with the same
    name and add a `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Read from the command line what field we''ll sort by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `TreeSet` of users using the specified comparator, load the users
    into it with your new method, and then print the loaded users to the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the first case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here's the output of the second case
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here's the output of the third case
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Here's the output of the fourth case
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! In this exercise, you used TreeSet to sort and eliminate duplicate
    elements while loading them from the CSV file, all at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Queues are a special data structure that respect the First In, First Out (FIFO)
    pattern. This means that it keeps the elements in order of insertion and can return
    the elements starting from the first inserted one while adding elements to the
    end. That way, new work can be enqueued at the end of the queue while work to
    be processed gets dequeued from the front. The following is an illustration of
    this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: A queue that stores work to be processed](img/C09581_Figure_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: A queue that stores work to be processed'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the Collections Framework, a queue is represented by the `java.util.Queue`
    interface. To enqueue an element, you can use `add(E)` or `offer(E)`. The first
    will throw an exception if the queue is full, while the second will just return
    `true` or `false`, telling you whether the operation was successful or not. It
    also has methods to dequeue elements or just check what's at the front of the
    queue. `remove()` will return and remove the element at the front or throw an
    exception if the queue is empty. `poll()` will return the element and remove it
    or return null if the queue is empty. `element()` and `peek()` work the same way,
    but only return the element without removing it from the queue, the first throwing
    an exception and the latter returning null if the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.Deque` is an interface that extends `java.util.Queue` with extra
    methods that allow elements to be added, removed, or peeked at on both sides of
    the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.LinkedList` is an implementation of `java.util.Queue` and `java.util.Deque`
    that also implements `java.util.List`.'
  prefs: []
  type: TYPE_NORMAL
- en: java.util.ArrayDeque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of Queue and Deque uses an array as the underlying data store.
    The array grows automatically to support the data that's added to it.
  prefs: []
  type: TYPE_NORMAL
- en: java.util.PriorityQueue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of Queue uses a heap to keep elements in sort order. The
    order can be given by the element if it implements `java.lang.Comparable` or by
    a passed-in comparator. A heap is a specialized type of tree that keeps elements
    sorted, similar to `TreeMap`. This implementation of queue is great for processing
    elements that need to be processed in some priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 30: Fake Email Sender'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, you will simulate the process of sending emails to users
    using one processor. For this, you''ll write two applications: one that simulates
    sending the email and one that reads from the CSV and invokes the first one for
    each user. The constraint that forces you to use a queue is that only one process
    can run at a time. This means that while the users are loaded from the CSV, you''ll
    enqueue them and send emails whenever possible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `EmailSender.java` with a class and a `main` method in
    it. To simulate sending the email, the class will sleep for a random amount of
    time, up to one second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Create another file called `SendAllEmails.java` with a class and a `main` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `static` field called `runningProcess`. This will represent the send
    email process that is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `static` method that will try to initiate the process of sending an
    email by dequeuing an element from the queue, if the process is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` method, create an `ArrayDeque` of strings that will represent
    the queue of emails to send to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the CSV to read each row from it. You can do this by using `CSVReader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'With the user loaded, we can add its email to the queue and try to send an
    email immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Because reading from a file is, in general, very fast, we''ll simulate a slow
    read by adding some sleep time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside the try-with-resources block, that is, after we''ve finished reading
    all users from the file, we need to ensure we drain the queue. For that, we can
    use a `while` loop that runs while the queue is not empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, it is important to not use 100% of the CPU while you sleep. This
    is very common when processing elements from a queue, like in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can just wait for the last send email process to finish, following
    a similar pattern: check and wait while sleeping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You wrote an application that simulates the sending of emails
    using constrained resources (one process only). This application is ignoring the
    fact that users are duplicated in the file. It also ignores the output of the
    send email process. How would you implement a duplicate send detector and avoid
    that issue? How do you think the output of the send process affects the decision
    of duplicate avoidance?
  prefs: []
  type: TYPE_NORMAL
- en: Properties of Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When picking a data structure to solve a problem, you''ll have to consider
    the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Ordering - If order is important when accessing the data, what order the data
    will be accessed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniqueness - Does it matter if you have the same element multiple times inside
    the collection? How do you define uniqueness?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nullables - Can values be null? If mapping key to values, is the null key valid?
    Does it make sense to use null in either?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following table to determine what collection better suits your use
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.1: Table representing the properties on collections](img/C09581_Table_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 7.1: Table representing the properties on collections'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '"Sorted naturally" means that it will sort based on the element (or key) if
    the element implements `Comparable` or using a passed-in comparator.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing applications, processing data is one of the most fundamental
    tasks. In this lesson, you learned how to read and parse data from files so that
    you're able to process them as part of your application. You also learned how
    to compare objects so that you can sort them in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: As part of processing data, you learned how to store data using basic and advanced
    data structures. Knowing how to efficiently process data is very important so
    that you avoid resource contention scenarios such as running out of memory, or
    requiring too much processing or time to execute the task at hand. A big part
    of processing data efficiently is about picking the right data structures and
    algorithms for the right problems. All the new tools that you have added to your
    belt will help you make the correct decisions when building your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next lesson, we will have a look at some advanced data structures.
  prefs: []
  type: TYPE_NORMAL
