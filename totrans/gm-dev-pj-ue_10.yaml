- en: 11\. Blend Spaces 1D, Key Bindings, and State Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins by creating the Blend Space asset needed to allow movement
    animation blending from idle to walking, and finally to running, based on the
    speed of the player character. We will then implement new key mappings and use
    those mappings in C++ to code gameplay functionality for the player character,
    like sprinting. Lastly, we will create a new animation state machine within our
    character animation blueprint so that the player animations can smoothly transition
    between movement and jumping.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the `SuperSideScroller` player character
    animating correctly when moving around the environment and moving in a way that
    feels best for the game. This means that the player will support an idle, walking,
    and sprinting animation, while also supporting the animations needed for jumping.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we had a high-level look at animation and the development
    of the game design for your `SuperSideScroller` project. You were provided with
    just the beginning steps in the development of the project itself. You also prepared
    the player' characters' animation blueprint, character blueprint, and imported
    all of the required skeletal and animation assets.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the character can move around the level, but is stuck in the
    T-Pose and does not animate at all. This can be fixed by creating a new Blend
    Space for the player character, which will be done in the very first exercise
    of this chapter. Once the Blend Space is complete, you will implement this in
    the character animation blueprint in order for the character to animate while
    moving.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be working with many new functions, asset types, and
    variables in order to achieve the desired movement of the player character. Some
    of these include the `Try Get Pawn Owner` function within the `Animation Blueprint`,
    the `1D Blend space asset` type, and `Input Bindings` in the project configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start this chapter by first learning about Blend Spaces and then creating
    your Blend Space asset that you will need in order to get the player character
    animating while moving.
  prefs: []
  type: TYPE_NORMAL
- en: Blend Spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blend Spaces, as the name suggests, allow you to blend between multiple animations
    based on one or more conditions. Blend Spaces are used in different types of video
    games, but, more often than not, in games where the player can view the entire
    character. Blend spaces are not usually used when the player can only see the
    character arms, such as in the First-Person template project provided in Unreal
    Engine 4, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: The first-person perspective of the default character in the
    First-Person project template in Unreal Engine 4.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.1: The first-person perspective of the default character in the First-Person
    project template in Unreal Engine 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is more common in third-person games where there is a need to use Blend
    Spaces to smoothly blend movement-based animations of the character. A good example
    is the Third-Person template project provided in Unreal Engine 4, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: The third-person perspective of the default character, in the
    First-Person project template in Unreal Engine 4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2: The third-person perspective of the default character, in the
    First-Person project template in Unreal Engine 4'
  prefs: []
  type: TYPE_NORMAL
- en: Blend Spaces allow the player character to blend between animations based on
    a variable, or a set of variables. For example, in the case of *Joel,* from *The
    Last of Us*, his movement animation is based on the speed at which he is moving,
    and this speed is provided by the player through the controller sticks (or joystick).
    With increased speeds, his animation updates from walking, to running, and then
    to sprinting. This is what we are trying to achieve with our character in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the Blend Space asset provided by Unreal Engine when creating
    the `Side Scroller` project template by opening `/Mannequin/Animations/ThirdPerson_IdleRun_2D`.
    This is a 1D Blend Space asset created for the `Side Scroller` mannequin skeletal
    mesh so that the player character can smoothly blend between idle, walking, and
    running animations based on the speed of the character.
  prefs: []
  type: TYPE_NORMAL
- en: If you check `Persona`, in the `Asset Details` panel on the left-hand side,
    you will see the `Axis Settings` category with the `Horizontal Axis` parameter
    where we have settings for this axis, which essentially acts as a variable that
    we can reference in our animation blueprint. Please refer to the image below to
    see the `Axis Settings` within `Persona`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Shown here are the axis settings for the 1D Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.3: Shown here are the axis settings for the 1D Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: Below the preview window, we will also see a small graph with points along the
    line from left to right; one of these points will be highlighted `green`, while
    the others are `white`. We can *left-click* and drag this `green` point along
    the horizontal axis to preview the blended animation based on its value. At speed
    `0`, our character is in `Idle` and, as we move our preview along the axis, the
    animation will begin to blend Walking, followed by `Running`. Please refer the
    following image to view the single-axis graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Highlighted here is the key frame timeline of the 1D Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.4: Highlighted here is the key frame timeline of the 1D Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at 1D Blend Spaces vis-à-vis a normal
    Blend Space.
  prefs: []
  type: TYPE_NORMAL
- en: 1D Blend Space vs Normal Blend Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before moving forward with the 1D Blend Space, let's take a moment to distinguish
    the main differences between a Blend Space and a 1D Blend Space in Unreal Engine 4\.
  prefs: []
  type: TYPE_NORMAL
- en: The Blend Space asset in Unreal is controlled by two variables, represented
    by the *X* and *Y* axes of the Blend Space graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the 1D Blend Space only supports one axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to imagine this as a 2D graph. As you know that each axis has its own direction,
    you can better visualize why and when you would need to use this Blend Space rather
    than a 1D Blend Space, which only supports a single axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say, for example, you wanted to make the player character strafe left and right
    while also supporting forward and backward movement. If you were to map this movement
    out on a graph, it would look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: This is what a Blend Space movement would look like on a simple
    graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.5: This is what a Blend Space movement would look like on a simple
    graph'
  prefs: []
  type: TYPE_NORMAL
- en: Now, visualize the movement for the player character, keeping in mind the fact
    that the game is a `Side Scroller`. The character won't be supporting left or
    right strafing or forward and backward movement. The player character will only
    need to animate in one direction because the `Side Scroller` character rotates
    toward the direction of movement by default. Having to only support one direction
    is why you are using a 1D Blend Space instead of a normal Blend Space.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to set up this type of Blend Space asset for our main character
    and use the Blend Space for the same purpose, for movement-based animation blending.
    In the next exercise, let's start by creating the Blend Space asset together using
    our custom animation assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Creating the CharacterMovement 1D Blend Space'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get the player character to animate while he moves, you need to
    first create a Blend Space as discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will create the Blend Space asset, add the idle animation,
    and update the `CharacterMovement` component so that you assign an appropriate
    walking speed value that corresponds with the Blend Space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `/MainCharacter/Animation` folder in `Content Browser`, where
    all the new animations you imported in the last chapter are located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, *right-click* in the main area of `Content Browser` and, from the drop-down
    menu, hover over the option for `Animation` and, from its additional drop-down
    menu, select `Blend Space 1D` by *left-clicking*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to select `MainCharacter_Skeleton`, and not `UE4_Mannequin_Skeleton`,
    as the skeleton for the Blend Space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you apply the incorrect skeleton, the Blend Space will not be functional
    for the player character and its custom skeletal mesh when selecting the skeleton
    for assets such as Blend Spaces or animation blueprints that require one. Here,
    you are telling this asset with which skeleton it is compatible. By doing so,
    in the case of a Blend Space, you are able to use animations that are made for
    this skeleton and thereby ensure that everything is compatible with everything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Name this Blend Space asset `SideScroller_IdleRun_1D`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open the `SideScroller_IdleRun_1D` Blend Space asset. You can see the
    single-axis graph below the preview window:![Figure 11.6: The editing tool used
    to create Blend Spaces in Unreal Engine 4'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6: The editing tool used to create Blend Spaces in Unreal Engine
    4'
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side of the editor, you have the `Asset Details` panel that
    contains the `Axis Settings` category. It is here that you will label the axis
    and provide both a minimum and maximum float value that will later be of use to
    you in the `Animation Blueprint` for the player character. Please refer to the
    figure below to see the default values set for `Horizontal Axis`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: The axis settings that affect the axis of the Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.7: The axis settings that affect the axis of the Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, rename the `Horizontal Axis` as `Speed`:![Figure 11.8: The horizontal
    axis is now named Speed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.8: The horizontal axis is now named Speed'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to establish `Minimum Axis Value` and `Maximum Axis Value`.
    You will want the minimum value to be `0.0f`, which is set by default, because
    the player character will be in `Idle` when he is not moving at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But what about the `Maximum Axis Value`? This one is a little trickier because
    you need to bear the following points in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: You will be supporting a sprinting behavior for the character that allows the
    player to move faster when holding down the *Left Shift* keyboard button. When
    released, the player will return to the default walking speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The walking speed to match the characters' `Max Walk Speed` parameter of the
    `CharacterMovementComponent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you set the `Maximum Axis Value`, you need to set the character's `Max
    Walk Speed` to a value that suits the `SuperSideScroller` game.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, navigate to `/Game/MainCharacter/Blueprints/` and open the `BP_SuperSideScroller_MainCharacter`
    blueprint:![Figure 11.9: The directory of the SuperSideScroller main character
    blueprint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.9: The directory of the SuperSideScroller main character blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `Character Movement` component and, in the `Details` panel, under
    the `Character Movement: Walking` category, find the `Max Walk Speed` parameter
    and set this value to `300.0f`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Max Walk Speed` parameter set, return to the `SideScroller_IdleRun_1D`
    Blend Space and set the `Maximum Axis Value` parameter. If the walking speed was
    `300.0f`, what should the maximum value be? Keeping in mind that you will support
    sprinting for the player character, this maximum value needs to be more than the
    walking speed.
  prefs: []
  type: TYPE_NORMAL
- en: Update the `Maximum Axis Value` parameter to a value of `500.0f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, set the `Number of Grid Divisions` parameter to a value of `5`. The
    reason for this is that when working with divisions, a `100` unit spacing between
    each grid point makes it easier to work with since `Maximum Axis Value` is `500.0f`.
    This is useful in the case of grid point snapping when you apply the movement
    animations along the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leave the remaining properties set as their defaults:![Figure 11.10: The final
    axis settings for the Blend Space'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.10: The final axis settings for the Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: What you have done here with these settings is that you are telling the Blend
    Space to use an incoming float value between `0.0f` and `500.0f` to blend between
    the animations that you will place in the next step and the activity. By dividing
    the grid into `5` divisions, you are able to easily add the animations needed
    at the correct float value along the axis graph.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue creating the Blend Space by adding the first animation to the
    axis graph, the `Idle` animation.
  prefs: []
  type: TYPE_NORMAL
- en: To the right of the grid, there is the `Asset Browser` tab. Notice that the
    list of assets includes all of the animations of the player character that you
    imported in *Chapter 12*, *Animation Blending and Montages*. This is because you
    selected the `MainCharacter_Skeleton` asset when creating the Blend Space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, *left-click* and drag the `Idle` animation to our grid at position `0.0`:![Figure
    11.11: Dragging the Idle animation to the grid position 0.0'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.11: Dragging the Idle animation to the grid position 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that when dragging this animation to the grid, it will snap to the grid
    point. Once the animation is added to the Blend Space, the player character changes
    from its default T-Pose and starts to play the `Idle` animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: With the Idle animation added to the 1D Blend Space,'
  prefs: []
  type: TYPE_NORMAL
- en: the player character begins to animate
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.12: With the Idle animation added to the 1D Blend Space, the player
    character begins to animate'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you now have an understanding of how to create
    a 1D Blend Space and, more importantly, you know the differences between a 1D
    Blend Space and a normal Blend Space. Additionally, you know the importance of
    aligning the values between the player character movement component and the Blend
    Space and why you need to ensure that the walking speed correlates appropriately
    with the values in the Blend Space.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the first activity of this chapter, where you will be applying
    the remaining `Walking` and `Running` animations to the Blend Space just as you
    added the `Idle` animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Adding the Walking and Running Animations to the Blend Space'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The 1D movement Blend Space is coming together nicely so far, but you are missing
    the walking and running animations. In this activity, you will finish the Blend
    Space by adding these animations to the Blend Space at the appropriate horizontal
    axis values that make sense for the main character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the knowledge acquired from *Exercise 11.01*, *Creating the CharacterMovement
    1D Blend Space*, perform the following steps to finish up the character movement
    Blend Space:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on from *Exercise 11.01*, *Creating the CharacterMovement 1D Blend
    Space*, head back to `Asset Browser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add the `Walking` animation to the horizontal grid position `300.0f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add the `Running` animation to the horizontal grid position `500.0f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can *left-click* and drag the green preview grid point along
    the grid axis to see how the animation blends together based on the axis value,
    so pay attention to the character animation preview window to make sure that it
    looks correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13: The Running animation in the Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.13: The Running animation in the Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: When this activity is complete, you will have a functional Blend Space that
    blends the character movement animations from `Idle` to `Walking` to `Running`
    based on the value of the horizontal axis that represents the player character's
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Main Character Animation Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the animations added to the Blend Space, you should be able to walk around
    and see those animations at work, right? Well, no. If you select Play-In-Editor,
    you will notice that the main character is still moving in the T-Pose. The reason
    is because you aren't yet telling the animation blueprint to use our Blend Space
    asset, which you will do later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Animation Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before jumping into using the animation blueprint you created in the last chapter,
    let's briefly discuss what this type of blueprint is, and what its main function
    is. An animation blueprint is a type of blueprint that allows you to control the
    animation of a skeleton and skeletal mesh, in this instance, the player character
    skeleton and mesh you imported in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'An animation blueprint is broken into two main graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Event Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anim Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Event Graph works as in a normal blueprint where you can use events, functions,
    and variables to script gameplay logic. The Anim Graph, on the other hand, is
    unique to an animation blueprint, and this is where you use logic to determine
    the final pose of the skeleton and skeletal mesh at any given frame. It is here
    where you can use elements such as state machines, anim slots, Blend Spaces, and
    other animation-related nodes to then output to the final animation for the character.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the following example (you can follow along).
  prefs: []
  type: TYPE_NORMAL
- en: Open the `AnimBP_SuperSideScroller_MainCharacter` animation blueprint in the
    `MainCharacter/Blueprints` directory.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `AnimGraph` should open where you can see the character preview,
    our `Asset Browser` tab, and the main graph. It is inside this `AnimGraph` that
    you will implement the Blend Space you just created in order to have the player
    character animate correctly when moving around the level.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with the next exercise, where we will do this and learn more
    about animation blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Adding the Blend Space to the Character Animation Blueprint'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this exercise, you will add the Blend Space to the animation blueprint and
    prepare the necessary variable to help control this Blend Space based on the movement
    speed of the player character. Let's begin by adding the Blend Space to `AnimGraph`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the Blend Space to `AnimGraph` by finding the `Asset Browser` on the right-hand
    side, and *left-click* and drag the `SideScroller_IdleRun_1D` Blend Space asset
    into `AnimGraph`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the variable input for this Blend Space node is labeled `Speed`,
    just like the horizontal axis inside the Blend Space. Please refer to *Figure
    11.14* to see the Blend Space in `Asset Browser`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you were to name the `Horizontal Axis` differently, the new name would be
    shown as the input parameter of the Blend Space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14: Asset Browser gives you access to all animation assets related
    to the MainCharacter_Skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.14: Asset Browser gives you access to all animation assets related
    to the MainCharacter_Skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, connect the `Output Pose` asset of the Blend Space node to the `Result`
    pin of the `Output Pose` node. Now, the animation pose in the preview shows the
    character in the `Idle` animation pose:![Figure 11.15: You now have limited control
    of the Blend Space and can manually enter values into the Speed parameter to update
    the character movement animations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.15: You now have limited control of the Blend Space and can manually
    enter values into the Speed parameter to update the character movement animations'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `PIE,`(`Idle` animation instead of remaining in the T-Pose:![Figure
    11.16: The player character now plays the Idle animation in-game'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.16: The player character now plays the Idle animation in-game'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have the ability to control our Blend Space with our `Speed` input
    variable. With the ability to use the Blend Space in place, you need a way to
    store the character''s movement speed, and pass that value to the `Speed` input
    parameter of the Blend Space. This is what you will need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `Event Graph` of our animation blueprint. By default, there
    will be the `Event Blueprint Update Animation` event and a pure `Try Get Pawn
    Owner` function. Please refer to *Figure 11.17* to see the default setup of `Event
    Graph`. The event is updated each frame that the animation is updated, and returns
    the `SuperSideScroller` player character blueprint class before attempting to
    get any more information.![Figure 11.17: Animation blueprints include this event
    and function pair'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: by default to use in your Event Graph
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.17: Animation blueprints include this event and function pair by
    default to use in your Event Graph'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between a `Pure` and `Impure` function in Unreal Engine
    4 is that a `Pure` function implies that the logic it contains will not modify
    a variable or member of the class in which it is being used. In the case of `Try
    Get Pawn Owner`, it is simply returning a reference to the `Pawn` owner of the
    animation blueprint. `Impure` functions do not have this implication and are free
    to modify any variable or member it wants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the `Return Value` from the `Try Get Pawn Owner` function and, from the
    `Context Sensitive` menu that appears, search for the cast to `SuperSideScrollerCharacter`:![Figure
    11.18: The context-sensitive menu finds the related function or variable on which
    basis actions can be taken on the object you are checking from'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.18: The context-sensitive menu finds the related function or variable
    on which basis actions can be taken on the object you are checking from'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the execution output pin from `Event Blueprint Update Animation` to
    the execution input pin of the cast:![Figure 11.19: Inside the Event Graph, use
    the Try Get Pawn Owner function to cast the returned Pawn object to the SuperSideScrollerCharacter
    class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.19: Inside the Event Graph, use the Try Get Pawn Owner function to
    cast the returned Pawn object to the SuperSideScrollerCharacter class'
  prefs: []
  type: TYPE_NORMAL
- en: The character blueprint you created inherits from the `SuperSideScrollerCharacter`
    class. Since the owning pawn of this animation blueprint is your `BP_SuperSideScroller_MainCharacter`
    character blueprint and this blueprint inherits from the `SuperSideScrollerCharacter`
    class, the cast function will execute successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Next, store the returned value from the cast to its own variable; that way,
    we have a reference to it in case we need to use it again in our animation blueprint.
    Refer to *Figure 11.20* and make sure to name this new variable `MainCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is the option in the context-sensitive dropdown for `Promote to Variable`,
    which allows you to store any valid value type to its own variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20: As long as the cast is successful, you will want to keep'
  prefs: []
  type: TYPE_NORMAL
- en: track of the owning character
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.20: As long as the cast is successful, you will want to keep track
    of the owning character'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to track the character''s speed, use the `Get Velocity` function from
    the `MainCharacter` variable. Every object from the `Actor` class has access to
    this function that returns the magnitude and direction vector that the object
    is moving in:![Figure 11.21: The GetVelocity function can be found under Utilities/Transformation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.21: The GetVelocity function can be found under Utilities/Transformation'
  prefs: []
  type: TYPE_NORMAL
- en: 'From `Get Velocity`, you can use the `VectorLength` function to get the actual
    speed:![Figure 11.22: The VectorLength function returns the magnitude of the vector,'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: but not the direction
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.22: The VectorLength function returns the magnitude of the vector,
    but not the direction'
  prefs: []
  type: TYPE_NORMAL
- en: '`Return Value` from the `VectorLength` function can then be promoted to its
    own variable named `Speed`:![Figure 11.23: Every actor has the Get Velocity function
    that returns the magnitude and direction of the actor''s movement'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.23: Every actor has the Get Velocity function that returns the magnitude
    and direction of the actor''s movement'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you were able to obtain the player character speed by using
    the `GetVelocity` function. The vector returned from the `GetVelocity` function
    gives the length of the vector to ascertain the actual speed. By storing this
    value in the `Speed` variable, you can now reference this value in the `AnimGraph`
    of the animation blueprint to update your Blend Space, which you will do in the
    next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Velocity Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving on to the next step, let's explain what you are doing when you
    get the velocity of the character and promote the vector length of that vector
    to the `Speed` variable.
  prefs: []
  type: TYPE_NORMAL
- en: What is velocity? Velocity is a vector that has a given `GetVelocity` function
    and the `VectorLength` function on the returned velocity vector; you are getting
    the value of the `Speed` variable of our character. That is why you store that
    value in a variable and use it to control the Blend Space, as shown in the following
    figure, which is an example of vectors. Where one has a positive (right) direction
    with a magnitude of `100`, the other has a negative (left) direction with a magnitude
    of `35`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24: Figure showing two different vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.24: Figure showing two different vectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.03: Adding the Blend Space to the Character Animation Blueprint'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have a better understanding of `Vectors` and how to store the `Speed`
    variable of the player character from the previous exercise, you can follow these
    next steps to apply the speed to the 1D Blend Space you created earlier in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `AnimGraph` within your `AnimBP_SuperSideScroller_MainCharacter`
    animation blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Speed` variable to update the Blend Space in real time in the `AnimGraph`
    by *left-clicking* and dragging the `Speed` variable onto the graph, and connecting
    the variable to the input of the `Blendspace Player` function:![Figure 11.25:
    You can now use the Speed variable to update the Blend Space in every frame when
    the animation is updated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.25: You can now use the Speed variable to update the Blend Space
    in every frame when the animation is updated'
  prefs: []
  type: TYPE_NORMAL
- en: Next, compile the animation blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You now have the ability to update the Blend Space based on the speed of the
    player character. When you use `PIE`, you can see the character in `Idle` and
    in the `Walking` animation when you move:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.26: The player character is finally able to walk around in the
    level'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.26: The player character is finally able to walk around in the level'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the main character is using the movement animations based on movement
    speed. In the next activity, you will update the character movement component
    so that you can preview the character running animation from the Blend Space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.02: Previewing the Running Animation In-Game'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the animation blueprint updating and getting the speed of the player character,
    you are now able to preview the `Idle` and `Walking` animations in-game.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will update the `CharacterMovement` component of the player
    character blueprint so that you can preview the `Running` animation in-game as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to, and open, the `BP_SuperSideScroller_MainCharacter` player character
    blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the `CharacterMovement` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `Max Walk Speed` parameter to a value of `500.0` so that your character
    can move fast enough to blend its animation from the `Idle` to `Walking` and finally,
    to `Running`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of this activity, you will have allowed the player character to reach
    a speed that allows you to preview the `Running` animation in-game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.27: The player character running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.27: The player character running'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have handled the player character movement blending from `Idle`
    to `Walk` and finally to `Run`, let's move on to the next step to add the functionality
    to allow the player character to move even quicker by sprinting.
  prefs: []
  type: TYPE_NORMAL
- en: Input Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game requires input from the player, whether it is the keys on a keyboard
    such as *W*, *A*, *S*, and *D* for moving the player character, or the thumb sticks
    on a controller; this is what makes video games an interactive experience. Unreal
    Engine 4 allows us to map keyboard, mouse, gamepad, and other types of controls
    to labeled actions or axes that you can then reference in Blueprint or C++ to
    allow character or gameplay functionality to occur. It is important to point out
    that each unique action or axis mapping can have one or more key bindings, and
    that the same key binding can be used for multiple mappings. Input bindings are
    saved into an initialization file called `DefaultInput.ini` and can be found in
    the `Config` folder of your project directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Input bindings can be edited directly from the `DefaultInput.ini` file or through
    `Project Settings` in the editor itself; the latter being more easily accessible
    and less error-prone when editing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a new input binding for the player character's `Sprint` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.04: Adding Input for Sprinting and Throwing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the player character moving around the level, you will now implement a
    unique character class for the player character that derives from the base `SuperSideScrollerCharacter`
    C++ class. The reason to do this is so that you can easily differentiate between
    classes of the player character and the enemy later on, instead of relying solely
    on unique blueprint classes.
  prefs: []
  type: TYPE_NORMAL
- en: While creating the unique C++ character class, you will implement the *sprinting*
    behavior to allow the player character to *walk* and *sprint* as desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by implementing the `Sprinting` mechanic by first adding the input
    binding for `Sprint`:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Edit` option on the toolbar at the top of the editor and, from
    the drop-down list, select `Project Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `Project Settings`, navigate to the `Input` option under the `Engine`
    category on the left-hand side. By default, the `Side Scroller` template project
    provided by Unreal Engine comes with Action Mappings for `Jump` with the keys
    *W*, *Up Arrow Key*, *Space Bar*, and *Gamepad Face Button Bottom* bound to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add new `Action Mapping` by *left-clicking* on the `+` button next to `Action
    Mappings`. Label this mapping `Sprint` and add two keys for its controls; `Left
    Shift` and `Gamepad Right Shoulder`. Please refer to the figure below for the
    updated bindings.![Figure 11.28: The Jump and Sprint Action Mappings applied to
    key bindings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.28: The Jump and Sprint Action Mappings applied to key bindings'
  prefs: []
  type: TYPE_NORMAL
- en: With the `Sprint` input binding in place, you need to create a new C++ class
    for the player character based on the `SuperSideScroller` character class.
  prefs: []
  type: TYPE_NORMAL
- en: Head back inside the editor, navigate to `File` and, from the drop-down list,
    select the `New C++ Class` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new player character class will inherit from the `SuperSideScrollerCharacter`
    parent class because this base class has a majority of the functionality needed
    for the player character. After selecting the parent class, *left-click* on `Next`.
    Please refer to the following image to see how to find the `SuperSideScrollerCharacter`
    class.![Figure 11.29: Selecting the SuperSideScrollerCharacter parent class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.29: Selecting the SuperSideScrollerCharacter parent class'
  prefs: []
  type: TYPE_NORMAL
- en: Name this new class `SuperSideScroller_Player`. Leave the path as the default
    that Unreal Engine provides for you, unless you have a need to adjust the file
    directory of this new class. After naming the new class and selecting the directory
    to save the class in, *left-click* `Create Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting `Create Class`, Unreal Engine will generate the source and header
    files for you and Visual Studio will automatically open these files. You will
    notice that both the header file and the source file are almost empty. This is
    OK because you are inheriting from the `SuperSideScrollerCharacter` class and
    much of the logic you want is done in that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SuperSideScroller_Player`, you will add only the functionality you need
    on top of what you inherit. You can view the line where the inheritance is taking
    place inside `SuperSideScroller_Player.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class declaration is saying that the new `ASuperSideScroller_Player` class
    inherits from the `ASuperSideScrollerCharacter` class.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you were able to add the necessary `Input Binding`
    for the `Sprint` mechanic that can then be referenced in C++ and used to allow
    the player to sprint. Now that you have also created the C++ class for the player
    character, you can update the code with the `Sprint` functionality, but first
    you will need to update the `Blueprint` character and the animation blueprint
    to reference this new class. Let's do this in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you reparent a blueprint to a new class? Each blueprint inherits
    from a parent class. In most cases, this is `Actor`, but in the case of your character
    blueprint, its parent class is `SuperSideScrollerCharacter`. Inheriting from a
    parent class allows a blueprint to inherit the functionality and variables of
    that class so that logic can be reused on the blueprint level.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when inheriting from the `SuperSideScrollerCharacter` class, the
    blueprint inherits components such as the `CharacterMovement` component and the
    `Mesh` skeletal mesh component, that can then be modified in Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.05: Reparenting the Character Blueprint'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have created a new character class for the player character, you
    need to update the `BP_SuperSideScroller_MainCharacter` blueprint to use the `SuperSideScroller_Player`
    class as its parent class. If you don't, then any logic you add to the new class
    will not affect the character made in Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to reparent the blueprint to the new character class:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `/Game/MainCharacter/Blueprints/` and open the `BP_SuperSideScroller_MainCharacter`
    blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `File` option on the toolbar and, from the drop-down menu, select
    the `Reparent Blueprint` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When selecting the `Reparent Blueprint` option, Unreal will ask for the new
    class to reparent the blueprint to. Search for `SuperSideScroller_Player` and
    select the option from the dropdown by *left-clicking*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you select the new parent class for the blueprint, Unreal will reload the
    blueprint and recompile it, both of which will happen automatically for you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when reparenting blueprints to new parent classes because this can
    lead to compile errors or settings to be erased or reverted back to class defaults.
    Unreal Engine will display any warnings or errors that may occur after compiling
    the blueprint after reparenting to a new class. These warnings and errors usually
    occur if there is blueprint logic that references variables or other class members
    that no longer exist in the new parent class. Even if there are no compile errors,
    it is best to confirm that any logic or settings you have made to your blueprint
    are still present after the reparenting before moving on with your work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your character blueprint is correctly reparented to the new `SuperSideScroller_Player`
    class, you need to also update the `AnimBP_SuperSideScroller_MainCharacter` animation
    blueprint to ensure that you are casting to the correct class when using the `Try
    Get Pawn Owner` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, navigate to the `/MainCharacter/Blueprints/` directory and open the `AnimBP_SuperSideScroller_MainCharacter`
    animation blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Event Graph`. From the `Return Value` of the `Try Get Pawn Owner` function,
    search for `Cast` to `SuperSideScroller_Player`:![Figure 11.30: Instead of casting
    to the base SuperSideScrollerCharacter class, you can cast to the new SuperSideScroller_Player
    class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.30: Instead of casting to the base SuperSideScrollerCharacter class,
    you can cast to the new SuperSideScroller_Player class'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then connect the output as a `SuperSideScroller_Player` cast to the
    `MainCharacter` variable. This works because the `MainCharacter` variable is of
    the `SuperSideScrollerCharacter` type and the new `SuperSideScroller_Player` class
    inherits from that class:![Figure 11.31: You can still use the MainCharacter variable
    because SuperSideScroller_Player is based on the SuperSideScrollerCharacter due
    to inheritance'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.31: You can still use the MainCharacter variable because SuperSideScroller_Player
    is based on the SuperSideScrollerCharacter due to inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: Now that both the `BP_SuperSideScroller_MainCharacter` character blueprint and
    the `AnimBP_SuperSideScroller_MainCharacter` animation blueprint are referencing
    your new `SuperSideScroller_Player` class, it is now safe to move forward into
    C++ and code the character sprint functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.06: Coding the Character Sprint Functionality'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the new `SuperSideScroller_Player` class reference correctly implemented
    in blueprints following the previous exercise, it is time to start coding the
    functionality that will allow the player character to sprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to add the `Sprinting` mechanic to the character:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to take care of is the constructor of the `SuperSideScroller_Player`
    class. Navigate back to Visual Studio and open the `SuperSideScroller_Player.h`
    header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will use the `constructor` function later in this exercise to set initialized
    values for variables. For now, it will be an empty constructor. Make sure that
    the declaration is made under the `public` access modifier heading, as seen in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the constructor declared, create the constructor function definition in
    the `SuperSideScroller_Player.cpp` source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With the constructor in place, it's time to create the `SetupPlayerInputComponent`
    function so that you can use the key bindings created earlier to call functions
    within the `SuperSideScroller_Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetupPlayerInputComponent` function is a function that the character class
    has built-in by default, so you need to declare it as a `virtual` function with
    the `override` specifier. This tells Unreal that you are using this function and
    intend to redefine its functionality in this new class. Make sure that the declaration
    is made under the `Protected` access modifier heading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SetupPlayerInputComponent` function requires an object of the `UInputComponent`
    class to be passed into the function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `UInputComponent* PlayerInputComponent` variable is inherited from the `UCharacter`
    base class that our `ASuperSideScroller_Player()` class derives from, and therefore,
    must be used as the input parameter of the `SetupPlayerInputComponent()` function.
    Using any other name will result in a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the source file, create the definition of the `SetupPlayerInputComponent`
    function. In the body of the function, we will use the `Super` keyword to call
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Super` keyword enables us to call the `SetupPlayerInputComponent` parent
    method. With the `SetupPlayerInputComponent` function ready, you need to include
    the following header files in order to continue with this exercise without any
    compile errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#include "Components/InputComponent.h"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "GameFramework/CharacterMovementComponent.h"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need to include the header for the input component in order to bind
    the key mappings to the sprint functions you will be creating next. The header
    for the `Character Movement` component will be necessary for the sprint functions
    because you will be updating the `Max Walk Speed` parameter based on whether the
    player is sprinting. The following code is all of the headers that need to be
    included for the player character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the necessary headers included in the source file of the `SuperSideScroller_Player`
    class, you can now create the sprint functions used to make the player character
    move faster. Let's begin by declaring the required variable and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `Private` access modifier in the header file of the `SuperSideScroller_Player`
    class, declare a new Boolean variable called `bIsSprinting`. This variable will
    be used as a failsafe in order to know for certain whether the player character
    is sprinting before making any changes to the movement speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare two new functions, `Sprint();` and `StopSprinting();`. These
    two functions will not take any arguments and will not return anything. Declare
    the functions under the `Protected` access modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Sprint();` function will be called when the player *presses/holds* the
    `Sprint` keys mapping to the binding, and `StopSprinting()` will be called when
    the player *releases* the keys mapped to the binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the definition of the `Sprint();` function. In the source file of
    the `SuperSideScroller_Player` class, create the definition for this function,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Within the function, you will first want to check the value of the `bIsSprinting`
    variable. If the player is `bIsSprinting` is `False`, then move forward with the
    rest of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `If` statement, set the `bIsSprinting` variable to `True`. Then,
    you can access the `GetCharacterMovement()` function and modify the `MaxWalkSpeed`
    parameter. Set `MaxWalkSpeed` to `500.0f`. Remember that the `Maximum Axis Value`
    parameter of the movement Blend Space is `500.0f`. This means that the player
    character will reach the speed necessary to use the `Running` animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `StopSprinting()` function will look almost identical to the `Sprint()`
    function you just wrote, but it works in the opposite manner. You first want to
    check whether the player *is* sprinting, meaning that `bIsSprinting` is `True`.
    If so, move forward with the rest of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `If` statement, set `bIsSprinting` to `False`. Then, access the
    `GetCharacterMovement()` function to modify `MaxWalkSpeed`. Set `MaxWalkSpeed`
    back to `300.0f`, the default speed for the player character walking. This means
    that the player character will reach only the speed necessary for the `Walking`
    animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the functions needed for sprinting, it is time to bind these
    functions to the action mappings you created earlier. In order to do this, perform
    the following steps within the `SetupPlayerInputComponent` function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by binding the `Sprint()` function. Inside the `SetupPlayerInputComponent`
    function, use the `PlayerInputComponent` variable that is passed to the function
    so as to call the `BindAction` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The parameters we need for `BindAction` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the action mapping as written in `Project Settings` that you set
    up earlier in this exercise, in this case, `Sprint`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enumerator value of the `EInputEvent` type that you want to use for this
    binding; in this case you will use `IE_Pressed` because this binding will be for
    when the `Sprint` key(s) are pressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will do the same thing for the `StopSprinting()` function, but this time
    you need to use the `IE_Released` enumerator value, and reference the `StopSprinting`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With `Action Mappings` bound to the sprint functions, the last thing you need
    to do is set default initialized values of the `bIsSprinting` variable and the
    `MaxWalkSpeed` parameter from the `Character Movement` component.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `constructor` function in the source file of your `SuperSideScroller_Player`
    class, add the `bIsSprinting = false` line. This variable is constructed as false
    because the player character should not be sprinting by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, set the `MaxWalkSpeed` parameter of the character movement component
    to `300.0f` by adding the line `GetCharacterMovement()->MaxWalkSpeed = 300.0f`.
    Please review the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With the initialization of the variables added to the constructor, the `SuperSideScroller_Player`
    class is done, for now. Return to Unreal Engine and *left-click* on the `Compile`
    button on the toolbar. This will recompile the code and perform a hot-reload of
    the editor.
  prefs: []
  type: TYPE_NORMAL
- en: After recompiling and hot-reloading the editor, you can Play-In-Editor and see
    the fruits of your labor. The base movement behavior is the same as before, but
    now if you hold *Left Shift* or *Gamepad Right Shoulder* on a controller, the
    player character will sprint and begin to play the `Running` animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.32: The player character can now sprint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.32: The player character can now sprint'
  prefs: []
  type: TYPE_NORMAL
- en: With the player character able to sprint, let's move on to the next activity,
    where you will implement the base `Throw` functionality in a very similar way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.03: Implementing the Throwing Input'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the features included with this game is the ability for the player to
    throw projectiles at the enemy. You won't be creating the projectile or implementing
    the animation in this chapter, but you will set up the key bindings and the C++
    implementation for use in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you need to set up the key bindings for the `Throw` projectile
    functionality and implement a debug log in C++ for when the player presses the
    key(s) mapped to `Throw` by doing the following.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `Throw` input to `Project Settings` in the input binding. Name this
    binding `ThrowProjectile` and bind it to *Left-Mouse Button* and *Gamepad Right
    Trigger*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within Visual Studio, add a new function to the header file of `SuperSideScroller_Player`.
    Name this function `ThrowProjectile()`. This will be a void function without parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the definition in the source file of the `SuperSideScroller_Player` class.
    In the definition of this function, use `UE_LOG` to print a message letting you
    know that the function is being called successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about `UE_LOG` here: [https://www.ue4community.wiki/Legacy/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://www.ue4community.wiki/Legacy/Logs,_Printing_Messages_To_Yourself_During_Runtime).'
  prefs: []
  type: TYPE_NORMAL
- en: The expected result by the end of this activity is that when you use the *left
    mouse button* or the *gamepad right trigger*, a log will appear in the `Output
    Log`, letting you know that the `ThrowProjectile` function is being called successfully.
    You will use this function later on to spawn your projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.33: The expected output log'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.33: The expected output log'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you now have functionality in-place for when you
    create the player projectile in *Chapter 13*, *Enemy Artificial Intelligence*.
    You also now have the knowledge and experience of adding new key mappings to your
    game, and implementing functionality in C++ that utilizes these mappings to enable
    gameplay functionality. Now, you will continue with updating player character
    movement to allow the jumping animation to play correctly when the player jumps.
  prefs: []
  type: TYPE_NORMAL
- en: Animation State Machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's get to know what state machines are in the context of Unreal Engine
    4 and in animation. State machines are a means of categorizing an animation, or
    sets of animations, into their own state. A state can be thought of as a condition
    that the player character is in at a specific time. Is the player currently walking?
    Is the player jumping? In many third-person games such as *The Last of Us*, this
    is the separation of movement, jumping, crouching, and climbing animations into
    their own state. Each state is then accessible when certain conditions are met
    while the game is played. Conditions can include whether the player is jumping,
    the speed of the player character, and whether or not the player is in the crouched
    state. The job of the state machine is to transition between each state using
    logical decisions called **Transition Rules**. When you create multiple states
    with multiple transition rules that intertwine with one another, the state machine
    begins to look like a web.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the following image to see how the state machine looks for the
    `ThirdPerson_AnimBP` animation blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A general overview of state machines can be found here: [https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Animation/StateMachines/Overview/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.34: The state machine of ThirdPerson_AnimBP that is included with
    the SideScroller project template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.34: The state machine of ThirdPerson_AnimBP that is included with
    the SideScroller project template'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the state machine for the player character, this state machine
    will handle the states of default player movement and jumping. Currently, you
    have the player character animating simply by using a Blend Space that is controlled
    by the speed of the character. What you will do in the next exercise is create
    a new state machine and move the movement Blend Space logic into its own state
    within that state machine. Let's begin by creating the new state machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.07: Player Character Movement and Jump State Machine'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will implement a new animation state machine and integrate
    the existing movement Blend Space into the state machine. Additionally, you will
    set up the states for when the player jump starts, and for when the player is
    in the air during that jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding this new state machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `/MainCharacter/Blueprints/` directory and open the `AnimBP_SuperSideScroller_MainCharacter`
    animation blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `AnimGraph`, *right-click* in the empty space of the graph and search for
    `state machine` inside the context-sensitive search to find the `Add New State
    Machine` option. Name this new state machine `Movement`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, instead of plugging the output pose of the `SideScroller_IdleRun` Blend
    Space, we can connect the output post of the new state machine, `Movement`, to
    the output pose of the animation:![Figure 11.35: The new Movement state machine
    replaces the old Blend Space'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.35: The new Movement state machine replaces the old Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting an empty state machine into the `Output Pose` of the animation blueprint
    will result in the warnings displayed below. All this means is that there is nothing
    happening within that state machine and that the result will be invalid to `Output
    Pose`. Don't worry; you will fix this next.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.36: The empty state machine results in compile warnings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.36: The empty state machine results in compile warnings'
  prefs: []
  type: TYPE_NORMAL
- en: '*Double left-click* on the `Movement` state machine to open the state machine
    itself. The image below shows what this looks like.![Figure 11.37: This is the
    empty state machine that is created'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.37: This is the empty state machine that is created'
  prefs: []
  type: TYPE_NORMAL
- en: You will start by adding a new state that will handle what the character was
    doing before; `Idle`, `Walking`, and `Running`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `Entry` point, *left-click* and drag out to open the context-sensitive
    search. You will notice that there are only two options – `Add Conduit` and `Add
    State`. For right now, you will add a new state and name this state `Movement`.
    Refer to the following images to see the `Movement` state created.![Figure 11.38:
    Inside the state machine, you need to add a new state that will handle the movement
    Blend Space you created earlier'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.38: Inside the state machine, you need to add a new state that will
    handle the movement Blend Space you created earlier'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.39: The new Movement state'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.39: The new Movement state'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy and paste the logic you had where you connected the `Speed` variable to
    the `SideScroller_IdleRun` Blend Space into the new `Movement` state created in
    the last step. Connect it to the `Result` pin of the `Output Animation Pose` node
    of this state:![Figure 11.40: Connecting the output pose of the Blend Space'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to the output pose of this state
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.40: Connecting the output pose of the Blend Space to the output pose
    of this state'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you recompile the animation blueprint, you will notice first that the
    warnings you saw earlier are now gone. This is because you added a new state that
    outputs an animation to `Output Animation Pose` instead of having an empty state machine.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have constructed your very first state machine.
    Although it is a very simple one, you are now telling the character to enter and
    use the `Movement` state by default. If you now PIE, you will see that the player
    character is now moving around like he was earlier prior to making the state machine.
    This means that your state machine is functioning, and you can continue to the
    next step, which will be adding the initial states required for jumping. Let's
    start by creating the `JumpStart` state.
  prefs: []
  type: TYPE_NORMAL
- en: Transition Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conduits are a way of telling each state the conditions under which it can transition
    from one state to another. In this case, a transition rule is created as a connection
    between the `Movement` and `JumpStart` states. This is indicated by the directional
    arrow of the connection between the states again. The tool-tip mentions the term
    *transition rule*, and this means that you need to define how the transition between
    these states will happen, using a Boolean value to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.41: There needs to be a transition rule to go from movement'
  prefs: []
  type: TYPE_NORMAL
- en: to the start of the character's jump
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.41: There needs to be a transition rule to go from movement to the
    start of the character''s jump'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.08: Adding States and Transition Rules to the State Machine'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of transitioning from the player character's default movement Blend
    Space to the beginning of the jump animation, you will need to know when the player
    decides to jump. This can be done using a useful function called `IsFalling` from
    the `Character Movement` component of the player character. You will want to track
    whether the player is currently falling in order to transition in and out of jumping.
    The best way to do this is to store the result of the `IsFalling` function in
    its own variable, just like how you did when tracking the player's speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Back in the overview of the state machine itself, *left-click* and drag from
    the edge of the `Movement` state to open the context-sensitive menu again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the option to `Add State` and name this state `JumpStart`. When you
    do this, Unreal will automatically connect these states and implement an empty
    `Transition Rule` for you:![Figure 11.42: The Transition Rule that Unreal automatically
    creates'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: for you when connecting two states
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.42: The Transition Rule that Unreal automatically creates for you
    when connecting two states'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate back to `Event Graph` inside the animation blueprint, where you had
    used the Event Blueprint update animation event to store the `Speed` of the player
    character.![Figure 11.43: EventGraph of the SuperSideScroller player animation
    blueprint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.43: EventGraph of the SuperSideScroller player animation blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a getter variable for the `MainCharacter` and access the `Character
    Movement` component. From the `Character Movement` component, *left-click* and
    drag to access the context-sensitive menu. Search for `IsFalling`:![Figure 11.44:
    How to find the IsFalling function'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.44: How to find the IsFalling function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The character movement component can tell you whether the player character
    is currently in the air with the help of the `IsFalling` function:![Figure 11.45:
    The character movement component showing the state of player character'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.45: The character movement component showing the state of player
    character'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `Return Value` Boolean of the `IsFalling` function, *left-click* and
    drag to search for the `Promote to Variable` option from the context-sensitive
    menu. Name this variable `bIsInAir`. When promoting to a variable, the Return
    Value output pin should automatically connect to the input pin of the newly promoted
    variable. If it does not, remember to connect them.![Figure 11.46: A new variable,
    bIsInAir, that contains the value of the IsFalling function'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.46: A new variable, bIsInAir, that contains the value of the IsFalling
    function'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are storing the state of the player and whether or not they are
    falling, this is the perfect candidate for the transition rule between the `Movement`
    and `JumpStart` states.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Movement State` machine, *double left-click* on the `Transition Rule`
    to enter its graph. You will find only one output node, `Result`, with the parameter
    `Can Enter Transition`. All you need to do here is use the `bIsInAir` variable
    and connect it to that output. Now, the `Transition Rule` is saying that if the
    player is in the air, the transition between the `Movement` state and the `JumpStart`
    states can happen.![Figure 11.47: When in the air, the player will transition
    to the start of the jumping animation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.47: When in the air, the player will transition to the start of the
    jumping animation'
  prefs: []
  type: TYPE_NORMAL
- en: With `Transition Rule` in place between the `Movement` and `JumpStart` states
    ready, all that is left to do is to tell the `JumpStart` state which animation
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the state machine graph, *double left-click* on the `JumpStart` state
    to enter its graph. From `Asset Browser`, *left-click* and drag the `JumpingStart`
    animation to the graph:![Figure 11.48: Make sure to have the JumpingStart animation
    selected in Asset Browser before left-clicking and dragging it into the state'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.48: Make sure to have the JumpingStart animation selected in Asset
    Browser before left-clicking and dragging it into the state'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the output of the `Play JumpingStart` node to the `Result` pin of the
    `Output Animation Pose` node:![Figure 11.49: Connecting the JumpingStart animation
    to the Output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animation Pose of the JumpStart state
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.49: Connecting the JumpingStart animation to the Output Animation
    Pose of the JumpStart state'
  prefs: []
  type: TYPE_NORMAL
- en: Before you can move forward with the next state, there are settings that need
    to be changed on the `JumpingStart` animation node.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* on the `Play JumpingStart` animation node and update the `Details`
    panel to have the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Loop Animation = False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Play Rate = 2.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the following figure to see the final settings for the `Play
    JumpingStart` animation node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.50: Due to the slowness of the JumpStart animation, increasing
    the play rate will result in a smoother jumping animation overall'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.50: Due to the slowness of the JumpStart animation, increasing the
    play rate will result in a smoother jumping animation overall'
  prefs: []
  type: TYPE_NORMAL
- en: You are setting the `Loop Animation` parameter to `False` because there is no
    reason that this animation should loop; it should only play once in any case.
    The only way that this animation would loop is if the player character is somehow
    stuck in this state, but this will never happen because of the next state you
    will create. The reason for setting `Play Rate` to `3.0` is because the animation
    itself, `JumpingStart`, is too long for the purposes of the game you are making.
    The animation has the character bend their knees drastically, and jump upward
    over the course of more than a second. For the `JumpStart` state, you want the
    character to play this animation quicker so that it is more fluid and offers a
    smoother transition to the next state; the `JumpLoop`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the player character has begun the `JumpStart` animation, there is a point
    in time during that animation where the player is in the air and should transition
    to a new state. This new state will loop until the player is no longer in the
    air and can transition into the final state of ending the jump. Next, let's create
    this new state that will transition from the `JumpStart` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the state machine graph, *left-click* and drag from the `JumpStart` state
    and select the `Add State` option. Name this new state `JumpLoop`. As before,
    Unreal will automatically provide you with a `Transition Rule` between these states
    that you will add to in the next exercise. Finally, recompile the Animation Blueprint
    and ignore any warnings that may appear under Compiler Results.![Figure 11.51:
    Creating another state that will handle the animation of the character while in
    the air after the initial jump start'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.51: Creating another state that will handle the animation of the
    character while in the air after the initial jump start'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have added and connected your own states for
    `JumpStart` and `JumpLoop`. Each of these states is connected via a `Transition
    Rule` and you now have a better understanding of how states within a state machine
    transition from one to another via the rules established in each transition rule.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will look more into how to transition from the `JumpStart`
    state to the `JumpLoop` state via a function, `Time Remaining Ratio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.09: Time Remaining Ratio Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for the `JumpStart` state to smoothly transition to the `JumpLoop`
    state, you need to take a moment to think exactly how you want this transition
    to work. Based on how the `JumpStart` and `JumpLoop` animations work, it is best
    to transition in the `JumpLoop` animation after a specified set of time has elapsed
    on the `JumpStart` animation. That way, the `JumpLoop` state plays smoothly after
    `X` seconds of the `JumpStart` animation playing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Double left-click* on the `Transition Rule` between `JumpStart` and `JumpLoop`
    to open its graph. The `Transition Rule` you will apply here is to check how much
    time is remaining from the `JumpingStart` animation. This is done because a certain
    percentage of time remains in the `JumpingStart` animation, and you can safely
    assume that the player is in the air and is ready to transition to the `JumpingLoop`
    animation state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this, first make sure that the `JumpingStart` animation is selected in
    `Asset Browser`, and then *right-click* in `Event Graph` of the `Transition Rule`
    and find the `Time Remaining Ratio` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's take a moment to talk about the `Time Remaining Ratio` function and what
    it is doing. This function returns a float between `0.0f` and `1.0f` that tells
    you how much time is remaining in the specified animation. The values `0.0f` and
    `1.0f` can directly be translated to a percentage value so that they are easier
    to consider. In the case of the `JumpingStart` animation, you would want to know
    whether less than 60% of the animation is remaining in order to transition successfully
    to the `JumpingLoop` state. This is what you will do now.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `Return Value` float output parameter of the `Time Remaining Ratio`
    function, search for the `Less Than comparative operative` node from the context-sensitive
    search menu. Since you are working with a returned value between `0.0f` and `1.0f`,
    in order to know whether less than 60% of the animation remains, you need to compare
    this returned value with a value of `0.6f`. The final result is as follows:![Figure
    11.52: You will need to know how much time is left in the JumpingStart animation
    before transitioning to the JumpLoop animation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_11_52.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.52: You will need to know how much time is left in the JumpingStart
    animation before transitioning to the JumpLoop animation'
  prefs: []
  type: TYPE_NORMAL
- en: With this `Transition Rule` in place, all that is left to do is to add the `JumpLoop`
    animation to the `JumpLoop` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Movement` state machine, *double left-click* on the `JumpLoop` state
    to enter its graph. With the `JumpLoop` animation asset selected in `Asset Browser`,
    *left-click* and drag it onto the graph. Connect its output to the `Result` input
    of `Output Animation Pose`, as shown below. The default settings of the `Play
    JumpLoop` node will remain unchanged.![Figure 11.53: The JumpLoop animation connected
    to Output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animation Pose of the new state
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_53.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.53: The JumpLoop animation connected to Output Animation Pose of
    the new state'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `JumpLoop` animation in place in the `JumpLoop` state, you can now
    compile the animation blueprint and PIE. You will notice that the movement and
    sprinting animations are still present, but what happens when you try to jump?
    The player character begins the `JumpStart` state and plays the `JumpLoop` animation
    while in the air. This is great, the state machine is working, but what happens
    when the player character reaches the ground and is no longer in the air? The
    player character does not transition back to the `Movement` state, which makes
    sense because you have not yet added the state for `JumpEnd` or the transitions
    between `JumpLoop` and `JumpEnd`, and from `JumpEnd` back to the `Movement` state.
    You will do this in the next activity. See below for an example of a player character
    stuck in the `JumpLoop` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.54: The player character can now play the JumpingStart animation
    and the JumpLoop animation, but cannot transition back to the default movement'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_54.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.54: The player character can now play the JumpingStart animation
    and the JumpLoop animation, but cannot transition back to the default movement'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you were able to successfully transition from the
    `JumpStart` state to the `JumpLoop` state by using the `Time Remaining Ratio`
    function. This function allows you to know how far along an animation has played,
    and with this information, you had the state machine transition into the `JumpLoop`
    state. The player can now successfully transition from the default `Movement`
    state to the `JumpStart` state and then to the `JumpLoop` state, resulting in
    an interesting issue. The player is now stuck in the `JumpLoop` state because
    the state machine does not contain the transition back to the `Movement` state.
    Let's fix this in the next activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.04: Finishing the Movement and Jumping State Machine'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With half of the state machine completed, it's time to add the state for when
    the jump ends, as well as the Transition Rules that allow you to transition from
    the `JumpLoop` state to this new state, and the transition from this new state
    back to the `Movement` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following to complete the `Movement` state machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new state for `Jump End` that transitions from `JumpLoop`. Name this state
    `JumpEnd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `JumpEnd` animation to the new `JumpEnd` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the `JumpEnd` animation and how quickly we want to transition between
    the `JumpLoop`, `JumpEnd`, and `Movement` states, consider modifying the parameters
    of the animation like you did for the `JumpStart` animation. The `loop animation`
    parameter needs to be `False` and the `Play Rate` parameter needs to be set to
    `3.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Transition Rule` from the `JumpLoop` state to the `JumpEnd` state based
    on the `bIsInAir` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Transition Rule` from the `JumpEnd` state to the `Movement` state based
    on the `Time Remaining Ratio` function of the `JumpEnd` animation. (Look at the
    `JumpStart` to `JumpLoop` Transition Rule).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By the end of this activity, you will have a fully functioning movement state
    machine that allows the player character to idle, walk, and sprint, as well as
    being able to jump and animate correctly at the start of the jump, while in the
    air, and when landing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.55: Player character with idle, walk, sprint, and jump animation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_11_55.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.55: Player character with idle, walk, sprint, and jump animation'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, you have now finished the movement state machine
    for the player character. By adding the remaining `JumpEnd` state and the `Transition
    Rules` to transition to the state from the `JumpLoop` state, and to transition
    from the `JumpEnd` state back to the `Movement` state, you successfully created
    your first animation state machine. Now, you can run around the map and jump onto
    elevated platforms, all while animating correctly and transitioning between movement
    and jump states.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the player movement Blend Space created and the player character animation
    blueprint using a state machine to transition from movement to jumping, you are
    ready to move on to the next chapter, where you will prepare the required animation
    slot, animation montage, and update the animation blueprint for the throw animation
    that will use only the upper body of the character.
  prefs: []
  type: TYPE_NORMAL
- en: From the exercises and activities in this chapter, you learned how to create
    a 1D Blend Space that allows the smooth blending of movement-based animations
    such as idling, walking, and running using the speed of the player character to
    control the blending of animations.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you learned how to integrate new key bindings into the project
    settings and bind those keys in C++ to enable character gameplay mechanics such
    as sprinting and throwing.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you learned how to implement your very own animation state machine within
    the character animation blueprint in order for the player to have the ability
    to transition between movement animations, to the various states of jumping, and
    back to movement again. With all of this logic in place, in the next chapter let's
    move on and create the assets and logic for allowing the player character to play
    the throwing animation, and set up the base class for the enemy.
  prefs: []
  type: TYPE_NORMAL
