- en: Searching and Reading Local Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Crawling and searching directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with encodings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading CSV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading file metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading PDF files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading Word documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning documents for a keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will deal with the basic operations to read files, starting
    with searching and opening files in directories and subdirectories. Then, we'll
    describe some of the most common file types and how to read them, including formats
    such as raw text files, PDFs, and Word documents.
  prefs: []
  type: TYPE_NORMAL
- en: The last recipe will combine them all, showing how to search recursively in
    a directory for a word in different kinds of files.
  prefs: []
  type: TYPE_NORMAL
- en: Crawling and searching directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to recursively scan a directory to get all the
    files contained there. The files can be of a particular kind, or just all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a test directory with some file information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All the files will be empty; we will use them in this recipe only to discover
    them. Notice there are four files that have a `.txt` extension, and two that have
    a `.pdf` extension.
  prefs: []
  type: TYPE_NORMAL
- en: The files are also available in the GitHub repository here: [https://github.com/PacktPublishing/Python-Automation-Cookbook/tree/master/Chapter04/documents/dir](https://github.com/PacktPublishing/Python-Automation-Cookbook/tree/master/Chapter04/documents/dir).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the created `dir` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Print all the filenames in the `dir` directory and subdirectories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the full path of the files, joining with the `root`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Print only the `.pdf` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Print only files that contain an even number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`os.walk()` goes through the whole directory and all subdirectories, returning
    all the files. It returns a tuple with the specific directory, the subdirectories
    that depends directly, and all the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `os.path.join()` function allows us to cleanly join two paths, such as the
    base path and the file.
  prefs: []
  type: TYPE_NORMAL
- en: As files are returned as pure strings, any kind of filtering can be done, as
    in step 3\. In step 4, the full power of regular expressions can be used to filter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we'll deal with the content of the files, and not just the
    filename.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The returned files are not opened or modified in anyway. This operation is read-only.
    Files can be opened as usual, and described as in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that changing the structure of the directory while walking it may affect
    the results. If you need to store any file while working, for example, when copying
    or moving a file, it's usually a good idea to store it in a different directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The  `os.path` module has other interesting functions. The most useful, other
    than `join()`, are probably:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.path.abspath()`, which returns the absolute path of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.path.split()`, which splits the path between directory and file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`os.path.exists()`, to return whether a file exists or not on the filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full documentation about `os.path` can be found here: [https://docs.python.org/3/library/os.path.html](https://docs.python.org/3/library/os.path.html).
    Another module, `pathlib`, can be used for higher-level access, in an object-oriented
    way: [https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html).
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated in step 4, multiple ways of filtering can be used. All of the
    string manipulations shown in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let
    Us Begin Our Automation Journey* can be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Introducing regular expressions* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let
    Us Begin Our Automation Journey *
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading text files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After searching for a particular file, we'll probably follow up by opening it
    and reading it. Text files are very simple yet very powerful files. They store
    data in plain text, without complicated binary formats.
  prefs: []
  type: TYPE_NORMAL
- en: Text file support is provided natively in Python, and it's easy to consider
    it a collection of lines.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll read the `zen_of_python.txt` file, containing the *Zen of Python* by
    Tim Peters, which is a collection of aphorisms that very well describe the design
    principles behind Python. It is available in the GitHub repository here: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/documents/zen_of_python.txt](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/documents/zen_of_python.txt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The *Zen of Python* is described in PEP-20 here: [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/).
  prefs: []
  type: TYPE_NORMAL
- en: The *Zen of Python* can be displayed in any Python interpreter by calling `import
    this`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open and print the whole file, line by line (the result is not displayed):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file and print any line containing the string `should`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file and print the first line containing the word `better`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To open a file in text mode, use the `open()` function. This returns a `file`
    object that then can be iterated over to return it line by line, as shown in step
    1 of the *How to do it…* section.
  prefs: []
  type: TYPE_NORMAL
- en: The `with` context manager is a very convenient way of dealing with files, as
    it will close them after finishing its use (leaving the block). It will do so
    even if there's an exception raised.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 shows how to iterate and filter the lines based in what lines are applicable
    for our tasks. The lines are returned as strings that can be filtered in multiple
    ways, as described before.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the whole file may not be required, as shown in step 3\. Because iterating
    through the file line by line will be reading the file as you go, you can stop
    at any time, avoiding reading the rest of the file. For a small file such as our
    example, that's not very relevant, but for long files, this can reduce memory
    use and time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `with` context manager is the preferred way of dealing with files, but
    it''s not the only one. You may also open and close them manually, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the `.close() ` method, to ensure that the file is closed and to free resources
    related to opening a file. The `.read()` method reads the whole file in one go,
    instead of line by line.
  prefs: []
  type: TYPE_NORMAL
- en: The `.read()` method also accepts a size parameter in bytes that limits the
    size of the data read. For example, `file.read(1024)` will return up to 1 KB of
    information. The next call to `.read()` will continue from that point.
  prefs: []
  type: TYPE_NORMAL
- en: Files are opened in a particular mode. Modes define a combination of read/write
    as well as text or binary data. By default, files are opened in read-only and
    text mode, which are described as `'r'` (step 2) or `'rt'` (step 3).
  prefs: []
  type: TYPE_NORMAL
- en: More modes will be explored in other recipes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Crawling and searching directories* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Dealing with encodings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with encodings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text files can be present in different encodings. In recent years, the situation
    has greatly improved, but there are still compatibility problems when working
    with different systems.
  prefs: []
  type: TYPE_NORMAL
- en: There's a difference between raw data in a file and a string object in Python.
    The string object has been transformed from whatever encoding the file contains
    into a native string. Once it is in this format, it may need to be stored in different
    encodings. By default, Python works with the defined by the OS, which in modern
    operating systems is UTF-8.  This is a highly compatible encoding, but you may
    need to save files in a different one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We prepared two files in the GitHub repository that store the string `20£`
    in two different encodings. One in usual UTF8 and another in ISO 8859-1, another
    common encoding. The files are available in GitHub under the `Chapter04/documents` directory,
    with the names `example_iso.txt` and `example_utf8.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Python-Automation-Cookbook](https://github.com/PacktPublishing/Python-Automation-Cookbook)'
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the Beautiful Soup module, presented in the *Parsing HTML* recipe
    in [Chapter 3](d640524b-3aa3-406e-a6d4-842bc61c4658.xhtml), *Building Your First
    Web Scraping Application*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `example_utf8.txt` file and display its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to open the `example_iso.txt` file, which will raise an exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `example_iso.txt` file with the proper encoding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `utf8` file and save its content in an `iso-8859-1` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, read from the new file in the proper format to ensure it is correctly
    saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steps 1 and 2 in the *How to do it…* section are very straightforward. In step
    3, we add an extra parameter, `encoding`, to specify that the file needs to be
    opened in something different to UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: Python accepts a lot of standard encodings right out of the box. Check here
    for all of them and their aliases: [https://docs.python.org/3/library/codecs.html#standard-encodings](https://docs.python.org/3/library/codecs.html#standard-encodings).
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we create a new file in ISO-8859-1 and write to it as usual. Notice
    the `'w'` parameter, which specifies to open it for writing and in text mode.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 is a confirmation that the file is properly saved.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that we know the encoding a file is in. But sometimes we're
    not sure about that. Beautiful Soup, a module to parse HTML, can try to detect
    what encoding a particular file has.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically detecting what encoding a file has may be, well, impossible, as
    there are potentially an infinte number of encodings. But we'll check the usual
    encodings that should cover 90% of the real world cases. Just remember that the
    easiest way of knowing for sure is to ask whomever created the file in the first
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we''ll need to open the file to read in binary format with the `''rb''`
    parameter, to then pass the binary content to the `UnicodeDammit` module of Beautiful
    Soup, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The encoding can then be inferred. Though `.unicode_markup` returns the decoded
    string, it's better to use this suggestion only once, to then open the file in
    our automated task with the proper encoding.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Manipulating strings* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let
    Us Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Parsing HTML* recipe in [Chapter 3](d640524b-3aa3-406e-a6d4-842bc61c4658.xhtml), *Building
    Your First Web Scraping Application*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading CSV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some text files contain tabular data separated by commas. This is a convenient
    way of creating structured data, instead of using proprietary, more complex formats
    such as Excel or others. These files are called **Comma Separated Values**, or
    **CSV**, files and most spreadsheet packages also export to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've prepared a CSV file using the data for the 10 top movies by theatre attendance,
    as described by this page: [http://www.mrob.com/pub/film-video/topadj.html](http://www.mrob.com/pub/film-video/topadj.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We copied the first ten elements of the table into a spreadsheet program (Numbers)
    and exported the file as a CSV. The file is available in the GitHub repository
    in the `Chapter04/documents` directory as `top_films.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/167bb0f1-03c9-4a8f-80af-8faa051e79c5.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the `csv` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file, create a reader, and iterate through it to show the tabular
    data of all rows (only three rows are shown):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file and use `DictReader` to structure the data, including the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the items in `structured_data` is a full dictionary that contains each
    of the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that the file needs to be read, and we use a `with` context manager.
    This ensures that the file is closed at the end of the block.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in step 2 from the *How to do it…* section, the `csv.reader` class
    allows us to structure the returning lines of code by subdividing them as lists,
    following the format of the table data. Notice how all the values are described
    as strings. `csv.reader` does not understand whether the first line is a header
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: For a more structured read of the file, in step 3 we use `csv.DictReader`, which
    by default reads the first row as a header defining the fields described later,
    and then converts each of the rows into dictionaries with those fields.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, like in this case, the names of the fields as described in the file
    can be a little verbose. Don't be afraid to translate the dictionary on an extra
    step into more manageable field names.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As CSV is a very loosely defined interpretation, there are several ways that
    the data can be stored. This is represented in the `csv` module as **dialects**.
    For example, the values can be delimited by commas, semicolons, or tabs. The list
    of default accepted dialects can be displayed by calling `csv.list_dialect`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the dialect will be Excel, which is the most common one. Even other
    spreadsheets will commonly use it.
  prefs: []
  type: TYPE_NORMAL
- en: But dialects can also be inferred from the file itself through the `Sniffer`
    class. The `Sniffer` class analyzes a sample of the file (or the whole file) and
    returns a `dialect` object to allow reading in the proper way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the file is open with no new lines, to not make any assumptions
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The dialect can then be used when opening the reader. Note the `newline` again,
    as the dialect will split the lines correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The full `csv` module documentation can be found here: [https://docs.python.org/3.6/library/csv.html](https://docs.python.org/3.6/library/csv.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Dealing with encodings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading text files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading log files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common structured text file format is **log files**. Log files consist
    of rows of logs, which are a line of text with a particular format. Typically,
    each one will have a time when it happened, so the file is an ordered collection
    of events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `example_log.log` file with five sales logs can be obtained from the GitHub
    repository here: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/documents/example_logs.log](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/documents/example_logs.log).
  prefs: []
  type: TYPE_NORMAL
- en: 'The format is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the `Chapter01/price_log.py` file to process each log into an object.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import `PriceLog`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the log file and parse all logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Determine the total income by all sales:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Determine how many units have been sold of each `product_id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Filter the logs to find all occurrences of selling product ID `1489`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As each of the logs is a single line, we open the file and go one by one, parsing
    each of them. The parsing code is available on `price_log.py`. Check it for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: In Step 2 in the *How to do it…* section, we open the file and process each
    of the lines to create a log list with all our processed logs. Then, we can produce
    aggregation operations, as in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 shows how to aggregate all values, in this case summing the price of
    all items sold over the log file, to get the total revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 uses the Counter to determine the amount of each item in the file log.
    This returns a dictionary-like object with the values to count and the number
    of times they appear.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering can also be done in a line-by-line approach, as shown in step 5\.
    This is similar to the other filtering in the recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that you can stop processing a file as soon as you have all the data
    you need. This may be a good strategy if the file is very big, as is usually the
    case with log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Counter is a great tool to quickly count a list. See the Python documentation
    here for more details: [https://docs.python.org/2/library/collections.html#counter-objects](https://docs.python.org/2/library/collections.html#counter-objects).
    You can get the ordered items by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using a third party tool—parse* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let
    Us Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading text files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading file metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File metadata is everything associated with a particular file that is not the
    data itself. That means parameters such as the size of the file, the creation
    date, or its permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing through that data is important, for example, to filter files older
    than a date, or find all files bigger than a value in KBs. In this recipe, we'll
    see how to access the file metadata in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the `zen_of_python.txt` file, available in the GitHub repository
    ([https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/documents/zen_of_python.txt](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/documents/zen_of_python.txt)).
    As you can see by using the `ls` command, the file has `856` bytes, and, in this
    example, it was created on June 14:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: On your computer the dates may vary, based on when you downloaded the code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import `os` and `datetime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the stats of the `zen_of_python.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the size of the file, in bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain when the file was last modified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain when the file was last accessed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`os.stats` returns a stats object that represents the metadata stored in the
    filesystem. The metadata includes:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the file, in bytes, as shown in step 3 in the *How to do it…* section,
    using `st_size`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the file content was last modified, as shown in step 4, using `st_mtime`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the file was last read (accessed), as shown in step 5, using `st_atime`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The times are returned as timestamps, so in steps 4 and 5 we create a `datetime` object
    from the timestamps to better access the data.
  prefs: []
  type: TYPE_NORMAL
- en: All these values can be used to filter the files.
  prefs: []
  type: TYPE_NORMAL
- en: Notice you don't need to open the file with `open()` to read its metadata. Detecting
    whether a file has been changed after a known value will be quicker than comparing
    its content, so you can take advantage of that for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To obtain the stats one by one, there are also convenience functions available
    in `os.path`, which follow the pattern `get<value>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The value is specified in the UNIX timestamp format (seconds since  January 1, 1970).
  prefs: []
  type: TYPE_NORMAL
- en: Notice calling these three functions will be slower than calling `os.stats` and
    processing the results. Also, returned `stats` can be inspected to detect the
    available values.
  prefs: []
  type: TYPE_NORMAL
- en: The values described in the recipe are available for all filesystems, but there
    are more that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to obtain the creation date of a file, you can use the `st_birthtime`
    parameter for MacOS or `st_mtime` in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '`st_mtime` is always available, but its meaning changes between systems. In
    Unix systems, it will change when the content is modified, so it''s not a reliable
    time of creation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.stat` will follow symbolic links. If you want to get the stats of a symbolic
    link, use `os.lstat()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Check the full documentation about all available stats here: [https://docs.python.org/3.6/library/os.html#os.stat_result](https://docs.python.org/3.6/library/os.html#os.stat_result).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Reading text files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the most common data that is not text is image data. Images had their
    own set of specific metadata that can be read to filter values or perform other
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: A main challenge is dealing with multiple formats and different metadata definitions.
    We'll show in this recipe how to get information from both a JPEG and PNG, and
    how the same information can be encoded differently.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best general toolkit for dealing with images in Python is, arguably, Pillow.
    This module allows you to easily read files in the most common formats, as well
    as perform operations on them. Pillow started as a fork of **PIL** (**Python Imaging
    Library**), a previous module that became stagnant some years ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also use the `xmltodict` module to transform some data in XML to a
    more convenient dictionary. Add both modules to `requirements.txt` and reinstall
    into the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The metadata information in photo files is defined in the **EXIF** (**Exchangeable
    Image File**) format. EXIF is a standard to store information about pictures,
    including things like what camera took the picture, when it was taken, GPS on
    where, exposure, focal length, color info, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can get a good summary here: [https://www.slrphotographyguide.com/what-is-exif-metadata/](https://www.slrphotographyguide.com/what-is-exif-metadata/).
    All the information is optional, but virtually all digital cameras and processing
    software will store some data. Because of the privacy concerns, parts of it, like
    the exact location, can be disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following images will be used for this recipe, and are available to download
    in the GiHub repository ([https://github.com/PacktPublishing/Python-Automation-Cookbook/tree/master/Chapter04/images](https://github.com/PacktPublishing/Python-Automation-Cookbook/tree/master/Chapter04/images)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`photo-dublin-a1.jpg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`photo-dublin-a2.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`photo-dublin-b.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two of them, `photo-dublin-a1.jpg` and `photo-dublin-a2.png`, are the same photo,
    but while the first is the raw picture the second one has been retouched to slightly
    change the colors and crop it. Notice one is in JPEG format and the other in PNG.
    The other one, `photo-dublin-b.png `, is a different picture. Both pictures were
    taken in Dublin, with the same phone camera, on two different days.
  prefs: []
  type: TYPE_NORMAL
- en: While Pillow understands how JPG files store the EXIF info directly, PNG files
    store XMP info, a more generic standard that can contain EXIF info.
  prefs: []
  type: TYPE_NORMAL
- en: More info about XMP can be obtained here: [https://www.adobe.com/devnet/xmp.html](https://www.adobe.com/devnet/xmp.html).
    For the most part, it defines an XML tree structure that's relatively readable
    in raw.
  prefs: []
  type: TYPE_NORMAL
- en: To further complicate it, XMP is a subset of RDF, which is a standard describing
    the way of encoding the information.
  prefs: []
  type: TYPE_NORMAL
- en: If EFIX, XMP, and RDF sounds confusing, well, it's because they are. Ultimately,
    they are just names to store the values we are interested in. We can inspect the
    specifics of the names using Python introspection tools and check exactly how
    the data is structured and what the name of the parameter we are looking for is.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the GPS information is stored in different formats, we''ve included in the
    GitHub repository a file called `gps_conversion.py`, here: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/gps_conversion.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/gps_conversion.py). This
    includes the functions `exif_to_decimal` and `rdf_to_decimal`, which will transform
    both formats into decimals to compare them.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the modules and functions to use in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the first photo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the width, height, and format of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the EXIF information of the image, and process it for a convenient
    dictionary. Show the camera, the lens used, and when it was taken:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the second image and obtain the XMP info:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the RDF description field, which contains all the values we are looking
    for. Retrieve the model (a TIFF value), the lens model (an EXIF value), and the
    creation date (an XMP value). Check the values are the same as in step 4, even
    if the file is different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the GPS information in both pictures, transform into an equivalent format,
    and check that they are the same. Notice that the resolution is not the same,
    but they match up to the fourth decimal point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the third image and obtain the creation date and GPS info, and check it
    doesn''t match the other photo, although it is close (the second and third decimals
    are not the same):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pillow is able to interpret files in most common languages, and open them as
    images in JPG format, as shown in step 2 in the *How to do it…* section.
  prefs: []
  type: TYPE_NORMAL
- en: The `Image` object contains the basic information about the size and format
    of the file, and is displayed in step 3\. The `info` property contains information
    that is dependent on the format.
  prefs: []
  type: TYPE_NORMAL
- en: The EXIF metadata for JPG files can be parsed with the `._getexif()` method,
    but then it needs to be translated properly, as it uses the raw binary definition.
    For example, the number 42,036 corresponds to the `LensModel` property. Fortunately,
    there's a definition of all tags in the `PIL.ExifTags` module. We translate the
    dictionary to readable tags in the step 4 to obtain a more readable dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 opens a PNG format, which has the same properties related to size, but
    the metadata is stored in XML/RDF format and needs to be parsed with the help
    of `xmltodict.` Step 6 shows how to navigate this metadata to extract the same
    information as in the JPG format. The data is the same, as both files come from
    the same original picture, even if the images are different.
  prefs: []
  type: TYPE_NORMAL
- en: '`xmltodict` has some issues when trying to parse data that''s not in XML format.
    Check that the input is valid XML.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 extracted the GPS information for both images, which is stored in different
    ways, and shows they are the same (although the precision is different because
    of the way it is encoded).
  prefs: []
  type: TYPE_NORMAL
- en: Step 8 shows the information on a different photo.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pillow also has a lot of functionality around modifying pictures. It is very
    easy to resize or make simple modifications to a file, such as rotating it. You
    can find the complete Pillow documentation here: [https://pillow.readthedocs.io](https://pillow.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: Pillow allow a lot of operations with images. Not only simple operations such
    as resizing or transforming one format into another, but also things like cropping
    the image, applying color filters, or generating animated GIFs. If you're interested
    in image processing using Python, it is definitely something to take a look at.
  prefs: []
  type: TYPE_NORMAL
- en: The GPS coordinates in the recipe are stated in **DMS** (**Degrees**, **Minutes**,
    **Seconds**), **DDM** (**Degrees**, **Decimal Minutes**), and transformed into
    **DD** (**Decimal Degrees**). You can find more about the different GPS formats
    here: [http://www.ubergizmo.com/how-to/read-gps-coordinates/](http://www.ubergizmo.com/how-to/read-gps-coordinates/).
    You'll also find how to search the exact locations of the pictures there, in case
    you're curious.
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced use of reading image files is to try to process them for **OCR**
    (**Optical Character Recognition**). This means automatically detecting text in
    an image and extracting and processing it. The open source module `tesseract`
    allows you to do this, and it can be used with Python and Pillow.
  prefs: []
  type: TYPE_NORMAL
- en: You need to install `tesseract` in your system ([https://github.com/tesseract-ocr/tesseract/wiki](https://github.com/tesseract-ocr/tesseract/wiki)),
    and the `pytesseract` Python module (using `pip install pytesseract`). You can
    download a file with clear text, called `photo-text.jpg`, from the GitHub repository
    at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/images/photo-text.jpg](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/images/photo-text.jpg)[:](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/images/photo-text.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'OCR can be difficult if the text is not very clear in the image, or it is mixed
    with images, or it uses a distinctive font. There''s an example of that in the `photo-dublin-a-text.jpg` file,
    (available in the GitHub repository at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/images/photo-dublin-a-text.jpg](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter04/images/photo-dublin-a-text.jpg)),
    which includes text over the picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'More information about Tesseract is available at the following links: [https://github.com/tesseract-ocr/tesseract](https://github.com/tesseract-ocr/tesseract)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/madmaze/pytesseract](https://github.com/madmaze/pytesseract)'
  prefs: []
  type: TYPE_NORMAL
- en: Properly importing files to OCR may require initial image processing for better
    results. Image processing is out of scope for the objectives of this book, but
    you may use OpenCV, which more powerful than Pillow. You can process a file and
    then open it with Pillow: [http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html](http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Reading text files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading file metadata* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Crawling and searching directories* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading PDF files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common format for documents is **PDF** (**Portable Document Format**). It
    started as a format to describe a document for any printer, so PDF is a format
    that ensures that the document will be printed exactly as it shows, and therefore
    is a great way of guaranteeing consistency. It has become a powerful standard for
    sharing documents, especially documents that are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we are going to use the `PyPDF2` module. We need to add it
    to our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the GitHub directory `Chapter03/documents`, we have prepared two documents,
    `document-1.pdf` and `document-2.pdf`, to use in this recipe. Note they contain
    mostly Lorem Ipsum text, which is just placeholder text.
  prefs: []
  type: TYPE_NORMAL
- en: Lorem Ipsum text is commonly used in design to show text without needing to
    create the content before the design. Learn more about it here: [https://loremipsum.io/](https://loremipsum.io/).
  prefs: []
  type: TYPE_NORMAL
- en: They are both the same test document, but the second one can only be opened
    with a password. The password is `automate`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `document-1.pdf` file and create a PDF document object. Notice the
    file needs to be open for the whole reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the number of pages of the document, and check it is not encrypted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the creation date from the document info (`2018-Jun-24 11:15:18`), and
    discover that it has been created with a Mac `Quartz PDFContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the first page, and read the text on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same operation for the second page (redacted here):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the file and open `document-2.pdf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the document is encrypted (it requires a password) and raises an error
    if trying to access its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Decrypt the file and access its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the file to clean up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the document is open, as shown on steps 1 and 2 in the *How to do it…*
    section, the `document` object provides access to the document.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting properties are the number of pages, available in `.numPages`,
    and each of the pages, available in `.pages`, which can be accessed like a list.
  prefs: []
  type: TYPE_NORMAL
- en: Other data accessible is stored in `.documentInfo`, which stores metadata on
    the creator and when it was created.
  prefs: []
  type: TYPE_NORMAL
- en: The information in `.documentInfo` is optional and sometimes not up-to-date.
    It depends greatly on the tool used to generate the PDF.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the `page` objects can get its text by calling `.extractText()`, which
    will return all the text contained in the page, as done in steps 5 and 6\. This
    method tries to extract all text, but it has some limitations. For well-structured
    texts, such as our example, it works quite well and the resulting text can be
    processed cleanly. Dealing with text in multiple columns or located in strange
    positions, it may complicate working with it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the PDF file needs to be open for the whole operation, instead of
    using a `with` context operator. After leaving the `with` block, the file is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 8 and 9 shows how to deal with encrypted files. You can detect whether
    a file is encrypted or not with `.isEncrypted`, and then decrypt it with the `.decrypt`
    method, giving the password.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PDF is such a flexible format that it is very standard, but that also means
    that it can be difficult to parse and process.
  prefs: []
  type: TYPE_NORMAL
- en: While most PDF files contain text information, it is not uncommon that they
    contain images. This, for example, happens very often with scanned documents.
    This means that the information is stored as a collection of images, instead of
    in text. This makes it difficult to extract the data; we end up having to resolve
    to methods such as OCR to parse the images into text.
  prefs: []
  type: TYPE_NORMAL
- en: PyPDF2 does not provide a good interface to deal with images. You may need to
    transform the PDF into a collection of images and then process them. Most PDF
    readers can do it, or you can use a command-line tool such as `pdftooppm` ([https://linux.die.net/man/1/pdftoppm](https://linux.die.net/man/1/pdftoppm))
    or QPDF (see the following). See the *Reading images* recipe  for ideas about
    OCR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some ways of encrypting files may not be understood by PyPDF2\. It will generate
    `NotImplementedError: only algorithm code 1 and 2 are supported`. If that happens,
    you need to decrypt the PDF externally and open it once it is decrypted. You can
    use QPDF to create a copy without the password, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The full QPDF is available here: [http://qpdf.sourceforge.net/files/qpdf-manual.html](http://qpdf.sourceforge.net/files/qpdf-manual.html).
    QPDF is available in most package managers as well.
  prefs: []
  type: TYPE_NORMAL
- en: QPDF is capable of doing a lot of transformations and analyzing PDFs in-depth.
    There are also bindings into Python on a module called `pikepdf` ([https://pikepdf.readthedocs.io/en/stable/](https://pikepdf.readthedocs.io/en/stable/)).
    This module is more difficult to use than PyPDF2 and it's not as straightforward
    for text extraction, but it can be useful if other operations such as extracting
    images from a PDF are required.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Reading text files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Crawling and searching directories* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading Word documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Word documents (`.docx`) are another common kind of document that stores text.
    They are typically generated with Microsoft Office, but other tools also produce
    compatible files. They are probably the most common format to share files that
    need to be editable, but they are also common for distributing documents.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see in this recipe how to extract text information from a Word document.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the `python-docx` module to read and process Word documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We have prepared a test file, available in the GitHub `Chapter04/documents`
    directory, called `document-1.docx`, which we'll use with this recipe. Note that
    this document follows the same Lorem Ipsun pattern that was described in the test
    document for the recipe *Reading PDF files* recipe .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import `python-docx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `document-1.docx` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Check some of the metadata properties stored in `core_properties`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the number of paragraphs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Walk through the paragraphs to detect the ones that contain text. Notice not
    all text is displayed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the text for paragraphs `30` and `31`, which correspond to the title
    and subtitle on the first page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the paragraphs has `runs`, which are sections of the text with different
    properties. Check that the first text paragraph and `run` is in bold and the second
    is in italics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In this document, most of the paragraphs have only one `run`, but we have a
    good example of different runs in paragraph `48`. Display its text and the different
    styles. For example, the word `Word` is in bold, and `ipsum` is in italics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important peculiarity of Word documents is that the data is structured
    in paragraphs, instead of in pages. The size of the font, line size and other
    considerations may make the number of pages change.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the paragraphs are also typically empty, or include only new lines,
    tabs, or other whitespace characters. It is a good idea to check when a paragraph
    is empty and skip it.
  prefs: []
  type: TYPE_NORMAL
- en: In the *How to do it…* section, step 2 opens the file and step 3 shows how to
    access the core properties. These are properties that are defined in Word as document
    metadata, such as the author or creation date.
  prefs: []
  type: TYPE_NORMAL
- en: This information needs to be taken with a grain of salt, as a lot of tools that
    produce Word documents (but not Microsoft Office) won't necessarily fill it. Double-check
    before using that information.
  prefs: []
  type: TYPE_NORMAL
- en: The paragraphs of the document can be iterated and have their text extracted
    in raw format, as shown in step 6\. This is information that doesn't include styling
    information and it's typically the most useful one for processing the data automatically.
  prefs: []
  type: TYPE_NORMAL
- en: If the styling information is required, the runs can be used, as in steps 7
    and 8\. Each paragraph can contain one or more runs, which are smaller units that
    share the same styling. For example, if a sentence is *Word1* word2 **word3**,
    there will be three runs, one with italic text (Word1), another with underline
    (word2), and another with bold (word3). Even more so, there can be intermediate
    runs with regular text that contains just the whitespaces, making a total of 5
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: The styling can be detected individually on properties such as bold, italic,
    or underline.
  prefs: []
  type: TYPE_NORMAL
- en: The division in runs can quite complicated. Due to the way editors work it,
    is not uncommon to have *half-words,* a split word in two runs, sometimes with
    the same properties. Do not rely on the number of runs and analyse the content.
    In particular, double-check if trying to ensure if a part with a particular style
    is divided in two or more runs. A good example is the words `lore` `m` (it should
    be `lorem`) in Step 8.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that, because Word documents are produced by so many sources, a lot
    of properties may not be set up, leaving it to the tool on what specifics to use.
    For example, is very common to keep the default font, which may mean that the
    font information is left empty.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Further style information can be found under the font attribute, such as `small_caps`
    or size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Normally focusing on the raw text, without paying attention to the style information
    is the correct parsing. But sometimes a bold word in a paragraph, will have special
    significance. It may be the header or the result you're looking for. Because it's
    highlighted, it likely is what you're looking for! Keep that in mind when analysing
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the whole `python-docx` documentation here: [https://python-docx.readthedocs.io/en/latest/](https://python-docx.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Reading text files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading PDF files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning documents for a keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will join all the lessons of the previous recipes and will
    search the files in the directory for a particular keyword. This is a recap of
    the rest of the recipes in this chapter and includes a script that searches different
    kinds of files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Be sure to include all the following modules in the `requirements.txt` file
    and install them into your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the directory to search has the following files (all are available
    in GitHub in the `Chapter04/documents` directory). Note that `file5.pdf` and `file6.pdf`
    are copies of `document-1.pdf`, for simplicity. `file1.txt` to `file4.txt` are
    empty files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We've prepared a script, `scan.py`, that will search for a word in all the `.txt`,
    `.csv`, `.pdf`, and `.docx` files. The script is available in the `Chapter04`
    directory of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to help `-h` for how to use the `scan.py` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for the word `the`, which is present in most of the files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for the word `lorem`, only present in the PDF and docx files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for the word `20£`, only present in the two ISO files, with different
    encodings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The search is case insensitive. Search for the word `BETTER`, only present
    in the `zen_of_python.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The file `scan.py` has the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: An entry point that parses the input parameters and creates the help for the
    command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A main function that walks through the directory and analyses each of the files found.
    Based on their extension, it decides whether there's an available function to
    process and search it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `EXTENSION` dictionary, which pairs the extensions with the function to search
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `search_txt`, `search_csv`, `search_pdf`, and `search_docx` functions, which
    process and search for the required word for each kind of file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The comparison is case-insensitive, so the search word is transformed in lower
    case and, in all comparisons, the text is transformed into lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the search functions have their own peculiarities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`search_txt` first opens the file to determine its encoding, using `UnicodeDammit`,
    then it opens the file and reads it line by line. If the word is found, it stops
    immediately and returns success.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`search_csv` opens the file in CSV, and iterates not only line by line, but
    also column by column. As soon as the word is found, it returns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`search_pdf` opens the file and exits if it is encrypted. It not, it goes page
    by page, extracting the text and comparing it with the word. It returns as soon
    as it finds a match.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`search_docx` opens the file and iterates through all its paragraphs for a
    match. As soon as a match is found, the function returns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some extra ideas that could be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: More search functions could be added. In this chapter, we went through log files
    and images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A similar structure could work for searching for files and returning only the
    last 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search_csv` is not sniffing to detect the dialect. This could be added as
    well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading is quite sequential. It should be possible to read the files in parallel,
    analyzing them for faster returns, but be aware that reading files in parallel
    can lead to sorting issues, as the files won't always be processed in the same
    order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Crawling and searching directories* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading text files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Dealing with encodings* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading CSV files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading PDF files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reading Word documents* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
