- en: Using ipfsapi to Interact with IPFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to interact with IPFS programmatically
    with Python. There are a couple of interactions that we can do here, such as adding
    files, retrieving files, hosting mutable files, subscribing to topics, publishing
    topics, and copying files to the **Mutable File System** (**MFS**). First, we
    have to install the IPFS software and launch it. Then, we will learn how to install
    the IPFS Python library and learn about most of its API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the IPFS software and it's library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ipfsapi API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the IPFS software and its library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of writing, there are only two IPFS implementations: `go-ipfs`
    (written in the Go language) and `js-ipfs` (written in JavaScript). There is no
    IPFS implementation written in Python as of yet. The Go implementation is the
    more popular one, so we will use that.'
  prefs: []
  type: TYPE_NORMAL
- en: Go to, [https://dist.ipfs.io/#go-ipfs](https://dist.ipfs.io/#go-ipfs), and download
    the software for your platform. For Ubuntu Linux, the file is named `go-ipfs_v0.4.18_linux-amd64.tar.gz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract this using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the binary using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This step is optional. Here, we export the `IPFS_PATH` environment variable
    to our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is where the `ipfs` stores the files. You can store this statement in `~/.bashrc`.
    By default (without this environment variable), the `ipfs` would use `~/.ipfs`
    (the `.ipfs` directory in the home directory) as the place to store data.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting up the environment variable, initialize the `ipfs` local repository.
    You only perform this step once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the `ipfs` in the cloud (such as Amazon Web Services, Google Cloud
    Platform, Digital Ocean, or Azure), you should use a server profile flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If not, you will get a pesky warning letter from the cloud provider because
    the IPFS `daemon`, by default (without a server profile flag), would do something
    resembling port scanning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, launch `daemon`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By default, the API server is listening on port 5001\. We will interact with
    the IPFS programmatically through this port. By default, it only listens in localhost.
    Be careful if you want to open this port to the outside world. There is no **Access
    Control List** (**ACL**) in the IPFS. Anyone who has access to this port can upload
    data to the IPFS.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Gateway server is listening on port 8080\. We download the file
    from the IPFS peer-to-peer file system using this port. The Swarm, by default,
    is listening on port 4001\. This is how other nodes download the file from our
    storage. All of these ports can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IPFS has a dashboard that can be accessed at the following link: [http://localhost:5001/webui](http://localhost:5001/webui).
    The following is a screenshot of the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f8ed742f-d554-4bb6-a2df-99f53cb32300.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, most IPFS nodes are located in the US, China, and Germany.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Peers tab to see the distribution of IPFS nodes according to their
    IP address, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/151a3ee6-7eb8-47cb-afda-750c2d72faea.png)'
  prefs: []
  type: TYPE_IMG
- en: The nodes can be seen in this tab, including their IP addresses. If you are
    concerned about the privacy of nodes, bear in mind that the development of the
    privacy feature is still in its infancy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure the IPFS setting in the Settings tab, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e13e2e31-c830-4c68-8b0e-b8b5f7f06e68.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our IPFS daemon has been launched, let's install our `ipfs` Python
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal since we don''t want to disturb our daemon. Then, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the `ipfs` Python library was called `py-ipfs-api`, but it has since
    been renamed to `ipfsapi`.
  prefs: []
  type: TYPE_NORMAL
- en: Content hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the IPFS quick start documentation ([https://docs.ipfs.io/introduction/usage](https://docs.ipfs.io/introduction/usage)),
    the first thing that they teach you is to download the cute cat picture. Use the
    following code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, the cat picture will be downloaded and you
    will get the following as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/53ded3eb-4636-40f0-992a-b8fc5e79a398.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`eog` is an image viewer in Ubuntu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To respect the tradition, let''s create a Python script to download the preceding
    image programmatically with Python and name the script `download_cute_cat_picture.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After executing this script, the image will be named `cat.jpg` in your directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, there is a `cat.jpg` filename after the long hash.
    Technically speaking, what we are doing here is downloading a file inside a directory
    that contains a cute cat picture. You can try this if you like. To do so, create
    another script and name it `download_a_directory_of_cute_cat_picture.py` and then
    run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After executing this script, you will get a directory named `QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ`
    in the directory that contains this script. If you peek inside this directory,
    you will find the cat picture file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the script line by line to understand the usage of the `ipfsapi`
    library. You can use the following code to import the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is used to get a connection object to IPFS daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `connect` method accepts a couple of parameters. The two most important
    parameters are `host` and `port`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, we connect to localhost with port 5001:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the methods of the IPFS HTTP API from the *c* object. `get` is
    one of the methods that''s used to interact with IPFS daemon. For this method,
    there is usually an equivalent argument with the `ipfs` client software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that we use the `ipfs cat` command in the command-line interface
    before we created our first Python script. However, in the script, we use the
    `get` method. There is also a `cat` method in the `ipfsapi` library.
  prefs: []
  type: TYPE_NORMAL
- en: The `get` method is used to download the file, while the `cat` method is used
    to get the content of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script that uses the `cat` method and name it `cat_cute_cat.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` method returns the bytes object of the content of the file. It accepts
    two optional parameters, `offset` and `length`. `offset` is a starting position
    in the file where you want to start to get the content. `length` is the length
    of the content you want to get starting from the `offset `position. These parameters
    are important if you want to build a download manager (with pausing and resuming
    capabilities) or a video streaming player. You may not always want to download
    the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a file to the IPFS. To do this, create a simple file and name
    it `hello.txt`. This is the content of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you have a new line after the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the command prompt comes after the line of the string, then all is well.
    You can carry on.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Let''s say the command prompt comes on the right of the string, as
    shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means you don't have the new line and you need to add this after the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a script to add this file to the IPFS and name it `add_file.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this code will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve the content of the file, which is `I am a good unicorn.\n`,
    by using the `cat` or `get` method. Let''s use the `cat` method in the script
    named `get_unicorn.py`, as given in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in [Chapter 10](f50b5479-887d-48ab-a1db-381f2d3beb4f.xhtml)
    , *InterPlanetary – A Brave New File System*, we get the content of the file through
    the hash. Through this, we only retrieve the content, not the name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do you turn `b''I am a good unicorn.\n''` into `''QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR''`?
    Is it just by hashing the content? For example, to `hash` the content of the file,
    you could use the SHA-256 hash function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Not so fast! It turns out you need to learn about protobuf, multihash, and base58
    first to understand the process. Let's discuss these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Protobuf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have tried to install Google open source software such as `Tensorflow`,
    you would encounter protobuf because it is used by `Tensorflow`. `Protobuf` is
    a serialization library. If you learned about Python from the official documentation,
    you would know that Pickle as a way to serialize data. If you learned about web
    development programming, most likely, you would use `.json` or `.xml` as data
    serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we pass `b''I am a good unicorn.\n''` to the IPFS, we wrap our data
    in a data structure. Let''s create a script to prove my claim and name the script
    `get_unicorn_block.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the script will allow you to see that the content of the file is wrapped
    by other stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we still have our content of the file intact, `b'I am a good
    unicorn.\n'`, between the cryptic strings. What are the junk characters on the
    left and on the right? This is the data structure of a data node in the IPFS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we unserialize this serialized data, let''s quickly learn how to use
    `protobuf`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `protobuf-compiler` using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `protobuf` compiler is `protoc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s install the Python `protobuf` library using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Before serializing data with `protobuf`, you need to create a data structure
    format first. The format must be saved in a file. Let''s name the format file
    `crypto.proto` and use the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When you look at this data structure, it's like a struct or class without methods.
    After declaring the syntax you use, you declare the `package` to avoid a name
    collision. `message` is just like a class or struct keyword in another mainstream
    programming language. This `message` is an encapsulation of many data types. In
    our case, they are `string`, `int32`, and `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can serialize data with protobuf in Python, we need to convert this
    `.proto` file into a Python module file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `python_out` parameter is used to indicate in which directory you want to
    output this Python file.
  prefs: []
  type: TYPE_NORMAL
- en: You should get the `crypto_pb2.py` file generated for you. Refer to the code
    file in GitLab link for the script: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_11](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_11).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you did not read the comment on the top of the file, let me read it for
    you: Do not edit the file directly. If you want to change the data structure in
    a serialization process, you modify the `.proto` file and then compile it. Now
    that you have this `Python` library file generated for you, you can throw away
    the `.proto` file. However, it''s a good idea to keep it for documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test the serialization and unserialization processes with a Python
    script. Name the script `serialize_crypto_data.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the script, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The serialized output, `b'\n\x0cBitcoin Cash\x10\xc0\xde\x81\n\x18\x00'`, resembles
    our unicorn data block in the IPFS. If you parse this binary data, you should
    get the original Python object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the basic usage of protobuf, let''s get back to our
    block data in the IPFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is the serialized data in protobuf. Before we unserialize it, we need to
    get the related `.proto` files. Apparently, we need two `.proto` files, `unixfs.proto`
    and `merkledag.proto`.
  prefs: []
  type: TYPE_NORMAL
- en: '`unixfs.proto` can be downloaded from [https://github.com/ipfs/go-unixfs/blob/master/pb/unixfs.proto](https://github.com/ipfs/go-unixfs/blob/master/pb/unixfs.proto),
    while `merkeldag.proto` can be downloaded from [https://github.com/ipfs/go-merkledag/blob/master/pb/merkledag.proto](https://github.com/ipfs/go-merkledag/blob/master/pb/merkledag.proto).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the content of the `unixfs.proto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block is the content of the `merkledag.proto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the process, you should remove the following lines in the `merkledag.proto`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, compile both `.proto` files using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After doing this, you will get the `unixfs_pb2.py` and `merkledag_pb2.py` files
    that were generated as the output.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a script to decode our block data, `b'\n\x1b\x08\x02\x12\x15I am
    a good unicorn.\n\x18\x15'`, and name the script `unserialize_unicorn.py`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script. This will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let's dissect what’s happening here. Our original data, `b'I am a good unicorn.\n'`,
    is wrapped in `Data` from the `unixfs` proto module, and is then wrapped again
    in `PBNode` from the `merkledag` proto module. That's why we unserialize the serialized
    data in the script with `PBNode` first. Then, we unserialize the result with `Data`.
  prefs: []
  type: TYPE_NORMAL
- en: Multihash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's hash the serialized data. IPFS uses multihash to hash the data. This
    means it is not just outputting the hash output, but it also outputs the hash
    function that it uses, the length of the hash output from that hash function,
    and the hash output from that hash function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of the usage of multihash. Suppose the data
    that we want to hash is `b''i love you''`. We choose `sha256` as a hash function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out the length of this hash output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since a number in hexadecimal format always takes two characters, the length
    of the hash output is 32 (64 / 2). However, we want the hexadecimal version of
    32, which is 0x20 or `20`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a hash function table that lists all hash functions that multihash
    supports (sha1, shake, blake, keccak, and so on). This can be seen here: [https://github.com/multiformats/multicodec/blob/master/table.csv](https://github.com/multiformats/multicodec/blob/master/table.csv).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `sha256` is given the number `12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we combine them using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s do this again, but using another function, which is `sha1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The hex version of 20 (40 / 2) is 0x14, or `14`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sha1` hash function is given the number 0x11 or `11` from the hash functions
    table. Hence, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So, why would you want to use multihash and not just a normal hash function,
    such as `sha1`, `sha256`, or `keccak256`? The argument is sometimes that the hash
    function is broken, meaning that someone could find two different inputs with
    the same hash output in a reasonable time. If this happens, it is very dangerous.
    Hashing is used for integrity checks. Imagine I sent you a secret document to
    create a cure for cancer. To make sure it is not tampered with, we hash this document
    and then broadcast the hash output. Consequently, anyone who wants to learn this
    document needs to verify the hash of the document first before reading and executing
    it. However, imagine my enemy could create a different document. Now, instead
    of a cure for cancer, this document is a guide to creating a virus, but it still has
    the same hash output. If you hash the wrong document, you will innocently execute
    the file and create the virus.
  prefs: []
  type: TYPE_NORMAL
- en: If a hash function is broken (and it happened, the `sha1` hash function is already
    broken), programmers need to upgrade their system. However, they will encounter
    difficulties because usually, they make assumptions regarding the hash function.
    For example, if they use the `sha1` function, they would expect the output from
    the hash function to be 20 numbers in length. If they choose to upgrade the hash
    function to `sha256`, they need to replace all the code that anticipates a length
    of 20 characters when dealing with the old hash function, which is cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: With `multihash`, we expect the upgrade process to be simplified because the
    function and the length of the output of the hash function is embedded in the
    output of the `multihash` function. We no longer make assumptions regarding the
    length of hashing output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still cannot get your head around the motivation of `multihash`, let''s
    experiment with it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you observe that when we want to check the integrity of the `b''i love
    you'' `data, we don''t make assumptions regarding the length of the hash output?
    We then discovered the bad news that the `sha1` hash function is broken. To upgrade
    our system, what we need to do is merely replace the `''sha1''` string with the `''sha2_256''`
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: By using multihash, upgrading the hash function in the IPFS software becomes
    an easy task. The hash function is just a matter of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Base58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing we need to learn is `base58`. Base58 is a modified version of
    `base64`. This is usually used to encode the binary data as an ASCII string. The
    following code block is used to encode `b''i love you''` as an ASCII string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `base64` module is part of the Python standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, you will not encode another ASCII string with `base64`. Instead, you
    will encode binary data, such as an image file. If you open `cat.jpg` with the
    text editor, you would get gibberish text similar to the text that''s shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f82c64d6-d77d-4a81-8569-18c5a45381bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a perfect example of encoding with `base64`. Why would you want to
    encode binary data with `base64`? One of the use cases is if you want to attach
    a cute cat picture in an email to your friend. Email protocol does not allow binary
    data. The following code block shows what the result will be if we attach the
    picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The process of encoding with `base64` (how you turn `b'i love you'` into `b'aSBsb3ZlIHlvdQ=='`)
    is beyond the scope of this book. You can look into the `base64` specification
    if you are curious enough.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with `base64`, `base58` will be very simple. In `base58`
    encoding, the ambiguous letters when printed, such as 0, O, I, and l, are removed.
    The + (plus) and / (slash) characters are also removed. This `base58` encoding
    was designed by Satoshi Nakamoto to encode large integers. A Bitcoin address is
    just a very large integer in a nutshell. If you have ever transferred any amount
    in cryptocurrency (not necessarily Bitcoin), you would most likely have double
    checked the address to make sure the address is correct. For example, you want
    to transfer 1 Bitcoin to your grandma's Bitcoin address, and her address is `1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2`.
    If you are like most people, you would verify the correctness of the address a
    couple of times to make sure the address is not incorrect. By removing ambiguous
    characters such as 0, O, I, and l, you would find it easier to make sure this
    address is what it is supposed to be. Base58 is one of the good UX designs in
    software that is used to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: So, `base58` is not designed to encode a cute cat picture. You would use `base64`
    encoding for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the `base58` library to experiment with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: By using `base58`, we can create a long hexadecimal string that can be checked
    and verified with ease using our own eyes.
  prefs: []
  type: TYPE_NORMAL
- en: Combining protobuf, multihash, and base58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned about protobuf, multihash, and base58, we can finally make
    sense of the puzzle of how the content of the `b'I am a good unicorn.\n'` file turned
    into `'QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR'`.
  prefs: []
  type: TYPE_NORMAL
- en: The `b'I am a good unicorn.\n'` data is wrapped in an IPFS node and serialized
    with protobuf into `b'\n\x1b\x08\x02\x12\x15I am a good unicorn.\n\x18\x15'`.
    Here's how to do it in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script and name it `serialize_unicorn.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it. You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then, this protobuf-serialized data is hashed with `sha256` (the multihash in
    the IPFS uses the `sha256` hashing function by default) into `'912d1af8f0013cd12a514859d20e9a196eb2845981408a84cf3543bb359a4536'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to do it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of `sha256` functions in the multihash table used by the IPFS is
    12\. The table can be seen here: [https://github.com/multiformats/multicodec/blob/master/table.csv](https://github.com/multiformats/multicodec/blob/master/table.csv).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The length of the hash output is `32`, or 0x20 in hexadecimal. One hex number
    occupies two characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s concatenate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you encode this output in base58 encoding, you should get `'QmY7MiYeySnsed1Z3KxqDVYuM8pfiT5gGTqprNaNhUpZgR'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you do it in Python. The `b58encode()` method only accepts byte
    objects, not hexadecimal objects, so you have to convert hexadecimal string into
    byte objects first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`codecs` is part of the Python standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon executing the code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! The puzzle has finally been solved.
  prefs: []
  type: TYPE_NORMAL
- en: The ipfsapi API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go back to the API of ipfsapi. We have added a file with IPFS API and
    received the hash that we use to refer to the content of the file. But if we add
    a big file, this will be split into many chunks. This is for efficiency purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's download quite a big image file from Unsplash. Go to, [https://unsplash.com/photos/UBtUB4Qc-_4](https://unsplash.com/photos/UBtUB4Qc-_4) to
    download an image file. The name of the downloaded file is `milada-vigerova-1284157-unsplash.jpg`.
    Put this in the same directory as your IPFS Python script files. You could use
    any image file for this, but make sure its size is at least 1 MB. However, if
    you use another image file, you should get a different hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script named `add_image_file.py` using the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it. You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create another script to list all blocks from this block and name the
    script `list_blocks.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`pprint` is part of the Python standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script. You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As I have explained in [Chapter 10](f50b5479-887d-48ab-a1db-381f2d3beb4f.xhtml),
    *InterPlanetary – A Brave New File System*, a big file would not be hashed straight
    away because of memory concerns. Instead, it will be divided into many chunks.
    Each chunk has a size of 262,158 bytes, except for the last one. However, you
    can configure the size of the chunk. Each chunk would be hashed separately. Then,
    the root hash of the content of the file is the combination of these hashes. The
    IPFS uses the Merkle tree to calculate the root hash. Of course, however, you
    must wrap each chunk inside the IPFS node before serializing it with protobuf.
    Then, there will be the container node that contains all of the links to these
    chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can reverse engineer the following IPFS block without `.proto` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the hash from this image file. Get the IPFS block of this file content.
    You can use Python script or the IPFS command-line utility to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We save the block, which is in binary format, to a binary file. Then, we can
    `decode` this binary file using the `protoc` compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be familiar with this structure. When you decode the serialized data
    in protobuf without proto files, the problem is that you have to guess what 1,
    2, 3, and 4 means inside a certain block. If you have proto files, this line, `3:
    2604197`, would turn into `filesize: 2604197`. Consequently, it is a good idea
    to get the proto files before decoding serialized data in protobuf.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reconstruct the original file from these chunks. Let''s create the script
    and name it `construct_image_from_blocks.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: After running the script, if you open `image_from_blocks.jpg`, you will view
    the original image file.
  prefs: []
  type: TYPE_NORMAL
- en: We have added one file. Now, let's try to add a directory of files.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `mysite`. Inside this directory, create a directory
    named `img`. Put the `cat.jpg` image file inside this `img` directory. Then, adjacent
    to the `img` directory, create a file named `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the content of `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `README.md` file adjacent to the `img` directory as well. The
    following code block is the content of the `README.md` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a Python script to add this directory to the IPFS and name the
    script `add_directory.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the, script will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The second argument of the `add` method concerns `recursive` arguments. The
    IPFS uses the Merkle DAG data structure to save this directory of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can open our website in a browser with the following URL: `http://localhost:8080/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/`.
    The following screenshot is how the website will appear in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59d9a3a2-3131-4d20-a21d-0e5fcf154063.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You could also access the IPFS path from another gateway (using another node)
    using the following URL: [https://ipfs.io/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/](https://ipfs.io/ipfs/QmZamPcNnfZjjTkoyrYjYMEA8pp29KmpmkuSvkicSGiZDp/).
    Depending on your internet connection, this could take some time because a node
    in the ipfs.io server needs to locate the content in your computer.'
  prefs: []
  type: TYPE_NORMAL
- en: IPNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to publish a file or a directory of files in which their integrities
    are guarded by hashes is wonderful. Occasionally, however, you may want to be
    able to publish a dynamic file with the same link. What I mean here is that a
    hash link would generate different content at different times. One of the use
    cases is that you want to publish news. Depending on the situation, news can change
    every minute or hour.
  prefs: []
  type: TYPE_NORMAL
- en: The way you do that is by using the **Interplanetary Name System** (**IPNS**).
    The hash link is derived from the cryptography key in our IPFS node. When we launch
    the IPFS daemon, we become one node among many in IPFS peer-to-peer networks.
    Our identity is based on a cryptography key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two horoscope predictions. The predictions here should change
    over time. The first filename is `horoscope1.txt`, and the content of this file
    is given in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The second filename is `horoscope2.txt`, and the content of this file is given
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add those two files using this Python script, named `add_horoscope_predictions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note these two hashes that we obtained in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a script to list all of our keys and name the script `keys_list.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding script will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s publish our first horoscope prediction. Create a Python script
    named `publish_horoscope1.py` using the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this may take a while. Publishing a file in the IPNS is a little slow.
    If you are patient enough, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You publish content with the `name_publish()` method. It accepts a hash link
    of the content (IPFS path, not the filename) as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to access the content from the IPFS, you can use the `cat` or `get` methods.
    Here, we are using the `cat` method. The argument for the `cat` method is not
    a hash link or IPFS path, but an IPNS path, which is just a key that you can get
    from the `keys_list.py` script. You must prefix this with the `'/ipns/'` string.
    Consequently, the IPNS path is `'/ipns/ QmVPUMd7mFG54zKDNNzPRgENsr5VTbBxWJThfVd6j9V4U8'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s publish more data. Create a script named `publish_horoscope2.py` using
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this will give you a different result from the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The IPNS path, which is `'ipns/ QmVPUMd7mFG54zKDNNzPRgENsr5VTbBxWJThfVd6j9V4U8'`,
    is still the same, but we got a different result.
  prefs: []
  type: TYPE_NORMAL
- en: This is very interesting, but are we limited to a single IPNS path? No. You
    could generate another key so that you can have another IPNS path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python script named `generate_another_key.py` using the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding script will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Your new IPNS path from `'another_key'` is `'/ipns/ QmcU8u2Koy4fdrSjnSEjrMRYZVPLKP5YXQhLVePfUmjmkv'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when you want to publish content on the IPNS path, just use the `key`
    argument in `name_publish()`. Create a script named `publish_horoscope1_in_another_ipns.py` using
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Run it. You should get the first horoscope prediction. As you may have observed,
    we use another peer ID. Notice the index 1 in `peer_id = c.key_list()['Keys'][1]['Id']`.
    Previously, we used the index 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Publishing in the IPNS would not store it forever. By default, it stores the
    IPFS file for 24 hours. You could change the duration by using the `lifetime`
    keyword in `name_publish()`. For example, if you want to publish the IPFS file
    in the IPNS for `5h`, you could do this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Pinning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if you want to delete the file on the IPFS? Let''s say you accidentally
    add a nude picture of yourself using the `ipfs add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: How do you remove your nude picture? There is no such thing as `ipfs rm QmPCqvJHUs517pdcFNZ7EJMKcjEtbUBUDYxZcwsSijRtBx`
    because this command does not make any sense. What is it supposed to do? Tell
    every node that holds your nude picture to delete the picture? That would defeat
    the noble purpose of IPFS. What you can do is remove the picture on your IPFS
    local storage. The term for removing the local file in IPFS is called *removing
    the pin*. After removing the pin of your nude picture file, the content is still
    in IPFS local storage. But when the garbage collector of the IPFS works to clean
    up objects, it would remove the content of your nude picture file. Hopefully,
    no one has had the opportunity to pin (download) this sensitive file on their
    nodes!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to remove the pin and ask the garbage collector to do
    its job. Name the script `removing_nude_picture.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script. Then, if you try to get the content of your nude picture, it
    will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if someone has already pinned your nude picture in another node,
    then you would still get the content of your nude picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nude picture in this example is basically a nude picture of a panda, which
    can be downloaded from the Unsplash website from: [https://unsplash.com/photos/IgdVdJCmzf4](https://unsplash.com/photos/IgdVdJCmzf4).
    If you use this picture in this example, be prepared that there are other people
    who will use it as well. To test whether deleting a pin really works, you could
    use a truly unique file that no one in this world has. There is a way to check
    whether the file has been deleted on your local storage by dissecting the `LevelDB`
    file in the IPFS store path. However, that is beyond the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Pubsub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IPFS has an experimental feature, which is **Publish-Subscribe**, or **pubsub**.
    Basically, a node in the IPFS can subscribe to a topic. Let's say this topic is
    a Bitcoin topic. A node in the IPFS can publish a *To the moon!* message to a
    bitcoin topic. Then, any node that subscribes to the 'bitcoin' topic could get
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because pubsub is an experimental feature, you need to run IPFS daemon with
    a particular flag. Run IPFS daemon with the `--enable-pubsub-experiment` flag
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Both the subscriber and the publisher need to run the daemon with this particular
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to subscribe to a certain topic and name the script
    `subscribe_topic.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The method to subscribe to a topic is `pubsub_sub`. The first argument is a
    topic we want to subscribe to. When we receive data from our subscription, we
    will also get the information about the sender. However, for now, we only care
    about the message. This message is in `base64` encoding, so we have to decode
    it first.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script. This will wait until any message is received before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to publish to this topic and name the script `publish_topic.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: It would be better if you run this script in another computer so you can marvel
    at the wonder of the decentralized technology. Don't forget that you must run
    the IPFS daemon with a particular flag. But if you are lazy, you could run this
    script in the same computer.
  prefs: []
  type: TYPE_NORMAL
- en: While the subscribing script is running, run the publishing script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the Terminal where you run the subscribing script, you should get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: So, what is pubsub good for? To start with, you could build a notification system.
    Imagine you run a home file-sharing system for your family. When you add a picture
    of your daughter, you want to give notice to all of your family members. Not just
    a notification; you could build a decentralized chatting system (something such
    as IRC or Slack). When combined with other technologies, such as a content-free
    replicated data type, you could even build a decentralized online pair programming
    system on top of the IPFS!
  prefs: []
  type: TYPE_NORMAL
- en: Beware that pubsub are still experimental features. The developers of the IPFS
    have many interesting plans in the pipeline. Among the most interesting is the
    plan to add an authentication system to the top of the pubsub system based on
    a cryptography key. Now, everyone can publish and subscribe to a topic.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable File System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The IPFS has a feature called Mutable File System (MFS). The MFS is different
    from your OS file system. Let''s create a script to explore this feature and name
    the script `exploring_mfs.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'You may wonder what the point of this feature is. There is nothing that you
    can do in your MFS that you cannot do in your OS file system. In terms of this
    particular example, yes, you are right that this feature is pointless. But there
    is one subtle difference between MFS and your OS file system when copying files.
    Let''s create a script to prove this assertion and name the script `copy_in_mfs.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the script will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The file with the hash link `QmY8zTocoVNDJWUr33nhksBiZ3hxugFPhb6qSzpE761bVN`
    is a cute bear video that can be downloaded from: [https://videos.pexels.com/videos/bear-in-a-forest-855113](https://videos.pexels.com/videos/bear-in-a-forest-855113).
    You can download this with the following command: `ipfs get QmY8zTocoVNDJWUr33nhksBiZ3hxugFPhb6qSzpE761bVN`
    (assuming my IPFS node is online, you could download the video from that URL and
    pin the video yourself in another computer to test the script if no other IPFS
    nodes pinning this video are online). The file size is 46 MB, but the script was
    executed very quickly. The runtime of the script is too fast considering we have
    to download the video file. That happened because we do not download the video
    to our storage. The path of `/46MB_cute_bear.mp4` in our MFS is not a genuinely
    traditional file, as in our OS file system. You can say it''s like a symbolic
    link to a real file in the IPFS, pinned by some nodes in the IPFS ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: That means you could copy 100 TB files from IPFS paths to your MFS and it would
    not take any storage (except for some metadata).
  prefs: []
  type: TYPE_NORMAL
- en: If you think like a computer scientist, the IPFS file system is like a giant
    graph database.
  prefs: []
  type: TYPE_NORMAL
- en: Other APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other methods of the IPFS HTTP API that we don't have room to discuss
    here. The complete reference can be found in [https://docs.ipfs.io/reference/api/http/](https://docs.ipfs.io/reference/api/http/).
    There are APIs to bootstrap your nodes (which is useful if you want to construct
    your nodes list based on certain existing nodes), to find nearby nodes from a
    node, to connect to a particular node, to configure the IPFS, to shutdown IPFS
    daemon, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about interacting with the IPFS through the
    HTTP API using Python. First of all, you installed IPFS software and ran the daemon.
    You started this by adding a file to the IPFS and studied how to get the hash
    of the content of the file, which is based on protobuf, multihash, and base58\.
    Then, you saw that a big file would be divided into many chunks if added to the
    IPFS. You could also add a directory of files into the IPFS. Based on this ability,
    you could host a static website on the IPFS. Then, you learned about publishing
    IPFS files in the IPNS on which you could have dynamic content. After this, you
    learned about the MFS, where you could copy a large file from the IPFS without
    incurring any significant costs in your local storage.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will combine the IPFS and smart contracts to build
    a decentralized application.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the references to the various sites associated with this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ipfs/py-ipfs-api](https://github.com/ipfs/py-ipfs-api)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ipfs.io/](https://docs.ipfs.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
