- en: Chapter 7. Graphical User Interface Improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mixing heavyweight and lightweight components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing window types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the opacity of a window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a varying gradient translucent window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the shape of a window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new border types in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple file selection in the FileDialog class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the print dialog box type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new JLayer decorator for a password field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to develop applications that have a **Graphical User Interface**
    (**GUI**) interface has been enhanced in Java 7\. Some of these are minor improvements
    and are discussed in this introduction. Others, such as using the `javax.swing.JLayer`
    decorator class are more involved and are discussed in separate recipes.
  prefs: []
  type: TYPE_NORMAL
- en: It is now possible to mix heavyweight and lightweight components in an application
    without adding special code to make it work as desired. This improvement is largely
    transparent to users of Java 7\. However, the essence of this approach, and special
    situations that might arise from their use, are detailed in the *Mixing heavyweight
    and lightweight components* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: To ease the development of applications, three basic window types have been
    introduced. These should simplify the creation of certain types of applications
    and are discussed in the *Managing window types* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The overall appearance of an application may include such characteristics as
    its opacity and shape. The *Managing the opacity of a window* recipe illustrates
    how to control a window's opacity and the *Creating a varying gradient translucent
    window* recipe looks into creating gradients for such windows. Controlling the
    shape of a window, such as making it round or some irregular shape, is detailed
    in the *Managing the shape of a window* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The translucency-related capabilities were added originally as part of the **Java
    6 Update 10** release. However, they were implemented as part of the private `com.sun.awt.AWTUtilities`
    class. This capability has been moved to the `java.awt` package.
  prefs: []
  type: TYPE_NORMAL
- en: '`Javax.swing.JComponents` have borders whose appearance can be controlled.
    In Java 7, several new borders have been added. These are illustrated in the *Using
    the new border types in Java 7* recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Improvements have also been made in the use of the file dialog and print dialog
    boxes. These enhancements are discussed in the *Handling multiple file selection
    in the FileDialog class* and *Controlling the print dialog box type* recipes,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to draw over a `JComponent` has been added. This allows the use
    of special effects, which were not easily achieved in earlier versions of Java.
    The *Using the new JLayer decorator for a password field* recipe illustrates this
    process and also demonstrates how to create a watermark for windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the recipes of this chapter use a `JFrame-based` application. The following
    is the code used to develop a minimal window-based application, upon which the
    recipe''s examples are based. An `ApplicationDriver` class is used to start and
    display the `JFrame-derived ApplicationWindow` class. The `ApplicationDriver`
    class is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `invokeLater` method uses an inner class to create and then display the
    `ApplicationWindow`. This window is set up in its constructor. It is a simple
    window that has an **Exit** button, which we will use to close the application
    and enhance in later recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is executed, the output should appear as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/5627_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a number of minor improvements introduced in Java 7\. For example,
    the protected static `java.awt.Cursor` array has been deprecated. Instead, use
    the `getPredefinedCursor` method. This method takes an integer argument and returns
    a `Cursor` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new **HSV** tab was introduced to the `java.swing.JColorChooser` dialog box.
    It appears as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/5627_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also in Java 7, it is possible to customize a dragged JApplet''s title and
    to specify whether it should be decorated or not. This is accomplished from a
    `script` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `java_decorated_frame` parameter is set to `true` to specify that the window
    should be decorated. The title of the window is specified using the `java_applet_title`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This example is adapted from [http://download.oracle.com/javase/tutorial/deployment/applet/draggableApplet.html](http://download.oracle.com/javase/tutorial/deployment/applet/draggableApplet.html).
    More details on how to create draggable applets can be found at that site.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of miscellaneous changes need to be noted. The **Nimbus Look and Feel**
    has been moved from the `com.sun.java.swing` package to the `javax.swing` package.
    The `isValidateRoot` method has been added to the `Applet` class to indicate that
    the container is a valid root. Lastly, a new **Java2D** graphics pipeline based
    upon the **X11 XRender** extension has been added to provide better access to
    **Graphical Processing Units** (**GPU**).
  prefs: []
  type: TYPE_NORMAL
- en: Mixing heavyweight and lightweight components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java provides two basic sets of components for developing GUI applications:
    **Abstract Window Toolkit** (**AWT**) and **Swing**. AWT is dependent upon the
    native systems'' underlying code, and these components are therefore referred
    to as heavyweight components. Swing components, on the other hand, operate fully
    independent of the native system, are completely implemented in Java code, and
    are thus referred to as lightweight components. In previous versions of Java,
    it was inefficient and troublesome to mix heavyweight and lightweight components.
    In `Java 6 Update 12`, and continuing into Java 7, the JVM handles the mixing
    of heavyweight and lightweight components.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are working with code that implements both heavyweight and lightweight
    components, there is no need to make any changes to the code, as Java 7 automatically
    handles the components. We are going to modify code from the beginning of this
    chapter to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application using the code examples from the introduction section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the code to use both heavyweight and lightweight examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application using an older version of Java and then again using Java
    7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new window application as specified in the introduction to this chapter.
    Add the following section of code to the `ApplicationWindow` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the declaration of the **Exit** button so that you are now using
    a heavyweight `Button` rather than a lightweight `JButton` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. You need to run the application using a version of
    Java prior to **Java 6 Build 10** or the overlapping issue will not display. When
    the window opens, click on the menu and notice that, although the menu item overlaps
    the **Exit** button, the button shows through and covers the menu text. The following
    is an example of the overlap:![How to do it...](img/5627_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the application again using Java 7\. When you click on the menu this
    time, you should notice the overlapping issue has been resolved, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JVM handles the mixing of components automatically. In this example, we
    created a scenario to illustrate the overlapping problem, and then showed how
    it was resolved in the latest Java releases. However, it is a good practice to
    call the `validate` method on the top-level frame to ensure that all shapes are
    redrawn properly. There is also the potential that previous work-arounds for mixing
    components may need to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some specific areas to consider, when using mixed components
    with Java 7:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced swing events may not work correctly, particularly those events maintained
    by a `javax.swing.InputMap`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partially transparent lightweight components that are intended to allow heavyweight
    components to be seen through them are not supported. The heavyweight items will
    not be displayed beneath translucent pixels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heavyweight components must be created as part of the frame's or applet's process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the mixing of heavyweight and lightweight components has already been handled
    in your application and the Java 7 additions have caused problems, you can use
    the private `sun.awt.disableMixing` system property to turn off mixing support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing window types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `JFrame` class supports a `setType` method, which configures the general
    appearance of a window to one of the three types. This can simplify the setting
    of a window's appearance. In this recipe we will examine these types and their
    appearance on Windows and Linux platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set the window type, use the `setType` method with one of the three window
    types, as found in the `java.awt.Window` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Type.NORMAL:` This represents a normal window and is the default value for
    windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type.POPUP:` This is a temporary window intended to be used for small areas,
    such as tool tips'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type.UTILITY:` This is also a small window for objects, such as a palette'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new window application as specified in the introduction to this chapter.
    Add the following statement before the **Exit** button is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. On a Windows system, the window should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of the method is simple enough. The `Type` enumeration is found in
    the `java. awt` package. On Windows, the windows appear as shown in the following
    screenshots. The normal and popup styles have the same appearance. The utility
    type is missing the minimize and maximize buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows an example of the window type `Type.NORMAL:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5627_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following screenshot shows an example of the window type `Type.POPUP:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5627_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following screenshot shows an example of the window type `Type.UTILITY:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5627_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On Ubuntu, the windows appear as shown in the following screenshots. The normal
    and utility have the same appearance, while the popup type is missing its buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows an example of the window type `Type.NORMAL:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5627_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following screenshot shows an example of the window type `Type.POPUP:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5627_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following screenshot shows an example of the window type `Type.UTILITY:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5627_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Managing the opacity of a window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The opacity of a window refers to how transparent the window is. When a window
    is completely opaque, then nothing behind the window on the screen can be seen.
    A partially opaque window allows the background to bleed through. In this recipe
    we will learn how to control the opacity of a window.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To control the opacity of a window, use the `JFrame` class' `setOpacity` method
    with a float value representing how opaque the window should be.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Replace the `invokeLater` method invocation with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The window should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the window behind this application can be seen. In this case, the
    background is the code for the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setOpacity` used `0.75f` to set the opacity of the window. This results
    in it being 75 percent transparent, as can be seen by the code bleed through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The range of values for opacity is 0.0f through 1.0f. A value of 1.0f represents
    a completely opaque window, and a value of 0.0f represents a completely transparent
    window. If the opacity is set to 0.0f, the mouse may or may not be enabled. This
    is determined by the underlying system. To set a value less than 1.0f:'
  prefs: []
  type: TYPE_NORMAL
- en: Translucency must be supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The window must be undecorated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The window cannot be in full screen mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To determine whether translucency is supported or not is covered in the next
    section. The `getOpacity` method can be used to determine what the current level
    of opacity is.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To determine if the platform supports opacity, we need to use an instance of
    the `java.awt.GraphicsDevice` class. The `java.awt.GraphicsEnvironment` class
    contains a list of `GraphicsDevice` objects for the current platform. A `GraphicsDevice`
    normally refers to the screens available, but can include printers or image buffers.
    Each `GraphicsDevice` may also contain a set of `GraphicsConfiguration` objects
    that specify the configurations possible for a device, such as its resolution
    and what color model it supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code sequence, we get an instance of the `GraphicsEnvironment`
    object and then use its `getDefaultScreenDevice` method to get a `GraphicsDevice`
    object. The `isWindowTranslucencySupported` method is used against the `GraphicsDevice`
    object to determine if transparency is supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GraphicsDevice.WindowTranslucency` enumeration represents the types of
    transparency that may be supported by the platform. Its values are summarized
    in the following table. The alpha value refers to the level of transparency:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PERPIXEL_TRANSLUCENT` | Represents the system support for some of the pixels
    to be set with potentially different alpha values |'
  prefs: []
  type: TYPE_TB
- en: '| `PERPIXEL_TRANSPARENT` | Represents the system support for all of the pixels
    to be set to either 0.0f or 1.0f |'
  prefs: []
  type: TYPE_TB
- en: '| `TRANSLUCENT` | Represents the system support for all of the pixels to be
    set with an alpha value |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the new JLayer Decorator for a password field* recipe addresses how
    to draw over the top of a `JComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a varying gradient translucent window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are instances when an application window can be aesthetically enhanced
    by the addition of special graphics features. Java 7 supports the use of gradient
    translucent windows, and the translucency can be both visually interesting as
    well as functional.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will demonstrate using both the transparency feature as well as
    a color gradient on a window.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create a translucent, gradient color window, you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a check to ensure that the system environment supports per-pixel translucency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the background color, such that the window initially is completely transparent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `java.awt.GradientPaint` object to specify the color and position of
    the gradient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Add the following code to the `ApplicationDriver` class, before the start of the
    thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, replace the body of the `ApplicationWindow` constructor with the following
    code sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your window should resemble the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we added code to the `ApplicationDriver` class to test whether per-pixel
    translucency was supported by the system. In our example, if it were not supported,
    the application would exit. This is discussed in more detail in the *There's more..*.
    section of the *Managing the opacity of a window* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Gradients should not be used on decorated windows. We called the `setDefaultLookAndFeelDecorated`
    method to ensure that the default look and feel is used. When executed on Windows
    7, this results in an undecorated window.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ApplicationDriver` class, we first set the background color of the window.
    We used `(0, 0, 0, 0)` to specify the saturation levels of each color, red, green,
    and blue, and the alpha value, as zero. Color values can be any integer between
    0 and 255, but we want to start our window without any color. The alpha value
    of zero means our window will be completely transparent.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created a new `JPanel`. Within the `JPanel`, we overrode the `paintComponent`
    method and created a new `GradientPaint` object. There are four constructors for
    the `GradientPaint` class. We chose to use the one requiring floating numbers
    for the X and Y coordinates of the points referenced in the gradient, and the
    `Color` objects to specify the color of the gradient. You also have the option
    of passing `Point2D` objects rather than floating point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The first points specified, either by floating point number or `Point2D` objects,
    represent the start of the gradient. The second two, in our example, determined
    by the `getWidth` and `getHeight` methods, determine the ending points of the
    gradient. The result in our example was a gradient that started out light in the
    upper-left-hand corner, and became progressively darker as it moved down and to
    the right.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we cast the gradient as a `Graphics2D` object and called the `setPaint`
    and `fillRect` method to paint our gradient across the window.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the `GraphicsDevice` object to determine the level of transparency
    support is discussed in more detail in the *There's more..*. section of the *Managing
    the opacity of a window* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the shape of a window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times in application development when it can be fun and useful to
    create specially-shaped windows. This feature is now available in Java as of version
    7\. In this recipe we will develop a stop sign shape window to ensure that the
    user wants to continue some operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a specially-shaped window, you must:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that per-pixel translucency is supported on the given system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a component listener to catch `componentResized` events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of a shape and pass it to the `setShape` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    In the `main` method, prior to starting the thread, test to ensure that shaped
    windows are supported on the system by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class called `StopPanel` that is derived from `JPanel` and add
    the following constructor to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to implement a `paintComponent` method for the `StopPanel` class.
    It is responsible for displaying text to our window. The following is one way
    to implement this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `ApplicationWindow` class, create a new instance of a `StopPanel`
    before the **Exit** button is created. Next, create a new instance of a `Shape`.
    In our example, we created a `Polygon` object by using the `getPolygon` method
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a `componentListener` in front of the code to create the **Exit**
    button to catch the `componentResized` event. Within the listener, invoke the
    `setShape` method against the `Shape` object. We will also set the foreground
    and background colors at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Add a call to the `setUndecorated` method and set the property to `true:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `getPolygon` method to the class. This method creates an octagon
    using the two arrays of integers in conjunction with the `addPoint` method of
    the `Polygon` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application is executed, you should see an octagonal window formatted
    like the following one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our initial test to verify per-pixel translucency allowed us to tailor the application
    to the needs of the system it is running on. In our example, if the property was
    not supported we simply exited the application, though in a real-world environment
    you would probably want to open a less sophisticated window. Detecting the operating
    system support is discussed in more detail in the *There's more..*. section of
    the *Managing the opacity of a window* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `StopPanel` class implemented the `JPanel` interface and allowed us to add
    the custom text and buttons we used in our window. Because we were using a special
    shape for our window, we chose to call the `setLayout` method with a `null` argument,
    which in turn allowed us to use the `setBounds` methods to explicitly place our
    buttons where we wanted them on the window. It is important to note that although
    the window is displayed as an octagon, or whatever other shape you choose, in
    actuality the window is still a rectangle, as specified by the `setSize` method.
    Therefore, buttons and other objects may be placed on the window, but not visible
    if they are outside the bounds set by your shape.
  prefs: []
  type: TYPE_NORMAL
- en: The `paintComponent` method was used to customize the text on the window. Within
    this method, we set the size, style, and location of the text, and called the
    `drawString` method to actually paint it to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To actually create an octagonal window, we created our `getPolygon` method and
    manually drew the polygon. However, if you wanted to use a window with a shape
    already defined by a class implementing the `Shape` interface, you would not need
    to create a separate method. You simply pass the `Shape` object to the `setShape`
    method. If the `setShape` method's argument is `null`, the window will resize
    to the default for the given system, typically a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to execute the `setShape` method within a `componentResized`
    event. This ensures that anytime the window is redrawn, the `setShape` method
    will be called and the shape will be maintained. It is also important to call
    the `setUndecorated` method because, at the present time, decorations will be
    lost with specially-shaped windows. Also, the window may not be in full-screen
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the `GraphicsDevice` object to determine the level of transparency
    support is discussed in more detail in the *There's more..*. section of the *Managing
    the opacity of a window* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new border types in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Borders are used for the outline of swing components. In Java 7, several new
    border options are available. In this recipe we will develop a simple application
    to demonstrate how to create borders and how these borders appear.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create and use a border:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new border using a `javax.swing.BorderFactory` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the border object as an argument of the `setBorder` method applied against
    a `JComponent` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Modify the `ApplicationWindow` class to replace the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. The window should appear as follows:![How to do it...](img/5627_07_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setBorder` method changed the border of the `JPanel` to a raised soft-beveled
    border. The `BorderFactory` method possesses a number of static methods to create
    borders. The following table summarizes the new borders available in Java 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Visual effect |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| The default border | ![How it works...](img/5627_07_16.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| `createRaisedSoftBevelBorder()` | ![How it works...](img/5627_07_17.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `createLineBorder(Color.BLACK, 1, true)`The first argument is the color of
    the border. The second is its thickness, while the third argument specifies whether
    the corners should be rounded or not. | ![How it works...](img/5627_07_18.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `createLoweredSoftBevelBorder()` | ![How it works...](img/5627_07_19.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `createSoftBevelBorder(BevelBorder.LOWERED)`This has the same effect as `createLoweredSoftBevelBorder()`
    | ![How it works...](img/5627_07_20.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| `createSoftBevelBorder(BevelBorder.RAISED)`This has the same effect as `createRaisedSoftBevelBorder()`
    | ![How it works...](img/5627_07_21.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| `createSoftBevelBorder(BevelBorder.LOWERED, Color.lightGray, Color.yellow)`The
    first argument is the type of border: `RAISED` or `LOWERED.` The second argument
    is the color of the outer highlighted areaThe third argument is the color of the
    inner edge | ![How it works...](img/5627_07_22.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| `createSoftBevelBorder(BevelBorder.RAISED,Color.lightGray, Color.yellow)`The
    same arguments as `createSoftBevelBorder` | ![How it works...](img/5627_07_23.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `createSoftBevelBorder(BevelBorder.LOWERED, Color.lightGray, Color.lightGray,
    Color.white, Color.orange)`The arguments are used for the inner and outer edges
    of the highlighted and shadowed areas of the border | ![How it works...](img/5627_07_24.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `createStrokeBorder(new BasicStroke(1.0f))`A second overloaded method takes
    a `Paint` object as a second argument, and is used to generate a color | ![How
    it works...](img/5627_07_25.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| `createDashedBorder(Color.red)` | ![How it works...](img/5627_07_26.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `createDashedBorder(Color.red, 4.0f, 1.0f)`The second argument is the relative
    length of a dash line and the third parameter is the relative length of a space.
    | ![How it works...](img/5627_07_27.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| `createDashedBorder(Color.red, 2.0f, 10.0f, 1.0f, true)`The second parameter
    specifies the thickness of the line. The third and fourth parameters specify the
    length and spacing respectively, while the last Boolean parameter determines whether
    the ends are rounded or not. | ![How it works...](img/5627_07_28.jpg) |'
  prefs: []
  type: TYPE_TB
- en: The border can be changed for any `JComponent` class. However, the appearance
    is not always acceptable. As we did in this example, it is sometimes better to
    change the border on an enclosing `JPanel` object.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple file selection in the FileDialog class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to select two or more files or directories in a file dialog box
    is achieved using the *Ctrl* and/or *Shift* keys in conjunction with the mouse.
    In Java 7, the file dialog box enables or disables this capability using the `java.awt.FileDialog`
    class' `setMultipleMode` method. This simple enhancement is illustrated in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable or disable the selection of multiple files in a print dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `FileDialog` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use its `setMultipleMode` method to determine its behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the return value to determine which files were selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Modify the `ApplicationWindow` class to add a button to display a file dialog
    box as shown in the following code. In an anonymous inner class, we will display
    the dialog box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. The application window should appear as follows:![How
    to do it...](img/5627_07_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **File Dialog** button and the following dialog box should appear.
    Navigate to a directory and select a few files. In the window that follows, two
    files of the `/home/music` directory have been selected:![How to do it...](img/5627_07_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fileDialog` class' `setMultipleMode` method was executed with an argument
    of `true`. This enabled multiple selections of files. An anonymous inner class
    was created to handle the selection of the file button event. In the `actionPerformed`
    method, the dialog box was made visible.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To determine which files were selected, we can use the `fileDialog` class''
    `getFiles` method. Add the following code after the `fileDialog` class'' `setVisible`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The method returns an array of `File` objects. Using a for each loop, we can
    display the name of each file selected. Execute the application and select a few
    files. The output for the selected music files should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Space Machine A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the print dialog box type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard print dialog that comes as part of the `java.awt.PrintJob` class
    allows the use of both a common and a native dialog box. This provides the ability
    to better tailor the application to a platform. The specification of the dialog
    box type is simple.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To specify the print dialog type and to use the print dialog, the following
    steps need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `javax.print.attribute.PrintRequestAttributeSet` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the dialog type desired to this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `PrinterJob` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `PrintRequestAttributeSet` object as an argument to the `PrinterJob`
    class' `printDialog` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Modify the `ApplicationWindow` class to add a button to display a print dialog
    shown as follows. In an anonymous inner class, we will display a printer dialog
    box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application and select the **Print** button. The dialog box that
    appears should use the common appearance type, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_07_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A new **Print** button was created allowing the user to display a print dialog
    box. In the anonymous inner class used to handle the button''s action event, we
    created a `PrintRequestAttributeSet` object based on the `javax.print.attribute.HashPrintRequestAttributeSet`
    class. This permitted us to add the `DialogTypeSelection.NATIVE` attribute to
    the set. The `DialogTypeSelection` class is new to Java 7 and provides two fields:
    `COMMON` and `NATIVE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we created a `PrinterJob` object and executed the `printDialog` method
    against this object. The print dialog box was then displayed. If we had used the
    `NATIVE` type instead, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the print dialog would appear as follows on a Windows platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5627_07_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the new JLayer decorator for a password field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 7 supports the decoration of GUI components, such as textboxes and panels.
    Decoration is the process of drawing on top of the component to give it a special
    appearance. For example, we may want to watermark an interface to show that it
    is a beta version, or possibly to provide an indication of an error with a graphical
    X in a text field that is not otherwise possible.
  prefs: []
  type: TYPE_NORMAL
- en: The `javax.swing.JLayer` class provided a way of tying components of a display,
    the drawing of extra graphics over the components, and the interception of the
    events together. The handling of the events and the display is delegated to a
    `javax.swing.plaf.LayerUI` derived object. When an event occurs, a method to handle
    the event will be executed. When the component is drawn, the `LayerUI` derived
    object's `paint` method will be executed displaying graphics as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will learn how Java supports this capability. In the first
    section, we will demonstrate how to display an error message for a password field.
    In the *There's more..*. section, we will show how to create a watermark for a
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To decorate a component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the components to be decorated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `LayerUI` derived class that implements the decoration graphics operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `JLayer` object based on the component and the `LayerUI` derived class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `JLayer` object to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Use the following `ApplicationWindow`. In its constructor, we will perform the
    essential steps using a `getPanel` method to return our password `JPanel` object.
    When the user enters a password, the window will be decorated with a message indicating
    that the password is too short, until at least six characters are entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `PasswordLayerUI` class as shown in the following code. The
    `paint` method will perform the actual decoration. The remaining methods are used
    to enable keyboard events and handle them as they occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. Enter a few characters in the textbox. Your window
    should appear similar to the following:![How to do it...](img/5627_07_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter at least six characters. At that point the decoration should disappear
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_07_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `ApplicationWindow`, we created an instance of the `PasswordLayerUI`
    class. We used this object along with the `JPanel` returned by the `getPanel`
    method to create `JLayer` object. The `JLayer` object was then added to the window.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of generics for the `LayerUI` and `JLayer` objects. This was
    used to ensure that the elements are all compatible. We used `JPanel` because
    that was the composite component we were decorating.
  prefs: []
  type: TYPE_NORMAL
- en: The `JLayer` class provided a way of tying the password box, the display of
    the error message, and the interception of the key events together. The handling
    of the key events and the display of the error message was delegated to the `PasswordLayerUI`
    object. When a key was pressed, the `processKeyEvent` method was executed. When
    the component was drawn, the `paint` method was executed displaying the error
    message by the password box.
  prefs: []
  type: TYPE_NORMAL
- en: In the `PasswordLayerUI` class, we declared a private `String` variable to hold
    our error message. It was declared at this level, because it was used in more
    than one method.
  prefs: []
  type: TYPE_NORMAL
- en: The `paint` method does the actual decorating. It was passed a `Graphics` object
    representing the area that we can draw to, and a `JComponent` component, which
    in this case was a `JPanel`. In the `paint` method, we used both the component's
    font and we also created a new `font` for the error message. The `height` and
    `width` of the component and the error string were calculated and used to position
    the error string that was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `installUI` and `uninstallUI` methods were concerned with performing any
    initialization required to perform decoration. In this case, they were used to
    enable keyboard events to be intercepted and processed by the class. The `setLayerEventMask`
    method was used with the `AWTEvent.KEY_EVENT_MASK` argument to enable the processing
    of keyboard events. The `processKeyEvent` method performed the actual processing
    of keyboard events. In this method, the length of the password text field contents
    was used to determine which error message was to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example could conceivably be performed using a label instead. However,
    this example was intended to provide a simple demonstration of how to use decorations.
    The creation of other decorations, such as a watermark is not as easily performed
    without the use of `JLayer` and `LayerUI` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code before the `dispose` method. This sequence will add
    a watermark to the window indicating that this is a beta version of the interface.
    The `Castellar` font is used to provide a more stenciled look to the text. A `Composite`
    object is used to change the alpha value for the string. This effectively controls
    the transparency of the string displayed. The `getComposite` method is used to
    get the current composite for the window, and is then used to determine the rule
    being used. The rule along with an alpha value of `0.25f` is used to allow the
    watermark to fade into the background as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When executed, your application should appear similar to the following screenshot.
    Notice that the watermark is in all caps. This is the result of using the `Castellar`
    font, which is an all-capital letter font patterned after the letters used on
    a Roman column dedicated to Augustus.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5627_07_35.jpg)'
  prefs: []
  type: TYPE_IMG
