- en: RSS Reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create an app which will be able to fetch, process,
    and show the user several RSS feeds. RSS is a web feed, which allows users to
    access updates to online content in a standardized and computer-readable format.
    They are normally used in news websites, news aggregators, forums, and blogs to
    represent updated content and it fits very well to the mobile world, as we can
    have all the content from different blogs or newspapers just by entering the feed's
    URL in one app.
  prefs: []
  type: TYPE_NORMAL
- en: An RSS feed reader will serve as an example on how to fetch external data, store
    it, and display it to the user, but at the same time, will add a bit of complexity
    to our state tree; we will need to store and manage lists of feeds, entries, and
    posts. On top of that, we will introduce MobX as a library to manage all those
    state models and update our views, based on the user's actions. Therefore, we
    will introduce the concept of actions and stores, which is widely used in some
    of the most popular state management libraries, such as Redux or MobX.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the previous chapter, and because the UI patterns we will need
    for this app are very similar on both platforms, we will aim at sharing 100% of
    the code for iOS and Android.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand our RSS reader, let's take a look at how the app will look
    like once we finish it.
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9b2159fe-4103-49bb-8d26-884e73c431a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dc295cc7-7640-46fc-a27a-68b8e27fb961.png)'
  prefs: []
  type: TYPE_IMG
- en: The home screen will display a list of the feeds already added by the user.
    It will also show a button (+) in the navigation header to add a new feed to the
    list. When that button is pressed, the app will navigate to the Add feed screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ab44b43d-3ec3-4384-9ffe-7635078d3540.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9ab48440-ae80-4472-a992-572019522f21.png)'
  prefs: []
  type: TYPE_IMG
- en: Once a new feed has been added, it will show on the home screen and the user
    will be able to open it by simply tapping on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2cff312d-358f-40a2-ac98-e25c7a4443de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2241542d-5f29-487d-9eb7-670f212020da.png)'
  prefs: []
  type: TYPE_IMG
- en: At this stage, the app will retrieve the list of the updated entries for the
    selected feed and display it on a list. In the navigation header, a Trash icon
    will allow the user to remove the feed from the app. If the user is interested
    in any entries, she can click on it to display the full content for that entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/80a7cfb4-2ce0-4e5f-a2b0-98354da60e05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6e7a138d-9aed-48ec-9bf9-c1cc862b49d7.png)'
  prefs: []
  type: TYPE_IMG
- en: This last screen is basically a WebView, a lightweight browser opened by default
    in the URL, which is containing the content for the selected entry. The user will
    be able to navigate to subsections and fully interact with the open website in
    this screen having also the possibility to go back to the feed details by tapping
    on the Back arrow in the navigation header.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: State management with MobX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch external data from a URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic linking modules with native resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ActivityIndicator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did in the first chapter, we need to initialize a new React Native project
    through React Native''s CLI. This time, we will name our project `RSSReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For this app, we will need a total of four screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FeedList`: This is a list containing the titles for the feeds which were added
    to the app sorted by the time they were added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddFeed`: This is a simple form to allow the user to add a feed by sending
    its URL. We will here retrieve the feed details to finally add and save them in
    our app for later usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FeedDetail`: This is a list containing the latest entries (retrieved before
    mounting the screen) belonging to the selected feed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EntryDetail`: This is a WebView showing the contents of the selected entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the screens, we will include an `actions.js` file containing all the
    user actions modifying the app's state. Although we will review how the state
    is managed in a later section, in detail, it's also important to note that besides
    this `actions.js` file, we need a `store.js` file to contain the state structure
    and methods to modify it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, and as it is normal in most of the React Native projects, we will need
    an `index.js`  file (already created by React Native's CLI) and a `main.js` file
    to serve as an entry point for our app's components tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these files will be organized inside `src/` and `src/screens/` folders,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/644ee843-3dc1-458f-9c92-d422f1c7f8e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, we will use several npm modules to save development time
    and put the focus on the functional aspects of the RSS reader itself, rather than
    dealing with custom state management frameworks, custom UI, or data processing.
    For these matters, we will use the following `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen in this file, we will be using the following npm modules together with
    the standard React Native''s modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mobx`: This is the state management library we will be using'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobx-react`: This is the official React bindings for MobX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`native-base`: As we did in the previous chapter, we will use NativeBase''s
    UI library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-native-vector-icons`: NativeBase requires this module to display graphic
    icons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-navigation`: We will use the React Native''s community navigation library again'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simple-xml2json`: A lightweight library to convert XML (the standard format
    for RSS feeds) into JSON to easily manage the RSS data within our code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having this `package.json` file, we can run the following command (in the root
    folder of our project) to finish the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once npm finishes installing all dependencies, we can start our app in the
    iOS simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in the Android emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using vector icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this app, we will use two icons: a plus sign to add feeds and a trash bin
    to remove them. React Native doesn''t include a list of icons to be used by default,
    so we will need to add one. In our case, since we are using `native-base` as our
    UI library, it''s very convenient to use `react-native-vector-icons`, as it is
    supported natively from `native-base`, but it requires one extra configuration
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Some libraries use extra native capabilities which are not present in React
    Native. In the case of `react-native-vector-icons`, we need to include a number of
    vector icons stored in the library accessible natively. For these kinds of tasks,
    React Native includes `react-native link`, a script to automatically link the
    provided library to prepare all the native code and resources, which are needed
    for this library to be accessible within our app. Lots of libraries will require
    this extra step, but thanks to React Native's CLI, it is a very simple step, which
    in the past required moving files around projects and messing with configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Managing our state with MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MobX is a library which makes state management simple and scalable by transparently
    applying functional reactive programming. The philosophy behind MobX is very simple:
    *anything that can be derived from the application state, should be derived automatically. *This
    philosophy applies to UI, data serialisation and server communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Lots of documentation and examples of using MobX can be found on its website [https://mobx.js.org/,](https://mobx.js.org/) although
    we will make a small introduction in this section to fully understand our app's
    code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MobX uses the concept of "observable" properties. We should declare an object
    containing our general application''s state, which will hold and declare those
    observable properties. When we modify one of these properties, all the subscribed
    observers will be updated by MobX automatically. This is the basic principle behind
    MobX, so let''s take a look at a sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have an attribute, `feeds`, marked as `@observable`, meaning that any component
    can subscribe to it and be notified every time the value is changed. This attribute
    is initialized as an empty array in the class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also created the `addFeed` method, which will push a new feed into
    the `feeds` attribute and therefore will trigger automatic updates on all the
    observers. To better understand MobX observers, let''s take a look at a sample
    component observing the feeds list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we notice is the need to mark our component with the `@observer`
    decorator to ensure it is updated when any of the `@observable ` properties change
    in our store.
  prefs: []
  type: TYPE_NORMAL
- en: By default, React Native's Babel configuration doesn't support the `@<decorator>`
    syntax. In order for it to work, we will need to modify our `.babelrc` file (found
    in the root of our project) and add `transform-decorator-legacy` as a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is the need for the store to be received in the component
    as a property. In this case, since we are using `react-navigation`, we will pass
    it inside `screenProps`, which is the standard way in `react-navigation` for sharing
    properties between `<Navigator>` and its child screens.
  prefs: []
  type: TYPE_NORMAL
- en: MobX has many more features, but we will leave those for more complex apps as
    one of the goals for this chapter is to show how simple state management can be when
    we are building small apps.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After understanding how MobX works, we are ready to create our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen the basic structure of this file in the MobX section of
    this chapter. Now, we will add some methods to modify the list of feeds and to
    select a specific feed/entry when the user taps on them in our app's listings
    for feeds/entries.
  prefs: []
  type: TYPE_NORMAL
- en: We are also making use of `AsyncStorage` to persist the list of feeds every
    time it is modified by either `addFeed` or `removeFeed`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There will be two types of actions in our app: those affecting a specific component''s
    state and those affecting the general app state. We want to store the latter somewhere
    out of the component''s code, so we can reuse and easily maintain them. An extended
    practice in MobX (and also Redux or Flux) apps is to create a file named `actions.js`,
    where we will store all the actions modifying business logic for our app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of our RSS reader, the business logic revolves around feeds and
    entries, so we will capture all the logic dealing with these models in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since actions modify the general app state, they will need to access the store.
    Let''s take a look at each action separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchFeed`: When a user wants to add a feed to the RSS reader, he will need
    to pass the URL, so the app can download the details for that feed (feed title,
    list of latest entries, and when it was updated for the last time). This action
    is responsible for retrieving this data (formatted as an XML document) from the
    supplied URL and transforming that data into a JSON object with a standard format
    for the app. Fetching the data from the supplied URL will be performed by `fetch`,
    a built-in library in React Native, which is used to make HTTP requests to any
    URL. Since `fetch` supports promises, we will use async/await to handle the asynchronous
    behavior and simplify our code. Once the XML document containing the feed''s data
    is retrieved, we will convert that data into a JSON object using `simple-xml2json`,
    a very lightweight library for this kind of needs. Finally, the action returns
    a JSON object containing only the data we will really need in our app (title,
    entries, and last update time).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectFeed`: Once the user has added one or more feeds to the reader, she
    should be able to select one of them to get the list of the latest entries for
    that feed. This action just saves the details for a specific feed in the store,
    so it can be used by any screen interested in displaying data related to that
    feed (that is, the `FeedDetail` screen).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectEntry`: Similar to `selectFeed`, a user should be able to select one
    of the entries in a feed to get the details for that specific entry. In this case,
    the screen displaying that data will be `EntryDetail` as we will see in a later
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addFeed`: This action requires two parameters: the URL for a feed and the
    feed''s detail. These parameters will be used to store the feed in the list of
    saved feeds so that it will be available globally in our app. In the case of this
    app, we decided to use the URL as the key which stores the details for the feed,
    as it is a unique property of any RSS feed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeFeed`: A user can also decide that they don''t want a specific feed
    in the RSS reader anymore and therefore we need an action to remove the feed from
    the list of feeds. This action only requires the URL for the feed to be passed
    as a parameter, since we stored the feed using the URL as an ID to uniquely identify
    the feed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking in React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most mobile apps need to fetch and update data from an external URL. There are
    several npm modules, which can be used in React Native to communicate and download
    remote resources such as Axios or SuperAgent. If you are familiar with a specific
    HTTP library, you can use it in your React Native projects (as long as is not
    dependent on any browser specific APIs), although a safe and proficient option
    is to use `Fetch`, the built-in networking library in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: '`Fetch` is very similar to `XMLHttpRequest`, so it will feel familiar to any
    web developers who had to perform AJAX requests from the browser. On top of that,
    `Fetch` supports promises and the ES2017 async/await syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: The full documentation for the `Fetch` API can be found on Mozilla Developer
    Networks website [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
  prefs: []
  type: TYPE_NORMAL
- en: By default, iOS will block any request that's not encrypted using SSL. If you
    need to fetch from a cleartext URL (one that begins with `http` instead of `https`),
    you will first need to add an **App Transport Security** (**ATS**) exception.
    If you know ahead of time what domains you will need access to, it is more secure
    to add exceptions just for those domains; if the domains are not known until runtime,
    you can disable ATS completely. Note, however, that from January 2017, Apple's
    App Store review will require reasonable justification for disabling ATS. See
    Apple's documentation for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our app's entry point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All React Native apps have one entry file: `index.js`,  we will delegate the
    root of the component''s tree to our `src/main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will also register our app with the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `src/main.js` file to understand how we will
    set up navigation and start up our component''s tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `react-navigation` as our navigator library and `StackNavigator`
    as our navigation pattern. Add each of our screens to the `StackNavigator` function
    to generate our `<Navigator>`. All this is very similar to the navigation pattern we
    used in [Chapter 1](51ac8f19-54e1-4917-b9f6-3b7df132cf3f.xhtml), *Shopping List*,
    but we incorporated an improvement to it: we are passing `store` in the `screenProps`
    property for our `<Navigator>`, instead of directly passing the attributes and
    methods to modify our app''s state. This simplifies and cleans up the code base
    and as we will see in later sections, it will free us from notifying the navigation
    every time our state changes. All these improvements come for free thanks to MobX.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the FeedsList screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The list of feeds will be used as the home screen for this app, so let''s focus
    on building the list of the feeds'' titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This component expects to receive the list of feeds from `this.props.screenProps.store` and
    then iterates over that list building a NativeBase `<List>`, showing the titles
    for each of the feeds on the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce some MobX magic now. As we want our component to be re-rendered
    when the list of feeds changes (when a feed is added or removed), we have to mark
    our component with the `@observer` decorator. MobX will automatically force the
    component re-rendering on any update. Let''s see now how to add the decorator
    to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now, our component will be notified when the store is changed and
    a re-render will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Adding event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add an event handler to be triggered when the user taps on one of the
    feed''s titles so the list of entries for that feed is displayed on a new screen
    (`FeedDetail`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For this, we added a method to our component named `_handleFeedPress`, which
    will receive the feed detail as a parameter. When this method is called, it will
    run the action `selectFeed` and will trigger a navigation event passing the feed's
    URL as a property, so the next screen (`FeedDetail`) can include a button to delete
    the feed based on that URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add `navigationOptions`, including the title for the navigation
    header and the button to add a feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pressing the `AddFeed` button will navigate to the `AddFeed` screen. This button
    will be displayed to the right of the navigation header by passing it as a property
    named `headerRight` in the `navigationOptions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this component looks all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our list of feeds fully functional, let's allow the users to
    add some feeds through the `AddFeed` screen.
  prefs: []
  type: TYPE_NORMAL
- en: Building the AddFeed screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This screen consists of a basic form, including one `<Input>` for the URL from
    the feed and a `<Button>` to retrieve the feed information from the provided URL
    to later store the feed's details in our store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to import two actions ( `addFeed` and `fetchFeed` ), which will
    be called once the `Add` button is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the functionality in this component is in `_handleAddPress` as it is
    the handler, which will be triggered once the `Add` button is pushed. This handler
    is responsible for four tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking there is a URL present to retrieve data from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the feed data from the provided URL (through the `fetchFeed` action)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving that data into the app's state (through the `addFeed` action)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alerting the user if something went wrong when fetching or saving the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One important thing to note is how the  `fetchFeed` action is used. Since it
    was declared with the `async` syntax, we can use it as a promise and attach it
    to the result of its listeners for `then` and `catch`.
  prefs: []
  type: TYPE_NORMAL
- en: ActivityIndicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a good practice to display a spinner every time the app needs to wait
    for a response to an HTTP request. Both iOS and Android have standard activity
    indicators to display this behavior and both are available through the `<ActivityIndicator>`
    component in React Native's module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to display this indicator is by keeping a `loading` flag in
    the component state. Since this flag is only used by our component to display
    this `<ActivityIndicator>`, it makes sense to have it inside the component''s
    state instead of moving it to the general app''s state. Then, it can be used inside
    the `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is very common in React apps for displaying or hiding components
    based on flags or simple conditions. It takes advantage of the way JavaScript
    evaluates the `&&` operations: check truthiness of the first operand, if truthy,
    returns the second operator; otherwise, it returns the first operator. This syntax
    saves lines of code on a very common kind of instructions and therefore it will
    be widely used throughout this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the FeedDetail screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recap what happened when the user tapped on one feed on the `FeedsList`
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `navigate` method was called on the `navigation` property to open the `FeedDetail`
    screen. As a parameter, the `_handleFeedPress` function passed `feedUrl`, so it
    can retrieve the feed data and display it to the user. This is a necessary step
    since the data we have in our store for the selected feed can be obsolete. So,
    it's better to re-fetch that data before showing it to the user so we are sure
    it's 100% updated. We could also do a more complex check instead of retrieving
    the whole feed every time the user selects a feed, but we will stay with the given approach
    in order to keep simplicity in this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by retrieving the updated list of entries in the `componentWillMount`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will mark our component as `@observer` so that it get''s updated every time
    the selected feed changes. Then, we need a state with two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loading`: This is a flag to signal to the user that we are fetching the updated
    feed''s data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry`: This is the list of entries to be displayed to the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, before the component is mounted, we want to start the retrieval of the
    updated entries. For this matter, we can reuse the `fetchFeed` action we used
    in the `AddFeed` screen. When the feed data is received, the `loading` flag in
    the component''s state is set to `false`, which will hide `<ActivityIndicator>`
    and the entries list for the feed will be set in the component''s state. Now that
    we have a list of entries, let''s take a look at how we will display it to the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `&&` syntax is used again to display `<ActivityIndicator>` until the data
    is retrieved. Once the data is available and properly stored in, the `entry` property
    inside our component's state, we will render the list items containing the entries
    titles for the selected field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add an event handler which will be triggered when a user taps
    on one of the entries'' titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This handler is named `_handleEntryPress` and is responsible for two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Marking the tapped entry as selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to `EntryDetail`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To finalize the component, let''s add the navigation header through the `navigationOptions`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Besides adding the title for this screen (the feed's title), we want to add
    an icon to the navigation for the user to be able to remove the feed from the
    stored list of feeds in the app. We will use the `trash` icon of `native-base`
    for this purpose. When it's pressed, the `removeFeed` action will be called passing
    the URL for the current feed URL, so it can be deleted from the store, then it
    will force the navigation to go back to the `FeedList` screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the finished component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move on to the last screen: `EntryDetail`.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the EntryDetail screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EntryDetail` screen is just WebView: a component-abled rendering web content
    in a native view. You can think of a WebView as a lightweight web browser displaying
    the contents of a website for a provided URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method in this component is merely returning a new `WebView` component
    loading the URL from the selected entry inside the store. As we did with the feed''s
    data in the previous sections, we need to retrieve the `selectedEntry` data from `this.props.screenProps.store`.
    The URL can be stored in two different ways depending on the RSS version of the
    feed: in the link property or one level deeper in `link.href`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A state management library becomes necessary in every app when its complexity
    starts to grow. As a rule of thumb, it's a good idea to add a state management
    library when the app is comprised of more than four screens and they share information
    between them. For this app, we used MobX, which is simple but powerful enough
    to handle all the feeds and entries' data. In this chapter, you learned the basics
    of MobX and how to use it in conjunction of `react-navigation`. It's important
    to understand the concept of actions and stores, as we will use them in future
    apps not only built around MobX but also on Redux.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to fetch data from a remote URL. This is a very common
    action in most of the mobile apps, although we only covered the basic usage of
    it. In the following chapters, we will dive deeper into the `Fetch` API. Moreover,
    we saw how to process and format the fetched data to formalize it within our app.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed what a WebView is and how we can insert web content into
    our native app. This can be done using local HTML strings or remotely through
    the URL, so it's a very powerful trick used by mobile developers to reuse or access
    web-only content.
  prefs: []
  type: TYPE_NORMAL
