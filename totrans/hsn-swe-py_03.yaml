- en: System Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of any **system modeling** process is to define and document a conceptual
    model of some aspect of a system, usually focusing individually on one (or many)
    specific faces of that system. System models may be defined in a formal architecture
    description language, such as **Unified Modeling Language** (**UML**), and can,
    in those cases, get very detailed – down to the minimum required property and
    method members of classes. Details at that level are generally fluid – or at least
    not finalized – until the requirements analysis processes in Agile methodologies,
    and will be discussed in more detail in [Chapter 4](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=28&action=edit),
    *Methodologies, Paradigms, and Practices*.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a higher, less granular level, there are still several system-model views
    that are of particular interest going into the development process, particularly
    with respect to the bigger picture:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture, both logical and physical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business processes and rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structure and flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interprocess communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System scope/scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture, both logical and physical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of both logical and physical architecture specifications is to define
    and document the logical and physical components of a system, respectively, in
    order to provide clarity around how those component elements relate to one another.
    The artifacts resulting from either effort could be text documentation, or diagrams,
    and both have their own advantages and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Text documentation is usually quicker to produce, but unless there is some sort
    of architectural documentation standard that can be applied, the formats can (and
    probably will) vary from one system team to another, at a minimum. That sort of
    variance can make it difficult for the resulting artifacts to be understandable
    outside the team that it originated with. If there is not a lot of movement of
    developers between teams, or a significant influx of new developers to teams,
    that may not be a significant concern. It can also be difficult to ensure that
    all of the moving parts or the connections between them are fully accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: The primary advantage to diagrams is the relative ease with which they can be
    understood. If the diagram has obvious indicators, or symbols that unambiguously
    indicate, for example, that one component is a database service and another is
    an application, then the difference between them becomes obvious at a glance.
    Diagrams also have the advantage of being more easily understandable to non-technical
    audiences.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, text-based or diagram-based documents are, obviously, most useful
    if they are well-constructed, and provide an accurate view or model of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Logical architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Development is often going to be more concerned with the logical architecture
    of a system than with the physical. Provided that whatever mechanisms needed are
    in place for the actual code in a system to be deployed to, live on, connect to,
    and use the various physical components that relate to the logical components,
    and that any physical architecture constraints are accounted for, little more
    information is generally needed, so where any given component lives just isn''t
    as important from that perspective. That often means that a physical architecture
    breakdown is at best a nice-to-have item, or maybe a should-have at most. That
    also assumes that the structure in question isn''t something that''s so commonplace
    that a need for it to be documented surfaced. There are, for example, any number
    of systems in the wild that follow the same common three-tier structure, with
    a request-response cycle that progresses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A user makes a request through the **Presentation Tier**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That request is handed off to the **Application Tier**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application retrieves any data needed from the **Data Tier**, perhaps doing
    some manipulation or aggregation of it in the process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Application Tier** generates a response and hands it back to the **Presentation
    Tier**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Presentation Tier** returns that response to the user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Diagrammed, that structure might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6bf5d867-714f-423b-86e6-86f3427d264d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This three-tier architecture is particularly common in web applications, where:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Presentation Tier** is the web-server (with the web browser being no more
    than a remote output-rendering component)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Application Tier** is code called by, and generating responses to, the
    web server, written in whatever language and/or framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Data Tier** is any of several back-end data-store variants that persist
    application data between requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider, as an example, the following logical architecture for the refueling-tracking
    system concept mentioned earlier. It serves as a good example of this three-tier
    architecture as it applies to a web application, with some specifically identified
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/03eb615f-6e25-4ae3-acbd-cb81fc883c2d.png)'
  prefs: []
  type: TYPE_IMG
- en: Physical architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary difference between logical and physical architecture documentation
    is that, while logical architecture''s concerns end with identifying functional
    elements of the system, physical architecture takes an additional step, specifying
    actual devices that those functional elements execute on. Individual items identified
    in logical architecture may reside on common devices, physically. Really, the
    only limitations are the performance and capabilities of the physical device.
    This means that these different physical architectures are all logically identical;
    they are all valid ways of implementing the same three-tier web application''s
    logical architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8803dcbf-ff7d-4045-b717-1a54e1e56cc5.png)'
  prefs: []
  type: TYPE_IMG
- en: With the current enthusiasm for virtualization, serverless, and cloud-based
    technologies in the industry, provided by public and private cloud technologies
    such as Amazon Web Services and VMware, whether a physical architecture specification
    really is a physical architecture often becomes something of a semantics quibble.
    While, in some cases, there may not be a single, identifiable physical computer
    the way there would be if there was a dedicated piece of server hardware, in many
    cases that distinction is irrelevant. If it acts like a distinct physical server,
    it can be treated as one for the purposes of defining a physical architecture.
    In that case, from a documentation standpoint, there is no knowledge value lost
    in treating a virtual server like a real one.
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering many serverless elements in a system, several can still be
    represented as a physical architecture element as well – so long as it acts like
    a real device from the perspective of how it interacts with the other elements,
    the representation is adequate. That is, given a hypothetical web application
    that lives completely in some public cloud, where:'
  prefs: []
  type: TYPE_NORMAL
- en: That cloud allows serverless functions to be defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functions will be defined for processing the following, with back-end databases
    for each of those entities also living in the cloud:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A corresponding physical architecture might look something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/051270e3-a92f-4765-a662-1d6319a1bce1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example real-world implementation of this serverless architecture can be
    implemented in all three of the big-name public clouds: **Amazon Web Services**
    (**AWS**), Azure, and **Google Cloud Platform** (**GCP**). Each of these public
    cloud platforms provides virtual server-instances that could serve the website
    and maybe databases. The processor servers in this structure could use serverless
    functions (AWS Lambda, or Cloud Functions in Azure and GCP) to drive the interactions
    between the website and the databases as the website sends events to the functions
    in the processor elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Collectively, logical and physical architecture specifications provide development
    with at least some of the information needed to be able to interact with non-application
    tiers. Even if specific credentials will be required but are not supplied in the
    documentation, knowing, for example, what kind of database drives the data tier
    of a system defines how that data tier will be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases (business processes and rules)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any system, the most important thing is whether it's doing what it's supposed
    to do for all of the use cases that it's supposed to support. Code has to be written
    for each of those use cases, and each use case corresponds to one or more business
    processes or rules, so it's only logical that each of those use cases needs to
    be defined and documented to whatever extent is appropriate for the development
    process. As with the logical and physical architecture, it's possible to execute
    those definitions as either text or some sort of diagram, and those approaches
    have the same advantages and drawbacks that were noted before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unified Modeling Language (UML) provides a high-level diagramming standard
    for use cases, useful mostly for capturing the relationship between specific types
    of users (actors, in UML''s terminology) and the processes that they are expected
    to interact with. That''s a good start, and may even be sufficient all by itself
    if the process itself is very simple, already extensively documented, or known
    across the development team. The use case diagram for the Refuel-Tracker application
    concept that was discussed earlier in *Use Cases* section is, so far, very simple,
    and harks back to the system goals that were established for it in the [Chapter
    2](dd61b582-20a9-4a97-b73e-6c66ee2c0a3b.xhtml), *The Software Development Life
    Cycle*. This time, though, we''ll attach some names to them for reference in the
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Refuel**: Various users can log refueling''s, providing the current odometer
    reading and the quantity of fuel involved:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivery drivers (at local fuel-stations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fleet maintenance staff (at the main office, where there is a company fuel station)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance Alert**: Fleet maintenance staff will be alerted when a truck''s
    calculated fuel efficiency drops to lower than 90% of its average, so that the
    truck can be scheduled for an examination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route Review Alert**: Office staff will also be alerted when a truck''s calculated
    fuel efficiency drops to lower than 90% of its average, so that the truck''s delivery
    rounds can be examined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those three use cases are simple to diagram, if that''s the preferred documentation.
    The following list of processes is also a viable option. In some ways it''s actually
    better than a standard diagram, since it provides some business rules of the system
    that a standard use case diagram doesn''t capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a95d85eb-a0fc-428b-9282-864d3936a381.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Even if the diagram were modified to include some of the missing information
    (what a refueling is, and what the rules around the two `«trigger»` items are),
    it still only tells part of the story: who is expected (or allowed) to use specific
    process functionality. The balances, the actual processes underneath the use cases,
    are still unknown, but need to be exposed so that code can be written around them
    to actually make them work. This also can be handled either as plain text of some
    sort, or through a diagram. Looking at the Refuel process that''s been identified,
    it breaks down to something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Driver** or **Fleet Tech** logs a refuel of a truck, providing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current odometer reading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of fuel used to fill the truck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those values are stored (probably in an application database, though that may
    not be part of the actual requirements) with an association to the truck (how
    that gets specified has yet to be determined).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The application calculates the fuel efficiency for the refueling: (current
    odometer reading minus previous odometer reading) ÷ quantity of fuel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the efficiency is less than or equal to 90% of the most recent efficiency
    value for that truck, the **Route Review **alert is triggered .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the efficiency is less than or equal to 90% of at least half of the previous
    four efficiency values for that truck, the **Maintenance** alert is triggered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether a diagram (such as the following flowchart) would add any value to
    the documentation will likely depend on the process being described, and on team
    or even personal preferences. These five steps, as a simple flowchart, are simple
    enough that going any further than a text description of them is probably not
    going to add any value, but more complex processes might benefit from a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3dff51f3-a3b3-42a3-afa6-2ade0b581c8e.png)'
  prefs: []
  type: TYPE_IMG
- en: From a developer's perspective, use cases map out to one-to-many functions or
    methods that will have to be implemented, and if there are process flows documented,
    those explain how they will execute at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Data structure and flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Between the two of them, basic use-case and business-process documentation may
    provide enough information to make the structure and flow of the data through
    the system obvious, or at least transparent enough that development won't need
    any additional information. The Refuel process we've been looking at probably
    falls into that category, but let's see what a data-flow diagram for it might
    look like anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data that''s coming in (the **Refuel Data** in the flowchart) was defined
    earlier in *Use Cases* section, and at least some of the related data flow was
    also noted, but having some names to associate with those values, and knowing
    what types of value they are, will be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`odometer`**: The current odometer reading (probably an `<int>` value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`fuel_quantity`**: The amount of fuel used to fill the truck (probably a
    `<float>` value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`truck_id`**: The truck being refueled (a unique identifier for the record
    of the truck in the application''s database – to keep things simple, we''ll assume
    it''s also **`<int>`**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'During the process, a refuel-efficiency value is also being created that might
    need to be passed along to the **Route Review** alert and/or **Maintenance** alert
    processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`re`: The calculated refuel-efficiency value, a `<float>` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this very simple case, data elements are simply being noted, by name and
    type. The diagram indicates where they start being available, or when they are
    explicitly passed to a process – otherwise they are assumed to be available all
    the way through. Then the data elements are just added to the previous flowchart
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2446f7f8-69e0-4ace-8d31-93ab616c908b.png)'
  prefs: []
  type: TYPE_IMG
- en: In a more complicated system, something that has more complex data structures,
    more data structures in general, more processes that use those, or any of several
    combinations of those factors, a source and destination oriented flow-diagram
    may be a better option – something that doesn't really pay attention to the inner
    workings of the processes, just to what data is needed, and where it comes from.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59b99061-b4a3-4385-ba94-dc97c25245ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Data-flow documentation/diagrams tell developers what data is expected, where
    it's originating from, and where/whether it's going to live after the processes
    are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Interprocess communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's very common for different processes to communicate with each other. At
    the most basic level, that communication might take the form of something as simple
    as one function or method calling another from somewhere in the code they share.
    As processes scale outward, though, especially if they are distributed across
    separate physical or virtual devices, those communication chains will often get
    more complex themselves, sometimes even requiring dedicated communications protocols.
    Similar communication-process complexities can also surface, even in relatively
    uncomplicated systems, if there are interprocess dependencies that need to be
    accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In pretty much any scenario where the communication mechanism between two processes
    is more complicated than something at the level of methods calling other methods,
    or perhaps a method or process writing data that another process will pick up
    and run with the next time it''s executed, it''s worth documenting how those communications
    will work. If the basic unit of communication between processes is thought of
    as a message, then, at a minimum, documenting the following will generally provide
    a solid starting point for writing the code that implements those interprocess
    communication mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What the message contains**: The specific data expected:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is required in the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What additional/optional data might be present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How the message is formatted**: If the message is serialized in some fashion,
    converted to JSON, YAML, or XML, for example, that needs to be noted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How the message is transmitted and received**: It could be queued up on a
    database, transmitted directly over some network protocol, or use a dedicated
    message-queue system such as RabbitMQ, AWS SQS, or Google Cloud Platform''s Publish/Subscribe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What kinds of constraint apply to the message protocol**: For example, most
    message-queuing systems will guarantee the delivery of any given queued message
    once, but not more than once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How messages are managed on the receiving end**: In some distributed message-queue
    systems – certain variants of AWS SQS, for example – the message has to be actively
    deleted from the queue, lest it be received more than once, and potentially acted
    upon more than once. Others, such as RabbitMQ, automatically delete messages as
    they are retrieved. In most other cases, the message only lives as long as it
    takes to reach its destination and be received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interprocess-communication diagramming can usually build on the logical architecture
    and use-case diagrams. One provides the logical components that are the endpoints
    of the communication process, the other identifies what processes need to communicate
    with each other. Documented data flow may also contribute to the bigger picture,
    and would be worth looking at from the perspective of identifying any communication
    paths that might've been missed elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The refuel tracker, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Can access the database for the existing route-scheduling application, which
    provides a dashboard for the route schedulers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maintenance alert functionality can leverage a web service call belonging
    to an off-the-shelf fleet-maintenance system that was purchased, which has its
    own dashboard used by the fleet technicians.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relevant messaging involved for the route-review and maintenance-alert
    processes is very simple under these circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: An update in the route-scheduling database, perhaps flagging the last route
    that the truck was scheduled for as an inefficient route, or maybe some sort of
    notification that'll pop up on the dashboard to alert a route scheduler to review
    the route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JSON-over-REST API call made to the maintenance-tracking system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That messaging would fit on a simple variant of the use case diagram already
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0b9c039c-8ce0-4428-a96c-730bb0a21e5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The order-processing, fulfillment, and shipping system might use RabbitMQ messaging
    to deal with order-fulfillment, passing entire orders and simple inventory checks
    from the products datasource to determine whether an order can be fulfilled. It
    might also use any of several web service API calls to manage order shipment,
    pushing the shipping information back into the order over a similar web service
    call. That message flow (omitting the data structure for brevity) might then look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45f88b14-86a1-4d42-a450-de97abc15157.png)'
  prefs: []
  type: TYPE_IMG
- en: The main takeaway from a development focus on Interprocess Communication is
    how the data identified earlier gets from one point in the system to another.
  prefs: []
  type: TYPE_NORMAL
- en: System scope and scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If all of these items are documented and/or diagrammed, if it''s done thoroughly
    and accurately, they will, collectively, provide a holistic view of the total
    scope of a system:'
  prefs: []
  type: TYPE_NORMAL
- en: Every system component role should be identified in the Logical Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where each of those components actually resides should be identified in the
    Physical Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every use case (and hopefully every business process) that the system is supposed
    to implement should be identified in the use-case documentation, and any of the
    underlying processes that aren't painfully obvious should have at least a rough
    happy-path breakdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every chunk of data that moves from one place or process to another should be
    identified in the Data Flow, with enough detail to collate a fairly complete picture
    of the structure of that data as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The formats and protocols that govern how that data move about, at least for
    any part of the system that involves more than just passing system objects from
    one function or method in the code-base to another, should be identified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fair idea of where and how those data are persisted should be discernible
    from the Logical, and maybe Physical, architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only significant missing piece that hasn't been noted is the scale of the
    system. If the scope is how many types of object are being worked with or are
    moving around in the system, the scale would be how many of those objects exist,
    either at rest (stored in a database, for example) or actively at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scale can be hard to anticipate with any accuracy, depending on the context
    of the system. Systems such as the hypothetical refueling tracker and order-processing/fulfillment/shipping
    system that have been used for illustration are generally going to be more predictable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The number of users is going to be reasonably predictable**: All employees
    and all customers pretty much covers the maximum user base for both of those'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of objects being used is also going to be reasonably predictable**:
    The delivery company only has so many trucks, after all, and the company running
    the order system, though probably less predictable, will still have a fair idea
    of how many orders are in flight at most, and at typical levels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a system or application enters a user space such as the web, though, there
    is potential for radical variation, even over very short periods of time. In either
    case, some sort of planning around expected and maximum/worst-case scale should
    be undertaken. That planning may have significant design and implementation effects –
    fetching and working with a dozen records at a time out of a few hundred or thousand
    total records doesn't require nearly the attention to efficiency that those same
    twelve records out of several million or billion would, just as a basic example – on
    how code might be written. If planning for even potential massive surges in use
    involves being able to scale out to multiple servers, or load-balance requests,
    that might also have an effect on the code, though probably at a higher, interprocess-communication
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the components, data, and documentation from this chapter, as well as
    the previous two chapters, are potentially available in any software engineering
    effort. How much is actually is available probably depends in part on how much
    discipline is involved in the predevelopment processes, even if there isn't anything
    formal associated with it. That discipline might be present because of a singularly
    talented project manager.
  prefs: []
  type: TYPE_NORMAL
- en: Another contributor to when, how much, and what quality of data is available
    is often the development methodology in play through the life of a project, system,
    or team. Several of the more common methodologies manage these predevelopment
    efforts in significantly different manners, and their treatment can make a substantial
    difference.
  prefs: []
  type: TYPE_NORMAL
