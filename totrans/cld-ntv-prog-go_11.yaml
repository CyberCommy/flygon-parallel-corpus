- en: Migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to chapter 11 of our journey to learn the world of cloud native programming
    and the Go language. In this chapter, we'll cover some practical techniques to
    migrate applications from monolithic architectures to microservice architectures.
    We have already covered monolithic and microservice architectures in [Chapter
    2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml), *Building Microservices Using
    Rest APIs. *However, we will start this chapter by covering the practical definitions
    of monolithic and microservice architectures, in case you are reading this chapter
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A review on monolithic applications and microservices architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for migrating from monolithic applications to microservices applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced microservices design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data consistency in microservices architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a monolithic application?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **monolithic application** is simply a single piece of software that undertakes
    several independent tasks at once. Let's take an online store application as an
    example. In a monolithic architecture, we'd have a single piece of software that
    would handle the customers, their orders, the database connections, the website,
    the inventory, and any other tasks needed for the online store to be successful.
  prefs: []
  type: TYPE_NORMAL
- en: A single piece of software doing everything might seem like an inefficient approach
    for software design, which is the case in some scenarios. However, it is important
    to mention that monolithic applications are not always bad. There are some scenarios
    where a single software service doing all the work is an acceptable idea. This
    includes minimum viable products or MVPs where we try to build something fast
    to get it out for test users to try. It also includes use cases where not a lot
    of data load or traffic is expected, such as an online store for legacy board
    game hobbyists.
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **microservice architecture** takes a different approach to building software
    as compared to monolithic applications. In a microservice architecture, the tasks
    are distributed among multiple smaller software services, which are known as microservices.
    In a well-designed microservice architecture, each microservice should be self-contained,
    deployable, and scalable. Well-designed microservices also enjoy clean APIs that
    allow other microservices to communicate with them. The concept of independent
    software services working together to reach a common goal is not new; it existed
    in the past as **service-oriented architectures** (**SOA**). However, modern microservices
    architectures take the idea a bit further by insisting on the software services
    being relatively small,  independent, and fully self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the online store example. In the case of a microservice architecture,
    we would have a microservice for customer handling, a microservice for inventory
    handling, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical microservice contains multiple essential layers in the inside to
    handle logging, configuration, APIs to communicate with other microservices, and
    persistence. There is also the core code of the microservice, which covers the
    main task the service is supposed to do. The following is what a microservice
    should internally look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b75db61-3b04-471c-a000-60aa8f4b3a33.png)'
  prefs: []
  type: TYPE_IMG
- en: Internal look of microservice
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architectures have major advantages over monolithic applications
    when it comes to scalability and flexibility. Microservices allow you to scale
    indefinitely, utilize the power of more than one programming language, and gracefully
    tolerate failures.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from monolithic applications to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now, let's say that you have a monolithic application, your business is
    growing, your customers are demanding more features, and you need to migrate to
    an architecture that is both flexible and scalable. It's time to use microservices.
    The first key rule of thumb to have in mind when migrating is that there is no
    golden set of steps we need to follow to perform a successful migration from monolithic
    applications to microservices. The steps we need to follow differ from one situation
    to another and from one organization to another. Having said that, there are some
    very helpful concepts and ideas that we can cover in this chapter, which will
    help you make informed decisions on how to go about the migration.
  prefs: []
  type: TYPE_NORMAL
- en: Humans and technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most overlooked aspects when transitioning from monolithic applications
    to microservices is the **people factor**. We typically think of technology and
    architecture, but what about teams who write the code, manage the projects, and
    redesign the application? Moving from a monolithic application to a microservice
    is a paradigm shift that needs to be properly planned for in an organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to consider right after making the decision to move
    to microservices is the structures of teams involved with the development process.
    Typically, the following comprises the team that works on monolithic applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers who are used to working in very specific pieces of the application
    in a single programming language and nothing else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IT infrastructure teams who are used to deployments being nothing more than
    updating a few number of servers hosting the monolithic application and its databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team leads who own a piece of an application as opposed to an entire software
    service from A to Z
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned before, microservices migration represents a paradigm shift. This
    means that when transitioning to a microservice architecture, a new way of thinking
    needs to get engaged in the organization. Consider the following :'
  prefs: []
  type: TYPE_NORMAL
- en: Developers will need to be divided into smaller teams, where each team should
    be in charge of one or more microservices. Developers will need to be comfortable
    being in charge of an entire software service as opposed to a bunch of software
    modules or classes. Of course, if the organization is large enough, you can still
    have developers being responsible for specific modules within the microservice.
    However, it pays off if the developers are trained to think of their product as
    the entire microservice, as this will produce a better-designed microservice.
    Developers will also need to be comfortable with using the right programming language
    for the job. For example, Java is important for data processing and pipelining,
    Go is very good for building fast reliable microservices, C# is good for Windows
    services, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IT infrastructure teams will need to learn about horizontal scaling, redundancy,
    expandable cloud platforms, and the planning process involved with deploying a
    massive number of services distributed among numerous servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team leads will carry the responsibility of an entire software service from
    A to Z. They will need to consider implementation details such as how to scale
    the service, whether to share a database with other services or have its own database,
    and how the service would communicate with other service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cutting a monolithic application to pieces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we discussed the people aspect of the migration, let's take a dive
    into the technical details. One golden rule that virtually everyone agrees on
    is that writing everything from scratch and ignoring all the code in the existing
    monolithic application (also known as the big bang rewrite) is not a good idea.
    Instead, the best approach to migrate from a monolithic application to microservices
    is to cut the monolithic application piece by piece over time. Each detached piece
    becomes a microservice. For every new microservice, we will need to ensure that
    it can still communicate with the monlithic application, as well as other new
    microservices. If this approach goes well, the monolithic application will keep
    shrinking overtime till it becomes a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78cdb5a4-136f-4f38-991d-f5659b14fdc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Monolithic application shrinking overtime
  prefs: []
  type: TYPE_NORMAL
- en: This sounds simple; however, in real life, it is typically not that straightforward.
    Let's cover some planning strategies to make the piece-by-piece approach more
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: How do we break the code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One key technical question we will need to ask is how exactly should we break
    the monolithic application''s code? Here are some important points to keep in
    mind:'
  prefs: []
  type: TYPE_NORMAL
- en: If an application is well-written, there will be clean and obvious separations
    between the different classes or software modules.  This makes cutting up the
    code an easier task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, if there are no clean separations in the code, we'll need
    to do some refactoring to the existing code before we can start moving pieces
    of code to new microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is typically preferred not to add new code or features to the monolithic
    application without trying to separate the new feature into a new microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glue code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for the new microservice to fit into the original application without
    breaking its functionality, the microservice needs to be capable of exchanging
    information with the original application. To make this happen, we may need to
    write some glue code that will link the new with the old. The glue code typically
    includes some API interfaces that would act as the communication channel between
    the original application and the microservice. The glue code will also include
    any code necessary to make the new microservice work with the existing application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6662e58-ee72-4ea8-92ed-ae2c223656de.png)'
  prefs: []
  type: TYPE_IMG
- en: Glue code
  prefs: []
  type: TYPE_NORMAL
- en: The glue code might be temporary or permanent, depending on our application.
    Sometimes, the glue code might need to do some data modeling translation or communicate
    with an old database to make things work.
  prefs: []
  type: TYPE_NORMAL
- en: If your application is a web application, the glue code may include a temporary
    web HTTP API that can connect your newly separated microservice with your viewing
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss some important design patterns and architectural
    approaches that can help us build robust and effective cloud-ready microservices.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Sacrificial architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sacrificial architecture** is an important design approach that doesn''t
    typically get the attention it deserves. It was mentioned by Martin Folwer in
    2014 and can be found at [https://martinfowler.com/bliki/SacrificialArchitecture.html](https://martinfowler.com/bliki/SacrificialArchitecture.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The core idea of sacrificial architecture is that we should write our software
    in a way where it is easily replaceable in the future. To understand the previous
    statement better, let's consider an example scenario. Let's say that a couple
    of years ago, we had built a computer networking application that utilizes custom
    data serialization formats designed by our developers. Today, we need to rewrite
    the application in a more modern programming language that can handle a lot more
    data load and user requests. This task will not be fun or easy by any measure
    because our application relies on custom serialization and communications protocols
    that can only be understood by the original developers of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if we had used a more standardized serialization format such as protocol
    buffers? The task of rewriting or updating the application will be much easier
    and more efficient because protocol buffers are supported by a wide range of programming
    languages and frameworks. Building our application with a standard serialization
    format instead of a custom one is what sacrificial architecture is about.
  prefs: []
  type: TYPE_NORMAL
- en: When we design our software with sacrificial architecture in mind, the tasks
    of upgrading, refactoring, and/or evolving our application become much more straightforward.
    If our monolithic application gets designed with sacrificial architecture in mind,
    separating pieces of the application into microservices becomes easy.
  prefs: []
  type: TYPE_NORMAL
- en: If we write our glue code with sacrificial architecture in mind, evolving the
    glue code in the future or getting rid of it altogether and replacing it with
    something else becomes much easier. If we build our new microservices with sacrificial
    architecture in mind, we give ourselves the capability to grow and evolve our
    microservices quickly, painlessly, and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: A four-tier engagement platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **four-tier engagement platform** is an architectural approach that targets
    the application as a whole. It was described by Forrester research at ;[https://go.forrester.com/blogs/13-11-20-mobile_needs_a_four_tier_engagement_platform/](https://go.forrester.com/blogs/13-11-20-mobile_needs_a_four_tier_engagement_platform/).
    This architecture is very suited for modern applications targeting the mobile
    and web age. The architecture allows scalability, flexibility, and performance.
    It also makes integrating cloud services and internal microservices quite easy
    and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ac4697f-dd63-4e40-b05a-573ca35e2f76.png)'
  prefs: []
  type: TYPE_IMG
- en: Four-tier engagement architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The main idea behind this architecture is that the overall application should
    be divided into four main layers or tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The client layer**:This layer is responsible for the user experience; it
    tailors the user experience based on the user''s context environment. A context
    environment includes the user device type, the user''s location, the time of day,
    among other things. For example, if the user of your product is using a smart
    watch, then the client layer should render content suitable for a smart watch.
    If they are using a tablet, a user interface that is perfect for a tablet greets
    the user. If the user is viewing data from China, the client layer needs to show
    the information in Chinese. If the user is viewing the data from Canada, the information
    needs to be shown in English.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The delivery layer**: The delivery layer is responsible for delivering optimized
    data to the users as requested by the client layer. This is achieved by doing
    on-the-fly optimizations, such as image compression or bandwidth reduction. The
    layer can make use of monitoring tools to track user activity, then utilize algorithms
    to use this information to deliver better customer experience. This layer is also
    where we would using caching algorithms and techniques to ensure better performance
    for our customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The aggregation layer**: This layer is where data from different sources
    is aggregated to form stable and uniform data models, which can then be handed
    over to the preceding layers. Tasks undertaken by this layer include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acting as an API hub between layer, providing service discoverability, and data
    access to the preceding layers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating outputs from internal services such as in-house microservices and
    external services such as AWS cloud services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging data from different source types—for example, reading a base64-encoded
    message from one source and a JSON-encoded message from another source and then
    linking them together to form a unified data model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding data to formats suitable for delivery to the users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying role-based access to the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The services layer:** This layer is composed of our external and internal
    services. It provides the raw data and functionality to the layers. These layers
    are composed of a set of deployable internal and external services. The services
    layer is where we would communicate with databases such as MySQL or DynamoDB;
    it''s where we would use third-party services such as AWS S3 or Twilio. This layer
    should be designed to be pluggable, meaning that we could easily add or remove
    services to it as we please.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we design our modern applications with the preceding architectural pattern,
    we will gain endless flexibility and scalability. For example, we can target new
    user device types in the client layer without needing to change much code in other
    layers. We can add or remove microservices or cloud services in the services layer
    without needing to change much code in the layers above it. We can support new
    encoding formats in the aggregation layer such as Thrift or protocol buffers without
    needing to change much code on the other layers. The four-tier engagement platform
    is currently being utilized by companies such as Netflix and Uber.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded contexts in domain-driven designs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Domain-driven** **design **(**DDD**) is a popular design pattern that we
    can use to internally design microservices. Domain-driven design typically targets
    complex applications that are likely to grow exponentially over time. If your
    monolithic application was already designed via DDD, migrating to microservices
    architecture will be straightforward. Otherwise, if you are expecting the new
    microservices to grow in scope and complexity, then considering DDD may be a good
    idea.'
  prefs: []
  type: TYPE_NORMAL
- en: Domain-driven design is a massive topic. The wikipedia article can be found
    at [https://en.wikipedia.org/wiki/Domain-driven_design](https://en.wikipedia.org/wiki/Domain-driven_design).
    However, for the purpose of this section, we will cover some brief concepts that
    can help us obtain practical understanding of DDD. Then, from there, you'll learn
    why this design approach is good for complex microservices architectures.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of domain-driven design is that a complex application should be considered
    to be functioning within a *domain*. A domain is simply defined as a sphere of
    knowledge or activity. The domain of our software application can be described
    as everything related to the purpose of the software. So, for example, if our
    software application's main goal is to facilitate planning social events, then
    planning social events becomes our domain.
  prefs: []
  type: TYPE_NORMAL
- en: A domain contains *contexts*; each context would represent a logical piece of
    the domain, where people talk the same language. Language used within a context
    can only be understood based on the context from which it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: 'From my experience, it is difficult to understand what a context is without
    an example. So, let''s take a simple example. Assume that the organization that
    is behind the social events application is a large organization, with a sales
    department, a marketing department, and a support department. This means that
    the domain-driven design of this organization may need to include the following
    three main contexts: a sales context, a marketing context, and a support context.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the language used by the sales people will only be relevant to the sales
    people. For example, the concepts of sales funnel, sales opportunity, or sales
    pipeline are very important to sales, but may not be relevant to the support department.
    That is why, a sales context can include the concept of a sales funnel, but you
    won't find that language or  concept in the support context much.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9124a64c-1f1b-404b-829f-138e696490c4.png)'
  prefs: []
  type: TYPE_IMG
- en: The Domain
  prefs: []
  type: TYPE_NORMAL
- en: 'Domains also contain models. Each model is an abstraction that describes an
    independent concept in the domain. Models are what end up getting transformed
    into software modules or objects. Models typically live inside contexts. For example,
    in a sales context, we will need models to represent a sales contract, a sales
    funnel, a sales opportunity, the sales pipeline, and the customers among others,
    whereas in the support context, we need models to show tickets, customers, and
    defects. The following is a simple diagram showing some models inside the sales
    context and the support context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44d6aaf1-7ead-42a0-8734-56590e1576e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Sales and support contact
  prefs: []
  type: TYPE_NORMAL
- en: Different contexts can share the same language or concept, but focus on a different
    aspect of it. In our huge organization example, a word used by the sales people
    might not always mean the same word for the support people. For example, the word
    *customer* for sales represents a customer who is likely to buy a product from
    the organization, but hasn't done so just, yet. On the other hand, a customer
    for the support department is probably a customer who already bought the product,
    bought a support contract, and is suffering from some kind of issue with the product.
    So, both contexts share the concept of a customer; however, they care about different
    things when it comes to that concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the same language might mean different things in different contexts
    introduces one of the key ideas in the world of DDD, which is bounded contexts.
    Bounded contexts are contexts that share a concept, but then they implement their
    own models of that concept. For example, the concept of *customers* is represented
    by a model in the sales context, which reflects the version of customer that the
    sales department cares about. The concept of customers is also modeled in the
    support context according to their version of it. Although they are two models,
    they are still linked. That is because, at the end of the day, they both represent
    a customer for the social events planning company. The following is a simple diagram
    that shows what this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39d9dcb0-771c-417f-8376-5d520ae9d179.png)'
  prefs: []
  type: TYPE_IMG
- en: Bounded sales and support contact
  prefs: []
  type: TYPE_NORMAL
- en: Contexts and Bounded contexts is where the worlds of domain-driver design and
    microservices start to meet. It is a key design factor when it comes to complex
    modern microservices, because contexts can map easily to microservices. If you
    try to define bounded contexts, you will find yourself not only defining what
    a microservice should be in practice, but also what information should be shared
    between microservices to form the overall application. A simple definition for
    a bounded context is that it's a self-contained logical block that is part of
    a bigger application. This same definition can be applied with no additions to
    describe a well-designed microservice. Sometimes, a bounded context can be divided
    into more than one  service, but that typically depends on the level of complexity
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In our example here, we would then end up with a microservice that handles sales
    operations and a microservice that handles support operations.
  prefs: []
  type: TYPE_NORMAL
- en: If your monolithic application has been already designed with the DDD principles
    in mind, migrating to a microservices architecture gets easier. That is because
    transitioning from code that form the bounded contexts to self-containing microservices
    would make sense.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, your monolithic application is not designed this way,
    but the application is complex and growing, then DDD principles can be utilized
    to build future microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Data consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The database that powers an application is a vital block that must be handled
    with extreme care and respect when migrating to a microservice architecture. In
    the world of monolithic applications, you would likely deal with a small number
    of databases (one or maybe two) that connects to your monolithic application through
    a fat data handling layer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3866d74d-1919-4e48-bd36-f0ec9e61446c.png)'
  prefs: []
  type: TYPE_IMG
- en: Monolithic application with database
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of microservices and distributed cloud architectures, things
    can get wildly different. That is because the architecture will likely include
    a wider range of data models and database engines to serve the needs of the distributed
    microservices. Microservices can have their own databases, share databases with
    other applications, or make use of multiple databases at once. Data consistency
    and modeling in a modern microservices architecture are a nontrivial challenge
    that we need to tackle with good applications design before it gets out of control.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f79828-f779-40ec-8730-d7f9d3ed3c27.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following section, we'll discuss some strategies to keep in mind when
    breaking the data models from a monolithic application paradigm to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architecture for data consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key design patterns that we can utilize to protect data consistency in a microservices
    architecture is an event-driven design. The reason why data consistency is difficult
    to maintain with microservices is that each microservice is typically responsible
    for a piece of data from the overall application. The sum of the data stores handled
    by the application's microservices represent the total state of the application.
    So, that means when a microservice updates its database, other microservices that
    are affected by this data change need to know about it so that they can take appropriate
    actions and update their own states.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the sales and support microservices example from the bounded context
    section of this chapter. In the event that a new customer buys a product, the
    sales microservice will need to update its own database to reflect the new customer
    status as an actual paying customer instead of just a potential customer. This
    event will also need to be communicated to the support microservice so that it
    can update its own database to reflect the fact that there is a new paying customer
    who deserves customer or technical support whenever needed.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of event communication between microservices is what event-driven
    design is about in the world of microservices. A message queue or a message broker
    between the microservices can be utilized to communicate event messages between
    microservices. Message brokers were discussed in detail in [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*. Microservices
    that need to be notified whenever a certain event happens will have to subscribe
    to those events.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3f1de3a-32a3-41a1-a6a4-84b5641089af.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, the support service will need to subscribe to the event topic on
    the message queue that represents a customer buying the product. The sales microservice
    then triggers this event whenever a customer buys the product. Since the support
    service is subscribed to that event, it will receive the notification of the event
    shortly after, which will include the new customer's information. From there,
    the support service will be able to carry out its own logic to ensure that the
    support organization is ready for that customer whenever help is needed or even
    maybe trigger a welcome email for the new customer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this all sounds good, but what if the support microservice fails before
    it can receive the new customer event? This means that the support service will
    end up not knowing about the new customer, and hence it will not apply any logic
    to add the relevant information about the new customer into the support database.
    Does that mean when the customer calls later for help, the support team won't
    help because they don't see the customer in their system? Obviously, we don't
    want that to happen. One approach would be to have a central database that stores
    customer data, which would be shared between different microservices, but what
    if we seek a flexible design where each  microservice is fully responsible for
    it's entire state. This is where the concepts of event sourcing and CQRS come
    into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Events sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea behind event sourcing is that instead of fully relying on a local
    database to read the state, we need to make use of a recorded stream of events
    to form the state. To make that work, we will need to store all current and past
    events so that we can retrieve them at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: We need an example to solidify this theoretical definition. Let's say that the
    support service had failed and crashed before it could receive the new customer
    event. If the support service doesn't use event sourcing, then when it restarts,
    it will not find the customer information in its own database and will never know
    about the customer. However, if it uses event sourcing, then instead of only looking
    at its local database, it will look at an event store which is shared with all
    the other microservices. The event store will record any event that was ever triggered
    between our microservices. In that event store, the support service will be able
    to replay the new customer event that got triggered recently and will see that
    this customer doesn't currently exist in the local support microservice database.
    The support service can then take this information and process it as normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, a key trick for this design to work is to never discard any events,
    past or new. This is achieved by saving them in an event store; here is what this
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b39e000-6ae9-46f8-abcb-9d68c15174f3.png)'
  prefs: []
  type: TYPE_IMG
- en: There are multiple ways to implement an event store; it can be a SQL database,
    a NoSQL database, or even a message queue that supports having events saved forever.
    Kafka is an example of a message queue that claims to also be a good engine for
    event sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple approaches to tackling event sourcing; the scenario that
    we covered in this section represented an approach where we use event stores with
    snapshots. A snapshot in this case was the support microservice local database,
    which also tried to keep a snapshot state. However, the ultimate state was still
    expected to be in the event store.
  prefs: []
  type: TYPE_NORMAL
- en: There are other approaches to implementing event sourcing, where no snapshots
    are used and the entire state always has to be derived from the event store.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of event sourcing is that it can grow exponentially in complexity.
    That is because in some environments, we may need to replay tons of events in
    order to build the current state of the system, which requires a lot of processing
    and complexity. The queries we need to run in order to form data models that join
    data from different replay events can easily become painful.
  prefs: []
  type: TYPE_NORMAL
- en: A popular approach to control the complexity of event sourcing is CQRS.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea behind **Command Query Responsibility Segregation** (**CQRS**) is
    that commands—which means any operations related to changing data such as add,
    updates, or deletes—should be separated from queries—which are any operations
    related to reading data. In a microservices architecture, that may mean that some
    services should be responsible for commands, whereas others are responsible for
    querying.
  prefs: []
  type: TYPE_NORMAL
- en: A key advantage of CQRS is separation of concerns. That is because we separate
    write concerns from read concerns and allow them to scale independently. For example,
    let's say that we work with a complex application where we need different view
    models of our data to be available. We would like to store all customer data in
    an elastic search cluster in order to be able to efficiently search for them and
    retrieve their information. At the same time, we would like to store all the customer
    data in a graph database because we would like a graph view of the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will create micrservices that are responsible for querying
    the customer events from the events stream (message queue) and then updating elastic
    search and the graph database whenever a new customer event is received via event
    sourcing. Those services will be the querying part of CQRS. On the other hand,
    we'll have other microservices that are responsible for triggering new events
    whenever needed. Those services will end up being the command part of CQRS.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3211dba1-7403-49a0-b56a-c008bd94cfd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Those read and write microservices can then work with the rest of our services
    to form our application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dove deeper into the practical aspects of migrating from
    monolithic applications to microservices applications. We had a close look at
    some advanced design patterns and architectures that we can utilize to our benefit
    in order to switch from monolithic applications to microservices applications.
    This chapter concludes our learning journey for this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss some technologies and topics that you can
    start exploring after acquiring the knowledge contained within this book.
  prefs: []
  type: TYPE_NORMAL
