- en: Data and Your Friend, JSON
  prefs: []
  type: TYPE_NORMAL
- en: It's time to learn the specifics of how JavaScript deals with data internally.
    Most of these structures are (nearly) identical to Python, but there are differences
    in syntax and usage. We touched on them in [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar*, but now it's time to take a deeper dive into how we work with data and
    use methods and properties. Understanding how to work with data is foundational
    to using JavaScript, especially when doing advanced work such as working with
    APIs and Ajax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Data types – both JavaScript and Python are dynamically typed!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects and JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API calls from the frontend – Ajax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clone or download the repository for this book from GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers) and look
    through the `Chapter-4` material.
  prefs: []
  type: TYPE_NORMAL
- en: Data types – both JavaScript and Python are dynamically typed!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty Grammar**,*
    we discussed using `typeof()` to ascertain what a variable''s data type is and
    using `let` and `const` to define them. There''s an interesting fact about JavaScript
    that Python shares: both are dynamically typed. As opposed to statically typed
    languages such as Java, JavaScript''s variable types can change over the course
    of a program. This is one reason why `typeof()` can come in handy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a quick example contrasting JavaScript with Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Java** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If we tried to run the Java code, we'd get an error stating that the types are
    incompatible. In Java, *variables* have a type. When we run the JavaScript code,
    however, everything's just fine. In JavaScript, *values* have a type.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to know that JavaScript is *weakly typed*, which means that
    implicit conversion between data types is allowed in most cases. If we recall
    the loose and strict equality operators from [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml),
    *Nitty-Gritty Grammar*, weak typing is why current best practices specify using
    strict equality checking wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at a few languages on the scales of strong/weak and dynamic/static,
    we can plot the languages on an axis like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb1f8ae0-83e2-4a6b-8bb6-1a37426c00a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Axes of typing
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript style usually advocates for descriptive names rather than shorthand
    names. One of the reasons why this is acceptable is that often, JavaScript code
    is *minified* before it goes to production. It's not exactly like compiling, but
    it does condense whitespace and rename variables to be condensed. We'll discuss
    some of these build processes in [Chapter 16](e9e24fd5-967a-4853-88af-15a31a29f5cd.xhtml), *Enter
    Webpack, *when we discuss webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so JavaScript is dynamically and weakly typed. What does that mean in practice?
    The short answer is this: be careful! It''s very easy to get your types mixed
    up in a comparison operator or, even worse, accidentally cast a variable to a
    different type. It gives us much more flexibility as we''re writing our program,
    but it can also be a curse. Some developers like to use Hungarian notation ([https://frontstuff.io/write-more-understandable-code-with-hungarian-notation](https://frontstuff.io/write-more-understandable-code-with-hungarian-notation))
    to help differentiate variable types, but this isn''t common practice in JavaScript.
    Probably the best way to help yourself and your colleagues keep your types correct
    is to be explicit with your variable names.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a deeper dive into the primitive data types because they''ll be
    crucial to our work in JavaScript. We not only need to know *what* we''re using,
    but the *why* is also important. Our **primitives** are the building blocks of
    the rest of the language: Booleans, numbers, and strings. The rest of JavaScript
    is built upon these primitive data types. We''ll start with Booleans.'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Boolean** is possibly the simplest and most universal data type since
    it's inherently tied to the 1s and 0s of binary logic. In JavaScript, a Boolean
    is written simply as `true` or `false`. It's not recommended to use `1` or `0`
    for Boolean values, as they'll be interpreted as numbers and thus fail strict
    equality. Boolean values are a specific data type, as opposed to in Python, where,
    at the core of the language, Boolean inherits from a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember in [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar,* where we learned that almost everything in JavaScript is an object?
    The same applies to Booleans. As you can see in the following screenshot, if you
    bring up the JavaScript console in your browser, chances are that it will autocomplete
    for you to see the methods available to you for Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/77521c80-1b46-4b99-a80e-590a5e05874c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Boolean autocomplete in Chrome
  prefs: []
  type: TYPE_NORMAL
- en: Now, I doubt any of these methods are particularly useful to you, but it's a
    handy way to check what methods are available to you for a given variable.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans only get us so far—it's time to look at **numbers** next.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript doesn''t have a conception of different types of numbers such as
    integers, floats, or doubles—everything is simply a number. All the basic arithmetic
    methods are built-in, and the `Math` object provides the rest of the functionality
    you''d expect to find built into a programming language. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use scientific notation, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Numbers in JavaScript are not just any old numbers, but are, inherently, floats.
    To be technical, they are stored as double-precision floating-point numbers following
    the international IEEE 754 standard. However, this does lead to a couple of…interesting…quirks.
    Keep this in mind if you get strange results, such as in the following screenshot
    from the JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e62bdb66-7599-428a-bda8-57b9f3e55912.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Floating-point precision error
  prefs: []
  type: TYPE_NORMAL
- en: 'A rule of thumb is to think about what precision you want your calculations
    to be. You can use the `toPrecision()` method of a number to specify your precision
    and then the `parseFloat()` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`toPrecision()` returns a string, which may seem counter-intuitive at first,
    but there''s a good reason for it. Let''s say you needed your number to have two
    decimal places (for example, to display dollars and cents). If you used `toPrecision()`
    on a number and it returned a number, if you were to do more calculations on the
    integer, it would render only the integer unless you manipulated the decimal places
    as well. There is some method to the madness.'
  prefs: []
  type: TYPE_NORMAL
- en: Next up: **strings**. We need to add some content to our programs!
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ah, the venerable string data type. It has some of the basics you''d expect,
    such as a `length` property and the `slice()` and `split()` methods, but two that
    always trip me up are `substr()` and `substring()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two methods is that the first one specifies `(start,
    length)`, while the second specifies `(start, end index)`. A handy way to remember
    the difference is that `.substring()` has an "i" in the name, correlating with
    index—the place in the string at which to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new addition in ES6 that makes our life easier is template literals. Take
    a look at this log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It will work, but it''s a little clunky. Let''s use template literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important things to note in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The string starts and ends with a backtick, not a quote.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variables to insert are encased in `${ }`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template literals are handy, but they're not required. As you research code
    online when you run into problems, you will definitely see examples of the older,
    string-concatenated way of writing. However, keep in mind that this is an option
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try our hand at an exercise!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – a basic calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our knowledge of Booleans, numbers, and strings, let's build a basic calculator.
    Begin by cloning the repository at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/starter-code).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can safely ignore the HTML and CSS for the most part, but a readthrough
    of the HTML will help. Let''s take a look at the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is not an easy exercise for a beginner to JavaScript, so don't be afraid
    to check out the solution code and reverse-engineer it: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/solution-code)[.](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/calculator/solution-code)
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's explore **arrays** and a new addition to ES6: **sets**.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any programming language has some conception of an array or a *collection of
    item**s *that all share some common features or use. JavaScript has a few of them: **arrays **and **sets**.
    Both of these structures contain items, and in many ways, they are similar in
    usage, too, in that they can be enumerated, iterated over, and displayed for purposes
    of logical construction.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays can contain different data types. This is a fully viable array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It contains strings, numbers, Booleans, `null`, and an object. This is fine!
    While in practice you may not be mixing data types, there's nothing preventing
    you from doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a quirk about using `typeof()` on arrays: since they''re not true
    primitives, `typeof(myArray)` will return `object`. You should keep that in mind
    as you write JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw before in [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml),
    *Nitty-Gritty Grammar*, `.push()` and `.pop()` are two of the most useful array
    methods, to add and remove items from an array, respectively. There are a good
    number of other methods available, though. Let's take a look at a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an array, we can do so as in the previous code or simply as `const
    myArray = []`. Now, while we can modify the values inside an array, we can declare
    it as a `const` because, for most purposes, we wouldn''t want to let the program
    completely redefine it. We can still manipulate the values inside the array; we
    just don''t want to destroy and recreate it. Let''s continue with our array with
    items from the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Remember that arrays are zero-indexed, so our counting begins at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove an element from the end of an array, we use `.pop()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove an object from the beginning of an array, use `.shift()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that all of these methods introduced so far mutate the original array
    directly. `.pop()` and `.shift()` return the excised value, not the array itself.
    This distinction is important because not all array methods behave this way. Let''s
    take a look at `slice` and `splice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can look up the parameters for these two methods on the **MDN Web Docs**
    site. For the purposes of introducing these methods, just be aware that the behavior
    of methods on a variable can change from mutational to stable.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are closely related to arrays but have some slight differences. Let's take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sets are a compound data type introduced in ES6\. A set is an array with duplicates
    removed and that prohibits adding duplicates. Try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`myArray` will have a length of 8, while `mySet` will have a length of 7—even
    *after* trying to add `''goodbye''`. JavaScript''s `.add()` method of a set will
    first test to be sure a unique value is being added. Note the `new` keyword and
    the capitalization of the data type; this is not unique to creating sets, but
    it is important. In ES5 and before, it was common practice to declare new variables
    this way, but that practice is now considered legacy except for in a few instances.'
  prefs: []
  type: TYPE_NORMAL
- en: There's a common introductory-level JavaScript question in interviews that asks
    you to deduplicate an array. You can use a **set** to do this in one fell swoop
    instead of iterating through the array and checking each value.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many possible solutions to deduplicating an array without using
    sets, let's take a look at a fairly basic example that uses the `.sort()` method.
    As you can expect from the name, this method will sort an array in ascending order.
    This approach is best used if you know the array will contain the same data type
    of strings or numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We know a deduplicated, sorted array should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try it without using sets. Here is one approach that uses a deduplicating
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and take a look: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/index.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the output? We should get an array with a length of 3, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The raw approach is a bit more complex, right? Sets are a much more user-friendly
    way of deduplicating an array. Objects are another type of collection in JavaScript.
    As promised, here's a deeper dive into them.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects! Objects are at the core of JavaScript. As mentioned before in [Chapter
    3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty Grammar*, almost
    everything in JavaScript is, at its core, an object. Objects may be intimidating
    at first, but they''re easy enough to grasp in theory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the skeleton of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An object is a collection of *key/value pairs*. They''re useful for many reasons,
    especially to contain and organize data. Let''s look at the example of Captain
    Picard from the [Chapter 3](4257dcd7-525c-4ca9-9695-d9cfcff438d7.xhtml), *Nitty-Gritty
    Grammar*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw, we can use dot notation to access the properties of an object, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can also use other data types as values, as with `captain.seniorStaff`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with everything else, objects also have their own methods. One of the most
    handy ones is `.hasOwnProperty()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try our array deduplication again, but this time, let''s leverage
    objects to create a hashmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a peek: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/hashmap.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/hashmap.html).
    Now, it''s not immediately obvious, but this approach is nearly twice as fast
    as the deduplication method we explored before. Why? In short, an object''s values
    can be accessed immediately in O(1) time versus iterating through the whole array
    in O(n). If you''re unfamiliar with Big O notation, which is a fuzzy way to calculate
    code complexity, here''s a good primer: [https://www.topcoder.com/blog/big-o-notation-primer/](https://www.topcoder.com/blog/big-o-notation-primer/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a side-by-side comparison of the two approaches with an array of
    length 24,975.
  prefs: []
  type: TYPE_NORMAL
- en: The first implementation, [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large.html), will
    result in a time between 5 and 8 milliseconds (your mileage may vary).
  prefs: []
  type: TYPE_NORMAL
- en: However, by using a hashmap with an object, we can reduce our runtime by at
    least a few milliseconds: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large_hashmap.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/deduplicate/large_hashmap.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now, a few milliseconds may seem insignificant (and impossible to distinguish
    with the eye) but think about an operation that needs to run over and over against
    datasets of a similar length. The savings add up.
  prefs: []
  type: TYPE_NORMAL
- en: You can take a peek at [https://stackoverflow.com/a/9229821/2581282](https://stackoverflow.com/a/9229821/2581282)
    for some more ideas and explanations for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to examine something that makes JavaScript...well, *JavaScript!*
    Its notion of inheritance and classes is quite different from other languages.
    Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypal inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance in JavaScript really is one of its major strengths. Instead of
    classical class-based inheritance, JavaScript uses **prototypal** inheritance.
    (Protip: it''s pronounced *pro-to-TYPE-al* not *pro-to-TYPICAL.*) That''s because
    it uses the object''s prototype as a template. Do you remember previously when
    we worked with the methods of a string and a number in the console and found a
    bunch of methods available to us even on a simple data type? Well, we can go further
    than that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamental to the concept of prototypal inheritance in JavaScript is the prototype
    chain, which tells us what we have access to in terms of methods. Let''s take
    a look at a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/81656623-0365-4bb7-81ad-178cea0103d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The prototype chain
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does this mean? Consider `Alice`: we can see that this variable is
    a string as it descends from the `String` prototype. So, translated into code,
    we can say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What will we get in the console? Simply `Alice`. We've given the *property*
    of `name` to our `Alice` string object. Now, let's take a look at this mysterious
    `sayHello()` method in the prototype. What do you think would happen if we executed
    the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you guessed that we would get an undefined error on the `sayHello()` function,
    you'd be correct. We haven't defined it yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we do so by modifying the `String` prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, in our console, we will get `My name is Alice`. OK, so what happened?
  prefs: []
  type: TYPE_NORMAL
- en: By directly modifying the `String` prototype and adding a `sayHello()` method,
    we can use this method on any string and access its properties. Just like we used
    dot notation before, we can use the `this` keyword to refer to properties of the
    object within which we are working. Consequently, `this.name` works inside our
    prototype and equals `Alice.name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may be thinking *this seems a little dangerous*. We''re modifying
    a base data type, and if we attempted to call `.sayHello()` on a string that *doesn''t*
    have a `name` property, we''ll get a nice huge error. You''re correct! There''s
    a better way to do this that still utilizes the concept of prototypal inheritance.
    Take a peek at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we would expect, we get `My name is Alice.` and `My name is Bob.`. We didn't
    need to define `sayHello()` twice; rather, `Alice` and `Bob` *inherited* the method
    from `Person`. Efficiency!
  prefs: []
  type: TYPE_NORMAL
- en: Now we're going to talk about Jason. Jason who? No, no, the object-based data
    structure called **JSON** is what we're going to examine next.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSON** (pronounced *jay-sohn* or *jason*) stands for **JavaScript Object
    Notation**. If you''ve seen it in the field before, you may know that it''s often
    used as a convenient transfer format with APIs. We''ll discuss APIs a little more
    in a bit, but for now, let''s understand what JSON is and why it''s useful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what it looks like. We''ll be using the **Star Wars API**
    (**SWAPI**) ([https://swapi.dev](https://swapi.dev)) as a convenient read-only
    API. Take a peek at this example result: [https://swapi.dev/api/people/1/?format=json](https://swapi.dev/api/people/1/?format=json):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/120bc245-bca3-4ee3-9307-b2bdc4966f25.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – SWAPI people instance
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the great things about JSON is that it''s fairly legible, as it doesn''t
    have lots of nodes and formatting like XML. However, in its raw format, as in
    the preceding screenshot, it''s still a jumble. Browsers have great tools to parse
    JSON into a legible tree. Take a minute to find and install one for your browser
    and then visit the previous API call. Now, your response should be formatted as
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/660ec1ae-7931-4696-b340-89ecda9ba8e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – SWAPI formatted
  prefs: []
  type: TYPE_NORMAL
- en: That's a lot more legible now. Say hi to Luke Skywalker!
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the design decisions made by the authors of this API was to include
    in each result only the unique data of the resource in the result. For example,
    for `homeworld`, it doesn''t spell out "Tatooine" but rather provides a **URI**
    (**U****niform Resource Identifier**) for a *planet* resource. We can see that
    `homeworld` and its data are key-value pairs, just like other objects, `films`
    is an array of strings, and the entire dataset is an object with curly braces
    at the beginning and end. That''s all there is to JSON: properly formatted JavaScript
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to dive into a couple of pieces of information about how the internet
    works to inform our use of JavaScript, APIs, and the greater web in general.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the HTTP verbs that allow us to communicate back
    and forth with APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Verb** | **CRUD Equivalent** |'
  prefs: []
  type: TYPE_TB
- en: '| POST | Create |'
  prefs: []
  type: TYPE_TB
- en: '| GET | Read |'
  prefs: []
  type: TYPE_TB
- en: '| PUT | Update/Replace |'
  prefs: []
  type: TYPE_TB
- en: '| PATCH | Update/Modify |'
  prefs: []
  type: TYPE_TB
- en: '| DELETE | Delete |'
  prefs: []
  type: TYPE_TB
- en: While the actual verbs used in an API depend on the API's design, these are
    the standard REST terms that many APIs today use. **REST** stands for **REpresentational**
    **State** **Transfer** and is a standard description of how to format APIs. Now,
    REST or RESTful APIs don't always have to communicate with JSON—REST is agnostic
    to format. Let's take a look at API calls in practice.
  prefs: []
  type: TYPE_NORMAL
- en: API calls from the frontend – Ajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ajax** (also spelled AJAX) stands for **Asynchronous JavaScript and XML**.
    These days, however, you''re more likely to work with JSON than XML, so the name
    is a bit misleading. On to code: take a look at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi.html).
    Open this locally, and in your developer tools, you should see a JSON object as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3bf95b87-4173-419f-9bd5-b7d93eb3ff40.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – SWAPI Ajax result
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You''ve made your first Ajax call! Let''s break down the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`fetch` is a fairly new API in ES6 that essentially replaces the older, more
    complicated way of making Ajax calls with `XMLHttpRequest`. As you can see, the
    syntax is fairly concise. What might not be obvious is the role that the `.then()`
    functions play—or even what they are.'
  prefs: []
  type: TYPE_NORMAL
- en: '`.then()` is an example of a Promise. We won''t discuss Promises at length
    right now, but the basic premise hinges upon the asynchronous part of JavaScript.
    Essentially, a Promise says: "Execute this code, and I promise that at a later
    time, I''ll provide you with more data. Don''t block code execution here."'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi-2.html](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-4/ajax/swapi-2.html)
    locally in your browser. You should see Loading Data… for a quick second, and
    then the JSON displayed. You can use your browser's developer tools to throttle
    your internet connection to see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much about the `document.querySelector` lines—we'll cover those
    in detail in [Chapter 6](fe95a50e-72eb-45eb-a35c-4ce76858884e.xhtml), *The Document
    Object Model (DOM)*. For now, just understand that they're used to place information
    in an HTML document. Let's throttle our connection using the developer tools down
    to Slow 3G or similar. When we refresh, we should see a flash of Awaiting Headline…,
    then Luke Skywalker, followed by Loading Data…, and *then*, a few seconds later,
    the JSON as text.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this work? The line of code to change Awaiting Headline… to Luke
    Skywalker comes after the Ajax call. So why does the headline change *before*
    the data section? The answer is *Promises*.
  prefs: []
  type: TYPE_NORMAL
- en: Using `fetch`, we establish that we're inherently using asynchronous data, and
    thus the `.then()` statements tell us what we can do *after* the Promised statement
    resolves. It frees the program to continue on to other parts of the program. In
    fact, we could make multiple fetch calls that may return at various times, and
    still not block our user's use of the program. Asynchronicity is a fundamental
    concept when working with modern JavaScript, so take your time understanding it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's get some experience with actually *using *APIs! It's time to really
    get our hands dirty and interact with not just local code but also external code.
  prefs: []
  type: TYPE_NORMAL
- en: SWAPI lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get some hands-on practice with this API. What we're going to do is fairly
    inelegant for the moment, but it will show us how to use asynchronous behavior
    to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should expect to see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d0bfb7d6-c598-4c5d-a379-56e4e22f3dd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – SWAPI Promises result
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that since we're using Promises and have to iterate over the `films`
    array, the order of films may vary. You can choose to order them by film number
    if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lab will require nested Promises and some syntaxes we haven''t covered
    yet, so give yourself plenty of time to experiment if you''d like to do this lab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starter code: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/starter-code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution code: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-4/ajax-lab/solution-code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with any lab, keep in mind that the solution code won't match your code,
    but is meant as a resource for thought processes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data is at the heart of every program, and your JavaScript programs are no
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is loosely typed, which means variable types can mutate if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booleans are simple true/false statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers are non-differentiated between integers, floats, or other types of numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and sets can contain a lot of data and make organizing our data easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects are key-value pairs that efficiently store data for O(1) retrieval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API calls are actually not that scary!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've taken a closer look at data types, APIs, and JSON. What we've discovered
    is that data is very flexible in JavaScript, up to and including manipulating
    the prototypes of the objects themselves. Taking a look at JSON and APIs, we've
    successfully used `fetch()` to perform our first API calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive further into writing JavaScript to make a more
    interesting application, as well as understanding the details of how to construct
    one!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the following questions, select the correct option:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is inherently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronous
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Asynchronous
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A `fetch()` call returns a:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`then`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`next`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`finally`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Promise
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With prototypal inheritance, we can (select all):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add methods to a base data type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract methods from a base data type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename our data type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast our data into another format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, what will be the expected output?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, what's the best way to output `Will Riker`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Riker.sayHello()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`console.log(Riker.name)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`console.log(Riker.this.name)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Officer.Riker.name()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on statically versus dynamically typed languages, you can
    refer to [https://android.jlelse.eu/magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b](https://android.jlelse.eu/magic-lies-here-statically-typed-vs-dynamically-typed-languages-d151c7f95e2b).
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about Hungarian notation, refer to [https://frontstuff.io/write-more-understandable-code-with-hungarian-notation](https://frontstuff.io/write-more-understandable-code-with-hungarian-notation).
  prefs: []
  type: TYPE_NORMAL
