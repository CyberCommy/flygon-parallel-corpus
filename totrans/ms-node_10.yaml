- en: Testing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"When the terrain disagrees with the map, trust the terrain."'
  prefs: []
  type: TYPE_NORMAL
- en: – Swiss Army Manual
  prefs: []
  type: TYPE_NORMAL
- en: Since Node is being built by a community fully committed to code sharing, where
    interoperability between modules is so important, it should come as no surprise
    that code testing tools and frameworks entered Node's ecosystem right after inception.
    Indeed, the normally parsimonious core Node team added the `assert` module early
    on, suggesting a recognition that testing is a fundamental part of the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is not solely a bug-detecting and defect-fixing process. Test-Driven
    Development, for example, insists on having tests precede the existence of any
    code! Testing, generally, is the process of making comparisons between the existing
    behavior and desired behavior in software, where new information is continuously
    fed back into the process. In this sense, testing involves modeling expectations
    and verifying that individual functions, composed units, and implementation paths
    satisfy the expectations of every stakeholder, both within and beyond the boundaries
    of an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is, therefore, also about managing risk. In this way, anomalies can
    be identified and quantified, while bumps in the terrain can now usefully inform
    our current understanding of the map such that the number of missteps (or defects)
    decline and our confidence rises. Testing helps us measure when we are done.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on some known and useful patterns for testing
    Node applications, investigating native Node tools for code integrity testing,
    general testing with the Mocha framework, and headless browser testing, the last
    allowing for the testing of browser-based JavaScript from within a Node environment.
    We'll also be looking at the other side of the testing coin—debugging—and combine
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: As you move through this chapter, it might be useful to keep in mind that integrating
    the philosophy of testing into a project can be difficult to do well. Writing
    the right tests is more difficult than writing some tests. Testing the right things
    is more difficult than testing everything (full code coverage seldom means nothing
    can go wrong). A good testing strategy should be implemented as early as possible—something
    to consider as you embark on your next Node project.
  prefs: []
  type: TYPE_NORMAL
- en: Why testing is important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good testing strategy builds confidence through the accumulation of proof
    and increasing clarity. Within a company, this might mean that some criteria for
    the execution of a business strategy have been satisfied, allowing for the release
    of a new service or product. The developers within a project team gain the pleasure
    of an automated judge that confirms or denies whether changes committed to a code
    base are sound. With a good testing framework, refactoring loses its danger; the
    "if you break it you own it" caveat that once placed negative pressure on developers
    with new ideas is no longer as ominous. Given a good version control system and
    test/release process, any breaking change can be rolled back without negative
    impact, freeing curiosity and experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three common types of tests are: unit tests, functional tests, and integration
    tests. While our goal in this chapter is not to put forward a general theory about
    how to test applications, it will be useful to briefly summarize what unit, functional,
    and integration tests are, which members of a team are most interested in each,
    and how we might go about building up (or breaking up) a code base into testable
    units.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unit tests** concern themselves with units of system behavior. Each unit
    being tested should encapsulate a very small set of code paths, without entanglements.
    When a unit test fails, this should, ideally, indicate that an isolated part of
    the overall functionality is broken. If a program has a well-described set of
    unit tests, the purpose and expected behavior of an entire program should be easy
    to comprehend. A unit test applies a limited perspective to small parts of a system,
    unconcerned with how those parts may be wrapped up into larger functional blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: An example unit test might be described in this way; when the `123` value is
    passed to a `validate_phone_number()` method, the test should return false. There
    is no confusion about what this unit does, and a programmer can use it with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are normally written and read by programmers. Class methods are good
    candidates for unit tests, as are other service endpoints whose input signatures
    are stable and well understood, with expected outputs that can be accurately validated.
    Generally, it is assumed that unit tests run quickly. If a unit test is taking
    a long time to execute, it is likely that the code under test is much more complex
    than it should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests are not concerned with how a function or method will receive its
    inputs, or how it will be used in general. A test for an `add` method shouldn''t
    be concerned with whether the method will be used in a calculator or somewhere
    else, it should simply test whether the two integer inputs (3,4) will cause the
    unit to emit a correct result (7). A unit test is not interested in where it fits
    in the dependency tree. For this reason, unit tests will often *mock* or *stub*
    data sources, such as passing two sample integers to an `add` method. As long
    as the inputs are typical, they need not be actual. Additionally, good unit tests
    are reliable: unencumbered by external dependencies, they should remain valid,
    regardless of how the system around them changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests only confirm that a single entity works in isolation. Testing whether
    units can work well when combined is the purpose of functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where unit tests concern themselves with specific behaviors, **functional tests**
    are designed to validate pieces of functionality. The ambiguity of the root word
    *function*, especially for programmers, can lead to confusion, where *unit tests*
    are called *functional tests*, and vice versa. A functional test combines many
    units into a body of functionality, such as *when a user enters a username and
    password and clicks on send, that user will be logged into the system*. We can
    easily see that this functional group will comprise of many unit tests, one for
    validating a username, one for handling a button click, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests are normally the concern of those responsible for some specific
    domain within an application. While programmers and developers will remain the
    ones to implement these tests, product managers or similar stakeholders will normally
    devise them (and complain when they fail). These tests for the most part check
    whether larger product specifications are being satisfied, rather than for technical
    correctness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example unit test for `validate_phone_number` given earlier might form
    part of a functional test with this description: when a user enters the wrong
    phone number, display a help message that describes the right format in that user''s
    country. That an application bothers to help users who make mistakes with phone
    numbers is an abstract effort very different from simply validating a technical
    entity like a phone number. Functional tests might be thought of as abstract models
    of how well some collection of units work together to satisfy a product need.'
  prefs: []
  type: TYPE_NORMAL
- en: As functional tests are made against combinations of many units, it is expected
    that, unlike an isolated unit test, executing them will involve mixing concerns
    from any number of external objects or systems. In the preceding login example,
    we see how a relatively simple functional test can cut across database, UI, security,
    and other application layers. As it is compositionally more complex, it's OK if
    functional tests take a little more time to run than unit tests. Functional tests
    are expected to change less often than unit tests, such that changes in functionality
    often represent major releases, as opposed to the minor changes unit test modifications
    usually indicate.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, like unit tests, functional tests are themselves isolated from concerns
    about how the functional group under test, as a whole, relates to the rest of
    an application. For this reason, mock data may be used as a context for running
    functional tests, as the functional group itself is not concerned with its effect
    on general application state, which is the domain of integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Integration tests** ensure that the entire system is correctly wired together,
    so that a user would feel that the application is working correctly. In this way,
    integration tests typically validate the expected functionality of an entire application,
    or one of a small set of significant product functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important difference between integration and the other types of tests
    under discussion is that integration tests are to be executed within a realistic
    environment, on real databases with actual domain data, on servers, and other
    systems mirroring the target production environment. In this way, integration
    tests can easily break formerly passing unit and functional tests.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a unit test for `validate_phone_number` may have given a pass to
    an input like `555-123-4567`, but during an integration test, it will fail to
    pass some real (and valid) system data like `555.123.4567`. Similarly, a functional
    test may successfully test the ability of an ideal system to open a help dialog,
    but when integrated with a new browser or other runtime, it is found that the
    expected functionality is not achieved. An application that runs well against
    a single local filesystem may fail when run against a distributed filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this added complexity, system architects—the team members that are able
    to apply a higher-level perspective on what system correctness entails—normally
    design integration tests. These tests find errors in the wiring that isolated
    tests are not able to recognize. Not surprisingly, integration tests can often
    take a long time to run, typically designed to not only run simple scenarios but
    to imitate expected high-load, realistic environments.
  prefs: []
  type: TYPE_NORMAL
- en: Native Node testing and debugging tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A preference for tested code has formed part of the Node community's ethos since
    its inception, reflected in the fact that most popular Node modules, even simple
    ones, are distributed with test suites. While browser-side development with JavaScript
    suffered for many years without usable testing tools, the relatively young Node
    distribution contains many. Perhaps because of this, many mature and easy-to-use
    third-party testing frameworks have been developed for Node. This leaves a developer
    no excuse for writing untested code! Let's look into some of the provided tools
    for debugging and testing Node programs.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Console output is the most basic testing and debugging tool, providing a quick
    way to see what is happening at some point in a script. The globally accessible
    `console.log` is commonly used when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Node has enriched this standard output mechanism with more useful methods, such
    as `console.error(String, String…)`, which prints arguments to `stderr` rather
    than `stdout`, and `console.dir(Object)`, which runs `util.inspect` (refer to
    the following) on the provided object and writes results to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pattern is commonly seen when a developer wants to track how
    long a piece of code takes to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `console.time` and `console.timeEnd` methods standardize this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you pass the same label to `timeEnd()` so that Node can find the
    measurement you started with `time()`. Node prints the stopwatch result to `stdout`.
    We will see other special console methods when discussing the assert module and
    performing stack traces later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting console output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding methods are all very useful when logging simple strings. More
    often, useful logging data may need to be formatted, either by composing several
    values into a single string, or by neatly displaying a complex data object. The
    `util.format` and `util.inspect` methods can be used to handle these cases.
  prefs: []
  type: TYPE_NORMAL
- en: The util.format(format, [arg, arg…]) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method allows a formatting string to be composed out of placeholders,
    each of which captures and displays the additional values passed. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see that the two placeholders (prefixed by `%`) are replaced in order
    by the passed arguments. Placeholders expect one of the following three types
    of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%s`: A string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%d`: A number, either an integer or a float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%j`: A JSON object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a greater number of arguments than placeholders is sent, the extra arguments
    are converted to strings via `util.inspect()`, and concatenated to the end of
    the output, separated by spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If no formatting string is sent, the arguments are simply converted to strings
    and concatenated, separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: The util.inspect(object, [options]) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use this method when a string representation of an object is desired. Through
    the setting of various options, the look of the output can be controlled:'
  prefs: []
  type: TYPE_NORMAL
- en: '`showHidden`: Defaults to false. If true, the object''s non-enumerable properties
    will be shown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depth`: An object definition, such as a JSON object, can be deeply nested.
    By default, `util.inspect` only traverses two levels into the object. Use this
    option to increase (or decrease) that depth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colors`: Allows the colorization of the output (check out the following code
    snippet).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customInspect`: If the object being processed has an `inspect` method defined,
    the output of that method will be used instead of Node''s default `stringification`
    method (refer to the following code snippet). Defaults to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting a custom inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This can be very useful when logging complex objects, or objects whose values
    are so large as to make console output unreadable. If your shell is showing pretty
    colors in your terminal, `util.inspect` will too if color is set to true. You
    can even customize which colors, and how they are used. By default, the colors
    just indicate the data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the defaults, as set in `util.inspect.styles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Node shows functions in cyan under the special category in the preceding code.
    These default color assignments may be swapped out with one of the supported ANSI
    color codes stored in the `util.inspect.colors` object: bold, italic, underline,
    inverse, white, grey, black, blue, cyan, green, magenta, red, and yellow. For
    example, to have the number values of objects displayed in green rather than the
    default of yellow, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Node debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most developers have used an IDE for development. A key feature of all good
    development environments is access to a debugger, which allows breakpoints to
    be set in a program in places where state or other aspects of the runtime need
    to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'V8 comes with a powerful debugger (commonly seen powering the Google Chrome
    browser''s developer tools panel), and this debugger is accessible to Node. It
    is invoked using the inspect directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple step-through and inspection debugging can now be achieved within a node
    program. Consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dummyVar` will make sense in a second. For now, note the `debugger` directive.
    Executing this program without that line runs the program as you would expect:
    print `hello`, wait a second, and then print `world`. With the debugger directive,
    running inspect produces this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger directive creates a break point, and once hit, Node gives us a
    CLI to the debugger itself, from within which we can execute some standard debugging
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cont` or `c`: Continue execution from the last break point, until the next
    break point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` or `s`: Step in, that is, keep running until a new source line (or break
    point) is hit, then return control to debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next` or `n`: The same as `step`, but function calls made on the new source
    line are executed without stopping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`out` or `o`: Step out, that is, execute the remainder of the current function
    and back out to the parent function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backtrace` or `bt`: Trace the steps to the current execution frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setBreakpoint()` or `sb()`: Set a break point on the current line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setBreakpoint(Integer)` or `sb(Integer)`: Set a break point on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the specified line
  prefs: []
  type: TYPE_NORMAL
- en: '`clearBreakpoint()` or `cb()`: Clear break point on the current line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clearBreakpoint(Integer)` or `cb(Integer)`: Clear a break point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: on the specified line
  prefs: []
  type: TYPE_NORMAL
- en: '`run`: If the debugger''s script has terminated, this will start it again'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: Terminates and restarts the script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pause` or `p`: Pause running code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill`: Kill the running script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quit`: Exit the debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: Display V8 version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts`: Lists all loaded scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To repeat the last debugger command, simply press *Enter* on your keyboard.
    Your carpal tunnels will thank you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the script we are debugging: entering `cont` into the debugger
    will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We're now stopped at the debugger statement on line 3 (note the chevron). If
    you now, for example, type `next` (or `n`,) the debugger will step to the next
    instruction and stop at `console.log('world')`.
  prefs: []
  type: TYPE_NORMAL
- en: It is normally useful at a break point to do some state inspection, such as
    the value of variables. You can jump into the **repl** from the debugger in order
    to do that. Currently, we're paused at the `debugger` statement. What if we wanted
    to check the value of `dummyVar`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As an experiment, run the script again, using `next` instead of `cont`, just
    before the execution of this final context. Keep hitting Enter (which repeats
    your last command) and try to follow the code that is being executed. After a
    few steps you''ll notice that the `timers.js` script will be introduced into this
    execution context, and you''ll see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `scripts` command in the debugger at this point, which lists currently
    loaded scripts. You will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Experiment with various methods of using the powerful V8 debugger to pause,
    inspect, and navigate within your Node program. Beyond common debugging needs,
    the debugger is great at showing you what Node does at a deep level when executing
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we'll return to a discussion of other debugging and testing
    techniques and tools available to the Node developer. For now, let's consider
    the `assert` module, and how to deploy this native testing framework provided
    with Node.
  prefs: []
  type: TYPE_NORMAL
- en: The assert module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node''s `assert` module is used for simple unit testing. In many cases, it
    suffices as a basic scaffolding for tests, or is used as the assertion library
    for testing frameworks (such as Mocha, as we''ll see later). Usage is straightforward:
    we want to assert the truth of something, and throw an error if our assertion
    is not true. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the assertion were true (both values are equal), nothing would be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Following the UNIX Rule of Silence (when a program has nothing surprising, interesting,
    or useful to say, it should say nothing), assertions only return a value when
    the assertion fails. The value returned can be customized using an optional message
    argument, as seen in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `assert` module API is composed of a set of comparison operations with
    identical call signatures: the actual value, the expected value, and an optional
    message to display when the comparison fails. Alternate methods functioning as
    shortcuts or handlers for special cases are also provided.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A distinction must be made between identity comparison (`===`) and equality
    comparison (`==`), the former often referred to as strict equality comparison
    (as is the case in the `assert` API). As JavaScript employs dynamic typing, when
    two values of different types are compared using the `==` equality operator, an
    attempt is made to coerce (or cast) one value into the other, a sort of common
    denominator operation. Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the more predictable results when identity comparison is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The thing to remember is that the `===` operator does not perform type coercion
    prior to the comparison, while the equality operator compares after type coercion.
  prefs: []
  type: TYPE_NORMAL
- en: Equating strings and numerals makes JavaScript a forgiving language for newcomers
    to programming, and soon after, creates a bug the now more experienced programmer
    inadvertantly hid in a larger code base. Language authors such as *Brendan Eich*
    make decisions like these, and are seldom able to change behavior so fundamental
    later on, and they have to defend their decisions through unending arguments and
    controversy as programmers bash and laud their languages because of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, because objects may contain the same values but not be derived
    from the same constructor, the identity of two objects with the same values is
    distinct; identity requires that both operands refer to the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the concept of deep equality is used for object comparisons where
    identity need not be exact. Two objects are deeply equal if they both possess
    the same number of owned properties, the same prototype, the same set (though
    not necessarily the same order) of keys, and equivalent (not identical) values
    for each of their properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It is useful to test your assumptions about how values are understood in comparison
    to each other by designing some assertion tests. The results may surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the functions in Node''s assert module, organized into groups based
    on how you might use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using an assert function with equal in the name follows the same rules as the
    `==` operator, while strict equal is like using `===` instead. Additionally, choose
    a function with deep in the title, or not, to pick the desired behavior we explored
    earlier. The simplest function, `assert.ok`, can be all you need if you write
    the logic of equating yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node''s asynchronous functions return an error object to your callback function.
    Give this object to `assert.ifError(e)` and if `e` is defined, `ifError` will
    throw it. Use `assert.fail()` when execution has reached a part of your code where
    it should never go. This is most useful when the exception is trapped by a `try`/`catch`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A shortcut method for logging assertion results is available in the console
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can confirm that functions always throw or never throw with
    `assert.throws` and `assert.doesNotThrow`.
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed explanation of how comparison is done in JavaScript, consult:[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
    [Node's assert module is strongly influenced by the CommonJS test specification,
    which can be found at:](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
    [http://wiki.commonjs.org/wiki/Unit_Testing](http://wiki.commonjs.org/wiki/Unit_Testing)[.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some instances, you might want to run a script within a separate and more
    limited context, isolated from the scope of your larger application. For these
    situations, Node provides the `vm` module, a sandbox environment consisting of
    a new V8 instance and a limited execution context for running script blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see how a provided sandbox becomes the local execution scope for the
    provided script. The running script only operates within the provided sandbox
    object, and is denied access to even the standard Node globals, such as the running
    process, which we can demonstrate by changing the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This module does not guarantee a perfectly safe *jail* within which completely
    untrusted code can be executed safely. If this is your need, consider running
    a separate process with proper system-level permissions. As `vm` spins up a new
    V8 instance, each invocation costs some milliseconds of startup time and about
    two megabytes of memory. Use `vm` only when it's worth this performance cost.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of testing code, the `vm` module can be quite effective, in
    particular, in its ability to force code to run in a limited context. When performing
    a unit test, for example, one can create a special environment with mocked data
    simulating the environment within which the tested script will run. This can be
    better than creating an artificial call context with fake data. Additionally,
    this sandboxing will allow the execution context for new code to be better controlled,
    providing good protection against memory leaks and other unanticipated collisions
    that may bubble up while testing.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing between local scope and execution context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before covering further examples, we need to distinguish between the local
    scope of a process and its execution context. The distinction will help with understanding
    the difference between the two primary `vm` methods: `vm.runInThisContext` and
    `vm.runInNewContext`.'
  prefs: []
  type: TYPE_NORMAL
- en: At any time, V8 might have a single, or more likely, several, execution contexts.
    These contexts act as separate containers, in which V8 can execute some more JavaScript.
    When using Chrome, you can think of these execution contexts as different tabs
    navigated to different websites.
  prefs: []
  type: TYPE_NORMAL
- en: The script on one site can't see or mess up the script on another site. The
    execution context of a Node process represents the runtime context within V8,
    including native Node methods and other global objects (process, console, setTimeout,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: A script executed through `vm.runInNewContext` has no visibility into either
    scope; its context is limited to the sandbox object to which it was passed, as
    seen earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'A script executed through `vm.runInThisContext` has visibility into the global
    execution scope of your Node process, but not into the local scope. We can demonstrate
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Scripts are, therefore, run within contexts through `vm`.
  prefs: []
  type: TYPE_NORMAL
- en: It is often useful to precompile contexts and scripts, in particular, when each
    will be used repeatedly. Use `vm.createContext([sandbox])` to compile an execution
    context, and pass in a key/value map. In the next section, we'll look at how to
    apply these contexts to precompiled scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Using compiled contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After receiving a string of JavaScript code, the V8 compiler will do its best
    to optimize the code into a compiled version that runs more efficiently. This
    compilation step must occur each time a `vm` context method receives code as a
    string. If your code doesn't change and is reused at least once, it is better
    to use `new vm.Script(code, [filename])` to compile it once and for all.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can executed these compiled scripts in the contexts inherited from `runInThisContext`
    and `runInNewContext`. Here, we run a compiled script in both contexts, demonstrating
    how the `x` and `y` variables being incremented exist in fully isolated scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Had both scripts modified the same `x` and `y` in context, the outputs would
    have been `2000 2000` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if the `runInNewContext` script is not passed an emulation layer
    (sandbox), it will throw a `ReferenceError: x is not defined`, having access to
    neither the local nor global `x` and `y` values. Try it out.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know something about assertions and creating test contexts, let's
    write some real tests using some common testing frameworks and tools.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Mocha, Chai, and Sinon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great benefits of writing tests for your code is that you will be
    forced to think through how what you’ve written works. A test that is difficult
    to write might indicate code that is difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, comprehensive coverage with good tests helps others (and
    you) understand how an application works. In this section, we’ll look at how to
    describe your tests using the test runner **Mocha**, using **Chai** as its assertion
    library, and **Sinon** when mocking is necessary to a test. We'll use **redis**
    to demonstrate how to create tests against a simulated dataset (rather than testing
    against production databases, which would, of course, be a bad idea). We’ll use
    **npm** as a test script runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, set up the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, initialize a `package.json` file with `npm init` within the `/testing`
    folder. You can just press *Enter* at the prompts, but when you are asked for
    a test command, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This sets up our project for importation of the modules we'll need. We'll discuss
    what Chai does later. For now, suffice it to say that in this test command, Mocha
    is being referred to a configuration file for dependency information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and install the needed libraries into this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `/scripts` folder will contain the JavaScript we’ll be testing. The `/spec`
    folder will contain configuration and test files.
  prefs: []
  type: TYPE_NORMAL
- en: This will make more sense as we move ahead. For now, recognize that this assignation
    to npm’s `test` attribute asserts that we will be using Mocha for testing, Mocha’s
    test report will be of the `spec` type, and that tests will exist in the `/spec`
    directory. We are also requiring a configuration file for Chai, which will be
    explained as we move on. Importantly, this has now created a script declaration
    in npm that will allow you to run your test suite with the `npm test` command. Use
    that command whenever you need to run the Mocha tests we’ll be developing in what
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mocha is a test runner that does not concern itself with test assertions themselves.
    Mocha is used to organize and run your tests, primarily through the use of the
    `describe` and `it` operators. Schematically, Mocha tests look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Mocha harness leaves open how the tests are described and
    organized, and makes no assumptions about how test assertions are designed. It
    is an organizational harness for your tests, with the additional aim of producing
    human-readable test definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set up tests that run synchronously, as described earlier, or asynchronously
    using the completion handler passed to all its callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Blocks can also be nested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Mocha offers *hooks*, enabling you to run some code before and/or
    after tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeEach()` runs before each test in a describe block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach()` runs after each test in a describe block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before()` runs code once prior to any test—prior to any run of `beforeEach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after()` runs code once after all tests have run—after any run of `afterEach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, these are used to set up test contexts, such as creating some variables
    before tests and cleaning them up prior to some other tests. This simple collection
    of tools is expressive enough to handle most testing needs. Additionally, Mocha
    provides various test reporters that offer differently formatted results. We’ll
    see those in action later as we build some realistic test scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw earlier with Node’s native assert module, at its base, testing involves
    asserting what we expect some chunk of code to do, executing that code, and checking
    whether our expectations were met. Chai is an assertion library that offers a
    more expressive syntax, offering three assertion styles: `expect`, `should`, and
    `assert`. We will use Chai to provide the assertions (tests) to be wrapped within
    Mocha `it` statements, favoring the `expect` style of assertion.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while `Chai.assert` is modeled after the core Node assert syntax,
    Chai augments the object with additional methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we will create a configuration file, `chai.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Place this file in the `/spec/helpers` folder. This will tell Chai to display
    the full stack trace of any errors, and to expose the expect assertion style as
    a global. Similarly, Sinon is also exposed as a global (more on Sinon in the next
    section). This file will augment the Mocha test run context such that we can use
    these tools without having to redeclare them in each test file. The `expect` style
    of assertion reads like a sentence, with *sentences* composed from works like
    *to*, *be*, *is*, and more. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To explore the extensive list of *words* available when creating expect test
    chains, consult the full docs at: [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
    As stated earlier, Mocha does not have an opinion on how you create assertions.
    We will use `expect` to create assertions in the tests that follow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider testing the capitalize function in the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We might do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This Chai assertion will be true, and Mocha will report the same. You will construct
    your entire test suite out of these blocks of descriptions and assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at how to add Sinon to our test process.
  prefs: []
  type: TYPE_NORMAL
- en: Sinon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within a testing environment, you are typically emulating the realities of a
    production environment, as access to real users or data or other live systems
    is unsafe or otherwise undesirable. Being able to simulate environments is, therefore,
    an important part of testing. Also, you will often want to inspect more than just
    call results; you might want to test whether a given function is being called
    in the right context or with the right examples. Sinon is a tool that helps you
    simulate external services, emulate functions, track function calls, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sinon-chai module extends Chai with Sinon assertions at: [https://github.com/domenic/sinon-chai](https://github.com/domenic/sinon-chai).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key Sinon technologies are spies, stubs, and mocks. Additionally, you can
    set fake timers, create fake servers, and more (visit: [http://sinonjs.org/](http://sinonjs.org/)).
    This section focuses on the first three. Let’s go over some examples of each.'
  prefs: []
  type: TYPE_NORMAL
- en: Spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the Sinon documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A test spy is a function that records arguments, returns value, the value
    of this and exception thrown (if any) for all its calls. A test spy can be an
    anonymous function, or it can wrap an existing function."'
  prefs: []
  type: TYPE_NORMAL
- en: 'A spy gathers information on the function it is tracking. Take a look at this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The spy was called twice; once with `foo`, once with `bar`, and never with `baz`.
    If you're writing a test of whether a certain function was called and/or testing
    the arguments it received, spies are a great testing tool for your case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose that we wanted to test whether our code properly connects to
    the pub/sub functionality of Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do more with spy and Mocha. We deploy spy to proxy the
    native subscribe method of client1, importantly setting up and tearing down the
    spy proxy (restoring the original functionality) within Mocha’s before and after
    methods. The Chai assertions prove that both `subscribe` and `nowPublish` are
    functioning correctly, and are receiving the right arguments. More information
    on spies can be found at: [http://sinonjs.org/releases/v4.1.2/spies](http://sinonjs.org/releases/v4.1.2/spies).'
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test stubs are functions (spies) with preprogrammed behavior. They support the
    full test spy API in addition to methods that can be used to alter the stub’s
    behavior. A stub, when used as a spy, can be wrapped around an existing function
    such that it can fake the behavior of that function (rather than simply recording
    function executions, as we saw earlier with spies).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that you have some functionality in your application that makes
    calls to some HTTP endpoint. The code may be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When successful, the call will log `Got status: 200`. Should the endpoint be
    unavailable, you’ll see something like `Got error: getaddrinfo ENOTFOUND`.'
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that you will need to test the ability of your application to handle
    alternate status codes, and, of course, explicit errors. It may not be in your
    power to force the endpoint to emit these, yet you must prepare for them, should
    they occur. Stubs are useful here to create synthetic responses, so that your
    response handlers can be tested comprehensibly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use stubs to emulate a response without actually calling the `http.get`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This stub yields a simulated response by wrapping the original method, which
    is never called, resulting in a `404` being returned from a call that would normally
    return a status code of `200`. Importantly, note how we `restore` the stubbed
    method to its original state when done.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following *pseudo* code describes a module that makes HTTP
    calls, parses the response, and responds with `''handled''` if everything went
    okay, and `''not handled''` if the HTTP response was unexpected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Mocha test ensures that the `Caller.parseReponse` method can
    handle all response codes we need handled, using stubs to simulate the entire
    expected response range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By proxying the original `makeCall` method, we can test `parseResponse` against
    a range of status codes without the difficulty of forcing remote network behavior.
    Noting that the preceding test should fail (there is no handler for `403` codes),
    the output of this test should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cb086b1-72f3-46bb-af64-53c20ddb1fa7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The full API for stubs can be seen at: [http://sinonjs.org/releases/v4.1.2/stubs/](http://sinonjs.org/releases/v4.1.2/stubs/).'
  prefs: []
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocks (and mock expectations) are fake methods (like spies) with preprogrammed
    behavior (like stubs) as well as preprogrammed expectations. A mock will fail
    your test if it is not used as expected. Rather than checking expectations *after
    the fact*, mocks can be used to check whether the unit under test is being used
    correctly; they enforce implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we check the number of times a specific function
    is called and that it is called with specific, expected arguments. Specifically,
    we again test the `capitalize` method of Utilities, this time using mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After setting up a mock on `utilities`, we map a five element array to `capitalize`,
    expecting `capitalize` to be called exactly five times, with the array’s elements
    as arguments (using `apply` to spread the array into individual arguments). The
    well-named `mock.verify` is then checked to see whether our expectations were
    satisfied. As usual, when done, we unwrap the utilities object with `mock.restore`.
    You should see true logged to your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remove one element from the tested array, frustrating expectations. When
    you run the test again, you should see the following near the top of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This should clarify the type of test results that mocks are designed to produce.
  prefs: []
  type: TYPE_NORMAL
- en: Note that mocked functions do not execute; `mock` overrides its target. In the
    preceding example, no array members are ever run through `capitalize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit our earlier example testing Redis `pub/sub`, using mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than checking for conclusions, here, we assert our expectation that
    the mocked `subscribe` method will receive the exact argument channel only once.
    Mocha expects `mock.verify` to return `true`. To make this test fail, add one
    more `client.subscribe(''channel'')` line, producing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'More information on how to use mocks can be found at: [http://sinonjs.org/releases/v4.1.2/mocks/](http://sinonjs.org/releases/v4.1.2/mocks/).'
  prefs: []
  type: TYPE_NORMAL
- en: Headless testing with Nightmare and Puppeteer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to test whether a UI is working is to pay several people to interact
    with a website via a browser and report any errors they find. This can become
    a very expensive and, ultimately, unreliable process. Also, it requires putting
    potentially failing code into production in order to test it. It's better to test
    whether browser views are rendering correctly from within the testing process
    itself, prior to releasing anything *into the wild*.
  prefs: []
  type: TYPE_NORMAL
- en: A browser, stripped of its buttons and other controls, is at heart a program
    that validates and runs JavaScript, HTML, and CSS, and creates a view. That the
    validated HTML is rendered visually on your screen is simply a consequence of
    humans only being able to see with their eyes. A machine can interpret the logic
    of compiled code and see the results of interactions with that code without a
    visual component. Perhaps, because eyes are usually found in one's head, a browser
    run by machines on a server is typically referred to as a headless browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at two headless browser test automation libraries: **Nightmare**
    ([https://github.com/segmentio/nightmare](https://github.com/segmentio/nightmare))
    and **Puppeteer** ([https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer)).
    Nightmare uses **Electron** as its browser environment, while Puppeteer uses headless
    **Chromium**. They both provide you with a scriptable environment around a browser
    context, enabling various operations on that *page*, such as grabbing a screenshot,
    filling out and submitting a form, or pulling some content from the page based
    on a CSS selector. In keeping with our earlier work, we''ll also learn how to
    use Mocha and Chai to harness these headless browser tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's get familiar with both of these tools, and then look at how they can be
    integrated into your testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: Nightmare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nightmare exposes a very expressive API for working with web content. Let''s
    jump right in with an example Mocha test that validates the document title of
    a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use Mocha's `beforeEach` and `afterEach` to anticipate many test blocks,
    creating a fresh Nightmare instance for each, and automatically cleaning up those
    instances after each test has run via `nightmare.end`. You don't necessarily have
    to do this, but it is a useful *boilerplate*. Nightmare accepts a configuration
    object reflecting Electron's **BrowserWindow** options ([https://github.com/electron/electron/blob/master/docs/api/browser-window.md#new-browserwindowoptions](https://github.com/electron/electron/blob/master/docs/api/browser-window.md#new-browserwindowoptions)),
    and here, we use the `show` attribute, which makes the rendering instance visible—the
    view *pops up* on your screen so that you can watch the page being manipulated.
    Especially with tests where navigation and UI interactions are being made, it
    can be useful to see those manipulations in action. Go ahead and try it here and
    in the tests that follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test is easy to read. Here, we simply head to a URL, fetch the title of
    that page, and run an assertion to test that we have the right title. Note that
    Nightmare is designed to natively work with Promises, and the `Promise` chain
    you see is built on Node-native Promises. If you''d like to use another `Promise`
    library, you can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Interacting with pages is the sine qua non of headless browser testing, letting
    you write UI tests that run automatically. For example, you might want to test
    your application''s login page, or whether a search input returns the right results
    in the right order when submitted. Let''s add another test to this suite, one
    where we search for the Nightmare home page on Yahoo and query the result page
    for the link text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can see how this works. Find the search box on Yahoo's front page using
    a CSS selector, type `'nightmare.js'` into it and click on the Submit button to
    submit the form. Wait for a new element `#main` to show up, indicating that the
    result page has been rendered. We then create an `evaluate` block, which will
    execute within the browser scope. This is a good place to do custom DOM selections
    and manipulations. Here, we find the first link, and check whether it is the one
    we expected. This simple pattern can be easily modified to click links on your
    website to ensure that the links are working, for example, or indeed running several
    selectors over the resulting page to ensure that the right results were delivered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your tests, you may find repeating patterns. Imagine that extracting text
    from links targeted by selector is a common pattern in your tests. Nightmare allows
    you to turn these into custom actions. Let''s create a custom `getLinkText` action
    on Nightmare, and use that in our tests instead. To start—and prior to instantiating
    Nightmare—define a new `action`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, replace the original evaluate instruction with a call to our custom action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We have simply transposed our original instructions to an action block, with
    a custom name and function signature, and called that from our test chain. While
    this example is contrived, it is easy to imagine much more complex actions, even
    a library of them your engineers might draw on as a sort of *programming language*
    for tests. Note that `evaluate_now`, not `evaluate`, is used in the action. Nightmare
    will queue `evaluate` instructions, and since our action has already been queued
    (as part of the original test chain), we want to evaluate the command right now,
    immediately in our action, not requeue it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Nightmare, visit: [https://github.com/segmentio/nightmare#api](https://github.com/segmentio/nightmare#api).'
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Puppeteer is a shiny new Google project focused on creating a browser testing
    API using Chromium engine. The team is aggressively targeting the very latest
    Node versions, taking advantage of all the latest features of the Chromium engine
    (visit: [https://github.com/GoogleChrome/puppeteer/issues/316](https://github.com/GoogleChrome/puppeteer/issues/316)).
    In particular, it is designed to encourage the use of async/await patterns when
    writing your tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the document title example from earlier written using Puppeteer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `async` function wrapper. This pattern is very tight, and given how
    often tests must jump in and out of the browser context, `async`/`await` feels
    like a good fit here. We can also see how much the Puppeteer API was influenced
    by the Nightmare API. Like Nightmare, Puppeteer accepts a configuration object:
    [https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions).
    The equivalent of Nightmare''s `show` is `headless`, which places Chrome into
    headless mode. It might be a good exercise to rewrite the preceding Nightmare
    Yahoo search example in Puppeteer. Full documentation is available at: [https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a Mocha test using Puppeteer to read the NYTimes, intercept image rendering
    calls and cancel them, and then take a screenshot of the image-less page and write
    it to your local filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a PDF, you can just swap out the `screenshot` section with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It is not uncommon for developers to build test suites that take screenshots
    of the same page at various mobile device sizes, even running visual diffs to
    check whether your website is rendering correctly in all (for example, [https://github.com/mapbox/pixelmatch](https://github.com/mapbox/pixelmatch)).
    You might even create a service that selects fragments of several URLs and combines
    them into a single PDF report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navalia is another new framework with an interesting approach to testing with
    the headless Chrome API; you can find it at: [https://github.com/joelgriffith/navalia](https://github.com/joelgriffith/navalia).'
  prefs: []
  type: TYPE_NORMAL
- en: You should now have enough information to start implementing UI tests for your
    applications. Some hypermodern applications even involve running Chromium on AWS
    Lambda (refer to [Chapter 9](c8e13bc3-e661-441c-9fbc-bfdf6019f5f8.xhtml), *Microservices*),
    letting you *farm out* your testing work. Both Nightmare and Puppeteer are modern,
    well-maintained, and document projects that fit very nicely into the Node testing
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's dig a little deeper into how to figure out just what is happening
    *behind the scenes *when a Node process is running, and how to be more surgical
    when testing and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the terrain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Node can also require a more scientific, experimental effort. For example,
    memory leaks are notoriously difficult bugs to track down. You will need powerful
    process profiling tools to take samples, test scenarios, and get a grip on just
    where the problem is coming from. If you are designing a log analysis and summarization
    tool that must crunch through gigabytes of data, you might want to test out various
    parsing algorithms and rank their CPU/memory usage. Whether testing the existing
    processes or being a software engineer, gathering information on resource usage
    is important. What we will look at in this section is how to take data snapshots
    of running processes, and how to draw useful information out of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node already provides some process information natively. Basic tracking of
    how much memory your Node process is using is easy to fetch with `process.memoryUsage()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can build scripts to watch these numbers and, perhaps, emit warnings when
    memory allocation exceeds some predetermined threshold. There are many companies
    that provide such monitoring services, such as **Keymetrics** ([https://keymetrics.io](https://keymetrics.io)),
    the makers and maintainers of PM2\. There are also modules like **node-report** ([https://github.com/nodejs/node-report](https://github.com/nodejs/node-report)),
    which provide a great way to generate system reports whenever your process is
    terminated via process crash, system signal, or other reason. The great module **memeye** ([https://github.com/JerryC8080/Memeye](https://github.com/JerryC8080/Memeye))
    makes it easy to create browser-based dashboards displaying this kind of system
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several native sources of information on Node processes. Visit the
    documentation at: [https://nodejs.org/api/process.html](https://nodejs.org/api/process.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by learning how to gather more extensive memory usage statistics,
    profile running processes, gather key data profiles on how V8 is performing, and
    so on in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Testing processes, memory, and CPU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are native tools for Node, enabling you to profile running V8 processes.
    These are snapshots with summaries that capture statistics on how V8 treated the
    process when compiling, and the sorts of actions and decisions it made while it
    was selectively optimizing the *hot* code as it ran. This is a powerful debugging
    technique when trying to track down the reasons why, for example, a function is
    running slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Any node process can have a a V8 log generated simply by passing the `--prof` (for
    profile) flag. Let's use an example to see how V8 process profiling works. Reading
    a large log file is a sufficiently non-trivial and common task that Node developers
    will come across. Let’s create a log reader and check its performance.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your code bundle, there will be a `logreader.js` file under the `/profiling` directory
    for this chapter. This simply reads the `dummy.log` file also found in the code
    bundle. It’s a good example of how to use a `stream.Transform` to process large
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to note is that the main functions have been named, prefixed
    with $. This is a good practice generally—you should always name your functions,
    and the reason is specifically relevant to debugging. We want those names to show
    up in the reports we’re about to generate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a v8 log, run this script using the `–-prof` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You should now see a V8 log file in the current working directory, named something
    like `isolate-0x103000000-v8.log`. Go ahead and take a look at it—the log is somewhat
    intimidating, but if you do a search for, say, `$reader`, you'll find instances
    of how V8 is recording its structuring of the call stack and compilation work.
    Regardless, this is clearly not meant for humans to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a much more useful summary of this profile by running the following
    command against that log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After a couple of seconds, the process will finish, and a new file, profile,
    will exist in the directory. Go ahead and open that. There is a lot of information,
    and doing a deep dive into what it all means is well beyond the scope of this
    chapter. Nevertheless, you should see that the summary neatly summarizes key V8
    activity, measured with ticks (remember our discussion about the event loop in
    [Chapter 2](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml), *Understanding Asynchronous
    Event-Driven Programming*?). For example, consider this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that `$reader` consumed 8 ticks, was lazy compiled, and was
    optimized (*). If it had not been optimized, it would have been marked with a
    tilde(~). If you see that an unoptimized file was consuming a large number of
    ticks, you'll probably take a look and try to rewrite it in an optimal way. This
    can be a powerful way to "solve" slower parts of your application stack.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping the heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned earlier, a heap is essentially a large allocation of memory, and
    in this specific case, it is the memory allocated to the V8 process. By examining
    where and how memory is being used, you can track down things such as memory leaks,
    or simply find out where the most memory is being used and make adjustments to
    your code, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The de-facto module for taking heap snapshots is `heapdump` ([https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump))
    by *Ben Noordhuis*, a core Node developer since the very beginning of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and install that module and create a new file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Run that file. You will that a file is generated with a name like `1512180093208.heapsnapshot`.
    It's not a human-readable file, but it contains everything you need to reconstruct
    a view on heap usage. You just need the right visualization software. Thankfully,
    you can use the Chrome web browser to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up Chrome DevTools. Go to the Memory tab. You will see an option there
    to Load a heap snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/249e4621-461b-4d75-929b-8aab7bb4b670.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Load the file that you just created (note that it **must** have the `.heapsnapshot` extension).
    Once loaded, click on the heap icon, and you''ll see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c58b06f1-e7a0-4dd4-a6b4-ff0cf3fe1a3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Summary to activate the dropdown, and select Statistics. You''ll now
    see something like the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b9a689f-4679-430d-a0a2-1e14c0eb66e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Becoming familiar with how to read heap dumps is a skill useful to any Node
    developer. For a good intro on how to understand memory allocation, try: [https://developer.chrome.com/devtools/docs/memory-analysis-101](https://developer.chrome.com/devtools/docs/memory-analysis-101).
    The source code to run Chrome DevTools UI is open and free, [https://github.com/ChromeDevTools/devtools-frontend](https://github.com/ChromeDevTools/devtools-frontend),
    as is the protocol itself. Think about how you might take periodic heap dumps
    of running processes and test system health using DevTools, either as we''ve demonstrated
    or via a custom build.'
  prefs: []
  type: TYPE_NORMAL
- en: While we use Chrome in our demonstrations, other tools can *hook into* this
    protocol. Check out [https://nodejs.org/en/docs/inspector/](https://nodejs.org/en/docs/inspector/) and [https://github.com/ChromeDevTools/awesome-chrome-devtools#chrome-devtools-protocol](https://github.com/ChromeDevTools/awesome-chrome-devtools#chrome-devtools-protocol).
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome DevTools have even more functionalities useful to developers. Let's
    take a look at those now.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Node to Chrome DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Chrome Debugging Protocol was recently *integrated* with the Node core ([https://github.com/nodejs/node/pull/6792](https://github.com/nodejs/node/pull/6792)),
    which means that you can now debug a running Node process using Chrome DevTools
    (and other tools). This includes being able to not only watch memory allocation
    but also to gather active feedback on CPU usage, along with directly debugging
    your live code—adding break points and inspecting current variable values, for
    instance. This is an essential debugging and testing tool for the professional
    Node developer. Let's dig into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For demonstration purposes, we''ll create a quick server that performs some
    significant work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `$alloc` and `$serverHandler` named functions; these function names
    will be used to trace our process. Now, we''ll start that server up, but with
    a special `--inspect` flag indicating to Node that we plan to inspect (debug)
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like the debugger is active. To view it, open up a Chrome browser and
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You should see the process you've started listed. You can inspect that process
    or simply load up an active debugging screen by clicking on Open dedicated DevTools
    for Node, which will, from now on, attach to any Node process you start with `--inspect`.
  prefs: []
  type: TYPE_NORMAL
- en: CPU profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open up another browser window and navigate to our test server at `localhost:8080`.
    You should see I'm done displayed (if not, go back and start up `server.js`, as
    instructed earlier). Keep that open; you'll be reloading this page shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Memory in the debugger UI, and you'll see the interface from earlier.
    This is the *standalone* version of the debugger we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click on Profiler, which is the interface to debug CPU behavior (execution
    time in particular), and click on Start. Go back to your browser and reload the
    I''m done page a few times. Return to the debugger and click on Stop. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e807cf50-37d7-4bb0-83fe-98b03f61c73e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the three larger *blocks*, which were generated by three runs of our server
    handler. Using your mouse, select one of these blocks and zoom in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95871298-4bd1-4a04-a930-08badabaf7f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we see a full breakdown of V8 activity engaged when handling our request.
    Remember `$alloc`? By mousing over its timeline, you can inspect the total CPU
    time it consumed. If we zoom in to the send section in the bottom-right, we can
    also see that it took our server 1.9 ms to execute an HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1cc07bd-0a5d-4761-b1bb-dac482f2f154.png)'
  prefs: []
  type: TYPE_IMG
- en: Play around with this interface. In addition to helping you find and debug the
    slower parts of your application, when developing tests, you can use this tool
    to create a mental map of what the expected behavior of a *normal* run is, and
    design health tests. For example, one of your tests might call a specific route
    handler and pass or fail based on some predetermined maximum execution time threshold.
    If these tests are *always on*, probing your live application periodically, they
    might even trigger automatic throttling behaviors, log entries, or the sending
    of urgent emails to your engineering team.
  prefs: []
  type: TYPE_NORMAL
- en: Live debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps, the most powerful feature of this interface is its ability to directly
    debug running code, and to test the state of live applications. Click on the Sources tab
    in the debugger. This is an interface to the actual *scripts* comprising the Node
    process. You should see the *mounted* version of our `server.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04271b8b-7ec7-4c54-9066-777b61b9e09f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fun fact: here, you can see how Node actually wraps your modules so that the
    global `exports`, `require`, `module`, `__filename`, and `__dirname` variables
    are available to you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set a break point on line 11\. Just click on the number; you should
    see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d1e61e6-7b08-4c4d-8a76-41ccb91d82b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Recall our discussion about the Node debugger earlier? The same principles will
    apply here; we'll be able to use this interface to step through executing code,
    stopping execution periodically, and examining application state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let''s cause this code to be executed in our server. Go back
    to your browser and reload `localhost:8080`, calling the route and ultimately
    hitting the break point you just set. The debugger interface should pop up, and
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b86f93b5-59e6-4931-9dca-859e587007b5.png)'
  prefs: []
  type: TYPE_IMG
- en: In addition to clearly indicating where we are (the line number, within the
    `$serverHandler` function), the interface is also usefully showing us the value
    of `d` in the current iteration of a `while` loop. Recall our Node debugger discussion
    earlier? The same principles apply here. If you hover over the debugging control
    icons on the right, you'll see that the second one is the *step over* function.
    We're in a loop; let's step to the next iteration. Go ahead and hit step over
    the loop several times. Did you note how the value of d is being updated while
    you step through this loop?
  prefs: []
  type: TYPE_NORMAL
- en: If you explore the interface on the right, you can dig very far into the current
    state of the program, with a full breakdown of all scope variables, globals being
    referenced, and so forth. By using the *step into* control, you can watch the
    progress of every single request through the execution stack, walking through
    the Node runtime as it executes. You will benefit from this exercise and understand
    your code (and how Node works) much more clearly. This will help you become a
    better test writer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usefully, there is a chrome plugin that makes interacting with inspected Node
    processes as simple as point and click; it''s available at: [https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mathias Buus* has created an interesting tool, providing very useful debugging
    information for the rare but hair-pulling case of processes not ending when they
    are supposed to, and you can find it at: [https://github.com/mafintosh/why-is-node-running](https://github.com/mafintosh/why-is-node-running).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Matteo Collina''s* excellent `loopbench` ([https://github.com/mcollina/loopbench](https://github.com/mcollina/loopbench))
    and its packaged version for Node servers ([https://github.com/davidmarkclements/overload-protection](https://github.com/davidmarkclements/overload-protection))
    can be used to not only provide testing and debugging information, but for the
    development of smart, self-regulating servers than will automatically shed (or
    redirect) loads when running too hot, a nice feature in a distributed application
    architecture of independent, networked nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Node community has embraced testing from the beginning, and many testing
    frameworks and native tools are made available to developers. In this chapter,
    we examined why testing is so important to modern software development as well
    as something about functional, unit, and integration testing, what they are, and
    how they can be used. With the vm module, we learned how to create special contexts
    for testing JavaScript programs, and picking up some techniques for sandboxing
    untrusted code along the way.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we learned how to work with the extensive set of Node testing and
    error-handling tools, from more expressive console logging to Mocha and mocking
    with Sinon, onto one line tracing and debugging heaps and live code. Finally,
    we learned about two different headless browser testing libraries, learning two
    ways in which such testing might be done in each, and how these virtual browsers
    can be integrated with other testing environments.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can test your code, go out and experiment with the power of Node.
  prefs: []
  type: TYPE_NORMAL
