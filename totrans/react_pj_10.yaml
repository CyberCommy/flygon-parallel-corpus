- en: Creating a Real-Time Messaging Application with React Native and Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a real-time connection with a server is crucial when you're developing
    a real-time messaging application as you want your users to receive their messages
    as soon as they are sent. What you might have experienced in the previous two
    chapters is that mobile applications are more intuitive to use than web applications.
    When you want users to send messages back-and-forth, this is best done by building
    a mobile application, which you'll do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll create a real-time mobile messaging application using
    React Native and Expo that connects with a GraphQL server. By using WebSockets,
    you can create real-time connections with a server for web and mobile applications
    and have a two-way data flow between your application and a GraphQL server. This
    connection can also be used for authentication by using OAuth and JWT tokens,
    which is what you did in the [Chapter 7](ab243538-4b30-452f-8d9f-f80c648a6758.xhtml),
    *Build a Full Stack E-Commerce Application with React Native and GraphQL*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL with React Native using Apollo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication flows in React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL subscriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a mobile messaging application build with React
    Native and Expo that uses a GraphQL server for authentication and to send and
    receive messages. Messages can be received in real-time as GraphQL subscriptions
    are used through a WebSocket that was created with Apollo. Users need to be logged
    in to send messages through the application, for which an authentication flow
    was built using React Navigation and AsyncStorage to store authentication details
    in persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch10-initial](https://github.com/PacktPublishing/React-Projects/tree/ch10-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch10](https://github.com/PacktPublishing/React-Projects/tree/ch10)[.](https://github.com/PacktPublishing/React-Projects/tree/ch9)
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to have the application Expo Client installed on a mobile iOS or Android
    device to run the project on a physical device. Alternatively, you can install
    either Xcode or Android Studio on your computer to run the application on a virtual
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/).
    There''s a known issue when running the emulator, which can be prevented by ensuring
    that the following lines are present in your `~/.bash_profile` or `~/.bash_rc`  file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value for `ANDROID_SDK_LOCATION` is the path to the Android SDK on your
    local machine and can be found by opening Android Studio and going to **Preferences** | **Appearance
    & Behavior** *|* **System Settings** | **Android SDK**. The path is listed in
    the box that states the Android SDK locationand looks like this: `/Users/myuser/Library/Android/sdk`.
  prefs: []
  type: TYPE_NORMAL
- en: This application was created using **Expo SDK version 33.0.0,** and so, you
    need to ensure that the version of Expo you're using on your local machine is
    similar. As React Native and Expo are frequently updated, make sure that you're
    working with this version so that the patterns described in this chapter behave
    as expected. In case your application doesn’t start or if you encounter errors,
    refer to the Expo documentation to learn more about updating the Expo SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out the initial project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This project consists of two parts: a boilerplate React Native application
    and a GraphQL server. The React Native application can be found in the `client` directory,
    while the GraphQL server can be found in the `server` directory. For this chapter,
    you''ll need to have both the application and the server running at all times,
    where you''ll only make code changes to the application in the `client` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with this chapter, you''ll need to run the following command
    in the `client` and `server` directories in order to install all of the dependencies
    and start both the server and the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the mobile application, this command will start Expo after installing the
    dependencies and gives you the ability to start your project from the Terminal
    or from your browser. In the Terminal, you can either use the QR code to open
    the application on your mobile device or open the application on a virtual device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of whether you''ve opened the application using the from a physical
    or virtual iOS or Android device, the application should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8dab731f-78bf-46e1-8bdf-21b18befa226.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The initial application consists of five screens: `AuthLoading`, `Conversations`, `Conversation`,
    `Login`, and `Settings`. The `Conversations` screen will be the initial screen
    and shows a loading message, while the `Settings` screen contains a non-functioning
    logout button. For now, the `AuthLoading`, `Conversation`, and `Login` screens
    aren''t visible yet as you''ll add the routing to these screens later on in this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure from this React Native application in the `client` directory
    is as follows, where the structure is similar to the projects you''ve created
    before in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the `assets` directory, you can find the images that are used for the application
    icon on the Home screen. Once you've installed this application on your mobile
    device, the image that will serve as the splash screen will be displayed when
    you start the application. Details about your application such as its name, description,
    and version are placed in `app.json`, while `babel.config.js` holds specific Babel
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The `App.js` file is the actual entry point of your application, where the `AppContainer.js` file is
    being imported and returned. In `AppContainer`, all of the routes for this application
    are defined and `AppContext` will contain information that should be available
    in the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the components for this application are located in the `Screens` and `Components` directories,
    where the first one holds the components that are rendered by the screens. The
    child components for these screens can be found in the `Components` directory, which
    has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The GraphQL server can be found at: `http://localhost:4000/graphql` and is where
    the GraphQL Playground will be visible. From this playground, you can view the
    schema for the GraphQL server and introspect all of the available queries, mutations,
    and subscriptions. Although you won't be making any code changes to the server,
    it's important to know about the schema and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The server has two queries to retrieve a list of conversations or a single conversation
    by using the `userName` parameter as the identifier. These queries will return
    the `Conversation` type, which has an `id`, `userName`, and a list of messages
    of the `Message` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'On this GraphQL server, two mutations can be found, which are to either log
    the user in or to send a message. The user can be logged in by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Username**: `test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**: `test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there's one subscription that will retrieve messages that are added
    to the conversation. This subscription will enhance the query and can be sent
    in a document to retrieve a single conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a real-time messaging application with React Native and Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons why mobile applications are popular is because they usually
    provide real-time data, such as updates and notifications. With React Native and
    Expo, you can create mobile applications that can handle real-time data using
    WebSockets that synchronize with, for example, a GraphQL server. In this chapter,
    you'll add GraphQL to a React Native application and add extra features to this
    application to make it work with real-time data.
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphQL in React Native with Apollo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](https://cdp.packtpub.com/react_projects_/wp-admin/post.php?post=33&action=edit#post_30), 
    *Build a Full Stack E-Commerce Application with React Native and GraphQL*, you've
    already set up a connection with the GraphQL server for a web application; similarly,
    in this chapter, you'll use a GraphQL server for the data in your mobile application.
    To use GraphQL in a React Native application, you can use Apollo to make the experience
    of developers smoother.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Apollo in React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `react-apollo` package, which you've already used for Apollo in a React
    web application, can also be used for Apollo in a React Native mobile application.
    This fits perfectly with the tagline of React and React Native: *learn once, write
    everywhere*. But before we add Apollo to the application, it's important to know
    that when you run your application using the Expo application on your mobile,
    localhost requests aren't supported. The local GraphQL server for this project
    is running on `http://localhost:4000/graphql`, but to be able to use this endpoint
    in the React Native application, you need to find the local IP address of your
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find your local IP address, you''ll need to do the following depending on
    your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For Windows**: Open the Terminal (or command prompt) and run this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a list, as follows, with data from your local machine. In
    this list, you need to look for the field **IPv4 Address**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0033c76-9caf-4443-9f99-328624f755e8.png)'
  prefs: []
  type: TYPE_IMG
- en: '**For macOS**: Open the Terminal and run this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this command, the local `Ipv4 Address` of your machine gets returned,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting the local IP address, you can use this address to set up the
    Apollo client for the React Native application. To be able to use Apollo and GraphQL,
    you need to install several packages from `npm` using `npm` with the following
    command. You need to do this from the `client` directory in a separate Terminal
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the `App.js`, file, you can now use `apollo-client` to create your GraphQL
    client using `apollo-link-http` to set up the connection with the local GraphQL
    server and `apollo-cache-inmemory` to cache your GraphQL requests. Also, the `ApolloProvider` component
    will use the client you've created to make the GraphQL server available to all
    of the components that are nested within this Provider. The local IP address must
    be used to create the value for `API_URL` with the prefix `http://` and suffix
    `:4000/graphql` that points towards the correct port and endpoint, making it look
    like `http://192.168.1.107:4000/graphql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, add the following lines to `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, you're able to send documents with queries and mutations from any of the
    components nested within `ApolloProvider`, but you aren't able to send subscriptions
    in your documents yet. Support for subscriptions doesn't come out of the box and requires
    setting up a WebSocket for a real-time two-way connection between the client React
    Native application and the GraphQL server. This will be done later on in this
    chapter, after you've added authentication to the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of this section, you'll use Apollo to get the data from the
    GraphQL server that you just linked to the Apollo Client in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Apollo in React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look at the application, you will see there are two tabs; one is showing
    the `Conversations` screen and the other is showing the `Settings` screen. The
    `Conversations` screen is now displaying the text `Loading...`, where the conversations
    that were returned from the GraphQL server should be shown. The components to
    display the conversations have already been created and can be found in the `client/Components/Conversation` directory,
    while the logic to request the conversations still needs to be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Apollo, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to import the `Query` component from `react-apollo` into
    the `client/Screens/Conversations.js` file, which you''ll use to send a document
    to the GraphQL server. This `Query` component will use the `GET_CONVERSATIONS` query and
    the `ConversationItem` component must be imported as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Conversations` screen should now request the `GET_CONVERSATIONS` query using
    the `Query` component. When the request hasn''t been resolved, a loading message
    will be displayed. When the request to the GraphQL server is resolved, a styled
    `Flatlist` will return a list of the imported `ConversationItem` components. The
    styled `Flatlist` has already been created and can be found as the `ConversationsList` component at
    the bottom of this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Conversations` screen initially shows the loading message when the document
    with the query is sent; after the query has returned data, the `ConversationsList`
    component will be displayed. This component renders `ConversationItem` components
    that display the data from the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you try to click on any of the conversations, nothing will happen, except
    that you''ll see a small animation that changes the opacity. This is because the
    `ConversationItem` component is a styled `TouchableOpacity`, which can be passed
    as a function that is called when you tap it. The function to navigate to the
    conversation can be created from the `navigation` prop, which is available in
    the `Conversations` screen. This prop should be passed as a prop to `ConversationItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConversationItem` component can now navigate to the `Conversation` screen
    when `TouchableOpacity` is being tapped; this component can be found in the `client/Components/Conversation/ConversationItem.js` file,
    where the `navigation` prop should be destructured and used to call the `navigate` function
    on the `onPress` handler. This item is passed with the `navigate` function so
    that this data can be used in the `Conversation` screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This navigates to the `Conversation` screen from the `client/Screens/Conversation.js` file,
    where the full conversation should be displayed. To display the conversation,
    you can either use the item data that was just passed to this screen or send another
    document to the GraphQL server that contains the query to retrieve the conversation.
    To make sure the most recent data is displayed, the `Query` component can be used
    to send a query to retrieve the conversation using the `userName` field from the
    `navigation` prop. To do this, you need to import the `Query` component, the `GET_CONVERSATION` query that
    is used by `Query`, and the `Message` component to display the messages from the
    conversation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can add the `Query` component to the `Conversation` screen
    and have it use the `GET_CONVERSATION` query with `userName`, which was retrieved
    from the `navigation` prop. Once the query resolves the `Query` component returns
    a `data` object with a field called `messages`. This value can be passed to a
    `FlatList` component. In this component, you can iterate over this value and return `Message`
    components that display all of the messages from the conversation. `FlatList`
    is already styled and can be found at the bottom of the file as `MessagesList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All of the received messages from this conversation are now being displayed
    and, using the form at the bottom of this screen, a new message can be added to
    the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the device that you''re running the application on, the `Conversation`
    and `Conversation` screens should look something like this on a device running
    on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d97e780f-273a-4650-8f51-317bc80ce117.png)'
  prefs: []
  type: TYPE_IMG
- en: However, to send a message, a document with a mutation should be sent to the
    GraphQL server and, to do so the user must be authenticated. How to handle authentication
    for this mutation will be addressed in the next section, where the authentication
    flow will be added.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication in React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, authentication for mobile applications is similar to how you would
    handle authentication in web applications, although there are some minor differences.
    The flow for authenticating a user on a mobile application would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user opens your application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A loading screen is shown that checks for any authentication information in
    the persistent storage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If authenticated, the user will be forwarded to the main screen for the application;
    otherwise, they will be forwarded to the login screen, where the user can log
    in
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever the user signs out, the authentication details will be removed from
    the persistent storage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the biggest caveats of this flow is that the mobile device doesn't support
    local storage or session storage as these persistent storage solutions are tied
    to the browser. Instead, you'd need to use the `AsyncStorage` library from React
    Native to have persistent storage on both iOS and Android. On iOS, it will use
    native code blocks to give you the global persistent storage that `AsyncStorage` offers,
    while on devices running Android, either RockDB- or SQLite-based storage will
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex usages, it's recommended to use an abstraction layer on top
    of `AsyncStorage` as encryption isn't supported out of the box by `AsyncStorage`.
    Also, the use of a key-value system can give you performance issues if you want
    to store a lot of information for your application using `AsyncStorage`. Both
    iOS and Android will have set limitations on the amount of storage each application
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with React Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up the authentication flow we described earlier, you'll use the React
    Navigation package again. Previously, you used the different types of navigators
    from React Navigation, but not `SwitchNavigator`. With this navigator type, you
    can only display one screen at once, and you can navigate to other screens using
    the `navigation` prop. `SwitchNavigator` should be the main navigator of your
    application and other navigators such as `StackNavigator` can be nested inside
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding authentication to the React Native application involves performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to using this navigator type is importing `createSwitchNavigator` from `react-navigation`,
    just like you imported the other navigators into the `client/AppContainer.js` file.
    Also, import the screen component for the login screen, which can be found at `client/Screens/Login.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of wrapping `TabNavigator` at the bottom of this file with `createAppContainer`,
    you need to return `SwitchNavigator` instead. To create this, you need to use `createSwitchNavigator`, which
    you imported in the previous step. This navigator contains the `Login` screen
    and `TabNavigator`, which is the main screen for this application. For the user
    to only see the main screen when authenticated, the `Login` screen needs to be
    the initial screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Login` screen that is now displayed in the application will only switch
    to `TabNavigator` when the correct authentication details are filled in.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this form needs to be connected to the GraphQL server first to receive
    the JWT token that is needed for authentication. The component for the `Login` screen
    already has a form, but submitting this form doesn''t call any function to authenticate
    the user yet. Therefore, you need to use a `Mutation` component from `react-apollo` and
    have this component send a document with the correct mutation to the GraphQL server. The
    mutation that needs to be added to this component can be found in the `constants.js` file and
    is called `LOGIN_USER`. To submit the form, the `loginUser` function that is returned
    by the `Mutation` component should be called when the user presses `Button`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `TextInput` components are controlled component, and use `useState` Hooks
    to control their values. Both the `userName` and `password` constants that are
    used by this mutation take two variables for authentication, which are also `userName` and `password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the `loginUser` function, which sends the mutation in a document,
    the `Mutation` component will also return the `loading`, `error`, and `data` variables
    that are returned by the GraphQL server. The `loading` variable can be used to
    communicate to the user that the document was sent to the server, while the `data`
    and `error` variables are returned when the GraphQL server responds to this document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will change the text of the button at the bottom of the form to `Loading...` when
    the document is sent to the GraphQL server and no response has been returned yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `error` variable to show an error message when the wrong credentials
    have been filled in, you won''t be destructuring the variable from the output
    of the `Mutation` component. Instead, the error variable will be retrieved from `Promise`
    that is returned by the `loginUser` function. For displaying the error, you''ll
    use the `graphQLErrors` method that is available from the `error` variable, which
    returns an array (since there could be multiple errors) and renders the error
    within an `Alert` component from React Native:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the right username and password combination are used, the data variable
    should be used to store the JWT token that will be returned by the GraphQL server.
    Just like the `error` variable that was retrieved from the `loginUser` function,
    the `data` variable can be retrieved from this `Promise` as well. This token is
    available on the `data` variable and should be stored somewhere safe, which can
    be done using the `AsyncStorage` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After storing the token, the user should be redirected to the main application,
    which can be found at the `Main` route and represents the screens linked to `TabNavigator`.
    To redirect the user, you can use the `navigation` prop that is passed to the
    `Login` component by `SwitchNavigator`. Since storing something with `AsyncStorage` should
    be done asynchronously, the navigation function should be called from within the
    callback of `Promise` that is returned by `AsyncStorage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This, however, only completes a part of the authentication flow since the `Login`
    screen will always be displayed when the application first renders. That way,
    users always have to log in with their authentication details, even when their
    JWT token is stored in the persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether or not the user has logged in before, a third screen has to
    be added to `SwitchNavigator`. This screen will determine whether the user has
    a token stored in the persistent storage and if they do, the user will be redirected
    to the `Main` route immediately. If the user hasn''t logged in before, the user
    will be redirected to the `Login` screen you''ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This intermediate screen that determines whether there is an authentication
    token stored in the persistent storage, that is the `AuthLoading` screen, should
    be added to `SwitchNavigator` in `App.js`. This screen should also become the
    initial route that is served by the navigator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `AuthLoading` screen, the authentication token should be retrieved
    from the persistent storage, and afterward, the navigation to either the `Login`
    or `Main` screen should be handled. This screen can be found in the `client/Screens/AuthLoading.js` file, where
    nothing but a simple interface has been added. The token can be retrieved using
    the `getItem` method from the `AsyncStorage` library and should be called from
    a `useEffect` Hook so that it''s retrieved when the `AuthLoading` screen is first
    loaded. From `callback`, and from `Promise` returned by `getItem`, the `navigate`
    function from the `navigation` prop is used for the actual navigation to either
    of these screens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The final step in completing the authentication flow is adding the possibility
    for a user to log out of the application by deleting the token from the persistent
    storage. This is done in the `client/Screens/Settings.js` file. This renders the
    `Settings` screen that can be found in `TabNavigator`. The `Settings` screen has
    a green button, which you can set an `onPress` event on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `removeItem` method from `AsyncStorage` can be used for deleting the token
    from the persistent storage and returns `Promise`. In the callback of this `Promise`,
    you can again handle the navigation to return to the `Login` screen as you don''t
    want an unauthenticated user in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the logout functionality, you''ve completed the authentication flow
    that uses JWT tokens returned by the GraphQL server. This can be requested by
    filling in a form on the `Login` screen. If the authentication is successful,
    the user will be redirected to the `Main` screen and, by using the Log out button
    on the `Settings` screen, the user can log out and will be directed back to the
    `Login` screen. The final authentication flow will now look something like this,
    depending on which operating system you''re running this application on. The following
    screenshots have taken taken from a device that''s running on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/22c6656d-d2d5-4501-b80f-804de21ebd29.png)'
  prefs: []
  type: TYPE_IMG
- en: However, for the GraphQL server to know whether this user is authenticated,
    you need to send a validation token to it. In the next part of this section, you'll
    learn how to do this by using a **JSON Web Token** (**JWT**).
  prefs: []
  type: TYPE_NORMAL
- en: Sending authentication details to the GraphQL server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The authentication details that are now stored in the persistent storage should
    also be added to the Apollo Client so that they''re sent to the GraphQL server
    with every document. This can be done by extending the setup of Apollo Client
    with the token information. since the token is a JWT, it should be prefixed with
    `Bearer`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to install an Apollo package to deal with adding values to `context`.
    The `setContext` method is available from the `apollo-link-context` package, which
    you can install from `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apollo-link-context` package should be imported into the `client/App.js` file,
    where the Apollo client is created. You need to separate the construction of the `HttpLink` object
    for the client as this one needs to be combined with the created Context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can use the `setContext()` method to extend the headers that
    are being sent to the GraphQL server so that you can also include the token that
    can be retrieved from the persistent storage. This method should be used asynchronously
    as getting an item from `AsyncStorage` is also asynchronous. The token that will
    be returned must be prefixed with `Bearer` as the GraphQL server expects the JWT
    token in that format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `httpLink` that is used for the `link` field when creating the Apollo Client
    should now be combined with `authLink` so that the token that is retrieved from
    `AsyncStorage` will be added to the headers when the request is sent to the GraphQL
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, any document is passed to the GraphQL server will be able to use the token
    that was retrieved by using the login form of your application—something that
    you'll need when a mutation is used to send a message in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling subscriptions in React Native with Apollo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can proceed and send documents containing mutations to the GraphQL
    server, we need to set up Apollo so that we can handle subscriptions. For handling
    subscriptions, a WebSocket needs to be set up for your application, which enables
    a real-time two-way connection between the GraphQL server and your application.
    That way, you'll receive instant feedback when you, for example, send or receive
    a message using this mobile application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Apollo Client for GraphQL subscriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use subscriptions in your React Native application, there are more packages
    you need to add to the project that, for example, make it possible to add the
    WebSocket. These packages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `apollo-link-ws` package helps you create a link to the GraphQL server running
    the subscription, like `apollo-link-http` does for queries and mutations. `subscriptions-transport-ws` is
    a package that is needed to run `apollo-link-ws`, while `apollo-utilities` is
    added to use a method that is available on those packages so that you can separate
    requests regarding subscriptions from requests for queries or mutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing these packages, you need to follow these steps to use subscriptions
    in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the creation of the link to the GraphQL server using `apollo-link-ws`.
    The URL to the GraphQL server should be prefixed with `ws://` instead of `http://` as
    it concerns a connection with a WebSocket. The URL to the GraphQL server running
    on your machine would look like `ws://192.168.1.107/graphql` instead of `http://192.168.1.107/graphql` and
    must be added to the `SOCKET_URL` constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `split` and `getMainDefinition` methods, the distinction between
    different requests to the GraphQL server can be made by separating queries and
    mutations from subscriptions. That way, only documents containing subscriptions
    will be sent using the WebSocket, and queries and mutations will use the default
    flow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The setup for Apollo now also supports subscriptions, which you'll add in the
    next part of this section where the `Conversations` screen will be filled with
    real-time data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding subscriptions to React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The local GraphQL server that is running on your machine supports both a query
    and a subscription so that you can return a conversation from a specific user.
    Where the query will return the full conversation, the subscription will return
    any new message that may have been sent or received in that conversation. At the
    moment, the `Conversation` screen is only sending a document with the query that
    will return the conversation with a user if you tap on any of the conversations
    displayed on the `Conversations` screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subscriptions can be added to your application in multiple ways; using the
    `Subscription` component from `react-apollo` is the most simple one. But since
    you''re already retrieving the conversation using the `Query` component in `client/Screens/Conversation.js`,
    the `Query` component can be extended to also support subscriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in adding the subscriptions to the `Conversation` screen is
    by splitting the screen into multiple components. You can do this by creating
    a new component called `ConversationBody` in the `client/Components/Conversation` directory.
    This file should be called `ConversationBody.js` and contain the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating this new component, it should be imported into the `Conversation`
    screen in the `client/Screens/Conversation.js` file, where it can replace the
    `ContainerBody` component that is already present in that file. This also means
    that some imports become obsolete and that the `ContainerBody` styled component
    can be deleted as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the logic for retrieving the subscription can be added to the `Query`
    component, by getting the `subscribeToMore` method from it. This method should
    be passed to the `ConversationBody` component, where it will be called and thereby
    retrieve any new messages that are sent or received in the conversation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ConversationBody` component, the `subscribeToMore` method can now be
    used to retrieve any new messages that are added to the conversation, by using
    a subscription. The subscription to use is called `MESSAGES_ADDED` and can be
    found in the `client/constants.js` file. It takes `userName` as a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the subscription and destructuring the `subscribeToMore` method
    from the props, the logic for retrieving the subscription can be added. Calling `subscribeToMore`
    should be done from a `useEffect` Hook and only when the `ConversationBody` component
    first mounts. Any newly added messages will cause the `Query` component to rerender,
    which makes the `ConversationBody` component rerender as well, so it isn''t necessary to
    check for any updates in the `useEffect` Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `subscribeToMore` method will now check for any new messages by using the `MESSAGES_ADDED` subscription,
    and the results from that subscription will be added to the `Query` component
    on an object called `previous`. The local GraphQL server will return a new message
    every few seconds, so you can see that the subscription is working by opening
    a conversation and waiting for new messages to appear in that conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Besides queries, you also want to be able to send real-time subscriptions as
    well. This will be addressed in the final part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using mutations with subscriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from using a subscription to receive messages in a conversation, they
    can also be used to display the messages you send yourself. Previously, you used
    the `refetchQueries` prop on a `Mutation` component to resend documents with any
    queries that would have been affected by the mutation you've executed. By using
    subscriptions, you no longer have to refetch, for example, the conversation query,
    as the subscription will get the new message you've just sent and add it to the
    query.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, you used a `Query` component from `react-apollo` to
    send a document to the GraphQL server, while in this section, the new React Apollo
    Hooks will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The React Apollo Hooks can be used from the `react-apollo` package, but if you
    only want to use the Hooks, you can install `@apollo/react-hooks` instead by executing `npm
    install @apollo/react-hooks`. The GraphQL components such as `Query` or `Mutation`
    are available in both the `react-apollo` and `@apollo/react-components` packages.
    Using these packages will decrease the size of your bundle as you're only importing
    the features you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Hooks from this package must be used in the `ConversationActions` component.
    This is used in the `Conversation` screen component, which will consist of the
    input field to type a message and a button to send the message. When you press
    this button, nothing will happen as the button isn''t connected to a mutation.
    Let''s connect this button and see how the subscription will also display the
    message you''ve sent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useMutation` Hook should be imported into the `client/Components/Conversation/ConversationActions.js` file,
    which will be used to send the message from the input field to the GraphQL server.
    The mutation that will be included in the document that you sent must also be
    imported and is called `SEND_MESSAGE`; this can be found in the `client/constants.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This `useMutation` Hook can now be used to wrap the `TextInput` and `Button`
    components, and the `sendMessage` prop from the Hook can be used to send a document
    with the message to the GraphQL server. The value for `TextInput` is controlled
    by the `setMessage` function that was created by the `useState` Hook, and this
    function can be used to clear `TextInput` after the mutation is sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Sending a message by typing a value into the text field and pressing the send
    button afterward will now update the conversation with the message you've just
    sent. But you might notice that this component is getting lost behind the keyboard,
    depending on the size of the screen of your mobile device. This behavior can easily
    be avoided by using the `KeyboardAvoidingView` component from `react-native`.
    This component will make sure that the input field is being displayed outside
    the area of the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `KeyboardAvoidingView` component can be imported from `react-native` and
    used to replace the `View` component that is currently being styled into the `ConversationsActionsWrapper`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on which platform your mobile device is running on, the `KeyboardAvoidingView`
    component still might not display the input field outside the keyboard area. However,
    the `KeyboardAvoidingView` component can be customized using the `keyboardVerticalOffset`
    and `behavior` props. For iOS and Android, the values for these props should be
    different; in general, Android needs a smaller offset than iOS. In this situation,
    `keyboardVerticalOffset` must be set to `190` for iOS and to `140` for Android,
    and the `behavior` of the component for both platforms must be set to `padding`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`KeyboardAvoidingView` might not work as expected on the Android Studio emulator
    or on devices running Android, as there are a lot of different possible screen
    sizes for devices that can run the Android operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: When you press the input field, the keyboard will no longer be hidden behind
    the keyboard and you should be able to type and send a message that will send
    a document with a mutation to the GraphQL server. Your message will also appear
    in the conversation that was being displayed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you built a mobile messaging application that can be used to
    send and receive messages from a GraphQL server. The messages are received in
    real time as GraphQL subscriptions were used to receive the messages through a
    WebSocket. Also, a mobile authentication flow was added, meaning users should
    be logged in to send and receive messages. For this, `AsyncStorage` was used to
    store the JWT token returned by the GraphQL server in persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: The project you've built in this chapter was pretty challenging, but the project
    you'll create in the next chapter will be even more advanced. So far, you've handled
    most of the core features for a React Native mobile application, but there's more
    to come. The next chapter will explore how to build a full stack application with
    React Native and GraphQL as you'll be adding notifications and more to a social
    media application.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about what was covered in this chapter, check out the
    following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets: [https://developer.mozilla.org/en-US/docs/Web/API/WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apollo React Hooks: [https://www.apollographql.com/docs/react/api/react-hooks/](https://www.apollographql.com/docs/react/api/react-hooks/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
