- en: Chapter 5. Security and Traceability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Security** is one of the biggest concerns in systems nowadays. The amount
    of information leaked from big companies is worrying, especially because 90% of
    the information leaks could be mended with very small actions by the software
    developers. Something similar happens with the logging of events and the traceability
    of errors. No one really pays too much attention until someone requests the logs
    that you don''t have in order to audit a failure. In this chapter, we will discuss
    how to manage security and logging so that our system is safe and traceable, with
    the help of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure logical security**: We will discuss how to secure our software
    infrastructure in order to provide the industry standard security layer in our
    communications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application security**: We will introduce the common techniques to secure
    our applications. Practices such as output encoding or input validation are the
    industry standard and they could save us from a catastrophe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traceability**: Being able to follow the requests around our system is a
    must in microservices architectures. We will leverage this task to Seneca and
    learn how to get the information from this fantastic framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auditing**: Even though we put our best efforts in building a software, accidents
    happen. The ability to rebuild the sequence of calls and see exactly what happened
    is important. We will discuss how to enable our system in order to be able to
    recover the required information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure logical security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infrastructure security is usually ignored by software engineers as it is completely
    different from their area of expertise. However, nowadays, and especially if your
    career is leaning towards DevOps, it is a subject that should not be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are not going to go very deep into the infrastructure security
    more than few rules of thumb to keep your microservices safe.
  prefs: []
  type: TYPE_NORMAL
- en: It is strongly recommended for the readers to read and learn about cryptography
    and all the implications around the usage of SSH, which is one of the main resources
    for keeping communications secure nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: SSH – encrypting the communications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any organization, there is a strict list of people who can access certain
    services. In general, this authentication for these services is done via username
    and password, but it can also be done using a key to *verify the identity of the
    user*.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what authentication method is used, the communication should always
    be done over a secure channel such as **SSH**.
  prefs: []
  type: TYPE_NORMAL
- en: '**SSH** stands for **Secure Shell** and it is a software used to access shells
    in remote machines, but it can also be a very helpful tool to create proxies and
    tunnels to access remote servers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain how it works using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I am using **Vagrant** to facilitate the building of virtual machines.
    Vagrant is a very popular tool to automate development environments and their
    website ([https://www.vagrantup.com/](https://www.vagrantup.com/)) consists of
    useful information.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, we execute the `ssh david@192.168.0.1` command. This command
    tries to open a terminal as the user `david` in the `192.168.0.1` host.
  prefs: []
  type: TYPE_NORMAL
- en: As it is the first time that this command is executed against the machine in
    the IP `192.168.0.1`, our computer will not trust the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by maintaining a file called `known_hosts`, under the `/home/david/.ssh/known_hosts`
    folder in this case (it will depend on the user).
  prefs: []
  type: TYPE_NORMAL
- en: 'This file is a list of hosts with the corresponding key. As you can see, the
    following two lines explain that the *host cannot be trusted* and present the
    fingerprint of the key held by the remote server in order to verify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the user is supposed to verify the identity of the server by
    checking the key. Once this is done, we can instruct SSH to connect to the server,
    which will result in the following log being printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we check our `known_hosts` file, we can see that the key has been added
    to the list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SSH – encrypting the communications](img/B04889_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This key stored in the `known_hosts` file is the public key of the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH uses a **cryptography algorithm** called **RSA**. This algorithm is built
    around the concept of **asymmetric cryptography**, which is shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SSH – encrypting the communications](img/B04889_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The asymmetric cryptography relies on a set of keys: one public and one private.
    As the name states, the public key can be shared with everyone; whereas, the private
    key has to be kept secret.'
  prefs: []
  type: TYPE_NORMAL
- en: The messages encrypted with the private key can only be decrypted with the public
    key and the other way around so that it is almost impossible (unless someone gets
    the other half of the key) to intercept and decrypt a message.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our computer knows the public key of the server and we are in
    a position to start an encrypted session with the server. Once we get the terminal,
    all the commands and results of these commands will be encrypted and sent over
    the wire.
  prefs: []
  type: TYPE_NORMAL
- en: This key can also be used to connect to a remote server without password. The
    only thing we need to do is generate an SSH key in our machine and install it
    in the server in a file called `authorized_keys` under the `.ssh` folder, where
    the `known_hosts` file is.
  prefs: []
  type: TYPE_NORMAL
- en: When working with microservices, you can be remotely logged in to quite a few
    different machines so that this approach becomes more attractive. However, we
    need to be very careful about how we handle the private keys because if a user
    leaks that private key, our infrastructure could be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Application security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application security is becoming more and more important. As the cloud is becoming
    the de-facto standard for infrastructure in large companies, we can't rely on
    the fact that the data is confined in a single data centre.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when someone starts a new business, the main focus is to build the
    product from the functional point of view. Security is not the main focus and
    usually gets overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very dangerous practice and we are going to amend that by letting
    the reader know the main security threats that could compromise our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main four big security points to develop applications in a secure manner
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-site scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-site request forgery token protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open redirects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this section, we will be able to identify the main vulnerabilities,
    but we won't be armored against a malicious attacker. In general, a software engineer
    should be up to date with the security as much as they are up to date with new
    technologies. No matter how good the product you build is, if it is not secure,
    someone will find out and take the advantage of it.
  prefs: []
  type: TYPE_NORMAL
- en: Common threats – how to be up to date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we stated before, security is an ongoing subject in application development.
    No matter what type of software you are building, there will always be security
    implications around it.
  prefs: []
  type: TYPE_NORMAL
- en: The best way I've found during my professional career to be up to date with
    security around web development without being a full-time dedicated security engineer
    is to follow the **OWASP** project. **OWASP** stands for **Open Web Application
    Security Project** and they produce quite an interesting document (among others)
    on a yearly basis called OWASP Top 10.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OWASP Top 10 was first published in 2003 and its goal is to raise awareness
    in the development community about the most common threats in application development.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we identified the four main security issues that a
    software developer can face and all of them are mentioned in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Injection** is, by far, the most dangerous attack that we could be exposed
    to. Specifically, a SQL injection is the most common form of injection that affects
    applications and it consists of an attacker forcing a SQL code in one of our application
    queries, leading to a different query that could compromise the data of our company.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other types of injections, but we are going to focus on SQL injection,
    as pretty much every application in the modern world uses a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection consists of the injection or manipulation of SQL queries in our
    application through the input from non-validated sources, such as a web form or
    any other data source with arbitrary input of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never store passwords in plain in the database. Always hash and salt them to
    avoid rainbow-table attacks. This is just an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This query will give us the user that corresponds to a given name and password.
    In order to build the query from the client''s input, we can consider doing something
    similar to the following code as a good idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At first sight, it looks like an easy program that accesses the database called
    `test_db` and issues a query to check whether there is a user that matches the
    username and password and renders it back to the client so that if we open the
    browser and try to browse to the `http://localhost:3000/login?username=david&password=mypassword`
    URL, the browser will render a JSON object with the result of the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Nothing strange yet, but what happens if the customer tries to hack us?
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:3000/login?username='' OR 1=1 --&password=mypassword`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the query generated by it is the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQL, the `--` character sequence is used to comment the rest of the line
    so that the effective query would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This query returns the full list of users, and if our software is using the
    result of this query to resolve whether the user should be logged in or not, we
    are in some serious problems. We have just granted access to our system to someone
    who does not even know a valid username.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the many examples on how SQL injection can affect us.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it is pretty obvious that we are concatenating untrusted data
    (coming from the user) into our query, but believe me, when the software gets
    more complicated, it is not always easy to identify.
  prefs: []
  type: TYPE_NORMAL
- en: A way to avoid SQL injection is through the usage of prepared statements.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Applications interact with users mainly through forms. These forms usually contain
    free text input fields that could lead to an attack.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to prevent corrupted data from getting into our server is through
    input validation, which as the name suggests, consists of validating the input
    from the user to avoid the situation described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of input validation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: White listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Black listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Black listing** is a dangerous technique. In majority of cases, trying to
    define what is incorrect in the input takes a lot more effort than simply defining
    what we expect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recommended approach is (and will always be) to **white list** the data
    coming from the user, validating it through the use of a regular expression: we
    know how a phone number looks like, we also know how a username should look like,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input validation is not always easy. If you have ever come across the validation
    of an e-mail, you will know what I am talking about: the regular expression to
    validate an e-mail is anything but simple.'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that there is not an easy way to validate some data should not restrict
    us from doing it as the omission of input validation could lead to a serious security
    flaw.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation is not the silver bullet for SQL injections, but it also helps
    with other security threats such as cross-site scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the query from the previous section, we do something quite dangerous: concatenate
    user input into our query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the solutions could be to use some sort of escaping library that will
    sanitize the input from the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `mysql` library used provides a suite of methods to escape
    strings. Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The small script from earlier escapes the string provided as `username` in the
    previous example, the result is `\' OR 1=1 --`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `escape()` method has replaced the dangerous characters,
    sanitizing the input from the user.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Cross-site scripting**, also known as **XSS**, is a security vulnerability
    that mainly affects web applications. It is one of the most common security issues
    and the implications can be huge for the customer as potentially, someone could
    steal the user identity with this attack.'
  prefs: []
  type: TYPE_NORMAL
- en: The attack is an injection code put into a third-party website that could steal
    data from the client's browser. There are a few ways of doing it, but by far,
    the most common is by unescaped input from the client.
  prefs: []
  type: TYPE_NORMAL
- en: In few websites on the Internet, users can add comments containing arbitrary
    input. This arbitrary input can contain script tags that load a JavaScript from
    a remote server that can steal the session cookie (or other types of valuable
    information), letting the attacker replicate the user session on a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of XSS attacks: **persistent** and **non-persistent**.'
  prefs: []
  type: TYPE_NORMAL
- en: The **persistent** type of XSS consists of storing the XSS attack by crafting
    a particular string of text that resolves into the attack once it is displayed
    to the user in the website. This code could be injected via an arbitrary input
    text that is stored in the database (such as a comment in a forum).
  prefs: []
  type: TYPE_NORMAL
- en: The **non-persistent** type of XSS is when the attack is inserted into a non-persistent
    part of the application due to bad data handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-site scripting](img/B04889_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have searched for a book (this book) in [http://www.amazon.co.uk/](http://www.amazon.co.uk/).
    It does not produce any output (as the book is not published yet), but it specifies
    that **Your search "microservices nodejs" did not match any products**, which
    is somehow using the input from the web browser as output. Even more, when I clicked
    on search, Amazon redirected me to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=microservices+nodejs](http://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=microservices+nodejs)'
  prefs: []
  type: TYPE_NORMAL
- en: We know Amazon is secure, but if it was sensible to XSS attacks, we could have
    modified the value of the `field-keywords` parameter to craft a request that injected
    a script tag in the content, leading to the attacker being able to steal the session
    cookie that could result in some serious problems for the website.
  prefs: []
  type: TYPE_NORMAL
- en: Output encoding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A way to protect against this attack is output encoding. We have done it before,
    when we used `connection.escape()` in the *Input validation* section of this chapter.
    In fairness, we should be validating all the data entered from the user and encoding
    all the outputs that come from third parties. This includes the input entered
    by the user, as well as sources of information coming from outside of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'When narrowing the problem to web development, we have to be aware of the three
    different areas where output encoding is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most problematic two are JavaScript and HTML, where an attacker could easily
    steal information without too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, no matter which framework we use for building our app, it always
    has functions to encode the output.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site request forgery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** (**CSRF**) is the reverse of cross-site request
    scripting. In cross-site request scripting, the problem is in the client trusting
    the data coming from the server. With cross-site request forgery, the problem
    is that the server trusts the data coming from the client.'
  prefs: []
  type: TYPE_NORMAL
- en: After stealing the session cookie, the attacker can not only steal information
    from the user, but can also modify the information of the account associated with
    the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by posting the data to the server via HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP classifies its requests in methods. A method is basically used to specify
    what is the operation to be carried by the request. The most interesting four
    methods are the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This gets the data from the server. It should not modify any persistent
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This creates a resource in the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This updates a resource in the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This deletes a resource from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more methods (such as `PATCH` or `CONNECT`), but let's focus on these
    four. As you can see, three of these four methods modify data from the server,
    and a user with a valid session could potentially steal data, create payments,
    order goods, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A way to avoid the cross-site request forgery attack is by protecting the `POST`,
    `PUT` and `DELETE` endpoints with a cross-site request token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following HTML form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This form describes a perfectly valid situation: a user registering on our
    website; very simple, but still valid and flawed.'
  prefs: []
  type: TYPE_NORMAL
- en: We are specifying a URL and the list of expected parameters so that an attacker
    can register hundreds or thousands of accounts within a span of minutes, with
    a small script that issues a `POST` request with the two parameters (`email` and
    `password`) in the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the difference: there is an extra hidden parameter called `csrftoken`.'
  prefs: []
  type: TYPE_NORMAL
- en: This parameter is a random string that is generated every time a form is rendered
    so that we can add this extra parameter to every form.
  prefs: []
  type: TYPE_NORMAL
- en: Once the form is submitted, the `csrftoken` parameter is validated to only let
    go through the requests with a valid token and generate a new token to be rendered
    on the page again.
  prefs: []
  type: TYPE_NORMAL
- en: Open redirects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, our application might need to redirect the user to a certain URL.
    For example, when hitting a private URL without a valid authentication, the user
    will usually be redirected to the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://www.mysite.com/my-private-page`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This could result into a redirect to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://www.mysite.com/login?redirect=/my-private-page`'
  prefs: []
  type: TYPE_NORMAL
- en: This sounds legit. The user is sent to the login page, and once he provides
    a valid set of credentials, it is redirected to `/my-private-page`.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if someone tries to steal the account of our user?
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://www.mysite.com/login?redirect=http://myslte.com`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a crafted request that will redirect the user to `myslte.com` instead
    of `mysite.com` (note the `l` instead of `i`).
  prefs: []
  type: TYPE_NORMAL
- en: Someone could make `myslte.com` look like the login page of `mysite.com` and
    steal your user's password and username by distributing the preceding URL in the
    social media as the users will be redirected to a malicious page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for the preceding problem is quite simple: don''t redirect the
    user to untrusted third-party websites.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the best way of doing such task is white listing the target hosts for
    redirects. Basically, we don't let our software redirect our customers to unknown
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: Effective code reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most effective ways to reduce security flaws in our applications
    is through a systematic and informed code review process. The problem with code
    reviews is that they always end up being a dump area for opinions and personal
    preferences that usually not only won't improve the quality of the code, but will
    also lead to last minute changes that could expose vulnerabilities in our application.
  prefs: []
  type: TYPE_NORMAL
- en: A dedicated stage in the product development life cycle for a security code
    review helps to drastically reduce the amount of bugs delivered to production.
  prefs: []
  type: TYPE_NORMAL
- en: The problem that the software engineers have is that their mind is trained to
    build things that work well, but they don't have the mindset to find defects,
    especially around the things that they build. This is why you should not be testing
    your own code (any further than the test carried on when developing), and even
    less, security testing your application.
  prefs: []
  type: TYPE_NORMAL
- en: However, we usually work in teams and that enables us to review someone else's
    code, but we have to do it in an effective manner.
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews require as much brain power as needed to write software, especially
    if you are reviewing a complex code. You should never spend more than two hours
    reviewing the same functionality, otherwise important flaws will be missed and
    attention to detail will decrease to a worrying level.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a big problem in microservices-based architectures as the functionality
    should be small enough to be read in a reasonable period of time, especially if
    you talked to the author about what he was trying to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should always follow a two phase review, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the code quickly to get the big picture: how it works, what technology
    it uses that you are not familiar with, does it do what it is supposed to do,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the code following a checklist of items to look for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list of items has to be decided upfront and depends on the nature of the
    software that your company is building.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the list of items to check around the code security concerns during
    a code review is quite big, but we can narrow it down to the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Is all the input validated/encoded when applicable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is all the output encoded, including logs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we protect endpoints with cross-site request forgery tokens?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are all the user credentials encrypted or hashed in the database?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we check this list, we will be able to identify the biggest issues around
    security in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Traceability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traceability is extremely important in the modern information systems. It is
    a delicate matter in microservices that is gracefully solved in Seneca, making
    the requests easy to follow around our system so that we can audit the failure.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Seneca is pretty good with the logging. There are so many options that can be
    configured in Seneca in order to get the required information about how everything
    is working (if it is working).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how logging works with a small application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest Seneca application that can be written. Let''s run it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result of running the app with the default logging configuration.
    Aside from the `console.log()` method that we have used in the code, there is
    some internal information about Seneca being logged. Sometimes, you might want
    to only log what your application is producing so that you can debug the application
    without all the noise. In this case, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, sometimes, there are weird behaviors in the system (or even a bug
    in the frameworks used) and you want to get all the information about what is
    happening. Seneca supports that as well, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will print an endless amount of information that might
    not be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to reduce the amount of logging produced by Seneca, there is a fine-grain
    control in what gets logged into the output. Let''s take a look at the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'They are random lines from a log output on the preceding code example, but
    it will give us useful information: these entries are debug-level log lines for
    different actions (such as plugin, register, and act) on the Seneca framework.
    In order to filter them, Seneca provides a control over what levels or actions
    do we want to see. Consider the following for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will only output the logs related to the `INFO` level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also filter by action type, which is quite interesting. When you are
    working with microservices, knowing the chain of events that happened in a flow
    is one of the first things that you need to look into in order to audit a failure.
    With this control over the logging that Seneca gives us, it is as easy as executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging](img/B04889_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, all the preceding lines correspond to the `act` type, and even
    more, if we follow the output of the command from top to bottom, we exactly know
    the sequence of events to which Seneca reacted and their order.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tracing requests is also a very important activity, and sometimes, it is even
    a legal requirement, especially if you work in the world of finance. Again, Seneca
    is fantastic at tracing requests. For every call, Seneca generates a unique identifier.
    This identifier can be traced across all the paths to where the call is going
    to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are logging a dictionary that contains the transaction ID in Seneca
    to the terminal. So, if we execute it, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how all the requests in Seneca are traced: the framework assigns
    an ID and it gets propagated across endpoints. In this case, all our endpoints
    are in the local machine, but if we distribute them in different machines, the
    ID will still be the same.'
  prefs: []
  type: TYPE_NORMAL
- en: With this unique ID, we will be able to reconstruct the journey of the customer
    data in our system, and ordering the requests with the associated timestamp, we
    can get an accurate picture of what the user was doing, how much time did every
    action take, what are the possible problems associated with delays, and so on.
    Usually, the logging combined with circuit breakers output information allows
    the engineers to solve issues within a very reduced time frame.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up till now, we have been using `console.log()` to output the data into the
    logs. This is a bad practice. It breaks the format of the logs and throws the
    content to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, Seneca comes to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what Seneca produces as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are now outputting the transaction ID using the logger. We
    have produced a `WARN` message instead of a simple console dump. From now on,
    we can use Seneca log filters to hide the output of our actions in order to focus
    on what we are trying to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seneca provides the following five levels of logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEBUG**: This is used to debug applications when you are developing them
    and also trace problems in production systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INFO**: This log level is used to produce important messages about events
    such as a transaction has started or completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WARN**: This is the warning level. We use it when something bad happens in
    the system, but it is not critical, the user usually does not get affected; however,
    it is an indication that something is going in the wrong way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ERROR**: This is used to log errors. Generally, the user gets affected by
    it and it also interrupts the flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FATAL**: This is the most catastrophic level. It is only used when a non-recoverable
    error has occurred and the system won''t be able to function normally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to produce logs in different levels is to use the associated functions.
    As we have seen earlier, we called `this.log.warn()` to log a warning. If we call
    the `this.log.fatal()` method, we will be logging a fatal error, and same with
    the other levels.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to adjust the logs in your application as a part of the development process
    or you will regret the lack of information when something bad occurs in production.
  prefs: []
  type: TYPE_NORMAL
- en: In general, INFO, DEBUG, and WARN will be the most used log levels.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP codes are often ignored, but they are a really important mechanism to standardize
    responses from remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a program (or user) issues a request to a server, there are a few things
    that could happen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It could be successful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could fail validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could produce a server error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the possibilities are endless. The problem that we now have
    is that HTTP was created for the communication between machines. How do we handle
    the fact that machines will be reading these codes?
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP solved this problem in a very elegant way: every single request has to
    be resolved with an HTTP code and these codes have ranges that indicate the nature
    of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 1xx – informational
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The codes in the 100-199 range are purely informational. The most interesting
    code in this range is the 102 code. This code is used to specify that an operation
    is happening in the background and might take some time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 2xx – success codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Success codes are used to indicate a certain level of success in the HTTP request.
    It is the most common (and desired) codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common codes in this range are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200: Success`: This code indicates a full success. Nothing went wrong even
    remotely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201: Created`: This code is used mainly for REST APIs when the client requests
    to create a new entity in the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`203: Non-authoritative information`: This code is intended to be used when,
    while routing the request through a transforming proxy, the origin responds with
    a 200.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204: No Content`: This is a successful code, but there is no content coming
    back from the server. Sometimes, APIs returns 200, even if there is no content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`206: Partial Content`: This code is used for paginated responses. A header
    is sent, specifying a range (and an offset) that the client will accept. If the
    response is bigger than the range, the server will reply with 206, indicating
    that there is more data to follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3xx – redirection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The codes in the 300 to 399 range indicate that the client must take some additional
    actions to complete the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common codes in this range are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`301: Moved permanently`: This status code is indicating that the resource
    that the client was trying to get has been moved permanently to another location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`302: Found`: This code indicates that the user is required to perform a temporary
    redirect for some reason, but the browsers started implementing this code as `303
    See Other`. This lead to the introduction of the 303 and `307 Temporary redirect`
    codes to disambiguate the overlap of behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`308 Permanent Redirect`: This code, as the name indicates, is used to specify
    a permanent redirect for a resource. It could be confused with 301, but there
    is a small difference, the 308 code does not allow the HTTP method to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4xx – client errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The codes in the 400 to 499 range represent errors generated by the client.
    They indicate that there is a problem with the request. This range is particularly
    important as it is the way that HTTP servers have to indicate the clients that
    something is wrong with their request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common codes in this range are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`400 Bad Request`: This code indicates that the request from the user is syntactically
    incorrect. There could be parameters missing or some of the values didn''t pass
    validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401 Unauthorized`: This code represents a lack of authentication of the client.
    Usually, a valid login will fix this problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403 Forbidden`: This is similar to 401, but in this case, it is indicating
    that the user does not have enough privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404 Not Found`: This means that the resource is not found in the server. This
    is the error that you get when you navigate to a page that does not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5xx – server errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This range indicates that there has been a processing error in the server. When
    a 5xx code is issued, it means that there was some sort of problem in the server
    and it cannot be fixed from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the codes in this range are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`500 Internal Server Error`: This means that an error has occurred in the software
    in the server. There is no more information disclosed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`501 Not Implemented`: This error occurs when a client hits an endpoint that
    has not been implemented yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`503 Service unavailable`: This code is issued when the server is not available
    for some reason, either an excess of the load or the server is down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why HTTP codes matter in microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The popular saying *don't reinvent the wheel* is one of my favorite principles
    when building software. HTTP codes are a standard, so everybody understands the
    consequences of the different codes.
  prefs: []
  type: TYPE_NORMAL
- en: When building microservices, you always need to keep in mind that your system
    will be interacting with proxies, caches, and other services that already speak
    HTTP so that they can react according to the response from the servers.
  prefs: []
  type: TYPE_NORMAL
- en: The best example of this is the circuit-breaker pattern. No matter how you implement
    it and what software you use, a circuit breaker has to understand that an HTTP
    request with 500 code is an error, so it can open the circuit accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is good practice to keep the codes of your application as accurate
    as possible as it will benefit your system in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have learned how to build secure software (and not only
    microservices), although it is a subject big enough to write a full book on it.
    The problem with security is that companies usually see investing in security
    as burning money, but that is far from reality. I am a big fan of the 80-20 rule:
    20% of time will give you 80% of features and the 20% of missing features will
    require 80% of the time.'
  prefs: []
  type: TYPE_NORMAL
- en: In security, we really should be aiming for 100% coverage; however, the 80%
    shown in this chapter will cover majority of the cases. Anyway, as I mentioned
    before, a software engineer should be up to date with security as a flaw in the
    security of an application is the easiest way to kill a company.
  prefs: []
  type: TYPE_NORMAL
- en: We have also been talking about traceability and logging, one of the most ignored
    subjects in the modern software engineering that are becoming more and more important,
    especially if your software is built using a microservices approach.
  prefs: []
  type: TYPE_NORMAL
