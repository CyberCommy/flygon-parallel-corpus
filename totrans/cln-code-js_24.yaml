- en: Case Study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have discussed a litany of principles, walked through almost
    every aspect of the JavaScript language, and have discussed, at length, what constitutes
    *clean code*. This has all been working toward a final destination where we are
    fully equipped to write beautiful and clean JavaScript code that tackles real
    and challenging problem domains. The pursuit of clean code, however, is never
    complete; new challenges will always arise that make us think in new and paradigm-shifting
    ways about the code we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be walking through the process of creating a new piece
    of functionality in JavaScript. This will involve both client-side and server-side
    parts, and will force us to apply many of the principles and knowledge we''ve
    gathered throughout the book. The specific problem we''ll be tackling has been
    adapted from a real-life project that I was responsible for, and while we won''t
    be going into every nook and cranny of its implementation, we will be covering
    the most important parts. The completed project is available for you to view on
    GitHub at the following link: [https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The problem**: We''ll define and explore the problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The design**: We''ll design a UX and architecture that solves the problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The implementation**: We''ll implement our design'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem we''ll be solving relates to a core part of our web application''s
    user experience. The web application we''ll be working on is a frontend to a large
    plant database with tens of thousands of different species of plants. Among other
    functionality, it allows users to find specific plants and add them to collections
    so that they can keep track of their exotic greenhouses and botanical research
    inventories. The illustration is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e254a325-cd9f-4839-bbfe-f4930bc8f91c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Currently, when users wish to find a plant, they must use a search facility
    that involves entering a plant name *(the full Latin name*) into a text field,
    clicking Search, and receiving a set of results, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e74e911d-7b93-4c8b-9eb0-e8d3de98270d.png)'
  prefs: []
  type: TYPE_IMG
- en: For the purposes of our case study, the plant names only exist as their full
    Latin names, which includes a family (for example, Acanthaceae), a genus (for
    example, Acanthus), and a species (for example, Carduaceus). This highlights the
    challenges involved in catering to complex problem domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works well enough, but following some user focus groups and online feedback,
    it has been decided that we need to offer a better UX for users that enables them
    to more quickly find the plants they''re interested in. Specific points that were
    raised are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: I find it burdensome and slow to find species sometimes. I wish it were more
    immediate and flexible, so that I didn't have to keep going back and making a
    change to my query, especially if I've spelled it incorrectly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, when I know the name of a plant species or genus, I'll still get it slightly
    wrong and get no results. I'll then have to go back and adjust my spelling or
    search elsewhere online.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I wish I could see the species and genuses come up as I type. That way I can
    more quickly find the appropriate plant and not waste any time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a number of usability concerns expressed here. We can distill them
    into the following three topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: The current search facility is slow and clunky to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error** **c****orrection**: The process of having to correct typing errors
    is annoying and burdensome'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**: It would be useful to get feedback about existing *genuses*/*species*
    while typing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task is now becoming clearer. We need to improve the UX so that users are
    able to query the database of plants in a way that is faster, provides more immediate
    feedback, and lets them prevent or correct typing errors along the way.
  prefs: []
  type: TYPE_NORMAL
- en: The design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After some brainstorming, we decided that we can solve our problem in quite
    a conventional way; we can simply transform the input field into one that provides
    an auto-suggestion dropdown. Here''s a mockup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e2c2309-6bc8-406d-86fd-f1bfa89b9a68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This auto-suggestion dropdown would have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: When a term is typed, it will display a prioritized list of plant names that
    contain that term as a prefix, for example, searching for `car` will yield the
    result `carnea` but not `encarea`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a term is selected either by click, the arrow (up/down), or *Enter* key,
    it will run a specified function (which may later be used to add selected items
    to the user's collection)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When no matching plant names can be found, the user will be told with a notice
    such as `No plants with that name exist`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the core behaviors of our component, and in order to implement them,
    we'll need to consider both client-side and server-side parts. Our client will
    have to render `<input>` to the user, and as they type, it will have to dynamically
    adjust the list of suggestions. The server will have to provide to the client
    a list of suggestions for each potential query, while taking into consideration
    the fact that results will need to be delivered quickly. Any significant latency
    will drastically reduce the benefit of the user experience that we're trying to
    create.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It just so happens that this new Plant Selection component will be the first
    piece of significant client-side code within our web application, and as such,
    it's important to note that our design decisions will impact not only this specific
    component but also any other components we consider building in the future.
  prefs: []
  type: TYPE_NORMAL
- en: To aid us in our implementation, and considering the possibility of other potential
    additions in the near future, we've decided to adopt a JavaScript library to assist
    in the manipulation of the DOM, and a supporting toolset that enables us to work
    swiftly and to a high-level of quality. In this instance, we've decided to use
    React on the client side, with webpack and Babel to aid in compilation and bundling,
    and Express on the server side for HTTP routing.
  prefs: []
  type: TYPE_NORMAL
- en: The Plant Selection application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed, we've decided to build our *Plant Selection* functionality as
    its own self-contained application with both a client (the React component) and
    a server (the plant-data API). Having this level of isolation allows us to focus
    purely on the problem of selecting plants, but there's no reason that this couldn't
    be integrated into a larger code base at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our directory structure is roughly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In addition to reducing complexity for us (the programmers) the separation of
    server and client means that the server-side application (that is, the Plant Selection
    API) can be run on its own distinct server if necessary, while the client can
    be served up statically from a CDN, requiring only the server-side's address in
    order to access its REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server of `EveryPlantSelectionApp` is responsible for retrieving the plant
    names (the plant *families*, *genuses,* and *species*) and making them available
    to our client-side code via a simple REST API. To do this, we can use the `express`
    Node.js library, which enables us to route HTTP requests to specific functions,
    easily delivering JSON to our client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the skeletal beginnings of our server implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''re implementing just one route (`/plants/:query`). This
    will be requested by the client whenever a user enters a partial plant name into
    the `<input/>`, so that a user typing `Carduaceus` may produce the following set
    of requests to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can imagine how this may result in a larger number of expensive and possibly
    redundant requests, especially if a user is typing quickly. It's possible that
    a user will type `cardua` before any of the previous requests can complete. For
    that reason, when we come around to implementing the client side, it'll be appropriate
    for us to use some kind of request throttling (or request debouncing) to ensure
    that we're only making a reasonable number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Request throttling** is the act of reducing the overall amount of requests
    by only allowing a new request to be performed at a specified time interval, meaning
    that 100 requests spanned over five seconds, throttled to an interval of one second,
    would produce only five requests. **Request debouncing** is similar, though instead
    of performing a single request on every interval, it''ll wait a predesignated
    amount of time for incoming requests to stop being made before enacting an actual
    request. So, 100 requests over five seconds, debounced by five seconds, would
    only produce a single final request at the five second mark.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement the `/plants/` endpoint, we need to consider the most
    optimal way to search through the names of over *300,000* different plant species
    for matches. To accomplish this, we'll be using a special in-memory data structure
    called a **trie**. This is also known as a *prefix tree *and is very common to
    use in situations where autosuggestion or autocompletion needs to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'A trie is a tree-like structure that stores chunks of letters that appear next
    to each other as a series of nodes attached by branches. It''s much easier to
    visualize than to describe, so let''s imagine that we need a trie based on the
    following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using that data, the produced trie might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0fd9a5f9-ff9b-4291-b9b3-10a7c13975d9.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our dataset of four words has been represented as a tree-like
    structure where the first common letter, `"A"`, serves as the root. The `"CORN"` suffix
    branches off from this. Additionally, the `"PP"` branch (forming `"APP"`), branches
    off, and the last `"P"` of that then branches off to `"L"`, which itself then
    branches off to `"E"` (forming `"APPLE"`) and `"ICATION"` (forming `"APPLICATION"`).
  prefs: []
  type: TYPE_NORMAL
- en: This may seem convoluted, but given this trie structure, we can, given an initial
    prefix typed by a user like `"APPL"`, easily find all matching words (`"APPLE"`
    and `"APPLICATION"`) by simply stepping through the nodes of the tree. This is
    far more performant than any linear search algorithm. For our purposes, given
    a prefix of a plant name, we want to be able to performantly display every plant
    name that the prefix may lead to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our specific dataset will include over 300,000 different plant species, but
    for the purposes of this case study, we''ll only be using species from the `Acanthaceae` family,
    which amounts to around 8,000 species. These are available to use in the form
    of JSON as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We'll be feeding this data into a third-party trie implementation called **trie-search** on
    NPM. This package has been selected because it fulfills our requirements and seems
    like a well-tested and well-maintained library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the trie to operate as we desire, we''ll need to concatenate the
    *family*, *genus*, and *species* of each plant into a singular string. This enables
    the trie to include both the fully qualified plant name (for example, `"Acanthaceae
    Pararuellia alata"`) and the split names (`["Acanthaceae", "Pararuellia", "alata"]`).
    The *split* name is automatically generated by the trie implementation we''re
    using (meaning it splits strings on whitespace, via the regex `/\s/g`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code enters our dataset into the trie. Following this, it can
    be queried by simply passing a prefix string to its `get(...)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a query (for the prefix, `laxi`) would return the following from our dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, with regard to our REST endpoint, `/photos/:query`, all it needs to do
    is return a JSON payload that contains whatever we get from `trie.get(query)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To separate our concerns a little better and to ensure we''re not mixing too
    many different layers of abstraction (in possible violation of The Law of Demeter),
    we can abstract away our trie data structure and plant data to a module of its
    own. We can call this `plantData` to communicate the fact that it encapsulates
    and provides access to the plant data. The nature of how it works, which happens
    to be via an in-memory trie data structure, does not need to be known to its consumers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this module returns an interface that provides one method,
    `query()`, which our main HTTP routing code can utilize to deliver the JSON result
    for `/plants/:query`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because we have isolated and contained the plant-querying functionality, it
    is now far easier to make assertions about it. Writing some tests that target
    the `plantData` abstraction will give us a high level of confidence that our HTTP
    layer is using a reliable abstraction, minimizing the potential bugs that can
    crop up within our HTTP layer itself.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, since this is the first set of tests we'll be writing for our
    project, we'll be installing Jest (`npm install jest --save-dev`). There are a
    large number of testing frameworks available, with varying styles, but for our
    purposes, Jest is suitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write tests for our `plantData` module in a file intuitively located
    alongside it and named `plantData.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are a large number of tests within `plantData.test.js` that aren't included
    here for the sake of brevity; however, you can view them in the GitHub repository: [https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this test is asserting whether an `Acanthaceae Thunbergia` query
    intuitively returns plants that have a fully qualified name containing these terms.
    In our dataset, this will only include plants that have an `Acanthaceae` family
    and a `Thunbergia` genus, so we can simply confirm that the results match that
    expectation. We can also check that partial searches, such as `Acantu Thun`, also
    intuitively return any plants that have either *family*, *genus*, or *species*
    names beginning with `Acantu` or `Thun`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We confirm our expectations here by asserting that every returned result's `fullyQualifiedName`
    matches the regular `/\bAcant/i` and `/\bThun/i` expressions. The `/i` expression
    indicates case sensitivity. The `\b` expression here represents a word boundary
    so that we can ensure that the `Acant` and `Thun` substrings appear at the beginning
    of individual words and are not embedded within words. For example, imagine a
    plant called `Luathunder`. We don't want our autosuggestion mechanism to match
    such instances. We only want it to match prefixes, as that is how users will be
    entering plant *families*, *genuses*, or *species* into `<input />` (from the
    start of each word).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a well-tested and isolated server-side architecture, we can
    begin to move onto the client side, where we will be rendering the plant names
    provided by `/plants/:query` in response to the user typing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the client-side build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first step, on the client, is to introduce *React* and a supporting toolset
    that can aid us in development. In the old days of web development, it was, and
    arguably still is, entirely possible to build things without complicated tools
    and build steps. In times past, we were able to simply create an HTML page, include
    any third-party dependencies inline, and then begin writing our JavaScript without
    having to worry about anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically we can still do this. Even when using modern frontend frameworks
    such as React, we could opt to just include it as a `<script>` dependency and
    then write vanilla JavaScript inline. However, by doing this, we would not be
    receiving the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Newer JavaScript syntax** (ES 2019 and beyond): The ability to use modern
    JavaScript syntax and have it compiled to JavaScript that is safe to use in all
    environments/browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom syntax and language extensions**: The ability to use language extensions
    (such as JSX or FlowJS) or other languages that compile to JavaScript (such as
    TypeScript or CoffeeScript).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency tree management**: The ability to specify your dependencies easily
    (for example, using an `import` statement) and have these automatically reconciled
    and combined into a bundle, without having to manually fiddle with the `<script>`
    tags and versioning nightmares.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance improvements**: Intelligent compilation and bundling can provide
    meaningful HTTP and runtime performance gains by reducing the overall footprint
    of your JavaScript and CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linters and analysers**: The ability to use linters and other forms of analysis
    on your JavaScript (and your CSS and HTML), giving us a detailed insight into
    code quality and prospective bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamentally, the very nature of web applications is more complicated now,
    especially on the frontend. For our purposes of creating an autosuggestion component,
    we need to ensure that we've got a good foundation of tools and build steps so
    that ongoing development can be seamless and simple. This can create a headache
    when setting things up but is worth it in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to compile our JavaScript (including React''s JSX), we''ll be using
    *Babel*, which can take our JavaScript and convert it into widely supported regular
    JavaScript syntax. To add Babel as a dependency within `EveryPlantSelectionApp/client`,
    we can use `npm` to install it and its various preset configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Babel will manage the compilation of our JavaScript to a syntax that is widely
    supported. But in order to make these files ready for delivery to a browser, we
    need to bundle them into a singular file that can be delivered by itself within
    our HTML like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To accomplish this, we will need to use a bundler, such as webpack. Webpack
    can carry out the following tasks for us:'
  prefs: []
  type: TYPE_NORMAL
- en: It can compile the JavaScript via Babel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can then reconcile each module, including any of its dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can produce a singular bundled JavaScript file that includes all dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to use webpack, we need to install several related dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Webpack also requires its own configuration file, named `webpack.config.js`.
    Within this file, we must tell it how to bundle our code and whereabouts in our
    project we want the bundled code to output to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration is essentially telling webpack the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Please begin at `EveryPlantSelectionApp/client/app/index.jsx `
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please use Babel to compile this module and all its dependencies that end in
    `.jsx` or `.js `
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please output the compiled and bundled file to `EveryPlantSelectionApp/client/dist/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, we need to install React so that we''re ready to create our plant selection
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It may seem like this is a lot of work just to render a basic UI component,
    but what we've actually done is created a foundation upon which we can accommodate
    many new features, and we've created a build pipeline that will make it easier
    to ship our development code base to production.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our component's job is to display an enhanced `<input>` element that will, when
    focused, react to what the user types by rendering a dropdown-style list of available
    options that the user can then select from.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a primitive outline, we can imagine the component as containing `<div>`,
    `<input>` into which the user can type, and `<ol>` to display the suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `role` and `aria-autocomplete` attributes on `<input>` are used to instruct
    the browser (and any screen readers) that the user will be provided with a set
    of predefined choices when typing. This is of vital importance to accessibility.
    The `autoComplete` attribute is used to simply enable or disable the browser's
    default autocompletion behavior. In our case, we want it disabled as we are providing
    our own custom autocompletion/suggestion functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only want `<ol>` to display when `<input>` is focused. In order to accomplish
    this, we''ll need to bind to both the focus ad blur events of `<input>` and then
    create a distinct piece of state that can track whether we should consider the
    component open or not. We can call this piece of state `isOpen`, and we can conditionally
    render or not render `<ol>` based on its Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: React has its own conventions around state management, which may look rather
    bizarre if you've not been exposed before. The `const [foo, setFoo] = useState(null)` code
    creates a piece of state (called `foo`), which we can change in response to certain
    events. Whenever this state changes, React would then know to trigger a re-render
    of the related component. Flick back to [Chapter 12](5df59321-fd46-4504-93ed-5e8555b33b01.xhtml)*, Real-World
    Challenges*, and look at the *DOM binding and reconciliation* section for a refresher
    on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is for us to bind to the `change` event of `<input>` so that
    we can take whatever the user has typed and trigger a request to our `/plants/:query`
    endpoint in order to discern what suggestions to show the user. First, however,
    we want to create a mechanism via which the request can occur. In the React world,
    it suggests modeling this functionality as a *Hook* of its own. Remembering that
    Hooks are, by convention, prefixed with a *use* verb, we could call this something
    like `usePlantLike`. As its sole argument, it can accept a `query` field (the
    string typed by the user), it can return an object with a `loading` field (to
    indicate the current loading state) and a `plants` field (to contain the suggestions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation of `usePlantsLike` is thankfully quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using another *React* state management pattern, `useEffect()`,
    to run a specific function whenever the `query` argument changes. So, if `usePlantLike`
    receives a new `query` argument, for example, `Acantha`, then the loading state
    will be set to `true` and a new `fetch()` will be instigated, the result of which
    will populate the `plants` state. This can be difficult to wrap one's head around,
    but for the purposes of the case study, all we really need to appreciate is the
    fact that this `usePlantsLike` abstraction is encapsulating the complexity of
    issuing the `/plants/:query` requests to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**It is wise to separate rendering logic from data logic**. Doing so ensures
    a good hierarchy of abstraction and separation of concerns, and enshrines each
    module as an area of *single responsibility*. Conventional MVC and MVVM frameworks
    helpfully force this separation, while more modern rendering libraries such as
    React give you a little more choice. So here, we''ve chosen to isolate the data
    and server-communication logic within a React Hook, which is then utilized by
    our component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use our new React Hook whenever the user types something into `<input>`.
    To do this, we can bind to its `change` event and every time it''s triggered,
    grab its `value`, and then pass it as the `query` argument to `usePlantsLike`
    in order to derive a new set of suggestions for the user. These can then be rendered
    within our `<ol>` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added a new piece of state, `query`, which we set via `setQuery`
    within the `onChange` handler of `<input>`. This `query` mutation will then cause
    `usePlantsLike` to issue a new request from the server and populate `<ol>` with
    multiple `<li>` elements, each representing an individual plant name suggestion.
  prefs: []
  type: TYPE_NORMAL
- en: 'And with that, we have completed the basic implementation of our component.
    In order to make use of it, we can render it in our `client/index.jsx` entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code attempts to render `<PlantSelectionInput/>` to an element with a `"root"` ID.
    As outlined previously, webpack, our bundling tool, will automatically bundle
    our compiled JavaScript into a singular `main.js` file and place it in `dist/`
    (that is, distribution) directory. This will sit alongside our `index.html` file,
    which will serve as a user-facing portal to our application. For our purposes,
    this only needs to be a simple page that demonstrates `PlantSelectionInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can place any relevant CSS within the `<style>` tag here in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In larger projects, it's wise to come up with a scaled CSS solution that works
    well with many different components. Examples that work well with *React* include
    *CSS modules* or s*tyled component**s*, both of which allow you to define CSS
    scoped just to individual components, avoiding the headache of juggling global
    CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The styling of our component is not particularly challenging as it is just
    a list of textual items. The main challenge is in ensuring that, when the component
    is in its fully opened state, the list of suggestions appears atop any other content
    on the page. This can be achieved by relatively positioning the `<input>` container
    and then absolutely positioning `<ol>`, visualized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f6a48501-2aea-4bf9-80ea-22f15d752833.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This concludes the implementation of our component, but we should also implement
    a basic level of testing (at least). To accomplish this, we''ll be using Jest,
    a testing library, and its snapshot matching functionality. This will enable us
    to confirm that our React component produces the expected hierarchy of DOM elements
    and will protect us from future regressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Jest helpfully saves the produced snapshots to a `__snapshots__` directory and
    then compares any future executions of the tests against these saved snapshots.
    In addition to these tests, we'll also be able to implement regular functional,
    or even E2E tests that can encode expectations such as *When the user types, the
    list of suggestions updates correspondingly*.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our construction of the component and our case study. If you
    have a look at our GitHub repository, you can see the completed project, play
    with the component, run the tests yourself, and you can fork the repository to
    make your own changes too.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the link to the GitHub repository: [https://github.com/PacktPublishing/Clean-Code-in-JavaScript](https://github.com/PacktPublishing/Clean-Code-in-JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this, the final chapter, we have explored a real-world problem through the
    lens of the principles and learnings that we have gathered throughout the book.
    We posed a problem that users were encountering and then designed and implemented
    a user experience that solved their problem in a clean way. This included both
    server-side and client-side pieces, enabling us to see, from start to finish,
    what a self-contained JavaScript project may look like. Although we haven''t been
    able to cover every single detail, I hope that this chapter has been helpful in
    cementing the core ideas behind *clean code* and that you now feel better prepared
    to write clean JavaScript code to tackle all types of problem domains. One core
    tenet I hope you can take away with you is simply this: **focus on the user**.'
  prefs: []
  type: TYPE_NORMAL
