- en: Common Patterns in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn various design patterns in C++. Design patterns
    provide a common approach to solving different types of problems properly, and
    oftentimes, design patterns are discussed throughout the internet, at conferences,
    and in front of the water cooler at work regarding their advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to introduce you to some of the more popular, less
    popular, and even controversial patterns, giving you an idea of the different
    types of problems that design patterns attempt to solve. This is an important
    chapter as it will give you the skills to tackle hard problems by teaching you
    already existing approaches to common problems others have experienced in the
    past. Learning even a subset of these design patterns will lay the foundation
    for discovering other design patterns on your own as you run into problems in
    your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the singleton pattern properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending your objects with the decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding communication with the observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance with static polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter11](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Learning the factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn what the factory pattern is, how to implement
    it, and when to use it. This recipe is important, especially when unit testing
    as the factory pattern provides the ability to add seams (that is, intentional
    places in your code that provide opportunities for making changes) capable of
    changing what type of object another object allocates, including the ability to
    allocate fake objects for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try the code for the factory pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will go through each of these examples and explain what
    each example program does and how it relates to the lessons being taught in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The factory pattern provides an object that allocates resources with a means
    to change the types that the object allocates. To better understand how this pattern
    works and why it is so useful, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We start, as shown in the preceding code, with a class called `know_it_all`
    that provides an answer when asked a question. In this particular case, no matter
    what question is asked, it always returns the same answer. The answer is defined
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, the answer is a simple class that is constructed
    given a string and stores the string internally. It is important to note in this
    case that the user of this API cannot actually extract the string that the answer
    class stores, meaning the use of these APIs is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding, we can ask a question, and a result is provided,
    but we are not sure of what result was actually provided. This type of problem
    exists all of the time in object-oriented programming, and testing this sort of
    logic is one of the many reasons why entire books have been written on the subject
    of object mocking. A mock is a fake version of an object designed specifically
    to validate the output of a test (unlike a fake, which is nothing more than an
    object that provides test input). In the preceding example, however, a mock still
    needs a way to be created so that the output of a function can be verified. Enter
    the factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the answer class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we have added a static function that allows
    the `answer` class to create instances of itself. We have not changed the fact
    that the `answer` class doesn''t provide the ability to extract the content it
    holds within, just how the `answer` class is created. We can then modify the `know_it_all`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the only difference here is that the `know_it_all`
    class takes a template parameter for `factory_t` and uses it to create the answer
    class instead of creating the `answer` class directly. `factory_t` is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This defaults to the static `make_answer()` function that we added to the `answer`
    class. In its most simple form, the preceding example demonstrates the factory
    pattern. Instead of creating an object directly, we delegate the creation of an
    object to another object. The preceding implementation doesn''t change anything
    about how the two classes are used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, the `main()` logic remains unchanged, but this new
    approach ensures that the `know_it_all` class focuses on answering questions without
    worrying about how to create the `answer` class itself, leaving that task to a
    different object. The real power behind this subtle change is we can now provide
    the `know_it_all` class with a different factory, resulting in a different `answer`
    class being returned. To demonstrate this, let''s create a new `answer` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, we have created a new `answer` class that sub-classes
    the original `answer` class. This new class checks the value it is given during
    construction and outputs success or failure based on the string it is provided.
    We can then use this new `answer` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41a225db-9424-4bd1-aa9f-8be824d88b8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the preceding approach, we are not able to ask different questions to
    see whether the `know_it_all` class provides the right answers without having
    to modify the original `answer` class. For example, suppose the `know_it_all`
    class was implemented this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We tested this version of the `know_it_all` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3626806f-b78e-4c07-81cf-329507c18135.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It should be noted that there are several ways to implement the factory pattern.
    The preceding approach uses a template argument to change how the `know_it_all`
    class creates answers, but we could also use a runtime approach as well, as in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, we start with a custom `know_it_all` constructor
    that stores a pointer to a factory function, which again, defaults to our `answer`
    class, but provides the ability to change the factory if we choose, which is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted, we could also add a setter to this class to change this function
    pointer at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using the singleton pattern properly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to properly implement the singleton pattern
    in C++11 and above and when it is appropriate to use the singleton pattern. This
    recipe is important as it will teach you when to use the singleton pattern, which
    provides a clear definition of a single global resource, ensuring the resource
    is kept global without the possibility of multiple copies.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try the singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton pattern has been around in C++ for several years, and it is arguably
    one of the most controversial patterns in all of C++ as its global nature introduces
    coupling in your application (similar to how global variables introduce coupling).
    The singleton pattern implements a single, global resource. Specifically, it creates
    an object that maintains global scope, while ensuring no copies of itself can
    exist. The debate as to whether or not the singleton pattern should be used in
    your code will not be answered in this book as it depends on your use case, but
    let's at least cover some advantages and disadvantages of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages: **The singleton pattern provides a clearly defined interface
    for global resources that can only contain a single instance. Whether we like
    it or not, global resources exist in all of our applications (for example, heap
    memory). If such a global resource is needed, and you have a mechanism to handle
    coupling (for example, a mocking engine such as Hippomocks), the singleton pattern
    is a great way to ensure the global resource is managed properly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disadvantages:** The following are the disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern defines a global resource, and like any global resource
    (for example, a global variable), any code that uses a singleton object becomes
    tightly coupled with the singleton. Coupling, in objected-oriented design, should
    always be avoided as it prevents the ability to fake a resource your code might
    depend on, which limits flexibility when testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern hides dependencies. When inspecting an object's interface,
    there is no way to determine that the object's implementation depends on a global
    resource. Most argue that this can be handled with good documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern maintains its state throughout the lifetime of the application.
    This is especially true (that is, the disadvantage is obvious) when unit testing
    as the singleton's state carries from one unit test to the next, which most consider
    a violation of what a unit test is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, global resources should always be avoided. Period. To ensure that
    your code is properly written to enforce the singleton design pattern, if and
    when you need a single global resource. Let's discuss the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you are writing an application for an embedded device, and your embedded
    device has an additional memory pool that you can map into your application (for
    example, device memory for a video or network device). Now, suppose you can only
    ever have one of these additional memory pools and you need to implement a set
    of APIs to allocate memory from this pool. In our example, we will implement this
    memory pool using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will implement a memory manager class to allocate memory from this
    pool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we have created a memory manager class that
    stores a pointer to the memory buffer that contains our single, global resource.
    We then create a simple allocation function that handles this memory out as needed
    (with no ability to free, which keeps the algorithm really simple).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a global resource, we create the class globally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use our new memory manager as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we allocate four integer pointers and then output
    the address of our memory block and the addresses of the integer pointers to ensure
    the algorithm is working as intended, resulting in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4538b81d-108f-4a76-98a9-f759ccfadcff.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding, the memory manager properly allocates memory as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with the preceding implementation is that the memory manager is
    just a class like any other, meaning it can be created as many times as we want
    as well as copied. To better demonstrate why this is a problem, let''s look at
    the following example. Instead of creating one memory manager, let''s create two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s use both of these memory managers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, the only difference is we are now using two memory
    managers instead of one. This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a5fd1a4-19c6-44c5-8250-18a3e61714ec.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding, memory has been double allocated, which will likely
    result in corruption and undefined behavior. The reason this occurs is the memory
    buffer itself is a global resource—something we cannot change. The memory manager
    itself does nothing to ensure this scenario cannot happen and, as a result, the
    user of this API might accidentally create a second memory manager. Note that,
    in our example, we explicitly created a second copy, but a second copy could occur
    by simply passing the memory manager around, inadvertently creating copies along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this issue, we must handle two specific scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating more than one instance of the memory manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying the memory manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To address both of these issues, let''s now show the singleton pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, we start with the constructor being marked as `private`.
    Marking the constructor as `private` prevents the use of the memory manager from
    creating their own instances of the memory manager. Instead, to get an instance
    of the memory manager, we will use the following `public` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This preceding function creates a static (that is, global) instance of the memory
    manager and then returns a reference to this instance. Using this function, the
    user of the API can only get an instance of the memory manager from this function,
    which always returns only a reference to the globally defined resource. In other
    words, there is no ability to create additional instances of the class without
    the compiler complaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step to creating the singleton class is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding, the copy and move constructors/operators are explicitly
    deleted. This addresses the second issue. By removing the copy constructor and
    operator, there is no ability to create a copy of the global resource, ensuring
    that the class only exists as a single global object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this singleton class, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cde66b36-11d4-4296-b84d-0a76d9e7da36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we attempt to create another instance of the memory manager ourselves, we
    would get an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, since the singleton class is a single, global resource, we can create
    wrappers to remove the verbosity, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This change can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding, the `constexpr` wrapper provides a simple means to
    remove the verbosity of our singleton class, something that would be difficult
    to do if the memory manager wasn't a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Extending your objects with the decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement the decorator pattern, which
    provides the ability to extend the functionality of a class without the need for
    inheritance, which by design is static in nature. This recipe is important because
    inheritance doesn't support the ability to extend a class at runtime, a problem
    the decorator pattern addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to implement the decorator pattern. To start,
    let''s look at a simple example: suppose we are writing a C++ application that
    will host a website. In our website, we need to define a button that users can
    click on, but we need to calculate the width of the button given an extra margin
    that adds to the total size of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, we have created a class called `margin` that returns
    the width of the margin in question (we will only focus on the width to simplify
    our example). We can then define our button as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, the total width of our button is the width of the
    button itself plus the width of the margin. We can then get the width of our button
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/697bea8a-1cdb-45ac-8431-53344285e825.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The problem with the preceding example is the button must always have a margin
    as the button directly inherits the margin class. There are ways to prevent this
    (for example, our button could have a configuration option that determines whether
    the button returns the width with the margin or not), but in this recipe, we will
    use the decorator pattern to solve this issue, allowing us to create two buttons:
    one button with a margin, and one button without a margin. Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s define the following pure virtual base class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding, the pure virtual base class defines the `width` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then implement our button as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding, the button inherits the base class and returns a
    width of `10`. Using the preceding, we can start that `button` is always a width
    of `10`, and the button has no concept of a margin.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a margin to the button, we first must create a decorator class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The decorator pattern starts with a private member to a `base` pointer, which
    is set in the decorator's constructor. The decorator also defines the `width`
    function but forwards the call to the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a margin class, which is a decorator, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding, the margin class returns the width of the object
    it is decorating with an additional `32` added to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create our two buttons as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c40ae265-8e79-4f31-8cea-5a48a0d65d00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The biggest advantage to the decorator pattern is it allows us to extend a
    class at runtime. For example, we can create a button with two margins if we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We could otherwise create another decorator. To demonstrate this, let''s extend
    our base class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding base class now defines a width, and a content width (the amount
    of space inside our button that we can actually use). Now, we can create our button
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, our button has a static width, and the content width
    is the same as the width itself minus 1 (to leave space for the button''s border).
    We then define our decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, the only difference is the decorator now has to
    forward the width and the content width functions. Our margin decorator looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the case with web programming, a margin increases the size of an object.
    It doesn''t change the space within an object for its internal contents, and hence,
    the margin returns the content width with no modifications. With the preceding
    changes, we can now add a padding decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The padding decorator is the opposite of the margin decorator. It doesn't change
    the size of an object, it reduces the total amount of space given to the internal
    contents of an object. As a result, it doesn't change the width, but it does decrease
    the size of the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a button using our new decorators, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, we create a button that has an added margin and
    added padding, which results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d871265-d736-4585-83b8-30b74a6b04e9.png)'
  prefs: []
  type: TYPE_IMG
- en: The decorator pattern provides the ability to create different buttons without
    the need for compile-time inheritance, which would require us to have a different
    button definition for every possible type of button we could think of. It should
    be noted, however, that the decorator pattern comes at a cost of added allocations
    and redirections of function calls, so this runtime flexibility does come at a
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: Adding communication with the observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement the observer pattern. The observer
    pattern provides the ability for a class to register with another class to receive
    notifications when an event occurs. The Qt language provides this feature through
    the use of its singles and slots mechanism while requiring a MOC compiler to make
    it work. This recipe is important as we will learn how to implement the observer
    pattern without the need for Qt, using standard C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The observer pattern provides the ability for an observer to be notified when
    an event occurs. To explain how this works, let''s start with the following pure
    virtual base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, we have defined `observer`, which must implement
    a `trigger()` function. We can then create two different versions of this pure
    virtual base class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we have created two different classes, both
    of which subclass the observer pure virtual class, overriding the trigger function.
    We can then implement a class that produces an event the observer might be interested
    in, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we start with `std::vector`, which stores any
    number of observers. We then provide a trigger function, which represents our
    event. When this function is executed, we loop through all of the observers and
    notify them of the event by calling their `trigger()` functions. Finally, we provide
    a function that allows an observer to subscribe to the event in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following demonstrates how these classes could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/381ac2b5-23b3-46d9-9c09-6eda2174b3b4.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding, when the alarm class is triggered, the observers
    are notified of the event and process the notification as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with static polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create polymorphism without the need for
    virtual inheritance. Instead, we will use compile-time inheritance (called static
    polymorphism). This recipe is important because static polymorphism does not incur
    the same performance and memory usage penalties as runtime, virtual inheritance
    (as no vTable is required), at the expense of readability and the inability to
    leverage the runtime benefits of virtual subclassing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to try the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main goals of polymorphism is that it provides the ability to override
    how an object executes a particular function while, at the same time, providing
    the ability to provide common logic across a set of objects. The problem with
    virtual inheritance is that the ability to override requires the use of a vTable
    (that is, a virtual table, which is an extra block of memory needed to handle
    virtual inheritance) if you wish to use the base class as your interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the previously defined base class. It provides a `foo()`
    function as pure (that is, a subclass must implement this function) while also
    providing its own common logic. We can then create two subclasses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, we subclass the base class and override the `foo()`
    function with subclass-specific functionality. We can then call the subclass-specific
    `foo()` functions from our base class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/523debdb-a99c-47b7-9ea3-d8aa453ca274.png)'
  prefs: []
  type: TYPE_IMG
- en: This type of runtime polymorphism requires the use of a vTable, which not only
    increases the memory footprint of each object but also incurs a performance penalty
    as each function call requires a vTable lookup. If the runtime properties of virtual
    inheritance are not needed, static polymorphism can provide the same functionality
    without the penalties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s define the base class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Like our previous example, the base class doesn't implement the `foo()` function
    but instead requires a subclass to implement this function (which is what allows
    a static cast to cast this to type `T`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then implement our subclasses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous example, the subclasses simply implement the `foo()` function.
    The difference, in this case, is the inheritance requires the use of the template
    parameter, which removes the need for the `foo()` function to override as the
    base class never uses a virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding static polymorphism allows us to execute the `foo()` function
    from our base class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding, the `test()` function does not have any information
    about each subclass. It only has information about the base (or interface) class.
    This `test()` function can be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This again results in the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a35eb7-3016-43dc-9871-77f0e57eb78f.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding, if the polymorphic types are known at compile time,
    static polymorphism can be used to remove the need for `virtual`, removing the
    need of a vTable. This type of logic is especially helpful when working with template
    classes where the base type is known but the subclass type is not (and is provided),
    allowing the template function to only need the base interface.
  prefs: []
  type: TYPE_NORMAL
