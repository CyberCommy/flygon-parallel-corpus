- en: STL Support and Proposals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Standard Template Library** (**STL**) has been a useful companion to C++
    programmers since the 90s. Starting from concepts such as generic programming
    and value semantics, it has grown to support many useful scenarios. In this chapter,
    we will look at how STL supports functional programming in C++ 17 and see what
    some of the new features that have been introduced in C++ 20 are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using functional features from the `<functional>` header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functional features from the `<numeric>` header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functional features from the `<algorithm>` header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::optional` and `std::variant`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++20 and the ranges library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.4.0c.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter15` folder. It includes and uses `doctest`, which is a single-header
    open source unit testing library. You can find it on its GitHub repository here:
    [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).'
  prefs: []
  type: TYPE_NORMAL
- en: The <functional> header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to start somewhere in our exploration of functional programming support
    in STL, and the header aptly named `<functional>` seems like a good start. This
    header defines the fundamental `function<>` type, which we can use for functions
    and have used a few times in this book for lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `function<>` type to store any type of function, be it a free
    function, a member function, or a lambda. Let''s look at an example of a free
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of a member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in order to call a member function through the `function<>`
    type, a valid reference to an object needs to be passed in. Think of it as the
    `*this` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this fundamental type, the `<functional>` header offers a few
    already-defined function objects that come in handy when using functional transformations
    on collections. Let''s look at a simple example of using the `sort` algorithm
    in combination with the defined `greater` function in order to sort a vector in
    descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<functional>` header defines the following useful function objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic operations**: `plus`, `minus`, `multiplies`, `divides`, `modulus`,
    and `negate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparisons**: `equal_to`, `not_equal_to`, `greater`, `less`, `greater_equal`,
    and `less_equal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical operations**: `logical_and`, `logical_or`, and `logical_not`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bit-wise operations**: `bit_and`, `bit_or`, and `bit_xor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These function objects spare us the trouble of encapsulating common operations
    in functions when we need to use them with higher-order functions. While it's
    a great collection, I would dare to suggest that an identity function would be
    equally useful, as weird as that may sound. Fortunately, it's easy to implement
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, that''s not all the `<functional>` header has to offer. The `bind`
    function implements partial functional application. We''ve seen it in action multiple
    times in this book, and you can see its usage in detail in [Chapter 5](daf883d3-a1ab-4969-8c81-7d3f33ed1934.xhtml),
    *Partial Application and Currying*. Its basic function is to take a function,
    bind one or more parameters to values, and obtain a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the `function<>` type allowing us to write lambdas, the predefined function
    objects reducing duplication, and `bind` allowing partial application, we have
    the bases for structuring our code in a functional way. But we couldn't do so
    effectively without higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: The <algorithm> header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<algorithm>` header file contains algorithms, with some of them implemented
    as higher-order functions. In this book, we have seen examples of use for many
    of them. Here''s a list of useful algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`all_of`, `any_of`, and `none_of`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_if` and `find_if_not`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count_if`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy_if`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generate_n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen how focusing on data and combining these higher-order functions
    to transform input data into the desired output is one of the ways in which you
    can think in small, composable, pure functions. We have also seen the drawbacks
    of this approach—the need to copy data, or make multiple passes through the same
    data—and we have seen how the new ranges library solves these issues in an elegant
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: While all of these functions are extremely useful, there is one function from
    the `<algorithm>` namespace that deserves a special mention—the implementation
    of the functional `map` operation, `transform`. The `transform` function takes
    an input collection and applies a lambda to each element of the collection, returning
    a new collection with the same number of elements but with the transformed values
    stored in it. This opens infinite possibilities of adapting data structures to
    our needs. Let's look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting one property of each object from a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We often need to get the value of a property from each element from a collection.
    In the following example, we use `transform` to get the list of all the names
    of people from a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we use a wrapper over `transform` and `transformAll` in order to
    avoid writing the boilerplate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Computing conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we need to compute whether a condition applies or not for a collection
    of elements. In the following example, we will compute whether people are minors
    or not by comparing their age with `18`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Converting everything into a displayable or serializable format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We often need to save or display a list. To do so, we need to convert each
    element of the list into a displayable or serializable format. In the following
    example, we are computing the JSON representation of the `Person` objects from
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Even with the infinite possibilities that are opened by the `transform` function,
    it becomes even more powerful in combination with the `reduce` (`accumulate` in
    C++) higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: The <numeric> header – accumulate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s interesting to see that the two higher-order functions that form the
    `map`/`reduce` pattern, one of the most commonly known patterns in functional
    programming, ended up in two different header files in C++. The `transform`/`accumulate`
    combination, requiring both the `<algorithm>` and the `<numeric>` header files,
    allow us to solve many problems that have the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection is provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection needs to be transformed into something else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An aggregated result needs to be computed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the total price with tax for a shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we have a `Product` structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also assume that we have different tax levels based on product categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we were given a list of products, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compute the total price, with and without tax. We also have a helper
    wrapper, `accumulateAll`, at our disposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the price without tax, we just need to get all the product prices
    and add them up. It''s a typical `map`/`reduce` scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, we `map` (`transform`) the list of `Products` into a list of prices,
    and then `reduce` (or `accumulate`) them into a single value—its total.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar, albeit more complex, process applies when we need the total price
    with tax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we `map` (`transform`) the list of `Products` with the list of prices
    with tax, then `reduce` (or `accumulate`) all the values into the total with tax.
  prefs: []
  type: TYPE_NORMAL
- en: In case you're wondering, the `doctest::Approx` function allows for a comparison
    between floating point numbers with a small rounding error.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a list into JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to convert each item from a list into JSON
    through a `transform` call. It''s easy to turn it into a full JSON list with the
    help of `accumulate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use `transform` to turn the list of people into a list of JSON representations
    for each object, and then we use `accumulate` to join them and use a few additional
    operations to add the front and back of the list representation in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `transform`/`accumulate` (or `map`/`reduce`) combination
    serves a lot of different uses, depending on the functions we pass into it.
  prefs: []
  type: TYPE_NORMAL
- en: Back to <algorithm> – find_if and copy_if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can accomplish a lot of things with `transform`, `accumulate`, and `any_of`/`all_of`/`none_of`.
    Sometimes, however, we need to filter out some of the data from collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual style of doing this is with `find_if`. However, `find_if` is cumbersome
    if what we need is to find all the items from a collection that fit a specific
    condition. Therefore, the best option to solve this problem in a functional way
    using the C++ 17 standard is `copy_if`. The following example uses `copy_if` to
    find all the minors in a list of people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <optional> and <variant>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed happy path cases a lot, which are when the data is valid for
    our data transformations. What do we do for edge cases and errors? Sure, in exceptional
    cases, we can throw exceptions or return error cases, but what about situations
    when we need to return an error message?
  prefs: []
  type: TYPE_NORMAL
- en: The functional way is to return data structures in these cases. After all, we
    need to return an output value even when the input isn't valid. But we hit a challenge—the
    type we need to return in the case of an error is an error type, while the type
    we need to return in the case of valid data is some more valid data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we have two structures that support us in these cases—`std::optional`
    and `std::variant`. Let''s take an example of a list of people, some of whom are
    valid and some of whom are invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last person has an invalid age. Let''s try to write, in a functional way,
    the code that will display the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To have a chain of transformations, we need to use the `optional` type, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this call, we obtain a list of pairs between the person and a value that
    is either `nullopt`, `minor`, or `major`. We can use this in the following `transform`
    call in order to obtain the list of strings according to the validity condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the call to accumulate creates the expected output string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check this out with a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: An alternative method is possible with the use of `variant`, if we need to,
    for example, return an error code combined with the person.
  prefs: []
  type: TYPE_NORMAL
- en: C++ 20 and the ranges library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed the ranges library at length in [Chapter 14](1edd5963-94e4-48dc-830f-8f201b3a39c7.xhtml),
    *Lazy Evaluation Using the Ranges Library*. If you can use it, either because
    you use C++ 20 or because you can use it as a third-party library, the previous
    function becomes extremely simple and much faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, finding the list of minors from a list of people is very easy with
    the ranges'' `view::filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the `isMinor` predicate, we can pass it to `view::filter` to find
    the minors from the list of people.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went on a tour of the functional programming features that
    are available in the STL of C++ 17, and of the new features in C++ 20\. With functions,
    algorithms, the help provided by `variant` and `optional` in error or edge cases,
    and the simplified and optimized code that can be achieved using the ranges library,
    we have pretty good support for functional programming features.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to move on to the next chapter and look at the C++ 17 language
    support for functional programming, and at the interesting things that are coming
    for functional programming in C++20.
  prefs: []
  type: TYPE_NORMAL
