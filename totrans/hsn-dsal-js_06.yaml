- en: Exploring Types of Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An algorithm in the computer science world is a set of instructions that takes
    finite space and time to execute. It starts at an initial state of the application
    and then performs a set of instructions step by step to achieve the end result.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms come in all shape and sizes, and all of them will fit the bill when
    you compare it with the overly generic definition of what an algorithm is. The
    big question is to decide which algorithm to use in which case and to make modifications
    to enhance its functionality based on the application's needs.
  prefs: []
  type: TYPE_NORMAL
- en: As I have shown in the use cases in previous chapters, most of the times, the
    algorithms that exist out there do not directly apply to the problems at hand.
    This is when a thorough understanding of the algorithm comes in handy. That is
    exactly what we will be doing in this chapter; we will take a look at a series
    of algorithms and then try to understand them better with the help of some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following algorithms with some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadth First Search (BFS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic Programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greedy Algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branch And Bound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's set up a bare-bones Node.js project before we start looking at the use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Node.js application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will use a very simple and light Node.js application, which
    will be holding our example scripts. The main goal here is to be able to run each
    of the use cases individually and not have an entire web (client or server) application
    for each of them. This helps us to have a uniform base project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create your application''s project folder. From the Terminal,
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to initialize a Node.js project, run the `init` command in the `root`
    folder of the project. This will prompt a series of questions to generate the `package.json`file.
    You can fill out the answers you wish or just click on returnto accept default
    values for the prompts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also install our beloved `lodash` to help us out with some of the trivial
    array and object manipulations and utilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once your project is ready to go, we can now add the necessary scripts in the
    project's root and then run them independently.
  prefs: []
  type: TYPE_NORMAL
- en: Using recursion to serialize data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is a very popular **programming paradigm** in which a problem statement
    can be broken down into several smaller problems, which can be defined in terms
    of itself. Recursion is usually confused with **divide and concur**,in which the
    problem statement is broken into non-overlapping sub-problems which can be solved
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will take a simple tree in which we have a root
    element followed by some child elements. We will be serializing this tree data,
    which can then be easily sent to the UI or persisted in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first create a folder called `recursion` within our project, which we
    created based on the preceding section. Then, we can create our `serializer.js`
    file within this folder, which will contain the class for serializing tree data.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudocode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s formulate our algorithm in pseudo code before implementing the recursive
    serializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Serializing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the pseudo code in place, the code for serialization becomes
    quite simple, let us add the following to a file called `recursion.js` next to
    our serializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding code we split the problem in terms of itself, that
    we determined what needs to be done for one level and then repeated the process
    for all the nodes **recursively. **Now, to consume this serialization method,
    create a `serialization.js` file and then add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding file with the `node recursion/serializer.js` command from
    the root of the project, we get the serialized response logged onto the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding response, you can note that the depth-first approach can
    be seen quite visibly based on our input dataset. `B` is a child of `A`, and `E`
    is a leaf child of `B` (indicated by the `^` symbol following `E`). Deserializing
    this serialized data using recursive is also a simple process, which you can try
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Using Dijkstra to determine the shortest path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until the preceding chapter, we explored only the simple ways of graph traversal, **Breadth
    First Search** (**BFS**) and **Depth First Search** (**DFS**). We did discuss
    in brief in the preceding chapter about Dijkstra and how it can help us determine
    the path from node **A** to node **B** in a graph, provided the graph is directed
    with weighted edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have just that. We have a graph of nodes (cities) and edges
    (approximate distance in miles), and we need to determine the fastest path for
    a user to reach a destination node from a given start node, provided other factors,
    such as speed, traffic, and weather, remain constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/abe94949-c722-4241-8575-b60cdde8783b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our trip starts from **San Francisco** (**SF**) and ends in **Phoenix** (**PX**).
    We have identified some intermediate cities in which the user can stop for rest
    or gas: **Monterey** (**MT**), **San Jose** (**SJ**), **Santa Barbara** (**SB**),
    **Los Angeles** (**LA**), **San Diego** (**SD**), **Fresno** (**FR**), **Bakersfield**
    (**BK**), and **Las Vegas** (**LV**). The distance to each of these cities is
    indicated by the weights that are associated with each of the edges between the
    cities.'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the pseudo code for implementing Dijkstra''s algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Dijkstra's algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s break down the implementation of Dijkstra''s algorithm based on the
    pseudo code described in the preceding section. The first step is to initialize
    all the variables. We will use one to track the costs of going through each node,
    one for tracking the path we are taking, and one more to track the already visited
    nodes to avoid recalculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our `solve()` method here has initialized the `costs` with the `cost` of the
    start node, and then set the end nodes `cost` as `Infinity` as that is not calculated
    yet. This means that at the beginning, the `costs` `set` would contain exactly
    the same data as the nodes and edges, going out from the start node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also calculated the paths accordingly, for example, since we are starting
    with `SF` in our example, the nodes—`SJ`, `MT`, and `SB`—were all reached from
    node `SF`. Following code explains how we can extract the lowest cost at each
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is probably the most important part of the code; we are calculating the
    `currentCheapestNode` based on the `costs` and the `visitedNodes` array, whose
    value in the first iteration will be `SJ`, as we can see from our preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the first node, we can then access its neighbors and update the
    `costs` of reaching these neighbors only if its `costs` are less than the current
    `cost` of the node. Also, if the cost is lesser, it is only logical that we would
    like to pass through this node to get to the end node, so we update the path to
    this neighbor as well. We then recursively repeat this process after marking the
    visited nodes. At the end of all iterations, we will have the updated costs of
    all the nodes and thus get the final cost of traveling to a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once all the nodes' `costs` are generated, we will simply backtrack the steps
    which were taken to reach the end node, and we can return the cost of the end
    node and the path taken to reach the end node. The Utility method to get the lowest
    cost unvisited node is added at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to consume this class, we can create a file called `shortest-path.js`
    under the `dijkstra` folder along with the `dijkstra.js` class that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to run this file, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command logs the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This, when visualized based on the original illustration, would be something
    like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/123c2c77-d526-47da-afb3-c71e80586f43.png)'
  prefs: []
  type: TYPE_IMG
- en: Using BFS to determine relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, it's not what it sounds like. We are not heading down a romantic path
    where we ask each other the difficult question. We are, however, talking about
    a simple graph, for example, a family tree (yes, trees are forms of the graph).
    In this example, we will use BFS to determine the shortest path between two nodes,
    which can then establish the relationship between those two nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first set up our test data so that we have the input graph ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1112a6c8-816d-40ac-a461-0a3782262a2d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can note from the preceding diagram that we have a small family in which
    nodes `A`, `E`, and `F` are siblings. `A` is married to `B` with nodes `C` and `D`
    as their children. Node `G` is a child of node `F`. Nothing complex or out of
    the ordinary here. We will use this data to determine the relationship between
    nodes `C` and `G`. You can surely look at the graph and tell it yourself, but
    that's not fun now, is it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now convert this into a format that our program can understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That got complex real quick, didn't it? This is a challenge with nodes where
    you want to establish a relationship (that is, labeled edges). Let's add this
    data to the `family.json` file and then take a look at the pseudo code for the
    BFS so that we can understand it better before implementing the same.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pseudo code for BFS is very similar to DFS, the main difference is that
    in BFS we iterate over all the connected nodes first before moving out to another
    level looking for our target node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Sounds very similar to the other example we worked on with DFS, doesn't it?
    That is because DFS and BFS are very similar in terms of how we approach the problem.
    The minor difference between the two is that we evaluate all connected nodes before
    spreading out one more level in BFS, whereas we select one of the connected nodes in
    case of DFS and then traverse it till the entire depth.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing BFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the previously discussed pseudo code, we will first simplify our
    data a little bit. There are two ways to do this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an adjacency matrix of the graph data that indicates the graph as a two-dimensional
    array of size *m x m*, which consists of 1s and 0s. *1s* indicates a connection
    between the *mrow* node with *mcolumn* and *0s* indicates no connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We simplify the dataset and only extract the nodes as a map in which the key
    is the node and the value is the list of nodes that it is connected to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although both approaches are fine ways of approaching the problem, the first
    option is usually preferred and is popular because the second option is of a higher
    code complexity because of all the overhead of sets and lists which come with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: However, right now, we don't need to worry about code complexity as we want
    to get the simplest possible solution out there, so we will go with the second
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will simplify the input data so that we have the transformed input
    to pass into the BFS algorithm that we are going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This basically sets the `transformedFamilyNodes` to the structure, which is
    described earlier, and in our case, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the class for our BFS search and then add a method to implement
    the search functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We accept the list of the original family nodes in the constructor and then
    the modified graph within our search method, which we will iterate upon. Then,
    why would we need the original family nodes? Because once we extract the path
    from one node to another, we will need to establish the relationship between them,
    which is recorded on the original unprocessed family nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will move on to implement the `search()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This was quick and painless. If you have noted, we are calling the `getRelationBetweenNodes`,
    which extracts the relations between the nodes based on the `familyNodes`, which
    are passed into the constructor once the path between two nodes is determined.
    This will extract the relationship of each node with the node that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the class ready, we are ready to invoke this by calling `node
    bfs/relations.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code logs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be represented visually as follows, based on the initial illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8b31bd8e-9e12-41f3-8f0a-7b702782be69.png)'
  prefs: []
  type: TYPE_IMG
- en: Using dynamic programming to build a financial planner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dynamic programming** (**DP**) is a very common and powerful approach to
    solve a certain class of problems. These problems present themselves in ways in
    which the main problem can be divided into sub-problems and the sub-problems can
    be broken down further into smaller problems, with some overlap in between.'
  prefs: []
  type: TYPE_NORMAL
- en: 'DP is often confused with recursion because of their similarities. A DP problem
    is only a type of problem, whereas recursion is part of the solution to such problems.
    There are two main ways in which we can approach solving such problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Break the problem down to sub-problems: If a sub-problem is solved already
    then return the saved solution, else solve and save the solution before returning
    it. This is also known as **memoization**. This is also known as a top-down approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Break the problem to sub-problems: Start solving the smallest sub-problem and
    work up. This approach is known as **bottom-up** approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we have a series of expenses that a user has; we will need
    to provide the user with all the possible outcomes based on a total, which is
    set by the user. We want the users to be able to pick and choose what option they
    like, thus we will go with the bottom-up approach. First, let''s break down the
    input data and then deduce the code from the pseudo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can note from the preceding code that the sample input data has been normalized
    for simplicity and code efficiency. Once we have that setup, we can create our
    pseudo code to understand the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, for this type of problem, we will be creating a two-dimensional
    array, where one dimension, (y), represents the values of the elements (that is,
    costs of each expense: 5, 3, 2, 2, and 5) and the other dimension, (x), represents
    the total cost incrementally (that is, 0 through 10). This is why we normalize
    our data in the first step—it helps us in terms of keeping our array small in
    terms of its dimensions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the array, we will assign each of the array positions—`arr[i][j]`—as
    true if any of the `0 to i` costs can create the `j` sum at any point, else it
    will be false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note in the preceding code that the algorithm is quite straightforward; we just
    break down the problem into smaller sub-problems and try to answer the question
    for each sub-problem while working its way up to the bigger problem. Once we are
    done constructing the array, we start from the last cell of the array and then
    traverse up and add a cell to the path taken, based on whether the current cell
    is true or not. The recursive process is stopped once we reach the total of `0`,
    that is, the first column.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the dynamic programming algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the approach, let's first create the class for our algorithm
    and add the `analyze()` method, which will first create the 2D array before generating
    the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the class is initialized, we will construct our 2D array with all the
    values in it set to `false`. We will then use this 2D array and update some of
    the values within it based on our conditions, which we will discuss shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can implement the `analyze()` method, which will set the appropriate
    values in each of the cells of the 2D array.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will set the values of the first column, and then of the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the first column is all true, a cell of the first row, on the other
    hand, is only true when the cost associated with that row is less than the sum,
    that is, we can build the requested sum with only one element. Next, we take the
    row and column that has been filled out and use that to build the rest of the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can implement the `generateOutcomes()` method, which will allow us
    to capture the possible paths recursively. When we list down our 2D array and
    take a look at what the generated array looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e297533-3d83-4957-ae0c-38525e7b20c5.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the preceding screenshot that the column `0` (i.e. sum `0`) is
    all `true`, and for row `0` (cost `5`), the only other column in which all the
    values are true is column 5 (i.e. sum `5`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, moving on to the next row, let's analyze the values one by one, for example,
    at that stage, the costs `5` and `3` (taken from the cost of the current row and
    the row above it) cannot add up to give a cost of `1` or `2` but it can give `3`,
    `5`, and `8`, so only they are `true` and the rest are `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, moving on to each of the next rows, we can try to import the value from
    the row above if it is true, if it is not then subtract the current row's cost
    from the column sum and check whether that column for the above row is true. This
    lets us determine whether the sum was determined by an earlier subset.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in row `3` column `1`, we just import from the parent row (remember
    that column `0` is always `true`). When we reach column `2`, we see that the parent
    rows' col `2` is `false`, so we offset this columns sum (`2`) with the current
    rows cost (`2`) so we end up with row `2` column `0` which is `true.` Hence we
    assign a value of `true` to row `2` column `2`, and then we continue this process
    for the next column till the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the entire array is constructed, we will need to start at the very end,
    which in this case, is `array[4][10]`, and recursively traverse up until we reach
    the sum of `0` or reach the top with a nonzero sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this can be consumed in our planner to generate the list of options for
    our users to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the previous code logs the different combinations which fit our budget,
    resulting in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using a greedy algorithm to build a travel itinerary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A greedy algorithm is one in which a problem is broken down into smaller sub-problems
    and a solution to each of these sub-problems is pieced together based on a locally
    optimized choice at each step. This means that, in case of weighted edge graphs,
    for example, the next node is picked on the basis of whatever provides the least
    cost to travel from the current node. This may not be the best path to take, but,
    in the case of greedy algorithms, getting a solution is the main goal rather than
    getting the perfect or the ideal solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this use case, we have a set of cities along with the weight associated with
    traveling to each of these cities *(cost to travel/stay + enjoyment factor and
    so on)*. The objective is to figure out a way in which we want to travel and visit
    these cities so that the travel is complete and fun. Of course, for a given set
    of cities, you can travel to them in many possible ways, but that does not guarantee
    that the path is going to be optimized. To solve this problem, we will be using
    Kruskal's minimum spanning tree algorithm, which is a type of greedy algorithm
    that will generate the best possible solution for us. A spanning tree in a graph
    is one in which all the nodes are connected and there are no cycles between the
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that our input data is of the following format, which is the
    same as what we have seen earlier in the Dijkstra example, except that we are
    not defining any direction between the nodes, allowing us to travel from either
    direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da5896ae-c1eb-4e81-9f3a-932850db3b74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This data can be programmatically written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'From this information, we can extract the unique edges, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Understanding spanning trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go ahead and implement the pseudo code and the code, let's take some
    time to understand what spanning trees are and how we can employ them to simplify
    the problems as stated previously.
  prefs: []
  type: TYPE_NORMAL
- en: A spanning tree within a graph is a series of edges that can connect all the
    nodes without any cycles within them. By saying that, it is obvious that there
    can be more than one spanning tree for any given graph. In terms of our example,
    it makes more sense now that we want to generate the **minimum spanning tree**
    (**MST**), that is, the spanning tree in which the combined edge weight is the
    minimum.
  prefs: []
  type: TYPE_NORMAL
- en: However, how do we generate the spanning tree and make sure that it has the
    minimum value? The solution, although not quite obvious, is quite simple. Let's
    explore the approach with the pseudo code.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem at hand now has boiled down to the following—connect all the nodes
    of our graph with least weight edges and no cycles. To achieve this, first, we
    will need to isolate all our edges and sort by weight in an increasing order.
    Then, we employ a technique called `union by rank` to get the final list of the
    edges, which can be used to create the MST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `find()` method, we will perform a small optimization called path compression.
    Sounds fancy, but it really isn''t. Let''s say that we are at a node `A` whose
    parent is node `B` and its parent is node `C`. When we are trying to determine
    that, we only parse this entire path once, and for next time, we remember that
    the parent of node `A` is ultimately node `C`. The way we do it is also relatively
    easy—every time we traverse up the tree for a node, we will be updating its `parent`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a minimum spanning tree using a greedy algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have the dataset up as described earlier. Now, we will generate
    the edges from that data and then pass it on to our spanning tree class to generate
    the MST. So let us add the following code to `greeds/travel.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Our MST class can be added to `greedy/mst.js` which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code would log the edges, which will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once connected, these paths will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9a3e0e6-cf76-4109-b6f3-e6c6b355af4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Using branch and bound algorithm to create a custom shopping list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The branch and bound algorithm are applied to a set of problems, which involves
    combinational optimization. What that means is that we can have a problem at hand
    that does not necessarily have one correct solution, but with the information
    that we have, we will need to generate the best possible solution out of the finite
    yet very large number of available solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the branch and bound algorithm to optimize and solve a particular
    class of dynamic programming problems known as the 0/1 knapsack problem. In this
    case, consider that we have a shopping list in which we have a list of items,
    their cost in dollars, and their importance (value) to you on a scale of 0 to
    10\. For example, consider the following sample list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Given the list, we now need to find the best possible combination to maximize
    the value, given a fixed budget (for example, $10). The algorithm is called 0/1
    knapsack because the decision that you can take is only a binary, that is, either
    take an item or drop it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to understand what the problem statement is from a mathematical
    standpoint. We want to maximize the value while staying within our budget, so
    if we assume that we have `e[1], e[2], e[3]` and so on up to `e[n]` elements, and
    know that each of these elements can either be picked (which will assign it a
    value of 1) or not picked (which will assign it a value of 0), to determine the
    total value, we can formulate it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/226735ec-f528-40d7-95b2-bb927ad02550.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While we try to keep the value maximized, we also want to keep the total cost
    less than the budget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/099d05c5-9ea6-4a49-90e7-4324ad5763e1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Okay, great, now we know the problem, but what can be the solution for this?
    Since we know that the value is always going to be either 0 or 1, we can create
    a binary tree to represent the state space of our solution and then layout a branch
    for each possibility at every node; for example in our case, we will have *2*^(*n* )possibilities
    (n = 7), which is a total of 128\. Now, going through each of the 128 possibilities
    does not sound very optimal, and we can note that this number is going to increase
    exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding branch and bound algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before writing the pseudo code, let's break down the solution for a better understanding.
    What we want to do is to create a binary tree, and at each level of the tree we
    want to assign the cost to get to the node, the value of the node and the upper
    bound of the cost that it takes to reach to that node.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, how do we calculate the upper bound of the tree? To determine that,
    let''s first break our problem down into smaller parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have that, we will rearrange our elements in the decreasing order of
    our value to cost ratio because we want to pick the elements with the highest
    value for the least cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To determine the upper bound, we will now use a greedy algorithm (elements arranged
    in a decreasing order) in which we will allow fractional values to get the highest
    possible upper bound.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's pick the obvious first element, which has a value of `12` and cost
    of `4`, so the total upper bound of value at this step is `12` and the total cost
    is `4`, which is less than the maximum, that is, `10`. Then, we move on to the
    next element, where the upper bound now becomes *12+6=18* and the cost is *4+2
    = 6* , which is still less than `10`. Then, we pick the next, which brings the
    upper bound of the value to *18+9=27* and the cost to *6+3=9*. If we take the
    next element with a cost of `3`, we will go over the maximum cost, so we will
    take it fractionally, that is, *(remaining cost/cost of the item) * value of the
    item which would be equal to (1/3)*6*, which is `2`. So, the upper bound of the
    root element is *27+2 = 29*.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can now say that under the given constraints, such as the cost and value,
    the upper bound value which we can get is `29`. Now that we have the upper bound
    on the value, we can create a root element for our binary tree with this upper
    bound value and a cost and value of 0 each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the root nodes maximum upper bound is calculated, we can repeat this process
    recursively for the subsequent nodes starting from the first node. At each level,
    we will update the cost, value, and upper bound in such a way that it reflects
    what the values would be when a node is picked versus when it is not picked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d8282701-a7f3-4e8e-bc5c-23064eb18a5d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, you can note that we have built the state space tree
    for a few levels, which show what the state of each of the nodes would be when
    the branch is taken and also when it is not taken. As you can see, few of the
    branches are below the maximum upper bound of **27** (which we calculated earlier),
    whereas one of the branches goes over **27**, so we can remove that branch from
    further consideration. Now, at each of these steps, our main goal is to keep traversing
    the state space while increasing the value accumulated and staying below or equal
    to the upper bound. Any branch that deviates too far or exceeds from the upper
    bound can be safely removed from consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing branch and bound algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed how we can construct the state space tree step by
    step for each of the elements that are available, but that is not necessary, we
    only need to add the nodes selectively based on our bounds and the maximum cost
    that has been set.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does that mean for us in implementation? We will take nodes one by
    one, consider what would happen if we include it or if we do not, and then add
    it to the queue for further processing if it falls under the conditions (bounds)
    that are set by us (maximum overall cost and the maximum upper bound of each branch).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already have a list of items with us, we will first do some transformations
    to make the rest of the algorithm simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the costs and the values sorted and extracted, we can then implement
    the algorithm to calculate the maximum value at each with, and without, the current
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the same algorithm, we get the results with the maximum value returned
    to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This logs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When not to use brute-force algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brute-force algorithm is a type of problem-solving technique in which every
    possible solution to a particular problem is explored before either selecting
    or rejecting one of the solutions as the final solution to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: When posed with a challenge, the most natural reaction is to brute-force the
    solution or try to brute-force it first and then optimize it later. However, is
    that really the best way to approach such problems? Are there better ways of doing
    things?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is most definitely yes, as we have seen very well in the entire chapter
    so far. brute-force is not the solution until it is the only solution. Sometimes,
    we may feel that we are creating a custom algorithm to find the solution to our
    given problem, but we need to ask ourselves if we are really going through all
    the possible solutions to the problem, if we are, then that's brute-force again.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, brute-force is not one fixed algorithm for us to detect it. The
    approach keeps changing with the problem statements, hence the need to see if
    we are trying to generate all solutions and avoid doing that.
  prefs: []
  type: TYPE_NORMAL
- en: However, you may ask, how do I know when to brute-force a problem and when should
    I try to find an optimal solution? How do I know a more optimal solution or algorithm
    exists for such a problem?
  prefs: []
  type: TYPE_NORMAL
- en: There is no quick and dirty way to tell if there are easier solutions than brute-force
    to calculate any solutions. For example, a problem can be solved in a brute-force
    manner, take any of the examples in this chapter, for instance. We can come up
    with a list of all possibilities (however hard it may be to generate this list,
    as a large number of them may exist) and then shortlist the ones that we deem
    as solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In our example to generate the shortest path, we used Dijkstra's algorithm to
    use the cost associated with traveling to each city. A brute-force solution of
    this would be to calculate all the paths available in the graph from start to
    end nodes and then calculate the cost of each of the paths and then ultimately
    select the path with the lowest cost.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about the problem statement can greatly help with reducing the complexity
    of problems and also help us avoid brute-force solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-force Fibonacci generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a Fibonacci generator, for example, and brute-force the generation
    of some numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we are not applying any domain knowledge; we simply take
    the two previous numbers from the series and add them. This is a fine way of doing
    it, but we can see that there are some improvements to be made here.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Fibonacci generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use recursion to generate Fibonacci series as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we apply the same concept as earlier, that the next number
    is a summation of the two previous numbers of the Fibonacci series numbers. However,
    we are relying on recursion to recalculate all the old values as and when a new
    value is demanded.
  prefs: []
  type: TYPE_NORMAL
- en: Memoized Fibonacci generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can further enhance the generator using memoization, which is a technique
    of calculating a value only once and remembering it for later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are relying on an in-memory variable called `memory` to store and retrieve
    the previously calculated value of the Fibonacci number within the series, hence
    avoiding a series of duplicate calculations.
  prefs: []
  type: TYPE_NORMAL
- en: If you log the time taken for each of these methods, you can see that as the
    size of the input number increases, the performance does go down significantly
    for the recursive approach. Just because an algorithm is brute-force, that does
    not mean it is the worst/slowest/costliest. However, with a simple change to recursion(memoization),
    you can see that it is again faster than the brute-force technique.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to code the solution for any problem, the biggest help is to reduce
    unnecessary space and time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the important types of algorithms and implemented
    them for some example use cases. We also discussed various algorithmic optimization
    techniques, such as memoization and backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss some of the sorting techniques and apply
    them to solve some examples.
  prefs: []
  type: TYPE_NORMAL
