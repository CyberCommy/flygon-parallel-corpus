- en: Chapter 11. User Authentication in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A significant percentage of modern, interactive websites allow some form of
    user interaction-from allowing simple comments on a blog, to full editorial control
    of articles on a news site. If a site offers any sort of ecommerce, authentication,
    and authorization of paying customers is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Just managing users-lost usernames, forgotten passwords, and keeping information
    up to date-can be a real pain. As a programmer, writing an authentication system
    can be even worse.
  prefs: []
  type: TYPE_NORMAL
- en: Lucky for us, Django provides a default implementation for managing user accounts,
    groups, permissions, and cookie-based user sessions out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Like most things in Django, the default implementation is fully extendible and
    customizable to suit your project's needs. So let's jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Django authentication system handles both authentication and authorization.
    Briefly, authentication verifies a user is who they claim to be, and authorization
    determines what an authenticated user is allowed to do. Here the term authentication
    is used to refer to both tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The authentication system consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Permissions: Binary (yes/no) flags designating whether a user may perform a
    certain task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Groups: A generic way of applying labels and permissions to more than one user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A configurable password hashing system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms for managing user authentication and authorization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View tools for logging in users, or restricting content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pluggable backend system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The authentication system in Django aims to be very generic and doesn''t provide
    some features commonly found in web authentication systems. Solutions for some
    of these common problems have been implemented in third-party packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Password strength checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling of login attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication against third-parties (OAuth, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Django authentication system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's authentication system in its default configuration has evolved to serve
    the most common project needs, handling a reasonably wide range of tasks, and
    has a careful implementation of passwords and permissions. For projects where
    authentication needs differ from the default, Django also supports extensive extension
    and customization of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: User objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`User` objects are the core of the authentication system. They typically represent
    the people interacting with your site and are used to enable things like restricting
    access, registering user profiles, associating content with creators and so on.
    Only one class of user exists in Django''s authentication framework, that is,
    `superusers` or admin `staff` users are just user objects with special attributes
    set, not different classes of user objects. The primary attributes of the default
    user are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`username`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating superusers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create superusers using the `createsuperuser` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will be prompted for a password. After you enter one, the user will be created
    immediately. If you leave off the `-username` or the `-email` options, it will
    prompt you for those values.
  prefs: []
  type: TYPE_NORMAL
- en: Creating users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest, and least error prone way to create and manage users is through
    the Django admin. Django also provides built in views and forms to allow users
    to log in and out and change their own password. We will be looking at user management
    via the admin and generic user forms a bit later in this chapter, but first, let's
    look at how we would handle user authentication directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most direct way to create users is to use the included `create_user()`
    helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Changing passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django does not store raw (clear text) passwords on the user model, but only
    a hash. Because of this, do not attempt to manipulate the password attribute of
    the user directly. This is why a helper function is used when creating a user.
    To change a user''s password, you have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`manage.py changepassword username` offers a method of changing a User''s password
    from the command line. It prompts you to change the password of a given user which
    you must enter twice. If they both match, the new password will be changed immediately.
    If you do not supply a user, the command will attempt to change the password of
    the user whose username matches the current system user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also change a password programmatically, using `set_password()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Changing a user's password will log out all their sessions if the `SessionAuthenticationMiddleware`
    is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django comes with a simple permissions system. It provides a way to assign
    permissions to specific users and groups of users. It''s used by the Django admin
    site, but you''re welcome to use it in your own code. The Django admin site uses
    permissions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to view the *add* form and add an object is limited to users with the
    *add* permission for that type of object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to view the change list, view the *change* form and change an object
    is limited to users with the *change* permission for that type of object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to delete an object is limited to users with the *delete* permission
    for that type of object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Permissions can be set not only per type of object, but also per specific object
    instance. By using the `has_add_permission()`, `has_change_permission()` and `has_delete_permission()`
    methods provided by the `ModelAdmin` class, it''s possible to customize permissions
    for different object instances of the same type. `User` objects have two many-to-many
    fields: `groups` and `user_permissions`. `User` objects can access their related
    objects in the same way as any other Django model.'
  prefs: []
  type: TYPE_NORMAL
- en: Default permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `Django.contrib.auth` is listed in your `INSTALLED_APPS` setting, it will
    ensure that three default permissions-add, change, and delete-are created for
    each Django model defined in one of your installed applications. These permissions
    will be created for all new models each time you run `manage.py migrate`.
  prefs: []
  type: TYPE_NORMAL
- en: Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Django.contrib.auth.models.Group` models are a generic way of categorizing
    users so you can apply permissions, or some other label, to those users. A user
    can belong to any number of groups. A user in a group automatically has the permissions
    granted to that group. For example, if the group `Site editors` has the permission
    `can_edit_home_page`, any user in that group will have that permission.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond permissions, groups are a convenient way to categorize users to give
    them some label, or extended functionality. For example, you could create a group
    `Special users`, and you could write code that could, say, give them access to
    a members-only portion of your site, or send them members-only email messages.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatically creating permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While custom permissions can be defined within a model''s `Meta` class, you
    can also create permissions directly. For example, you can create the `can_publish`
    permission for a `BookReview` model in `books`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The permission can then be assigned to a `User` via its `user_permissions` attribute
    or to a `Group` via its `permissions` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Permission caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ModelBackend` caches permissions on the `User` object after the first time
    they need to be fetched for a permissions check. This is typically fine for the
    request-response cycle since permissions are not typically checked immediately
    after they are added (in the admin, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are adding permissions and checking them immediately afterward, in a
    test or view for example, the easiest solution is to re-fetch the `User` from
    the database. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Authentication in web requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django uses sessions and middleware to hook the authentication system into
    `request` objects. These provide a `request.user` attribute on every request which
    represents the current user. If the current user has not logged in, this attribute
    will be set to an instance of `AnonymousUser`, otherwise it will be an instance
    of `User`. You can tell them apart with `is_authenticated()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to log a user in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To log a user in, from a view, use `login()`. It takes an `HttpRequest` object
    and a `User` object. `login()` saves the user''s ID in the session, using Django''s
    session framework. Note that any data set during the anonymous session is retained
    in the session after a user logs in. This example shows how you might use both
    `authenticate()` and `login()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Calling** `authenticate()` **first**'
  prefs: []
  type: TYPE_NORMAL
- en: When you're manually logging a user in, you must call `authenticate()` before
    you call `login()`. `authenticate()` sets an attribute on the `User` noting which
    authentication backend successfully authenticated that user, and this information
    is needed later during the login process. An error will be raised if you try to
    login a user object retrieved from the database directly.
  prefs: []
  type: TYPE_NORMAL
- en: How to log a user out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To log out a user who has been logged in via `login()`, use `logout()` within
    your view. It takes an `HttpRequest` object and has no return value. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that `logout()` doesn't throw any errors if the user wasn't logged in.
    When you call `logout()`, the session data for the current request is completely
    cleaned out. All existing data is removed. This is to prevent another person from
    using the same web browser to log in and have access to the previous user's session
    data.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to put anything into the session that will be available to the user
    immediately after logging out, do that after calling `logout()`.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting access to logged-in users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The raw way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simple, raw way to limit access to pages is to check `request.user.is_authenticated()`
    and either redirect to a login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '... or display an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The login_required decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a shortcut, you can use the convenient `login_required()` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`login_required()` does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user isn''t logged in, redirect to `LOGIN_URL`, passing the current
    absolute path in the query string. Example: `/accounts/login/?next=/reviews/3/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is logged in, execute the view normally. The view code is free to
    assume the user is logged in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the path that the user should be redirected to upon successful
    authentication is stored in a query string parameter called `next`. If you would
    prefer to use a different name for this parameter, `login_required()` takes an
    optional `redirect_field_name` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you provide a value to `redirect_field_name`, you will most likely
    need to customize your login template as well, since the template context variable
    which stores the redirect path will use the value of `redirect_field_name` as
    its key rather than `next` (the default). `login_required()` also takes an optional
    `login_url` parameter. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you don''t specify the `login_url` parameter, you''ll need to
    ensure that the `LOGIN_URL` and your login view are properly associated. For example,
    using the defaults, add the following lines to your URLconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `LOGIN_URL` also accepts view function names and named URL patterns. This
    allows you to freely remap your login view within your URLconf without having
    to update the setting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The `login_required` decorator does NOT check the `is_active flag`
    on a user.'
  prefs: []
  type: TYPE_NORMAL
- en: Limiting access to logged-in users that pass a test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To limit access based on certain permissions or some other test, you''d do
    essentially the same thing as described in the previous section. The simple way
    is to run your test on `request.user` in the view directly. For example, this
    view checks to make sure the user has an email in the desired domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As a shortcut, you can use the convenient `user_passes_test` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`user_passes_test()` takes a required argument: a callable that takes a `User`
    object and returns `True` if the user is allowed to view the page. Note that `user_passes_test()`
    does not automatically check that the `User` is not anonymous. `user_passes_test()`
    takes two optional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`login_url`. Lets you specify the URL that users who don''t pass the test will
    be redirected to. It may be a login page and defaults to `LOGIN_URL` if you don''t
    specify one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect_field_name`. Same as for `login_required()`. Setting it to `None`
    removes it from the URL, which you may want to do if you are redirecting users
    that don''t pass the test to a non-login page where there''s no *next page*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The permission_required() decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s a relatively common task to check whether a user has a particular permission.
    For that reason, Django provides a shortcut for that case-the `permission_required()`
    decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `has_perm()` method, permission names take the form `<app label>.<permission
    codename>` (that is `reviews.can_vote` for a permission on a model in the `reviews`
    application). The decorator may also take a list of permissions. Note that `permission_required()`
    also takes an optional `login_url` parameter. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As in the `login_required()` decorator, `login_url` defaults to `LOGIN_URL.`
    If the `raise_exception` parameter is given,the decorator will raise `PermissionDenied`,
    prompting the 403 (HTTP Forbidden) view instead of redirecting to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: Session invalidation on password change
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your `AUTH_USER_MODEL` inherits from `AbstractBaseUser`, or implements its
    own `get_session_auth_hash()` method, authenticated sessions will include the
    hash returned by this function. In the `AbstractBaseUser` case, this is a **Hash
    Message Authentication Code** (**HMAC**) of the password field.
  prefs: []
  type: TYPE_NORMAL
- en: If the `SessionAuthenticationMiddleware` is enabled, Django verifies that the
    hash sent along with each request matches the one that's computed server-side.
    This allows a user to log out of all of their sessions by changing their password.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default password change views included with Django, `Django.contrib.auth.views.password_change()`
    and the `user_change_password` view in the `Django.contrib.auth` admin, update
    the session with the new password hash so that a user changing their own password
    won''t log themselves out. If you have a custom password change view and wish
    to have similar behavior, use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes the current request and the updated user object from which
    the new session hash will be derived and updates the session hash appropriately.
    Example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since `get_session_auth_hash()` is based on `SECRET_KEY`, updating your site
    to use a new secret will invalidate all existing sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django provides several views that you can use for handling login, logout, and
    password management. These make use of the built-in auth forms but you can pass
    in your own forms as well. Django provides no default template for the authentication
    views-however, the following template context is documented for each view.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different methods to implement these views in your project, however, the
    easiest and most common way is to include the provided URLconf in `Django.contrib.auth.urls`
    in your own URLconf, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will make each of the views available at a default URL (detailed in next
    section).
  prefs: []
  type: TYPE_NORMAL
- en: The built-in views all return a `TemplateResponse` instance, which allows you
    to easily customize the response data before rendering. Most built-in authentication
    views provide a URL name for easier reference.
  prefs: []
  type: TYPE_NORMAL
- en: Login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logs a user in.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default URL: ** `/login/`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`template_name`: The name of a template to display for the view used to log
    the user in. Defaults to `registration/login.html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect_field_name`: The name of a `GET` field containing the URL to redirect
    to after login. Defaults to `next`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authentication_form`: A callable (typically just a form class) to use for
    authentication. Defaults to `AuthenticationForm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s what `login` does:'
  prefs: []
  type: TYPE_NORMAL
- en: If called via `GET`, it displays a login form that POSTs to the same URL. More
    on this in a bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If called via `POST` with user submitted credentials, it tries to log the user
    in. If login is successful, the view redirects to the URL specified in `next`.
    If `next` isn't provided, it redirects to `LOGIN_REDIRECT_URL` (which defaults
    to `/accounts/profile/`). If login isn't successful, it redisplays the login form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's your responsibility to provide the HTML for the login template, called
    `registration/login.html` by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Template Context**'
  prefs: []
  type: TYPE_NORMAL
- en: '`form`: A `Form` object representing the `AuthenticationForm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: The URL to redirect to after successful login. This may contain a query
    string, too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`site`: The current `Site`, according to the `SITE_ID` setting. If you don''t
    have the site framework installed, this will be set to an instance of `RequestSite`,
    which derives the site name and domain from the current `HttpRequest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`site_name`: An alias for `site.name`. If you don''t have the site framework
    installed, this will be set to the value of `request.META[''SERVER_NAME'']`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you'd prefer not to call the template `registration/login.html`, you can
    pass the `template_name` parameter via the extra arguments to the view in your
    URLconf.
  prefs: []
  type: TYPE_NORMAL
- en: Logout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logs a user out.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default URL: ** `/logout/`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`next_page`: The URL to redirect to after logout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template_name`: The full name of a template to display after logging the user
    out. Defaults to `registration/logged_out.html` if no argument is supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect_field_name`: The name of a `GET` field containing the URL to redirect
    to after log out. Defaults to `next`. Overrides the `next_page` URL if the given
    `GET` parameter is passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template context:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: The string *Logged out*, localized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`site`: The current `Site`, according to the `SITE_ID` setting. If you don''t
    have the site framework installed, this will be set to an instance of `RequestSite`,
    which derives the site name and domain from the current `HttpRequest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`site_name`: An alias for `site.name`. If you don''t have the site framework
    installed, this will be set to the value of `request.META[''SERVER_NAME'']`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logout_then_login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logs a user out, then redirects to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default URL:** None provided.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`login_url`: The URL of the login page to redirect to. Defaults to `LOGIN_URL`
    if not supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password_change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allows a user to change their password.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default URL: ** `/password_change/`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`template_name`: The full name of a template to use for displaying the password
    change form. Defaults to `registration/password_change_form.html` if not supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post_change_redirect`: The URL to redirect to after a successful password
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password_change_form`: A custom *change password* form which must accept a
    `user` keyword argument. The form is responsible for actually changing the user''s
    password. Defaults to `PasswordChangeForm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template context:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`form`: The password change form (see `password_change_form` from the preceding
    list).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password_change_done
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The page shown after a user has changed their password.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default URL: ** `/password_change_done/`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`template_name`: The full name of a template to use. Defaults to `registration/password_change_done.html`
    if not supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password_reset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allows a user to reset their password by generating a one-time use link that
    can be used to reset the password, and sending that link to the user's registered
    email address.
  prefs: []
  type: TYPE_NORMAL
- en: If the email address provided does not exist in the system, this view won't
    send an email, but the user won't receive any error message either. This prevents
    information leaking to potential attackers. If you want to provide an error message
    in this case, you can subclass `PasswordResetForm` and use the `password_reset_form`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Users flagged with an unusable password aren't allowed to request a password
    reset to prevent misuse when using an external authentication source like LDAP.
    Note that they won't receive any error message since this would expose their account's
    existence but no mail will be sent either.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default URL: ** `/password_reset/`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`template_name`: The full name of a template to use for displaying the password
    reset form. Defaults to `registration/password_reset_form.html` if not supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email_template_name`: The full name of a template to use for generating the
    email with the reset password link. Defaults to `registration/password_reset_email.html`
    if not supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subject_template_name`: The full name of a template to use for the subject
    of the email with the reset password link. Defaults to `registration/password_reset_subject.txt`
    if not supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password_reset_form`: Form that will be used to get the email of the user
    to reset the password for. Defaults to `PasswordResetForm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_generator`: Instance of the class to check the one-time link. This will
    default to `default_token_generator`, it''s an instance of `Django.contrib.auth.tokens.PasswordResetTokenGenerator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post_reset_redirect`: The URL to redirect to after a successful password reset
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from_email`: A valid email address. By default, Django uses the `DEFAULT_FROM_EMAIL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html_email_template_name`: The full name of a template to use for generating
    a `text/html` multipart email with the password reset link. By default, HTML email
    is not sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template context:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`form`: The form (see `password_reset_form`) for resetting the user''s password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Email template context:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`email`: An alias for `user.email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: The current `User`, according to the `email` form field. Only active
    users are able to reset their passwords (`User.is_active is True`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`site_name`: An alias for `site.name`. If you don''t have the site framework
    installed, this will be set to the value of `request.META[''SERVER_NAME'']`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain`: An alias for `site.domain`. If you don''t have the site framework
    installed, this will be set to the value of `request.get_host()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protocol`: http or https'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid`: The user''s primary key encoded in base 64.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token`: Token to check that the reset link is valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sample `registration/password_reset_email.html` (email body template):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The same template context is used for subject template. Subject must be single
    line plain text string.
  prefs: []
  type: TYPE_NORMAL
- en: Password_reset_done
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The page shown after a user has been emailed a link to reset their password.
    This view is called by default if the `password_reset()` view doesn't have an
    explicit `post_reset_redirect` URL set. **Default URL: ** `/password_reset_done/`
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the email address provided does not exist in the system, the user is inactive,
    or has an unusable password, the user will still be redirected to this view but
    no email will be sent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`template_name`: The full name of a template to use. Defaults to `registration/password_reset_done.html`
    if not supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password_reset_confirm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Presents a form for entering a new password.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default URL: ** `/password_reset_confirm/`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`uidb64`: The user''s id encoded in base 64\. Defaults to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token`: Token to check that the password is valid. Defaults to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template_name`: The full name of a template to display the confirm password
    view. Default value is `registration/password_reset_confirm.html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_generator`: Instance of the class to check the password. This will default
    to `default_token_generator`, it''s an instance of `Django.contrib.auth.tokens.PasswordResetTokenGenerator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_password_form`: Form that will be used to set the password. Defaults to
    `SetPasswordForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post_reset_redirect`: URL to redirect after the password reset done. Defaults
    to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template context:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`form`: The form (see `set_password_form` ) for setting the new user''s password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validlink`: Boolean, True if the link (combination of `uidb64` and `token`)
    is valid or unused yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password_reset_complete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Presents a view which informs the user that the password has been successfully
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Default URL: ** `/password_reset_complete/`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`template_name`: The full name of a template to display the view. Defaults
    to `registration/password_reset_complete.html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_app`: A hint indicating which application contains the current view.
    See the namespaced URL resolution strategy for more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_context`: A dictionary of context data that will be added to the default
    context data passed to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The redirect_to_login helper function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django provides a convenient function, `redirect_to_login` that can be used
    in a view for implementing custom access control. It redirects to the login page,
    and then back to another URL after a successful login.
  prefs: []
  type: TYPE_NORMAL
- en: '**Required arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`next`: The URL to redirect to after a successful login.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`login_url`: The URL of the login page to redirect to. Defaults to `LOGIN_URL`
    if not supplied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect_field_name`: The name of a `GET` field containing the URL to redirect
    to after log out. Overrides `next` if the given `GET` parameter is passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don't want to use the built-in views, but want the convenience of not
    having to write forms for this functionality, the authentication system provides
    several built-in forms located in `Django.contrib.auth.forms` (*Table 11-1*).
  prefs: []
  type: TYPE_NORMAL
- en: The built-in authentication forms make certain assumptions about the user model
    that they are working with. If you're using a custom User model, it may be necessary
    to define your own forms for the authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: '| Form Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AdminPasswordChangeForm` | A form used in the admin interface to change
    a user''s password. Takes the `user` as the first positional argument. |'
  prefs: []
  type: TYPE_TB
- en: '| `AuthenticationForm` | A form for logging a user in. Takes `request` as its
    first positional argument, which is stored on the form instance for use by subclasses.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PasswordChangeForm` | A form for allowing a user to change their password.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PasswordResetForm` | A form for generating and emailing a one-time use link
    to reset a user''s password. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetPasswordForm` | A form that lets a user change their password without
    entering the old password. |'
  prefs: []
  type: TYPE_TB
- en: '| `UserChangeForm` | A form used in the admin interface to change a user''s
    information and permissions. |'
  prefs: []
  type: TYPE_TB
- en: '| `UserCreationForm` | A form for creating a new user. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.1: Django''s built-in authentication forms'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating data in templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The currently logged-in user and their permissions are made available in the
    template context when you use `RequestContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When rendering a template `RequestContext`, the currently logged-in user, either
    a `User` instance or an `AnonymousUser` instance, is stored in the template variable
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ user }}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This template context variable is not available if a `RequestContext` is not
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The currently logged-in user's permissions are stored in the template variable
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ perms }}`. This is an instance of `Django.contrib.auth.context_processors.PermWrapper`,
    which is a template-friendly proxy of permissions. In the `{{ perms }}` object,
    single-attribute lookup is a proxy to `User.has_module_perms`. This example would
    display `True` if the logged-in user had any permissions in the `foo` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Two-level-attribute lookup is a proxy to `User.has_perm`. This example would
    display `True` if the logged-in user had the permission `foo.can_vote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, you can check permissions in template `{% if %}` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to also look permissions up by `{% if in %}` statements. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Managing users in the admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have both `Django.contrib.admin` and `Django.contrib.auth` installed,
    the admin provides a convenient way to view and manage users, groups, and permissions.
    Users can be created and deleted like any Django model. Groups can be created,
    and permissions can be assigned to users or groups. A log of user edits to models
    made within the admin is also stored and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should see a link to *Users* in the *Auth* section of the main admin index
    page. If you click this link, you should see the user management screen (*Figure
    11.1*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating users](img/image_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Django admin user management screen'
  prefs: []
  type: TYPE_NORMAL
- en: The *Add user* admin page is different than standard admin pages in that it
    requires you to choose a username and password before allowing you to edit the
    rest of the user's fields (*Figure 11.2*).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want a user account to be able to create users using the Django admin
    site, you'll need to give them permission to add users and change users (that
    is, the *Add user* and *Change user* permissions). If an account has permission
    to add users but not to change them, that account won't be able to add users.
  prefs: []
  type: TYPE_NORMAL
- en: Why? Because if you have permission to add users, you have the power to create
    superusers, which can then, in turn, change other users. So Django requires add
    and change permissions as a slight security measure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating users](img/image_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Django admin add user screen'
  prefs: []
  type: TYPE_NORMAL
- en: Changing passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User passwords are not displayed in the admin (nor stored in the database),
    but the password storage details are displayed. Included in the display of this
    information is a link to a password change form that allows admins to change user
    passwords (*Figure 11.3*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing passwords](img/image_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Link to change password (circled)'
  prefs: []
  type: TYPE_NORMAL
- en: Once you click the link, you will be taken to the change password form (*Figure
    11.4*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing passwords](img/image_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Django admin change password form'
  prefs: []
  type: TYPE_NORMAL
- en: Password management in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Password management is something that should generally not be reinvented unnecessarily,
    and Django endeavors to provide a secure and flexible set of tools for managing
    user passwords. This document describes how Django stores passwords, how the storage
    hashing can be configured, and some utilities to work with hashed passwords.
  prefs: []
  type: TYPE_NORMAL
- en: How Django stores passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django provides a flexible password storage system and uses **PBKDF2** (for
    more information visit [http://en.wikipedia.org/wiki/PBKDF2](http://en.wikipedia.org/wiki/PBKDF2))
    by default. The `password` attribute of a `User` object is a string in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Those are the components used for storing a User''s password, separated by
    the dollar-sign character and consist of: the hashing algorithm, the number of
    algorithm iterations (work factor), the random salt, and the resulting password
    hash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is one of a number of one-way hashing or password storage algorithms
    Django can use (see the following code). Iterations describe the number of times
    the algorithm is run over the hash. Salt is the random seed used and the hash
    is the result of the one-way function. By default, Django uses the PBKDF2 algorithm
    with a SHA256 hash, a password stretching mechanism recommended by NIST(for more
    information visit [http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf](http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf)).
    This should be sufficient for most users: it''s quite secure, requiring massive
    amounts of computing time to break. However, depending on your requirements, you
    may choose a different algorithm, or even use a custom algorithm to match your
    specific security situation. Again, most users shouldn''t need to do this-if you''re
    not sure, you probably don''t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do, please read on: Django chooses the algorithm to use by consulting
    the `PASSWORD_HASHERS` setting. This is a list of hashing algorithm classes that
    this Django installation supports. The first entry in this list (that is, `settings.PASSWORD_HASHERS[0]`)
    will be used to store passwords, and all the other entries are valid hashers that
    can be used to check existing passwords.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if you want to use a different algorithm, you''ll need to modify
    `PASSWORD_HASHERS` to list your preferred algorithm first in the list. The default
    for `PASSWORD_HASHERS` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This means that Django will use PBKDF2 to store all passwords, but will support
    checking passwords stored with PBKDF2SHA1, Bcrypt, SHA1, and so on. The next few
    sections describe a couple of common ways advanced users may want to modify this
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bcrypt with Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bcrypt (for more information visit [http://en.wikipedia.org/wiki/Bcrypt](http://en.wikipedia.org/wiki/Bcrypt))
    is a popular password storage algorithm that's specifically designed for long-term
    password storage. It's not the default used by Django since it requires the use
    of third-party libraries, but since many people may want to use it, Django supports
    Bcrypt with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Bcrypt as your default storage algorithm, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `bcrypt` library. This can be done by running `pip install Django[bcrypt]`,
    or by downloading the library and installing it with `python setup.py install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `PASSWORD_HASHERS` to list `BCryptSHA256PasswordHasher` first. That
    is, in your settings file, you''d put:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: (You need to keep the other entries in this list, or else Django won't be able
    to upgrade passwords; see the following section).
  prefs: []
  type: TYPE_NORMAL
- en: That's it-now your Django install will use Bcrypt as the default storage algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Password truncation with BCryptPasswordHasher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The designers of Bcrypt truncate all passwords at 72 characters which means
    that `bcrypt(password_with_100_chars) == bcrypt(password_with_100_chars[:72])`.
    The original `BCryptPasswordHasher` does not have any special handling and thus
    is also subject to this hidden password length limit. `BCryptSHA256PasswordHasher`
    fixes this by first hashing the password using sha256\. This prevents the password
    truncation and so should be preferred over the `BCryptPasswordHasher`.
  prefs: []
  type: TYPE_NORMAL
- en: The practical ramification of this truncation is pretty marginal as the average
    user does not have a password greater than 72 characters in length and even being
    truncated at 72, the compute powered required to brute force Bcrypt in any useful
    amount of time is still astronomical. Nonetheless, we recommend you use `BCryptSHA256PasswordHasher`
    anyway on the principle of *better safe than sorry*.
  prefs: []
  type: TYPE_NORMAL
- en: Other Bcrypt implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several other implementations that allow Bcrypt to be used with Django.
    Django's Bcrypt support is NOT directly compatible with these. To upgrade, you
    will need to modify the hashes in your database to be in the form `bcrypt$(raw
    bcrypt output)`.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the work factor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PBKDF2 and Bcrypt algorithms use a number of iterations or rounds of hashing.
    This deliberately slows down attackers, making attacks against hashed passwords
    harder. However, as computing power increases, the number of iterations needs
    to be increased.
  prefs: []
  type: TYPE_NORMAL
- en: The Django development team have chosen a reasonable default (and will increase
    it with each release of Django), but you may wish to tune it up or down, depending
    on your security needs and available processing power. To do so, you'll subclass
    the appropriate algorithm and override the `iterations` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to increase the number of iterations used by the default PBKDF2
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subclass of `Django.contrib.auth.hashers.PBKDF2PasswordHasher`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Save this somewhere in your project. For example, you might put this in a file
    like `myproject/hashers.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add your new hasher as the first entry in `PASSWORD_HASHERS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That's it-now your Django install will use more iterations when it stores passwords
    using PBKDF2.
  prefs: []
  type: TYPE_NORMAL
- en: Password upgrading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When users log in, if their passwords are stored with anything other than the
    preferred algorithm, Django will automatically upgrade the algorithm to the preferred
    one. This means that old installs of Django will get automatically more secure
    as users log in, and it also means that you can switch to new (and better) storage
    algorithms as they get invented.
  prefs: []
  type: TYPE_NORMAL
- en: However, Django can only upgrade passwords that use algorithms mentioned in
    `PASSWORD_HASHERS`, so as you upgrade to new systems you should make sure never
    to *remove* entries from this list. If you do, users using unmentioned algorithms
    won't be able to upgrade. Passwords will be upgraded when changing the PBKDF2
    iteration count.
  prefs: []
  type: TYPE_NORMAL
- en: Manually managing a user's password
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Django.contrib.auth.hashers` module provides a set of functions to create
    and validate hashed password. You can use them independently from the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to manually authenticate a user by comparing a plain-text password
    to the hashed password in the database, use the function `check_password()`. It
    takes two arguments: the plain-text password to check, and the full value of a
    user''s `password` field in the database to check against, and returns `True`
    if they match, `False` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '`make_password()` creates a hashed password in the format used by this application.
    It takes one mandatory argument: the password in plain-text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, you can provide a salt and a hashing algorithm to use, if you don''t
    want to use the defaults (first entry of `PASSWORD_HASHERS` setting). Currently
    supported algorithms are: `''pbkdf2_sha256''`, `''pbkdf2_sha1''`, `''bcrypt_sha256''`,
    `''bcrypt''`, `''sha1''`, `''md5''`, `''unsalted_md5''` (only for backward compatibility)
    and `''crypt''` if you have the `crypt` library installed.'
  prefs: []
  type: TYPE_NORMAL
- en: If the password argument is `None`, an unusable password is returned (one that
    will be never accepted by `check_password()`).
  prefs: []
  type: TYPE_NORMAL
- en: '`is_password_usable()` checks if the given string is a hashed password that
    has a chance of being verified against `check_password()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing authentication in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The authentication that comes with Django is good enough for most common cases,
    but you may have needs not met by the out-of-the-box defaults. To customize authentication
    to your projects needs involves understanding what points of the provided system
    are extensible or replaceable.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication backends provide an extensible system for when a username and
    password stored with the User model need to be authenticated against a different
    service than Django's default. You can give your models custom permissions that
    can be checked through Django's authorization system. You can extend the default
    User model, or substitute a completely customized model.
  prefs: []
  type: TYPE_NORMAL
- en: Other authentication sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There may be times you have the need to hook into another authentication source-that
    is, another source of usernames and passwords or authentication methods.
  prefs: []
  type: TYPE_NORMAL
- en: For example, your company may already have an LDAP setup that stores a username
    and password for every employee. It'd be a hassle for both the network administrator
    and the users themselves if users had separate accounts in LDAP and the Django-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: So, to handle situations like this, the Django authentication system lets you
    plug in other authentication sources. You can override Django's default database-based
    scheme, or you can use the default system in tandem with other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying authentication backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behind the scenes, Django maintains a list of authentication backends that it
    checks for authentication. When somebody calls `authenticate()`-as described in
    the previous section on logging a user in-Django tries authenticating across all
    of its authentication backends. If the first authentication method fails, Django
    tries the second one, and so on, until all backends have been attempted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of authentication backends to use is specified in the `AUTHENTICATION_BACKENDS`
    setting. This should be a list of Python path names that point to Python classes
    that know how to authenticate. These classes can be anywhere on your Python path.
    By default, `AUTHENTICATION_BACKENDS` is set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That's the basic authentication backend that checks the Django users database
    and queries the built-in permissions. It does not provide protection against brute
    force attacks via any rate limiting mechanism. You may either implement your own
    rate limiting mechanism in a custom authorization backend, or use the mechanisms
    provided by most web servers. The order of `AUTHENTICATION_BACKENDS` matters,
    so if the same username and password is valid in multiple backends, Django will
    stop processing at the first positive match. If a backend raises a `PermissionDenied`
    exception, authentication will immediately fail. Django won't check the backends
    that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Once a user has authenticated, Django stores which backend was used to authenticate
    the user in the user's session, and re-uses the same backend for the duration
    of that session whenever access to the currently authenticated user is needed.
    This effectively means that authentication sources are cached on a per-session
    basis, so if you change `AUTHENTICATION_BACKENDS`, you'll need to clear out session
    data if you need to force users to re-authenticate using different methods. A
    simple way to do that is simply to execute `Session.objects.all().delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an authentication backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An authentication backend is a class that implements two required methods:
    `get_user(user_id)` and `authenticate(**credentials)`, as well as a set of optional
    permission related authorization methods. The `get_user` method takes a `user_id`-which
    could be a username, database ID or whatever, but has to be the primary key of
    your `User` object-and returns a `User` object. The `authenticate` method takes
    credentials as keyword arguments. Most of the time, it''ll just look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'But it could also authenticate a token, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Either way, `authenticate` should check the credentials it gets, and it should
    return a `User` object that matches those credentials, if the credentials are
    valid. If they're not valid, it should return `None`. The Django admin system
    is tightly coupled to the Django `User` object described at the beginning of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the best way to deal with this is to create a Django `User` object
    for each user that exists for your backend (for example, in your LDAP directory,
    your external SQL database, and so on.) You can either write a script to do this
    in advance, or your `authenticate` method can do it the first time a user logs
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example backend that authenticates against a username and password
    variable defined in your `settings.py` file and creates a Django `User` object
    the first time a user authenticates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Handling authorization in custom backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom authorization backends can provide their own permissions. The user model
    will delegate permission lookup functions (`get_group_permissions()`, `get_all_permissions()`,
    `has_perm()`, and `has_module_perms()`) to any authentication backend that implements
    these functions. The permissions given to the user will be the superset of all
    permissions returned by all backends. That is, Django grants a permission to a
    user that any one backend grants.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a backend raises a `PermissionDenied` exception in `has_perm()` or `has_module_perms()`,
    the authorization will immediately fail and Django won''t check the backends that
    follow. The simple backend mentioned before could implement permissions for the
    admin fairly simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This gives full permissions to the user granted access in the preceding example.
    Notice that in addition to the same arguments given to the associated `User` functions,
    the backend authorization functions all take the user object, which may be an
    anonymous user, as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: A full authorization implementation can be found in the `ModelBackend` class
    in `Django/contrib/auth/backends.py`, which is the default backend and it queries
    the `auth_permission` table most of the time. If you wish to provide custom behavior
    for only part of the backend API, you can take advantage of Python inheritance
    and subclass `ModelBackend` instead of implementing the complete API in a custom
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization for anonymous users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An anonymous user is one that is not authenticated that is they have provided
    no valid authentication details. However, that does not necessarily mean they
    are not authorized to do anything. At the most basic level, most websites authorize
    anonymous users to browse most of the site, and many allow anonymous posting of
    comments and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Django's permission framework does not have a place to store permissions for
    anonymous users. However, the user object passed to an authentication backend
    may be an `Django.contrib.auth.models.AnonymousUser` object, allowing the backend
    to specify custom authorization behavior for anonymous users.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially useful for the authors of re-usable apps, who can delegate
    all questions of authorization to the auth backend, rather than needing settings,
    for example, to control anonymous access.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization for inactive users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An inactive user is a one that is authenticated but has its attribute `is_active`
    set to `False`. However, this does not mean they are not authorized to do anything.
    For example, they are allowed to activate their account.
  prefs: []
  type: TYPE_NORMAL
- en: The support for anonymous users in the permission system allows for a scenario
    where anonymous users have permissions to do something while inactive authenticated
    users do not. Do not forget to test for the `is_active` attribute of the user
    in your own backend permission methods.
  prefs: []
  type: TYPE_NORMAL
- en: Handling object permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django's permission framework has a foundation for object permissions, though
    there is no implementation for it in the core. That means that checking for object
    permissions will always return `False` or an empty list (depending on the check
    performed). An authentication backend will receive the keyword parameters `obj`
    and `user_obj` for each object related authorization method and can return the
    object level permission as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Custom permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create custom permissions for a given model object, use the `permissions`
    model Meta attribute. This example Task model creates three custom permissions,
    that is, actions users can or cannot do with Task instances, specific to your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing this does is create those extra permissions when you run `manage.py
    migrate`. Your code is in charge of checking the value of these permissions when
    a user is trying to access the functionality provided by the application (viewing
    tasks, changing the status of tasks, closing tasks.) Continuing the preceding
    example, the following checks if a user may view tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Extending the existing user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to extend the default `User` model without substituting your
    own model. If the changes you need are purely behavioral, and don't require any
    change to what is stored in the database, you can create a proxy model based on
    `User`. This allows for any of the features offered by proxy models including
    default ordering, custom managers, or custom model methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to store information related to `User`, you can use a one-to-one
    relationship to a model containing the fields for additional information. This
    one-to-one model is often called a profile model, as it might store non-auth related
    information about a site user. For example, you might create an Employee model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming an existing Employee Fred Smith who has both a User and Employee model,
    you can access the related information using Django''s standard related model
    conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a profile model''s fields to the user page in the admin, define an `InlineModelAdmin`
    (for this example, we''ll use a `StackedInline`) in your app''s `admin.py` and
    add it to a `UserAdmin` class which is registered with the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: These profile models are not special in any way-they are just Django models
    that happen to have a one-to-one link with a User model. As such, they do not
    get auto created when a user is created, but a `Django.db.models.signals.post_save`
    could be used to create or update related models as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Note that using related models results in additional queries or joins to retrieve
    the related data, and depending on your needs substituting the User model and
    adding the related fields may be your better option. However existing links to
    the default User model within your project's apps may justify the extra database
    load.
  prefs: []
  type: TYPE_NORMAL
- en: Substituting a custom user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some kinds of projects may have authentication requirements for which Django''s
    built-in `User` model is not always appropriate. For instance, on some sites it
    makes more sense to use an email address as your identification token instead
    of a username. Django allows you to override the default User model by providing
    a value for the `AUTH_USER_MODEL` setting that references a custom model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This dotted pair describes the name of the Django app (which must be in your
    `INSTALLED_APPS`), and the name of the Django model that you wish to use as your
    User model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing `AUTH_USER_MODEL` has a big effect on your Django project, particularly
    your database structure. For example, if you change your `AUTH_USER_MODEL` after
    you have run migrations, you will have to manually update your database because
    it affects the construction of many database table relationships. Unless there
    is a very good reason to do so, you should not change your `AUTH_USER_MODEL.`
  prefs: []
  type: TYPE_NORMAL
- en: Notwithstanding the preceding warning, Django does fully support custom user
    models, however a full explanation is beyond the scope of this book. A full example
    of an admin-compliant custom user app, as well as comprehensive documentation
    on custom user models can be found on the Django Project website ([https://docs.Djangoproject.com/en/1.8/topics/auth/customizing/](https://docs.Djangoproject.com/en/1.8/topics/auth/customizing/)).
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about user authentication in Django, the built-in
    authentication tools, as well as the wide range of customizations available. In
    the next chapter, we will be covering arguably the most important tool for creating
    and maintaining robust applications-automated testing.
  prefs: []
  type: TYPE_NORMAL
