- en: Chapter 7. The User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CryENGINE integrates Scaleform GFx, allowing the rendering of Adobe Flash-based
    user interfaces, HUDs, and animated textures. By tying UI elements together at
    runtime using the UI flowgraph solution, developers can intuitively create and
    expand user interfaces in no time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the CryENGINE Scaleform implementation, and the benefits it brings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our main menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a UI game event system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flash movie clips and UI graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to provide developers with a solution for creating user interfaces,
    CryENGINE integrates Adobe Scaleform GFx, a real-time Flash renderer for game
    engines. The system allows the creation of user interfaces in Adobe Flash, which
    can then be exported for immediate use in the engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to use Flash `.swf` files in materials, allowing the rendition
    of Flash movie clips on 3D objects present in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: The effort involved in creating modular dynamic user interfaces is greatly simplified
    with the addition of the UI flowgraph, a system that allows the creation and maintenance
    of any Flash UI element using the flowgraph system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI flowgraph system is based on the concept of two types: **elements**
    and **actions**. Each element represents a Flash file (`.swf` or `.gfx`), while
    each action is one flowgraph representing a UI state.'
  prefs: []
  type: TYPE_NORMAL
- en: Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UI elements are configured via XML files in `Game/Libs/UI/UIElements/`, and
    represent each Flash file. By modifying the UI element's configuration, we can
    change the events it receives and alignment mode, as well as expose the different
    functions and callbacks present in the exported SWF file.
  prefs: []
  type: TYPE_NORMAL
- en: XML Breakdown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The bare minimum for an element can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous XML code can be saved as `Game/Libs/UI/UIElements/MyMainMenu.xml`,
    and will load the Flash file called `Menus_Startmenu.swf` in the `Game/Libs/UI/`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once created, we'll be able to select our new UI element via flowgraph nodes
    such as **UI:Display:Config** (used to reconfigure any element in order to, for
    example, enable mouse events for an element at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: '![XML Breakdown](img/5909_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we know it works, let''s break it down a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This first element defines the start of the file, and determines in which category
    our element should be placed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `UIElement` XML element is used to decide the initial configuration, including
    the default name, and determining which events should be received by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen previously, each element can be configured via a set of attributes,
    allowing the developer to define what type of events to listen to:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Defines the name of the element (String). |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseevents` | Determines whether mouse events are sent to the Flash file
    (0/1). |'
  prefs: []
  type: TYPE_TB
- en: '| `cursor` | Determines whether to display a cursor while the element is visible
    (0/1). |'
  prefs: []
  type: TYPE_TB
- en: '| `keyevents` | Determines whether to send key events to the Flash file (0/1).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `console_mouse` | Determines whether the thumbstick should function as a
    cursor on console hardware (0/1). |'
  prefs: []
  type: TYPE_TB
- en: '| `console_cursor` | Determines whether to display a cursor while the element
    is visible while running on console hardware (0/1). |'
  prefs: []
  type: TYPE_TB
- en: '| `layer` | Defines the order in which the elements are displayed, in case
    multiple elements are present. |'
  prefs: []
  type: TYPE_TB
- en: '| `alpha` | Sets the background alpha of the element (0-1).Allows transparency
    in-game, for example, to feature an in-game level behind your main menu. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the previously mentioned properties can be tweaked in real time by
    using the **UI:Display:Config** node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `GFx` element determines which Flash file should be loaded for the element.
    It is possible to load multiple GFx files and put them into different layers.
  prefs: []
  type: TYPE_NORMAL
- en: This allows for selecting which element layer to use at runtime, for example,
    via the `layer` input on the **UI:Display:Config** node shown in the previous
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Constraints` allow configuring how the GFx element is displayed on screen,
    giving the developer the ability to tweak how the element performs under different
    display resolutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently three modes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode name | Description | Additional attributes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fixed | In the fixed mode, the developer can use four attributes to set the
    pixel distance from top and left corners, as well as set the desired resolution.
    | top, left, width, and height |'
  prefs: []
  type: TYPE_TB
- en: '| dynamic | In dynamic mode, the element is aligned on anchors, allowing horizontal
    and vertical alignment.halign can be set to `left`, `center`, or `right`, while
    valign can be set to `top`, `center`, or `bottom`.If scale is set to `1`, the
    element will be scaled to the screen resolution while maintaining aspect ratio.If
    max is set to `1`, the element will be maximized to make sure that 100 percent
    of the screen is covered. | halign, valign, scale, and max |'
  prefs: []
  type: TYPE_TB
- en: '| fullscreen | When active in this mode, the element viewport will be exactly
    the same as the render viewport.If scale is set to `1`, the element will be stretched
    to the screen resolution. | scale |'
  prefs: []
  type: TYPE_TB
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UI actions are the core of the UI flowgraph implementation. Each action is represented
    by a flowgraph, and defines a UI state. For example, each screen in a main menu
    would be handled using a separate action.
  prefs: []
  type: TYPE_NORMAL
- en: All available UI actions can be seen in the **Flow Graphs** toolbox, inside
    the Flowgraph Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Actions](img/5909_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a new UI action, navigate to **File** | **New UI action**, and specify
    the name of your new action in the newly opened **Save As** dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Actions](img/5909_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Actions are started by using the **UI:Action:Control** node and specifying the
    name of the pending action in the **UIAction** input port, and then activating
    the **Start** input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Actions](img/5909_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once started, the UI graph with the specified name will be activated, assuming
    it contains a **UI:Action:Start** node as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Actions](img/5909_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The graph can then initialize the requested UI by listening to the **StartAction**
    output port. Once the action is done, it should call **UI:Action:End** as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Actions](img/5909_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And that's it. UI graphs are saved as flowgraph XML files in `Game/Libs/UI/UIActions/`.
    The initial UI action is called **Sys_StateControl** and will always be active.
    The state controller graph should be responsible for loading and enabling menus
    based on system events such as level load.
  prefs: []
  type: TYPE_NORMAL
- en: The system state control action (`Sys_StateControl.xml`) is always active, and
    is used to start the initial actions, for example, to display the main menu when
    the engine is started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a main menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the UI flowgraph implementation, let's
    get started with creating our very own main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Creating menu elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do is create our UI element definition in order to
    provide the engine with a means for loading our exported SWF file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, create a new XML document in `Game/Libs/UI/UIElements/` named `MainMenuSample.xml`.
    The bare minimum code required for our menu can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the previous code present, the engine will know where to load our SWF file,
    and how to align it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SWF files can be re-exported by using `GFxExport.exe` (usually present in the
    `<root>/Tools/` directory) to be more efficient for an in-engine use. This is
    usually done before releasing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing ActionScript assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moving on, we'll need to expose the functions and events we defined in our Flash
    source file in order to allow the engine to invoke and receive these.
  prefs: []
  type: TYPE_NORMAL
- en: When exposing functions and events, we create simplistic flowgraph nodes that
    can be used by any flowgraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, function nodes can be accessed by navigating to **UI** | **Functions**
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing ActionScript assets](img/5909_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Events can be found by navigating to **UI** | **Events**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to create UI actions and elements in C++, effectively giving
    the user interface the ability to send and get events from native code. We'll
    be going through this in the *Creating UI Game Event System* section later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To expose a method, we need to add a new `<functions>` section into the `UIElement`
    definition as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the previous code, the engine will create two nodes that we can utilize
    to invoke the `setupScreen` and `addBigButton` ActionScript methods from our UI
    Graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions are always placed in the same flowgraph category: **UI:Functions:ElementName:FunctionName**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions](img/5909_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the **Call** port on either of the nodes displayed in the previous screenshot
    is triggered, the ActionScript method will be invoked with the specified parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **instanceID** input port determines which element instance to invoke the
    function on. If the value is set to `-1` (default), it will be invoked on all
    instances, otherwise if set to `-2`, it will be called on all initialized instances.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting up events is done in a similar way to functions, by using the `<events>`
    tag as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will result in the engine making the **OnBigButton** node
    available, triggered when the Flash file invokes the `onBigButton` fscommand,
    along with the associated button ID.
  prefs: []
  type: TYPE_NORMAL
- en: '![Events](img/5909_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Invoking a `fscommand` from Flash is relatively easy. The following code will
    trigger the `onBigButton` event, along with the associated button ID string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to functions, events are always placed in **UI:Events:ElementName:EventName**.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's also possible to define access to variables present in the Flash source
    file via the element definition. This allows for getting and setting the value
    of your variable by using the **UI:Variable:Var** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, define your array inside the element definition''s `<variables>`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After restarting the editor, place a new **UI:Variable:Var** node and browse
    for your new variable as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variables](img/5909_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we can simply set or get the value of our variable at any time by using
    flowgraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variables](img/5909_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we set the value of a Flash variable at runtime. This
    is also possible for arrays, by using the **UI:Variable:Array** node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, expose the array inside your element''s `<arrays>` block as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then simply restart your array and repeat the previous process, but with the
    **UI:Variable:Array** node. To create a new array via your UI graph, use the **UI:Util:ToArray**
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arrays](img/5909_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exposing MovieClip instances to flowgraph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same way that variables can be exposed, it's also possible to give direct
    access to MovieClips via the UI graphs. This allows the possibility to go to specific
    frames, change properties, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'All nodes that allow MovieClip interaction can be found by navigating to **UI**
    | **MovieClip** within the Flowgraph Editor: as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing MovieClip instances to flowgraph](img/5909_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To start, add or edit the `<movieclips>` block in your element definition as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will give flowgraph access to the **m_myMovieClip** movieclip present in
    your Flash file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the editor has been restarted, we can, for example, use the **UI:MovieClip:GotoAndPlay**
    node to skip directly to a different frame in the specified clip as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing MovieClip instances to flowgraph](img/5909_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the UI actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've configured the main menu element, it's time to create the UI
    actions that will result in the menu appearing in the Launcher application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the state control graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start by opening Sandbox and the Flowgraph Editor. Once it is open, create a
    new UI action by navigating to **File** | **New UI Action**. Call the action **Sys_StateControl**.
    This will be the primary UI action in which we trigger the initial menu and handle
    crucial system events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the action has been created, we''ll be using the following three system
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: OnSystemStarted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OnLoadingError
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OnUnloadComplete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together, these events signify when our main menu should appear. We'll be tying
    them together into a **UI:Action:Control** node, which in turn activates the MainMenu
    UIAction we'll create later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the state control graph](img/5909_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the MainMenu action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you're done, create another UI action and name it **MainMenu**. Once this
    is open, place a **UI:Action:Start** node. It's **StartAction** output port will
    be automatically activated when the **UI:Action:Control** node we created previously
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: We can now hook the **Start** node to a **UI:Display:Display** and **UI:Display:Config**
    node in order to initialize the main menu, making sure that the user can see it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the MainMenu action](img/5909_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our flash file will now be displayed when the game starts, but currently lacks
    any additional configuration from flowgraph.
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that our main menu file is initialized, we'll need to add a bit of ActionScript
    code to the Flash file in order to allow dynamic spawning and handling of buttons
    from our UI graph.
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes that you have a MovieClip that you can instantiate at runtime.
    In our sample, we'll be using a custom button called **BigButton**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding buttons](img/5909_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Flash source file (`.fla`) for our main menu is present in the `Game/Libs/UI/`
    folder of our sample installation, downloadable from [https://github](https://github)
    [.com/inkdev/CryENGINE-Game-Programming-Sample/](http://.com/inkdev/CryENGINE-Game-Programming-Sample/).
  prefs: []
  type: TYPE_NORMAL
- en: 'This section also assumes that you have two ActionScript functions: `SetupScreen`
    and `AddBigButton`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetupScreen` should configure the default settings for the scene, and remove
    all previously spawned objects. In our case, we want buttons spawned using `AddBigButton`
    to be removed whenever we call `SetupScreen`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddBigButton` should simply be a function that spawns a pre-created button
    instance as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When the button is clicked on, it should invoke an event that we catch in flowgraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For information on creating functions and events, see the *Exposing ActionScript
    assets* section discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re done, add the nodes to your MainMenu action, and call them after
    configuring the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding buttons](img/5909_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our main menu should now appear when starting the Launcher application, but
    there's no feedback for any user interaction with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, we can utilize the OnBigButton node that we exposed earlier
    in the chapter. This node will send events when a button has been clicked on,
    along with a string identifier that we can use to figure out which node was clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding buttons](img/5909_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous graph, we intercept the button events and use the **String:Compare**
    node to check what we need to do with the input. If the **IDD_Quit** button was
    clicked, we exit the game, and if the **IDD_Start** node was clicked, we load
    the **Demo** level.
  prefs: []
  type: TYPE_NORMAL
- en: End result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming that you didn''t create your own menu design, you should now see the
    following screenshot when starting the Launcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![End result](img/5909_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you've learned how easy creating a simple menu is, why not go ahead
    and create a **Heads-Up Display** (**HUD**) that is shown when the player is spawned?
  prefs: []
  type: TYPE_NORMAL
- en: Engine ActionScript callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of ActionScript callbacks that are automatically called by
    the engine. Simply by defining the functions in your Flash source file root, the
    engine will be able to invoke them.
  prefs: []
  type: TYPE_NORMAL
- en: '`cry_onSetup(isConsole:Boolean)`: This function is called when the SWF file
    is initially loaded by the engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cry_onShow()`: This function is called when the SWF file is shown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cry_onHide()`: This function is called when the SWF file is hidden.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cry_onResize(_iWidth:Number, _iHeight:Number)`: This function is called when
    the in-game resolution is changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cry_onBack()`: This function is called when the user presses the back button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cry_requestHide()`: This function is called when the element is hidden.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating UI game event systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI system utilizes the `IUIGameEventSystem` interface to communicate with
    flowgraph, allowing for custom functions and events to be defined in the same
    manner in which the ActionScript assets are exposed.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to allow user interfaces to access game and engine functionalities
    such as getting a list of playable levels. Each game event system specifies its
    category, which is then used in the Flowgraph Editor to define the category of
    functions and events registered.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we create an event system named MyUI using `IFlashUI::CreateEventSystem`,
    all functions will be found by navigating to **UI** | **Functions** | **MyUI**.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing IUIGameEventSystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing `IUIGameEventSystem` doesn''t require much work; there are only
    the following three pure virtuals that we need to assign:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetTypeName`: This is not directly overridden; use the `UIEVENTSYSTEM` macro
    instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InitEventSystem`: This is called to initialize the event system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnloadEventSystem`: This is called to unload the event system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, the bare minimum is as follows (the following file was saved as
    `MyUIGameEventSystem.h`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the class definition resolved, we can move on to the code itself.
    Start by creating a new file called `MyUIGameEventSystem.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: Once this file is created, register the event system by using the `REGISTER_UI_EVENTSYSTEM`
    macro. This is used to automatically create an instance of your class from within
    the `CUIManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the macro at the bottom of your CPP file, outside of the method scope
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `REGISTER_UI_EVENTSYSTEM` macro will only work in the CryGame
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Our event system should now compile, and will be created along with the other
    event systems contained in CryGame.
  prefs: []
  type: TYPE_NORMAL
- en: Our event system doesn't do anything at the moment. Read the following sections
    to learn how to expose functions and events to the UI flowgraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event systems can expose functions that work in the same way that the nodes
    we registered via our Main Menu element do. By exposing functions, we can allow
    the graphs to interact with our game to, for example, request player health.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll need to add two new members to our `CMyUIGameEventSystem`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The event dispatcher will be responsible for invoking functions as their nodes
    are triggered in flowgraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start creating a function, add the following code to the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To register our function, add the following code within your `InitEventSystem`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to see your node in the Flowgraph Editor after recompiling
    and restarting Sandbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Receiving events](img/5909_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dispatching events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to expose events to the UI graph is very useful, allowing you to
    handle event-based UI logic to, for example, display a scoreboard when the user
    requests it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, lets add the following code to your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `EUIEvent` enum contains the various events we're going to register, and
    is used as a way for the event sender to know which event you're trying to send
    to the UI system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll need to append a bit of code to the `InitEventSystem` function to
    expose our event as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The **OnMyUIEvent** node should now appear in the Editor after a successful
    recompilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dispatching events](img/5909_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dispatching the event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To dispatch your UI event, use `SUIEventSenderDispatcher::SendEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how user interfaces are created in CryENGINE,
    and created our own main menu with that knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: You know have the basic knowledge required to implement your own UI and UI event
    systems..
  prefs: []
  type: TYPE_NORMAL
- en: If you would prefer to work more with user interfaces before moving on to the
    next chapter, why not expand the Main Menu we created earlier? A good starting
    point could be to implement a level selection screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be covering the process of creating networked games
    to allow multiplayer functionality.
  prefs: []
  type: TYPE_NORMAL
