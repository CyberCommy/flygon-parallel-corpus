- en: Populus Development Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you're going to learn how to use Populus, which is a smart
    contract development framework. Populus, like Truffle, is a tool designed to make
    it easier for you to develop a smart contract. If we cast our minds back to [Chapter
    3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing Smart Contracts
    Using Vyper*, you may recall that we had to manually create a `.json` file and
    then copy the `abi` output in the console to the `.json` file. With Populus, you
    can avoid repeating manual jobs that you've executed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Populus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart contract unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a smart contract with Populus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Populus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Populus is a smart contract development framework, just like Truffle. So why
    should we use Populus instead of Truffle? Basically, this is a personal choice.
    Populus is written with Python and supports unit testing with Python by default.
    If you use Truffle, you use unit testing with JavaScript by default. This is like
    choosing `web3.py` (Python) or `web3.js` (JavaScript) to build a decentralized
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Populus, let''s observe the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a virtual environment from scratch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We install `web3`, `populus`, and `vyper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The reason why we have to install the specific version of `web3` is because
    the latest version of `web3` (4.8.2) breaks Populus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Solidity compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a symbolic link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize this project directory with `populus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command is like `truffle init`. After learning `populus`, you may not even
    need this command any more. This command will put two directories in your project
    directory—`contracts` and `tests`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `contracts`, there is a sample Solidity file: `Greeter.sol`. Inside
    the `tests` directory, there is a sample test file: `test_greeter.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Greeter.sol`, a simple smart contract, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you can compile the smart contract, you have to create a project configuration
    called `project.json`. You must enter the project directory first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`populus-venv` is where you create a virtual environment. If you take a look
    at it, it''s a significant file, containing 255 lines. You can compile it by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The result of the compilation is `build/contracts.json`. You can find `abi`
    and `bytecode` in that `.json` file. There's additional information that you can
    find in that `.json` file, apart from `abi` and `bytecode`, such as the compiler
    version.
  prefs: []
  type: TYPE_NORMAL
- en: You'll already be familiar with the workflow of smart contract development.
    Compile `Solidity/Vyper` files so we can get `abi` and `bytecode`. Then, use `abi`
    and `bytecode` with the `web3` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you''ll encounter something new. There is another directory that you haven''t
    seen yet: the `tests` directory. Inside that directory, there is a test file called
    `test_greeter.py`, whichis a unit test. Take a look at it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can execute this test file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Your test will now pass. We'll discuss smart contract unit testing in more depth later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for Vyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know, we aren''t focusing on Solidity in this book, but Vyper. We need
    to add support for Vyper. First, because this is a new virtual environment, install
    `vyper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the project directory, create a `.vy` file called `Greeter.vy` in
    the `contracts` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before you can compile this Vyper code, you need to change something in the `project.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to  `compilation` key. The value of the key is an object with these keys:
    `backend`, `backends`, `contract_source_dirs`, and`import_remappings`. Delete
    the `backends` key and then change the `backend` key to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, the content of the `compilation` key appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the compilation as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure it is indeed a Vyper compilation and not a Solidity compilation,
    you could open `build/contracts.json`. Inside, you will be able to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The latest version of Vyper is 0.1.0b6 and it breaks Populus. The developer
    needs some time to fix this. If the bug hasn't yet been fixed while you're reading
    this book, you could patch Populus yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check whether the bug is fixed or not using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case here, the bug has not been fixed. So, let''s patch Populus to fix
    the bug. Make sure you''re still in the same directory (`populus-venv/src/populus`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our Populus development framework now has Vyper support.
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you run unit testing, you will receive an error due to the incorrect data
    type. The solution here would be to change all string data types to a bytes data
    type. Then, owing to a deprecation warning, you should change the way you call
    methods in a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, your unit test, which is located in `tests/test_greeter.py`, should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then, if you were to run your unit test again, it would be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the first method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Your unit test function should accept the `chain` argument most of the time.
    From the `chain` object, you could get a provider. If you remember, a provider
    is an object that connects to an Ethereum blockchain, be it through HTTP or IPC.
    From there, you could get the contract object. Whether the test framework gets
    the contract object directly from the blockchain or whether it deploys the contract
    first before fetching the contract depends on the situation. In our case, it is
    the latter option. The test framework creates a contract object in memory and
    interacts with it. After unit testing, everything vanishes.
  prefs: []
  type: TYPE_NORMAL
- en: Later, you would fetch the contract object from a permanent blockchain. `get_or_deploy_contract`
    from the `provider` object returns two objects. You only need to concern yourself
    with the first one, the contract object, most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: From the `contract` object, executing the methods on the smart contract should
    be familiar to you. To execute the `public` method or to get the value of public
    variables, you would use `functions`, followed by the method or the public variables
    added with `()` and ending with `call()`.
  prefs: []
  type: TYPE_NORMAL
- en: After executing the public method, you would get the return value. In this case,
    you get as a `byte` object, unlike `string` in the Solidity example. In Vyper,
    there is no first class string support. String is stored as `byte` object. Vyper
    is still in active development mode, but expect this to change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the second unit test, you would test a method in the smart contract to change
    the state of a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is the same as the first unit test, except that here are two new lines
    in the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is the way to use a transaction. Remember, a transaction is anything that
    involves changing the state of the contract. You call `functions`, followed by
    the method that's going to change the state of the contract augmented by `()`,
    ending with `transact()` with the necessary parameters. After that, using the
    `chain` object, you wait for the transaction to finish. During testing, this has
    been very fast. But if you test this on another Ethereum blockchain, say, in the
    Rinkeby network, the transaction could last a couple of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to a more complicated example. Remember our donation smart contract
    that you wrote in [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing
    Smart Contracts Using Vyper*. Why don't we test that smart contract?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s save the donation smart contract in the source code folder that you
    developed in [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing
    Smart Contracts Using Vyper*. You can save the code in `contracts/donation.vy`.
    If you''ve forgotten this, you can refer to the code file on the following GitLab
    link for the full code, [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/contracts/Donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/contracts/Donation.vy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We want to test a number of different things here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let''s take a look at the constructor method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We want to test whether the `donatee` variable will contain the address of the
    account that launches the smart contract or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our first unit test. You can save this unit test in `tests/test_donation.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this unit test, we're using the two arguments version because we want to
    get the `web3` object. It does not actually matter if you switch the order of
    the parameters. `def test_donatee(web3, chain):` is the same as `def test_donatee(chain,
    web3):`.
  prefs: []
  type: TYPE_NORMAL
- en: The argument in `get_or_deploy_contract` is taken from the name of your `.vy`
    file. So be careful naming your source code filename.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that's new (but not really new since you already encountered this
    in [Chapter 4](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml), *Interacting With
    Smart Contracts Using Web3,* is `web3.eth.coinbase`. This is the default account.
    In this context (unit test), it means the address of the account that launched
    the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this unit test succeeds, let''s continue testing another method in this
    smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this method, you're forced to send at least 1 ether to the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the fail case by writing the second unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to add two `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's learn how to deal with an exception in this unit test. You can put a troubled
    transaction inside the `with` statement that will catch an exception. Basically,
    you expect the transaction to fail. When something fails in the program, it returns
    a special code (for example, -1) or it throws an exception. In this case, it throws
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test to see whether it works. Then, let''s test the success case, meaning
    the donation is accepted (refer to the code file in the following GitLab link
    for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/tests/test_donation.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/tests/test_donation.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is a lot to digest, so let's discuss it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use the `time` library to check the timestamp later in this
    unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You already know this statement. Using the `chain` object, you could get the
    provider and then you use the `get_or_deploy_contract` method from this provider.
    The result is a donation smart contract object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`eth_tester` is a library designed to make you test a smart contract easier.
    To do that, you create an object of `EthereumTester`. There are many helper functions
    in this library. One of them is there to give you some accounts loaded with a
    lot of ETH, sort of like Ganache. The first account is the manager account or
    the account that launched the smart contract. As demonstrated previously, you
    could also get that account from `web3.eth.coinbase`. The second account and so
    on are testing accounts that you could use in your unit test.'
  prefs: []
  type: TYPE_NORMAL
- en: '`t.get_accounts()` gives you a lot of accounts. However, don''t use the first
    account because that would be the manager account. Here, you use the second account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve seen the `transact` function in the previous unit test with the greeter
    smart contract. In this `transact` method, you could specify an ether amount that
    you want to send to the smart contract. You could also use a different account.
    In these `transact` parameters, we also use the helper function, `web3.toWei`.
    Otherwise, you have to use a number with a lot of zeros. Then, you wait for the
    transaction to be confirmed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After doing this, you can access the public variables to confirm the change
    in state.
  prefs: []
  type: TYPE_NORMAL
- en: For an array, you put an index inside the array method, as in `donation.functions.donaturs(0).call()`.
  prefs: []
  type: TYPE_NORMAL
- en: For mapping, instead of the integer index, you provide the key inside the parameter
    of the mapping method, as in `donation.functions.donatur_details__sum(donatur).call()`.
  prefs: []
  type: TYPE_NORMAL
- en: For a struct, you access the member by appending two underscores, as in `donation.functions.donatur_details__sum(donatur).call(`*)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we test the donation by asserting all of these variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check that the donator address is recorded correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check that the donation amount is recorded correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check that the donator''s name is recorded correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We then check the time when the donation occurred. We do this because the time
    is recorded when the transaction is confirmed in blockchain, so you never know
    when the transaction is being confirmed. In our case, it would be fast. However,
    if you test it in the Rinkeby network, that's something to keep in mind. Here,
    I make sure that the difference between the unit test time and the timestamp recorded
    in the smart contract doesn't differ by more than 10 minutes (600 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then check the donation amount directly from the balance of the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is different from the previous test, where you test the balance by checking
    the value of the public variable. In our case, we have many donations, so they'll
    be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the last method in the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is the method to withdraw the donation. Don't laugh; some people launched
    a smart contract that does not have a way to withdraw the ethers in it. All ethers
    in those smart contracts are locked forever, which is why testing is important.
    It ensures that you don't make stupid mistakes like this.
  prefs: []
  type: TYPE_NORMAL
- en: In this withdrawal method, you want to test that you can withdraw ethers in
    the smart contract. Then, you need to make sure that only a certain account (in
    this case, it is the manager account) is able to withdraw ethers from the smart
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a unit test for that. First, we create a unit test to make sure
    that another account can''t withdraw ethers from the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Everything should look familiar to you now. You wrap the fail case of withdrawing
    ethers in the `with` statement that catches the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test the success case that the manager account could indeed withdraw
    ethers to their account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything here will be familiar to you, except maybe the last line. The manager''s
    account balance after withdrawal minus the `initial_balance` wouldn''t be exactly
    `1` `ether` because the manager''s account needs to pay the fee. In this case,
    we just use a rough measurement to ensure that the withdrawal is successful. As
    long as the difference is below 10 gwei, that should be fine. Gwei is the currency
    we use to calculate the fee for sending a transaction. 1 gwei is 1,000,000,000
    wei. If you find this confusing, you could assert it using ether currency, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a successful result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5560df57-4bd6-4a7d-90e3-8287d1a540b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Using arguments in the constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both smart contracts that we test have no arguments in the constructor. But
    what if we write a smart contract that has arguments in the constructor? How do
    we test that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple smart contract that has arguments in the constructor.
    Name it `contracts/Greeter2.vy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write the following test. Name it `tests/test_greeter2.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, you customize the deployment of your smart contract using the `fixture`
    feature from `pytest`. First, you get the contract factory from the chain's provider,
    and then you put your argument in the `constructor` method of the `factory` object,
    ending with the `transact()` method. Then, wait until it is deployed on the blockchain.
    Finally, you will receive the address.
  prefs: []
  type: TYPE_NORMAL
- en: In the test function, you put the argument exactly as the fixture function's
    name. Here, our fixture function is `greeter2_contract`. Inside the test function,
    you just use this object as a smart contract object that's similar to an object
    returned by `chain.provider.get_or_deploy_contract('Donation')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, test this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a successful result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e7e24a72-078d-4e91-a64e-6836b011d7a0.png)'
  prefs: []
  type: TYPE_IMG
- en: There are still many things you could test. We only test for one donation, but
    we could accept up to 10 donations. This should be checked as well. How complete
    you want the test coverage to be is up to you and the requirements of the project.
    There are still a plethora of unit testing aspects that we haven't discussed here,
    such as setup, tear down, and test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a smart contract with Populus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Populus isn't just a framework designed to easily develop and test a smart contract.
    It has a tool to deploy a smart contract to a blockchain, including a private
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: A private chain is basically your private Ethereum blockchain, similar to Ganache,
    except that you build it yourself. It's like blockchain in the Rinkeby network,
    but you're the sole miner. You can create a private blockchain manually using
    geth software; `populus` just makes it easier for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to create a new private `chain` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create some files in your project directory. All generated
    files are located inside the `chains` directory. One of the files generated is
    `chains/localblock/genesis.json`. The purpose of the genesis file is to dictate
    the initial configuration of the Ethereum blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to know all of the meanings of these keys. `coinbase` means all
    mining rewards should go into this account. `alloc` means the initial balance
    of the accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the genesis file, you should get `chains/localblock/init_chain.sh`.
    Open it and you should have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This script is basically running geth software with certain parameters. The
    most important parameter is `init`, which you feed to your `genesis.json` file.
    Then, run the initialization of your private blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the `chains/localblock/run_chain.sh` file and you should have this
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The important flags that you need to note for now are `--mine`, `--password`,
    `--ipcpath`, `--unlock`, and `--datadir`. `--mine` indicates that you want to
    mine in this private blockchain, `--password` is the location of the password
    file, `--unlock` unlocks the account with the password file, `--datadir` is the
    location of your private Ethereum blockchain directory, and `--ipcpath` is where
    your `geth.ipc` will be located when you run your private Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the blockchain, edit the `chains/localblock/run_chain.sh` script*,*
    change the value of the `--ipcpath` flag to `/tmp/geth.ipc`, and then run the
    blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit the `project.json` file. The `chains` key has one object that has
    four keys: `tester`, `temp`, `ropsten`, and `mainnet`. Add the `localblock` key with
    its value in this object. Hence, the `localblock` key must be adjacent to the `tester`,
    `mainnet`, `temp`, and `ropsten` keys, as demonstrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you could deploy your smart contract to your private blockchain as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can play around with your smart contract such as you did in [Chapter
    4](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml)*, Interacting with Smart Contracts
    Using Web3*. You can refer to the code file at the following GitLab link: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_private_chain.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_private_chain.py),
    for the complete code of the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Are you still attached to Ganache? If so, we can deploy to a Ganache blockchain.
    Start by firing up Ganache and then add this content to the `chains` key object
    in the `projects.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the deployment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Then, when you want to play around with your smart contract in Ganache, you
    just have to adjust the provider as you learned in [Chapter 4](37b25b74-5f3e-4217-ad46-c8a33ae337c6.xhtml),
    *Interacting with Smart Contracts Using Web3:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder of the code is the same. You can name the script `interact_smart_contract_in_ganache.py`.
    In Ganache, the coinbase account and the manager account are the first accounts
    in Ganache. Refer to the GitLab link for the full code to interact with the smart
    contract in Ganache, [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_05/populus_tutorial/interact_smart_contract_in_ganache.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to develop a smart contract with the Populus
    development framework. Populus isn't equipped with Vyper support, only Solidity.
    Consequently, you need to add Vyper support by installing Vyper and editing the
    Populus project configuration file. You also learned how to create unit tests
    for a smart contract. In this unit test, you used the `web3` object to interact
    with a smart contract and test it programmatically. After this, you learned how
    to create a private chain. Finally, you deployed a smart contract to this private
    chain and Ganache.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you're going to build an application on top of a blockchain
    that's more complicated than the donation smart contract. This application is
    the voting decentralized application.
  prefs: []
  type: TYPE_NORMAL
