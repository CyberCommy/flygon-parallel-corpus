- en: Working with Templates, Static Files, and HTML Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files over HTTP using Gorilla Mux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first HTML form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading your first HTML form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating your first HTML form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading your first file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, we would like to create HTML forms to get the information from
    a client in a specified format, upload files or folders to the server, and generate
    generic HTML templates, rather than repeating the same static text. With the knowledge
    of the concepts covered in this chapter, we will be able to implement all these
    functionalities efficiently in Go.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with creating a basic template and then move
    on to serve static files, such as `.js`, `.css`, and `images` from a filesystem,
    and eventually create, read, and validate HTML forms and upload a file to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates allow us to define placeholders for dynamic content that can be replaced
    with the values at runtime by a template engine. They can then be transformed
    into an HTML file and sent to the client. Creating templates in Go is fairly easy
    using Go's `html/template` package, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create a `first-template.html` with a couple
    of placeholders whose value will be injected by the template engine at runtime.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `first-template.html` inside the `templates` directory by executing
    the following Unix command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the following content to `first-template.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template has two placeholders, `{{.Name}}` and `{{.Id}}`, whose
    values will be substituted or injected by the template engine at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `first-template.go`, where we will populate the values for the placeholders,
    generate an HTML as an output, and write it to the client, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab60eb27-0295-4b8a-9c7b-9d85f6c65b55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing `http://localhost:8080` will show us the Hello Foo! served by the
    template engine, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f54a702f-1181-404b-8c55-f0502b2365fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Execute `curl -X GET http://localhost:8080` from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5125ff70-60b0-4b27-a291-1fd30a424f85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the Go program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type Person struct { Id string Name string }`: Here we define a `person` struct
    type that has `Id` and `Name` fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field name should begin with a capital letter in the type definition; otherwise, it
    will result in errors and will not be replaced in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined a `renderTemplate()` handler, which does a lot of things.
  prefs: []
  type: TYPE_NORMAL
- en: '`person := Person{Id: "1", Name: "Foo"}`: Here we are initializing a `person`
    struct type with `Id` as `1` and `Name` as `Foo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parsedTemplate, _ := template.ParseFiles("templates/first-template.html")`: Here
    we are calling `ParseFiles` of the `html/template` package, which creates a new
    template and parses the filename we pass as an input, which is `first-template.html
    ,`in a templates directory. The resulting template will have the name and contents
    of the input file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := parsedTemplate.Execute(w, person)`: Here we are calling an `Execute`
    handler on a parsed template, which injects `person` data into the template, generates
    an HTML output, and writes it onto an HTTP response stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil {log.Printf("Error occurred while executing the template or
    writing its output : ", err) return }`: Here we check whether there are any problems
    while executing the template or writing its output on the response stream. If
    there are, then we log the error and exit with a status code of 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While designing web applications, it’s always a best practice to serve static
    resources, such as `.js`, `.css`, and `images` from the filesystem, or any **content
    delivery network** (**CDN**), such as Akamai or Amazon CloudFront, rather than
    serving it from the web server. This is because all these types of files are static
    and do not need to be processed; so why should we put extra load on the server?
    Moreover, it helps to boost application performance, as all the requests for the
    static files will be served from external sources and therefore reduce the load
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Go's `net/http` package is sufficient enough for serving static resources from
    the filesystem through `FileServer`, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created a template in our previous recipe, we will just extend
    it to serve a static `.css` file from the `static/css` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create a file server that will serve static
    resources from the filesystem. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `main.css` inside a `static/css` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the following content to `main.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `serve-static-files.go`, where we will create `FileServer`, which will
    serve resources from the `static/css` directory present on the filesystem for
    all URL patterns with  `/static`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `first-template.html` (created in our previous recipe) to include `main.css`
    from the `static/css` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94798377-1729-4559-9e5c-6c4ca2fa2f59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us the same output we saw in
    our previous recipe, but this time the text color has changed from the default
    **black** to **blue**, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07fd3f5a-f8c5-4976-98b3-5527c8372755.png)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the Network tab of Chrome DevTools, we can see `main.css`, which
    has been loaded from the `static/css` directory present on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the changes we introduced in the `main()` method as part
    of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fileServer := http.FileServer(http.Dir("static"))`: Here, we created a file
    server using the `FileServer` handler of the `net/http` package, which serves
    HTTP requests from the `static` directory present on the filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.Handle("/static/", http.StripPrefix("/static/", fileServer))`: Here,
    we are registering the `http.StripPrefix("/static/", fileServer)` handler with
    the `/static` URL pattern using `HandleFunc` of the `net/http` package, which
    means  `http.StripPrefix("/static/", fileServer)` gets executed and passes `(http.ResponseWriter,
    *http.Request)` as a parameter to it whenever we access the HTTP URL with the `/static` pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.StripPrefix("/static/", fileServer)`: This returns a handler that serves
    HTTP requests by removing `/static` from the request URL''s path and invokes the
    file server. `StripPrefix` handles a request for a path that doesn''t begin with
    a prefix by replying with an HTTP 404.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files over HTTP using Gorilla Mux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we served `static` resources through Go's HTTP file
    server. In this recipe, we will look at how we can serve it through the Gorilla
    Mux router, which is also one of the most common ways of creating an HTTP router.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created a template which serves `main.css` from the `static/css`
    directory present on the filesystem in our previous recipe, we will just update
    it to use the Gorilla Mux router.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/mux` package using the `go get` command, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `serve-static-files-gorilla-mux.go`, where we will create a Gorilla
    Mux router instead of an HTTP `FileServer`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing `http://localhost:8080` will show us the same output we saw in our
    previous recipe, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2ba4915-2e5d-4d3e-a893-eab0364df5d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the changes we introduced in the `main()` method as part
    of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`router :=mux.NewRouter()`: Here we instantiated the `gorilla/mux` router calling
    the `NewRouter()` handler of the mux router.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.HandleFunc("/",renderTemplate).Methods("GET")`: Here we registered
    the `/` URL pattern with the `renderTemplate` handler. This means `renderTemplate` will
    execute for every request with the URL pattern `/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.PathPrefix("/").Handler(http.StripPrefix("/static", http.FileServer(http.Dir("static/"))))`:
    Here we are registering `/` as a new route along with setting the handler to be
    executed once it is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.StripPrefix("/static", http.FileServer(http.Dir("static/")))`: This returns
    a handler that serves HTTP requests by removing `/static` from the request URL''s
    path and invoking the file server. `StripPrefix` handles a request for a path
    that doesn''t begin with a prefix by replying with an HTTP 404.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first HTML form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we want to collect the data from the client and send it to the server
    for processing, implementing an HTML form is the best choice. We will be covering
    this in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a simple HTML form that has two input fields
    and a button to submit the form. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `login-form.html` inside the `templates` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the following content to `login-form.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template has two textboxes—`username` and `password`—along with
    a Login button.
  prefs: []
  type: TYPE_NORMAL
- en: On clicking the Login button, the client will make a `POST` call to an action
    defined in an HTML form, which is `/login` in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `html-form.go`, where we will parse the form template and write it onto
    an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9fbfd8c-a74f-4b47-a3b3-4ac7c8ebacf3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d973921-5f28-483f-b58d-77ac105575c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func login(w http.ResponseWriter, r *http.Request) { parsedTemplate, _ :=
    template.ParseFiles("templates/login-form.html") parsedTemplate.Execute(w, nil)
    }`: This is a Go function that accepts `ResponseWriter` and `Request` as input
    parameters, parses `login-form.html`, and returns a new template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.HandleFunc("/", login)`: Here we are registering a login function with
    the `/` URL pattern using `HandleFunc` of the `net/http` package, which means the login
    function gets executed every time we access the HTTP URL with the `/` pattern
    passing `ResponseWriter` and  `Request` as the parameters to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: Here we are calling `http.ListenAndServe` to
    serve HTTP requests that handle each incoming connection in a separate Goroutine.
    `ListenAndServe` accepts two parameters—the server address and the handler—where
    the server address is `localhost:8080` and the handler is `nil`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil { log.Fatal("error starting http server : ", err) return}`:
    Here we check if there is a problem with starting the server. If there is, then
    log the error and exit with a status code of `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading your first HTML form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an HTML form is submitted, we have to read the client data on the server
    side to take an appropriate action. We will be covering this in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already created an HTML form in our previous recipe, we will just
    extend the recipe to read its field values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/schema` package using the `go get` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `html-form-read.go`, where we will read an HTML form field after decoding
    it using the `github.com/gorilla/schema` package and write Hello followed by the
    username to an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b576b702-a85a-4b85-8f84-6107c72022bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we enter the username and password and click on the Login button, we will
    see Hello followed by the username as the response from the server, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0373bdf-58fd-4108-8adf-24e204ff3006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s  understand the changes we introduced as part of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ( "fmt" "html/template" "log" "net/http" "github.com/gorilla/schema")`,
    we imported two additional packages—`fmt` and `github.com/gorilla/schema`—which
    help to convert `structs` to and from `Form` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we defined the `User struct` type, which has `Username` and `Password`
    fields, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we defined the `readForm` handler, which takes `HTTP Request` as an input
    parameter and returns `User`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand this Go function in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r.ParseForm()`: Here we parse the request body as a form and put the results
    into both `r.PostForm` and `r.Form`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user := new(User)`: Here we create a new `User struct` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decoder := schema.NewDecoder()`: Here we are creating a decoder, which we
    will be using to fill a user `struct` with `Form` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decodeErr := decoder.Decode(user, r.PostForm)`: Here we decode parsed form
    data from `POST` body parameters to a user `struct`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r.PostForm` is only available after `ParseForm` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: '`if decodeErr != nil { log.Printf("error mapping parsed form data to struct
    : ", decodeErr) }`: Here we check whether there is any problem with mapping form
    data to a struct. If there is, then log it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we defined a `login` handler, which checks if the HTTP request calling
    the handler is a `GET` request and then parses `login-form.html` from the templates
    directory and writes it to an HTTP response stream; otherwise, it calls the `readForm`
    handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Validating your first HTML form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, we have to validate a client's input before processing it,
    which can be achieved through the number of external packages in Go, such as `gopkg.in/go-playground/validator.v9`, `gopkg.in/validator.v2`,
    and `github.com/asaskevich/govalidator`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be working with the most famous and commonly used validator, 
     `github.com/asaskevich/govalidator`, to validate our HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created and read an HTML form in our previous recipe, we
    will just extend it to validate its field values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install `github.com/asaskevich/govalidator` and the `github.com/gorilla/schema`
    package using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `html-form-validation.go`, where we will read an HTML form, decode it
    using `github.com/gorilla/schema`, and validate each field of it against a tag
    defined in the `User struct` using `github.com/asaskevich/govalidator`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/348772a2-efa6-4d10-85b0-7c8862333408.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then submit the form with the valid values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86cba772-9979-4efc-ace2-bae92d5497be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will show us the Hello followed by the username on a browser screen, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12b1c3c6-f8d8-412e-96a3-b29e20e7d229.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Submitting the form with the value as non-alpha in any of the fields will show
    us the error message. For example, submitting the form with the Username value
    as `1234`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11bbc899-37d9-4d63-8edf-d38a2a63de20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will show us an error message on the browser, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e669f3e-942c-42e1-9c2c-d7ee4b674cf6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, we can submit an HTML form from the command line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the same output that we get in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ad63a7c-1b4b-468d-9dea-3fa04157ba04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s understand the change we introduced in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ("fmt", "html/template", "log", "net/http" "github.com/asaskevich/govalidator"
    "github.com/gorilla/schema" )`, we imported an additional package—`github.com/asaskevich/govalidator`,
    which helps us to validate structs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we updated the `User struct` type to include a string literal tag with
    the `key` as `valid` and `value` as `alpha, required`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next, we defined a `validateUser` handler, which takes `ResponseWriter`, `Request`, and
    `User` as inputs and returns a `bool` and `string`, which are the struct valid
    status and validation error message respectively. In this handler, we validated
    struct tags calling the `ValidateStruct` handler from `govalidator`. If there
    is an error in validating the field, then we fetch the error calling the `ErrorByField` handler
    from `govalidator` and return the result along with the validation error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we updated the `login` handler to call `validateUser` passing `(w http.ResponseWriter,
    r *http.Request, user *User)` as input parameters to it and check for any validation
    errors. If there are errors, then we write an error message to an HTTP response
    stream and return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uploading your first file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common scenarios in any web application is uploading a file
    or a folder to the server. For example, if we are developing a job portal, then
    we may have to provide an option where the applicant can upload their profile/resume,
    or, let's say, we have to develop an e-commerce website with a feature where the
    customer can upload their orders in bulk using a file.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving the functionality to upload a file in Go is quite easy using its built-in
    packages, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create an HTML form with a field of type `file`, which
    lets the user pick one or more files to upload to a server via a form submission.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `upload-file.html` inside the `templates` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the following content to `upload-file.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding template, we defined a field of type `file` along with a `Submit`
    button.
  prefs: []
  type: TYPE_NORMAL
- en: On clicking the Submit button, the client encodes the data that forms the body
    of the request and makes a `POST` call to the form action, which is `/upload`
    in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `upload-file.go`, where we will define handlers to render the file upload
    template, get the file from the request, process it, and write the response to
    an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/670f25ff-f46e-4aec-b0b4-c150b76ba734.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us the File Upload Form, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db929449-393f-4fa5-92ff-368b6c2f5de0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pressing the Submit button after choosing a file will result in the creation of
    a file on the server with the name as `uploadedFile` inside the `/tmp` directory.
    You can see this by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/438fac80-0552-4137-b28f-d6efe696fbfe.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the successful upload will display the message on the browser, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d430fc2d-02ab-4941-86c2-52dccd992090.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the Go program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined the `fileHandler()` handler, which gets the file from the request,
    reads its content, and eventually writes it onto a file on a server. As this handler
    does a lot of things, let’s go through it in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file, header, err := r.FormFile("file")`: Here we call the `FormFile` handler
    on the HTTP request to get the file for the provided form key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil { log.Printf("error getting a file for the provided form key
    : ", err) return }`: Here we check whether there is any problem while getting
    the file from the request. If there is, then log the error and exit with a status
    code of `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defer file.Close()`: The `defer` statement closes the `file` once we return
    from the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`out, pathError := os.Create("/tmp/uploadedFile")`: Here we are creating a
    file named `uploadedFile` inside a `/tmp` directory with mode `666`, which means
    the client can read and write but cannot execute the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if pathError != nil { log.Printf("error creating a file for writing : ", pathError)
    return }`: Here we check whether there are any problems with creating a file on
    the server. If there are, then log the error and exit with a status code of `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_, copyFileError := io.Copy(out, file)`: Here we copy content from the file
    we received to the file we created inside the `/tmp` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt.Fprintf(w, "File uploaded successfully : "+header.Filename)`: Here we
    write a message along with a filename to an HTTP response stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
