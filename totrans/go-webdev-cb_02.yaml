- en: Working with Templates, Static Files, and HTML Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files over HTTP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files over HTTP using Gorilla Mux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first HTML form
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading your first HTML form
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating your first HTML form
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading your first file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, we would like to create HTML forms to get the information from
    a client in a specified format, upload files or folders to the server, and generate
    generic HTML templates, rather than repeating the same static text. With the knowledge
    of the concepts covered in this chapter, we will be able to implement all these
    functionalities efficiently in Go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with creating a basic template and then move
    on to serve static files, such as `.js`, `.css`, and `images` from a filesystem,
    and eventually create, read, and validate HTML forms and upload a file to the
    server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first template
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates allow us to define placeholders for dynamic content that can be replaced
    with the values at runtime by a template engine. They can then be transformed
    into an HTML file and sent to the client. Creating templates in Go is fairly easy
    using Go's `html/template` package, which we will be covering in this recipe.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create a `first-template.html` with a couple
    of placeholders whose value will be injected by the template engine at runtime.
    Perform the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `first-template.html` inside the `templates` directory by executing
    the following Unix command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Copy the following content to `first-template.html`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding template has two placeholders, `{{.Name}}` and `{{.Id}}`, whose
    values will be substituted or injected by the template engine at runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `first-template.go`, where we will populate the values for the placeholders,
    generate an HTML as an output, and write it to the client, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab60eb27-0295-4b8a-9c7b-9d85f6c65b55.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing `http://localhost:8080` will show us the Hello Foo! served by the
    template engine, as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f54a702f-1181-404b-8c55-f0502b2365fb.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Execute `curl -X GET http://localhost:8080` from the command line as:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will result in the following response from the server:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5125ff70-60b0-4b27-a291-1fd30a424f85.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the Go program we have written:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`type Person struct { Id string Name string }`: Here we define a `person` struct
    type that has `Id` and `Name` fields.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field name should begin with a capital letter in the type definition; otherwise, it
    will result in errors and will not be replaced in the template.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined a `renderTemplate()` handler, which does a lot of things.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '`person := Person{Id: "1", Name: "Foo"}`: Here we are initializing a `person`
    struct type with `Id` as `1` and `Name` as `Foo`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parsedTemplate, _ := template.ParseFiles("templates/first-template.html")`: Here
    we are calling `ParseFiles` of the `html/template` package, which creates a new
    template and parses the filename we pass as an input, which is `first-template.html
    ,`in a templates directory. The resulting template will have the name and contents
    of the input file.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := parsedTemplate.Execute(w, person)`: Here we are calling an `Execute`
    handler on a parsed template, which injects `person` data into the template, generates
    an HTML output, and writes it onto an HTTP response stream.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil {log.Printf("Error occurred while executing the template or
    writing its output : ", err) return }`: Here we check whether there are any problems
    while executing the template or writing its output on the response stream. If
    there are, then we log the error and exit with a status code of 1.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files over HTTP
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While designing web applications, it’s always a best practice to serve static
    resources, such as `.js`, `.css`, and `images` from the filesystem, or any **content
    delivery network** (**CDN**), such as Akamai or Amazon CloudFront, rather than
    serving it from the web server. This is because all these types of files are static
    and do not need to be processed; so why should we put extra load on the server?
    Moreover, it helps to boost application performance, as all the requests for the
    static files will be served from external sources and therefore reduce the load
    on the server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Go's `net/http` package is sufficient enough for serving static resources from
    the filesystem through `FileServer`, which we will be covering in this recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created a template in our previous recipe, we will just extend
    it to serve a static `.css` file from the `static/css` directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create a file server that will serve static
    resources from the filesystem. Perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `main.css` inside a `static/css` directory, as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Copy the following content to `main.css`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create `serve-static-files.go`, where we will create `FileServer`, which will
    serve resources from the `static/css` directory present on the filesystem for
    all URL patterns with  `/static`, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update `first-template.html` (created in our previous recipe) to include `main.css`
    from the `static/css` directory:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94798377-1729-4559-9e5c-6c4ca2fa2f59.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us the same output we saw in
    our previous recipe, but this time the text color has changed from the default
    **black** to **blue**, as shown in the following image:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07fd3f5a-f8c5-4976-98b3-5527c8372755.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: If we look at the Network tab of Chrome DevTools, we can see `main.css`, which
    has been loaded from the `static/css` directory present on the filesystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the changes we introduced in the `main()` method as part
    of this recipe:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`fileServer := http.FileServer(http.Dir("static"))`: Here, we created a file
    server using the `FileServer` handler of the `net/http` package, which serves
    HTTP requests from the `static` directory present on the filesystem.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.Handle("/static/", http.StripPrefix("/static/", fileServer))`: Here,
    we are registering the `http.StripPrefix("/static/", fileServer)` handler with
    the `/static` URL pattern using `HandleFunc` of the `net/http` package, which
    means  `http.StripPrefix("/static/", fileServer)` gets executed and passes `(http.ResponseWriter,
    *http.Request)` as a parameter to it whenever we access the HTTP URL with the `/static` pattern.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.StripPrefix("/static/", fileServer)`: This returns a handler that serves
    HTTP requests by removing `/static` from the request URL''s path and invokes the
    file server. `StripPrefix` handles a request for a path that doesn''t begin with
    a prefix by replying with an HTTP 404.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files over HTTP using Gorilla Mux
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we served `static` resources through Go's HTTP file
    server. In this recipe, we will look at how we can serve it through the Gorilla
    Mux router, which is also one of the most common ways of creating an HTTP router.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created a template which serves `main.css` from the `static/css`
    directory present on the filesystem in our previous recipe, we will just update
    it to use the Gorilla Mux router.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/mux` package using the `go get` command, as
    follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create `serve-static-files-gorilla-mux.go`, where we will create a Gorilla
    Mux router instead of an HTTP `FileServer`, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the program with the following command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing `http://localhost:8080` will show us the same output we saw in our
    previous recipe, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2ba4915-2e5d-4d3e-a893-eab0364df5d8.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the changes we introduced in the `main()` method as part
    of this recipe:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`router :=mux.NewRouter()`: Here we instantiated the `gorilla/mux` router calling
    the `NewRouter()` handler of the mux router.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.HandleFunc("/",renderTemplate).Methods("GET")`: Here we registered
    the `/` URL pattern with the `renderTemplate` handler. This means `renderTemplate` will
    execute for every request with the URL pattern `/`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router.PathPrefix("/").Handler(http.StripPrefix("/static", http.FileServer(http.Dir("static/"))))`:
    Here we are registering `/` as a new route along with setting the handler to be
    executed once it is called.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.StripPrefix("/static", http.FileServer(http.Dir("static/")))`: This returns
    a handler that serves HTTP requests by removing `/static` from the request URL''s
    path and invoking the file server. `StripPrefix` handles a request for a path
    that doesn''t begin with a prefix by replying with an HTTP 404.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first HTML form
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we want to collect the data from the client and send it to the server
    for processing, implementing an HTML form is the best choice. We will be covering
    this in this recipe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a simple HTML form that has two input fields
    and a button to submit the form. Perform the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `login-form.html` inside the `templates` directory, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Copy the following content to `login-form.html`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding template has two textboxes—`username` and `password`—along with
    a Login button.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: On clicking the Login button, the client will make a `POST` call to an action
    defined in an HTML form, which is `/login` in our case.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `html-form.go`, where we will parse the form template and write it onto
    an HTTP response stream, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9fbfd8c-a74f-4b47-a3b3-4ac7c8ebacf3.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d973921-5f28-483f-b58d-77ac105575c0.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'Let’s understand the program we have written:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`func login(w http.ResponseWriter, r *http.Request) { parsedTemplate, _ :=
    template.ParseFiles("templates/login-form.html") parsedTemplate.Execute(w, nil)
    }`: This is a Go function that accepts `ResponseWriter` and `Request` as input
    parameters, parses `login-form.html`, and returns a new template.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.HandleFunc("/", login)`: Here we are registering a login function with
    the `/` URL pattern using `HandleFunc` of the `net/http` package, which means the login
    function gets executed every time we access the HTTP URL with the `/` pattern
    passing `ResponseWriter` and  `Request` as the parameters to it.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: Here we are calling `http.ListenAndServe` to
    serve HTTP requests that handle each incoming connection in a separate Goroutine.
    `ListenAndServe` accepts two parameters—the server address and the handler—where
    the server address is `localhost:8080` and the handler is `nil`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil { log.Fatal("error starting http server : ", err) return}`:
    Here we check if there is a problem with starting the server. If there is, then
    log the error and exit with a status code of `1`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading your first HTML form
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an HTML form is submitted, we have to read the client data on the server
    side to take an appropriate action. We will be covering this in this recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already created an HTML form in our previous recipe, we will just
    extend the recipe to read its field values.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/schema` package using the `go get` command,
    as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create `html-form-read.go`, where we will read an HTML form field after decoding
    it using the `github.com/gorilla/schema` package and write Hello followed by the
    username to an HTTP response stream, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the program with the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b576b702-a85a-4b85-8f84-6107c72022bb.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'Once we enter the username and password and click on the Login button, we will
    see Hello followed by the username as the response from the server, as shown in
    the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0373bdf-58fd-4108-8adf-24e204ff3006.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'Let’s  understand the changes we introduced as part of this recipe:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ( "fmt" "html/template" "log" "net/http" "github.com/gorilla/schema")`,
    we imported two additional packages—`fmt` and `github.com/gorilla/schema`—which
    help to convert `structs` to and from `Form` values.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we defined the `User struct` type, which has `Username` and `Password`
    fields, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we defined the `readForm` handler, which takes `HTTP Request` as an input
    parameter and returns `User`, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s understand this Go function in detail:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '`r.ParseForm()`: Here we parse the request body as a form and put the results
    into both `r.PostForm` and `r.Form`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user := new(User)`: Here we create a new `User struct` type.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decoder := schema.NewDecoder()`: Here we are creating a decoder, which we
    will be using to fill a user `struct` with `Form` values.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decodeErr := decoder.Decode(user, r.PostForm)`: Here we decode parsed form
    data from `POST` body parameters to a user `struct`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r.PostForm` is only available after `ParseForm` is called.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`if decodeErr != nil { log.Printf("error mapping parsed form data to struct
    : ", decodeErr) }`: Here we check whether there is any problem with mapping form
    data to a struct. If there is, then log it.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we defined a `login` handler, which checks if the HTTP request calling
    the handler is a `GET` request and then parses `login-form.html` from the templates
    directory and writes it to an HTTP response stream; otherwise, it calls the `readForm`
    handler, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Validating your first HTML form
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, we have to validate a client's input before processing it,
    which can be achieved through the number of external packages in Go, such as `gopkg.in/go-playground/validator.v9`, `gopkg.in/validator.v2`,
    and `github.com/asaskevich/govalidator`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be working with the most famous and commonly used validator, 
     `github.com/asaskevich/govalidator`, to validate our HTML form.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created and read an HTML form in our previous recipe, we
    will just extend it to validate its field values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install `github.com/asaskevich/govalidator` and the `github.com/gorilla/schema`
    package using the `go get` command, as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create `html-form-validation.go`, where we will read an HTML form, decode it
    using `github.com/gorilla/schema`, and validate each field of it against a tag
    defined in the `User struct` using `github.com/asaskevich/govalidator`, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the program with the following command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/348772a2-efa6-4d10-85b0-7c8862333408.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Then submit the form with the valid values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86cba772-9979-4efc-ace2-bae92d5497be.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'It will show us the Hello followed by the username on a browser screen, as
    shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12b1c3c6-f8d8-412e-96a3-b29e20e7d229.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Submitting the form with the value as non-alpha in any of the fields will show
    us the error message. For example, submitting the form with the Username value
    as `1234`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11bbc899-37d9-4d63-8edf-d38a2a63de20.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'It will show us an error message on the browser, as shown in the following
    screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e669f3e-942c-42e1-9c2c-d7ee4b674cf6.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, we can submit an HTML form from the command line as:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will give us the same output that we get in the browser:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ad63a7c-1b4b-468d-9dea-3fa04157ba04.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'Let’s understand the change we introduced in this recipe:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ("fmt", "html/template", "log", "net/http" "github.com/asaskevich/govalidator"
    "github.com/gorilla/schema" )`, we imported an additional package—`github.com/asaskevich/govalidator`,
    which helps us to validate structs.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we updated the `User struct` type to include a string literal tag with
    the `key` as `valid` and `value` as `alpha, required`, as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we defined a `validateUser` handler, which takes `ResponseWriter`, `Request`, and
    `User` as inputs and returns a `bool` and `string`, which are the struct valid
    status and validation error message respectively. In this handler, we validated
    struct tags calling the `ValidateStruct` handler from `govalidator`. If there
    is an error in validating the field, then we fetch the error calling the `ErrorByField` handler
    from `govalidator` and return the result along with the validation error message.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we updated the `login` handler to call `validateUser` passing `(w http.ResponseWriter,
    r *http.Request, user *User)` as input parameters to it and check for any validation
    errors. If there are errors, then we write an error message to an HTTP response
    stream and return it.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uploading your first file
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common scenarios in any web application is uploading a file
    or a folder to the server. For example, if we are developing a job portal, then
    we may have to provide an option where the applicant can upload their profile/resume,
    or, let's say, we have to develop an e-commerce website with a feature where the
    customer can upload their orders in bulk using a file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Achieving the functionality to upload a file in Go is quite easy using its built-in
    packages, which we will be covering in this recipe.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create an HTML form with a field of type `file`, which
    lets the user pick one or more files to upload to a server via a form submission.
    Perform the following steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `upload-file.html` inside the `templates` directory, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Copy the following content to `upload-file.html`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding template, we defined a field of type `file` along with a `Submit`
    button.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: On clicking the Submit button, the client encodes the data that forms the body
    of the request and makes a `POST` call to the form action, which is `/upload`
    in our case.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `upload-file.go`, where we will define handlers to render the file upload
    template, get the file from the request, process it, and write the response to
    an HTTP response stream, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/670f25ff-f46e-4aec-b0b4-c150b76ba734.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Run the program with the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us the File Upload Form, as
    shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db929449-393f-4fa5-92ff-368b6c2f5de0.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'Pressing the Submit button after choosing a file will result in the creation of
    a file on the server with the name as `uploadedFile` inside the `/tmp` directory.
    You can see this by executing the following commands:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/438fac80-0552-4137-b28f-d6efe696fbfe.png)**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the successful upload will display the message on the browser, as shown
    in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d430fc2d-02ab-4941-86c2-52dccd992090.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the Go program we have written:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined the `fileHandler()` handler, which gets the file from the request,
    reads its content, and eventually writes it onto a file on a server. As this handler
    does a lot of things, let’s go through it in detail:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`fileHandler()`处理程序，它从请求中获取文件，读取其内容，最终将其写入服务器上的文件。由于这个处理程序做了很多事情，让我们逐步详细介绍一下：
- en: '`file, header, err := r.FormFile("file")`: Here we call the `FormFile` handler
    on the HTTP request to get the file for the provided form key.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file, header, err := r.FormFile("file")`: 在这里，我们调用HTTP请求的`FormFile`处理程序，以获取提供的表单键对应的文件。'
- en: '`if err != nil { log.Printf("error getting a file for the provided form key
    : ", err) return }`: Here we check whether there is any problem while getting
    the file from the request. If there is, then log the error and exit with a status
    code of `1`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if err != nil { log.Printf("error getting a file for the provided form key
    : ", err) return }`: 在这里，我们检查是否在从请求中获取文件时出现了任何问题。如果有问题，记录错误并以状态码`1`退出。'
- en: '`defer file.Close()`: The `defer` statement closes the `file` once we return
    from the function.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer file.Close()`: `defer`语句会在函数返回时关闭`file`。'
- en: '`out, pathError := os.Create("/tmp/uploadedFile")`: Here we are creating a
    file named `uploadedFile` inside a `/tmp` directory with mode `666`, which means
    the client can read and write but cannot execute the file.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out, pathError := os.Create("/tmp/uploadedFile")`: 在这里，我们创建了一个名为`uploadedFile`的文件，放在`/tmp`目录下，权限为`666`，这意味着客户端可以读写但不能执行该文件。'
- en: '`if pathError != nil { log.Printf("error creating a file for writing : ", pathError)
    return }`: Here we check whether there are any problems with creating a file on
    the server. If there are, then log the error and exit with a status code of `1`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if pathError != nil { log.Printf("error creating a file for writing : ", pathError)
    return }`: 在这里，我们检查在服务器上创建文件时是否出现了任何问题。如果有问题，记录错误并以状态码`1`退出。'
- en: '`_, copyFileError := io.Copy(out, file)`: Here we copy content from the file
    we received to the file we created inside the `/tmp` directory.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_, copyFileError := io.Copy(out, file)`: 在这里，我们将从接收到的文件中的内容复制到`/tmp`目录下创建的文件中。'
- en: '`fmt.Fprintf(w, "File uploaded successfully : "+header.Filename)`: Here we
    write a message along with a filename to an HTTP response stream.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Fprintf(w, "File uploaded successfully : "+header.Filename)`: 在这里，我们向HTTP响应流写入一条消息和文件名。'
