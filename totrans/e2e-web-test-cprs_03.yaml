- en: '*Chapter 2*: Differences between Selenium WebDriver and Cypress'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both Cypress and Selenium WebDriver are test automation frameworks that support
    end-to-end testing, and when someone mentions Cypress, there is a quick need to
    compare or find out which is better than the other. Before we get started on understanding
    the differences between Selenium WebDriver and Cypress, we will first need to
    understand the different motives for development between the two testing frameworks
    and who their intended users are.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the reasons why both Cypress and Selenium WebDriver are architecturally
    different will play a major role in helping you understand different and similar
    aspects of both the Selenium WebDriver and Cypress frameworks. In this section,
    we will evaluate ways in which both WebDriver and Cypress are unique, different,
    and similar in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the different use cases for both Selenium WebDriver and Cypress,
    and examine how each one is suitable for the purpose of its use. We will also
    clearly identify the audience of each of the testing frameworks, and what you
    can gain from both or each of them. We will describe why you should choose Cypress
    as a test automation framework and why it is a perfect candidate for end-to-end
    testing automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After understanding the differences and similarities between Cypress and WebDriver
    we will conclude by listing factors and tools that make it stand out and put it
    ahead of the curve when it comes to end-to-end web testing automation. The following
    are the key topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why choose Cypress?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing Cypress and Selenium WebDriver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress for frontend testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to understand the ways in which
    Cypress is different and similar to Selenium WebDriver and how it shows prowess
    in frontend web automation testing.
  prefs: []
  type: TYPE_NORMAL
- en: Why choose Cypress?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress is an end-to-end testing framework that is written by developers, for
    developers and **Quality Assurance** (**QA**) engineers. Cypress focuses on testing
    web applications and since the only way to automate the web is by using JavaScript,
    Cypress only supports the use of JavaScript to write its tests.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress was specifically written for frontend teams that utilize JavaScript
    for the development of their products, along with teams that need to quickly get
    started with the process of writing unit, integration, and end-to-end tests without
    the complicated intricacies of properly setting up a testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress is not only beginner-friendly, but also ensures that everything that
    a developer or a QA engineer needs to get started on their tests is already packaged
    in the bundle that is downloaded and installed from the Cypress website. Cypress
    comes bundled with its own browser, a test runner, and chai as an assertion framework.
  prefs: []
  type: TYPE_NORMAL
- en: Having a bundle that contains everything required to get started with the process
    of writing tests means that anyone can just get started on the business of testing
    without needing to know about the setup process for assertion frameworks, test
    runners, or even the addition of browser drivers, such as in the case of using
    Selenium WebDriver.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress makes use of JavaScript, which makes it significantly easier for JavaScript
    developers to onboard and quickly grasp the Cypress concepts. The ease of onboarding
    also ensures that developers and QA engineers can quickly get up to speed with
    writing tests using Cypress. Since Cypress is developed in JavaScript, developers
    and QA teams using JavaScript find it easier to debug and also understand the
    errors as they are similar to those in JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress utilizes a universal driver that is currently compatible with Firefox,
    Edge, Chrome, and the Chromium family of browsers. Unlike Selenium, which utilizes
    WebDriver and interacts with the **Document Object Model** (**DOM**) using HTTP
    network requests, the Cypress driver works directly in the browser without the
    need to make network requests. The ability to run inside the browser with the
    tests ensures that Cypress can effectively interpret commands without introducing
    timeouts when commands are passed from the tests to the driver and then to the
    application running in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a universal driver also ensures that Cypress maintains the consistency
    of the methods that are utilized in all the browsers and also a standard format
    for the tests regardless of the browser that the tests will be run in. With this
    approach, it is possible for a QA team or an individual developer to grow their
    cross-browser testing as the only required thing is to run their existing test
    suites against the newly supported browser with Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: The Cypress framework runs on the browser as it's architecturally different
    from any other test automation tools such as Selenium WebDriver. The ability of
    Cypress to run on the browser gives it a competitive advantage over other automation
    tools as it comes packaged with automatic wait sequences that could otherwise
    need to be defined in tests. Cypress therefore knows when to wait for an event,
    such as a network request, which would otherwise need to be specified as an explicit
    or implicit wait in a Selenium-driven test.
  prefs: []
  type: TYPE_NORMAL
- en: Software development technologies such as JavaScript frameworks change quickly
    than the testing technologies and frameworks that are available. Cypress presents
    a unique opportunity where the developers and QA engineers can quickly get started
    with the process of writing tests without the need to worry that a testing setup
    needs to be done. Removing the worry about the underlying test infrastructure
    not only quickens the testing process but also ensures that teams can quickly
    get started with the tasks that matter and are critical in the software development
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Recap â€“ why choose Cypress?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned why Cypress is a preferred choice when it comes
    to web development testing and what makes it stand out from other test frameworks,
    including Selenium WebDriver. In the next section, we will be directly comparing
    the differences and similarities between Cypress and Selenium WebDriver.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Cypress and Selenium WebDriver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is easy to fall into the trap of making assumptions that Cypress is a replacement
    for Selenium WebDriver and that its use could render Selenium WebDriver completely
    obsolete in the world of testing automation. While it is simple to directly assume
    that either Cypress is better or superior to Selenium or the other way round,
    this thinking is flawed and is incorrect in most instances.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover why Cypress is unique and how its purpose is
    more complementary to Selenium WebDriver than supplementary. The following sections
    outline some of the differences between Selenium WebDriver and Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Browser driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress utilizes a custom universal driver for all the browsers that it supports,
    while on the other hand, Selenium WebDriver utilizes different drivers for each
    of the different browsers that it supports. The ability to use a universal driver
    for all the browsers means that on installation, we can run our tests on all the
    Cypress-supported browsers without the need to install an external driver. Selenium,
    on the other hand, requires a driver for every browser to be able to run tests
    in different browsers. The universal driver also gives Cypress a competitive edge
    as the team developing it is able to fix problems that are common in WebDriver,
    and can extend the functionality to different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Retries and waits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress comes with built-in explicit retries to search for elements in the **DOM**
    and explicitly waits for events to happen before a test is considered to have
    failed. Cypress comes coupled with events that determine whether requests need
    to be waited for before the browser decides whether they have failed or passed.
    Cypress is able to handle the waits and retries because it runs on the browser
    with the tests and is able to understand the state of the tests at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium, on the other hand, utilizes HTTP requests to WebDriver and it is therefore
    difficult for the framework to determine whether explicit or implicit waits are
    required when the tests are running. To solve the problem, Selenium users have
    to write the waits themselves in situations where the tests would need to wait
    for a request to complete before proceeding to the next step of execution. Selenium
    also does not come bundled with automatic retries when the tests are run, a feature
    that Cypress does possess.
  prefs: []
  type: TYPE_NORMAL
- en: Target usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress is built for JavaScript developers and QA engineers who want to quickly
    set up an automation framework and get to testing their end-to-end web applications,
    without spending too much bandwidth on setting up test frameworks or understanding
    the technologies behind building test frameworks. With Cypress, it is easy for
    developers to go beyond writing unit tests, to writing integration tests and even
    acceptance tests with features such as stubbing external dependencies, and testing
    how their applications behave. Cypress also currently favors developers and QA
    practices that are consistent with the Chromium family of browsers including Edge,
    with the addition of Firefox, which is currently in beta testing.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Selenium WebDriver is built to test anything that runs on
    the web. Selenium focuses on QA teams that want to test every aspect of their
    web applications and is not limited by factors such as browser compatibility or
    a single test runner, which is the case in Cypress. Selenium WebDriver gives the
    user options to extend it with different browsers and plugins, and also supports
    different languages such asÂ Java,Â Python,Â Ruby, C#, JavaScript,Â Perl,Â andÂ PHP.
    It is really difficult to plainly say that Selenium is a direct competitor to
    Cypress, as we can vividly see that while their use cases are closely similar,
    their audience and target users are totally different. While Selenium targets
    users of all major development languages, supporting even mobile automation in
    tools such as Appium, Cypress is only focused on making testing better for JavaScript
    web developers and QA engineers that understand the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress runs on the browser and this gives it an edge over tools such as Selenium
    WebDriver. Running on the browser means that Cypress is significantly faster and
    can interpret commands quicker at runtime, as there are no third-party services
    interpreting the commands on its behalf or sending HTTP requests to the browser
    driver. While all the Cypress commands run inside the browser, it is possible
    for Cypress to tell what is happening outside the browser, as it has access to
    everything that the application has, including the window object, the DOM, a document
    object, or any other process and method. As long as your application has access,
    then Cypress tests will have access. The following diagram shows the architecture
    of Cypress versus the Selenium WebDriver architecture. Where in Cypress, the execution
    takes place in the browser, in Selenium, the execution takes place outside the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 â€“ Selenium versus the Cypress test execution architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Chapter_2_Image01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 â€“ Selenium versus the Cypress test execution architecture
  prefs: []
  type: TYPE_NORMAL
- en: Cross-browser compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress does not currently support all major browsers in the way Selenium WebDriver
    does. Cypress is currently supporting browsers built using the Chromium open source
    project, Firefox, Edge, and Electron (the default browser in Cypress). On the
    other hand, Selenium has support for all major browsers and this gives it an advantage
    when it comes to the ability to test applications on multiple platforms. While
    it is possible to argue that cross-browser functionality across more than three
    browsers increases the architecture complexity with minimal value to the testing
    process, support for multiple browsers may lead to identifying bugs that are of
    high priority, even though the severity of the bugs could potentially be low.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress trade-offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, Cypress is a test automation tool that is focused on
    end-to-end test automation on the browser. Being able to run on the browser means
    that Cypress can interact with the elements on the browser better than any other
    tools but it also means that Cypress has permanent trade-offs that cannot be changed
    due to its architecture. The trade-offs are described in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Scope limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cypress works best when used as an automation utility for QA engineers and developers
    who are writing tests. Cypress does not support tools for manual automation and
    has no plans to integrate manual testing tools in the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress is also not designed for activities such as web indexing and performance
    testing, and carrying out such activities may reduce the performance ability of
    the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Environment limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cypress runs on the browser and that means the language it supports will always
    be JavaScript, as the test code will always be evaluated in the browser. Being
    able to run in the browser means that to connect to a database or a server we
    can only use the Cypress commands of `cy.exec()`, `cy.request()`, or `cy.task()`,
    which provide a way to expose the database or the server, which might be more
    work than if we could explicitly define their configurations and Cypress understood
    them. Having tests run in the browser creates a great experience for running tests,
    but it is a little cumbersome to plug in functionality that needs to run outside
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple browsers and multiple tabs â€“ limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Cypress framework does not support the ability for a test to control multiple
    browsers when running. This is a permanent trade-off since the ability to control
    multiple browsers is not possible when running tests within one browser.
  prefs: []
  type: TYPE_NORMAL
- en: The Cypress framework does not support the ability to interact with more than
    one browser tab, as this functionality is not exposed inside the browser. However,
    Cypress provides the ability to incorporate other tools such as Selenium or Puppeteer
    to operate and drive multiple browser tabs when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Control origin limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cypress only supports visiting URLs that are from the same origin in the same
    test. The control origin limitation means that for any particular test, you are
    not able to visit different URLs that do not belong to the same origin. An example
    would be trying to send a request to [https://github.com](https://github.com)
    and [https://gitlab.com](https://gitlab.com) in the same test, which would lead
    to an error. The following examples illustrate the improper and proper ways of
    utilizing the cross-origin when writing Cypress tests.
  prefs: []
  type: TYPE_NORMAL
- en: The proper way of utilizing cross-origin to run tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following test, the user prompts Cypress to first navigate to the [https://github.com](https://github.com)
    GitHub website and then to [https://docs.github.com/en](https://docs.github.com/en)
    (documentation link) for the GitHub resources. Both of the links belong to the
    same origin, `github.com`, and therefore Cypress would have no issue executing
    the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The improper way of utilizing cross-origin to run tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this test, the user prompts Cypress to first navigate to [https://github.com](https://github.com),
    then later navigate to https://gitlab.com, which is of a different origin to the
    first URL. This will lead to an error being thrown when the test is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Cypress and Selenium complementary actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can utilize both Cypress and Selenium together in some instances that are
    rare but still achievable when writing our tests. While Cypress has the limitation
    of not being able to control more than one browser tab, it is possible to configure
    Cypress to use Selenium to run multiple tabs. We can also utilize Cypress for
    our end-to-end tests and Selenium for activities such as load tests. Selenium
    has the ability to perform tests such as load tests, which are not supported in
    Cypress, and in such instances both test frameworks can be utilized together.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress is built for the web and is optimized to run on browsers. The architecture
    of Cypress allows it to effectively run tests, while at the same time overcoming
    the challenges of WebDriver. While Cypress is able to run on the browser, WebDriver
    interacts with the browser using the HTTP protocol, hence causing delays and unknown
    wait events when running tests. Cypress also targets QA engineers and developers
    who are looking to write tests without worrying about the underlying infrastructure
    and the limitation of one assertion library and programming language. Cypress
    also promises a future, as plans are underway to support Safari and Internet Explorer,
    that will ensure that developers and testers can try out Cypress on the browser
    of their choice.
  prefs: []
  type: TYPE_NORMAL
- en: With all the perks that Cypress comes bundled with, it also comes with some
    temporary and permanent trade-offs. Some of the temporary trade-offs are the ability
    to support all major browsers or to perform certain functions such as hovering
    over an element. The permanent trade-offs on the other hand mean that the architecture
    of Cypress cannot support them even in the future. They include aspects such as
    controlling multiple open browsers and/or operating multiple tabs in browsers,
    being able to connect to external databases and servers, and calling different
    cross-origins. All of the permanent trade-offs have workarounds and users can
    always implement the workarounds at will. Cypress, however, advises that workarounds
    should not be used in cases that would stretch Cypress beyond its intended purpose.
    Using Cypress for non-intended purposes may cause hurdles such as test automation
    complexity, which could end up reducing the effectiveness of Cypress as an automation
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Recap â€“ comparing Cypress and Selenium WebDriver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned the advantages of using Cypress and also compared
    it to using Selenium to write tests. We also identified why Selenium is architecturally
    different from Cypress and why both are more complementary than they are supplementary.
    We explored the trade-offs that Cypress has and some of the solutions to overcome
    the trade-offs that are permanent in the Cypress automation framework. In the
    next section, we will dive into the tools that make Cypress the best candidate
    for end-to-end web test automation.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress for frontend applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress is built for the web, and that means it comes packed with some tools
    and features that other frameworks may not have. This improves the testing experience
    for frontend web developers and QA engineers. In this section, we will explore
    the different elements that Cypress is packed with that make it convenient and
    easy for its users to jump in and get started. The following are some of the elements
    that make Cypress stand out from other test automation frameworks for frontend
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Test Runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Cypress Test Runner comes by default when Cypress is installed on the user's
    machine. It is an interactive user interface that allows the user of the Cypress
    framework to see the commands that are running in the tests, and also the application
    that is under test as the commands interact with it. The Test Runner has the ability
    to show the number of test failures, test passes, skipped tests, the command log,
    and even the viewport of the browser when the tests are running.
  prefs: []
  type: TYPE_NORMAL
- en: Setup process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in the previous chapter, the setup process of Cypress is not only
    clear and simple but it also ensures that the QA engineers and frontend developers
    need to run a single command to install Cypress. This eliminates the need to configure
    external dependencies to get started on the process of writing their tests. The
    Cypress documentation is also very interactive and clear, which makes it easy
    for developers and QA engineers to quickly onboard and use Cypress features.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation and debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress Test Runner comes with a built-in command log, and this means that when
    in **debug mode**, the user is able to check in real time the commands and assertions
    that have passed and the others that have failed. The ability to highlight failed
    commands and check which elements failed to be called, or what functions failed,
    is a capability that makes Cypress stand out, as debugging frontend applications
    not only becomes a walk in the park, but it also saves on the time that could
    have been used to investigate the cause of the failures. The command log also
    gives Cypress users instant feedback, and they can tell whether the tests have
    been properly written or not, just by checking the commands that are running on
    the Test Runner.
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive testing capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress combines the ability to write functional tests and also check responses
    from API calls made by the frontend. It also comes with visual regression capabilities
    that can identify whether an intentional change was made to the application under
    test.
  prefs: []
  type: TYPE_NORMAL
- en: When writing functional tests, the Cypress framework checks that the frontend
    functionality works as stipulated in the requirements document, and this would
    involve a process such as clicking a button or signing up a user.
  prefs: []
  type: TYPE_NORMAL
- en: API verification tests on the other hand check that the returned **XHR** (**XMLHttpRequest**)
    requests are successful with the correct responses received when the requests
    are returned. XHR requests provide an extra verification layer for API tests,
    as we can confirm that the structure of the expected data is similar to what we
    received in the frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: XHR works as an API but is represented in the form of an object, and its main
    purpose is to transfer data between a given web server and a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Visual regression tests check the consistency of the elements in a page by comparing
    a page snapshot of the baseline to that of the latest test runs. If differences
    are spotted, then the tests being run will fail. On failure, a snapshot showing
    the differences between expected and generated images is created to show the differences
    between the generated snapshot and the baseline image. After a test run, the QA
    engineer or developer can then accept or reject the changes that have been made
    to the frontend application in relation to the application changes.
  prefs: []
  type: TYPE_NORMAL
- en: Recap â€“ Cypress for frontend applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned why Cypress is the most suitable when it comes to
    testing frontend applications. We learned of different elements that make it a
    preferable testing framework and the way that we can leverage its strengths to
    write better and more exhaustive tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is without a doubt that Cypress is a powerful tool that can be leveraged
    by frontend teams and QA engineers to quickly get started and write tests without
    worrying about the overhead that comes with building test automation tools from
    the ground up. In this chapter, we learned why Cypress is the best web automation
    framework for testing, and we did this by comparing the different tools between
    Cypress and existing test automation tools. We also covered the differences between
    Cypress and Selenium, and the specific architectural similarities and differences
    between the two. Finally, we explored how we can leverage the tools. In the next
    chapter, we will learn how to use command-line tools to run, test, and debug Cypress
    tests.
  prefs: []
  type: TYPE_NORMAL
