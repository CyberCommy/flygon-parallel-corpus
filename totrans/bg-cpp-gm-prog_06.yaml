- en: Chapter 6.  Object-Oriented Programming, Classes, and SFML Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the longest chapter of the book. There is a fair amount of theory, but
    the theory will give us the knowledge to start using **Object-Oriented Programming**
    (**OOP**) to powerful effect. Furthermore, we will not waste any time in putting
    that theory to good use. Before we explore C++ OOP, we will find out about and
    plan our next game project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we will do in the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Plan the **Zombie Arena** game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about OOP and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code the `Player` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the SFML `View` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the Zombie Arena game engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the `Player` class to work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning and starting the Zombie Arena game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, if you haven't already, I suggest you go and watch a video of
    Over 9,000 Zombies ([http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/))
    and Crimson Land ([http://store.steampowered.com/app/262830/](http://store.steampowered.com/app/262830/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our game will obviously not be as in-depth or advanced as either of the examples
    but we will have the same basic set of features and game mechanics:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Heads-up Display** (**HUD**) that shows details such as score, high score,
    bullets in clip,total bullets left, player health, and zombies left to kill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player will shoot zombies while frantically running away from them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move around a scrolling world using the  ***W*, *A*, *S*, and *D*** keys while
    aiming the gun using the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In between each level, choose a **level up** that will affect the way the game
    needs to be played to succeed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collect **pick-ups** to restore health and ammunition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each wave brings more zombies and a bigger arena
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There will be three types of zombie to splatter. They will have different attributes
    such as appearance, health, and speed. We will call them chasers, bloaters, and
    crawlers. Take a look at this annotated screenshot of the game to see some of
    the features in action and the components and assets that make up the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Planning and starting the Zombie Arena game](img/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a little bit more information about each of the numbered points:'
  prefs: []
  type: TYPE_NORMAL
- en: The **SCORE** and **HI SCORE**. These, along with the other parts of the HUD,
    will be drawn in a separate layer, known as a **View**. The hi-score will be saved
    and loaded to a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a texture that will build a wall around the arena. This texture is contained
    in a single graphic called a **sprite-sheet**, along with the other background
    textures (3, 5, and 6).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first of two mud textures from the sprite-sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is an **ammo pick-up**. When the player gets this they will be given more
    ammunition. There is a **health pick-up** as well. The players can choose to upgrade these
    pick-ups in between waves of zombies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A grass texture, also from the sprite-sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second mud texture from the sprite-sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A blood splat where there used to be a zombie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bottom part of the HUD. From left to right there is an icon to represent
    ammo, the number of bullets in the clip, the number of spare bullets, a health
    bar, the current wave of zombies, and the number of zombies remaining in this
    wave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A crosshair which the player aims with the mouse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A slow-moving but strong bloater zombie
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A slightly faster-moving but weaker crawler zombie. There is also a chaser zombie
    who is very fast and weak. Unfortunately, I couldn't manage to get one in the
    screenshot before they were all killed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a lot to do and new C++ skills to learn. Let's start by creating a new
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project from the template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a new project is now extremely easy. Just follow these straightforward
    steps in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File** | **New Project** from the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that **Visual C++** is selected in the left-hand menu and then select
    **HelloSFML** from the list of presented options. This next image should make
    this clear:![Creating a project from the template](img/image_06_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Name:** field, type `ZombieArena` and also make sure that the **Create
    directory for solution** option is checked. Now click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to copy the SFML `.dll` files into the main project directory. My
    main project directory is `D:\Visual Studio Stuff\Projects\ ZombieArena\ZombieArena`.
    This folder was created by Visual Studio in the previous step. If you put your
    `Projects` folder somewhere else then perform this step there instead. The files
    we need to copy in to the `Projects` folder are located in your `SFML\bin` folder.
    Open a window for each of the two locations and highlight the required `.dll`
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now copy and paste the highlighted files into the project. The project is now
    set up and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: The project assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The assets in this project are more numerous and diverse than the previous
    game. The assets include:'
  prefs: []
  type: TYPE_NORMAL
- en: A font for the writing on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound effects for different actions such as shooting, reloading, or getting
    hit by a zombie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the graphics for the character, zombies, background, and sound required
    for the game are included in the download bundle. They can be found in the `Chapter
    6/graphics`, and `Chapter 6/sound` folders, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The font that is required has not been supplied. This is because I wanted to
    avoid any possible ambiguity regarding the license. This will not cause a problem
    though, as I will show you exactly where and how to choose and download fonts
    for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Although I will provide either the assets themselves or information on where
    to get them, you might like to create and acquire them for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The graphical assets make up the parts of the scene that is our Zombie Arena
    game. Take a look at the graphical assets and it should be clear where in our
    game they will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the assets](img/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What might be less obvious, however, is the `background_sheet.png` which contains
    four different images. This is the sprite-sheet I mentioned previously, and we
    will see how we can use one to save memory and increase the speed of our game
    in [Chapter 7](ch07.html "Chapter 7. C++ References, Sprite Sheets, and Vertex
    Arrays"), *C++ References, Sprite Sheets, and Vertex Arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sound files are all `.wav` format. These are files which contain the sound
    effects that we will play at certain events throughout the game. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hit.wav`: A sound that plays when a zombie comes into contact with the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pickup.wav`: A sound that plays when the player touches (collects) a health
    boost (pick-up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`powerup.wav`: A sound  that plays when the player chooses an attribute to
    increase (power-up) in between each wave of zombies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reload.wav`: A satisfying click to let the player know they have loaded a
    fresh clip of ammunition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reload_failed.wav`: A less satisfying sound that indicates failure to load
    new bullets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shoot.wav`: A shooting sound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splat.wav`: A sound like a zombie being hit by a bullet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the assets to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have decided which assets you will use, it is time to add them to
    the project. These next instructions will assume you are using all the assets
    supplied in the book''s download bundle. Where you are using your own, simply
    replace the appropriate sound or graphic file with your own, using exactly the
    same file name that is used in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to `D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three new folders within this folder and name them `graphics`, `sound`,
    and `fonts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the download bundle, copy the entire contents of `Chapter 6/graphics` into
    the `D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\graphics` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the download bundle, copy the entire contents of `Chapter 6/sound` into
    the `D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\sound` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now visit [http://www.1001freefonts.com/zombie_control.font](http://www.1001freefonts.com/zombie_control.font)
    in your web browser and download the **Zombie Control** font.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the contents of the zipped download and add the `zombiecontrol.ttf`
    file to the `D:\Visual Studio Stuff\Projects\ZombieArena\ZombieArena\fonts` folder.
    Now it's time to learn some more C++, so we can start writing the code for Zombie
    Arena.
  prefs: []
  type: TYPE_NORMAL
- en: OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP is a programming paradigm that we could consider almost the standard way
    to code. It is true there are non-OOP ways to code and there are even some non-OOP
    game coding languages and libraries. However, starting from scratch, as this book
    does, there is no reason to do things any other way. When the benefits of OOP
    become apparent you will never look back.
  prefs: []
  type: TYPE_NORMAL
- en: 'OOP will:'
  prefs: []
  type: TYPE_NORMAL
- en: Make our code easier to manage, change, or update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make our code quicker and more reliable to write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it possible to easily use other people's code (such as SFML)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already seen the third benefit in action. Let''s look at the first
    two benefits by introducing a problem that needs solving. The problem we are faced
    with is the complexity of the current project. Let''s consider just a single zombie
    and what we need to make it function in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal and vertical position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direction it is facing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different textures for each zombie type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different speeds for each zombie type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different health for each zombie type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of the type of each zombie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision-detection data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligence (to chase the player)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the zombie alive or dead?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list suggests perhaps a dozen variables for just one zombie! We would need,
    perhaps, whole arrays of each of these variables for managing a zombie horde.
    And what about all the bullets from the machine gun, the pick-ups, and the different
    level ups? The simple Timber!!! game was starting to get a bit unmanageable by
    the end, and it is easy to speculate that this more complicated shooter could
    be many times worse!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, handling complexity is not a new problem, and C++ was designed
    from the start to be the solution for this complexity.
  prefs: []
  type: TYPE_NORMAL
- en: What is OOP?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole.
  prefs: []
  type: TYPE_NORMAL
- en: Each chunk is self-contained, yet potentially reusable by other programs, while
    working together with the other chunks as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: These chunks are what we have been referring to as objects. When we plan and
    code an object, we do so with a **class**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A class can be thought of as the blueprint for an object.
  prefs: []
  type: TYPE_NORMAL
- en: We implement an object of a class. This is called an **instance** of a class.
    Think about a house blueprint. You can't live in it, but you can build a house
    from it. You build an instance of it. Often when we design classes for our games,
    we write them to represent real world things. In this project, we will write classes
    for the player, a zombie, a bullet, and more as well. However, OOP is more than
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OOP is a way of doing things, a methodology that defines best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The three core principles of OOP are **encapsulation**, **polymorphism,** and
    **inheritance**. This might sound complex, but actually, taken a step at a time,
    it is reasonably straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encapsulation means keeping the internal workings of your code safe from interference
    from the code that uses it. You can achieve this by allowing only the variables
    and functions, which you choose, to be accessed. This means your code can always
    be updated, extended, or improved without affecting the programs that use it,
    as long as the exposed parts are still accessed in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, with proper encapsulation, it wouldn't matter if the SFML team
    needed to update the way their `Sprite` class works. As long as the function signatures
    remain the same, we don't have to worry about what goes on inside. Our code written
    before the update will still work after the update.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism allows us to write code that is less dependent on the types we
    are trying to manipulate. This will make our code clearer and more efficient.
    Polymorphism means different forms. If the objects that we code can be more than
    one type of thing, then we can take advantage of this. Polymorphism might sound
    a little bit like black magic at this point. We will use polymorphism in the final
    project starting in [Chapter 12](ch12.html "Chapter 12. Abstraction and Code Management
    – Making Better Use of OOP"), *Abstraction and Code Management -* *Making Better
    Use of OOP*. Everything will then become clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like it sounds, inheritance means we can harness all the features and benefits
    of other people's classes, including the encapsulation and polymorphism, while
    further refining their code specifically to our situation. We will use inheritance
    in the final project starting in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management* - *Making
    Better Use of OOP*.
  prefs: []
  type: TYPE_NORMAL
- en: Why do it like this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When written properly, all this OOP allows you to add new features without worrying
    as much about how they interact with existing features. When you do have to change
    a class, its self-contained (encapsulated) nature means fewer or perhaps even
    zero consequences for other parts of the program.
  prefs: []
  type: TYPE_NORMAL
- en: You can use other people's code (such as the SFML classes) without knowing or
    perhaps even caring how it works inside.
  prefs: []
  type: TYPE_NORMAL
- en: OOP, and by extension SFML, allows you to write games that use complicated concepts,
    such as multiple cameras, multiplayer, OpenGL, directional sound, and more besides.
    All this without breaking a sweat.
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance you can create multiple similar, yet different, versions of
    a class without starting the class from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: You can still use the functions intended for the original type of object with
    your new object because of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: All this makes sense, really. And, as we know, C++ was designed from the start
    with all of this OOP in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ultimate key to success with OOP and making games (or any other type of
    app), other than the determination to succeed, is planning and design. It is not
    so much just knowing all the C++, SFML, and OOP topics that will help you write
    great code, but rather applying all that knowledge to write code that is well
    structured and designed. The code in this book is presented in an order and manner
    appropriate to learning the various C++ topics in a gaming context. The art and
    science of structuring your code is called **design patterns**. As your code gets
    longer and more complex, effective use of design patterns will become more important.
    The good news is that we don't need to invent these design patterns ourselves.
    We will need to learn about them as our projects get more complex. More on design
    patterns in the final chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this project we will learn about and use basic classes and encapsulation,
    and in the final project we will get a bit more daring and use inheritance, polymorphism,
    and other OOP-related C++ features too.
  prefs: []
  type: TYPE_NORMAL
- en: What is a class?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class is a bunch of code that can contain functions, variables, loops, and
    all the other C++ syntax we have already learned about. Each new class will be
    declared in its own `.h` code file with the same name as the class and its functions
    will be defined in their own `.cpp` file. This will become clearer when we actually
    look at writing some classes.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have written a class, we can use it to make as many objects from it
    as we want. Remember, the class is the blueprint and we make objects based on
    the blueprint. The house isn't the blueprint just as the object isn't the class.
    It is an object made from the class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can think of an object as a variable and the class as a type.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, with all this talk of OOP and classes we haven't actually seen any
    code. So let's fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: The class variable and function declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's use a different game example to Zombie Arena. Consider the most basic
    game of all, Pong. A paddle/bat that bounces a ball. The paddle would be an excellent
    candidate for a class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don''t know what Pong is, then take a look at this link: [https://en.wikipedia.org/wiki/Pong](https://en.wikipedia.org/wiki/Pong)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at a hypothetical `Paddle.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At first glance the code might appear a little complex, but when it is explained
    we will see there are very few new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to notice is that a new class is declared using the `class`
    keyword followed by the name of the class, and that the entire declaration is
    enclosed in curly braces followed by a closing semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now look at the variable declarations and their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All the names are prefixed with `m_`. This is not necessary, but it is a good
    convention. Variables declared as part of the class are called **member variables**.
    Prefixing with an `m_` makes it absolutely plain when we are dealing with a member
    variable. When we write functions for our classes, we will start to see local
    variables and parameters as well. The `m_` convention will then prove itself useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice also that all the variables are in a section of the code headed with
    the `private:` keyword. Scan your eyes over the previous sample code and notice
    that the body of the class code is separated into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `public` and `private` keywords control the encapsulation of our class.
    Anything that is private cannot be accessed directly by the user of an instance
    or object of the class. If you are designing a class for others to use, you don't
    want them being able to alter anything at will.
  prefs: []
  type: TYPE_NORMAL
- en: This means that our four member variables cannot be accessed directly by our
    game engine in `main`. They can be accessed indirectly by the code of the class.
    For the `m_Length` and `m_Height` variables this is fairly easy to accept, as
    long as we don't need to change the size of the paddle. The `m_XPosition` and
    `m_YPosition` member variables, however, do need to be accessed, or how on earth
    will we move the paddle?
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is solved in the `public:` section of the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The class provides two functions which are public and will be usable with an
    object of type `Paddle`. When we have seen the definition of these functions,
    we will see exactly how these functions manipulate the private variables.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we have a bunch of inaccessible (private) variables that cannot
    be used from the `main` function. This is good because encapsulation makes our
    code less error prone and more maintainable. We then solve the problem of moving
    the paddle by providing indirect access to the `m_XPosition` and `m_YPosition`
    variables by providing two public functions.
  prefs: []
  type: TYPE_NORMAL
- en: The code in `main` can call these functions, but the code inside the functions
    controls exactly how the variables are altered.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The class function definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function definitions we will write in this book will all go in a separate
    file to the class and function declarations. We will use files with the same name
    as the class and the `.cpp` file extension. So, in our hypothetical example, this
    next code would go in a file called `Paddle.cpp`. Take a look at this really simple
    code that has just one new concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that we must use an include directive to include
    the class and function declarations from the `Paddle.h` class.
  prefs: []
  type: TYPE_NORMAL
- en: The new concept we see here is the use of the **scope resolution** operator,
    `::`. As the functions belong to a class, we must write the signature part by
    prefixing the function name with the class name and `::`. `void Paddle::moveLeft()`
    and `void Paddle::moveRight`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, we have briefly seen the scope resolution operator before. Whenever
    we declare an object of a class and we have not previously used `using namespace..`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that we could have put the function definitions and declarations
    in one file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, when our classes get longer (as they will with our first Zombie Arena
    class) it is more organized to separate the function definitions into their own
    file. Furthermore, header files are considered public, and are often used for
    documentation purposes if other people will be using the code that we write.
  prefs: []
  type: TYPE_NORMAL
- en: Using an instance of a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite all the code we have seen related to classes, we haven't actually used
    the class. We already know how to do this as we have used the SFML classes many
    times already.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we would create an instance of `Paddle` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paddle` object has all the variables we declared in `Paddle.h`. We just
    can''t access them directly. We can, however, move our paddle using its public
    functions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `paddle` is a `Paddle`, and as such it has all the member variables
    and all the functions available to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could decide at a later date to make our **Pong** game multiplayer. In the
    `main` function, we could change the code to have two paddles. Perhaps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is vitally important to realize that each of these instances of `Paddle`
    are separate objects with their very own set of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and getter functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simple Pong paddle example was a good way of introducing the basics of classes.
    Classes can be simple and short like `Paddle`, but they can also be longer, more
    complicated, and themselves contain other objects.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to making games, there is a vital thing missing from the hypothetical
    `Paddle` class. It might be fine for all these private member variables and public
    functions, but how will we draw anything? Our Pong paddles need a sprite and a
    texture too.
  prefs: []
  type: TYPE_NORMAL
- en: We can include other objects in our class in exactly the same way that we include
    them in `main`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is an updated version of the `private:` section of `Paddle.h` code which
    includes a member `Sprite` and a member `Texture` too. Note that the file would
    also need the relevant SFML include directive for this code to compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The new problem is immediately upon us. If `m_Sprite` and `m_Texture` are private,
    then how on earth will we draw them in the `main` function?
  prefs: []
  type: TYPE_NORMAL
- en: We will need to provide a function that allows access to `m_Sprite` so it can
    be drawn. Look carefully at the new function declaration in the public section
    of `Paddle.h`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous code declares a function called `getSprite`. The significant thing
    to notice is that `getSprite` returns a `Sprite` object. We will see the definition
    of `getSprite` very soon.
  prefs: []
  type: TYPE_NORMAL
- en: If you are sharp minded, you will also have noticed that at no point have we
    loaded the texture or called `m_Sprite.setTexture(m_Texture)` to associate the
    texture with the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is coded, a special function is created by the compiler. We don't
    see this function in our code but it is there. It is called a constructor. When
    we need to write some code to prepare an object for use, often a good place to
    do this is the constructor. When we want the constructor to do anything other
    than simply create an instance, we must replace the default (unseen) constructor
    provided by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we provide a constructor function declaration. Note that constructors
    have no return type, not even `void`. Also note that we can immediately see that
    it is the constructor function because the function name is the same as the class,
    `Paddle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code shows the new function definitions in `Paddle.cpp` (`getSprite`
    and the constructor, `Paddle`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we use the constructor function, `Paddle`, to load the
    texture and associate it with the sprite. Remember that this function is called
    at the time that an object of type `Paddle` is declared. More specifically, when
    the code `Paddle paddle` is executed, the constructor is called.
  prefs: []
  type: TYPE_NORMAL
- en: In the `getSprite` function there is just one line of code that returns a copy
    of `m_Sprite` to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: We could do other setup work for our objects in the constructor as well and
    will do so when we build our first real class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see exactly how the `getSprite` function could be used, the
    code in `main` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous line of code assumes we have an SFML `RenderWindow` object called
    `window`. As `getSprite` returns an object of type `Sprite`, the previous line
    of code works exactly as if the sprite had been declared in `main`. Now we have
    a neatly encapsulated class that provides controlled access via its public functions.
  prefs: []
  type: TYPE_NORMAL
- en: Jumping around in the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I find that when I read books that jump around in the code files, I often find
    it hard to follow exactly what is going on. What follows are the complete listings
    for the hypothetical `Paddle.h` and `Paddle.cpp`, to get everything in context.
    Be sure to study them before moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Paddle.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Paddle.cpp`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will constantly be revisiting classes and OOP throughout the rest of the
    book. For now, however, we know enough to get started on our first real class
    for the Zombie Arena game.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Player-the first class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about what our `Player` class will need to do. The class will need
    to know how fast it can move, where in the game world it currently is, and how
    much health it has. As the `Player` class, in the player's eyes, is represented
    as a 2D graphical character, the class will need both a `Sprite` and a `Texture`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, although the reasons might not be obvious at this point, our `Player`
    class will also benefit from knowing a few details about the overall environment
    the game is running in. These details are screen resolution, the size of the tiles
    that make up an arena, and the overall size of the current arena.
  prefs: []
  type: TYPE_NORMAL
- en: As the `Player` class will be taking full responsibility for updating itself
    each frame, it will need to know the player's intentions at any given moment.
    For example, is the player currently holding down a particular keyboard direction
    key? Or is the player currently holding down multiple keyboard direction keys?
    Boolean variables to determine the status of the ***W*, *A*, *S*, and *D*** keys
    will be essential.
  prefs: []
  type: TYPE_NORMAL
- en: It is plain we are going to need quite a selection of variables in our new class.
    Having learned all we have about OOP, we will, of course, be making all these
    variables private. This means that we must provide access, where appropriate,
    from the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a whole bunch of `getter` functions, as well as some other functions,
    to set up our object. These functions are quite numerous; there are actually 21
    functions in this class. At first this might seem a little daunting, but we will
    go through them all and see that the majority of them simply set or get one of
    the private variables.
  prefs: []
  type: TYPE_NORMAL
- en: There are just a few fairly in-depth functions, such as `update`, which will
    be called once each frame from the `main` function, and `spawn`, which will handle
    the initializing of some of the private variables. As we will see, however, there
    is nothing complicated about them, and they will all be described in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to proceed is to code the header file. This will give us the opportunity
    to see all the private variables and examine all the function signatures. Pay
    close attention to the return values and argument types, as this will make understanding
    the code in the function definitions much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Player class header file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Right click** on **Header Files** in the **Solution Explorer** and select
    **Add** | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (`.h`),** and then, in the **Name** field, type `Player.h`. Finally,
    click the **Add** button. We are now ready to code the header file for our first
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get started coding the `Player` class by adding the declaration, including
    the opening and closing curly braces followed by a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add all our private member variables. Based on what we have already
    discussed, see if you can work out what each of them will do. We will go through
    them individually in a minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous code declares all our member variables. Some are regular variables
    and some are themselves objects. Notice that they are all under the `private:`
    section of the class and are therefore not directly accessible from outside the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice, we are using the naming convention of prefixing `m_` to all the
    names of the non-constant variables. The `m_` prefix will remind us, while coding
    the function definitions, that they are member variables and are distinct from
    some local variables we will create in some of the functions, as well as being
    distinct from the function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: All of the variable's uses will be obvious, such as `m_Position`, `m_Texture,`
    and `m_Sprite`, which are for the current location, the texture, and sprite of
    the player. In addition, each variable (or group of variables) is commented to
    make their usage plain.
  prefs: []
  type: TYPE_NORMAL
- en: However, why exactly they are needed and the context they will be used in might
    not be so obvious. For example, `m_LastHit`, which is an object of type `Time`,
    is for recording the time that the player last received a hit from a zombie. The
    use we are putting `m_LastHit` to is plain, but at the same time, it is not obvious
    why we might need this information.
  prefs: []
  type: TYPE_NORMAL
- en: As we piece the rest of the game together, the context for each of the variables
    will become clearer. The important thing for now is to familiarize yourself with
    the names and types to make following along with the rest of the project trouble
    free.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't need to memorize the variable names and types as we will discuss all
    the code when they are used. You do need to take your time to look over them and
    get a little bit familiar with them. Furthermore, as we proceed it might be worth
    referring back to this header file if anything seems unclear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add a whole long list of functions. Add all of the following highlighted
    code and see if you can work out what it all does. Pay close attention to the
    return types, parameters and name of each function. This is key to understanding
    the code we will write throughout the rest of the project. What do they tell us
    about each function? Add the following highlighted code and then we will examine
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'First note, that all the functions are public. This means we can call all of
    these functions, using an instance of the class, from main, with code like this:
    `player.getSprite();`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming `player` is a fully set up instance of the `Player` class, the previous
    code will return a copy of `m_Sprite`. Putting this code into a real context,
    we could, in the main function, write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The previous code would draw the player graphic in its correct location, just
    as if the sprite were declared in the `main` function itself. This is just like
    what we did with the hypothetical `Paddle` class previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to implement (write the definitions of) these functions in
    a corresponding `.cpp` file, let''s take a closer look at each of them in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void spawn(IntRect arena, Vector2f resolution, int tileSize):` This function
    does as the name suggests. It will prepare the object ready for use, including
    putting it in its starting location (spawning it). Notice that it doesn''t return
    any data, but it does have three arguments. It receives an `IntRect` called `arena`,
    which will be the size and location of the current level, a `Vector2f` that will
    contain the screen resolution, and an `int` which will hold the size of a background
    tile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void resetPlayerStats`: Once we give the player the ability to level up between
    waves, we will need to be able to take away and reset those abilities when they
    die.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Time getLastHitTime()`: This function does just one thing, it returns the
    time when the player was last hit by a zombie. We will use this function when
    detecting collisions and it will enable us to make sure the player isn''t punished
    too frequently for contact with a zombie.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FloatRect getPosition()`: This function returns a `FloatRect` that describes
    the horizontal and vertical floating point coordinates of the rectangle which
    contains the player graphic. This again is useful for collision detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vector2f getCenter()`: This is slightly different to `getPosition` because
    it is a `Vector2f` and contains just the X and Y locations of the very center
    of the player graphic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float getRotation()`: The code in main will sometimes need to know, in degrees,
    which way the player is currently facing. Three o''clock is zero degrees and increases
    clockwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sprite getSprite()`: As previously discussed, this function returns a copy
    of the sprite which represents the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void moveLeft()`, `...Right()`, `...Up()`, `...Down()`: These four functions
    have no return type or parameters. They will be called from the `main` function
    and the `Player` class will then be able to take action when one or more of the
    ***W*, *A*, *S*, and *D*** keys have been pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void stopLeft()`, `...Right()`, `...Up()`, `...Down()`: These four functions
    have no return type or parameters. They will be called from the `main` function,
    and the `Player` class will then be able to take action when one or more of the 
    ***W*, *A*, *S*, and *D*** keys have been released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void update(float elapsedTime, Vector2i mousePosition)`: This will be the
    only relatively long function of the entire class. It will be called once per
    frame from `main`. It will do everything necessary to make sure the player object''s
    data is updated ready for collision detection and drawing. Notice it returns no
    data, but receives the amount of elapsed time since the last frame, along with
    a `Vector2i`, which will hold the horizontal and vertical screen location of the
    mouse pointer or crosshair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that these are integer screen coordinates, distinct from floating point
    world coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '`void upgradeSpeed()`: A function that can be called from the leveling-up screen
    when the player chooses to make the player faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void upgradeHealth()`: Another function that can be called from the leveling-up
    screen when the player chooses to make the player stronger (have more health).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void increaseHealthLevel(int amount)`: A subtle but important difference to
    the previous function in that this one will increase the amount of health the
    player has, up to a maximum currently set. This function will be used when the
    player picks up a health pick-up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int getHealth()`: With the level of health being as dynamic as it is, we need
    to be able to determine how much health the player has at any given moment. This
    function returns an `int` which holds that value. As with the variables, it should
    now be plain what each of the functions is for. Also, as with the variables, the
    why and precise context of using some of these functions will only reveal itself
    as we progress with the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't need to memorize the function names, return types, or parameters as
    we will discuss all the code when they are used. You do need to take your time
    to look over them, along with the previous explanations, and get a little bit
    more familiar with them. Furthermore, as we proceed, it might be worth referring
    back to this header file if anything seems unclear.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can move on to the meat of our functions, the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Player class function definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At last we can begin to write the code which actually does the work of our class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Right click** on **Source Files** in the **Solution Explorer** and select
    **Add | New Item...**. In the **Add New Item** window, highlight (by **left-clicking**)
    **C++ File** ( **`.cpp`** )**,** and then in the **Name** field type `Player.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    our first class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the necessary include directives followed by the definition of the
    constructor. Remember, the constructor will be called when we first instantiate
    an object of type `Player`. Add this code into the `Player.cpp` file and then
    we can take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor function which, of course, has the same name as the class
    and no return type, we write code which begins to set up the `Player` object ready
    for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be absolutely clear: This code will run when we write this code from the
    `main` function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Don't add this previous line of code just yet.
  prefs: []
  type: TYPE_NORMAL
- en: All we do is initialize `m_Speed`, `m_Health,` and `m_MaxHealth` from their
    related constants. Then we load the player graphic in to `m_Texture`, associate
    `m_Texture` with `m_Sprite,` and set the origin of `m_Sprite` to the center `(25,
    25)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the cryptic comment `// !!Watch this space!!`, indicating that we will
    return to the loading of our texture and some important issues regarding it. We
    will eventually change how we deal with this texture once we have discovered a
    problem and learned a bit more C++. We will do so in [Chapter 8](ch08.html "Chapter 8. Pointers,
    the Standard Template Library, and Texture Management"), *Pointers, Standard Template
    Library, and Texture Management*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will code the `spawn` function. We will only ever create one instance
    of the `Player` class. We will, however, need to spawn it into the current level,
    each and every wave. This is what the spawn function will handle for us. Add the
    following code into the `Player.cpp` file. Be sure to examine the detail and read
    the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The previous code starts off by initializing the `m_Position.x` and `m_Position.y`
    values to half the height and width of the passed in `arena`. This has the effect
    of moving the player to the center of the level, regardless of its size.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we copy all of the coordinates and dimensions of the passed in `arena`
    to the member object of the same type, `m_Arena`. The details of the size and
    coordinates of the current arena are used so frequently that it makes sense to
    do so. We can now use `m_Arena` for tasks such as making sure the player can't
    walk through walls. In addition, we copy the passed in `tileSize` to the member
    variable `m_TileSize`, for the same purpose. We will see `m_Arena` and `m_TileSize`
    in action in the `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: The final two lines of code copy the screen resolution from the `Vector2f`,
    `resolution,` which is a parameter of `spawn`, into `m_Resolution`, which is a
    member variable of `Player`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the very straightforward code of the `resetPlayerStats` function. When
    the player dies, we will use it to reset any upgrades they might have used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We will not write the code that actually calls the `resetPlayerStats` function
    until we have nearly completed the project, but it is there ready for when we
    need it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next code, we will add two more functions. They will handle what happens
    when the player is hit by a zombie. We will be able to call `player.hit()` and
    pass in the current game time. We will also be able to query the last time that
    the player was hit by calling `player.getLastHitTime()`. Exactly how these functions
    will be useful will become apparent when we have some zombies!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the two new functions into the `Player.cpp` file and then we will examine
    the C++ a little more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The code for `getLastHitTime` is very straightforward. Return whatever value
    is stored in `m_LastHit`.
  prefs: []
  type: TYPE_NORMAL
- en: The `hit` function is a bit more in-depth and nuanced. First, the `if` statement
    checks to see whether the time passed in is 200 milliseconds further ahead than
    the time stored in `m_LastHit`. If it is, `m_LastHit` is updated with the time
    passed in and `m_Health` has `10` deducted from its current value. The last line
    of code in this `if` statement is `return true`. Note that the `else` clause simply
    returns `false` to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: The overall effect of this function is that health will only be deducted from
    the player up to five times per second. Remember that our game loop might be running
    at thousands of iterations per second. In this scenario, without the restriction,
    a zombie would only need to be in contact with the player for one second and tens
    of thousands of health points would be deducted. The `hit` function controls and
    restricts this occurrence. It also lets the calling code know if a new hit has
    been registered (or not) by returning `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: This code implies that we will detect collisions between a zombie and the player
    in the `main` function. We will then call `player.hit()` to determine whether
    to deduct any health points.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for the `Player` class we will implement a bunch of getter functions.
    They enable us to keep the data neatly encapsulated in the `Player` class, at
    the same time as making their values available to the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code right after the previous block and then we will discuss
    exactly what each function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is very straightforward. Each and every one of the previous
    five functions returns the value of one of our member variables. Look carefully
    at each and familiarize yourself with which function returns which value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next eight short functions enable the keyboard controls (we will use from
    `main`) to change data contained in our object of type `Player`. Add the code
    in the `Player.cpp` file and then I will summarize how it all works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The previous code has four functions (`moveLeft`, `moveRight`, `moveUp`, `moveDown`)
    which set the related Boolean variables (`m_LeftPressed`, `m_RightPressed`, `m_UpPressed`,
    `m_DownPressed`) to `true`. The other four functions (`stopLeft`, `stopRight`,
    `stopUp`, `stopDown`) do the opposite and set the same `Boolean` variables to
    `false`. The instance of the `Player` class can now be kept informed of which
    of the  ***W*, *A*, *S*, and *D*** keys have been pressed and which are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next function is the one which does all the hard work. The `update` function
    will be called once on every single frame of our game loop. Add the code that
    follows and we will then examine it in detail. If you followed along with the
    previous eight functions and you remember how we animated the clouds for the **Timber!!!**
    project, you will probably find most of the following code quite understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first portion of the previous code moves the player sprite. The four `if`
    statements check which of the movement-related `Boolean` variables (`m_LeftPressed`,
    `m_RightPressed`, `m_UpPressed`, `m_DownPressed`) are true and changes `m_Position.x`
    and `m_Position.y` accordingly. The same formula to calculate the amount to move
    as the Timber!!! project is used.
  prefs: []
  type: TYPE_NORMAL
- en: '`position (+ or -) speed * elapsed time.`'
  prefs: []
  type: TYPE_NORMAL
- en: After these four `if` statements, `m_Sprite.setPosition` is called and `m_Position`
    is passed in. The sprite has now been adjusted by exactly the right amount for
    that one frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next four `if` statements check whether `m_Position.x` or `m_Position.y`
    are beyond any of the edges of the current arena. Remember that the confines of
    the current arena were stored in `m_Arena` in the `spawn` function. Let''s look
    at the first of these four `if` statements in order to understand them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The previous code tests to see if `m_position.x` is greater than `m_Arena.width`
    minus the size of a tile (`m_TileSize`). As we will see when we create the background
    graphics, this calculation will detect the player straying into the wall.
  prefs: []
  type: TYPE_NORMAL
- en: When the `if` statement is true, the calculation `m_Arena.width - m_TileSize`
    is used to initialize `m_Position.x`. This makes the center of the player graphic
    unable to stray past the left-hand edge of the right-hand wall.
  prefs: []
  type: TYPE_NORMAL
- en: The next three `if` statements that follow the one we have just discussed do
    the same thing for the other three walls.
  prefs: []
  type: TYPE_NORMAL
- en: The last two lines of code calculate and set the angle that the player sprite
    is rotated to (facing). The line of code might look a little complex, but it is
    simply using the position of the crosshair (`mousePosition.x` and `mousePosition.y`)
    and the center of the screen (`m_Resolution.x` and `m_Resolution.y`) in a tried
    and tested trigonometric function.
  prefs: []
  type: TYPE_NORMAL
- en: How `atan` uses these coordinates along with Pi (3.141) is quite complicated,
    and that is why it is wrapped up in a handy function for us. If you want to explore
    trigonometric functions in more detail you can do so at [http://www.cplusplus.com/reference/cmath/](http://www.cplusplus.com/reference/cmath/).The
    last three functions for the `Player` class make the player 20% faster, have 20%
    more health, and increase the player's health by the amount passed in, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code at the end of the `Player.cpp` file and then we will take a closer
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, the `upgradeSpeed` and `upgradeHealth` functions increase
    the values stored in `m_Speed` and `m_MaxHealth,` respectively. The values are
    increased by 20% by multiplying the starting values by 0.2 and adding them to
    the current values. These functions will be called from the `main` function when
    the player is choosing what attributes of their character they wish to improve
    between levels.
  prefs: []
  type: TYPE_NORMAL
- en: The `increaseHealthLevel` takes an `int` value from `main` in the `amount` parameter.
    This `int` value will be provided by a class called `Pickup` that we will write
    in [Chapter 9](ch09.html "Chapter 9. Collision Detection, Pickups, and Bullets"),
    *Collision Detection, Pick-ups, and Bullets*. The `m_Health` member variable is
    increased by the passed in value. There is a catch for the player, however. The
    `if` statement checks whether `m_Health` has exceeded `m_MaxHealth`, and if it
    has, sets it to `m_MaxHealth`. This means the player cannot simply gain infinite
    health from pick-ups. They must instead carefully balance the upgrades they choose
    between levels.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, our `Player` class can't actually do anything until we instantiate
    it and put it to work in our game loop. Before we do that, let's take a look at
    the concept of a game camera.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the game camera with SFML View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, the SFML `View` class is one of the neatest classes. If after
    finishing this book you make games without using a media or gaming library, you
    will really notice the absence of `View`.
  prefs: []
  type: TYPE_NORMAL
- en: The `View` class allows us to consider our game as taking place in its own world,
    with its own properties. What do I mean? When we create a game, we are usually
    trying to create a virtual world. That virtual world rarely, if ever, is measured
    in pixels and rarely, if ever, will that world be exactly the same number of pixels
    as the player's monitor. We need a way to abstract the virtual world we are building,
    so that it can be whatever size or shape we like.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think of SFML `View` is as a camera through which the player
    views a part of our virtual world. Most games will have more than one camera or
    view of the world.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a split screen game where two players can be in different
    parts of the same world, at different times.
  prefs: []
  type: TYPE_NORMAL
- en: Or consider a game where there is a small area of the screen that represents
    the entire game world but at a very high level, or zoomed out, like a mini map.
  prefs: []
  type: TYPE_NORMAL
- en: Even if our games are much simpler than the previous two examples and don't
    need split screens or mini maps, we will likely want to create a world that is
    bigger than the screen it is being played on. This is, of course, the case with
    Zombie Arena.
  prefs: []
  type: TYPE_NORMAL
- en: And if we are constantly moving the game camera around to show different parts
    of the virtual world (usually tracking the player) what happens to the HUD? If
    we draw the score and other on-screen HUD info and then we scroll the world around
    to follow the player, then the score will move relative to that camera.
  prefs: []
  type: TYPE_NORMAL
- en: The SFML `View` class easily enables all these features and solves the problem
    with very straightforward code. The trick is to create an instance of `View` for
    each and every camera. Perhaps a `View` for the mini map, a `View` for the scrolling
    game world, and then a `View` for the HUD.
  prefs: []
  type: TYPE_NORMAL
- en: The instances of `View` can be moved around, sized, and positioned as required.
    So the main `View` following the game can track the player, the mini-map view
    can remain in a fixed zoomed-out, small corner of the screen, while the HUD can
    overlay the entire screen and never move, despite the fact that the main `View`
    can go wherever the player goes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some code using a few instances of View.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code is to introduce the `View` class. Don't add this code to the Zombie
    Arena project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and initialize a few instances of View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code creates two `View` objects that fill a 1920 x 1080 monitor.
    Now we can do some magic with `mainView` while leaving `hudView` completely alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When we manipulate the properties of a View, we do so as shown previously.
    When we draw sprites, text, or other objects to a view, we must specifically set
    the view as the current view for the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can draw everything we want into that view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The player might be at any coordinate whatsoever. It doesn't matter because
    `mainView` is centered around the graphic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can draw the HUD into `hudView`. Note that, just as we draw individual
    elements (background, game objects, text, and so on) in layers from back to front,
    we also draw views from back to front as well. Hence a HUD is drawn after the
    main game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can draw or show the window and all its views for the current frame
    in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to take your understanding of SFML View further than is necessary
    for this project, including how to achieve split screen and mini maps, then the
    best guide on the Web is on the official SFML website at [http://www.sfml-dev.org/tutorials/2.0/graphics-view.php](http://www.sfml-dev.org/tutorials/2.0/graphics-view.php).
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learnt about `View`, we can start coding the Zombie Arena `main`
    function and use our first `View` for real. In [Chapter 10](ch10.html "Chapter 10. Layering
    Views and Implementing the HUD"), *Layering Views and Implementing the HUD*, we
    will introduce a second instance of `View` for the HUD, fix it, and layer it over
    the top of the main `View`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Zombie Arena game engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this game, we will need a slightly upgraded game engine in `main`. In particular,
    we will have an enumeration called `state` which will track what the current state
    of the game is. Then, throughout `main`, we can wrap parts of our code so that
    different things happen in different states.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `HelloSFML` file in the **Solution Explorer** and select
    **Rename**. Change the name to `ZombieArena.cpp`. This will be the file that contains
    our `main` function and the code that instantiates and controls all our classes.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with the now familiar `main` function and some include directives.
    Note the addition of an include directive for the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code following to the `ZombieArena.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The previous code has nothing new in it except that the `#include "Player.h"`
    line means we can now use the `Player` class within our code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's flesh out some more of our game engine. This next code does quite a lot.
    Be sure to read the comments when you add the code to get an idea of what is going
    on. We will then go through it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code at the start of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run through each section of the code that we just entered. Just inside
    the main function we have this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The previous code creates a new enumeration class called `State`. Then the code
    creates an instance of `State` called `state`. The `state` enumeration can now
    be one of four values, as defined in the declaration. Those values are `PAUSED`,
    `LEVELING_UP`, `GAME_OVER`, and `PLAYING`. These four values will be just what
    we need for keeping track and responding to the different states that the game
    can be in at any given time. Note that it is not possible for `state` to hold
    more than one value at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The previous code declares a `Vector2f` called `resolution`. We initialize the
    two variables of `resolution` (`x` and `y`) by calling the `VideoMode::getDesktopMode`
    function for both `width` and `height`. The `resolution` object now holds the
    resolution of the monitor on which the game is running. The final line of code
    creates a new `RenderWindow` called `window` using the appropriate resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next code creates an SFML `View` object. The view is positioned (initially)
    at the exact coordinates of the pixels of the monitor. If we were to use this
    `View` to do some drawing in this current position it would have no effect whatsoever.
    However, we will eventually start to move this view to focus on the parts of our
    game world that the player needs to see. Then, when we start to use a second `View`
    that remains fixed (for the HUD), we will see how this `View` can track the action
    while the other remains static to display the HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a `Clock` to do our timing and a `Time` object called `gameTimeTotal`
    that will keep a running total of the game time that has elapsed. As the project
    progresses we will introduce more variables and objects to handle timing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code declares two vectors. One holding two floats, called `mouseWorldPosition`,
    and one holding two integers, called `mouseScreenPosition`. The mouse pointer
    is something of an anomaly because it exists in two different coordinate spaces.
    You could think of these as parallel universes if you like. First, as the player
    moves around the world we will need to keep track of where the crosshair is in
    that world. These will be floating point coordinates and will be stored in `mouseWorldCoordinates`.
    Of course the actual pixel coordinates of the monitor itself never change. They
    will always be 0,0 to horizontal resolution-1, vertical resolution-1\. We will
    track the mouse pointer position relative to this coordinate space using the integers
    stored in `mouseScreenPosition`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get to use our `Player` class. This line of code will cause the
    constructor function (`Player::Player`) to execute. Refer to `Player.cpp` if you
    want to refresh your memory about this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This `IntRect` object will hold starting horizontal and vertical coordinates
    as well as a width and a height. Once initialized, we will be able to access the
    size and location details of the current arena with code such as `arena.left`,
    `arena.top`, `arena.width,` and `arena.height`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the code that we added previously is, of course, our main
    game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You have probably noticed that the code is getting quite long. Let's talk about
    this inconvenience.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the code files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of abstraction using classes and functions is that the
    length (number of lines) of our code files can be reduced. Even though we will
    be using more than a dozen code files for this project, the length of the code
    in `ZombieArena.cpp` will still get a little unwieldy towards the end. In the
    final project, we will look at even more ways to abstract and manage our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, use this tip to keep things manageable. Notice on the left hand side
    of the code editor in Visual Studio, there are a number of **+** and - signs,
    one of which is shown in this next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing the code files](img/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There will be one sign for each block (`if`, `while`, `for`, and so on) of the
    code. You can expand and collapse these blocks by clicking on the + and - signs.
    I recommend keeping all the code not currently under discussion, collapsed. This
    will make things much clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we can create our own collapsible blocks. I suggest making a collapsible
    block out of all the code before the start of the main game loop. To do so, highlight
    the code, **right-click,** and choose **Outlining** | **Hide Selection**, as shown
    in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing the code files](img/image_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can click the + and the - sign to expand and contract the block. Each
    time we add code before the main game loop (and that will be quite often) you
    can expand the code, add the new lines, and then collapse it again. This next
    image is what the code looks like when it is collapsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing the code files](img/image_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is much more manageable than it was before.
  prefs: []
  type: TYPE_NORMAL
- en: Starting coding the main game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the last part of the previous code is the game loop, `while
    (window.isOpen()){}`. It is this that we turn our attention to now. Specifically,
    we will be coding the input-handling section of the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: The next code that we will add is quite long. There is nothing complicated about
    it, and we will examine it all in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code only, which is shown in the following code, into the
    main game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we instantiate an object of type `Event`. We will use
    `event`, as we did in the Timber!!! project, to poll for system events. To do
    so, we wrap the rest of the code from the previous block in a `while` loop with
    the condition `window.pollEvent(event)`. This will keep looping, for each frame,
    until there are no more events to process.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this `while` loop, we handle the events we are interested in. First,
    we test for `Event::KeyPressed` events. If the ***Enter*** key is pressed while
    the game is in the `PLAYING` state then we switch `state` to `PAUSED`.
  prefs: []
  type: TYPE_NORMAL
- en: If the ***Enter*** key is pressed while the game is in the `PAUSED` state then
    we switch `state` to `PLAYING` and restart `clock`. The reason we restart `clock`
    after switching from `PAUSED` to `PLAYING` is because, while the game is paused,
    the elapsed time still accumulates. If we didn't restart the clock all our objects
    would update their locations as if the frame had just taken a very long time.
    This will become more apparent as we flesh out the rest of the code in this file.
  prefs: []
  type: TYPE_NORMAL
- en: We then have an `else if` test to see if the *Enter* key was pressed while the
    game was in the `GAME_OVER` state. If it was, then `state` is changed to `LEVELING_UP`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `GAME_OVER` state is the state where the home screen is displayed.
    So the `GAME_OVER` state is the state after the player has just died and also
    when the player first runs the app. The first thing that the player gets to do
    each game is to pick an attribute to improve (level up).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code there is a final `if` condition to test if the state is
    `PLAYING`. This `if` block is empty, and we will add code to it throughout the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we will add code to lots of different parts of this file throughout the project,
    it is therefore worthwhile taking time to understand the different states our
    game can be in and where we handle them. It will also be very beneficial to collapse
    and expand the different `if`, `else`, and `while` blocks as and when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to thoroughly familiarize yourself with the `while`, `if`, and
    `else if` blocks we have just coded. We will be referring back to them regularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, immediately after the previous code and still inside the game loop, still
    dealing with handling input, add this highlighted code. Note the existing code
    (not highlighted) that shows exactly where the new code goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we first test to see if the player has pressed the ***Esc***
    key. If it is pressed, the game window will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, within one big `if(state == State::PLAYING)` block we check each of the 
    ***W*, *A*, *S*, and *D*** keys in turn. If a key is pressed, we call the appropriate
    `player.move...` function. If it is not, we call the related `player.stop...`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: This code ensures that, in each and every frame, the player object will be updated
    with exactly which of the ***W*, A**, *S*, *D* keys are pressed and which are
    not. The `player.move...` and `player.stop...` functions store the information
    in the member Boolean variables (`m_LeftPressed`, `m_RightPressed`, `m_UpPressed`
    `,` and `m_DownPressed`). The `Player` class then responds to the value of these
    Booleans, in each frame, in the `player.update` function which we will call in
    the update section of the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can handle the keyboard input to enable the player to level up at the
    start of each game and in between each wave. Add and study the following highlighted
    code and we will then discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, which is all wrapped in a test to see if the current
    value of `state` is `LEVELING_UP`, we handle the keyboard keys *1, 2, 3, 4, 5,*
    and *6*. In the `if` block for each, we simply set `state` to `State::PLAYING`.
    We will add code to deal with each level up option later in [Chapter 11](ch11.html
    "Chapter 11. Sound Effects, File I/O, and Finishing the Game"), *Sound Effects,
    File I/O, and Finishing the Game*.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this code does is this:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `state` is `LEVELING_UP`, wait for either the *1, 2, 3, 4, 5* or *6*
    key to be pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When pressed, change `state` to `PLAYING`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the state changes, still within the `if (state == State::LEVELING_UP)`
    block, the nested `if(state == State::PLAYING)` block will run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within this block, we set the location and size of `arena`, the `tileSize` to
    `50`, pass all the information in to `player.spawn,` and restart `clock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have an actual spawned player object that is aware of its environment
    and can respond to key presses. We can now update the scene on each pass through
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to neatly collapse the code from the input handling part of the game
    loop as we are done with that, for now. The next code is in the update part of
    the game loop. Add and study the highlighted code and then we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First note that all the previous code is wrapped in a test to make sure the
    game is in the `PLAYING` state. We don't want this code to run if the game is
    paused, over, or if the player is choosing what to level up.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we restart the clock and store the time that the previous frame took
    in the `dt` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the time that the previous frame took onto the accumulated time
    the game has been running for, as held by `gameTimeTotal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now we initialize a `float` called `dtAsSeconds` with the value returned by
    the `dt.AsSeconds` function. For most frames this will be a fraction of one. This
    is perfect for passing into the `player.update` function to be used to calculate
    how much to move the player sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can initialize `mouseScreenPosition` using the function `MOUSE::getPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering about the slightly unusual syntax for getting the position
    of the mouse? This is called a **static function**. If we define a function in
    a class with the static keyword, we are able to call that function using the class
    name and without an instance of the class. C++ OOP has loads of quirks and rules
    like this. We will see many more as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: We then initialize `mouseWorldPosition` using the SFML `mapPixelToCoords` function
    on `window`. We discussed this function when talking about the `View` class earlier
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are now able to call `player.update` and pass in `dtAsSeconds`
    and the position of the mouse, as is required.
  prefs: []
  type: TYPE_NORMAL
- en: We store the player's new center in a `Vector2f` called `playerPosition`. At
    the moment, this is unused, but we will have a use for this later in the project.
  prefs: []
  type: TYPE_NORMAL
- en: We can then center the view around the center of the players up-to-date position
    with the code, `mainView.setCenter(player.getCenter())`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now in a position to draw the player to the screen. Add this highlighted
    code which splits the draw section of the main game loop into different states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Within the `if(state == State::PLAYING)` section of the previous code, we clear
    the screen, set the view of the window to `mainView`, and then draw the player
    sprite with `window.draw(player.getSprite())`.
  prefs: []
  type: TYPE_NORMAL
- en: After all the different states have been handled, the code shows the scene in
    the usual manner with `window.display();`.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the game and see our player character spin around in response to
    moving the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you run the game, you need to press *Enter* to start the game and then
    a number from *1* to *6* to simulate choosing an upgrade option. Then the game
    will start.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also move the player around within the (empty) 500 x 500 pixel arena.
    You can see our lonely player in the center of the screen, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting coding the main game loop](img/image_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can't, however, get any sense of movement because we haven't implemented
    the background. We will do so in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) I notice we have coded quite a few functions of the `Player` class that we
    don't use.
  prefs: []
  type: TYPE_NORMAL
- en: A) Rather than keep coming back to the `Player` class, we have added the entire
    code that we will need throughout the project. By the end of [Chapter 11](ch11.html
    "Chapter 11. Sound Effects, File I/O, and Finishing the Game"), *Sound Effects,
    File I/O, and Finishing the Game,* we will have made full use of all the functions.
  prefs: []
  type: TYPE_NORMAL
- en: Q) I have learnt other languages and OOP seems much simpler in C++.
  prefs: []
  type: TYPE_NORMAL
- en: A) This was an introduction to OOP and its basic fundamentals. There is more
    to it than this. We will learn more OOP concepts and details throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! That was a long one. We have learned a lot in this chapter. We have discovered
    the basics of OOP, including how to use encapsulation to control how code outside
    of our classes can access the member variables. We built our first real class,
    `Player`, and put it to use in the start of what will become our new game, Zombie
    Arena.
  prefs: []
  type: TYPE_NORMAL
- en: Don't concern yourself too much if some of the details around OOP and classes
    are not entirely clear. The reason I say this is because we will spend the rest
    of the book making classes, and the more we use them the clearer they will become.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build our arena background by exploring what sprite
    sheets are. We will also learn about C++ references that allow us to manipulate
    variables, even when they are out of scope (in another function).
  prefs: []
  type: TYPE_NORMAL
