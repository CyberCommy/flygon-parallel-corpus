- en: Race Conditions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the concept of race conditions and their potential
    causes in the context of concurrency. The definition of critical section, which
    is a concept highly relevant to race conditions and concurrent programming, will
    also be covered. We will use some example code in Python to simulate race conditions
    and the solutions commonly used to address them. Finally, real-life applications
    that commonly deal with race conditions will be discussed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The basic concept of a race condition, and how it occurs in concurrent applications,
    along with the definition of critical sections
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simulation of a race condition in Python and how to implement race condition
    solutions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real-life computer science concepts that commonly interact and work with
    race conditions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is the list of prerequisites needed for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this chapter, we will be working with the subfolder titled `Chapter14`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2AdYWRj](http://bit.ly/2AdYWRj)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of race conditions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A race condition is typically defined as a phenomenon during which the output
    of a system is indeterminate and dependent on the scheduling algorithm and the
    order in which tasks are scheduled and executed. When the data becomes mishandled
    and corrupted during this process, a race condition becomes a bug in the system.
    Given the nature of this problem, it is quite common for a race condition to occur
    in concurrent systems, which emphasize scheduling and coordinating independent
    tasks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A race condition can occur in both an electronic hardware system and a software
    application; in this chapter, we will only be discussing race conditions in the
    context of software development—specifically, concurrent software applications.
    This section will cover the theoretical foundations of race conditions and their
    root causes and the concept of critical sections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Critical sections
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Critical sections indicate shared resources that are accessed by multiple processes
    or threads in a concurrent application, which can lead to unexpected, and even
    erroneous, behavior. We have seen that there are multiple methods to protect the
    integrity of the data contained in these resources, and we call these protected
    sections **critical sections**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, the data in these critical sections, when interacted with
    and altered concurrently or in parallel, can become mishandled or corrupted. This
    is especially true when the threads and processes interacting with it are poorly
    coordinated and scheduled. The logical conclusion, therefore, is to not allow
    multiple agents to go into a critical section at the same time. We call this concept
    **mutual exclusion**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the relationship between critical sections and the causes of
    race conditions in the next subsection.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How race conditions occur
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider a simple concurrent program, in order to understand what can
    give rise to a race condition. Suppose that the program has a shared resource
    and two separate threads (thread 1 and thread 2) that will access and interact
    with that resource. Specifically, the shared resource is a number and, as per
    their respective execution instructions, each thread is to read in that number,
    increment it by 1, and finally, update the value of the shared resource with the
    incremented number.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the shared number is originally 2, and then, thread 1 accesses
    and interacts with the number; the shared resource then becomes 3\. After thread
    1 successfully alters and exits the resource, thread 2 begins to execute its instructions,
    and the shared resource that is a number is updated to 4\. Throughout this process,
    the number was originally 2, was incremented twice (each time by a separate thread),
    and held a value of 4 at the end. The shared number was not mishandled and corrupted
    in this case.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Imagine, then, a scenario in which the shared number is still 2 at the beginning,
    yet both of the threads access the number at the same time. Now, each of the threads
    reads in the number 2 from the shared resource, each increments the number 2 to
    3 individually, and then, each writes the number 3 back to the shared resource.
    Even though the shared resource was accessed and interacted with by a thread twice,
    it only held a value of 3 at the end of the process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a race condition occurring in a concurrent program: since
    the second thread to access a shared resource does it before the first thread
    finishes its execution (in other words, writing the new value to the shared resource),
    the second thread fails to take in the updated resource value. This leads to the
    fact that, when the second thread writes to the resource, the value that is processed
    and updated by the first thread is overwritten. At the end of the execution of
    the two threads, the shared resource has technically only been updated by the
    second thread.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram further illustrates the contrast between a correct data
    handling process and a situation with a race condition:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cba8d804-7fd7-4729-95db-a8ca8f5647e6.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Mishandling shared data
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, we can see that a race condition can result in the mishandling
    and corruption of data. In the preceding example, we can see that a race condition
    can occur with only two separate threads accessing a common resource, causing
    the shared resource to be updated incorrectly and hold an incorrect value at the
    end of the program. We know that most real-life concurrent applications contain
    significantly more threads and processes and more shared resources, and the more
    threads/processes that interact with the shared resource, the more likely it is
    that a race condition will occur.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Simulating race conditions in Python
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss a solution that we can implement to solve the problem of
    race conditions, let''s try to simulate the problem in Python. If you have already
    downloaded the code for this book from the GitHub page, go ahead and navigate
    to the `Chapter14` folder. Let''s take a look at the `Chapter14/example1.py` file—specifically,
    the `update()` function, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The goal of the preceding `update()` function is to increment a global variable
    called `counter`, and it is to be called by a separate thread in our script. Inside
    the function, we are interacting with a shared resource—in this case, `counter`.
    We then assign the value of `counter` to another local variable, called `current_counter`
    (this is to simulate the process of reading data from more complex data structures
    for the shared resources).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will pause the execution of the function by using the `time.sleep()`
    method. The length of the period during which the program will pause is pseudo-randomly
    chosen between `0` and `1`, generated by the function call, `random.randint(0,
    1)`, so the program will either pause for one second or not at all. Finally, we
    assign the newly computed value of `current_counter` (which is its one-increment)
    to the original shared resource (the `counter` variable).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can move on to our main program:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are initializing the `counter` global variable with a set of `threading.Thread`
    objects, in order to execute the `update()` function concurrently; we are initializing
    twenty thread objects, to increment our shared counter twenty times. After starting
    and joining all of the threads that we have, we can finally print out the end
    value of our shared `counter` variable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Theoretically, a well-designed concurrent program will successfully increment
    the share counter twenty times in total, and, since its original value is `0`,
    the end value of the counter should be `20` at the end of the program. However,
    as you run this script, the `counter` variable that you obtain will most likely
    not hold an end value of `20`. The following is my own output, obtained from running
    the script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This output indicates that the counter was only successfully incremented nine
    times. This is a direct result of a race condition that our concurrent program
    has. This race condition occurs when a specific thread spends time reading in
    and processing the data from the shared resource (specifically, for one second,
    using the `time.sleep()` method), and another thread reads in the current value
    of the `counter` variable, which, at this point, has not been updated by the first
    thread, since it has not completed its execution.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, if a thread does not spend anytime processing the data (in other
    words, when `0` is chosen by the pseudo-random `random.randint()` method), the
    value of the shared resource can potentially be updated just in time for the next
    thread to read and process it. This phenomenon is illustrated by the fact that
    the end value of the counter varies within different runs of the program. For
    example, the following is the output that I obtained after running the script
    three times. The output from the first run is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output from the second run is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output from the third run is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, the final value of the counter is dependent on the number of threads
    that spend one second pausing and the number of threads not pausing at all. Since
    these two numbers are, in turn, dependent on the `random.randint()` method, the
    final value of the counter changes between different runs of the program. We will
    still have a race condition in our program, except for when we can ensure that
    the final value of the counter is always `20` (the counter being successfully
    incremented twenty times, in total).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Locks as a solution to race conditions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the most common solution to race conditions:
    locks. Intuitively, since the race conditions that we observed arose when multiple
    threads or processes accessed and wrote to a shared resource simultaneously, the
    key idea to solving race conditions is to isolate the executions of different
    threads/processes, especially when interacting with a shared resource. Specifically,
    we need to make sure that a thread/process can only access the shared resource
    after any other threads/processes interacting with the resource have finished
    their interactions with that resource.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The effectiveness of locks
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With locks, we can turn a shared resource in a concurrent program into a critical
    section, whose integrity of data is guaranteed to be protected. A critical section
    guarantees the mutual exclusion of a shared resource, and cannot be accessed concurrently
    by multiple processes or threads; this will prevent any protected data from being
    updated or altered with conflicting information, resulting from race conditions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, **Thread B** is blocked from accessing the shared
    resource—the critical section, named `var`—by a mutex (mutual exclusion) lock,
    because **Thread A** is already accessing the resource:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d4e4feb0-9ba3-46f0-89c3-3b4125b58095.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Locks prevent simultaneous access to a critical section
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will specify that, in order to gain access to a critical section in
    a concurrent program, a thread or process needs to acquire a lock object that
    is associated with the critical section; similarly, that thread or process also
    needs to release that lock upon leaving the critical section. This setup will
    effectively prevent multiple accesses to the critical section, and will therefore
    prevent race conditions. The following diagram illustrates the execution flow
    of multiple threads interacting with multiple critical sections, with the implementation
    of locks in place:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将指定，在并发程序中，为了访问临界区，线程或进程需要获取与临界区相关联的锁对象；同样，该线程或进程在离开临界区时也需要释放该锁。这样的设置将有效地防止对临界区的多次访问，因此也将防止竞争条件。以下图表说明了多个线程与多个临界区交互的执行流程，并且实现了锁的设置：
- en: '![](assets/5b3de2b6-dac3-43e0-a00f-4c30702a0763.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b3de2b6-dac3-43e0-a00f-4c30702a0763.png)'
- en: Locks and critical sections in multiple threads
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程中的锁和临界区
- en: 'As you can see in the diagram, threads **T1** and **T2** both interact with
    three critical sections in their respective execution instructions: **CS1**, **CS2**,
    and **CS3**. Here, **T1** and **T2** attempt to access **CS1** at almost the same
    time, and, since **CS1** is protected with lock **L1**, only **T1** is able to
    acquire lock **L1**, and hence, access/interact with the critical section, while
    **T2** has to spend time waiting for **T1** to exit out of the critical section
    and release the lock before accessing the section itself. Similarly, for the critical
    sections, **CS2** and **CS3**, although both threads require access to a critical
    section at the same time, only one can process it, while the other has to wait
    to acquire the lock associated with the critical section.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如图表所示，线程**T1**和**T2**都与其各自的执行指令中的三个临界区**CS1**、**CS2**和**CS3**进行交互。在这里，**T1**和**T2**几乎同时尝试访问**CS1**，由于**CS1**受到锁**L1**的保护，因此只有**T1**能够获取锁**L1**，因此可以访问/与临界区交互，而**T2**必须等待**T1**退出临界区并释放锁后才能访问该区域。同样，对于临界区**CS2**和**CS3**，尽管两个线程同时需要访问临界区，但只有一个可以处理，而另一个必须等待获取与临界区相关联的锁。
- en: Implementation in Python
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的实现
- en: 'Now, let''s implement the specification in the preceding example, in order
    to solve the problem of race conditions. Navigate to the `Chapter14/example2.py`
    file and consider our corrected `update()` function, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现前面示例中的规范，以解决竞争条件的问题。转到`Chapter14/example2.py`文件，并考虑我们已更正的`update()`函数，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see that all of the execution instructions of a thread specified in
    the `update()` function are under the context manager of a lock object named `count_lock`.
    So, every time a thread is called to run the function, it will have to first acquire
    the lock object, before any instructions can be executed. In our main program,
    we simply create the lock object in addition to what we already had, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，线程在`update()`函数中指定的所有执行指令都在名为`count_lock`的锁对象的上下文管理器下。因此，每次调用线程运行该函数时，都必须首先获取锁对象，然后才能执行任何指令。在我们的主程序中，除了我们已经拥有的内容，我们只需创建锁对象，如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the program, and your output should look similar to the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，您的输出应该类似于以下内容：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the counter was successfully incremented twenty times and held
    the correct value at the end of the program. Furthermore, no matter how many times
    the script is executed, the final value of the counter will always be **20**.
    This is the advantage of using locks to implement critical sections in your concurrent
    programs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，计数器成功增加了二十次，并且在程序结束时保持了正确的值。此外，无论脚本执行多少次，计数器的最终值始终为**20**。这是在并发程序中使用锁来实现临界区的优势。
- en: The downside of locks
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁的缺点
- en: 'In [Chapter 12](43dfc569-005f-416d-8492-c0814e403b02.xhtml), *Deadlock*, we
    covered an interesting phenomenon, in which the use of locks can lead to undesirable
    results. Specifically, we found out that, with enough locks implemented in a concurrent
    program, the whole program can become sequential. Let''s analyze this concept
    with our current program. Consider the `Chapter14/example3.py` file, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](43dfc569-005f-416d-8492-c0814e403b02.xhtml)中，*死锁*，我们介绍了一个有趣的现象，即使用锁可能会导致不良结果。具体来说，我们发现，在并发程序中实现了足够多的锁后，整个程序可能会变成顺序执行。让我们用当前的程序来分析这个概念。考虑`Chapter14/example3.py`文件，如下所示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Turning a concurrent program sequential
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将并发程序变为顺序执行
- en: 'The goal of this script is to compare the speed of our current concurrent program
    with its sequential version. Here, we are still using the same `update()` function,
    with locks, and we are running it twenty times, both sequentially and concurrently,
    like we did earlier. We are also creating a list of determined periods of pausing,
    so that these periods are consistent between when we simulate the sequential version
    and when we simulate the concurrent version (for this reason, the `update()` function
    now takes in a parameter that specifies the period of pausing each time it is
    called):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本的目标是比较当前并发程序与其顺序版本的速度。在这里，我们仍然使用相同的带有锁的`update()`函数，并且我们将它连续运行二十次，既顺序执行又并发执行，就像我们之前做的那样。我们还创建了一个确定的暂停时间列表，以便这些时间段在模拟顺序版本和模拟并发版本时保持一致（因此，`update()`函数现在需要接受一个参数，指定每次调用时的暂停时间）：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'During the next step of the program, we simply call the `update()` function
    inside a `for` loop, with twenty iterations, keeping track of the time it takes
    for the loop to finish. Note that, even though this is to simulate the sequential
    version of the program, the `update()` function still needs the lock object to
    be created prior, so we are initializing it here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的下一步中，我们只需在`for`循环中调用`update()`函数，进行二十次迭代，并跟踪循环完成所需的时间。请注意，即使这是为了模拟程序的顺序版本，`update()`函数仍然需要在此之前创建锁对象，因此我们在这里进行初始化：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last step is to reset the counter and run the concurrent version of the
    program that we already implemented. Again, we need to pass in the corresponding
    pause period while initializing each of the threads that run the `update()` function.
    We are also keeping track of the time it takes for this concurrent version of
    the program to run:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是重置计数器并运行我们已经实现的程序的并发版本。同样，我们需要在初始化运行`update()`函数的每个线程时传入相应的暂停时间。我们还要跟踪并发程序运行所需的时间：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, after you have run the script, you will observe that both the sequential
    version and the concurrent version of our program took the same amount of time
    to run. Specifically, the following is the output that I obtained; in this case,
    they both took approximately 12 seconds. The actual time that your program takes
    might be different, but the speed of the two versions should still be equal:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您运行脚本之后，您会观察到我们的程序的顺序版本和并发版本都花费了相同的时间来运行。具体来说，我得到的输出是：在这种情况下，它们都花费了大约12秒。您的程序实际花费的时间可能不同，但两个版本的速度应该是相等的。
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, our concurrent program is taking just as much time as its sequential version,
    which negates one of the biggest purposes of implementing concurrency in a program:
    improving speed. But why would concurrent and traditional sequential applications with
    the same sets of instructions and elements also have the same speed? Should the
    concurrent program always produce a faster speed than the sequential one?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的并发程序所花费的时间与其顺序版本一样多，这否定了在程序中实现并发的最大目的之一：提高速度。但为什么具有相同指令和元素集的并发和传统顺序应用程序也具有相同的速度？并发程序是否总是比顺序程序产生更快的速度？
- en: Recall that, in our program, the critical section is being protected by a lock
    object, and no multiple threads can access it at the same time. Since all of the
    execution of the program (incrementing the counter for twenty times) depends on
    a thread accessing the critical section, the placement of the lock object on the
    critical section means that only one thread can be executing at a given time.
    With this specification, the executions of any two threads cannot overlap with
    each other, and no additional speed can be gained from this implementation of
    concurrency.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在我们的程序中，临界区由一个锁对象保护，没有多个线程可以同时访问它。由于程序的所有执行（对计数器进行20次递增）都取决于一个线程访问临界区，因此在临界区放置锁对象意味着在给定时间内只有一个线程可以执行。根据这个规范，任何两个线程的执行都不会重叠，这种并发实现无法获得额外的速度。
- en: 'This is the phenomenon that we encountered when analyzing the problem of deadlock:
    if enough locks are placed in a concurrent program, that program will become entirely
    sequential. This is a reason why locks are sometimes undesirable solutions to
    problems in concurrent programming. However, this situation only happens if all
    of the execution of the concurrent program is dependent upon interacting with
    the critical section. Most of the time, reading and manipulating the data of a
    shared resource is only a portion of the entire program and, therefore, concurrency
    still provides the intended additional speed for our program.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在分析死锁问题时遇到的现象：如果在并发程序中放置了足够多的锁，那么该程序将变得完全顺序化。这就是为什么锁有时不是并发编程问题的理想解决方案的原因。然而，只有当并发程序的所有执行都依赖于与临界区交互时，才会出现这种情况。大多数情况下，读取和操作共享资源的数据只是整个程序的一部分，因此并发仍然可以为我们的程序提供预期的额外速度。
- en: Locks do not lock anything
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁不会锁任何东西
- en: An additional aspect of locks is the fact that they do not actually lock anything.
    The only way that a lock object is utilized, with respect to a specific shared
    resource, is for the threads and processes interacting with that resource to also
    interact with the lock. In other words, if those threads and processes choose
    to not check with the lock before accessing and altering the shared resource,
    the lock object itself cannot stop them from doing so.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 锁的另一个方面是它们实际上并没有锁住任何东西。锁对象与特定共享资源的交互线程和进程也需要与锁进行交互。换句话说，如果这些线程和进程选择在访问和更改共享资源之前不检查锁，那么锁对象本身就无法阻止它们这样做。
- en: In our examples, you have seen that, to implement the acquiring/releasing process
    of a lock object, the instructions of a thread or process will be wrapped around
    by a lock context manager; this specification is dependent on the implementation
    of the thread/process execution logic and not the resource. That is because the
    lock objects that we have seen are not connected to the resources that they are
    supposed to protect in any way. So, if the thread/process execution logic does
    not require any interaction with the lock object associated with the shared resource,
    that thread or process can simply gain access to the resource without difficulty,
    potentially resulting in the mismanipulation and corruption of data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，您已经看到，为了实现锁对象的获取/释放过程，线程或进程的指令将被锁上下文管理器包裹；这个规范取决于线程/进程执行逻辑的实现，而不是资源。这是因为我们看到的锁对象与它们所应保护的资源没有任何连接。因此，如果线程/进程执行逻辑不需要与共享资源相关联的锁对象进行任何交互，那么该线程或进程可以简单地访问资源而无需困难，可能导致数据的错误操作和损坏。
- en: This is not only true in the scope of having multiple threads and processes
    in a single concurrent program. Suppose that we have a concurrent system consisting
    of multiple components that all interact and manipulate the data of a resource
    shared across the system, and this resource is associated with a lock object;
    it follows that, if any of these components fail to interact with that lock, it
    can simply bypass the protection implemented by the lock and access the shared
    resource. More importantly, this characteristic of locks also has implications
    regarding the security of a concurrent program. If an outside, malicious agent
    is connected to the system (say, a malicious client interacting with a server)
    and intends to corrupt the data shared across the system, that agent can be instructed
    to simply ignore the lock object and access that data in an intrusive way.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅适用于在单个并发程序中拥有多个线程和进程的范围。假设我们有一个由多个组件组成的并发系统，所有这些组件都相互作用并操作跨系统共享的资源的数据，并且这个资源与一个锁对象相关联；由此可见，如果其中任何一个组件未能与该锁进行交互，它可以简单地绕过锁实施的保护并访问共享资源。更重要的是，锁的这种特性也对并发程序的安全性有着重要的影响。如果一个外部的恶意代理连接到系统（比如，一个恶意客户端与服务器进行交互）并且意图破坏跨系统共享的数据，那么该代理可以被指示简单地忽略锁对象并以侵入的方式访问数据。
- en: The view that locks don't lock anything was popularized by Raymond Hettinger,
    a Python core developer who worked on the implementation of various elements in
    Python concurrent programming. It is argued that using lock objects alone does
    not guarantee a secure implementation of concurrent data structures and systems.
    Locks need to be concretely linked to the resources that they are to protect,
    and nothing should be able to access a resource without first acquiring the lock
    that is associated with it. Alternatively, other concurrent synchronization tools,
    such as atomic message queues, can provide a solution to this problem.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 锁不锁任何东西的观点是由雷蒙德·赫廷格（Raymond Hettinger）提出的，他是Python核心开发人员，负责实现Python并发编程中的各种元素。有人认为仅使用锁对象并不能保证并发数据结构和系统的安全实现。锁需要与它们要保护的资源具体关联起来，没有任何东西应该能够在未先获取与之相关联的锁的情况下访问资源。或者，其他并发同步工具，比如原子消息队列，可以提供解决这个问题的方案。
- en: Race conditions in real life
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实生活中的竞争条件
- en: You have now learned about the concept of race conditions, how they are caused
    in concurrent systems, and how to effectively prevent them. In this section, we
    will provide an overarching view of how race conditions can occur in real-life
    examples, within the various sub-fields of computer science. Specifically, we
    will be discussing the topics of security, file management, and networking.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了竞争条件的概念，它们在并发系统中是如何引起的，以及如何有效地防止它们。在本节中，我们将提供一个关于竞争条件如何在计算机科学的各个子领域中发生的总体观点。具体来说，我们将讨论安全、文件管理和网络的主题。
- en: Security
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: Concurrent programming can have significant implications in terms of the security
    of the system in question. Recall that a race condition arises between the process
    of reading and altering the data of a resource; a race condition in an authenticating
    system can cause the corruption of data between the **time of check** (when the
    credentials of an agent are checked) and the **time of use** (when the agent can
    utilize the resource). This problem is also known as a **Time-Of-Check-To-Time-Of-Use**
    (**TOCTTOU**) bug, which is undoubtedly detrimental to security systems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程对系统安全性可能会产生重大影响。回想一下，读取和更改资源数据的过程之间会出现竞争条件；在认证系统中出现竞争条件可能会导致在检查代理的凭据和代理可以利用资源之间数据的损坏。这个问题也被称为**检查时间到使用时间**（TOCTTOU）漏洞，这无疑对安全系统有害。
- en: Careless protection of shared resources when handling race conditions, as we
    briefly touched upon during the last section, can provide external agents with access
    to those supposedly protected resources. Those agents can then change the data
    of the resources to create **privilege escalation** (in simple terms, to give
    themselves more illegal access to more shared resources), or they can simply corrupt
    the data, causing the whole system to malfunction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理竞争条件时对共享资源的粗心保护可以为外部代理提供访问那些被认为受到保护的资源的机会。然后这些代理可以改变资源的数据以创建**权限提升**（简单来说，给自己更多非法访问更多共享资源的权限），或者他们可以简单地破坏数据，导致整个系统发生故障。
- en: Interestingly, race conditions can also be used to implement computer security.
    As race conditions result from the uncoordinated access of multiple threads/processes
    to a shared resources, the specification in which a race condition occurs is significantly
    random. For example, in our own Python example, you saw that, when simulating
    a race condition, the final value of the counter varies between different executions
    of the program; this is (partly) because of the unpredictable nature of the situation,
    in which multiple threads are running and accessing the shared resources. (I say
    partly, since the randomness also results from the random pausing periods that
    we generate in each execution of the program.) So, race conditions are sometimes
    intentionally provoked, and the information obtained when the race condition occurs
    can be used to generate digital fingerprints for security processes—this information,
    again, is significantly random, and is therefore valuable for security purposes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，竞争条件也可以用于实现计算机安全。由于竞争条件是由多个线程/进程对共享资源的不协调访问导致的，竞争条件发生的规范是相当随机的。例如，在我们自己的Python示例中，你看到在模拟竞争条件时，计数器的最终值在程序的不同执行之间变化；这部分是因为情况的不可预测性，其中多个线程正在运行并访问共享资源。（我说部分是因为随机性也是由我们在每次执行程序时生成的随机暂停期间导致的。）因此，有时会故意引发竞争条件，并且在竞争条件发生时获得的信息可以用于生成安全流程的数字指纹——这些信息同样是相当随机的，因此对安全目的而言具有价值。
- en: Operating systems
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统
- en: Race conditions can occur in the context of file and memory management in an
    operating system, when two separate programs attempt to access the same resource,
    such as memory space. Imagine a situation where two processes from different programs
    have been running for a significant amount of time, and, even though they were
    originally initialized apart from each other in terms of memory space, enough
    data has been accumulated and the stack of execution of one process now collides
    with that of the other process. This can lead to the two processes sharing the
    same portion of memory space and can ultimately result in unpredictable consequences.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of the complexity of race conditions is illustrated by the Unix
    version 7 operating system—specifically, in the `mkdir` command. Typically, the
    `mkdir` command is used to create a new directory in the Unix operating system;
    this is done by calling the `mknod` command to create the actual directory and
    the `chown` command to specify the owner of that directory. Because there are
    two separate commands to be run and a definite gap exists between when the first
    command is finished and the second is called, this can cause a race condition.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'During the gap between the two commands, if someone can delete the new directory
    created by the `mknod` command and link the reference to another file, when the
    `chown` command is run, the ownership of that file will be changed. By exploiting
    this vulnerability, someone can theoretically change the ownership of any file
    in an operating system so that someone can create a new directory. The following
    diagram further illustrates this exploitation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/66861344-20e7-4db5-9f43-57592c8b370b.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Diagram of mkdir race condition
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In networking, race conditions can take the form of giving multiple users unique
    privileges in a network. Specifically, say a given server should only have exactly
    one user with admin privileges. If two users, who are both eligible to become
    the server admin, request access to those privileges at the same time, then it
    is possible for both of them to gain that access. This is because, at the point
    when both of the user requests are received by the server, neither of the users
    have been granted admin privileges yet, and the server thinks that admin privileges
    can still be given out.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: This form of a race condition is quite common when a network is highly optimized
    for parallel processing (for example, non-blocking sockets), without a careful
    consideration of the resources shared across the network.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A race condition is defined as a phenomenon during which the output of a system
    is indeterminate and is dependent on the scheduling algorithm and the order in
    which tasks are scheduled and executed. Critical sections indicate shared resources
    that are accessed by multiple processes or threads in a concurrent application,
    which can lead to unexpected, and even erroneous, behavior. A race condition occurs
    when two or more threads/processes access and alter a shared resource simultaneously,
    resulting in mishandled and corrupted data. Race conditions also have significant
    implications in real-life applications, such as security, operating systems, and
    networking.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Since the race conditions that we observed arose when multiple threads or processes
    accessed and wrote to a shared resource simultaneously, the key idea for solving
    race conditions is to isolate the execution of different threads/processes, especially
    when interacting with a shared resource. With locks, we can turn a shared resource
    in a concurrent program into a critical section, whose integrity of data is guaranteed
    to be protected. However, there are a number of disadvantages to using locks: with
    enough locks implemented in a concurrent program, the whole program might become
    sequential; locks don't lock anything.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will consider one of the biggest problems in Python
    concurrent programming: the infamous **Global Interpreter Lock (GIL)**. You will
    learn about the basic idea behind the GIL, its purposes, and how to effectively
    work with it in concurrent Python applications.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑Python并发编程中最大的问题之一：臭名昭著的**全局解释器锁（GIL）**。您将了解GIL背后的基本思想，它的目的，以及如何在并发Python应用程序中有效地使用它。
- en: Questions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a critical section?
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是临界区？
- en: What is a race condition and why is it undesirable in a concurrent program?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是竞争条件，为什么在并发程序中是不可取的？
- en: What is the underlying cause of race conditions?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争条件的根本原因是什么？
- en: How can locks solve the problem of race conditions?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁如何解决竞争条件的问题？
- en: Why are locks sometimes undesirable in a concurrent program?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么锁有时在并发程序中是不可取的？
- en: What is the significance of race conditions in real-life systems and applications?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实生活系统和应用中，竞争条件的重要性是什么？
- en: Further reading
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，您可以参考以下链接：
- en: '*Parallel Programming with Python*, by Jan Palach, Packt Publishing Ltd, 2014'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Python进行并行编程*，作者Jan Palach，Packt Publishing Ltd，2014'
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python并行编程食谱*，作者Giancarlo Zaccone，Packt Publishing Ltd，2015'
- en: '*Race Conditions and Critical Sections* ([tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections](http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html)),
    by Jakob Jenkov'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*竞争条件和临界区*（[tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections](http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html)），作者Jakob
    Jenkov'
- en: '*Race conditions, files, and security flaws; or the tortoise and the hare redux*,
    by Matt Bishop, Technical Report CSE-95-98(1995)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*竞争条件、文件和安全漏洞；或乌龟和野兔的重现*，作者Matt Bishop，技术报告CSE-95-98（1995）'
- en: '*Computer and Information Security, Chapter 11, Software Flaws and Malware
    1 Illustration* ([slideplayer.com/slide/10319860/](https://slideplayer.com/slide/10319860/))'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计算机和信息安全，第11章，软件缺陷和恶意软件1插图*（[slideplayer.com/slide/10319860/](https://slideplayer.com/slide/10319860/)）'
