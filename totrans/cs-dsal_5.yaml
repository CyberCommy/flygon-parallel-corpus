- en: Variants of Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you have learned about many data structures, starting
    with simple ones, such as arrays. Now, it is time for you to get to know a significantly
    more complex group of data structures, namely **trees**.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, the basic tree will be presented, together
    with its implementation in the C# language and some examples showing it in action.
    Then, the binary tree will be introduced with a detailed description of its implementation
    and an example of its application. The binary search tree is another tree variant,
    which is one of the most popular types of trees, used in many algorithms. The
    following two sections will cover self-balancing trees, namely AVL and red-black
    trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining part of the chapter is dedicated to heaps as tree-based data
    structures. Three kinds of heaps will be presented: binary, binomial, and Fibonacci.
    Such types will be briefly introduced, and the application of these data structures
    will be shown, using the external package.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays, lists, stacks, queues, dictionaries, sets, and now... trees. Are you
    ready to increase the level of difficulty and learn the next set of data structures?
    If so, let's start reading!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AVL trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red-black trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary heaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binomial heaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fibonacci heaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with introducing trees. What are they? Do you have any ideas about
    how such a data structure should look? If not, let''s take a look at the following
    diagram, which depicts a tree with captions regarding its particular elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c15bf17-435a-40a2-a6ab-3b2768d96d92.png)'
  prefs: []
  type: TYPE_IMG
- en: A tree consists of multiple **nodes**, including one **root** (**100** in the
    diagram). The root does not contain a **parent** node, while all other nodes do.
    For example, the parent element of node **1** is **100**, while node **96** has
    node **30** as the **parent**. Moreover, each node can have any number of **child**
    nodes, such as three **children** (that is, **50**, **1**, and **150**) in the
    case of the **root**. The child nodes of the same node can be named **siblings**,
    as in the case of nodes **70** and **61**. A node without children is named a **leaf**,
    such as **45** and **6** in the diagram. Take a look at the rectangle with three
    nodes (that is, **30**, **96**, and **9**). Such a part of the tree can be called
    a **subtree**. Of course, you can find many subtrees in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly talk about the minimum and maximum numbers of children of a node.
    In general, such numbers are not limited and each node can contain zero, one,
    two, three, or even more children. However, in practical applications, the number
    of children is often limited to two, as you will see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C#-based implementation of a basic tree seems to be quite obvious and not
    complicated. To do so, you can declare two classes, representing a single node
    and a whole tree, as described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first class is named `TreeNode` and is declared as the generic class to
    provide a developer with the ability to specify the type of data stored in each
    node. Thus, you can create the strongly-typed solution, which eliminates the necessity
    of casting objects to target types. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The class contains three properties: the data stored in the node (`Data`) of
    the type (`T`) specified while creating an instance of the class, a reference
    to the parent node (`Parent`), and a collection of references to child nodes (`Children`).'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the properties, the `TreeNode` class contains the `GetHeight` method,
    which returns a height of the node, that is, the distance to the root node. The
    implementation of this method is very simple, because it just uses the `while`
    loop to go up from the node until there is no parent element (when the root is
    reached).
  prefs: []
  type: TYPE_NORMAL
- en: Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next necessary class is named `Tree`, and it represents the whole tree.
    Its code is even simpler than that presented in the preceding section, and is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class contains only one property, `Root`. You can use this property to get
    access to the root node, and then you can use its `Children` property to obtain
    data of other nodes located in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that both `TreeNode` and `Tree` classes are generic and the
    same type is used in the case of these classes. For instance, if tree nodes should
    store `string` values, the `string` type should be used in the case of instances
    of `Tree` and `TreeNode` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Example – hierarchy of identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you want to see how to use a tree in a C#-based application? Let's take a
    look at the first example. The aim is to construct the tree with a few nodes,
    as shown in the following diagram. Only the group of nodes with darker backgrounds
    will be presented in the code. However, it is a good idea to adjust the code to
    extend this tree by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6afd0e1c-87c6-4057-a278-d08277502586.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the example, each node stores an integer value. Thus, `int`
    will be the type used for both `Tree` and `TreeNode` classes. The following part
    of code should be placed in the `Main` method in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code looks quite simple, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, a new instance of the `Tree` class is created. Then, the root
    node is configured by creating a new instance of the `TreeNode` class, setting
    a value of the `Data` property (to `100`), and assigning a reference to the `TreeNode`
    instance to the `Root` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines, the child nodes of the root node are specified—nodes
    with values equal to `50`, `1`, and `150`. For each of them, a value of the `Parent`
    property is set to a reference to the previously-added root node.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the code shows how to add a child node for a given node,
    namely for the third child of the root node, that is, the node with value equal
    to `150`. Here, only one node is added, the one with the value set to `30`. Of
    course, you need to specify a reference to the parent node as well.
  prefs: []
  type: TYPE_NORMAL
- en: That's all! You have created the first program that uses trees. Now you can
    run it, but you will not see any output in the console. If you want to see how
    data of nodes are organized, you can debug the program and see values of variables
    while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Example – company structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, you saw how to use integer values as data for each
    node in a tree. However, it is also possible to store instances of user-defined
    classes in nodes. In this example, you will see how to create a tree presenting
    the structure of a company, divided into three main departments: development,
    research, and sales.'
  prefs: []
  type: TYPE_NORMAL
- en: Within each department there can be another structure, such as in the case of
    the development team. Here, **John Smith** is **Head of Development**. He is a
    boss for **Chris Morris**, who is a manager for two junior developers, **Eric
    Green** and **Ashley Lopez**. The latter is also a supervisor of **Emily Young**,
    who is a **Developer Intern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example tree is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d22420a3-eabe-4864-abeb-a7c8eeb5b16b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, each node should store more information than just an integer
    value. There should be an identifier, a name, and a role. Such data are stored
    as values of properties in an instance of the `Person` class, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The class contains three properties ( `Id`, `Name`, and `Role`), as well as
    two constructors. The first constructor does not take any parameters, while the
    other takes three and sets values of particular properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from creating a new class, it is also necessary to add some code in the
    `Main` method in the `Program` class. The necessary lines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, a new instance of the `Tree` class is created. It is worth
    mentioning that the `Person` class is used as a type specified while creating
    new instances of `Tree` and `TreeNode` classes. Thus, you can easily store more
    than one simple data for each node.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining lines of code look similar to the first example for basic trees.
    Here, you also specify the root node (for the `CEO` role), then configure its
    child elements (`John Smith`, `Mary Fox`, and `Lily Smith`), and set a child node
    for one of the existing nodes, namely the node for the `Head of Sales`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does it look simple and straightforward? In the next section, you will see
    a more restricted, but very important and well-known, variant of trees: the binary
    tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Binary trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally speaking, each node in a basic tree can contain any number of children.
    However, in the case of **binary trees**, a node cannot contain more than two
    children. It means that it can contain zero, one, or two child nodes. Such a requirement
    has an important impact on the shape of a binary tree, as shown in the following
    two diagrams presenting binary trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97d1ae70-d6ba-4cba-bddc-beef55c0cba2.png)'
  prefs: []
  type: TYPE_IMG
- en: As already mentioned, a node in a binary tree can contain at most two children.
    For this reason, they are referred to as the **left child** and **right child**.
    In the case of the binary tree shown on the left-hand side of the preceding diagram,
    node **21** has two children, **68** as the left child and **12** as the right
    child, while node **100** has only a left child.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you thought about how you can iterate through all the nodes in a tree?
    How can you specify an order of nodes during **traversal** of a tree? There are
    three common approaches: pre-order, in-order, and post-order, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6203e8c5-d23c-41ca-b4ec-f7addeb54a82.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the diagram, there are clearly visible differences between
    the approaches. However, do you have any idea how you can apply pre-order, in-order,
    or post-order traversals for binary trees? Let's explain all of these approaches
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to traverse a binary tree with the **pre-order** approach, you first
    need to visit the root node. Then, you visit the left child. Finally, the right
    child is visited. Of course, such a rule does not apply only to the root node,
    but to any node within a tree. For this reason, you can understand the order of
    pre-order traversal as first visiting the current node, then its left child (the
    whole left subtree using the pre-order approach recursively), and finally its
    right child (the right subtree in a similar way).
  prefs: []
  type: TYPE_NORMAL
- en: The explanation can sound a bit complicated, so let's take a look at the simple
    example regarding the tree shown on the left of the preceding diagram. First,
    the root node (that is, **1**) is visited. Then, you analyze its left child node.
    For this reason, the next visited node is the current node, **9**. The next step
    is the pre-order traversal of its left child. Thus, **5** is visited. As this
    node does not contain any children, you can return to the stage of traversing
    when **9** is the current node. It has already been visited, as has its left child
    node, so it is time to proceed to its right child. Here, you first visit the current
    node, **6**, and follow to its left child, **3**. You can apply the same rules
    to continue traversing the tree. The final order is **1**, **9**, **5**, **6**,
    **3**, **4**, **2**, **7**, **8**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it still sounds a bit confusing, the following diagram should remove any
    confusions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b456784-0ec6-474b-9b66-0f372d545dfb.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram presents the following steps of the pre-order traversal with additional
    indicators: **C** for the **current node**, **L** for the **left child**, and
    **R** for the **right child**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second traversal mode is called **in-order**. It differs from the pre-order
    approach in the order that nodes are visited in: first the left child, then the
    current node, and then the right child. If you take a look at the example shown
    in the diagram with all three traversal modes, you can see that the first visited
    node is **5**. Why? At the beginning, the root node is analyzed, but it is not
    visited, because the in-order traversal starts with the left child node. Thus,
    it analyzes node **9**, but it also has a left child, **5**, so you proceed to
    this node. As this node does not have any children, the current node (**5**) is
    visited. Then, you return to the step when the current node is **9** and—as its
    left child has been already visited—you visit also the current node. Next, you
    follow to the right child, but it has a left child, **3**, which should be visited
    first. According to the same rules, you visit the remaining nodes in the binary
    tree. The final order is **5**, **9**, **3**, **6**, **1**, **4**, **7**, **8**, **2**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last traversal mode is named **post-order** and supports the following
    order of node traversal: the left child, the right child, then the current node.
    Let''s analyze the post-order example shown on the right side of the diagram.
    At the beginning, the root node is analyzed, but it is not visited, because the
    post-order traversal starts with the left child node. Thus—as in the case of the
    in-order approach—you proceed to node **9**, then **5**. Then, you need to analyze
    the right child of node **9**. However, node **6** has the left child (**3**),
    which should be visited first. For this reason, after **5**, you visit **3**,
    and then **6**, followed by **9**. What is interesting is that the root node of
    the binary tree is visited at the end. The final order is **5**, **3**, **6**,
    **9**, **8**, **7**, **2**, **4**, **1**.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about binary trees at [https://en.wikipedia.org/wiki/Binary_tree](https://en.wikipedia.org/wiki/Binary_tree).
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let's proceed to the C#-based implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of a binary tree is really simple, especially if you use
    the already-described code for the basic tree. For your convenience, the whole
    necessary code is placed in the following sections, but only its new parts are
    explained in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A node in a binary tree is represented by an instance of `BinaryTreeNode`,
    which inherits from the `TreeNode` generic class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `BinaryTreeNode` class, it is necessary to declare two properties, `Left`
    and `Right`, which represent both possible children of a node. The relevant part
    of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, you need to ensure that the collection of child nodes contains exactly
    two items, initially set to `null`. You can achieve this goal by assigning a default
    value to the `Children` property in the constructor, as shown in the preceding
    code. Thus, if you want to add a child node, a reference to it should be placed
    as the first or the second element of the list (the `Children` property). Therefore,
    such a collection always has exactly two elements and you can access the first
    or the second element without any exception. If it is set to any node, a reference
    to it is returned, otherwise `null` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next necessary class is named `BinaryTree`. It represents the whole binary
    tree. By using the generic class, you can easily specify a type of data stored
    in each node. The first part of the implementation of the `BinaryTree` class is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BinaryTree` class contains two properties: `Root`, which indicates the
    root node (as an instance of the `BinaryTreeNode` class), as well as `Count`,
    which has the total number of nodes placed in the tree. Of course, these are not
    the only members of the class, because it can also be equipped with a set of methods
    regarding traversing the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first traversal method, described in this book, is pre-order. As a reminder,
    it first visits the current node, then its left child, followed by the right child.
    The code of the `TraversePreOrder` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes two parameters: the current node (`node`) and the list of
    already-visited nodes (`result`). The recursive implementation is very simple.
    First, you check whether the node exists by ensuring that the parameter is not
    equal to `null`. Then, you add the current node to the collection of visited nodes,
    start the same traversal method for the left child, and—at the end—start it for
    the right child.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar implementation is possible for the in-order and post-order traversal
    modes. Let''s start with the code of the `TraverseInOrder` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, you recursively call the `TraverseInOrder` method for the left child,
    add the current node to the list of visited nodes, and start the in-order traversal
    for the right child.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is related to the post-order traversal mode, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code is very similar to the already-described methods, but, of course, another
    order of visiting nodes is applied. Here, you start with the left child, then
    you visit the right child, followed by the current node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add the public method for traversing the tree in various modes,
    which calls private methods presented earlier. The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The method takes only one parameter, a value of the `TraversalEnum` enumeration,
    which chooses the proper mode from pre-order, in-order, and post-order. The `Traverse`
    method uses the `switch` statement to call a suitable private method, depending
    on a value of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For using the `Traverse` method, it is also necessary to declare the `TraversalEnum`
    enumeration, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method described in this section is `GetHeight`. It returns the height
    of the tree, which can be understood as the maximum number of steps to travel
    from any leaf node to the root. The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code just iterates through all nodes of the tree using the pre-order traversal,
    reads the height for the current node (using the `GetHeight` method from the `TreeNode`
    class, described earlier), and saves it as the maximum one, if it is larger than
    the current maximum value. At the end, the calculated height is returned.
  prefs: []
  type: TYPE_NORMAL
- en: After the introduction to the topic of binary trees, let's see an example where
    this data structure is used for storing questions and answers in a simple quiz.
  prefs: []
  type: TYPE_NORMAL
- en: Example – simple quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example of a binary tree, a simple quiz application will be used. The
    quiz consists of a few questions and answers, shown depending on the previously-taken
    decisions. The application presents the question, waits until the user presses
    *Y* (yes) or *N* (no), and proceeds to the next question or shows the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the quiz is created in the form of a binary tree, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2679026d-3aac-4d4d-8868-2b46f7dfbe2f.png)'
  prefs: []
  type: TYPE_IMG
- en: At the beginning, the user is asked whether he or she has any experience in
    application development. If so, the program asks whether he or she has worked
    as a developer for more than five years. In the case of a positive answer, the
    result regarding applying to work as a senior developer is presented. Of course,
    other answers and questions are shown in the case of different decisions taken
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the simple quiz requires the `BinaryTree` and `BinaryTreeNode`
    classes, which were presented and explained earlier. Apart from them, you should
    declare the `QuizItem` class to represent a single item, such as a question or
    an answer. Each item contains only the textual content, stored as a value of the
    `Text` property. The proper implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Some modifications are necessary in the `Program` class. Let''s take a look
    at the modified `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the first line within the method, the `GetTree` method (shown in the following
    code snippet) is called to construct the tree with questions and answers. Then,
    the root node is taken as the current node, for which the following operations
    are taken until the answer is reached.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, you check whether the left or right child node exists, that
    is, whether it is a question (not an answer). Then, the textual content is written
    in the console and the program waits until the user presses a key. If it is equal
    to *Y*, the information about choosing the *yes* option is shown and the current
    node's left child is used as the current node. Similar operations are performed
    in the case of choosing *no*, but then the current node's right child is used
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: When decisions taken by the user cause the answer to be shown, it is presented
    in the console and `null` is assigned to the `node` variable. Therefore, you break
    out of the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the `GetTree` method is used to construct the binary tree with
    questions and answers. Its code is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, a new instance of the `BinaryTree` generic class is created.
    It is also configured that each node contains data as an instance of the `QuizItem`
    class. Then, you assign a new instance of the `BinaryTreeNode` to the `Root` property.
  prefs: []
  type: TYPE_NORMAL
- en: What is interesting is that even while creating questions and answers programmatically,
    you create some kind of tree-like structure, because you use the `Children` property
    and specify items directly within such constructions. Therefore, you do not need
    to create many local variables for all questions and answers. It is worth noting
    that a question-related node is an instance of the `BinaryTreeNode` class with
    two child nodes (for  *yes* and *no* decisions), while an answer-related node
    cannot contain any child nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In the presented solution, the values of the `Parent` property of the `BinaryTreeNode`
    instances are not set. If you want to use them or get the height of a node or
    a tree, you should set them on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last auxiliary method is `WriteAnswer`, with the code being as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The method just presents the text, passed as the parameter, in the white color
    in the console. It is used to show decisions taken by the user and the textual
    content of the answer.
  prefs: []
  type: TYPE_NORMAL
- en: The simple quiz application is ready! You can build the project, launch it,
    and answer a few questions to see the results. Then, let's close the program and
    proceed to the next section, where a variant of the binary tree data structure
    is presented.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A binary tree is an interesting data structure that allows creating a hierarchy
    of elements, with the restriction that each node can contain at most two children,
    but without any rules about relationships between the nodes. For this reason,
    if you want to check whether the binary tree contains a given value, you need
    to check each node, traversing the tree using one of three available modes: pre-order,
    in-order, or post-order. This means that the lookup time is linear, namely *O(n)*.'
  prefs: []
  type: TYPE_NORMAL
- en: What about a situation where there are some precise rules regarding relations
    between nodes in the tree? Let's imagine a scenario where you know that the left
    subtree contains nodes with values smaller than the root's value, while the right
    subtree contains nodes with values greater than the root's value. Then, you can
    compare the searched value with the current node and decide whether you should
    continue searching in the left or right subtree. Such an approach can significantly
    limit the number of operations necessary to check whether the tree contains a
    given value. It seems quite interesting, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is applied in the **binary search tree** data structure, which
    is also referred to as **BST**. It is a kind of a binary tree that introduces
    two strict rules regarding relations between nodes in the tree. The rules states
    that for any node:'
  prefs: []
  type: TYPE_NORMAL
- en: Values of all nodes in its left subtree must be smaller than its value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of all nodes in its right subtree must be greater than its value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, a BST can contain two or more elements with the same value. However,
    within this book a simplified version is given, which does not accept more than
    one element with the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does it look in practice? Let''s take a look at the following diagram of
    BSTs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cf99bb5-d124-494d-a022-c15038af2e46.png)'
  prefs: []
  type: TYPE_IMG
- en: The tree shown on the left-hand side contains 12 nodes. Let's check whether
    it complies with the BST rule. You can do so by analyzing each node, except leaf
    nodes, in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the root node (with value **50**) that contains four descendant
    nodes in the left subtree (**40**, **30**, **45**, **43**), all smaller than **50**.
    The root node contains seven descendant nodes in the right subtree (**60**, **80**,
    **70**, **65**, **75**, **90**, **100**), all greater than **50**. That means
    that the BST rule is satisfied for the root node. If you want to check the BST
    rule for the node **80**, you will see that the values of all descendant nodes
    in the left subtree (**70**, **65**, **75**) are smaller than **80**, while the
    values in the right subtree (**90**, **100**) are greater than **80**. You should
    perform the same verification for all nodes in the tree. Similarly, you can confirm
    that the BST from the right-hand side of the diagram adheres to the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, two such BSTs significantly differ in their topology. Both have the
    same height, but the number of nodes is different—12 and 7\. The one on the left
    seems to be fat, while the other is rather skinny. Which one is better? To answer
    to this question, let''s think about the algorithm of searching a value in the
    tree. As an example, the process of searching for the value **43** is described
    and presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32e6b37f-f619-4268-b1b6-0c81a8af6846.png)'
  prefs: []
  type: TYPE_IMG
- en: At the beginning, you take a value of the root node (that is, **50**) and check
    whether the given value (**43**) is smaller or greater. It is smaller, so you
    proceed to searching in the left subtree. Thus, you compare **43** with **40**.
    This time, the right subtree is chosen, because **43** is greater than **40**.
    Next, **43** is compared with **45** and the left subtree is chosen. Here, you
    compare **43** with **43**. Thus, the given value is found. If you take a look
    at the tree, you will see that only four comparisons are necessary and the impact
    on performance is obvious.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is clear than the shape of a tree has a great impact on
    the lookup performance. Of course, it is much better to have a fat tree with limited
    height than a skinny tree with bigger height. The performance boost is caused
    by making decisions as to whether searching should be continued in the left or
    right subtree, without the necessity of analyzing values of all nodes. If nodes
    do not have both subtrees, the positive impact on the performance will be limited.
    In the worst case, when each node contains only one child, the search time is
    even linear. However, in the ideal BST, the lookup time is the *O(log n)* operation.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about BSTs at [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree).
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let's proceed to the implementation in the C#
    language. At the end, you will see the example that shows how to use this data
    structure in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of a BST is more difficult than the previously-described
    variants of trees. For example, it requires you to prepare operations of insertion
    and removal of nodes from a tree, which do not break the rule regarding arrangement
    of elements in the BST. What is more, you need to introduce a mechanism for comparing
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the class representing a single node in a tree. Fortunately,
    you can use the implementation of the class already described for the binary tree
    (`BinaryTreeNode`) as a base. The modified code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a BST is a variant of a binary tree, each node has a reference to its left
    and right child node (or `null` if it does not exist), as well as to the parent
    node. A node stores also a value of a given type. As you can see in the preceding
    code, two members are added to the `BinaryTreeNode` class, namely the `Parent`
    property (of the `BinaryTreeNode` type) and the `GetHeight` method. They are moved
    and adjusted from the implementation of the `TreeNode` class. Its final code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The reason for the modification is to provide a developer with the simple way
    of accessing the parent node for a given node without casting from `TreeNode`
    to `BinaryTreeNode`.
  prefs: []
  type: TYPE_NORMAL
- en: Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole tree is represented by an instance of the `BinarySearchTree` class,
    which inherits from the `BinaryTree` generic class, as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that a type of data, stored in each node, should be comparable.
    For this reason, it has to implement the `IComparable` interface. Such a requirement
    is necessary because the algorithm needs to know the relationships between values.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is not the final version of the implementation of the `BinarySearchTree`
    class. You will see how to add new features, such as lookup, insertion, and removal
    of nodes, in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Contains` method, which checks whether the tree
    contains a node with a given value. Of course, this method takes into account
    the BST rule regarding arrangement of nodes to limit the amount of comparisons.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The method takes only one parameter, the value that should be found in the tree.
    Inside the method, the `while` loop exists. Within it, the searched value is compared
    with the value of the current node. If they are equal (the comparison returns
    `0` as the result), the value is found and the `true` Boolean value is returned
    to inform that the search is completed successfully. If the searched value is
    smaller than the value of the current node, the algorithm continues searching
    in the subtree with the left child of the current node as the root. Otherwise,
    the right subtree is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `CompareTo` method is provided by implementation of the `IComparable` interface
    from the `System` namespace. Such a method makes it possible to compare values.
    If they are equal, `0` is returned. If the object on which the method is called
    is bigger than the parameter, a value higher than `0` is returned. Otherwise,
    a value lower than `0` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The loop is executed until the node is found or there is no suitable child node
    to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next necessary operation is insertion of a node into a BST. Such a task
    is a bit more complicated, because you need to find a place for adding a new element
    that will not violate the BST rules. Let''s take a look at the code of the `Add`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The method takes one parameter, a value that should be added to the tree. Within
    the method, you find a parent element (using the `GetParentForNewNode` auxiliary
    method), where a new node should be added as a child. Then, a new instance of
    the `BinaryTreeNode` class is created and the values of its `Data` and `Parent`
    properties are set.
  prefs: []
  type: TYPE_NORMAL
- en: In the following part of the method, you check whether the found parent element
    is equal to `null`. It means that there are no nodes in the tree and the new node
    should be added as the root, which is well visible in the line, where a reference
    to the node is assigned to the `Root` property. The next comparison checks whether
    the value for addition is smaller than the value of the parent node. In such a
    case, the new node should be added as the left child of the parent node. Otherwise,
    the new node is placed as the right child of the parent node. At the end, the
    number of elements stored in the tree is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the auxiliary method for finding the parent element for
    a new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method is named `GetParentForNewNode` and takes one parameter, the value
    of the new node. Within this method, you declare two variables representing the
    currently-analyzed node (`current`) and the parent node (`parent`). Such values
    are modified in the `while` loop until the algorithm finds a proper place for
    the new node.
  prefs: []
  type: TYPE_NORMAL
- en: In the loop, you store a reference to the current node as the potential parent
    node. Then, the comparisons are performed, as in the case of the previously-described
    code snippet. First, you check whether the value for addition is equal to the
    value of the current node. If so, an exception is thrown, because it is not allowed
    to add more than one element with the same value to the analyzed version of the
    BST. If the value for addition is smaller than the value of the current node,
    the algorithm continues searching for the place for the new node in the left subtree.
    Otherwise, the right subtree of the current node is used. At the end, the value
    of the `parent` variable is returned to indicate the found location for the new
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Removal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know how to create a new BST, add some nodes to it, as well as check
    whether a given value already exists in the tree. However, can you also remove
    an item from a tree? Of course! You will learn how to achieve this goal in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main method regarding removal of a node from the tree is named `Remove`
    and takes only one parameter, the value of the node that should be removed. The
    implementation of the `Remove` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the method just calls another method, also named `Remove`.
    The implementation of this method is more complicated and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, the method checks whether the current node (the `node` parameter)
    exists. If not, the exception is thrown. Then, the `Remove` method tries to find
    the node to remove. That is achieved by comparing the value of the current node
    with the value for removal and calling the `Remove` method recursively for either
    the left or right subtree of the current node. Such operations are performed in
    the conditional statements with conditions `data.CompareTo(node.Data) < 0` and
    `data.CompareTo(node.Data) > 0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting operations are performed in the following part of the
    method. Here, you need to handle four scenarios of node removal, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a leaf node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with only a left child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with only a right child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with both left and right children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, you just update a reference to the deleted node in the parent
    element. Therefore, there will be no reference from the parent node to the deleted
    node and it cannot be reached while traversing the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case is also simple, because you only need to replace a reference
    to the deleted node (in the parent element) with the node that is a left child
    of the deleted node. This scenario is shown in the following diagram, which presents
    how to remove node **80** with only the left child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8d6e2e8-5b7d-4c51-a014-bcc3cc5a5750.png)'
  prefs: []
  type: TYPE_IMG
- en: The third case is very similar to the second case. Thus, you just replace a
    reference to the deleted node (in the parent element) with the node that is a
    right child of the deleted node.
  prefs: []
  type: TYPE_NORMAL
- en: 'All those three cases are handled in the code in a similar way, by calling
    the auxiliary method (`ReplaceInParent`). It takes two parameters: the node for
    removal and the node that should replace it in the parent node. For this reason,
    if you want to remove a leaf node, you just pass `null` as the second parameter,
    because you do not want to replace the removed node with anything else. In the
    case of removing a node with only one child, you pass a reference to the left
    or right child. Of course, you also need to decrement the counter storing the
    number of elements located in the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The related part of code is as follows (it differs for various cases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the most complicated scenario is removal of a node with both child
    nodes. In such a case, you find a node with the minimum value in the right subtree
    of the node for removal. Then, you swap the value of the node for removal with
    the value of the found node. Finally, you just need to call the `Remove` method
    recursively for the found node. The relevant part of code is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The important role is performed by the `ReplaceInParent` auxiliary method,
    the code for which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes two parameters: the node for removal (`node`) and the node
    that should replace it in the parent node (`newNode`). If the node for removal
    is not the root, you check whether it is the left child of the parent. If so,
    a proper reference is updated, that is, the new node is set as the left child
    of the parent node of the node for removal. In a similar way, the method handles
    the scenario when the node for removal is the right child of the parent. If the
    node for removal is the root, the node for replacing is set as the root.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end, you check whether the new node is not equal to `null`, that is,
    you are not removing a leaf node. In such a case, you set a value of the `Parent`
    property to indicate that the new node should have the same parent as the node
    for removal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last auxiliary method is named `FindMinimumInSubtree` and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The method takes only one parameter, namely the root of the subtree, where the
    minimum value should be found. Within the method, the `while` loop is used to
    get the leftmost element. When there is no left child, the current value of the
    `node` variable is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The presented implementation of the BST is based on the code shown at [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks quite simple, doesn''t it? However, how does it work in practice?
    Let''s take a look at a diagram depicting the removal of a node with two children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee7545af-cf87-4982-bbd0-9c8dd810140b.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram shows how to remove the node with **40** as the value. To do so,
    you need to find the successor, that is, the node with the minimum value in the
    right subtree of the node for removal. The successor is node **42**, which replaces
    node **40**.
  prefs: []
  type: TYPE_NORMAL
- en: Example – BST visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While reading the part regarding the BSTs, you have learned a lot about the
    data structure. As such, it is high time to create an example program to see this
    variant of trees in action. The application will show how to create a BST, add
    some nodes (both manually and using the previously-presented method for insertion),
    remove nodes, traverse the tree, and visualize the tree in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s adjust the code of the `Program` class, as shown in the following block
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning, a new tree (with nodes storing integer values) is prepared
    by creating a new instance of the `BinarySearchTree` class. It is configured manually
    by adding three nodes, together with indicating proper references for children
    and parent elements. The relevent part of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you use the `Add` method to add some nodes to the tree, and visualize
    the current state of the tree using the `VisualizeTree` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The next set of operations is related to the removal of various nodes from
    the tree, together with visualization of particular changes. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, all three traversal modes are presented. The part of code related
    to the pre-order approach is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Another interesting task is the development of the visualization of the tree
    in the console. Such a feature is really useful, because it allows a comfortable
    and fast way of observing the tree without the necessity of debugging the application
    in the IDE and expanding the following elements in the tooltip with the current
    values of variables. However, presenting the tree in the console is not a trivial
    task. Fortunately, you do not need to worry about it, because you will learn how
    to implement such a feature in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the `VisualizeTree` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes two parameters: an instance of the `BinarySearchTree` class
    representing the whole tree, and the caption that should be shown above the visualization.
    Within the method, the jagged array (with characters that should be presented
    in the console) is initialized using the `InitializeVisualization` auxiliary method.
    Then, you call the `VisualizeNode` recursive method to fill various parts of the
    jagged array with data regarding particular nodes existing in the tree. At the
    end, the caption and all rows from the buffer (represented by the jagged array)
    are written in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next interesting method is `InitializeVisualization`, which creates the
    afore mentioned jagged array, as presented in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The jagged array contains the number of rows equal to the height of the tree
    multiplied by `2` to have space also for lines connecting nodes with parents.
    The number of columns is calculated according to the formula *width* * 2*^(height)*
    - 1, where *width* is the constant value `COLUMN_WIDTH` and *height* is the height
    of the tree. These values can be simpler to understand if you take a look at the
    result in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, the jagged array has 8 elements. Each is an array with 75 elements. Of
    course, you can understand it as a screen buffer with 8 rows and 75 columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `VisualizeTree` method, `VisualizeNode` is called. Are you interested
    to learn about how it works and how you can present not only the values of nodes,
    but also lines? If so, let''s take a look at its code, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `VisualizeNode` method takes five parameters: the current node for visualization
    (`node`), the index of a row (`row`), the index of a column (`column`), the jagged
    array as the buffer (`console`), and the width (`width`). Within the method, there
    is a check for whether the current node exists. If it does, the value of the node
    is obtained as the `char` array, the margin is calculated, and the `char` array
    (with character-based representation of the value) is written in the buffer (the
    `console` variable).'
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines of code, the `VisualizeNode` method is called for left
    and right child nodes of the current node. Of course, you need to adjust the index
    of the row (by adding `2`) and the index of the column (by adding or subtracting
    the calculated value).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, the lines are drawn by calling the `DrawLineLeft` and `DrawLineRight`
    methods. The first is presented in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The method also takes five parameters: the current node for which the line
    should be drawn (`node`), the index of a row (`row`), the index of a column (`column`),
    the jagged array as the buffer (`console`), and the delta value calculated in
    the `VisualizeNode` method (`columnDelta`). At the beginning, you check whether
    the current node contains a left child, because only then is it necessary to draw
    the left part of the line. If so, you calculate the start and end indices of columns,
    and fill the proper elements of the jagged array with dashes. At the end, the
    plus sign is added to the jagged array in the place where the drawn line will
    be connected with the right line of another element. Moreover, the Unicode character
    ┌ (`\u250c`) is added on the other side of the line to create a user-friendly
    visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In almost the same way, you can draw the right line for the current node. Of
    course, you need to adjust the code regarding calculating column start and end
    indices, and change a character used to present changing direction of the line.
    The final version of the code of the `DrawLineRight` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! You have written the whole code necessary to build the project,
    launch the program, and see it in action. Just after launching, you will see the
    first BST, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the next two nodes, `75` and `125`, the BST looks a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you perform the insertion operation for the next five elements. These
    operations have a very visible impact on the tree shape, as presented in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding 10 elements, the program shows an impact of removing a particular
    node on the shape of the tree. To start, let''s remove the leaf node with `25`
    as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the program checks removing a node with only one child node, namely the
    right one. What is interesting is that the right child also has a right child.
    However, the presented algorithm works properly in such conditions and you receive
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The last removal operation is the most complicated one because it requires
    you to remove the node with both children, and it also performs the role of the
    root. In such a case, the leftmost element from the right subtree of the root
    is found and replaces the node for removal, as shown in the final view of the
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'One more set of operations left—the traversal of the tree in three different
    modes: pre-order, in-order, and post-order. The application presents the following
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The created application looks quite impressive, doesn't it? You have created
    not only the implementation of the binary search tree from scratch, but also prepared
    the platform for its visualization in the console. Great job!
  prefs: []
  type: TYPE_NORMAL
- en: Let's take one more look at the results of the in-order approach. As you can
    see, it gives you the nodes sorted in the ascending order in the case of a binary
    search tree.
  prefs: []
  type: TYPE_NORMAL
- en: However, can you see a potential problem with the created solution? What about
    a scenario where you remove nodes only from the given area of the tree or when
    you insert the already-sorted values? It could mean that the fat tree, with proper
    breadth-depth ratio, could become a skinny one. In the worst case, it could even
    be depicted as a list, where all nodes have only one child. Do you have any idea
    how to solve the problem of unbalanced trees and keep them balanced all the time?
    If not, let's proceed to the next sections, where two variants of self-balancing
    trees are presented.
  prefs: []
  type: TYPE_NORMAL
- en: AVL trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will get to know one of the variants of **self-balancing
    trees**, which keeps the tree balanced all the time while adding and removing
    nodes. However, why is it so important? As already mentioned, the performance
    of the lookup time depends on the shape of the tree. In the case of improper organization
    of nodes, forming a list, the process of searching for a given value can be the
    *O(n)* operation. With a correctly arranged tree, the performance can be significantly
    improved to *O(log n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you know that a BST can very easily become an **unbalanced tree**? Let''s
    make a simple test of adding the following nine numbers to the tree, from 1 to
    9\. Then, you will receive the tree with the shape shown in the following diagram
    on the left. However, the same values can be arranged in another way, as a **balanced
    tree**, with significantly better breadth-depth ratio, which is shown on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c2951c6-4cf9-43dd-88e7-a0b612a15078.png)'
  prefs: []
  type: TYPE_IMG
- en: You know what unbalanced and balanced trees are, as well as the aim of self-balancing
    trees—but what is an AVL tree? How does it work? What rules should be taken into
    account while using this data structure?
  prefs: []
  type: TYPE_NORMAL
- en: An AVL tree is a binary search tree with the additional requirement that, for
    each node, the height of its left and right subtrees cannot differ by more than
    one. Of course, that rule must be maintained after adding and removing nodes from
    a tree. The important role is performed by **rotations**, used to fix incorrect
    arrangements of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: While talking about the AVL trees, it is also crucial to indicate the performance
    of this data structure. In this case, both average and worst-case scenarios of
    insertion, removal, and lookup are *O(log n)*, so there is significant improvement
    in the worst-case scenarios in comparison with the binary search tree.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about AVL trees at [https://en.wikipedia.org/wiki/AVL_tree](https://en.wikipedia.org/wiki/AVL_tree).
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let's proceed to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the AVL trees, including various rotations necessary to
    keep the balanced state of a tree, seems to be quite complicated. Fortunately,
    you do not need to create its implementation from scratch, because you can use
    one of the available NuGet packages, such as **Adjunct**, which will be used for
    creating our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the Adjunct library can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://adjunct.codeplex.com/](http://adjunct.codeplex.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.nuget.org/packages/adjunct-System.DataStructures.AvlTree/](https://www.nuget.org/packages/adjunct-System.DataStructures.AvlTree/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package provides developers with a few classes that can be used while creating
    C#-based applications. Let's focus on the `AvlTree` generic class, which represents
    an AVL tree. The class is very simple to use, so you do not need to know all internal
    details of the AVL trees and you can easily benefit from its advantages.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `AvlTree` class is equipped with the `Add` method, which inserts
    a new node in a proper location in the tree. You can easily remove a node using
    the `Remove` method. What is more, you can get the height for a given node by
    calling the `Height` method. It is also possible to get the balance factor for
    a given node, using `GetBalanceFactor`, which is calculated as the difference
    between the height of the left and right subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: Another important class is `AvlTreeNode`. It implements the `IBinaryTreeNode`
    interface and contains four properties representing the height of the node (`Height`),
    references to the left and right nodes (`Left` and `Right`, respectively), as
    well as the value stored in the node (`Value`) with a type specified while creating
    an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Example – keep the tree balanced
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction to the topic of AVL trees, there is a very
    simple test that can cause a BST tree to become unbalanced. You can just add ordered
    numbers to create a long and skinny tree. So, let's try to create an example of
    adding exactly the same set of data to an AVL tree, implemented using the `Adjunct`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code placed in the `Main` method in the `Program` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, a new instance of the `AvlTree` class is created with indication
    that nodes will store integer values. Then, the `for` loop is used to add the
    following numbers (from 1 to 9) to the tree, using the `Add` method. After execution
    of the loop, the tree should contain 9 nodes, arranged according to the rules
    of AVL trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, you can traverse the tree using the regular methods: the in-order
    (`GetInorderEnumerator`), post-order (`GetPostorderEnumerator`), and breadth-first
    (`GetBreadthFirstEnumerator`) approaches. You have already learned about the first
    two, but what is **breadth-first traversal**? Its aim is to first visit all nodes
    on the same depth and then proceed to the next depth, until the maximum depth
    is reached.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will receive the following results for the
    traversals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of code shows the lookup feature of the AVL tree, using the `FindNode`
    method. It is used to get the `AvlTreeNode` instance representing a node with
    the given value. Then, you can easily get various data regarding the node, such
    as its height, as well as the values of left and right children, using the properties
    of the `AvlTreeNode` class. The part of the console output regarding the lookup
    feature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Easy, convenient, and without significant development effort—that quite precisely
    describes the process of applying one of the available packages to support AVL
    trees. By using it, you do not need to prepare complex code on your own and the
    number of possible problems can be significantly limited.
  prefs: []
  type: TYPE_NORMAL
- en: Red-black trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **Red-black tree**, also referred to as an **RBT**, is the next variant of
    the self-balancing binary search trees. As a variant of BSTs, this data structure
    requires that the standard BST rules be maintained. Moreover, the following rules
    must be taken into account:'
  prefs: []
  type: TYPE_NORMAL
- en: Each node must be colored either red or black. Thus, you need to add additional
    data for a node that stores a color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All nodes with values cannot be leaf nodes. For this reason, the NIL pseudo-nodes
    should be used as leaves in the tree, while all other nodes are internal ones.
    Moreover, all NIL pseudo-nodes must be black.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a node is red, both its children must be black.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any node, the number of black nodes on the route to a descendant leaf (that
    is, the NIL pseudo-node) must be the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The proper RBT is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/897476a0-63da-4e1d-9ae4-d1330f1566d1.png)'
  prefs: []
  type: TYPE_IMG
- en: The tree consists of nine nodes, each colored red or black. It is worth mentioning
    the NIL pseudo-nodes, which are added as leaf nodes. If you again take a look
    at the set of rules listed afore, you can confirm that all such rules are maintained
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to AVL trees, RBTs also must maintain the rules after adding or removing
    a node. In this case, the process of restoring the RBT properties is even more
    complicated, because it involves both **recoloring** and **rotations**. Fortunately,
    you do not need to know and understand the internal details, which are quite complex,
    to benefit from this data structure and apply it in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: While talking about this variant of self-balancing BSTs, it is also worth noting
    the performance. In both average and worst-case scenarios, insertion, removal,
    and lookup are *O(log n)* operations, so they are the same as in the case of the
    AVL trees and much better in worst-case scenarios in comparison with the BSTs.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about RBTs at [https://en.wikipedia.org/wiki/Red-black_tree](https://en.wikipedia.org/wiki/Red-black_tree).
  prefs: []
  type: TYPE_NORMAL
- en: You have already learned some basic information about RBTs, so let's proceed
    to the implementation using one of the available libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to use an RBT in your application, you can either implement it from
    scratch or use one of the available libraries, such as `TreeLib`, which you can
    easily install using the NuGet Package Manager. This library supports a few kinds
    of trees, among which the RBTs exist.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the library at [http://programmatom.github.io/TreeLib/](http://programmatom.github.io/TreeLib/)
    and [https://www.nuget.org/packages/TreeLib](https://www.nuget.org/packages/TreeLib).
  prefs: []
  type: TYPE_NORMAL
- en: As the library provides developers with many classes, it is a good idea to take
    a look at those related to RBTs. The first class is named `RedBlackTreeList` and
    represents an RBT. It is a generic class, so you can easily specify a type of
    data stored in each node.
  prefs: []
  type: TYPE_NORMAL
- en: The class contains a set of methods, including `Add` for inserting a new element
    to the tree, `Remove` for deleting a node with a particular value, `ContainsKey`
    for checking whether the tree contains a given value, and `Greatest` and `Least`
    for returning the maximum and minimum values stored in the tree. Moreover, the
    class is equipped with a few variants of iterating through the nodes, including
    the enumerator.
  prefs: []
  type: TYPE_NORMAL
- en: Example – RBT-related features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the case of AVL trees, let's prepare the example for RBTs, using the external
    library. The simple program will show how to create a new tree, add elements,
    remove a particular node, and benefit from other features of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following fragments of the code, which should be
    added to the `Main` method in the `Program` class. The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, a new instance of the `RedBlackTreeList` class is created. It is indicated
    that the nodes will store integer values. Then, the `for` loop is used to add
    10 numbers (ordered from 1 to 10) to the tree, using the `Add` method. After execution,
    the properly-arranged RBT with 10 elements should be ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next line, the `Remove` method is used to delete the node with the value
    equal to 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code check whether the tree contains a node with the
    value equal to `5`. The returned Boolean value is then used to present the message
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the code shows how to use the `Count` property, as well as
    the `Greatest` and `Least` methods. Such features allow the calculation of the
    total number of elements in the tree, as well as the minimum and maximum values
    stored within it. The relevant lines of code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'While using a tree data structure, you could need some way of getting values
    of nodes. You can achieve this goal using the `GetEnumerable` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of iterating through nodes in the tree involves the `foreach` loop,
    as presented in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, using the `TreeLib` library is really simple and you can add
    it to your application in just a few minutes. However, what is the result shown
    in the console after launching the program? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that `TreeLib` is not the only package that supports RBTs,
    so it is a good idea to take a look at various solutions and choose the one that
    the best suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: You have reached the end of the part of the chapter regarding self-balancing
    binary search trees. Now, let's proceed to the last part, which is related to
    heaps. What are they and why are they located in the chapter about trees? You
    will learn answers to these and many other questions very soon!
  prefs: []
  type: TYPE_NORMAL
- en: Binary heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **heap** is another variant of a tree, which exists in two versions: **min-heap**
    and **max-heap**. For each of them, an additional property must be satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For min-heap**: The value of each node must be greater than or equal to the
    value of its parent node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For max-heap**: The value of each node must be less than or equal to the
    value of its parent node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules perform a very important role, because they dictate that the root
    node always contains the smallest (in the min-heap) or the largest (in the max-heap)
    value. For this reason, it is a convenient data structure for implementing a priority
    queue, described in [Chapter 3](c0fd3ad7-ebfd-4df4-ae4a-fda9573a2b40.xhtml), *Stacks
    and Queues*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Heaps come in many variants, including **binary heaps**, which are the topic
    of this section. In this case, a heap must comply to one of the previously-mentioned
    rules (depending on the kind: min-heap or max-heap) and it must adhere to the
    **complete binary tree** rule, which requires that each node cannot contain more
    than two children, as well as all levels of a tree must be fully filled, except
    the last one, which must be filled from left to right and can have some empty
    space on the right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following two binary heaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57b79610-a0d6-41ec-beea-325932ddc8fa.png)'
  prefs: []
  type: TYPE_IMG
- en: You can easily check whether both heaps adhere to all the rules. As an example,
    let's verify the heap property for the node with value equal to **20** from the
    min-heap variant (shown on the left). The node has two children with values **35**
    and **50**, which are both greater than **20**. In the same way, you can check
    the remaining nodes in the heap. The binary tree rule is also maintained, as each
    node contains at most two children. The last requirement is that each level of
    the tree is fully filled, except the last one which does not need to be fully
    filled, but must contain nodes from left to right. In the min-heap example, three
    levels are fully filled (with one, two, and four nodes), while the last level
    contains two nodes (**25** and **70**), placed on the two leftmost positions.
    In the same way, you can confirm that the max-heap (shown on the right) is configured
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this short introduction to the topic of heaps, and especially
    to binary heaps, it is worth mentioning the broad range of applications. As already
    mentioned, this data structure is a convenient way of implementing the priority
    queue with the operation of inserting a new value and removing the smallest (in
    the min-heap) or the largest value (in the max-heap). Moreover, a heap is used
    in the heap sort algorithm, which is described in the example that follows. The
    data structure has also many other applications, such as in graph algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about binary heaps at [https://en.wikipedia.org/wiki/Binary_heap](https://en.wikipedia.org/wiki/Binary_heap).
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to take a look at the implementation of heaps? If so, let's proceed
    to the next section, where one of the available libraries supporting heaps is
    presented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary heap can be implemented either from scratch or you can use some of
    the already-available implementations. One of the solutions is named `Hippie`
    and can be installed to the project using the NuGet Package Manager. The library
    contains implementation of a few variants of heaps, including binary, binomial,
    and Fibonacci heaps, which are presented and described in this chapter of the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the library at [https://github.com/pomma89/Hippie](https://github.com/pomma89/Hippie)
    and [https://www.nuget.org/packages/Hippie](https://www.nuget.org/packages/Hippie).
  prefs: []
  type: TYPE_NORMAL
- en: 'The library contains a few classes, such as the `MultiHeap` generic class,
    which is common for various variants of heaps, including binary ones. However,
    if the same class is used for binary, binomial, and Fibonacci heaps, how can you
    choose which type of heap you want to use? You can use the static methods from
    the `HeapFactory` class to solve this problem. As an example, a binary heap can
    be created using the `NewBinaryHeap` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `MultiHeap` class is equipped with a few properties, such as `Count` for
    getting the total number of elements in the heap and `Min` for retrieving the
    minimum value. Moreover, the available methods allow adding a new element (`Add`),
    removing a particular item (`Remove`), removing the minimum value (`RemoveMin`),
    removing all elements (`Clear`), checking whether the given value exists in the
    heap (`Contains`), and merging two heaps (`Merge`).
  prefs: []
  type: TYPE_NORMAL
- en: Example – heap sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example of the binary heap, implemented using the `Hippie` library, the
    heap sort algorithm is presented and described below. The C#-based implementation,
    which should be added to the `Main` method in the `Program` class, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the implementation is very simple and short. At the beginning,
    you create a list with unsorted integer values as the input for the algorithm.
    Then, a new binary heap is prepared and you add each input value to the heap.
    At this stage, the elements from the input list are written in the console.
  prefs: []
  type: TYPE_NORMAL
- en: In the following part of the code, a new list is created. It will contain the
    sorted values and therefore it will contain the result of the algorithm. Then,
    the `while` loop is used to remove the minimum value from the heap in each iteration.
    The loop is executed until there are no elements in the heap. At the end, the
    sorted list is shown in the console.
  prefs: []
  type: TYPE_NORMAL
- en: The heap sort algorithm has *O(n * log(n))* time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build the project and run the application, you will see the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As already mentioned, binary heaps are not the only variant of heaps. Among
    others, a binomial heap is one of the very interesting approaches, which is the
    topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Binomial heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another kind of heap is a **binomial heap**. This data structure consists of
    a set of **binomial trees** with different orders. The binomial tree with order
    *0* is just a single node. You can construct the tree with order *n* using two
    binomial trees with order *n-1*. One of them should be attached as the left-most
    child of the parent of the first tree. It does sound a bit complicated, but the
    following diagram should remove any confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d4e9b3e-b52d-44ad-a437-08ea02ad2aa7.png)'
  prefs: []
  type: TYPE_IMG
- en: As already mentioned, the binomial tree with order **0** is only a single node,
    as shown on the left. The tree with order **1** consists of two trees with order
    **0** (marked with the dashed border) connected to each other. In the case of
    the tree with order **2**, two trees with order **1** are used. The second is
    attached as the left-most child of the parent of the first tree. In the same way,
    you can configure the binomial trees with the following orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, how can you know how many binomial trees should be located in the
    binomial heap, as well as how many nodes should they contain? The answer could
    be a bit surprising, because you need to prepare the binary representation of
    the number of nodes. As an example, let''s create a binomial heap with **13**
    elements. The number **13** has the following binary representation: **1101**,
    namely *1*2⁰ + 0*2¹ + 1*2² + 1*2³*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to get zero-based positions of the set bits, that is, **0**, **2**,
    and **3** in this example. Such positions indicate orders of binomial trees that
    should be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7fc557-a3a4-4140-a694-2fff25163a83.png)'
  prefs: []
  type: TYPE_IMG
- en: Moreover, there cannot be more than one binomial tree with the same order (such
    as two trees with order **2**) in the binomial heap. Is it also worth noting that
    each binomial tree must maintain the min-heap property.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about binomial heaps at [https://en.wikipedia.org/wiki/Binomial_heap](https://en.wikipedia.org/wiki/Binomial_heap).
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the binomial heap is significantly more complicated than
    the binary heap. For this reason, it may be a good idea to use one of the available
    implementations instead of writing your own from scratch. As stated in the case
    of binary heaps, the `Hippie` library is a solution that supports various variants
    of heaps, including binomial.
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be surprising, but the only difference in the code, in comparison
    with the example of the binary heap, is modification of the line where a new instance
    of the `MultiHeap` class is created. For supporting a binomial heap, you need
    to use the `NewBinomialHeap` method from the `HeapFactory` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: No more changes are necessary! Now you can perform the remaining operations,
    such as insertion or removal of elements, in the exact same way as in the case
    of the binary heap.
  prefs: []
  type: TYPE_NORMAL
- en: You have already learned about two kinds of heaps, namely binary and binomial
    ones. In the next section, the Fibonacci heap is briefly described.
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Fibonacci heap** is an interesting variant of heaps, which in some ways
    is similar to a binomial heap. First of all, it also consists of many trees, but
    there are no constraints regarding the shape of each tree, so it is much more
    flexible than the binomial heap. Moreover, it is allowed to have more than one
    tree with exactly the same shape in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a Fibonacci heap is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ebf3b19-9827-4b21-b359-3ed027961a35.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the important assumptions is that each tree is a min-heap. Thus, the
    minimum value in the whole Fibonacci heap is certainly a root node in one of the
    trees. Moreover, the presented data structure supports performing various operations
    in the *lazy* way. That means that it does not perform additional complex operations
    unless it is really necessary. For example, it can add a new node just as a new
    tree with only one node.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Fibonacci heaps at [https://en.wikipedia.org/wiki/Fibonacci_heap](https://en.wikipedia.org/wiki/Fibonacci_heap).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the binomial heap, the implementation of the Fibonacci heap is
    also not a trivial task and requires good understanding of the internal details
    of this data structure. For this reason, if you need to use Fibonacci heaps in
    your application, it may be a good idea to use one of the available implementations
    instead of writing your own from scratch. As stated previously, the `Hippie` library
    is a solution that supports many variants of heaps, including Fibonacci ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that the only difference in the code, in comparison
    with the binary and binomial heaps, is modification of the line where a new instance
    of the `MultiHeap` class is created. For supporting a Fibonacci heap, you need
    to use the `NewFibonacciHeap` method from the `HeapFactory` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: That's all! You have just read a brief introduction to the topic of Fibonacci
    heaps, as another variant of a heap and, therefore, another kind of a tree. That
    was the last subject in this chapter, so it is time to proceed to the summary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current chapter is the longest so far in the book. However, it contains
    a lot of information about variants of trees. Such data structures perform very
    important role in many algorithms and it is good to learn more about them, as
    well as to know how to use them in your applications. For this reason, this chapter
    contains not only short theoretical introductions, but also diagrams, explanations,
    and code samples.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, the concept of a tree was described. As a reminder, a tree
    consists of nodes, including one root. The root does not contain a parent node,
    while all other nodes do. Each node can have any number of child nodes. The child
    nodes of the same node can be named siblings, while a node without children is
    named a leaf.
  prefs: []
  type: TYPE_NORMAL
- en: Various variants of trees follow this structure. The first one described in
    the chapter is a binary tree. In this case, a node can contain at most two children.
    However, the rules for BSTs are even more strict. For any node in such trees,
    the values of all nodes in its left subtree must be smaller than the value of
    the node, while the values of all nodes in its right subtree must be greater than
    the value of the node. BSTs have a very broad range of applications and provide
    developers with significant improvements of the lookup performance. Unfortunately,
    it is possible to easily make a tree unbalanced while adding sorted values to
    the tree. Therefore, the positive impact on the performance can be limited.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you can use some kind of self-balancing tree, which
    remains balanced all the time while adding or removing nodes. In this chapter,
    two variants of self-balancing trees were presented: AVL trees and RBTs. The first
    kind has the additional requirement that, for each node, the height of its left
    and right subtrees cannot differ by more than one. The RBT is a bit more complex,
    because it introduces the concept of coloring nodes, either to red or black, as
    well as the NIL pseudo-nodes. Moreover, it is required that if a node is red,
    both its children must be black, and for any node, the number of black nodes on
    the route to a descendant leaf must be the same. As you have seen while analyzing
    such data structures, their implementation is significantly more difficult. Thus,
    the additional libraries, available to download using the NuGet Package Manager,
    were presented.'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the chapter was related to heaps. As a reminder, a heap
    is another variant of a tree, which exists in two versions, min-heap and max-heap.
    It is worth noting that the value of each node must be greater than or equal to
    (for min-heaps) or less than or equal to (for max-heaps) the value of its parent
    node. The heaps exist in many variants, including binary, binomial, and Fibonacci
    ones. All of these kinds were briefly presented in the chapter, together with
    information about using the implementation from one of the NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed to graphs, which are the subject of the next chapter!
  prefs: []
  type: TYPE_NORMAL
