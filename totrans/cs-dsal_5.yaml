- en: Variants of Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you have learned about many data structures, starting
    with simple ones, such as arrays. Now, it is time for you to get to know a significantly
    more complex group of data structures, namely **trees**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, the basic tree will be presented, together
    with its implementation in the C# language and some examples showing it in action.
    Then, the binary tree will be introduced with a detailed description of its implementation
    and an example of its application. The binary search tree is another tree variant,
    which is one of the most popular types of trees, used in many algorithms. The
    following two sections will cover self-balancing trees, namely AVL and red-black
    trees.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining part of the chapter is dedicated to heaps as tree-based data
    structures. Three kinds of heaps will be presented: binary, binomial, and Fibonacci.
    Such types will be briefly introduced, and the application of these data structures
    will be shown, using the external package.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Arrays, lists, stacks, queues, dictionaries, sets, and now... trees. Are you
    ready to increase the level of difficulty and learn the next set of data structures?
    If so, let's start reading!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Basic trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AVL trees
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red-black trees
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary heaps
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binomial heaps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fibonacci heaps
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic trees
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with introducing trees. What are they? Do you have any ideas about
    how such a data structure should look? If not, let''s take a look at the following
    diagram, which depicts a tree with captions regarding its particular elements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c15bf17-435a-40a2-a6ab-3b2768d96d92.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: A tree consists of multiple **nodes**, including one **root** (**100** in the
    diagram). The root does not contain a **parent** node, while all other nodes do.
    For example, the parent element of node **1** is **100**, while node **96** has
    node **30** as the **parent**. Moreover, each node can have any number of **child**
    nodes, such as three **children** (that is, **50**, **1**, and **150**) in the
    case of the **root**. The child nodes of the same node can be named **siblings**,
    as in the case of nodes **70** and **61**. A node without children is named a **leaf**,
    such as **45** and **6** in the diagram. Take a look at the rectangle with three
    nodes (that is, **30**, **96**, and **9**). Such a part of the tree can be called
    a **subtree**. Of course, you can find many subtrees in the tree.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly talk about the minimum and maximum numbers of children of a node.
    In general, such numbers are not limited and each node can contain zero, one,
    two, three, or even more children. However, in practical applications, the number
    of children is often limited to two, as you will see in the following section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C#-based implementation of a basic tree seems to be quite obvious and not
    complicated. To do so, you can declare two classes, representing a single node
    and a whole tree, as described in the following section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Node
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first class is named `TreeNode` and is declared as the generic class to
    provide a developer with the ability to specify the type of data stored in each
    node. Thus, you can create the strongly-typed solution, which eliminates the necessity
    of casting objects to target types. The code is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The class contains three properties: the data stored in the node (`Data`) of
    the type (`T`) specified while creating an instance of the class, a reference
    to the parent node (`Parent`), and a collection of references to child nodes (`Children`).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the properties, the `TreeNode` class contains the `GetHeight` method,
    which returns a height of the node, that is, the distance to the root node. The
    implementation of this method is very simple, because it just uses the `while`
    loop to go up from the node until there is no parent element (when the root is
    reached).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Tree
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next necessary class is named `Tree`, and it represents the whole tree.
    Its code is even simpler than that presented in the preceding section, and is
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class contains only one property, `Root`. You can use this property to get
    access to the root node, and then you can use its `Children` property to obtain
    data of other nodes located in the tree.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that both `TreeNode` and `Tree` classes are generic and the
    same type is used in the case of these classes. For instance, if tree nodes should
    store `string` values, the `string` type should be used in the case of instances
    of `Tree` and `TreeNode` classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Example – hierarchy of identifiers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you want to see how to use a tree in a C#-based application? Let's take a
    look at the first example. The aim is to construct the tree with a few nodes,
    as shown in the following diagram. Only the group of nodes with darker backgrounds
    will be presented in the code. However, it is a good idea to adjust the code to
    extend this tree by yourself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6afd0e1c-87c6-4057-a278-d08277502586.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the example, each node stores an integer value. Thus, `int`
    will be the type used for both `Tree` and `TreeNode` classes. The following part
    of code should be placed in the `Main` method in the `Program` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code looks quite simple, doesn't it?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, a new instance of the `Tree` class is created. Then, the root
    node is configured by creating a new instance of the `TreeNode` class, setting
    a value of the `Data` property (to `100`), and assigning a reference to the `TreeNode`
    instance to the `Root` property.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines, the child nodes of the root node are specified—nodes
    with values equal to `50`, `1`, and `150`. For each of them, a value of the `Parent`
    property is set to a reference to the previously-added root node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the code shows how to add a child node for a given node,
    namely for the third child of the root node, that is, the node with value equal
    to `150`. Here, only one node is added, the one with the value set to `30`. Of
    course, you need to specify a reference to the parent node as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: That's all! You have created the first program that uses trees. Now you can
    run it, but you will not see any output in the console. If you want to see how
    data of nodes are organized, you can debug the program and see values of variables
    while debugging.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Example – company structure
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, you saw how to use integer values as data for each
    node in a tree. However, it is also possible to store instances of user-defined
    classes in nodes. In this example, you will see how to create a tree presenting
    the structure of a company, divided into three main departments: development,
    research, and sales.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Within each department there can be another structure, such as in the case of
    the development team. Here, **John Smith** is **Head of Development**. He is a
    boss for **Chris Morris**, who is a manager for two junior developers, **Eric
    Green** and **Ashley Lopez**. The latter is also a supervisor of **Emily Young**,
    who is a **Developer Intern**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'An example tree is shown in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d22420a3-eabe-4864-abeb-a7c8eeb5b16b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, each node should store more information than just an integer
    value. There should be an identifier, a name, and a role. Such data are stored
    as values of properties in an instance of the `Person` class, as shown in the
    following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The class contains three properties ( `Id`, `Name`, and `Role`), as well as
    two constructors. The first constructor does not take any parameters, while the
    other takes three and sets values of particular properties.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from creating a new class, it is also necessary to add some code in the
    `Main` method in the `Program` class. The necessary lines are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the first line, a new instance of the `Tree` class is created. It is worth
    mentioning that the `Person` class is used as a type specified while creating
    new instances of `Tree` and `TreeNode` classes. Thus, you can easily store more
    than one simple data for each node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The remaining lines of code look similar to the first example for basic trees.
    Here, you also specify the root node (for the `CEO` role), then configure its
    child elements (`John Smith`, `Mary Fox`, and `Lily Smith`), and set a child node
    for one of the existing nodes, namely the node for the `Head of Sales`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Does it look simple and straightforward? In the next section, you will see
    a more restricted, but very important and well-known, variant of trees: the binary
    tree.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Binary trees
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally speaking, each node in a basic tree can contain any number of children.
    However, in the case of **binary trees**, a node cannot contain more than two
    children. It means that it can contain zero, one, or two child nodes. Such a requirement
    has an important impact on the shape of a binary tree, as shown in the following
    two diagrams presenting binary trees:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97d1ae70-d6ba-4cba-bddc-beef55c0cba2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: As already mentioned, a node in a binary tree can contain at most two children.
    For this reason, they are referred to as the **left child** and **right child**.
    In the case of the binary tree shown on the left-hand side of the preceding diagram,
    node **21** has two children, **68** as the left child and **12** as the right
    child, while node **100** has only a left child.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you thought about how you can iterate through all the nodes in a tree?
    How can you specify an order of nodes during **traversal** of a tree? There are
    three common approaches: pre-order, in-order, and post-order, as shown in the
    following diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6203e8c5-d23c-41ca-b4ec-f7addeb54a82.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: As you can see in the diagram, there are clearly visible differences between
    the approaches. However, do you have any idea how you can apply pre-order, in-order,
    or post-order traversals for binary trees? Let's explain all of these approaches
    in detail.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: If you want to traverse a binary tree with the **pre-order** approach, you first
    need to visit the root node. Then, you visit the left child. Finally, the right
    child is visited. Of course, such a rule does not apply only to the root node,
    but to any node within a tree. For this reason, you can understand the order of
    pre-order traversal as first visiting the current node, then its left child (the
    whole left subtree using the pre-order approach recursively), and finally its
    right child (the right subtree in a similar way).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The explanation can sound a bit complicated, so let's take a look at the simple
    example regarding the tree shown on the left of the preceding diagram. First,
    the root node (that is, **1**) is visited. Then, you analyze its left child node.
    For this reason, the next visited node is the current node, **9**. The next step
    is the pre-order traversal of its left child. Thus, **5** is visited. As this
    node does not contain any children, you can return to the stage of traversing
    when **9** is the current node. It has already been visited, as has its left child
    node, so it is time to proceed to its right child. Here, you first visit the current
    node, **6**, and follow to its left child, **3**. You can apply the same rules
    to continue traversing the tree. The final order is **1**, **9**, **5**, **6**,
    **3**, **4**, **2**, **7**, **8**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'If it still sounds a bit confusing, the following diagram should remove any
    confusions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b456784-0ec6-474b-9b66-0f372d545dfb.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: The diagram presents the following steps of the pre-order traversal with additional
    indicators: **C** for the **current node**, **L** for the **left child**, and
    **R** for the **right child**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The second traversal mode is called **in-order**. It differs from the pre-order
    approach in the order that nodes are visited in: first the left child, then the
    current node, and then the right child. If you take a look at the example shown
    in the diagram with all three traversal modes, you can see that the first visited
    node is **5**. Why? At the beginning, the root node is analyzed, but it is not
    visited, because the in-order traversal starts with the left child node. Thus,
    it analyzes node **9**, but it also has a left child, **5**, so you proceed to
    this node. As this node does not have any children, the current node (**5**) is
    visited. Then, you return to the step when the current node is **9** and—as its
    left child has been already visited—you visit also the current node. Next, you
    follow to the right child, but it has a left child, **3**, which should be visited
    first. According to the same rules, you visit the remaining nodes in the binary
    tree. The final order is **5**, **9**, **3**, **6**, **1**, **4**, **7**, **8**, **2**.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The last traversal mode is named **post-order** and supports the following
    order of node traversal: the left child, the right child, then the current node.
    Let''s analyze the post-order example shown on the right side of the diagram.
    At the beginning, the root node is analyzed, but it is not visited, because the
    post-order traversal starts with the left child node. Thus—as in the case of the
    in-order approach—you proceed to node **9**, then **5**. Then, you need to analyze
    the right child of node **9**. However, node **6** has the left child (**3**),
    which should be visited first. For this reason, after **5**, you visit **3**,
    and then **6**, followed by **9**. What is interesting is that the root node of
    the binary tree is visited at the end. The final order is **5**, **3**, **6**,
    **9**, **8**, **7**, **2**, **4**, **1**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about binary trees at [https://en.wikipedia.org/wiki/Binary_tree](https://en.wikipedia.org/wiki/Binary_tree).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let's proceed to the C#-based implementation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of a binary tree is really simple, especially if you use
    the already-described code for the basic tree. For your convenience, the whole
    necessary code is placed in the following sections, but only its new parts are
    explained in detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Node
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A node in a binary tree is represented by an instance of `BinaryTreeNode`,
    which inherits from the `TreeNode` generic class with the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `BinaryTreeNode` class, it is necessary to declare two properties, `Left`
    and `Right`, which represent both possible children of a node. The relevant part
    of code is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Moreover, you need to ensure that the collection of child nodes contains exactly
    two items, initially set to `null`. You can achieve this goal by assigning a default
    value to the `Children` property in the constructor, as shown in the preceding
    code. Thus, if you want to add a child node, a reference to it should be placed
    as the first or the second element of the list (the `Children` property). Therefore,
    such a collection always has exactly two elements and you can access the first
    or the second element without any exception. If it is set to any node, a reference
    to it is returned, otherwise `null` is returned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Tree
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next necessary class is named `BinaryTree`. It represents the whole binary
    tree. By using the generic class, you can easily specify a type of data stored
    in each node. The first part of the implementation of the `BinaryTree` class is
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `BinaryTree` class contains two properties: `Root`, which indicates the
    root node (as an instance of the `BinaryTreeNode` class), as well as `Count`,
    which has the total number of nodes placed in the tree. Of course, these are not
    the only members of the class, because it can also be equipped with a set of methods
    regarding traversing the tree.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The first traversal method, described in this book, is pre-order. As a reminder,
    it first visits the current node, then its left child, followed by the right child.
    The code of the `TraversePreOrder` method is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The method takes two parameters: the current node (`node`) and the list of
    already-visited nodes (`result`). The recursive implementation is very simple.
    First, you check whether the node exists by ensuring that the parameter is not
    equal to `null`. Then, you add the current node to the collection of visited nodes,
    start the same traversal method for the left child, and—at the end—start it for
    the right child.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar implementation is possible for the in-order and post-order traversal
    modes. Let''s start with the code of the `TraverseInOrder` method, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you recursively call the `TraverseInOrder` method for the left child,
    add the current node to the list of visited nodes, and start the in-order traversal
    for the right child.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is related to the post-order traversal mode, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code is very similar to the already-described methods, but, of course, another
    order of visiting nodes is applied. Here, you start with the left child, then
    you visit the right child, followed by the current node.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add the public method for traversing the tree in various modes,
    which calls private methods presented earlier. The relevant code is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The method takes only one parameter, a value of the `TraversalEnum` enumeration,
    which chooses the proper mode from pre-order, in-order, and post-order. The `Traverse`
    method uses the `switch` statement to call a suitable private method, depending
    on a value of the parameter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'For using the `Traverse` method, it is also necessary to declare the `TraversalEnum`
    enumeration, as shown in the following code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last method described in this section is `GetHeight`. It returns the height
    of the tree, which can be understood as the maximum number of steps to travel
    from any leaf node to the root. The implementation is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code just iterates through all nodes of the tree using the pre-order traversal,
    reads the height for the current node (using the `GetHeight` method from the `TreeNode`
    class, described earlier), and saves it as the maximum one, if it is larger than
    the current maximum value. At the end, the calculated height is returned.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: After the introduction to the topic of binary trees, let's see an example where
    this data structure is used for storing questions and answers in a simple quiz.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Example – simple quiz
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example of a binary tree, a simple quiz application will be used. The
    quiz consists of a few questions and answers, shown depending on the previously-taken
    decisions. The application presents the question, waits until the user presses
    *Y* (yes) or *N* (no), and proceeds to the next question or shows the answer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the quiz is created in the form of a binary tree, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2679026d-3aac-4d4d-8868-2b46f7dfbe2f.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: At the beginning, the user is asked whether he or she has any experience in
    application development. If so, the program asks whether he or she has worked
    as a developer for more than five years. In the case of a positive answer, the
    result regarding applying to work as a senior developer is presented. Of course,
    other answers and questions are shown in the case of different decisions taken
    by the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the simple quiz requires the `BinaryTree` and `BinaryTreeNode`
    classes, which were presented and explained earlier. Apart from them, you should
    declare the `QuizItem` class to represent a single item, such as a question or
    an answer. Each item contains only the textual content, stored as a value of the
    `Text` property. The proper implementation is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some modifications are necessary in the `Program` class. Let''s take a look
    at the modified `Main` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first line within the method, the `GetTree` method (shown in the following
    code snippet) is called to construct the tree with questions and answers. Then,
    the root node is taken as the current node, for which the following operations
    are taken until the answer is reached.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中的第一行，调用`GetTree`方法（如下面的代码片段所示）来构建具有问题和答案的树。然后，将根节点作为当前节点，直到到达答案为止。
- en: At the beginning, you check whether the left or right child node exists, that
    is, whether it is a question (not an answer). Then, the textual content is written
    in the console and the program waits until the user presses a key. If it is equal
    to *Y*, the information about choosing the *yes* option is shown and the current
    node's left child is used as the current node. Similar operations are performed
    in the case of choosing *no*, but then the current node's right child is used
    instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查左侧或右侧子节点是否存在，即是否为问题（而不是答案）。然后，在控制台中写入文本内容，并等待用户按键。如果等于*Y*，则显示有关选择*是*选项的信息，并使用当前节点的左子节点作为当前节点。在选择*否*的情况下执行类似的操作，但然后使用当前节点的右子节点。
- en: When decisions taken by the user cause the answer to be shown, it is presented
    in the console and `null` is assigned to the `node` variable. Therefore, you break
    out of the `while` loop.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户做出的决定导致答案显示时，它会在控制台中呈现，并将`null`赋给`node`变量。因此，您会跳出`while`循环。
- en: 'As mentioned, the `GetTree` method is used to construct the binary tree with
    questions and answers. Its code is presented as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`GetTree`方法用于构建具有问题和答案的二叉树。其代码如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At the beginning, a new instance of the `BinaryTree` generic class is created.
    It is also configured that each node contains data as an instance of the `QuizItem`
    class. Then, you assign a new instance of the `BinaryTreeNode` to the `Root` property.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`BinaryTree`泛型类的新实例。还配置每个节点包含`QuizItem`类的实例的数据。然后，将`Root`属性分配给`BinaryTreeNode`的新实例。
- en: What is interesting is that even while creating questions and answers programmatically,
    you create some kind of tree-like structure, because you use the `Children` property
    and specify items directly within such constructions. Therefore, you do not need
    to create many local variables for all questions and answers. It is worth noting
    that a question-related node is an instance of the `BinaryTreeNode` class with
    two child nodes (for  *yes* and *no* decisions), while an answer-related node
    cannot contain any child nodes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，即使在以编程方式创建问题和答案时，您也会创建某种类似树的结构，因为您使用`Children`属性并直接在这些结构中指定项目。因此，您无需为所有问题和答案创建许多本地变量。值得注意的是，与问题相关的节点是`BinaryTreeNode`类的实例，具有两个子节点（用于*是*和*否*决定），而与答案相关的节点不能包含任何子节点。
- en: In the presented solution, the values of the `Parent` property of the `BinaryTreeNode`
    instances are not set. If you want to use them or get the height of a node or
    a tree, you should set them on your own.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在所提供的解决方案中，`BinaryTreeNode`实例的`Parent`属性的值未设置。如果要使用它们或获取节点或树的高度，则应自行设置它们。
- en: 'The last auxiliary method is `WriteAnswer`, with the code being as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个辅助方法是`WriteAnswer`，代码如下：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The method just presents the text, passed as the parameter, in the white color
    in the console. It is used to show decisions taken by the user and the textual
    content of the answer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是在控制台中以白色显示传递的文本参数。它用于显示用户做出的决定和答案的文本内容。
- en: The simple quiz application is ready! You can build the project, launch it,
    and answer a few questions to see the results. Then, let's close the program and
    proceed to the next section, where a variant of the binary tree data structure
    is presented.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的测验应用程序已准备就绪！您可以构建项目，启动它，并回答一些问题以查看结果。然后，让我们关闭程序并继续到下一部分，介绍二叉树数据结构的变体。
- en: Binary search trees
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'A binary tree is an interesting data structure that allows creating a hierarchy
    of elements, with the restriction that each node can contain at most two children,
    but without any rules about relationships between the nodes. For this reason,
    if you want to check whether the binary tree contains a given value, you need
    to check each node, traversing the tree using one of three available modes: pre-order,
    in-order, or post-order. This means that the lookup time is linear, namely *O(n)*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是一种有趣的数据结构，允许创建元素的层次结构，每个节点最多可以包含两个子节点，但没有关于节点之间关系的任何规则。因此，如果要检查二叉树是否包含给定值，需要检查每个节点，使用三种可用模式之一遍历树：前序，中序或后序。这意味着查找时间是线性的，即*O(n)*。
- en: What about a situation where there are some precise rules regarding relations
    between nodes in the tree? Let's imagine a scenario where you know that the left
    subtree contains nodes with values smaller than the root's value, while the right
    subtree contains nodes with values greater than the root's value. Then, you can
    compare the searched value with the current node and decide whether you should
    continue searching in the left or right subtree. Such an approach can significantly
    limit the number of operations necessary to check whether the tree contains a
    given value. It seems quite interesting, doesn't it?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树中存在一些关于节点关系的明确规则呢？假设有这样一种情况，左子树包含小于根值的节点，而右子树包含大于根值的节点。然后，您可以将搜索值与当前节点进行比较，并决定是否应继续在左侧或右侧子树中搜索。这种方法可以显著限制检查树是否包含给定值所需的操作数量。这似乎很有趣，不是吗？
- en: 'This approach is applied in the **binary search tree** data structure, which
    is also referred to as **BST**. It is a kind of a binary tree that introduces
    two strict rules regarding relations between nodes in the tree. The rules states
    that for any node:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法应用于**二叉搜索树**数据结构，也称为**BST**。它是一种二叉树，引入了两个关于树中节点关系的严格规则。规则规定对于任何节点：
- en: Values of all nodes in its left subtree must be smaller than its value
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of all nodes in its right subtree must be greater than its value
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, a BST can contain two or more elements with the same value. However,
    within this book a simplified version is given, which does not accept more than
    one element with the same value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'How does it look in practice? Let''s take a look at the following diagram of
    BSTs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cf99bb5-d124-494d-a022-c15038af2e46.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: The tree shown on the left-hand side contains 12 nodes. Let's check whether
    it complies with the BST rule. You can do so by analyzing each node, except leaf
    nodes, in the tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the root node (with value **50**) that contains four descendant
    nodes in the left subtree (**40**, **30**, **45**, **43**), all smaller than **50**.
    The root node contains seven descendant nodes in the right subtree (**60**, **80**,
    **70**, **65**, **75**, **90**, **100**), all greater than **50**. That means
    that the BST rule is satisfied for the root node. If you want to check the BST
    rule for the node **80**, you will see that the values of all descendant nodes
    in the left subtree (**70**, **65**, **75**) are smaller than **80**, while the
    values in the right subtree (**90**, **100**) are greater than **80**. You should
    perform the same verification for all nodes in the tree. Similarly, you can confirm
    that the BST from the right-hand side of the diagram adheres to the rules.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'However, two such BSTs significantly differ in their topology. Both have the
    same height, but the number of nodes is different—12 and 7\. The one on the left
    seems to be fat, while the other is rather skinny. Which one is better? To answer
    to this question, let''s think about the algorithm of searching a value in the
    tree. As an example, the process of searching for the value **43** is described
    and presented in the following diagram:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32e6b37f-f619-4268-b1b6-0c81a8af6846.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: At the beginning, you take a value of the root node (that is, **50**) and check
    whether the given value (**43**) is smaller or greater. It is smaller, so you
    proceed to searching in the left subtree. Thus, you compare **43** with **40**.
    This time, the right subtree is chosen, because **43** is greater than **40**.
    Next, **43** is compared with **45** and the left subtree is chosen. Here, you
    compare **43** with **43**. Thus, the given value is found. If you take a look
    at the tree, you will see that only four comparisons are necessary and the impact
    on performance is obvious.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is clear than the shape of a tree has a great impact on
    the lookup performance. Of course, it is much better to have a fat tree with limited
    height than a skinny tree with bigger height. The performance boost is caused
    by making decisions as to whether searching should be continued in the left or
    right subtree, without the necessity of analyzing values of all nodes. If nodes
    do not have both subtrees, the positive impact on the performance will be limited.
    In the worst case, when each node contains only one child, the search time is
    even linear. However, in the ideal BST, the lookup time is the *O(log n)* operation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about BSTs at [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let's proceed to the implementation in the C#
    language. At the end, you will see the example that shows how to use this data
    structure in practice.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of a BST is more difficult than the previously-described
    variants of trees. For example, it requires you to prepare operations of insertion
    and removal of nodes from a tree, which do not break the rule regarding arrangement
    of elements in the BST. What is more, you need to introduce a mechanism for comparing
    nodes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Node
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the class representing a single node in a tree. Fortunately,
    you can use the implementation of the class already described for the binary tree
    (`BinaryTreeNode`) as a base. The modified code is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从表示树中单个节点的类开始。幸运的是，您可以使用已经描述的二叉树类（`BinaryTreeNode`）的实现作为基础。修改后的代码如下：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a BST is a variant of a binary tree, each node has a reference to its left
    and right child node (or `null` if it does not exist), as well as to the parent
    node. A node stores also a value of a given type. As you can see in the preceding
    code, two members are added to the `BinaryTreeNode` class, namely the `Parent`
    property (of the `BinaryTreeNode` type) and the `GetHeight` method. They are moved
    and adjusted from the implementation of the `TreeNode` class. Its final code is
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BST是二叉树的一种变体，每个节点都有对其左右子节点（如果不存在则为`null`）以及父节点的引用。节点还存储给定类型的值。正如您在前面的代码中所看到的，`BinaryTreeNode`类添加了两个成员，即`Parent`属性（`BinaryTreeNode`类型）和`GetHeight`方法。它们是从`TreeNode`类的实现中移动和调整的。最终代码如下：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The reason for the modification is to provide a developer with the simple way
    of accessing the parent node for a given node without casting from `TreeNode`
    to `BinaryTreeNode`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 修改的原因是为开发人员提供一种简单的方法，以便在不需要从`TreeNode`到`BinaryTreeNode`进行转换的情况下访问给定节点的父节点。
- en: Tree
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: 'The whole tree is represented by an instance of the `BinarySearchTree` class,
    which inherits from the `BinaryTree` generic class, as in the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 整个树由`BinarySearchTree`类的实例表示，该类继承自`BinaryTree`泛型类，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is worth mentioning that a type of data, stored in each node, should be comparable.
    For this reason, it has to implement the `IComparable` interface. Such a requirement
    is necessary because the algorithm needs to know the relationships between values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，每个节点中存储的数据类型应该是可比较的。因此，它必须实现`IComparable`接口。这种要求是必要的，因为算法需要了解值之间的关系。
- en: Of course, it is not the final version of the implementation of the `BinarySearchTree`
    class. You will see how to add new features, such as lookup, insertion, and removal
    of nodes, in the following sections.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是`BinarySearchTree`类实现的最终版本。在接下来的部分中，您将看到如何添加新功能，比如查找、插入和删除节点。
- en: Lookup
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找
- en: 'Let''s take a look at the `Contains` method, which checks whether the tree
    contains a node with a given value. Of course, this method takes into account
    the BST rule regarding arrangement of nodes to limit the amount of comparisons.
    The code is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Contains`方法，它检查树中是否包含具有给定值的节点。当然，此方法考虑了有关节点排列的BST规则，以限制比较的数量。代码如下：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The method takes only one parameter, the value that should be found in the tree.
    Inside the method, the `while` loop exists. Within it, the searched value is compared
    with the value of the current node. If they are equal (the comparison returns
    `0` as the result), the value is found and the `true` Boolean value is returned
    to inform that the search is completed successfully. If the searched value is
    smaller than the value of the current node, the algorithm continues searching
    in the subtree with the left child of the current node as the root. Otherwise,
    the right subtree is used instead.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只接受一个参数，即应在树中找到的值。在方法内部，存在`while`循环。在其中，将搜索的值与当前节点的值进行比较。如果它们相等（比较返回`0`作为结果），则找到该值，并返回`true`布尔值以通知搜索成功完成。如果搜索的值小于当前节点的值，则算法继续在以当前节点的左子节点为根的子树中搜索。否则，使用右子树。
- en: The `CompareTo` method is provided by implementation of the `IComparable` interface
    from the `System` namespace. Such a method makes it possible to compare values.
    If they are equal, `0` is returned. If the object on which the method is called
    is bigger than the parameter, a value higher than `0` is returned. Otherwise,
    a value lower than `0` is returned.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompareTo`方法由`System`命名空间中的`IComparable`接口的实现提供。这种方法使得比较值成为可能。如果它们相等，则返回`0`。如果调用该方法的对象大于参数，则返回大于`0`的值。否则，返回小于`0`的值。'
- en: The loop is executed until the node is found or there is no suitable child node
    to follow.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 循环执行直到找到节点或没有合适的子节点可以跟随。
- en: Insertion
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'The next necessary operation is insertion of a node into a BST. Such a task
    is a bit more complicated, because you need to find a place for adding a new element
    that will not violate the BST rules. Let''s take a look at the code of the `Add`
    method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必要的操作是将节点插入BST。这项任务有点复杂，因为您需要找到一个不会违反BST规则的新元素添加位置。让我们来看一下`Add`方法的代码：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The method takes one parameter, a value that should be added to the tree. Within
    the method, you find a parent element (using the `GetParentForNewNode` auxiliary
    method), where a new node should be added as a child. Then, a new instance of
    the `BinaryTreeNode` class is created and the values of its `Data` and `Parent`
    properties are set.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个参数，即应添加到树中的值。在方法内部，找到应将新节点添加为子节点的父元素（使用`GetParentForNewNode`辅助方法），然后创建`BinaryTreeNode`类的新实例，并设置其`Data`和`Parent`属性的值。
- en: In the following part of the method, you check whether the found parent element
    is equal to `null`. It means that there are no nodes in the tree and the new node
    should be added as the root, which is well visible in the line, where a reference
    to the node is assigned to the `Root` property. The next comparison checks whether
    the value for addition is smaller than the value of the parent node. In such a
    case, the new node should be added as the left child of the parent node. Otherwise,
    the new node is placed as the right child of the parent node. At the end, the
    number of elements stored in the tree is incremented.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the auxiliary method for finding the parent element for
    a new node:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method is named `GetParentForNewNode` and takes one parameter, the value
    of the new node. Within this method, you declare two variables representing the
    currently-analyzed node (`current`) and the parent node (`parent`). Such values
    are modified in the `while` loop until the algorithm finds a proper place for
    the new node.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the loop, you store a reference to the current node as the potential parent
    node. Then, the comparisons are performed, as in the case of the previously-described
    code snippet. First, you check whether the value for addition is equal to the
    value of the current node. If so, an exception is thrown, because it is not allowed
    to add more than one element with the same value to the analyzed version of the
    BST. If the value for addition is smaller than the value of the current node,
    the algorithm continues searching for the place for the new node in the left subtree.
    Otherwise, the right subtree of the current node is used. At the end, the value
    of the `parent` variable is returned to indicate the found location for the new
    node.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Removal
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know how to create a new BST, add some nodes to it, as well as check
    whether a given value already exists in the tree. However, can you also remove
    an item from a tree? Of course! You will learn how to achieve this goal in this
    section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The main method regarding removal of a node from the tree is named `Remove`
    and takes only one parameter, the value of the node that should be removed. The
    implementation of the `Remove` method is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, the method just calls another method, also named `Remove`.
    The implementation of this method is more complicated and is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the beginning, the method checks whether the current node (the `node` parameter)
    exists. If not, the exception is thrown. Then, the `Remove` method tries to find
    the node to remove. That is achieved by comparing the value of the current node
    with the value for removal and calling the `Remove` method recursively for either
    the left or right subtree of the current node. Such operations are performed in
    the conditional statements with conditions `data.CompareTo(node.Data) < 0` and
    `data.CompareTo(node.Data) > 0`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting operations are performed in the following part of the
    method. Here, you need to handle four scenarios of node removal, namely:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Removing a leaf node
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with only a left child
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with only a right child
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a node with both left and right children
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, you just update a reference to the deleted node in the parent
    element. Therefore, there will be no reference from the parent node to the deleted
    node and it cannot be reached while traversing the tree.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case is also simple, because you only need to replace a reference
    to the deleted node (in the parent element) with the node that is a left child
    of the deleted node. This scenario is shown in the following diagram, which presents
    how to remove node **80** with only the left child:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8d6e2e8-5b7d-4c51-a014-bcc3cc5a5750.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: The third case is very similar to the second case. Thus, you just replace a
    reference to the deleted node (in the parent element) with the node that is a
    right child of the deleted node.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'All those three cases are handled in the code in a similar way, by calling
    the auxiliary method (`ReplaceInParent`). It takes two parameters: the node for
    removal and the node that should replace it in the parent node. For this reason,
    if you want to remove a leaf node, you just pass `null` as the second parameter,
    because you do not want to replace the removed node with anything else. In the
    case of removing a node with only one child, you pass a reference to the left
    or right child. Of course, you also need to decrement the counter storing the
    number of elements located in the tree.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The related part of code is as follows (it differs for various cases):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Of course, the most complicated scenario is removal of a node with both child
    nodes. In such a case, you find a node with the minimum value in the right subtree
    of the node for removal. Then, you swap the value of the node for removal with
    the value of the found node. Finally, you just need to call the `Remove` method
    recursively for the found node. The relevant part of code is shown in the following
    code snippet:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The important role is performed by the `ReplaceInParent` auxiliary method,
    the code for which is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The method takes two parameters: the node for removal (`node`) and the node
    that should replace it in the parent node (`newNode`). If the node for removal
    is not the root, you check whether it is the left child of the parent. If so,
    a proper reference is updated, that is, the new node is set as the left child
    of the parent node of the node for removal. In a similar way, the method handles
    the scenario when the node for removal is the right child of the parent. If the
    node for removal is the root, the node for replacing is set as the root.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: At the end, you check whether the new node is not equal to `null`, that is,
    you are not removing a leaf node. In such a case, you set a value of the `Parent`
    property to indicate that the new node should have the same parent as the node
    for removal.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The last auxiliary method is named `FindMinimumInSubtree` and is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method takes only one parameter, namely the root of the subtree, where the
    minimum value should be found. Within the method, the `while` loop is used to
    get the leftmost element. When there is no left child, the current value of the
    `node` variable is returned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The presented implementation of the BST is based on the code shown at [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks quite simple, doesn''t it? However, how does it work in practice?
    Let''s take a look at a diagram depicting the removal of a node with two children:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee7545af-cf87-4982-bbd0-9c8dd810140b.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: The diagram shows how to remove the node with **40** as the value. To do so,
    you need to find the successor, that is, the node with the minimum value in the
    right subtree of the node for removal. The successor is node **42**, which replaces
    node **40**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Example – BST visualization
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While reading the part regarding the BSTs, you have learned a lot about the
    data structure. As such, it is high time to create an example program to see this
    variant of trees in action. The application will show how to create a BST, add
    some nodes (both manually and using the previously-presented method for insertion),
    remove nodes, traverse the tree, and visualize the tree in the console.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s adjust the code of the `Program` class, as shown in the following block
    of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At the beginning, a new tree (with nodes storing integer values) is prepared
    by creating a new instance of the `BinarySearchTree` class. It is configured manually
    by adding three nodes, together with indicating proper references for children
    and parent elements. The relevent part of code is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you use the `Add` method to add some nodes to the tree, and visualize
    the current state of the tree using the `VisualizeTree` method, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next set of operations is related to the removal of various nodes from
    the tree, together with visualization of particular changes. The code is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the end, all three traversal modes are presented. The part of code related
    to the pre-order approach is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Another interesting task is the development of the visualization of the tree
    in the console. Such a feature is really useful, because it allows a comfortable
    and fast way of observing the tree without the necessity of debugging the application
    in the IDE and expanding the following elements in the tooltip with the current
    values of variables. However, presenting the tree in the console is not a trivial
    task. Fortunately, you do not need to worry about it, because you will learn how
    to implement such a feature in this section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the `VisualizeTree` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The method takes two parameters: an instance of the `BinarySearchTree` class
    representing the whole tree, and the caption that should be shown above the visualization.
    Within the method, the jagged array (with characters that should be presented
    in the console) is initialized using the `InitializeVisualization` auxiliary method.
    Then, you call the `VisualizeNode` recursive method to fill various parts of the
    jagged array with data regarding particular nodes existing in the tree. At the
    end, the caption and all rows from the buffer (represented by the jagged array)
    are written in the console.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The next interesting method is `InitializeVisualization`, which creates the
    afore mentioned jagged array, as presented in the following code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The jagged array contains the number of rows equal to the height of the tree
    multiplied by `2` to have space also for lines connecting nodes with parents.
    The number of columns is calculated according to the formula *width* * 2*^(height)*
    - 1, where *width* is the constant value `COLUMN_WIDTH` and *height* is the height
    of the tree. These values can be simpler to understand if you take a look at the
    result in the console:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, the jagged array has 8 elements. Each is an array with 75 elements. Of
    course, you can understand it as a screen buffer with 8 rows and 75 columns.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `VisualizeTree` method, `VisualizeNode` is called. Are you interested
    to learn about how it works and how you can present not only the values of nodes,
    but also lines? If so, let''s take a look at its code, which is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `VisualizeNode` method takes five parameters: the current node for visualization
    (`node`), the index of a row (`row`), the index of a column (`column`), the jagged
    array as the buffer (`console`), and the width (`width`). Within the method, there
    is a check for whether the current node exists. If it does, the value of the node
    is obtained as the `char` array, the margin is calculated, and the `char` array
    (with character-based representation of the value) is written in the buffer (the
    `console` variable).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines of code, the `VisualizeNode` method is called for left
    and right child nodes of the current node. Of course, you need to adjust the index
    of the row (by adding `2`) and the index of the column (by adding or subtracting
    the calculated value).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, the lines are drawn by calling the `DrawLineLeft` and `DrawLineRight`
    methods. The first is presented in the following code snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The method also takes five parameters: the current node for which the line
    should be drawn (`node`), the index of a row (`row`), the index of a column (`column`),
    the jagged array as the buffer (`console`), and the delta value calculated in
    the `VisualizeNode` method (`columnDelta`). At the beginning, you check whether
    the current node contains a left child, because only then is it necessary to draw
    the left part of the line. If so, you calculate the start and end indices of columns,
    and fill the proper elements of the jagged array with dashes. At the end, the
    plus sign is added to the jagged array in the place where the drawn line will
    be connected with the right line of another element. Moreover, the Unicode character
    ┌ (`\u250c`) is added on the other side of the line to create a user-friendly
    visualization.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'In almost the same way, you can draw the right line for the current node. Of
    course, you need to adjust the code regarding calculating column start and end
    indices, and change a character used to present changing direction of the line.
    The final version of the code of the `DrawLineRight` method is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That''s all! You have written the whole code necessary to build the project,
    launch the program, and see it in action. Just after launching, you will see the
    first BST, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After adding the next two nodes, `75` and `125`, the BST looks a bit different:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, you perform the insertion operation for the next five elements. These
    operations have a very visible impact on the tree shape, as presented in the console:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After adding 10 elements, the program shows an impact of removing a particular
    node on the shape of the tree. To start, let''s remove the leaf node with `25`
    as the value:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, the program checks removing a node with only one child node, namely the
    right one. What is interesting is that the right child also has a right child.
    However, the presented algorithm works properly in such conditions and you receive
    the following result:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The last removal operation is the most complicated one because it requires
    you to remove the node with both children, and it also performs the role of the
    root. In such a case, the leftmost element from the right subtree of the root
    is found and replaces the node for removal, as shown in the final view of the
    tree:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'One more set of operations left—the traversal of the tree in three different
    modes: pre-order, in-order, and post-order. The application presents the following
    results:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The created application looks quite impressive, doesn't it? You have created
    not only the implementation of the binary search tree from scratch, but also prepared
    the platform for its visualization in the console. Great job!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Let's take one more look at the results of the in-order approach. As you can
    see, it gives you the nodes sorted in the ascending order in the case of a binary
    search tree.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: However, can you see a potential problem with the created solution? What about
    a scenario where you remove nodes only from the given area of the tree or when
    you insert the already-sorted values? It could mean that the fat tree, with proper
    breadth-depth ratio, could become a skinny one. In the worst case, it could even
    be depicted as a list, where all nodes have only one child. Do you have any idea
    how to solve the problem of unbalanced trees and keep them balanced all the time?
    If not, let's proceed to the next sections, where two variants of self-balancing
    trees are presented.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: AVL trees
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will get to know one of the variants of **self-balancing
    trees**, which keeps the tree balanced all the time while adding and removing
    nodes. However, why is it so important? As already mentioned, the performance
    of the lookup time depends on the shape of the tree. In the case of improper organization
    of nodes, forming a list, the process of searching for a given value can be the
    *O(n)* operation. With a correctly arranged tree, the performance can be significantly
    improved to *O(log n)*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you know that a BST can very easily become an **unbalanced tree**? Let''s
    make a simple test of adding the following nine numbers to the tree, from 1 to
    9\. Then, you will receive the tree with the shape shown in the following diagram
    on the left. However, the same values can be arranged in another way, as a **balanced
    tree**, with significantly better breadth-depth ratio, which is shown on the right:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c2951c6-4cf9-43dd-88e7-a0b612a15078.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: You know what unbalanced and balanced trees are, as well as the aim of self-balancing
    trees—but what is an AVL tree? How does it work? What rules should be taken into
    account while using this data structure?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: An AVL tree is a binary search tree with the additional requirement that, for
    each node, the height of its left and right subtrees cannot differ by more than
    one. Of course, that rule must be maintained after adding and removing nodes from
    a tree. The important role is performed by **rotations**, used to fix incorrect
    arrangements of nodes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: While talking about the AVL trees, it is also crucial to indicate the performance
    of this data structure. In this case, both average and worst-case scenarios of
    insertion, removal, and lookup are *O(log n)*, so there is significant improvement
    in the worst-case scenarios in comparison with the binary search tree.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about AVL trees at [https://en.wikipedia.org/wiki/AVL_tree](https://en.wikipedia.org/wiki/AVL_tree).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let's proceed to the implementation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the AVL trees, including various rotations necessary to
    keep the balanced state of a tree, seems to be quite complicated. Fortunately,
    you do not need to create its implementation from scratch, because you can use
    one of the available NuGet packages, such as **Adjunct**, which will be used for
    creating our example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the Adjunct library can be found at:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[http://adjunct.codeplex.com/](http://adjunct.codeplex.com/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.nuget.org/packages/adjunct-System.DataStructures.AvlTree/](https://www.nuget.org/packages/adjunct-System.DataStructures.AvlTree/).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package provides developers with a few classes that can be used while creating
    C#-based applications. Let's focus on the `AvlTree` generic class, which represents
    an AVL tree. The class is very simple to use, so you do not need to know all internal
    details of the AVL trees and you can easily benefit from its advantages.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `AvlTree` class is equipped with the `Add` method, which inserts
    a new node in a proper location in the tree. You can easily remove a node using
    the `Remove` method. What is more, you can get the height for a given node by
    calling the `Height` method. It is also possible to get the balance factor for
    a given node, using `GetBalanceFactor`, which is calculated as the difference
    between the height of the left and right subtrees.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Another important class is `AvlTreeNode`. It implements the `IBinaryTreeNode`
    interface and contains four properties representing the height of the node (`Height`),
    references to the left and right nodes (`Left` and `Right`, respectively), as
    well as the value stored in the node (`Value`) with a type specified while creating
    an instance of the class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Example – keep the tree balanced
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction to the topic of AVL trees, there is a very
    simple test that can cause a BST tree to become unbalanced. You can just add ordered
    numbers to create a long and skinny tree. So, let's try to create an example of
    adding exactly the same set of data to an AVL tree, implemented using the `Adjunct`
    library.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The code placed in the `Main` method in the `Program` class is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At the beginning, a new instance of the `AvlTree` class is created with indication
    that nodes will store integer values. Then, the `for` loop is used to add the
    following numbers (from 1 to 9) to the tree, using the `Add` method. After execution
    of the loop, the tree should contain 9 nodes, arranged according to the rules
    of AVL trees.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, you can traverse the tree using the regular methods: the in-order
    (`GetInorderEnumerator`), post-order (`GetPostorderEnumerator`), and breadth-first
    (`GetBreadthFirstEnumerator`) approaches. You have already learned about the first
    two, but what is **breadth-first traversal**? Its aim is to first visit all nodes
    on the same depth and then proceed to the next depth, until the maximum depth
    is reached.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will receive the following results for the
    traversals:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last part of code shows the lookup feature of the AVL tree, using the `FindNode`
    method. It is used to get the `AvlTreeNode` instance representing a node with
    the given value. Then, you can easily get various data regarding the node, such
    as its height, as well as the values of left and right children, using the properties
    of the `AvlTreeNode` class. The part of the console output regarding the lookup
    feature is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Easy, convenient, and without significant development effort—that quite precisely
    describes the process of applying one of the available packages to support AVL
    trees. By using it, you do not need to prepare complex code on your own and the
    number of possible problems can be significantly limited.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Red-black trees
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **Red-black tree**, also referred to as an **RBT**, is the next variant of
    the self-balancing binary search trees. As a variant of BSTs, this data structure
    requires that the standard BST rules be maintained. Moreover, the following rules
    must be taken into account:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Each node must be colored either red or black. Thus, you need to add additional
    data for a node that stores a color.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All nodes with values cannot be leaf nodes. For this reason, the NIL pseudo-nodes
    should be used as leaves in the tree, while all other nodes are internal ones.
    Moreover, all NIL pseudo-nodes must be black.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a node is red, both its children must be black.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any node, the number of black nodes on the route to a descendant leaf (that
    is, the NIL pseudo-node) must be the same.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The proper RBT is presented in the following diagram:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/897476a0-63da-4e1d-9ae4-d1330f1566d1.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: The tree consists of nine nodes, each colored red or black. It is worth mentioning
    the NIL pseudo-nodes, which are added as leaf nodes. If you again take a look
    at the set of rules listed afore, you can confirm that all such rules are maintained
    in this case.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to AVL trees, RBTs also must maintain the rules after adding or removing
    a node. In this case, the process of restoring the RBT properties is even more
    complicated, because it involves both **recoloring** and **rotations**. Fortunately,
    you do not need to know and understand the internal details, which are quite complex,
    to benefit from this data structure and apply it in your projects.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: While talking about this variant of self-balancing BSTs, it is also worth noting
    the performance. In both average and worst-case scenarios, insertion, removal,
    and lookup are *O(log n)* operations, so they are the same as in the case of the
    AVL trees and much better in worst-case scenarios in comparison with the BSTs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about RBTs at [https://en.wikipedia.org/wiki/Red-black_tree](https://en.wikipedia.org/wiki/Red-black_tree).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: You have already learned some basic information about RBTs, so let's proceed
    to the implementation using one of the available libraries.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to use an RBT in your application, you can either implement it from
    scratch or use one of the available libraries, such as `TreeLib`, which you can
    easily install using the NuGet Package Manager. This library supports a few kinds
    of trees, among which the RBTs exist.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the library at [http://programmatom.github.io/TreeLib/](http://programmatom.github.io/TreeLib/)
    and [https://www.nuget.org/packages/TreeLib](https://www.nuget.org/packages/TreeLib).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: As the library provides developers with many classes, it is a good idea to take
    a look at those related to RBTs. The first class is named `RedBlackTreeList` and
    represents an RBT. It is a generic class, so you can easily specify a type of
    data stored in each node.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The class contains a set of methods, including `Add` for inserting a new element
    to the tree, `Remove` for deleting a node with a particular value, `ContainsKey`
    for checking whether the tree contains a given value, and `Greatest` and `Least`
    for returning the maximum and minimum values stored in the tree. Moreover, the
    class is equipped with a few variants of iterating through the nodes, including
    the enumerator.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Example – RBT-related features
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the case of AVL trees, let's prepare the example for RBTs, using the external
    library. The simple program will show how to create a new tree, add elements,
    remove a particular node, and benefit from other features of the library.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following fragments of the code, which should be
    added to the `Main` method in the `Program` class. The first part is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, a new instance of the `RedBlackTreeList` class is created. It is indicated
    that the nodes will store integer values. Then, the `for` loop is used to add
    10 numbers (ordered from 1 to 10) to the tree, using the `Add` method. After execution,
    the properly-arranged RBT with 10 elements should be ready.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next line, the `Remove` method is used to delete the node with the value
    equal to 9:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following lines of code check whether the tree contains a node with the
    value equal to `5`. The returned Boolean value is then used to present the message
    in the console:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next part of the code shows how to use the `Count` property, as well as
    the `Greatest` and `Least` methods. Such features allow the calculation of the
    total number of elements in the tree, as well as the minimum and maximum values
    stored within it. The relevant lines of code are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'While using a tree data structure, you could need some way of getting values
    of nodes. You can achieve this goal using the `GetEnumerable` method, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Another way of iterating through nodes in the tree involves the `foreach` loop,
    as presented in the following code snippet:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As you can see, using the `TreeLib` library is really simple and you can add
    it to your application in just a few minutes. However, what is the result shown
    in the console after launching the program? Let''s see:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is worth noting that `TreeLib` is not the only package that supports RBTs,
    so it is a good idea to take a look at various solutions and choose the one that
    the best suits your needs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: You have reached the end of the part of the chapter regarding self-balancing
    binary search trees. Now, let's proceed to the last part, which is related to
    heaps. What are they and why are they located in the chapter about trees? You
    will learn answers to these and many other questions very soon!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Binary heaps
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **heap** is another variant of a tree, which exists in two versions: **min-heap**
    and **max-heap**. For each of them, an additional property must be satisfied:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '**For min-heap**: The value of each node must be greater than or equal to the
    value of its parent node'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For max-heap**: The value of each node must be less than or equal to the
    value of its parent node'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules perform a very important role, because they dictate that the root
    node always contains the smallest (in the min-heap) or the largest (in the max-heap)
    value. For this reason, it is a convenient data structure for implementing a priority
    queue, described in [Chapter 3](c0fd3ad7-ebfd-4df4-ae4a-fda9573a2b40.xhtml), *Stacks
    and Queues*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Heaps come in many variants, including **binary heaps**, which are the topic
    of this section. In this case, a heap must comply to one of the previously-mentioned
    rules (depending on the kind: min-heap or max-heap) and it must adhere to the
    **complete binary tree** rule, which requires that each node cannot contain more
    than two children, as well as all levels of a tree must be fully filled, except
    the last one, which must be filled from left to right and can have some empty
    space on the right.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following two binary heaps:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57b79610-a0d6-41ec-beea-325932ddc8fa.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
- en: You can easily check whether both heaps adhere to all the rules. As an example,
    let's verify the heap property for the node with value equal to **20** from the
    min-heap variant (shown on the left). The node has two children with values **35**
    and **50**, which are both greater than **20**. In the same way, you can check
    the remaining nodes in the heap. The binary tree rule is also maintained, as each
    node contains at most two children. The last requirement is that each level of
    the tree is fully filled, except the last one which does not need to be fully
    filled, but must contain nodes from left to right. In the min-heap example, three
    levels are fully filled (with one, two, and four nodes), while the last level
    contains two nodes (**25** and **70**), placed on the two leftmost positions.
    In the same way, you can confirm that the max-heap (shown on the right) is configured
    properly.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this short introduction to the topic of heaps, and especially
    to binary heaps, it is worth mentioning the broad range of applications. As already
    mentioned, this data structure is a convenient way of implementing the priority
    queue with the operation of inserting a new value and removing the smallest (in
    the min-heap) or the largest value (in the max-heap). Moreover, a heap is used
    in the heap sort algorithm, which is described in the example that follows. The
    data structure has also many other applications, such as in graph algorithms.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about binary heaps at [https://en.wikipedia.org/wiki/Binary_heap](https://en.wikipedia.org/wiki/Binary_heap).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to take a look at the implementation of heaps? If so, let's proceed
    to the next section, where one of the available libraries supporting heaps is
    presented.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary heap can be implemented either from scratch or you can use some of
    the already-available implementations. One of the solutions is named `Hippie`
    and can be installed to the project using the NuGet Package Manager. The library
    contains implementation of a few variants of heaps, including binary, binomial,
    and Fibonacci heaps, which are presented and described in this chapter of the
    book.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the library at [https://github.com/pomma89/Hippie](https://github.com/pomma89/Hippie)
    and [https://www.nuget.org/packages/Hippie](https://www.nuget.org/packages/Hippie).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'The library contains a few classes, such as the `MultiHeap` generic class,
    which is common for various variants of heaps, including binary ones. However,
    if the same class is used for binary, binomial, and Fibonacci heaps, how can you
    choose which type of heap you want to use? You can use the static methods from
    the `HeapFactory` class to solve this problem. As an example, a binary heap can
    be created using the `NewBinaryHeap` method, as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `MultiHeap` class is equipped with a few properties, such as `Count` for
    getting the total number of elements in the heap and `Min` for retrieving the
    minimum value. Moreover, the available methods allow adding a new element (`Add`),
    removing a particular item (`Remove`), removing the minimum value (`RemoveMin`),
    removing all elements (`Clear`), checking whether the given value exists in the
    heap (`Contains`), and merging two heaps (`Merge`).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Example – heap sort
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example of the binary heap, implemented using the `Hippie` library, the
    heap sort algorithm is presented and described below. The C#-based implementation,
    which should be added to the `Main` method in the `Program` class, is as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, the implementation is very simple and short. At the beginning,
    you create a list with unsorted integer values as the input for the algorithm.
    Then, a new binary heap is prepared and you add each input value to the heap.
    At this stage, the elements from the input list are written in the console.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In the following part of the code, a new list is created. It will contain the
    sorted values and therefore it will contain the result of the algorithm. Then,
    the `while` loop is used to remove the minimum value from the heap in each iteration.
    The loop is executed until there are no elements in the heap. At the end, the
    sorted list is shown in the console.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The heap sort algorithm has *O(n * log(n))* time complexity.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build the project and run the application, you will see the following
    result:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As already mentioned, binary heaps are not the only variant of heaps. Among
    others, a binomial heap is one of the very interesting approaches, which is the
    topic of the next section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Binomial heaps
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another kind of heap is a **binomial heap**. This data structure consists of
    a set of **binomial trees** with different orders. The binomial tree with order
    *0* is just a single node. You can construct the tree with order *n* using two
    binomial trees with order *n-1*. One of them should be attached as the left-most
    child of the parent of the first tree. It does sound a bit complicated, but the
    following diagram should remove any confusion:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d4e9b3e-b52d-44ad-a437-08ea02ad2aa7.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: As already mentioned, the binomial tree with order **0** is only a single node,
    as shown on the left. The tree with order **1** consists of two trees with order
    **0** (marked with the dashed border) connected to each other. In the case of
    the tree with order **2**, two trees with order **1** are used. The second is
    attached as the left-most child of the parent of the first tree. In the same way,
    you can configure the binomial trees with the following orders.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'However, how can you know how many binomial trees should be located in the
    binomial heap, as well as how many nodes should they contain? The answer could
    be a bit surprising, because you need to prepare the binary representation of
    the number of nodes. As an example, let''s create a binomial heap with **13**
    elements. The number **13** has the following binary representation: **1101**,
    namely *1*2⁰ + 0*2¹ + 1*2² + 1*2³*.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to get zero-based positions of the set bits, that is, **0**, **2**,
    and **3** in this example. Such positions indicate orders of binomial trees that
    should be configured:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c7fc557-a3a4-4140-a694-2fff25163a83.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: Moreover, there cannot be more than one binomial tree with the same order (such
    as two trees with order **2**) in the binomial heap. Is it also worth noting that
    each binomial tree must maintain the min-heap property.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about binomial heaps at [https://en.wikipedia.org/wiki/Binomial_heap](https://en.wikipedia.org/wiki/Binomial_heap).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the binomial heap is significantly more complicated than
    the binary heap. For this reason, it may be a good idea to use one of the available
    implementations instead of writing your own from scratch. As stated in the case
    of binary heaps, the `Hippie` library is a solution that supports various variants
    of heaps, including binomial.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be surprising, but the only difference in the code, in comparison
    with the example of the binary heap, is modification of the line where a new instance
    of the `MultiHeap` class is created. For supporting a binomial heap, you need
    to use the `NewBinomialHeap` method from the `HeapFactory` class, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: No more changes are necessary! Now you can perform the remaining operations,
    such as insertion or removal of elements, in the exact same way as in the case
    of the binary heap.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: You have already learned about two kinds of heaps, namely binary and binomial
    ones. In the next section, the Fibonacci heap is briefly described.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci heaps
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Fibonacci heap** is an interesting variant of heaps, which in some ways
    is similar to a binomial heap. First of all, it also consists of many trees, but
    there are no constraints regarding the shape of each tree, so it is much more
    flexible than the binomial heap. Moreover, it is allowed to have more than one
    tree with exactly the same shape in the heap.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a Fibonacci heap is as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ebf3b19-9827-4b21-b359-3ed027961a35.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: One of the important assumptions is that each tree is a min-heap. Thus, the
    minimum value in the whole Fibonacci heap is certainly a root node in one of the
    trees. Moreover, the presented data structure supports performing various operations
    in the *lazy* way. That means that it does not perform additional complex operations
    unless it is really necessary. For example, it can add a new node just as a new
    tree with only one node.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Fibonacci heaps at [https://en.wikipedia.org/wiki/Fibonacci_heap](https://en.wikipedia.org/wiki/Fibonacci_heap).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the binomial heap, the implementation of the Fibonacci heap is
    also not a trivial task and requires good understanding of the internal details
    of this data structure. For this reason, if you need to use Fibonacci heaps in
    your application, it may be a good idea to use one of the available implementations
    instead of writing your own from scratch. As stated previously, the `Hippie` library
    is a solution that supports many variants of heaps, including Fibonacci ones.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that the only difference in the code, in comparison
    with the binary and binomial heaps, is modification of the line where a new instance
    of the `MultiHeap` class is created. For supporting a Fibonacci heap, you need
    to use the `NewFibonacciHeap` method from the `HeapFactory` class, as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: That's all! You have just read a brief introduction to the topic of Fibonacci
    heaps, as another variant of a heap and, therefore, another kind of a tree. That
    was the last subject in this chapter, so it is time to proceed to the summary.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current chapter is the longest so far in the book. However, it contains
    a lot of information about variants of trees. Such data structures perform very
    important role in many algorithms and it is good to learn more about them, as
    well as to know how to use them in your applications. For this reason, this chapter
    contains not only short theoretical introductions, but also diagrams, explanations,
    and code samples.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, the concept of a tree was described. As a reminder, a tree
    consists of nodes, including one root. The root does not contain a parent node,
    while all other nodes do. Each node can have any number of child nodes. The child
    nodes of the same node can be named siblings, while a node without children is
    named a leaf.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Various variants of trees follow this structure. The first one described in
    the chapter is a binary tree. In this case, a node can contain at most two children.
    However, the rules for BSTs are even more strict. For any node in such trees,
    the values of all nodes in its left subtree must be smaller than the value of
    the node, while the values of all nodes in its right subtree must be greater than
    the value of the node. BSTs have a very broad range of applications and provide
    developers with significant improvements of the lookup performance. Unfortunately,
    it is possible to easily make a tree unbalanced while adding sorted values to
    the tree. Therefore, the positive impact on the performance can be limited.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, you can use some kind of self-balancing tree, which
    remains balanced all the time while adding or removing nodes. In this chapter,
    two variants of self-balancing trees were presented: AVL trees and RBTs. The first
    kind has the additional requirement that, for each node, the height of its left
    and right subtrees cannot differ by more than one. The RBT is a bit more complex,
    because it introduces the concept of coloring nodes, either to red or black, as
    well as the NIL pseudo-nodes. Moreover, it is required that if a node is red,
    both its children must be black, and for any node, the number of black nodes on
    the route to a descendant leaf must be the same. As you have seen while analyzing
    such data structures, their implementation is significantly more difficult. Thus,
    the additional libraries, available to download using the NuGet Package Manager,
    were presented.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the chapter was related to heaps. As a reminder, a heap
    is another variant of a tree, which exists in two versions, min-heap and max-heap.
    It is worth noting that the value of each node must be greater than or equal to
    (for min-heaps) or less than or equal to (for max-heaps) the value of its parent
    node. The heaps exist in many variants, including binary, binomial, and Fibonacci
    ones. All of these kinds were briefly presented in the chapter, together with
    information about using the implementation from one of the NuGet packages.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed to graphs, which are the subject of the next chapter!
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
