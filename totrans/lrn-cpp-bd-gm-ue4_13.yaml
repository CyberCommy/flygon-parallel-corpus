- en: Spell Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player does not yet have a means to defend himself. We will now equip the
    player with a very useful and interesting way of doing so, called magic spells.
    Magic spells will be used by the player to affect monsters nearby, so you can
    now damage them.
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin the chapter by describing how to create our own particle systems.
    We'll then move on to wrap the particle emitter into a `Spell` class, and write
    a `CastSpell` function for the avatar to be able to actually `CastSpells`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a spell?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spell class actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching right mouse click to CastSpell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating other spells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a spell?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practically, spells will be a combination of a particle system with an area
    of effect represented by a bounding volume. The bounding volume is checked for
    actors contained in each frame. When an actor is within the bounding volume of
    a spell, then that actor is affected by that spell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the blizzard spell, with the bounding volume
    highlighted in orange:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d502f3b7-aa44-4c5a-a35c-e7b0580c894d.png)'
  prefs: []
  type: TYPE_IMG
- en: The blizzard spell has a long, box-shaped bounding volume. In each frame, the
    bounding volume is checked for contained actors. Any actor contained in the spell's
    bounding volume is going to be affected by that spell for that frame only. If
    the actor moves outside the spell's bounding volume, the actor will no longer
    be affected by that spell. Remember, the spell's particle system is a visualization
    only; the particles themselves are not what will affect game actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PickupItem` class we created in [Chapter 8](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml),
    *Actors and Pawns*, can be used to allow the player to pick up items representing
    the spells. We will extend the `PickupItem` class and attach the blueprint of
    a spell to cast each `PickupItem`. Clicking on a spell''s widget from the HUD
    will cast it. The interface will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ac617a8-92ec-4798-b090-495b3fcb6524.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up particle systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need a place to put all our snazzy effects. To do so, we will follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Content Browser tab, right-click on the Content root and create a new
    folder called `ParticleSystems`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on that new folder, and select New Asset | Particle System, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8dda3c34-0393-4b68-b568-3a3b14626a26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'See this Unreal Engine 4 particle systems guide for information on how Unreal
    particle emitters work: [https://www.youtube.com/watch?v=OXK2Xbd7D9w&amp;index=1&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/watch?v=OXK2Xbd7D9w&index=1&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the NewParticleSystem icon that appears, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17c681be-20b8-4b94-8296-407dd2f2fda4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are done with the preceding steps, you will be in Cascade, the particle
    editor. The environment is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/173d7371-cbb2-419b-8ed1-863f44e04ebb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are several different panes here, each of which shows different information.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top left is the Viewport pane. This shows you an animation of the current
    emitter as it's currently working.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the right is the Emitters pane. Inside it, you can see a single object called
    Particle Emitter (you can have more than one emitter in your particle system,
    but we don't want that now). The listing of modules of Particle Emitter appears
    listed under it. From the preceding screenshot, we have the Required, Spawn, Lifetime,
    Initial Size, Initial Velocity, and Color Over Life modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing particle properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default particle emitter emits crosshair-like shapes. We want to change
    that to something more interesting. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the yellow Required box under the Emitters panel, then open the Material
    drop-down in the Details panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of all the available particle materials will pop up (you can type `particles`
    in the top to make it easier to find the ones you want).
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose the m_flare_01 option to create our first particle system, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac976fd3-6e9a-4358-8b5a-142353c6dba7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s change the behavior of the particle system. Click on the Color
    Over Life entry under the Emitters pane. The Details pane at the bottom shows
    information about the different parameters, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c64ae04-cd1d-4801-a952-deee7b5ae84d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Details pane of Color Over Life entry, I increased R, but not G and not
    B. This gives the particle system a reddish glow. (R is red, G is green, and B
    is blue). You can see the color on the bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instead of editing the raw numbers, however, you can actually change the particle
    color more visually. If you click on the greenish zigzag button beside the Color
    Over Life entry under Emitters, you will see the graph for Color Over Life displayed
    in the Curve Editor tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf931d8b-84fa-44fb-80fa-e72bc65ea783.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now change the Color Over Life parameters. The graph in the Curve Editor
    tab displays the emitted color versus the amount of time the particle has been
    alive. You can adjust the values by dragging the points around. Pressing *Ctrl*
    + left mouse button adds a new point to a line (if it doesn''t work, click in
    the yellow box to deselect AlphaOverLife and make sure only ColorOverLife is selected):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c416672-9b92-4de2-b9ef-882ea4895335.png)'
  prefs: []
  type: TYPE_IMG
- en: You can play around with the particle emitter settings to create your own spell
    visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Settings for the blizzard spell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we should rename our particle system from NewParticleSystem to
    something more descriptive. Let's rename it `P_Blizzard`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/422079ca-06d0-49ff-b57f-59b93b200da7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can rename your particle system by simply clicking on it and pressing *F2,
    as shown below*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adcfef39-8761-4855-be26-c1884276844b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will tweak some of the settings to get a blizzard particle effect spell.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back into the P_Blizzard particle system to edit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the Spawn module, change the spawn rate to `200.0`. This increases the
    density of the visualization, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d29f563b-55a5-4525-8a58-bad64b23d627.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the Lifetime module, increase the Max property from `1.0` to `2.0`, as
    shown in the following screenshot. This introduces some variation to the length
    of time a particle will live, with some of the emitted particles living longer
    than others:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3fa2b655-864f-4888-b124-d7d2bebba71b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the Initial Size module, change the Min property size to `12.5` in X,
    Y, and Z, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67d82c41-cf10-43b4-b50f-1e7931a51416.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the Initial Velocity module, change the Min / Max values to the values
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b14c94b-a895-4f16-a7c6-f1e890175a0f.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason we're having the blizzard blow in +X is because the player's forward
    direction starts out in +X. Since the spell will come from the player's hands,
    we want the spell to point in the same direction as the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the Color Over Life menu, change the blue (B) value to `100.0`. Also
    change R back to `1.0`. You will see an instant change to a blue glow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/278ad147-cb00-4705-890f-4c0866c07900.png)'
  prefs: []
  type: TYPE_IMG
- en: Now it's starting to look magical!
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the blackish area below the Color Over Life module. Choose Location
    | Initial Location, shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bcf639ba-60da-462f-b93c-b2bb17afbeeb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter values under Start Location | Distribution as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be1b38a4-0f7d-436f-8ca9-39f1822e792d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should have a blizzard that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b25a958-cb24-40c4-b82b-98475a219166.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Move the camera to a position you like, and then click on the Thumbnail option
    in the top menu bar. This will generate a Thumbnail icon for your particle system
    in the Content Browser tab, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a422433a-ec14-4068-af06-32445aa0ad80.png)'
  prefs: []
  type: TYPE_IMG
- en: Spell class actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Spell` class will ultimately do damage to all monsters. Toward that end,
    we need to contain both a particle system and a bounding box inside the `Spell`
    class actor. When a `Spell` class is cast by the avatar, the `Spell` object will
    be instantiated into the level and start `Tick()` functioning. On every `Tick()`
    of the `Spell` object, any monster contained inside the spell's bounding volume
    will be affected by that `Spell`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Spell` class should look something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are only three functions we need to worry about implementing, namely the
    `ASpell::ASpell()` constructor, the `ASpell::SetCaster()` function, and the `ASpell::Tick()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Spell.cpp` file. Underneath the include line for `Spell.h`, add a
    line to include the `Monster.h` file, so we can access the definition of `Monster`
    objects inside the `Spell.cpp` file (as well as a couple of other includes), as
    shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the constructor, which sets up the spell and initializes all components,
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Of particular importance is the last line here, `PrimaryActorTick.bCanEverTick
    = true`. If you don't set that, your `Spell` objects won't ever have `Tick()`
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `SetCaster()` method. This is called so that the person who
    casts the spell is known to the `Spell` object. We can ensure that the caster
    can''t hurt himself with his own spells by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `ASpell::Tick()` method, which actually deals damage to
    all contained actors, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ASpell::Tick()` function does a number of things, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets all actors overlapping `ProxBox`. Any actor that is not the caster gets
    damaged if the component overlapped is the root component of that object. The
    reason we have to check for overlapping with the root component is because, if
    we don't, the spell might overlap the monster's `SightSphere`, which means we
    will get hits from very far away, which we don't want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that if we had another class of thing that should get damaged, we would
    have to attempt a cast to each object type specifically. Each class type might
    have a different type of bounding volume that should be collided with; other types
    might not even have `CapsuleComponent` (they might have `ProxBox` or `ProxSphere`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increases the amount of time the spell has been alive for. If the spell exceeds
    the duration it is allotted to be cast for, it is removed from the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's focus on how the player can acquire spells, by creating an individual
    `PickupItem` for each spell object that the player can pick up.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprinting our spells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile and run your C++ project with the `Spell` class that we just added.
    We need to create blueprints for each of the spells we want to be able to cast.
    To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Class Viewer tab, start to type `Spell`, and you should see your Spell
    class appear
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on Spell, and create a blueprint called BP_Spell_Blizzard as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2c44941-90e5-47c0-bad6-063fd84cab08.png)'
  prefs: []
  type: TYPE_IMG
- en: If it doesn't open automatically, double-click to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the spell''s properties, choose the P_Blizzard spell for the particle
    emitter, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1ce427a-570e-4bc1-98b5-2ee9c87c8efa.png)'
  prefs: []
  type: TYPE_IMG
- en: If you can't find it, try selecting Particles (Inherited) under Components.
  prefs: []
  type: TYPE_NORMAL
- en: 'With  BP_SpellBlizzard(self) selected, scroll down until you reach the Spell
    category, and update the Damage Per Second and Duration parameters to values you
    like, as shown in the following screenshot. Here, the blizzard spell will last
    `3.0` seconds, and do `16.0` damage per second. After three seconds, the blizzard
    will disappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/592a8226-92ac-4099-a193-662622fa24c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you have configured the Default properties, switch over to the Components
    tab to make some further modifications. Click on and change the shape of `ProxBox`
    so that its shape makes sense. The box should wrap the most intense part of the
    particle system, but don''t get carried away in expanding its size. The `ProxBox`
    object shouldn''t be too big, because then your blizzard spell would affect things
    that aren''t even being touched by the blizzard. As shown in the following screenshot,
    a couple of outliers are OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbf2312a-6a5d-4de4-8ac3-ead61614357c.png)'
  prefs: []
  type: TYPE_IMG
- en: Your blizzard spell is now blueprinted and ready to be used by the player.
  prefs: []
  type: TYPE_NORMAL
- en: Picking up spells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall that we previously programmed our inventory to display the number of
    pickup items the player has when the user presses *I*. We want to do more than
    that, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d443ba0-5008-4ed8-a000-1cfbb0a04eae.png)'
  prefs: []
  type: TYPE_IMG
- en: Items displayed when the user presses I
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the player to pick up spells, we''ll modify the `PickupItem` class
    to include a slot for a blueprint of the spell the player casts by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once you've added the `UClass* Spell` property to the `APickupItem` class, recompile
    and rerun your C++ project. Now, you can proceed to make blueprints of `PickupItem`
    instances for your `Spell` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating blueprints for PickupItems that Cast Spells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a PickupItem blueprint called BP_Pickup_Spell_Blizzard, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c858650a-7e6b-496c-9855-2027dc4dd31f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It should open automatically so you can edit its properties. I set the blizzard
    item''s pickup properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the item is Blizzard Spell, and `5` are in each package. I took
    a screenshot of the blizzard particle system and imported it into the project,
    so the Icon is selected as that image. Under Spell, I selected BP_Spell_Blizzard
    as the name of the spell to be cast (not BP_Pickup_Spell_Blizzard), as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef88141-1364-4dea-9d2c-904abd726f13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I selected a blue sphere for the `Mesh` class of the `PickupItem` class (you
    can also get an interesting one by using the M_Water_Lake material). For Icon,
    I took a screenshot of the blizzard spell in the particle viewer preview, saved
    it to disk, and imported that image to the project, as shown in the following
    screenshot (see the `images` folder in the Content Browser tab of the sample project):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/612d25a5-142b-45fb-ba60-f7cbfd0f501f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Place a few of these `PickupItem` in your level. If we pick them up, we will
    have some blizzard spells in our inventory (if you can''t pick them up make sure
    you made the ProxSphere big enough):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/badddff5-2324-4dc4-9320-1957be5bf452.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we need to activate the blizzard. Since we already attached the left mouse
    click in [Chapter 10](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml), *Inventory
    System and Pickup Items*, to drag the icons around, let's attach the right mouse
    click to casting the spell.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching right mouse click to CastSpell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The right mouse click will have to go through quite a few function calls before
    calling the avatar''s `CastSpell` method. The call graph would look something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3946b2e1-8cbb-40fe-b7aa-556f61174f31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A few things happen between right-click and spell cast. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw before, all user mouse and keyboard interactions are routed through
    the `Avatar` object. When the `Avatar` object detects a right-click, it will pass
    the click event to `HUD` through `AAvatar::MouseRightClicked()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 10](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml), *Inventory System
    and Pickup Items* we used a `struct Widget` class to keep track of the items the
    player had picked up. `struct Widget` only had three members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will now need to add an extra property for the `struct Widget` class to remember
    the spell it casts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HUD` will determine if the click event was inside `Widget` in `AMyHUD::MouseRightClicked()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the click was on the `Widget` that casts a spell, the `HUD` then calls the
    avatar back with the request to cast that spell, by calling `AAvatar::CastSpell()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the avatar's CastSpell function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the preceding call graph in reverse. We will start by writing
    the function that actually casts spells in the game, `AAvatar::CastSpell()`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Also make sure to add the function to `Avatar.h` and add `#include "Spell.h"`
    to the top of this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might find that actually calling a spell is remarkably simple. There are
    two basic steps to casting the spell:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the spell object using the world object's `SpawnActor` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach it to the avatar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `Spell` object is instantiated, its `Tick()` function will run each
    frame when that spell is in the level. On each `Tick()`, the `Spell` object will
    automatically feel out monsters in the level and damage them. A lot happens with
    each line of code mentioned previously, so let's discuss each line separately.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating the spell – GetWorld()->SpawnActor()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create the `Spell` object from the blueprint, we need to call the `SpawnActor()`
    function from the `World` object. The `SpawnActor()` function can take any blueprint
    and instantiate it within the level. Fortunately, the `Avatar` object (and indeed
    any `Actor` object) can get a handle to the `World` object at any time by simply
    calling the `GetWorld()` member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line of code that brings the `Spell` object into the level is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to note about the preceding line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bpSpell` must be the blueprint of a `Spell` object to create. The `<ASpell>`
    object in angle brackets indicates that expectation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `Spell` object starts out at the origin (`0`, `0`, `0`), and with no
    additional rotation applied to it. This is because we will attach the `Spell`
    object to the `Avatar` object, which will supply translation and direction components
    for the `Spell` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if(spell)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We always test if the call to `SpawnActor<ASpell>()` succeeds by checking `if(
    spell )`. If the blueprint passed to the `CastSpell` object is not actually a
    blueprint based on the `ASpell` class, then the `SpawnActor()` function returns
    a `NULL` pointer instead of a `Spell` object. If that happens, we print an error
    message to the screen indicating that something went wrong during spell casting.
  prefs: []
  type: TYPE_NORMAL
- en: spell->SetCaster(this)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When instantiating, if the spell does succeed, we attach the spell to the `Avatar`
    object by calling `spell->SetCaster( this )`. Remember, in the context of programming
    within the `Avatar` class, the `this` method is a reference to the `Avatar` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how do we actually connect spell casting from UI inputs, to call the `AAvatar::CastSpell()`
    function in the first place? We need to do some `HUD` programming again.
  prefs: []
  type: TYPE_NORMAL
- en: Writing AMyHUD::MouseRightClicked()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The spell cast commands will ultimately come from the HUD. We need to write
    a C++ function that will walk through all the HUD widgets and test to see if a
    click is on any one of them. If the click is on a `widget` object, then that `widget`
    object should respond by casting its spell, if it has one assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to extend our `Widget` object to have a variable to hold the blueprint
    of the spell to cast. Add a member to your `struct Widget` object by using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, recall that our `PickupItem` had the blueprint of the spell it casts attached
    to it previously. However, when the `PickupItem` class is picked up from the level
    by the player, then the `PickupItem` class is destroyed, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, we need to retain the information of what spell each `PickupItem` casts.
    We can do that when that `PickupItem` is first picked up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `AAvatar` class, add an extra map to remember the blueprint of the
    spell that an item casts, by item name, with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `AAvatar::Pickup()`, remember the class of spell the `PickupItem` class
    instantiates with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, in `AAvatar::ToggleInventory()`, we can have the `Widget` object that displays
    on the screen. Remember what spell it is supposed to cast by looking up the `Spells`
    map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the line where we create the widget, and modify it to add assignment of
    the `bpSpell` objects that the `Widget` casts, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function to `AMyHUD`, which we will set to run whenever the
    right mouse button is clicked on the icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to our left mouse click function. We simply check the click
    position against all the widgets. If any `Widget` was hit by the right-click,
    and that `Widget` has a `Spell` object associated with it, then a spell will be
    cast by calling the avatar's `CastSpell()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Activating right mouse button clicks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect this HUD function to run, we need to attach an event handler to
    the mouse right-click. We can do so by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Settings | Project Settings; the dialog pops up
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under Engine - Input, add an action mapping for Right Mouse Button, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/222a2cf3-be13-4d8d-a73c-df854a0550b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Declare a function in `Avatar.h`/`Avatar.cpp` called `MouseRightClicked()`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `AAvatar::SetupPlayerInputComponent()`, we should attach the `MouseClickedRMB`
    event to that `MouseRightClicked()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have finally hooked up spell casting. Try it out; the gameplay is pretty
    cool, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28b4e241-832c-405a-85d7-b66336ffac8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating other spells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By playing around with particle systems, you can create a variety of different
    spells that do different effects. You can create spells for fire, or lightning,
    or to push the enemy away from you. You've probably run into many other possible
    spells while playing other games.
  prefs: []
  type: TYPE_NORMAL
- en: The fire spell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can easily create a fire variant of our blizzard spell by changing the
    color of the particle system to red. This is how the fire variant of our blizzard
    spell will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b86ad1b-7a5e-4675-b4b1-233d26ed5059.png)'
  prefs: []
  type: TYPE_IMG
- en: The out val of the color changed to red
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightning spell**: Create a lightning spell by using the beam particle. Follow
    Zak''s tutorial for an example of how beams are created and shot in a direction,
    at [https://www.youtube.com/watch?v=ywd3lFOuMV8&amp;list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&amp;index=7](https://www.youtube.com/watch?v=ywd3lFOuMV8&list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t&index=7).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forcefield spell**: A forcefield will deflect attacks. It is essential for
    any player. Suggested implementation: derive a subclass of `ASpell` called `ASpellForceField`.
    Add a bounding sphere to the class, and use that in the `ASpellForceField::Tick()`
    function to push the monsters out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now know how to create spells to defend yourself in game. We've used particle
    systems to create a visible spell effect, and an area that can be used to cause
    damage to any enemies inside it. You can expand on what you've learned to create
    even more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will look into a newer and easier way to build the user
    interface.
  prefs: []
  type: TYPE_NORMAL
