- en: Chapter 4. Creating RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is one single core feature that demonstrates Laravel's superiority,
    it would be the ability to quickly and easily create a RESTful API. With the arrival
    of Laravel 5, several new features have been added; however, the ability to create
    application models and controllers via the Artisan command-line tool remains the
    most useful feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature is what initially encouraged me and so many others to abandon
    frameworks such as CodeIgniter, which at the time that Laravel 4 was in beta,
    did not natively have the same integrated functionality. Laravel provides the
    basic CRUD methods: create, read, update, delete, and also lists all.'
  prefs: []
  type: TYPE_NORMAL
- en: Requests that arrive via HTTP to a Laravel URL are managed through their verbs
    and subsequently, the `routes.php` file, which is located at `app/Http/routes.php`.
    There are two ways in which the requests are handled. One way is that the request
    is handled directly via a closure, and the code is entirely inside the `routes`
    file. Another way is that it routes the request to a controller, where a method
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the basic paradigm used is convention-over-configuration, where the method
    names are ready to handle the various requests, without too much extra effort.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs in Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The list of RESTful API requests handled by the RESTful API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | HTTP VERB | Function | URL |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `GET` | This lists all accommodations | `/accommodations` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `GET` | This shows (reads) a single accommodation | `/accommodations/{id}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `POST` | This creates a new accommodation | `/accommodations` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `PUT` | This entirely modifies (updates) an accommodation | `/accommodations/{id}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `PATCH` | This partially modifies (updates) an accommodation | `/accommodations/{id}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `DELETE` | This deletes an accommodation | `/accommodations/{id}` |'
  prefs: []
  type: TYPE_TB
- en: Most RESTful API best practices suggest using the plural form of the model name.
    Laravel's documentation uses the singular format. Most practices agree that consistent
    plural naming, that is, `/accommodations/{id}` refers to a single accommodation
    and `/accommodations` refers to more than one accommodation, both using the plural
    form are preferred over a mixed, but grammatically correct `/accommodation/{id}`
    (singular form) and `/accommodations` (plural form).
  prefs: []
  type: TYPE_NORMAL
- en: Essential CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For simplicity, I have numbered each of the rows. The first and second items
    represent the *read* part of CRUD.
  prefs: []
  type: TYPE_NORMAL
- en: The first item, which is a `GET` call to the plural form of the model name,
    is rather simple; it displays all of the items. Sometimes, this is called a *list*
    to differentiate it from the *read* of a single record. Adding a *list* would
    thus expand the acronym to CRUDL. They could be paginated or require authorization.
  prefs: []
  type: TYPE_NORMAL
- en: The second item, also a `GET` call, adds the ID of the model to the end of the
    URL, displaying a single model with that corresponding ID. This could also require
    authentication but not paging.
  prefs: []
  type: TYPE_NORMAL
- en: The third item represents the *create* part of CRUD. It uses the `POST` verb
    to create a new model. Note that the URL format is the same as the first item;
    this demonstrates the importance of the verb to distinguish between the actions.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth, fifth, and sixth items use the new `HTTP` verbs that were not supported
    by all browsers. Whether or not the verbs are supported, JavaScript libraries
    and frameworks, such as jQuery, will send the verb in a way that Laravel can properly
    handle.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth item is the `update` part of CRUD and updates the model using the
    `PUT` verb. Note that it has the same URL format as the second, as it needs to
    know which model to update. It is also idempotent, which means that the entire
    model must be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth item is similar to the fourth item; it updates the model, but uses
    the `PATCH` verb. This is used to indicate that the model will be partially modified,
    which means that one or more of the model's attributes have to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth item deletes a single model and thus requires the model's ID, using
    the self-explanatory `DELETE` verb.
  prefs: []
  type: TYPE_NORMAL
- en: Bonus features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Laravel adds two additional methods that are not usually part of a standard
    RESTful API. A `GET` method on the model URL, adding `create` is used to display
    a form to create the model. A `GET` method on the model URL with its ID, adding
    `edit` is used to display a form to create the model. These two functions are
    useful for providing a URL that will load a form, even though this type of usage
    is not a standard RESTful:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP VERB | Function | URL |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | This displays an accommodation creation form | `/accommodations/create`
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | This displays an accommodation modification/update form | `/accommodations/{id}/edit`
    |   |'
  prefs: []
  type: TYPE_TB
- en: Controller creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a controller for the accommodations, the following Artisan command
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: CRUD(L) by example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen this controller before, but here are a few examples. The single
    most simple example of a RESTful call would be as shown in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: cRudl – read
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `GET` call to `http://www.hotelwebsite.com/accommmodations/1`, where
    `1` would be the ID of the room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return a single model as a JSON-encoded object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: crudL – list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a GET call to `http://www.hotelwebsite.com/accommmodations`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is similar to the preceding code, yet slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return all of the models, automatically encoded as JSON objects;
    there is nothing else that is required. Formatting has been added so that the
    JSON results are more easily readable, but basically, the entire model is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `deleted_at` field is a soft delete or the recycle bin mechanism. It is
    either `null` for not deleted or a `date`/`time` stamp for deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add pagination, simply substitute `all()` with `paginate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will now look like this. The eloquent collection array is now moved
    inside a `date` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Crudl – create
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `POST` call to `http://www.hotelwebsite.com/accommmodations`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new model, a `POST` call will be sent to `/accommodations`. A JSON
    would be sent from the frontend as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `store` function might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`201` is the HTTP status code (`HTTP/1.1 201 created`) for `created`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we returned the model as a JSON-encoded object. The object
    will include the ID that was inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: crUdl – update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `PUT` call to `http://www.hotelwebsite.com/accommmodations/1`, where
    `1` is the ID to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To update an existing model, the code is exactly the same as we used earlier,
    except that the following line is used to find the existing model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `PUT` verb would be sent to `/accommodations/{id}`, where `id` would be
    the numeric ID of the accommodations table.
  prefs: []
  type: TYPE_NORMAL
- en: cruDl – delete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a model, create a `DELETE` call to `http://www.hotelwebsite.com/accommmodation/1`,
    where `1` is the ID to be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There seems to be some disagreement about what the proper status code should
    be for a deleted model.
  prefs: []
  type: TYPE_NORMAL
- en: Model binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can use a technique called *model binding* to clean up the code even
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In `app/Providers/RouteServiceProvider.php`, add the `$router->model()` method
    that accepts the route as the first argument and the model that will be bound
    as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: Read revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, our `show` controller method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When `/accommodations/1` is called, for example, the model that corresponds
    to that ID will be injected into the method, allowing us to substitute the find
    method.
  prefs: []
  type: TYPE_NORMAL
- en: List revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, for the `list` method, we inject the type-hinted model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Update revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Likewise, the `update` method now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Delete revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Also, the `destroy` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Moving beyond CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If one of the requirements of the software application to be built is able
    to search for an accommodation, then we can easily add a search function. The
    search function will find accommodations by using a `name` string. One way to
    do this is to add a route to the `routes.php` file. This will map a `GET` call
    to search for a new `search()` function contained within `AccommodationsController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, the `GET` method would be preferred instead of the `POST` method,
    as it can be bookmarked and recalled later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will write our search function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several mechanisms here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Request` object that contains the variables from the `GET` request is type-hinted
    and then injected into the search function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Accommodation` model is type-hinted and then injected into the `search`
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `where()` method from the fluent query builder is called on the eloquent
    model `$accommodation`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` parameter is used from the `request` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get()` method is used to actually perform the SQL query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that some of the query builder and eloquent methods return an instance
    of the query builder, while the others execute the query and return the result.
    The `where()` method returns an instance of the query builder, while the `get()`
    method executes the query.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting eloquent collection is returned and automatically encoded into
    JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `GET` request, therefore, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant JSON would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Nested controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nested controllers is a new feature in Laravel 5 and is used to handle all of
    the RESTful actions that deal with relationships. For example, we can take advantage
    of this feature for the relationship between accommodations and rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship between accommodation and room is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An accommodation may have one or more rooms (one-to-many)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A room belongs to one and only one accommodation (one-to-one)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our models, we will now write the code to enable the one-to-one and one-to-many
    relationships to be skillfully handled by Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: Accommodation hasMany rooms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will add the code that is needed by the `Accomodation.php` file that
    represents the `accommodation` model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `rooms()` method creates an easy way to access the relationship from inside
    the accommodation model. The relation states that "the accommodation *hasMany*
    rooms". The `hasMany` function, when residing inside the `Accommodation` class,
    without any additional parameters, expects a column named `accommodation_id` to
    exist in the `Room` model's table, which in this case is `rooms`.
  prefs: []
  type: TYPE_NORMAL
- en: Room belongsTo accommodation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will add the code that is needed by the `Room.php` file that represents
    the `Room` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code states that "a room *belongsTo* an accommodation". The *belongsTo*
    method inside the `Room` class, without any additional parameters, expects a field
    in the `room` model's table; in this case, `rooms`, named `accommodation_id`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the tables in the application database have followed the active record conventions,
    then most of the eloquent relation functionalities will automatically function.
    All of the parameters can be easily configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to create a nested controller is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the following line would be added to the `app/Http/routes.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To display the routes created, the following command should be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table lists the HTTP verbs and their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | HTTP verb | Function | URL |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `GET` | This shows the accommodation and room relations | `/accommodations/{accommodations}/rooms`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `GET` | This shows an accommodation and room relation | `/accommodations/{accommodations}/rooms/{rooms}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `POST` | This creates a new accommodation and room relation | `/accommodations/{accommodations}/rooms`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `PUT` | This entirely modifies (updates) an accommodation and room relation
    | `/accommodations/{accommodations}/rooms/{rooms}` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `PATCH` | This partially modifies (updates) an accommodation and room
    relation | `/accommodations/{accommodations}/rooms/{rooms}` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `DELETE` | This deletes an accommodation and room relation | `/accommodations/{accommodations}/rooms/{rooms}`
    |'
  prefs: []
  type: TYPE_TB
- en: Eloquent relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A nice mechanism used to illustrate an Eloquent relation directly inside the
    controller is performed through the use of a **nested relation**, where two models
    are connected firstly through the route and secondly through their controller
    method's parameters via model dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Nested update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s investigate the `update`/`modify PUT` nested controller command. The
    URL looks like this: `http://www.hotelwebsite.com/accommodations/21/rooms/13`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `21` would be the ID of the accommodation and `13` would be ID of the
    room. The parameters are the type-hinted models. This allows us to easily update
    the relationship as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Nested create
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, it is easy to perform the nested `create` operation with a `POST`
    body to `http://www.hotelwebsite.com/accommodations/21/rooms`. The `POST` body
    is a JSON formatted object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is no ID needed for the room since we are creating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Eloquent model casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models are returned in the JSON format as they are represented in the database.
    Often, model attributes, which are Boolean in nature, are represented by `0` and
    `1` for `true` and `false`, respectively. It may be, in this case, more convenient
    to return a real `true` and `false` to the RESTful call's return object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Laravel 4, this was done using **accessors**. If the value was `$status`,
    the method would be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In Laravel 5, this process is much easier, thanks to a new feature called model
    casting. To apply this technique, simply add a protected key and a value array
    called `$casts` to the model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `room_number` is a string, but we want to return an integer.
    Status is a tiny integer, but we want to return a Boolean value. Casting these
    two values in the model will modify the resultant JSON in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will now change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Route caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Laravel 5 has a new mechanism for caching the routes as the `routes.php` file
    can easily grow very large and will quickly slow down the request process. To
    enable the caching mechanism, type the following `artisan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates another `routes.php` file in `/storage/framework/routes.php`.
    If this file exists, then it is used instead of the `routes.php` file, which is
    located in `app/Http/routes.php`. The structure of the file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice that an interesting technique is used here. The routes are serialized,
    then base64 is encoded. Obviously, to read the routes, the reverse is used, `base64_decode()`,
    and then `unserialize()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `routes.php` cached file exists, then every time a change is made to
    the `routes.php` file, the route cache `artisan` command must be executed. This
    will clear the file and then recreate it. If you later decide to no longer use
    this mechanism, then the following `artisan` command can be used to eliminate
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Laravel is useful for building several distinctly different types of applications.
    When building traditional web applications, there is often a tight integration
    between the controllers and the views. It is also useful when building an app
    that can be used on a smartphone. In this case, the frontend will be created for
    the smartphone's operating system using another programming language and/or framework.
    In this case, only the controllers and model will most likely be used. In either
    case, however, having a well-documented RESTful API is an essential part of a
    well-designed modern software.
  prefs: []
  type: TYPE_NORMAL
- en: Nested controllers helps developers right away to read the code—it is an easy
    way to understand that the particular controller deals with the "nesting" or the
    concept that one class is related another.
  prefs: []
  type: TYPE_NORMAL
- en: Type-hinting the models and objects into the controller also improves the readability
    and, at the same time, reduces the amount of code necessary to perform the basic
    operations on the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Also, eloquent model casting creates an easy way to transform the attributes
    of a model, without having to rely on external packages or tedious accessor functions,
    as was the case in Laravel 4.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is rather clear to us why Laravel is becoming the choice of many developers.
    Learning and repeating some of the steps illustrated in this chapter will allow
    a RESTful API to get created in under an hour for a small-to-medium size program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A RESTful API provides an easy way to expand the program in the future and also
    integrates with third-party programs and software that exist within a company
    that might need to communicate with the application. The RESTful API is the front-most
    shell of the inner part of the program and provides the bridge between the outside
    world and the application itself. The inner part of the program will be where
    all of the business logic and database connections will reside, so fundamentally,
    the controllers simply have the job of connecting the routes to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel follows the RESTful best practices, thus documenting the API should
    be easy enough for other developers and third-party integrators to understand.
    Laravel 5 has brought a few features in to the framework to enable the code to
    be more readable.
  prefs: []
  type: TYPE_NORMAL
- en: In future chapters, middleware will be discussed. Middleware adds various "middle"
    layers between the route and the controller. Middleware can provide features such
    as authentication. Middleware will enrich, protect, and help organize the routes
    into logical and functional groups.
  prefs: []
  type: TYPE_NORMAL
- en: We will also discuss DocBlock annotations. Annotations, while not natively supported
    in PHP, can be enabled via a Laravel community package. Then, inside the DocBlock
    of the controller and controller functions, the routing for each controller is
    automatically created, without having to actually modify the `app/Http/routes.php`
    file. This is another great community concept that Laravel easily adapts to, in
    the same manner as phpspec and Behat.
  prefs: []
  type: TYPE_NORMAL
