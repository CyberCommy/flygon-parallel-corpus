- en: Exploring Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes included in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Defaulted and deleted functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lambdas with standard algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a recursive lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a function template with a variable number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fold expressions to simplify variadic function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing higher-order functions map and fold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions into a higher-order function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniformly invoking anything callable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defaulted and deleted functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, classes have special members (constructors, destructors, and operators)
    that may be either implemented by default by the compiler or supplied by the developer.
    However, the rules for what can be default implemented are a bit complicated and
    can lead to problems. On the other hand, developers sometimes want to prevent
    objects from being copied, moved, or constructed in a particular way. That is
    possible by implementing different tricks using these special members. The C++11
    standard has simplified many of these by allowing functions to be deleted or defaulted
    in the manner we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you need to know what special member functions are and what
    copyable and moveable means.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following syntax to specify how functions should be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To default a function, use `=default` instead of the function body. Only special
    class member functions that have defaults can be defaulted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete a function, use `=delete` instead of the function body. Any function,
    including non-member functions, can be deleted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use defaulted and deleted functions to achieve various design goals, such as
    the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a class that is not copyable, and implicitly not movable, declare
    the copy operations as deleted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement a class that is not copyable, but is movable, declare the copy
    operations as deleted and explicitly implement the move operations (and provide
    any additional constructors that are needed):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure a function is called only with objects of a specific type, and perhaps
    prevent type promotion, provide deleted overloads for the function (the following
    example with free functions can also be applied to any class member functions):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class has several special members that can be implemented, by default, by
    the compiler. These are the default constructor, copy constructor, move constructor,
    copy assignment, move assignment, and destructor. If you don''t implement them,
    then the compiler does it so that instances of a class can be created, moved,
    copied, and destructed. However, if you explicitly provide one or more of these
    special methods, then the compiler will not generate the others according to the
    following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If a user-defined constructor exists, the default constructor is not generated
    by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined virtual destructor exists, the default constructor is not
    generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined move constructor or move assignment operator exists, then
    the copy constructor and copy assignment operator are not generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined copy constructor, move constructor, copy assignment operator,
    move assignment operator, or destructor exists, then the move constructor and
    move assignment operator are not generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined copy constructor or destructor exists, then the copy assignment
    operator is generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user-defined copy assignment operator or destructor exists, then the copy
    constructor is generated by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the last two rules in the preceding list are deprecated rules and
    may no longer be supported by your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, developers need to provide empty implementations of these special
    members or hide them in order to prevent the instances of the class from being constructed
    in a specific manner. A typical example is a class that is not supposed to be
    copyable. The classical pattern for this is to provide a default constructor and
    hide the copy constructor and copy assignment operators. While this works, the
    explicitly defined default constructor ensures the class is no longer considered
    trivial and, therefore, a POD type. The modern alternative to this is using a
    deleted function as shown in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler encounters `=default` in the definition of a function, it
    will provide the default implementation. The rules for special member functions
    mentioned earlier still apply. Functions can be declared `=default` outside the
    body of a class if and only if they are inlined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the compiler encounters the `=delete` in the definition of a function,
    it will prevent the calling of the function. However, the function is still considered
    during overload resolution, and only if the deleted function is the best match,
    the compiler generates an error. For example, by giving the previously defined
    overloads for the `run()` function, only calls with long integers are possible.
    Calls with arguments of any other type, including `int`, for which an automatic
    type promotion to `long` exists, will determine a deleted overload to be considered
    the best match and therefore the compiler will generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that previously declared functions cannot be deleted, as the `=delete`
    definition must be the first declaration in a translation unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The rule of thumb (also known as *The Rule of Five*) for class special member
    functions is that, if you explicitly define any copy constructor, move constructor,
    copy assignment operator, move assignment operator, or destructor, then you must
    either explicitly define or default all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Using lambdas with standard algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important modern features of C++ is lambda expressions, also
    referred to as lambda functions or simply lambdas. Lambda expressions enable us
    to define anonymous function objects that can capture variables in the scope and
    be invoked or passed as arguments to functions. Lambdas are useful for many purposes,
    and in this recipe, we will see how to use them with standard algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we discuss standard algorithms that take an argument that is
    a function or predicate applied to the elements it iterates through. You need
    to know what unary and binary functions are and what predicates and comparison
    functions are. You also need to be familiar with function objects because lambda
    expressions are syntactic sugar for function objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should prefer to use lambda expressions to pass callbacks to standard algorithms
    instead of functions or function objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define anonymous lambda expressions in the place of the call if you only need
    to use the lambda in a single place:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a named lambda, that is, one assigned to a variable (usually with the
    `auto` specifier for the type), if you need to call the lambda in multiple places:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use generic lambda expressions if you need lambdas that only differ in their
    argument types (available since C++14):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The non-generic lambda expression shown on the second bullet earlier takes
    a constant integer and returns `true` if it is greater than `0`, or `false` otherwise.
    The compiler defines an unnamed function object with the call operator having
    the signature of the lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The way the unnamed function object is defined by the compiler depends on the
    way we define the lambda expression that can capture variables, use the `mutable`
    specifier or exception specifications, or have a trailing return type. The `__lambda_name__`
    function object shown earlier is actually a simplification of what the compiler
    generates because it also defines a default copy and move constructor, a default
    destructor, and a deleted assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: It must be well understood that the lambda expression is actually a class. In
    order to call it, the compiler needs to instantiate an object of the class. The
    object instantiated from a lambda expression is called a *lambda closure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we want to count the number of elements in a range that
    are greater than or equal to 5 and less than or equal to 10\. The lambda expression,
    in this case, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This lambda captures two variables, `start` and `end`, by copy (that is, value).
    The resulting unnamed function object created by the compiler looks very much
    like the one we defined earlier. With the default and deleted special members
    mentioned earlier, the class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The lambda expression can capture variables by copy (or value) or by reference,
    and different combinations of the two are possible. However, it is not possible
    to capture a variable multiple times, and it is only possible to have `&` or `=`
    at the beginning of the capture list.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda can only capture variables from an enclosing function scope. It cannot
    capture variables with static storage duration (that is, variables declared in
    a namespace scope or with the `static` or `external` specifier).
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows various combinations for lambda captures semantics.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lambda** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[](){}` | Does not capture anything |'
  prefs: []
  type: TYPE_TB
- en: '| `[&](){}` | Captures everything by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[=](){}` | Captures everything by copy |'
  prefs: []
  type: TYPE_TB
- en: '| `[&x](){}` | Capture only `x` by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[x](){}` | Capture only `x` by copy |'
  prefs: []
  type: TYPE_TB
- en: '| `[&x...](){}` | Capture pack extension `x` by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[x...](){}` | Capture pack extension `x` by copy |'
  prefs: []
  type: TYPE_TB
- en: '| `[&, x](){}` | Captures everything by reference except for `x` that is captured
    by copy |'
  prefs: []
  type: TYPE_TB
- en: '| `[=, &x](){}` | Captures everything by copy except for `x` that is captured
    by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[&, this](){}` | Captures everything by reference except for pointer `this`
    that is captured by copy (`this` is always captured by copy) |'
  prefs: []
  type: TYPE_TB
- en: '| `[x, x](){}` | Error, `x` is captured twice |'
  prefs: []
  type: TYPE_TB
- en: '| `[&, &x](){}` | Error, everything is captured by reference, cannot specify
    again to capture `x` by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `[=, =x](){}` | Error, everything is captured by copy, cannot specify again
    to capture `x` by copy |'
  prefs: []
  type: TYPE_TB
- en: '| `[&this](){}` | Error, pointer `this` is always captured by copy |'
  prefs: []
  type: TYPE_TB
- en: '| `[&, =](){}` | Error, cannot capture everything both by copy and by reference
    |'
  prefs: []
  type: TYPE_TB
- en: 'The general form of a lambda expression, as of C++17, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All parts shown in this syntax are actually optional except for the capture
    list, that can, however, be empty, and the body, that can also be empty. The parameter
    list can actually be omitted if no parameters are needed. The return type does
    not need to be specified, as the compiler can infer it from the type of the returned
    expression. The `mutable` specifier (that tells the compiler the lambda can actually
    modify variables captured by copy), the `constexpr` specifier (that tells the
    compiler to generate a `constexpr` call operator), and the exception specifiers
    and attributes are all optional.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest possible lambda expression is `[]{}`, though it is often written
    as `[](){}`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where lambda expressions only differ in the type of their arguments.
    In this case, the lambdas can be written in a generic way, just like templates,
    but using the `auto` specifier for the type parameters (no template syntax is
    involved). This is addressed in the next recipe, mentioned in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using generic lambdas*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a recursive lambda*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we saw how to write lambda expressions and use them
    with standard algorithms. In C++, lambdas are basically syntactic sugar for unnamed
    function objects, which are classes that implement the call operator. However,
    just like any other function, this can be implemented generically with templates.
    C++14 takes advantage of this and introduces generic lambdas that do not need
    to specify actual types for their parameters and use the `auto` specifier instead.
    Though not referred with this name, generic lambdas are basically lambda templates.
    They are useful in cases where we want to use the same lambda but with different
    types of parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is recommended that you read the preceding recipe, *Using lambdas with standard
    algorithms*, before you continue with this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write generic lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: By using the `auto` specifier instead of actual types for lambda expression
    parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to use multiple lambdas that only differ by their parameter types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following example shows a generic lambda used with the `std::accumulate()`
    algorithm first with a vector of integers and then with a vector of strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the example from the previous section, we have defined a named lambda expression,
    that is, a lambda expression that has its closure assigned to a variable. This
    variable is then passed as an argument to the `std::accumulate()` function. This
    general algorithm takes the begin and the end iterators that define a range, an
    initial value to accumulate over, and a function that is supposed to accumulate
    each value in the range to the total. This function takes a first parameter representing
    the currently accumulated value and a second parameter representing the current
    value to accumulate to the total, and it returns the new accumulated value.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I did not use the term `add` because this can be used for other things
    than just adding. It can also be used for calculating a product, concatenating,
    or other operations that aggregate values together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two calls to `std::accumulate()` in this example are almost the same, only
    the types of the arguments are different:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first call, we pass iterators to a range of integers (from a `vector<int>`),
    0 for the initial sum and a lambda that adds two integers and returns their sum.
    This produces a sum of all integers in the range; for this example, it is 22.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second call, we pass iterators to a range of strings (from a `vector<string>`),
    an empty string for the initial value, and a lambda that concatenates two strings
    by adding them together and returning the result. This produces a string that
    contains all the strings in the range put together one after an other; for this
    example, the result is *"hello world!"*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though generic lambdas can be defined anonymously in the place where they are
    called, it does not really make sense because the very purpose of a generic lambda
    (that is basically, as mentioned earlier, a lambda expression template) is to
    be reused, as shown in the example from the *How to do it...* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining this lambda expression used with multiple calls to `std::accumulate()`,
    instead of specifying concrete types for the lambda parameters (such as `int`
    or `std::string`) we used the `auto` specifier and let the compiler deduce the
    type. When encountering a lambda expression that has the `auto` specifier for
    a parameter type, the compiler generates an unnamed function object that has a
    call operator template. For the generic lambda expression in this example, the
    function object would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The call operator is a template with a type parameter for each parameter in
    the lambda that was specified with `auto`. The return type of the call operator
    is also `auto`, which means the compiler will deduce it from the type of the returned
    value. This operator template will be instantiated with the actual types the compiler
    will identify in the context where the generic lambda is used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using lambdas with standard algorithms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using auto whenever possible* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a recursive lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambdas are basically unnamed function objects, which means that it should be
    possible to call them recursively. Indeed, they can be called recursively; however,
    the mechanism for doing it is not obvious, as it requires assigning the lambda
    to a function wrapper and capturing the wrapper by reference. Though it can be
    argued that a recursive lambda does not really make sense and a function is probably
    a better design choice, in this recipe we will look at how to write a recursive
    lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate how to write a recursive lambda, we will consider the well-known
    example of the Fibonacci function. This is usually implemented recursively in
    C++, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to write a recursive lambda function, you must perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the lambda in a function scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the lambda to an `std::function` wrapper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture the `std::function` object by reference in the lambda in order to call
    it recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are examples of recursive lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursive Fibonacci lambda expression in the scope of a function that is
    invoked from the scope where it is defined:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A recursive Fibonacci lambda expression returned by a function, that can be
    invoked from any scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you need to consider when writing a recursive lambda is that
    a lambda expression is a function object and, in order to call it recursively
    from the lambda''s body, the lambda must capture its closure (that is, the instantiation
    of the lambda). In other words, the lambda must capture itself and this has several
    implications:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the lambda must have a name; an unnamed lambda cannot be captured
    in order to be called again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, the lambda can only be defined in a function scope. The reason for
    this is that a lambda can only capture variables from a function scope; it cannot
    capture any variable that has a static storage duration. Objects defined in a
    namespace scope or with the static or external specifiers have static storage
    duration. If the lambda was defined in a namespace scope, its closure would have
    static storage duration and therefore the lambda would not capture it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third implication is that the type of the lambda closure cannot remain unspecified,
    that is, be declared with the auto specifier. It is not possible for a variable
    declared with the auto type specifier to appear in its own initializer because
    the type of the variable is not known when the initializer is being processed.
    Therefore, you must specify the type of the lambda closure. The way we can do
    this is using the general purpose function wrapper `std::function`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last, but not least, the lambda closure must be captured by reference. If we
    capture by copy (or value), then a copy of the function wrapper is made, but the
    wrapper is uninitialized when the capturing is done. We end up with an object
    that we are not able to call. Even though the compiler will not complain about
    capturing by value, when the closure is invoked, an `std::bad_function_call` is
    thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first example from the *How to do it...* section, the recursive lambda
    is defined inside another function called `sample()`. The signature and the body
    of the lambda expression are the same as those of the regular recursive function
    `fib()` defined in the introductory section. The lambda closure is assigned to
    a function wrapper called `lfib` that is then captured by reference by the lambda
    and called recursively from its body. Since the closure is captured by reference,
    it will be initialized at the time it has to be called from the lambda's body.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example, we have defined a function that returns the closure
    of a lambda expression that, in turn, defines and invokes a recursive lambda with
    the argument it was, in turn, invoked with. This is a pattern that must be implemented
    when a recursive lambda needs to be returned from a function. This is necessary
    because the lambda closure must still be available at the time the recursive lambda
    is called. If it is destroyed before that, we are left with a dangling reference
    and calling it will cause the program to terminate abnormally. This erroneous
    situation is exemplified in the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The solution for this is to create two nested lambda expressions as shown in
    the *How to do it...* section. The `fib_create()` method returns a function wrapper
    that when invoked creates the recursive lambda that captures itself. This is slightly
    and subtly, yet fundamentally, different from the implementation shown in the
    preceding sample. The outer `f` lambda does not capture anything, especially by
    reference; therefore, we don't have the issue with dangling references. However,
    when invoked, it creates a closure of the nested lambda, the actual lambda we
    are interested in calling and returns the result of applying that recursive `lfib`
    lambda to its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a function template with a variable number of arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is sometimes useful to write functions with a variable number of arguments
    or classes with a variable number of members. Typical examples include functions
    such as `printf` that take a format and a variable number of arguments, or classes
    such as `tuple`. Before C++11, the former was possible only with the use of variadic
    macros (that enable writing only type-unsafe functions) and the latter was not
    possible at all. C++11 introduced variadic templates, which are templates with
    a variable number of arguments that make it possible to write both type-safe function
    templates with a variable number of arguments and also class templates with a variable
    number of members. In this recipe, we will look at writing function templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions with a variable number of arguments are called *variadic functions*.
    Function templates with a variable number of arguments are called *variadic function
    templates*. Knowledge of C++ variadic macros (`va_start`, `va_end`, `va_arg` and
    `va_copy`, `va_list`) is not necessary for learning how to write variadic function
    templates, but it represents a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: We have already used variadic templates in our previous recipes, but this one
    will provide detailed explanations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to write variadic function templates, you must perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an overload with a fixed number of arguments to end compile-time recursion
    if the semantics of the variadic function template require it (refer to `[1]`
    in the following code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a template parameter pack to introduce a template parameter that can
    hold any number of arguments, including zero; these arguments can be either types,
    non-types, or templates (refer to `[2]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a function parameter pack to hold any number of function arguments, including
    zero; the size of the template parameter pack and the corresponding function parameter
    pack is the same and can be determined with the `sizeof...` operator (refer to
    `[3]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the parameter pack in order to replace it with the actual arguments being
    supplied (refer to `[4]`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example that illustrates all the preceding points, is a variadic
    function template that adds a variable number of arguments using `operator+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a first look, the preceding implementation looks like recursion, because
    function `add()` calls itself, and in a way it is, but it is a compile-time recursion
    that does not incur any sort of runtime recursion and overhead. The compiler actually
    generates several functions with a different number of arguments, based on the
    variadic function template usage, so it is only function overloading that is involved
    and not any sort of recursion. However, implementation is done as if parameters
    would be processed in a recursive manner with an end condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code we can identify the following key parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Typename... Ts` is a template parameter pack that indicates a variable number
    of template type arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ts... rest` is a function parameter pack that indicates a variable number
    of function arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rest...` is an expansion of the function parameter pack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position of the ellipsis is not syntactically relevant. `typename... Ts`,
    `typename ... Ts`, and `typename ...Ts` are all equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: In the `add(T head, Ts... rest)` parameter, `head` is the first element of the
    list of arguments, and `...rest` is a pack with the rest of the parameters in
    the list (this can be zero or more). In the body of the function, `rest...` is
    an expansion of the function parameter pack. This means the compiler replaces
    the parameter pack with its elements in their order. In the `add()` function,
    we basically add the first argument to the sum of the remaining arguments, which
    gives the impression of a recursive processing. This recursion ends when there
    is a single argument left, in which case the first `add()` overload (with a single
    argument) is called and returns the value of its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation of the function template `add()` enables us to write code,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the compiler encounters `add(1, 2, 3, 4, 5)`, it generates the following
    functions (`arg1`, `arg2`, and so on, are not the actual names the compiler generates)
    that show this is actually only calls to overloaded functions and not recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With GCC and Clang, you can use the `__PRETTY_FUNCTION__` macro to print the
    name and the signature of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding a `std::cout << __PRETTY_FUNCTION__ << std::endl` at the beginning
    of the two functions we wrote, we get the following when running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a function template, it can be used with any type that supports
    `operator+`. The other example, `add("hello"s, " "s, "world"s, "!"s)`, produces
    the *"hello world!"* string. However, the `std::basic_string` type has different
    overloads for `operator+`, including one that can concatenate a string to a character,
    so we should be able to also write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that will generate compiler errors as follows (note that I actually
    replaced `std::basic_string<char, std::char_traits<char>, std::allocator<char>
    >` with string *"hello world"* for simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens is that the compiler generates the code shown next where the return
    type is the same as the type of the first argument. However, the first argument
    is either a `std::string` or a `char` (again, `std::basic_string<char, std::char_traits<char>,
    std::allocator<char> >` was replaced with `string` for simplicity). In cases where
    `char` is the type of the first argument, the type of the return value `head+add(...)`
    that is an `std::string` does not match the function return type and does not
    have an implicit conversion to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this by modifying the variadic function template to have `auto`
    for the return type instead of `T`. In this case, the return type is always inferred
    from the return expression, and in our example, it will be `std::string` in all
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be further added that a parameter pack can appear in a brace-initialization
    and its size can be determined using the `sizeof...` operator. Also, variadic
    function templates do not necessarily imply compile-time recursion as we have
    shown in this recipe. All these are shown in the following example where we define
    a function that creates a tuple with an even number of members. We first use `sizeof...(a)`
    to make sure that we have an even number of arguments and assert by generating
    a compiler error otherwise. The `sizeof...` operator can be used with both template
    parameter packs and function parameter packs. `sizeof...(a)` and `sizeof...(T)`
    would produce the same value. Then, we create and return a tuple. The template
    parameter pack `T` is expanded (with `T...`) into the type arguments of the `std::tuple`
    class template, and the function parameter pack `a` is expanded (with `a...`)
    into the values for the tuple members using brace initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using fold expressions to simplify variadic function templates*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating raw user-defined literals* recipe of [Chapter 9](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml),
    *Working with Numbers and*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Strings*'
  prefs: []
  type: TYPE_NORMAL
- en: Using fold expressions to simplify variadic function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are discussing folding several times; this is an operation
    that applies a binary function to a range of values to produce a single value.
    We have seen this when we discussed variadic function templates and will see it
    again with higher-order functions. It turns out there is a significant number
    of cases where the expansion of a parameter pack in variadic function templates
    is basically a folding operation. To simplify writing such variadic function templates
    C++17 introduced fold expressions that fold an expansion of a parameter pack over
    a binary operator. In this recipe, we will see how to use fold expressions to
    simplify writing variadic function templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The examples in this recipe are based on the variadic function template `add()`
    that we wrote in the previous recipe, *Writing a function template with a variable
    number of arguments*. That implementation is a left-folding operation. For simplicity,
    we present the function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fold a parameter pack over a binary operator, use one of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Left folding with a unary form `(... op pack)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Left folding with a binary form `(init op ... op pack)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Right folding with a unary form `(pack op ...)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Right folding with a binary form `(pack op ... op init)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses shown above are part of the fold expression and cannot be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the compiler encounters a fold expression, it expands it in one of the
    following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Expansion** |'
  prefs: []
  type: TYPE_TB
- en: '| `(... op pack)` | ((pack$1 op pack$2) op ...) op pack$n |'
  prefs: []
  type: TYPE_TB
- en: '| `(init op ... op pack)` | (((init op pack$1) op pack$2) op ...) op pack$n
    |'
  prefs: []
  type: TYPE_TB
- en: '| `(pack op ...)` | pack$1 op (... op (pack$n-1 op pack$n)) |'
  prefs: []
  type: TYPE_TB
- en: '| `(pack op ... op init)` | pack$1 op (... op (pack$n-1 op (pack$n op init)))
    |'
  prefs: []
  type: TYPE_TB
- en: When the binary form is used, the operator on both the left-hand and right-hand
    side of the ellipses must be the same, and the initialization value must not contain
    an unexpanded parameter pack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following binary operators are supported with fold expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| + | - | * | / | % | ^ | & | &#124; | = | < | > | << |'
  prefs: []
  type: TYPE_TB
- en: '| >> | += | -= | *= | /= | %= | ^= | &= | &#124;= | <<= | >>= | == |'
  prefs: []
  type: TYPE_TB
- en: '| != | <= | >= | && | &#124;&#124; | , | .* | ->*. |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'When using the unary form, only operators such as `*`, `+`, `&`, `|`, `&&`,
    `||`, and `,` (comma) are allowed with an empty parameter pack. In this case,
    the value of the empty pack is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `+` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | `-1` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | `void()` |'
  prefs: []
  type: TYPE_TB
- en: 'Now that we have the function templates implemented earlier (let''s consider
    the left-folding version), we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering the  `add(1, 2, 3, 4, 5)` call, it would produce the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Due to the aggressive ways modern compilers do optimizations, this function
    can be inlined and eventually end up with an expression such as `auto sum = 1
    + 2 + 3 + 4 + 5`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fold expressions work with all overloads for the supported binary operators,
    but do not work with arbitrary binary functions. It is possible to implement a
    workaround for that by providing a wrapper type to hold a value and an overloaded
    operator for that wrapper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `wrapper` is a simple class template that holds a constant
    reference to a value of type `T`. An overloaded `operator<` is provided for this
    class template; this overload does not return a Boolean to indicate that the first
    argument is less than the second, but actually an instance of the `wrapper` class
    type to hold the minimum value of the two arguments. The variadic function template
    `min()` uses this overloaded `operator<` to fold the pack of arguments expanded
    to instances of the wrapper class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Implementing higher-order functions map and fold*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing higher-order functions map and fold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the preceding recipes in this book, we have used the general purpose
    algorithms `std::transform()` and `std::accumulate()` in several examples, such
    as implementing string utilities to create uppercase or lowercase copies of a
    string or summing the values of a range. These are basically implementations of
    higher-order functions, `map` and `fold`. A higher-order function is a function
    that takes one or more other functions as arguments and applies them to a range
    (a list, vector, map, tree, and so on), producing either a new range or a value.
    In this recipe, we will see how to implement `map` and `fold` functions to work
    with C++ standard containers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Map* is a higher-order function that applies a function to the elements of
    a range and returns a new range in the same order.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fold* is a higher-order function that applies a combining function to the
    elements of the range producing a single result. Since the order of the processing
    can be important, there are usually two versions of this function--`foldleft`,
    that processes elements from left to right, and **`foldright`** that combines
    the elements from right to left.'
  prefs: []
  type: TYPE_NORMAL
- en: Most descriptions of the function map indicate that it is applied to a `list`,
    but this is a general term that can indicate different sequential types, such
    as list, vector, and array, and also dictionaries (that is, maps), queues, and
    so on. For this reason, I prefer to use the term range when describing these higher-order
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the `map` function you should:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::transform` on containers that support iterating and assignment to
    the elements, such as `std::vector` or `std::list`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Use other means such as explicit iteration and insertion for containers that
    do not support assignment to the elements, such as `std::map`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `fold` function you should:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::accumulate()` on containers that support iterating:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Use other means to explicitly process containers that do not support iterating,
    such as `std::queue`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding examples, we have implemented the map in a functional way,
    without side-effects. That means it preserves the original range and returns a
    new one. The arguments of the function are the function to apply and the range.
    In order to avoid confusion with the `std::map` container, we have called this
    function `mapf`. There are several overloads for `mapf` as shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: The first overload is for containers that support iterating and assignment to
    its elements; this includes `std::vector`, `std::list`, and `std::array`, but
    also C-like arrays. The function takes an `rvalue` reference to a function and
    a range for which `std::begin()` and `std::end()` are defined. The range is passed
    by value so that modifying the local copy does not affect the original range.
    The range is transformed by applying the given function to each element using
    the standard algorithm `std::transform()`; the transformed range is then returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second overload is specialized for `std::map` that does not support direct
    assignment to its elements (`std::pair<T, U>`). Therefore, this overload creates
    a new map, then iterates through its elements using a range-based for loop, and
    inserts into the new map the result of applying the input function to each element
    of the original map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third overload is specialized for `std::queue`, which is a container that
    does not support iterating. It can be argued that a queue is not a typical structure
    to map over, but for the sake of demonstrating different possible implementations,
    we are considering it. In order to iterate over the elements of a queue, the queue
    must be altered--you need to pop elements from the front until the list is empty.
    This is what the third overload does--it processes each element of the input queue
    (passed by value) and pushes the result of applying the given function to the
    front element of the remaining queue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have these overloads implemented, we can apply them to a lot of
    containers, as shown in the following examples (notice that the map and fold functions
    used here are implemented in a namespace called funclib in the code accompanying
    the book and therefore shown with the fully qualified name):'
  prefs: []
  type: TYPE_NORMAL
- en: Retain absolute values from a vector. In this example, the vector contains both
    negative and positive values. After applying the mapping, the result is a new
    vector with only positive values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Square the numerical values of a list. In this example, the list contains integral
    values. After applying the mapping, the result is a list containing the squares
    of the initial values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Rounded amounts of floating point. For this example, we need to use `std::round()`;
    however, this has overloads for all floating point types, which makes it impossible
    for the compiler to pick the right one. As a result, we either have to write a
    lambda that takes an argument of a specific floating point type and returns the
    value of `std::round()` applied to that value or create a function object template
    that wraps `std::round()` and enables its call operator only for floating point
    types. This technique is used in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Uppercase the string keys of a map of words (where the key is the word and
    the value is the number of appearances in the text). Note that creating an uppercase
    copy of a string is itself a mapping operation. Therefore, in this example, we
    use `mapf` to apply `toupper()` to the elements of the string representing the
    key in order to produce an uppercase copy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Normalize values from a queue of priorities--initially, the values are from
    1 to 100, but we want to normalize them into two values, 1=high and 2=normal.
    All initial priorities that have a value up to 30 become a high priority, the
    others get a normal priority:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To implement `fold`, we actually have to consider the two possible types of
    folding, that is, from left to right and from right to left. Therefore, we have
    provided two functions called `foldl` (for left folding) and `foldr` (for right
    folding). The implementations shown in the previous section are very similar--they
    both take a function, a range, and an initial value and call `std::algorithm()`
    to fold the values of the range into a single value. However, `foldl` uses direct
    iterators, whereas `foldr` uses reverse iterators to traverse and process the
    range. The second overload is a specialization for type `std::queue`, which does
    not have iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these implementations for folding, we can do the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the values of a vector of integers. In this case, both left and right
    folding will produce the same result. In the following examples, we pass either
    a lambda that takes a sum and a number and returns a new sum or the function object
    `std::plus<>` from the standard library that applies `operator+` to two operands
    of the same type (basically similar to the closure of the lambda):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating strings from a vector into a single string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating an array of characters into a string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Counting the number of words from a text based on their already computed appearances
    available in a `map<string, int>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions can be pipelined, that is, they can call one function with
    the result of another. The following example maps a range of integers into a range
    of positive integers by applying the `std::abs()` function to its elements. The
    result is then mapped into another range of squares. These are then summed together
    by applying a left fold on the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As an exercise, we could implement the fold function as a variadic function
    template, in the manner seen in a previous recipe. The function that performs
    the actual folding is provided as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compare this with the `add()` function template that we wrote in the
    recipe *Writing a function template with a variable number of arguments*, we can
    notice several differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a function, which is perfectly forwarded when calling
    `foldl` recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end case is a function that requires two arguments because the function
    we use for folding is a binary one (taking two arguments).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The return type of the two functions we wrote is declared as `auto` because
    it must match the return type of the supplied binary function `f` that is not
    known until we call `foldl`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Creating a library of string helpers* recipe of [Chapter 9](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml),
    *Working with Numbers and Strings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a function template with a variable number of arguments*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Composing functions into a higher-order function*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions into a higher-order function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we implemented two higher-order functions, map and fold,
    and saw various examples of using them. At the end of the recipe, we saw how they
    can be pipelined to produce a final value after several transformations of the
    original data. Pipelining is a form of composition, which means creating one new
    function from two or more given functions. In the mentioned example, we didn't
    actually compose functions; we only called a function with the result produced
    by another, but in this recipe, we will see how to actually compose functions
    together into a new function. For simplicity, we will only consider unary functions
    (functions that take only one argument).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you go forward, it is recommended that you read the previous recipe,
    *Implementing higher-order functions map and fol*d. It is not mandatory for understanding
    this recipe, but we will refer to the map and fold functions implemented here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compose unary functions into a higher-order function, you should:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For composing two functions, provide a function that takes two functions, `f` and
    `g`, as arguments and returns a new function (a lambda) that returns `f(g(x))`
    where `x` is the argument of the composed function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For composing a variable number of functions, provide a variadic template overload
    of the function described previously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing two unary functions into a new one is relatively trivial. Create a
    template function that we called `compose()` in the earlier examples, with two
    arguments--`f` and `g`--that represent functions, and return a function that takes
    one argument `x` and returns `f(g(x))`. It is important though that the type of
    the value returned by the `g` function is the same as the type of the argument
    of the `f` function. The returned value of the compose function is a closure,
    that is, an instantiation of a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, it is useful to be able to combine more than just two functions
    together. This can be achieved by writing a variadic template version of the `compose()`
    function. Variadic templates are explained in more detail in the *Writing a function
    template with a variable number of arguments* recipe. Variadic templates imply
    compile-time recursion by expanding the parameter pack. This implementation is
    very similar to the first version of `compose()`, except as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes a variable number of functions as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned closure calls `compose()` recursively with the expanded parameter
    pack; recursion ends when only two functions are left, in which case, the previously
    implemented overload is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if the code looks like recursion is happening, this is not true recursion.
    It could be called compile-time recursion, but with every expansion, we get a
    call to another method with the same name but a different number of arguments,
    which does not represent recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have these variadic template overloads implemented, we can rewrite
    the last example from the previous recipe, *Implementing higher-order functions
    map and fold*. Having an initial vector of integers, we map it to a new vector
    with only positive values by applying `std::abs()` on each element. The result
    is then mapped to a new vector by doubling the value of each element. Finally,
    the values in the resulting vector are folded together by adding them to the initial
    value 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composition is usually represented by a dot (`.`) or asterisk (`*`), such as
    `f . g` or `f * g`. We can actually do something similar in C++ by overloading
    `operator*` (it would make little sense to try to overload operator dot). Similar
    to the `compose()` function, `operator*` should work with any number of arguments;
    therefore, we will have two overloads, just like in the case of `compose()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first overload takes two arguments and calls `compose()` to return a new
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second overload is a variadic template function that again calls `operator*`
    by expanding the parameter pack:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now simplify the actual composition of functions by applying `operator*`
    instead of the more verbose call to compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Writing a function template with a variable number of arguments*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniformly invoking anything callable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers, and especially those who implement libraries, sometimes need to
    invoke a callable object in a uniform manner. This can be a function, a pointer
    to a function, a pointer to a member function, or a function object. Examples
    of such cases include `std::bind`, `std::function`, `std::mem_fn`, and `std::thread::thread`.
    C++17 defines a standard function called `std::invoke()` that can invoke any callable
    object with the provided arguments. This is not intended to replace direct calls
    to functions or function objects, but it is useful in template metaprogramming
    for implementing various library functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should be familiar with how to define and use function
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify how `std::invoke()` can be used in different contexts, we will
    use the following function and class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::invoke()` function is a variadic function template that takes the
    callable object as the first argument and a variable list of arguments that are
    passed to the call. `std::invoke()` can be used to call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Free functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Free functions through pointer to function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Member functions through pointer to member function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Data members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Function objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, `std:invoke()` should be used in template meta-programming for
    invoking a function with an arbitrary number of arguments. To exemplify such a
    case, we present a possible implementation for our `std::apply()` function, and
    also a part of the standard library as of C++17 that calls a function by unpacking
    the members of a tuple into the arguments of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we see how `std::invoke()` works, let''s have a short look at how different
    callable objects can be invoked. Given a function, obviously, the ubiquitous way
    of invoking it is directly passing it the necessary parameters. However, we can
    also invoke the function using function pointers. The trouble with function pointers
    is that defining the type of the pointer can be cumbersome. Using `auto` can simplify
    things (as shown in the following code), but in practice, you usually need to
    define the type of the pointer to function first and then define an object and
    initialize it with the correct function address. Here are several examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling through a function pointer becomes more cumbersome when you need to
    invoke a class function through an object that is an instance of the class. The
    syntax for defining the pointer to a member function and invoking it is not simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of how cumbersome this kind of call may look, the actual problem
    is writing library components (functions or classes) that are able to call any
    of these types of callable objects, in a uniform manner. This is what benefits
    in practice from a standard function, such as `std::invoke()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation details of `std::invoke()` are complex, but the way it works
    can be explained in simple terms. Supposing the call has the form `invoke(f, arg1,
    arg2, ..., argN)`, then consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `f` is a pointer to a member function of a `T` class,  then the call is
    equivalent with either:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(arg1.*f)(arg2, ..., argN)`, if `arg1` is an instance of `T`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(arg1.get().*f)(arg2, ..., argN)`, if `arg1` is a specialization of `reference_wrapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`((*arg1).*f)(arg2, ..., argN)`, if it is otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `f` is a pointer to a data member of a `T` class and there is a single argument,
    in other words, the call has the form `invoke(f, arg1)`, then the call is equivalent
    to either:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arg1.*f` if `arg1` is an instance class `T`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arg1.get().*f` if `arg1` is a specialization of `reference_wrapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(*arg1).*f`, if it is otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `f` is a function object, then the call is equivalent to `f(arg1, arg2, ...,
    argN)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Writing a function template with a variable number of arguments*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
