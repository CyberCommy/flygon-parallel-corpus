- en: Understanding Design Patterns and Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the years, software has become increasingly complicated. Now, software
    is not only used for mathematical calculations or simple **create, read, update,
    and delete **(**CRUD**) operations: we are employing it to carry out complex tasks,
    such as controlling rocket engines or managing huge amounts of data every day.
    Businesses from a vast range of sectors have started to adopt software systems,
    including banks, insurance companies, research institutes, education institutes,
    and government agencies. The higher the demand for software, the more people begin
    to build careers in software development. From assembly-language programming,
    came procedural programming, before the introduction of the era of **Object-oriented
    programming** (**OOP**), which is still the most popular model, despite the emergence
    of other types of programming, such as functional programming. OOP has helped
    developers write good, modular software that is easy to maintain and extend. In
    this chapter, we are going to discuss some of the most important design principles
    and patterns that are followed by thousands of developers, and we are going to
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Design principles in software development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different design patterns in software development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creational design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start discussing design principles, let's think about what we mean
    by **design principles **in software development. When we develop software, we
    first design its architecture, and then we start writing its code. We want to
    write our code in such a way that it generates no bugs, or so it is easy to find
    bugs if there are any. We also want the code to be easily understandable when
    we read it and we want it to be structured in such a way that it can be changed
    later if required. Although it is difficult to write the best-possible code, there
    are various principles in software development that have been developed by experienced
    computer scientists. Using these, developers can write very clean code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The software developer Robert C. Martin, also known as Uncle Bob, came up with
    five software design principles. These principles are so effective and helpful
    for developers that they have become a norm in the software industry. Collectively,
    they are known as the SOLID principle, which represents the following different
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S **stands for the **single responsibility principle**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O **stands for the **open-closed principle**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L **stands for the **Liskov substitution principle**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I **stands for the **interface segregation principle**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D **stands for the **dependency inversion principle**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss these principles one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A class should have one, only one reason to change."'
  prefs: []
  type: TYPE_NORMAL
- en: – *Robert C. Martin*
  prefs: []
  type: TYPE_NORMAL
- en: This means that when we write a class, we should design it in such a way that
    it has only one responsibility. You should only need to change the class for one
    reason. If you have multiple reasons to change the class, it is violating the
    single responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: If a class has more than one responsibility and you make changes to a piece
    of code, this might break another piece of code, as they are in the same class
    and share some dependencies. Your code might not be very decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: The open-closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code needs to be written in such a way that adding new things in a software
    entity, such as classes, modules, or functions, is good, but modifying the entity
    itself should not be allowed. This reduces the possibility of bugs being generated.
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Derived types must be completely substitutable for their base types."'
  prefs: []
  type: TYPE_NORMAL
- en: – *Barbara Liskov*
  prefs: []
  type: TYPE_NORMAL
- en: This principle states that when you write a class, if it is derived from another
    class, it should be replaceable with the base class. Otherwise, your code will
    be very fragile and coupled. This principle was first discovered by Barbara Liskov,
    so it is named after her.
  prefs: []
  type: TYPE_NORMAL
- en: The interface segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, developers create large interfaces that contain too much information.
    Many classes might use this interface, but they might not need everything in it.
    This is what you should avoid in order to follow this principle. This principle
    supports small interfaces instead of big interfaces and, if necessary, a class
    can inherit multiple small interfaces that are actually applicable for the class.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"High-level modules should not depend on low-level modules; both should depend
    on abstractions. Abstractions should not depend on details. Details should depend
    upon abstractions"'
  prefs: []
  type: TYPE_NORMAL
- en: – *Robert C. Martin*
  prefs: []
  type: TYPE_NORMAL
- en: We know that, in software development, we work with layers. To make the layers
    decoupled, we have to design the dependencies of these layers in such a way that,
    instead of depending on each other, the layers should depend on abstraction. Therefore,
    if you change something in a high-level module or a low-level module, it won't
    harm the system. When we create these abstractions, we have to design them in
    such a way that they are not dependent on the implementation details. The abstractions
    should be independent and the classes that implement these interfaces or abstract
    classes should depend on those abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OOP, where all things are treated as objects, it's very important to keep
    track of how an object is created and managed. If a developer doesn't pay much
    attention to this topic, the objects of the software could make the software fragile
    and coupled. It's important to maintain the objects appropriately to keep the
    application easily extendable. Creational design patterns are patterns that help
    create objects in a manner where the most common problems regarding object creation
    can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main concepts that exist in creational design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating knowledge about the concrete classes the system uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide creating and combining instances of the concrete classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creational design patterns are classified into object-creational patterns and
    class-creational patterns, in which **object-creational patterns** deal with the
    creation of objects and **class-creational patterns** deal with the discovery
    of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five main creational design patterns in the industry:'
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The definition of this pattern from *Design Patterns: Elements of Reusable
    Object-Oriented* *Software* by the Gang of Four is to provide a combination to
    build families of similar or reliant objects without specifying their concrete
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing that this pattern offers is separation or abstraction
    of object creation. If you are not following any pattern, the simplest thing that
    comes to mind when you are creating an object is to use the `new` keyword and
    create an object wherever you need it. For example, if I need a `Person` object
    in my `Bank` class, the easiest way to do this would be to instantiate a `Person`
    object using a `new` keyword in the `Bank` class. However, using this approach
    sometimes creates complexity in the software. To avoid that, we can use the abstract
    factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern is mainly used in cases where you have objects
    from the same family, or that are related or dependent in some way. The idea is
    to create factory classes to carry out the work of object creation. If an object `A`,
    needs an instance of another object `B`, object `A` should ask the factory of
    object `B` to create an object of `B` and pass it to object `A`. In this way,
    object `A` is independent of the creation of object `B`. Now, in the abstract
    factory pattern, there is another layer of abstraction. The factory classes are
    also abstracted. This means that object `A` won't call the factory of object `B`
    directly, but instead use an abstraction. There should be a mechanism that determines
    which `Factory` class needs to be called. This means that object `A` is not dependent
    on any particular factory of another object.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Separating the plan of a complicated object from its imitation is the main idea
    of the builder pattern. In object-oriented software development, we sometimes
    need to create objects that are quite complex. For example, we might create an
    object that uses other objects, which in turn use other objects. Creating or instantiating
    this kind of object could be difficult when you just need that object to carry
    out another kind of work. It might also make the code more complex and reduce
    its readability.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about an example. Imagine that you are making some burgers, some
    of which are chicken burgers and some of which are beef burgers. When creating
    the chicken burger objects, you have to create a chicken burger patty object,
    a tomato ketchup object, a cheese object, and a bread object every time you create
    a chicken burger object, which leads to messy code. You also have to follow the
    same process when creating a beef burger object. This is a really complex way
    of handling and creating these objects.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern provides a nice way to solve this complexity. Using this
    pattern, we create a class called `Builder` whose main task is to create complex
    objects and return the newly-created object. With the builder pattern, we use
    another type of class, which is normally called the `director` class. The task
    of this class is to call the `Builder` class and get the object from it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's return to our burger example. We can have a `ChickenBurgerBuilder` class
    and a `BeefBurgerBuilder` class. These will set the items, the burger patty, the
    bread, the ketchup, and the cheese, in the class. When the `BurgerDirector` class
    wants to create a `chicken burger`, it will call `ChickenBurgerBuilder`. To create
    a `beef burger`, it will call `BeefBurgerBuilder`. The complexity of creating
    the `burger patty` and the other ingredients will be handled by the `Builder`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The factory method pattern is very similar to the abstract factory pattern.
    The difference is that, in the factory method pattern, the factory layer is not
    abstracted. Using this pattern means that you will create a factory class that
    will handle the creation of classes that implement the same abstraction. This
    means that, if there is an interface that is defined by many subclasses, a `Factory`
    class can create any of those subclasses depending on the logic passed to `Factory`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about an example. We will use the Factory method pattern to solve
    our burger-creating problem from the Builder pattern example we mentioned in the
    section, *The builder Pattern*. We will create a `Factory`, called `BurgerFactory`,
    that will take an input, such as `typeOfBurger` (Chicken or Beef). Then, `BurgerFactory`
    will decide which `Burger` type of object should be created. Let's suppose we
    have an Interface called `Burger` that both `ChickenBurger` and `BeefBurger` implement.
    This means that `BurgerFactory` will return an object of the `Burger` type. The
    client will not be aware which `Burger` Object will be created and returned. By
    using this pattern, we are isolating the client from a specific object, which
    increases the flexibility of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern is used when you want to avoid creating new classes of the
    same type or sub-type using traditional object-creation mechanisms, such as new
    keywords. Put simply, this pattern states that we should clone an object and then
    work with the cloned object as another newly-created object. This way, the traditional
    method of object creation is avoided.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton pattern is a very simple design pattern. It involves creating
    only one object of a class in the whole application. A **singleton object** is
    an object that can't have multiple instances. Whenever a piece of code needs to
    use this singleton object, it won't create a new object; instead, it will use
    the old object that is already available.
  prefs: []
  type: TYPE_NORMAL
- en: This design pattern is applicable when you want to handle some information from
    one source only. The best example of when we might use a singleton pattern is
    in a database connection string. In an application, if there are multiple database
    connections used, the database might get corrupted and cause exceptions in the
    application. Here, it's better to make the connection string a singleton object,
    meaning that only one instance is used for all communication. This reduces the
    chance of discrepancy.
  prefs: []
  type: TYPE_NORMAL
- en: Structural design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the design patterns that are available in software development are
    related to the code structure. These patterns help you to design your code in
    such a way that you will be able to avoid common structural problems. In the *Design
    Patterns: Elements of Reusable Object-Oriented Software* book by the Gang of Four,
    there are seven structural design patterns. In this section, we are just going
    to discuss four of these, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to find out more about the other three, take a look at the book
    *Design Patterns: Elements of Reusable Object-Oriented Software* by the Gang of
    Four. At first, it might be a little confusing to start using these patterns,
    but, as you get more experienced, it will become easier to identify which pattern
    is appropriate for which situation.'
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, when we think of the word adapter, we think about a small device that
    helps us plug our electronic devices into a power socket with a different kind
    of interface on the plug. The adapter design pattern actually does the same thing
    in software code. This design pattern states that, if two modules of a software
    want to communicate with each other, but the interface that one module expects
    is different from the interface that the other module has, instead of changing
    one interface to match the other interface, an adapter should be used. The benefit
    of doing this is that, in the future, if you want your code to talk to another
    interface, you won't have to change your code, but just use another adapter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine you have an Interface, `A`, but the code that you want
    to talk to wants another Interface, `B`. Instead of changing Interface `A` to
    Interface `B`, you use an adapter that converts interface `A` to interface `B`.
    This way, the code that uses interface `A` will not break, and you will be able
    to communicate with the code that asks for interface `B`.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern allows us to add new behaviors to objects dynamically.
    When this new behavior is added to an object, it shouldn't affect any other behavior
    that already exists on that object. This pattern provides a solution when you
    have to add new behaviors to an object at runtime. It also removes the need to
    create subclasses just to add a behavior to a task.
  prefs: []
  type: TYPE_NORMAL
- en: The facade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, if you have complex object relationships, it is hard to map them
    all and use them in your code. The facade pattern states that you should use a
    middle object to deal with the object-relational issues and give the client an
    easy point of contact. Let''s think about an example: when you go to a restaurant
    and order some food, you actually don''t go to each chef or person in the kitchen
    and collect food portions and make your own food; you tell the waiter what food
    you want. You don''t know how the item will be prepared or who will prepare it.
    You have no control over the making of the food, you just know that you will get
    the item that you have asked for. Here, the person taking the order is working
    as a facade. They take your order and ask different people to prepare the item
    you asked for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you ordered a beef burger. You call a `GetBeefBurger()` method
    and the facade will actually call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding methods are not real methods. I just want to give you an idea
    that the work of a facade is actually to hide the complexity from the client.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is very similar to the other structural design patterns that we
    have discussed. If there is a situation in which a piece of code should not call
    another piece of code directly for whatever reason, the proxy pattern can be used.
    The proxy pattern is especially useful when a piece of code doesn't have access
    rights to call another piece of code or when calling a piece of code directly
    is expensive in terms of resources. An example of when we might want to use a
    proxy pattern would be if we wanted to use a third-party library in our application,
    but we don't want our code to call the library directly for security reasons.
    In this case, we can create a proxy and let it communicate with the third-party
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behavioral design patterns are design patterns that deal with communication
    between objects. These design patterns allow your objects to communicate in a
    way that avoids the common issues that developers face related to object behavior.
    There are many patterns in this category:'
  prefs: []
  type: TYPE_NORMAL
- en: The chain-of-responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interpreter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mediator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memento pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template-method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, however, we are only going to talk about the following behavioral
    design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to find out more, refer to the *Design Patterns: Elements of Reusable
    Object-Oriented Software* book by the Gang of Four that we mentioned earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern states that, when an object wants to notify another object or call
    a method of another object, it should use another object instead of doing so directly.
    The object that will establish the communication is known as the command object.
    The command will encapsulate the object that holds the method to be called, the
    method name to be called, and the parameters that are to be passed, if there are
    any. The command pattern helps to decouple the relationship between the invoker
    and the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **observer pattern** is a solution to a problem in which many objects need
    to know when a particular object changes because they might have to update the
    data on their end. One way to do this is that all the objects, or observers, should
    ask the object, or the observable, whether the data has changed. If the data has
    changed in the observable, the observer will do its work. However, if we do this,
    the observers have to ask the observable about data changes very frequently to
    avoid slowing down your application. This requires a lot of resources.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern says that the observable should know the list of the observers
    that want to know about the data changes in the subject and notify each observer
    when the data in the subject is changed. This could be done by calling a method
    of the observers. A good use of this pattern is event and delegate in C#.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at a definition of the strategy pattern from the *Design
    Patterns: Elements of Reusable Object-Oriented Software* book by the Gang of Four:'
  prefs: []
  type: TYPE_NORMAL
- en: For example, a method could have different types of implementations depending
    on which class is using it. The definition, therefore, means that we need to make
    these different algorithms implement a base class or interface so that they belong
    to the same family and can be used interchangeably by the clients. The last part
    of the definition means that this pattern will allow clients to use different
    algorithms without affecting other clients.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we have a class, called `Animal`, that has a few common properties,
    such as `eat`, `walk`, and `noise`. Now, let's say you want to add another property,
    such as `fly`. Most of the animals in your class can fly, but a few can't. You
    could break the `Animal` class into two different classes, such as `AnimalWhichCanFly`
    and `AnimalWhichCantFly`. However, splitting this `Animal` class into two could
    over-complicate things as these animals could have other different attributes
    as well. Instead of using inheritance, therefore, you could use composition, which
    means you can add a property called `fly` in the `Animal` class and use it to
    indicate this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern states that instead of using a fixed type, `fly`, as the
    property type, we should use an interface, such as `IFly`, and then create `subclasses`
    that implement `IFly` and have different algorithms. Then, we can take advantage
    of polymorphism and assign the specific subclass at runtime when the subclasses
    of the `Animal` class are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to apply this on the preceding example. In the `Animal` class, instead
    of using the `Fly` property, we will use `IFly` and then implement different classes
    that implement `IFly`. For example, we create the `CanFly : IFly` and `CannotFly
    : IFly` classes. `CanFly` and `CannotFly` will have different implementations
    of the `Fly` method. If we create a `Dog` class that implements the `Animal` class,
    we will set the `Fly` property as the `CannotFly` class. If we create a `Bird`
    class, we will create an instance of `CanFly` and assign it to the `Fly` property.
    By applying this pattern, we have achieved a less-complicated object structure
    and easily-changeable algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MVC pattern is one of the most popular design patterns in the industry.
    You might have heard about it already, even if you are very new to the industry.
    This pattern is heavily used in web development. Many popular web-development
    frameworks use this design pattern. Some popular frameworks that use the MVC pattern
    are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C#:** ASP.NET MVC Web Framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java:** Spring framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PHP:** Laravel framework, Codeigniter framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ruby:** Rails framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The MVC design pattern states that we should divide a web application into
    three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **model** is the part that will hold the data models or objects and will
    be used in database transactions. **View** refers to the frontend of the application,
    which the users or customers look at. Finally, the **controller** is the part
    that handles all the business logic of the application. All the logic and decision-making
    parts will be in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of the MVC pattern is that your application is decoupled. Your view
    is independent from your business logic and your business logic is independent
    of your data source. This way, you can easily change one part of your application
    without affecting other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development is interesting because it changes all the time. There are
    many ways in which you can develop, design, or code something. None of these can
    be classified as the best way, because your code might need to change depending
    on the situation. However, because software development is a type of engineering,
    there are various rules that will make your software stronger and more reliable.
    Software design principles and design patterns are examples of these kinds of
    rules. Knowing these concepts and applying them to your own situation will make
    your life as a developer much easier.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has hopefully given you an idea of the basics of design patterns
    and shown you where you can look for more information. In the next chapter, we
    will get to know a very powerful and interesting software called Git. Git is a
    version-control system that helps to keep track of software code.
  prefs: []
  type: TYPE_NORMAL
