- en: Redux and Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we learned about React class components, and how to
    migrate from an existing class component-based project to a Hook-based one. Then,
    we learned about the trade-offs between the two solutions, and we discussed when
    and how existing projects should be migrated.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to turn the ToDo application that we created in
    the previous chapter into a Redux application. First, we are going to learn what
    Redux is, including the three principles of Redux. We are also going to learn
    when it makes sense to use Redux in an app, and that it is not appropriate for
    every app. Furthermore, we are going to learn how to handle state with Redux.
    Afterward, we are going to learn how to use Redux with Hooks, and how to migrate
    an existing Redux application to Hooks. Finally, we are going to learn the trade-offs
    of Redux, in order to be able to decide which solution would be best for a certain
    use case. By the end of this chapter, you will fully understand how to write Redux
    applications using Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What Redux is and when and why it should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling state with Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Redux with Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating a Redux application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the trade-offs of Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fairly recent version of Node.js should already be installed (v11.12.0 or
    higher). The `npm` package manager for Node.js also needs to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found on the GitHub repository: [https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-React-Hooks/tree/master/Chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Mm9yoC](http://bit.ly/2Mm9yoC)'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that it is highly recommended that you write the code on your own.
    Do not simply run the code examples that have been provided. It is important that
    write the code yourself in order for you to be able to learn and understand properly.
    However, if you run into any issues, you can always refer to the code example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started with the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What is Redux?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have previously learned, there are two kinds of state in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local** **state**: For example, to handle input field data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global** **state**: For example, to store the currently logged-in user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously in this book, we handled local state by using a State Hook, and more
    complex state (often global state) using a Reducer Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Redux is a solution that can be used to handle all kinds of state in React applications.
    It provides a single state tree object, which contains all application state.
    This is similar to what we did with the Reducer Hook in our blog application.
    Traditionally, Redux was also often used to store local state, which makes the
    state tree very complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux essentially consists of five elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Store**: Contains state, which is an object that describes the full state
    of our application—`{ todos: [], filter: ''all'' }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: Objects that describe a state modification—``{ type: ''FILTER_TODOS'',
    filter: ''completed'' }``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action creators**: Functions that create action objects—`(filter) => ({ type:
    ''FILTER_TODOS'', filter })`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducers**: Functions that take the current `state` value and an `action`
    object, and return a new state—`(state, action) => { ... }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connectors**: Higher-order components that connect an existing component
    to Redux, by injecting the Redux state and action creators as props—`connect(mapStateToProps,
    mapDispatchToProps)(Component)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Redux life cycle, the **Store** contains state, which defines the UI.
    The UI is connected to the Redux store, via **Connectors**. User interactions
    with the UI then trigger **Actions**, which are sent to the **Reducer**. The **Reducer** then
    updates the state in the **Store**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a visualization of the Redux life cycle in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56b43307-68c8-4181-9f8a-1a45e4e65da6.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualization of the Redux life cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have already learned about three of these components: the
    store (state tree), actions, and reducers. Redux is like a more advanced version
    of the Reducer Hook. The difference is that with Redux, we always dispatch state
    to a single reducer, therefore changing a single state. There should not be more
    than one instance of Redux. Through this restriction, we can be sure that our
    whole application state is contained in a single object, which allows us to reconstruct
    the whole application state, just from the Redux store.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result of having a single store containing all state, we can easily debug
    faulty states by saving the Redux store in a crash report, or we can automatically
    replay certain actions during debugging so that we do not need to manually enter
    text and click on buttons, over and over again. Additionally, Redux offers middleware
    that simplifies how we deal with asynchronous requests, such as fetching data
    from a server. Now that we understand what Redux is, in the next section, we will
    learn the three fundamental principles of Redux.
  prefs: []
  type: TYPE_NORMAL
- en: The three principles of Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Redux API is very small, and actually only consists of a handful of functions.
    What makes Redux so powerful is a certain set of rules that are applied to your
    code when using the library. These rules allow for the writing of scalable applications
    that are easy to extend, test, and debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux is based on three fundamental principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Single source of truth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State changes are processed with pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single source of truth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This Redux principle states that data should always have a single source of
    truth. This means that global data comes from a single Redux store, and local
    data comes from, for example, a certain State Hook. Each kind of data only has
    a single source. As a result, applications become easier to debug, and are less
    prone to errors.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Redux, it is not possible to modify the application state directly. It
    is only possible to change the state by dispatching actions. This principle makes
    state changes predictable: if no action happened, the application state will not
    change. Furthermore, actions are processed one at a time, so we do not have to
    deal with race conditions. Finally, actions are plain JavaScript objects, which
    makes them easy to serialize, log, store, or replay. As a result, debugging and
    testing a Redux application becomes very easy to do.'
  prefs: []
  type: TYPE_NORMAL
- en: State changes are processed with pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions are functions that, given the same input, will always return
    the same output. Reducer functions in Redux are pure, so, given the same state
    and action, they will always return the same new state.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following reducer is an impure function, because calling the
    function multiple times with the same input results in a different output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn this reducer into a pure function, we have to make sure it does not
    depend on an outside state, and only uses its arguments for the computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using pure functions for reducers makes them predictable, and easy to test
    and debug. With Redux, we need to be careful to always return a new state, and
    not modify the existing one. So, for example, we cannot use `Array.push()` on
    an array state, as it would modify the existing array; we have to use `Array.concat()`
    in order to create a new array. The same goes for objects, where we have to use
    rest/spread syntax to create new objects, instead of modifying existing ones.
    For example, `{ ...state, completed: true }`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the three fundamental principles of Redux, we
    can move on to using Redux in practice, by implementing state handling with Redux
    in our ToDo application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling state with Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State management with Redux is actually really similar to using a Reducer Hook.
    We first define the state object, then actions, and finally, our reducers. An
    additional pattern in Redux is to create functions that return action objects,
    so-called action creators. Furthermore, we need to wrap our whole app with a `Provider`
    component, and connect components to the Redux store in order to be able to use
    Redux state and action creators.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we have to install Redux, React Redux, and Redux Thunk. Let us
    look at what each one does individually:'
  prefs: []
  type: TYPE_NORMAL
- en: Redux itself just deals with JavaScript objects, so it provides the store, deals
    with actions and action creators, and handles reducers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Redux provides connectors in order to connect Redux to our React components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux Thunk is a middleware that allows us to deal with asynchronous requests
    in Redux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using **Redux** in combination with **React** offloads global state management
    to **Redux**, while **React** deals with rendering the application and local state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/57db1dda-569a-49f4-848a-935ea4c4f55c.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustration of how React and Redux work together
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Redux and React Redux, we are going to use `npm`. Execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that all of the required libraries are installed, we can start setting up
    our Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Defining state, actions, and reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in developing a Redux application is defining the state, then
    the actions that are going to change the state, and finally, the reducer functions,
    which carry out the state modification. In our ToDo application, we have already
    defined the state, the actions, and the reducers, in order to use the Reducer
    Hook. Here, we simply recap what we defined in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The full state object of our ToDo app consists of two keys: an array of todo
    items, and a string, which specifies the currently selected `filter` value. The
    initial state looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in Redux, the state object contains all of the state that is
    important to our app. In this case, the application state consists of an array
    of `todos` and a `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our app accepts the following five actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FETCH_TODOS`: To fetch a new list of todo items—`{ type: ''FETCH_TODOS'',
    todos: [] }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD_TODO`: To insert a new todo item—`{ type: ''ADD_TODO'', title: ''Test
    ToDo app'' }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOGGLE_TODO`: To toggle the `completed` value of a todo item—`{ type: ''TOGGLE_TODO'',
    id: ''xxx'' }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REMOVE_TODO`: To remove a todo item—`{ type: ''REMOVE_TODO'', id: ''xxx''
    }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILTER_TODOS`: To filter todo items—`{ type: ''FILTER_TODOS'', filter: ''completed''
    }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We defined three reducers—one for each part of our state—and an app reducer
    to combine the other two reducers. The filter reducer waits for a `FILTER_TODOS`
    action, and then sets the new filter accordingly. The todos reducer listens to
    the other todo-related actions, and adjusts the todos array by adding, removing,
    or modifying elements. The app reducer then combines both reducers, and passes
    actions down to them. After defining all the elements that are needed to create
    a Redux application, we can now set up the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Redux store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to keep things simple initially, and to show how Redux works, we are
    not going to use connectors for now. We are simply going to replace the `state`
    object, and the `dispatch` function that was previously provided by a Reducer
    Hook, with Redux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up the Redux store now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/App.js`, and import the `useState` Hook, as well as the `createStore`
    function from the Redux library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the import statements and before the `App` function definition, we are
    going to initialize the Redux store. We start by defining the initial state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to use the `createStore` function in order to define the
    Redux store, by using the existing `appReducer` function and passing the `initialState` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Please note that in Redux, it is not best practice to initialize the state by
    passing it to `createStore`. However, with a Reducer Hook, we need to do it this
    way. In Redux, we usually initialize state by setting default values in the reducer
    functions. We are going to learn more about initializing state via Redux reducers
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can get the `dispatch` function from the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is removing the following Reducer Hook definition within the
    `App` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is replaced with a simple State Hook, which is going to store our Redux
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define an Effect Hook, in order to keep the State Hook in sync
    with the Redux store state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the app still runs in exactly the same way as before. Redux works
    very similarly to the Reducer Hook, but with more functionality. However, there
    are slight differences in how actions and reducers should be defined, which we
    are going to learn about in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code can be found in the `Chapter12/chapter12_1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Defining action types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step when creating a full Redux application is to define so-called
    action types. They will be used to create actions in action creators and to handle
    actions in reducers. The idea here is to avoid making typos when defining, or
    comparing, the `type` property of actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the action types now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/actionTypes.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define and export the following constants in the newly created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined our action types, we can start using them in action
    creators and reducers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining action creators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After defining the action types, we need to define the actions themselves.
    In doing so, we are going to define the functions that will return the action
    objects. These functions are called action creators, of which there are two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous** **action creators**: These simply return an action object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous** **action creators**: These return an `async` function, which
    will later dispatch an action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to start by defining synchronous action creators, then we are going
    to learn how to define asynchronous action creators.
  prefs: []
  type: TYPE_NORMAL
- en: Defining synchronous action creators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already defined the action creator functions earlier, in `src/App.js`.
    We can now copy them from our `App` component, making sure that we adjust the
    `type` property in order to use the action type constants, instead of a static
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the synchronous action creators now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/actions.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import all action types, which we are going to need to create our actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define and export our action creator functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, synchronous action creators simply create and return action objects.
  prefs: []
  type: TYPE_NORMAL
- en: Defining asynchronous action creators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is defining an asynchronous action creator for the `fetchTodos`
    action. Here, we are going to use the `async`/`await` construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to use an `async` function to define the `fetchTodos` action
    creator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/actions.js`, first import the `FETCH_TODOS` action type and the `fetchAPITodos`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define a new action creator function, which will return an `async` function
    that is going to get the `dispatch` function as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `async` function, we are now going to call the API function, and `dispatch`
    our action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, asynchronous action creators return a function that will dispatch
    actions at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for us to be able to use asynchronous action creator functions in Redux,
    we are going to need to load the `redux-thunk` middleware. This middleware checks
    if an action creator returned a function, rather than a plain object, and if that
    is the case, it executes that function, while passing the `dispatch` function
    to it as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s adjust the store to allow for asynchronous action creators now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/configureStore.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `createStore` and `applyMiddleware` functions from Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, import the `thunk` middleware and `appReducer` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the store and apply the `thunk` middleware to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we export the `store`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using the `redux-thunk` middleware, we can now dispatch functions that will
    later dispatch actions, which means that our asynchronous action creator is going
    to work fine now.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously mentioned, Redux reducers differ from Reducer Hooks in that they
    have certain conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: Each reducer needs to set its initial state by defining a default value in the
    function definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each reducer needs to return the current state for unhandled actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now going to adjust our existing reducers so that they follow these conventions.
    The second convention is already implemented, because we defined a single app
    reducer earlier, in order to avoid having multiple dispatch functions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the initial state in Redux reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we are going to focus on the first convention—to set the initial state
    by defining a default value in the function arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/reducers.js` and import the `combineReducers` function from Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, rename `filterReducer` to `filter`, and set a default value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit `todosReducer` and repeat the same process there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are going to use the `combineReducers` function to create our `appReducer`
    function. Instead of creating the function manually, we can now do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Redux reducers are very similar to Reducer Hooks. Redux even
    provides a function that allows us to combine multiple reducer functions into
    a single app reducer!
  prefs: []
  type: TYPE_NORMAL
- en: Connecting components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to introduce connectors and container components. In Redux we
    can use the `connect` higher-order component to connect existing components to
    Redux, through injecting state and action creators as props into them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux defines two different kinds of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentational** **components**: React components, as we have been defining
    them until now'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container** **components**: React components that connect presentational
    components to Redux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Container components use a connector to connect Redux to a presentational component.
    This connector accepts two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mapStateToProps(state)`: Takes the current Redux state, and returns an object
    of props to be passed to the component; used to pass state to the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapDispatchToProps(dispatch)`: Takes the `dispatch` function from the Redux
    store, and returns an object of props to be passed to the component; used to pass
    action creators to the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are now going to define container components for our existing presentational
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new `src/components/` folder for all our presentational components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we copy all of the existing component files to the `src/components/`
    folder, and adjust the import statements for the following files: `AddTodo.js`,
    `App.js`, `Header.js`, `TodoFilter.js`, `TodoItem.js`, and `TodoList.js`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connecting the AddTodo component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to start connecting our components to the Redux store. The
    presentational components can stay the same as before. We only create new components—container
    components—that wrap the presentational components, and pass certain props to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect the `AddTodo` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/containers/` folder for all our container components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `src/containers/ConnectedAddTodo.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, we import the `connect` function from `react-redux`, and the
    `bindActionCreators` function from `redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we import the `addTodo` action creator and the `AddTodo` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to define the `mapStateToProps` function. Since this component
    does not deal with any state from Redux, we can simply return an empty object
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the `mapDispatchToProps` function. Here we use `bindActionCreators`
    to wrap the action creator with the `dispatch` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is essentially the same as manually wrapping the action creators,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the `connect` function to connect the `AddTodo` component to
    Redux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `AddTodo` component is successfully connected to the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the TodoItem component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we are going to connect the `TodoItem` component, so that we can use it
    in the `TodoList` component in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect the `TodoItem` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/containers/ConnectedTodoItem.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, we import the `connect` function from `react-redux`, and the `bindActionCreators` function
    from `redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we import the `toggleTodo` and `removeTodo` action creators, and the `TodoItem` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we only return an empty object from `mapStateToProps`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we bind two action creators to the `dispatch` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we connect the component, and export it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `TodoItem` component is successfully connected to the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the TodoList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After connecting the `TodoItem` component, we can now use the `ConnectedTodoItem`
    component in the `TodoList` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect the `TodoList` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/components/TodoList.js`, and adjust the import statement as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, rename the component that is returned from the function to `ConnectedTodoItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a new `src/containers/ConnectedTodoList.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, we import only the `connect` function from `react-redux`, as
    we are not going to bind the action creators this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we import the `TodoList` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define the `mapStateToProps` function. This time, we use destructuring
    to get `todos` and `filter` from the `state` object, and return them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `mapDispatchToProps` function, where we only return an
    empty object, since we are not going to pass any action creators to the `TodoList`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we connect and export the connected `TodoList` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `TodoList` component is successfully connected to the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the TodoList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have connected the `TodoList` component, we can move the filter
    logic from the `App` component to the `TodoList` component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `useMemo` Hook in `src/components/TodoList.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `src/components/App.js`, and remove the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit `src/components/TodoList.js`, and add the `filteredTodos` code here.
    Please note that we removed the destructuring from the state object, as the component
    already receives the `filter` and `todos` values as props. We also adjusted the
    dependency array accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, our filtering logic is in the `TodoList` component, instead of the `App`
    component. Let's move on to connecting the rest of our components.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the TodoFilter component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up is the `TodoFilter` component. Here, we are going to use both `mapStateToProps`
    and `mapDispatchToProps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect the `TodoFilter` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/containers/ConnectedTodoFilter.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, we import the `connect` function from `react-redux` and the `bindActionCreators` function
    from `redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we import the `filterTodos` action creator and the `TodoFilter` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We use destructuring to get the `filter` from our `state` object, and then
    we return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we bind and return the `filterTodos` action creator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we connect the component and export it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `TodoFilter` component is successfully connected to the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only component that still needs to be connected now, is the `App` component.
    Here, we are going to inject the `fetchTodos` action creator, and update the component
    so that it uses the connected versions of all the other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect the `App` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/components/App.js`, and adjust the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, adjust the following components that are returned from the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create the connected component. Create a new `src/containers/ConnectedApp.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this newly created file, we import the `connect` function from `react-redux`,
    and the `bindActionCreators` function from `redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we import the `fetchTodos` action creator, and the `App` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We already deal with the various parts of our state in other components, so
    there is no need to inject any state into our `App` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we bind and return the `fetchTodos` action creator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we connect the `App` component and export it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `App` component is successfully connected to the Redux store.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Provider component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we have to set up a `Provider` component, which is going to provide
    a context for the Redux store, which will be used by the connectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up the `Provider` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/index.js`, and import the `Provider` component from `react-redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, import the `ConnectedApp` component from the `containers` folder and import
    the Redux store that was created by `configureStore.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, adjust the first argument to `ReactDOM.render`, by wrapping the `ConnectedApp`
    component with the `Provider` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our application will work in the same way as before, but everything is
    connected to the Redux store! As we can see, Redux requires a bit more boilerplate
    code than simply using React, but it comes with a lot of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier handling of asynchronous actions (using the `redux-thunk` middleware)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized action handling (no need to define action creators in the components)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful functions for binding action creators and combining reducers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced possibilities for errors (for example, by using action types, we can
    ensure that we did not make a typo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are also disadvantages, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A lot of boilerplate code is required (action types, action creators, and connected
    components)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping of state/action creators in separate files (not in the components, where
    they are needed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first point is an advantage and disadvantage at the same time; action types
    and action creators do require more boilerplate code, but they also make it easier
    to update action-related code at a later stage. The second point, and the boilerplate
    code that is required for the connected components, can be solved by using Hooks
    to connect our components to Redux. We are going to use Hooks with Redux in the
    next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code can be found in the `Chapter12/chapter12_2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Using Redux with Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After turning our todo application into a Redux-based application, we are now
    using higher-order components, instead of Hooks, in order to get access to the
    Redux state and action creators. This is the traditional way to develop a Redux
    application. However, in the latest versions of Redux, it is possible to use Hooks
    instead of higher-order components! We are now going to replace the existing connectors
    with Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Even with Hooks, the `Provider` component is still required in order to provide
    the Redux store to other components. The definition of the store and the provider
    can stay the same when refactoring from `connect()` to Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of React Redux offers various Hooks as an alternative to
    the `connect()` higher-order component. With these Hooks, you can subscribe to
    the Redux store, and dispatch actions without having to wrap your components.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dispatch Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `useDispatch` Hook returns a reference to the `dispatch` function that
    is provided by the Redux store. It can be used to dispatch actions that are returned
    from action creators. Its API looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We are now going to use the Dispatch Hook to replace the existing container
    components with Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to migrate your whole Redux application at once in order to
    use Hooks. It is possible to selectively refactor certain components—meaning that
    they will use Hooks—while still using `connect()` for other components.
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to use the Dispatch Hook, let's move on to migrating our
    existing components so that they use the Dispatch Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks for the AddTodo component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned about the Dispatch Hook, let's see it in action by
    implementing it in our `AddTodo` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s migrate the `AddTodo` component to Hooks now:'
  prefs: []
  type: TYPE_NORMAL
- en: First delete the `src/containers/ConnectedAddTodo.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `src/components/AddTodo.js` file and import the `useDispatch` Hook
    from `react-redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, import the `addTodo` action creator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can remove the props from the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the Dispatch Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, adjust the handler function and call `dispatch()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all that is left to do is to replace the `ConnectedAddTodo` component
    with the `AddTodo` component in `src/components/App.js`. First, adjust the import
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, adjust the rendered component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our app still works in the same way as before, but we are now
    using Hooks in order to connect the component to Redux!
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks for the App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we are going to update our `App` component so that it directly dispatches
    the `fetchTodos` action. Let''s migrate the `App` component to Hooks now:'
  prefs: []
  type: TYPE_NORMAL
- en: First delete the `src/containers/ConnectedApp.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `src/components/App.js` file and import the `useDispatch` Hook
    from `react-redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, import the `fetchTodos` action creator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can remove the props from the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the Dispatch Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, adjust the Effect Hook and call `dispatch()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all that is left to do is to replace the `ConnectedApp` component with
    the `App` component in `src/index.js`. First, adjust the import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, adjust the rendered component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, using Hooks is much simpler and more concise than defining a
    separate container component.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks for the TodoItem component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to upgrade the `TodoItem` component to use Hooks. Let''s
    migrate it now:'
  prefs: []
  type: TYPE_NORMAL
- en: First delete the `src/containers/ConnectedTodoItem.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `src/components/TodoItem.js` file, and import the `useDispatch` Hook
    from `react-redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, import the `toggleTodo` and `removeTodo` action creators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can remove the action creator-related props from the function definition.
    The new code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the Dispatch Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, adjust the handler functions to call `dispatch()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all that is left to do is to replace the `ConnectedTodoItem` component
    with the `TodoItem` component in `src/components/TodoList.js`. First, adjust the
    import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, adjust the rendered component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Now the `TodoItem` component uses Hooks instead of a container component. Next,
    we are going to learn about the Selector Hook.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Selector Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another very important Hook that is provided by Redux is the Selector Hook.
    It allows us to get data from the Redux store state, by defining a selector function.
    The API for this Hook is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`selectorFn` is a function that works similarly to the `mapStateToProps` function.
    It will get the full state object as its only argument. The selector function
    gets executed whenever the component renders, and whenever an action is dispatched
    (and the state is different than the previous state).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that returning an object with multiple parts of the
    state from one Selector Hook will force a re-render every time an action is dispatched.
    If multiple values from the store need to be requested, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use multiple Selector Hooks, each one returning a single field from the state
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `reselect`, or a similar library, to create a memoized selector (we are
    going to cover this in the next section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `shallowEqual` function from `react-redux` as `equalityFn`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now going to implement the Selector Hook in our ToDo application, specifically
    in the `TodoList` and `TodoFilter` components.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks for the TodoList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we are going to implement a Selector Hook to get all `todos` for the
    `TodoList` component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First delete the `src/containers/ConnectedTodoList.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `src/components/TodoList.js` file, and import the `useSelector` Hook
    from `react-redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can remove all the props from the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define two Selector Hooks, one for the `filter` value, and one for
    the `todos` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all that is left to do is to replace the `ConnectedTodoList` component
    with the `TodoList` component in `src/components/App.js`. First, adjust the import
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, adjust the rendered component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the component can stay the same, because the values where we store
    the parts of the state have the same names as before.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks for the TodoFilter component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we are going to implement both the Selector and Dispatch Hooks in the
    `TodoFilter` component, because we need to highlight the current filter (state
    from the Selector Hook) and dispatch an action to change the filter (the Dispatch
    Hook).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement Hooks for the `TodoFilter` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: First, delete the `src/containers/ConnectedTodoFilter.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also delete the `src/containers/` folder, as it is empty now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `src/components/TodoFilter.js` file, and import the `useSelector`
    and `useDispatch` Hooks from `react-redux`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, import the `filterTodos` action creator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can remove all the props from the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the Dispatch and Selector Hooks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, adjust the handler function to call `dispatch()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all that is left to do is to replace the `ConnectedTodoFilter` component
    with the `TodoFilter` component in `src/components/App.js`. First, adjust the
    import statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, adjust the rendered component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Now, our Redux application makes full use of Hooks instead of container components!
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code can be found in the `Chapter12/chapter12_3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When defining selectors as we have done until now, a new instance of the selector
    is created every time the component is rendered. This is fine, if the selector
    function does not do any complex operations and does not maintain internal state.
    Otherwise, we need to use reusable selectors, which we are going to learn about
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up reselect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create reusable selectors, we can use the `createSelector` function
    from the `reselect` library. First, we have to install the library via `npm`.
    Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `reselect` library has been installed, and we can use it to create
    reusable selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Memoizing selectors that only depend on state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to memoize selectors, and the selector only depends on the state
    (not props), we can declare the selector outside of the component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `src/components/TodoList.js` file, and import the `createSelector`
    function from `reselect`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define selectors for the `todos` and `filter` parts of the state,
    before the component definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: If selectors are used by many components, it might make sense to put them in
    a separate `selectors.js` file, and import them from there. For example, we could
    put the `filterSelector` in a separate file, and then import it in `TodoList.js`,
    as well as `TodoFilter.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we define a selector for the filtered todos, before the component is defined,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we specify the other two selectors that we want to reuse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we specify a filtering selector, copying the code from the `useMemo` Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use our defined selector in the Selector Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined a reusable selector for the filtered todos, the result
    of filtering the todos will be memoized, and will not be re-computed if the state
    did not change.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code can be found in the `Chapter12/chapter12_4` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Just run `npm install` in order to install all dependencies and `npm start` to
    start the application, then visit `http://localhost:3000` in your browser (if
    it did not open automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Using the store Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Redux also provides a `useStore` Hook, which returns a reference to the
    Redux store itself. This is the same `store` object that was passed to the `Provider`
    component. Its API looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: It is best practice to avoid using the Store Hook directly. It usually makes
    more sense to use Dispatch or Selector Hooks instead. However, there are special
    use cases, such as replacing reducers, where using this Hook may be required.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to replace connectors with Hooks in existing
    Redux applications. Now, we are going to learn a strategy that will allow us to
    effectively migrate existing Redux applications to Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a Redux application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some Redux applications, local state was also stored in the Redux state
    tree. In others, React class component state was used to store local state. In
    either case, the way to migrate an existing Redux application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace **simple local state**, such as input field values, with State Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace **complex local state** with Reducer Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep **global state** (state that is used across multiple components) in the
    Redux store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already learned how to migrate React class components in the previous
    chapter. In the previous section, we learned how to migrate from Redux connectors
    to using Selector and Dispatch Hooks. We are now going to show an example of migrating
    Redux local state to a Hook-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us assume that our existing todo application stores the input field state
    in Redux, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Right now, whenever text is entered, we need to dispatch an action, compute
    the new state by calling all reducers, and then update the Redux store state.
    As you can imagine, this can get quite performance heavy if we have many input
    fields. Instead of storing the `newTodo` field in Redux, we should use a State
    Hook to store this local state, as it is only used internally by one component. We
    have already done this correctly during the implementation of the `AddTodo` component
    in our example app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to migrate existing Redux applications to Hooks,
    we can move on to discussing the trade-offs of Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs of Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To wrap up, let us summarize the pros and cons of using Redux in a web application.
    First, let us start with the positives:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides a certain project structure that allows us to easily extend and modify
    code later on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fewer possibilities for errors in our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better performance than using React Context for state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes the `App` component much simpler (offloads state management and action
    creators to Redux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux is a perfect fit for larger projects that deal with complex state changes,
    and state that is used across many components.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are also downsides to using Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing boilerplate code required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure becomes more complicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux requires a wrapper component (`Provider`) to connect the app to the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, Redux should not be used for simple projects. In these cases, a
    Reducer Hook might be enough. With a Reducer Hook, there is no need for wrapper
    components in order to connect our app to the state store. Furthermore, if we
    use multiple Reducer Hooks, it is slightly more performant to send actions to
    a specific reducer, instead of a global app reducer. However, the downside lies
    in having to deal with multiple dispatch functions, and keeping the various states
    synchronized. We also cannot use middleware, including support for asynchronous
    actions, with a Reducer Hook. If state changes are complex but only local to a
    certain component, it might make sense to use a Reducer Hook, but if the state
    is used throughout multiple components, or it is relevant for the whole app, we
    should definitely store it in Redux.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might not need Redux if your component does not do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save or load state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share state with other non-child components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In that case, it makes sense to use a State or Reducer Hook, instead of Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we first learned what Redux is, as well as when and why it should
    be used. Then, we learned about the three principles of Redux. Next, we used Redux
    in practice to handle state in our ToDo application. We also learned about synchronous
    and asynchronous action creators. Then, we learned how to use Redux with Hooks,
    and how to migrate an existing Redux application to a Hook-based solution. Finally,
    we learned about the trade-offs of using Redux and Reducer Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we are going to learn about handling state with
    MobX. We are going to learn what MobX is and how to use it the traditional way
    with React. Then, we are going to learn how to use MobX with Hooks, and we will
    also understand how to migrate an existing MobX application to a Hook-based solution.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to recap what we have learned in this chapter, try to answer the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What kind of state should Redux be used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which elements does Redux consist of?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three principles of Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we define action types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we connect components to Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Hooks can we use with Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we create reusable selectors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we migrate a Redux application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the trade-offs of Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should we use Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following reading material:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning Redux*, published by *Packt: *[ https://www.packtpub.com/web-development/learning-redux](https://www.packtpub.com/web-development/learning-redux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official Redux docs: [https://redux.js.org](https://redux.js.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official React-Redux docs: [https://react-redux.js.org/](https://react-redux.js.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about Hooks and Redux: [https://react-redux.js.org/next/api/hooks](https://react-redux.js.org/next/api/hooks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reselect library on GitHub: [https://github.com/reduxjs/reselect](https://github.com/reduxjs/reselect)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
