- en: Chapter 11. Sound Effects, File I/O, and Finishing the Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are nearly there. This short chapter will demonstrate how we can easily manipulate
    files stored on the hard drive using the C++ standard library, and we will also
    add sound effects. Of course, we know how to add sound effects, but we will discuss
    exactly where in the code the calls to `play` will go. We will also tie up a few
    loose-ends to make the game complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading the high score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the player to level up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create never-ending multiple waves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading the high-score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File I/O, or input/output, is a fairly technical subject. Fortunately for us,
    as it is such a common requirement in programming, there is a library that handles
    all the complexity for us. As with concatenating strings for our HUD, it is the
    **Standard Library** that provides the necessary functionality through `fstream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include `fstream` in the same way we included `sstream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, add a new folder in the `ZombieArena/ZombieArena` folder called `gamedata`.
    Next, right-click in this folder and create a new file called `scores.txt`. It
    is in this file that we will save the player's high-score. You could open the
    file and add a score to it. If you do, make sure it is quite a low score so we
    can easily test whether beating that score results in the new score being added.
    Be sure to close the file once you are done with it or the game will not be able
    to access it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next code, we create an `ifstream` object called `InputFile` and send
    the folder and file we just created as a parameter to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if(InputFile.is_open())` code checks that the file exists and is ready
    to read from. We then put the contents of the file into `hiScore` and close the
    file. Add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we handle saving a potentially new high-score. Within the block that handles
    the player''s health being less than or equal to zero, we create an `ofstream`
    object called `outputFile`, write the value of `hiScore` to the text file, and
    then close the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can play the game and your high-score will be saved. Quit the game and notice
    that your high-score is still there if you play it again.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make some noise.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create all the `SoundBuffer` and `Sound` objects that
    we need to add a range of sound effects to the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the required SFML includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go ahead and add the seven `SoundBuffer` and `Sound` objects which load
    and prepare the seven sound files that we prepared in [Chapter 6](ch06.html "Chapter 6. 
    Object-Oriented Programming, Classes, and SFML Views"): *Object-Oriented Programming,
    Classes, and SFML Views*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now the seven sound effects are ready to play. We just need to work out where
    in our code each of the calls to the `play` function will go.
  prefs: []
  type: TYPE_NORMAL
- en: Leveling up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next code we will add enables the player to level-up between waves. Because
    of the work we have already done that makes, this is straightforward to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code in the `LEVELING_UP` state where we handle player
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The player can now level-up each time a wave of zombies is cleared. We can't,
    however, increase the number of zombies or the size of the level yet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the `LEVELING_UP` state, right after the code we have just
    added, amend the code that runs when the state changes from `LEVELING_UP` to `PLAYING`.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the code in full. I have highlighted the lines that are either new or
    have been slightly amended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add or amend the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous code starts by incrementing the `wave` variable. Then the code
    is amended to make the number of zombies and size of the arena relative to the
    new value of `wave`. Finally, we add the call to `powerup.play()` to play the
    leveling up sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already determine the size of the arena and the number of zombies by the
    value of the `wave` variable. We must also reset the ammo, gun, `wave`, and `score`
    to zero at the start of each new game. Find the following code in the event handling
    section of the game loop and add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we can play the game, the player can get ever more powerful and the zombies
    will get ever more numerous within an arena of increasing size - until he dies
    then it all starts again.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the rest of the sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will add the rest of the calls to the `play` function. We deal with each
    of them individually as locating exactly where they go is key to playing them
    at the right moment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects while the player is reloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the highlighted code in three places to play the appropriate `reload` or
    `reloadFailed` sound when the player presses the ***R*** key to attempt to reload
    their gun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Make a shooting sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the highlighted call to `shoot.play()` near the end of the code that handles
    the player clicking the left mouse button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Play a sound when the player is hit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this next code, we wrap the call to `hit.play` in a test to see whether the
    `player.hit` function returns `true`. Remember that the `player.hit` function
    tests to see whether a hit has been recorded in the previous 100 milliseconds.
    This will have the effect of playing a fast, repeating, thudding sound, but not
    so fast that the sound blurs into one noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the call to `hit.play`, as highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Play a sound when getting a pickup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the player picks up a health pickup, we will play the regular pickup sound,
    but when the player gets an ammo pickup we play the reload sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the two calls to play sounds as highlighted here, within the appropriate
    collision detection code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Make a splat sound when a zombie is shot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a call to `splat.play` at the end of the section of code that detects a
    bullet colliding with a zombie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now play the completed game and watch the number of zombies and the
    arena increase with each wave. Choose your level-ups carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make a splat sound when a zombie is shot](img/image_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions that might be on your mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Q) Despite using classes, I am finding that the code is getting really long
    and unmanageable, again.
  prefs: []
  type: TYPE_NORMAL
- en: A) One of the biggest issues is the structure of our code. As we learn more
    C++, we will also learn ways to make the code more manageable and generally less
    lengthy.
  prefs: []
  type: TYPE_NORMAL
- en: Q) The sound effects seem a bit flat and unrealistic. How can they be improved?
  prefs: []
  type: TYPE_NORMAL
- en: A) One way to significantly improve the feeling the player gets from sound is
    to make the sound directional, as well as change the volume based on the distance
    from the sound source to the player character. We will use SFML's advanced sound
    features in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are finished with the Zombie Arena game. It has been quite a journey. We
    have learned a whole bunch of C++ fundamentals such as references, pointers, OOP,
    and classes. In addition, we have used SFML for managing cameras, vertex arrays,
    and collision detection as well. We learned how to use sprite sheets to reduce
    the number of calls to `window.draw` and speed up the frame rate. Using C++ pointers,
    the STL, and a little bit of OOP, we built a singleton class to manage our textures
    and in the next project we will extend this idea to manage all of our game's assets.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up in the closing project of the book we will discover particle effects,
    directional sound, and split-screen multiplayer gaming. In C++, we will encounter
    inheritance, polymorphism, and a few more new concepts as well.
  prefs: []
  type: TYPE_NORMAL
