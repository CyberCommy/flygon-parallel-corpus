- en: Chapter 8. Contracts and Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Store applications run in a tight sandbox known as **AppContainer**.
    This container does not allow applications to communicate directly with other
    applications on the machine (such as Win32 kernel object handles and shared memory).
    This makes sense in a way, because an app can't assume anything about the computing
    environment in which it's installed from the Store, except for the CPU architecture
    and capabilities that were requested by the app. There's no way to know for sure
    that an app exists, for instance, and even if there was a way, there's no good
    way to make sure it can actually talk to this app.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, Windows defines a set of contracts for app to app communication. Such
    contracts allow applications to implement some functionality without knowing which
    other app is going to use it. The contracts are well defined, and with the help
    of the operating system to make the necessary connections, they allow apps to
    communicate indirectly. We'll examine some of the common contracts in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Applications can also provide "plugins" into some of the operating system's
    provided functionality. These "plugins" are called extensions, and we'll take
    a look at one of them, the Settings extension.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Store apps cannot directly communicate with other apps, but what about
    the system itself? What about files, folders, or devices? It turns out that, by
    default, these are also restricted, and must be given permission by the user at
    the application install time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications must declare all intended system usage that is defined by Windows,
    as something the user must agree to. These are **capabilities** , and are part
    of the application manifest. Visual Studio provides a graphical view of capabilities
    in its manifest view which we have already used in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capabilities](img/5022_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The image shows all currently supported capabilities. By default, just one
    capability is enabled: the ability to make outbound network calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the user's "My" libraries (documents, pictures, videos, and music)
    must be explicitly requested, otherwise an "access denied" exception will be thrown
    upon access; the Documents library also demands the app specifies which file types
    it accepts.
  prefs: []
  type: TYPE_NORMAL
- en: Device access is naturally an issue, represented by capabilities such as **Microphone**,
    **Webcam**, **Location**, and **Proximity**.
  prefs: []
  type: TYPE_NORMAL
- en: Note, that there is no capability that can grant an application access to Windows
    system folders, such as `Program Files`, `System32`, and so on; this is simply
    beyond a Windows Store app—and so it should be. No app should need such high privilege
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contracts are defined by Windows for app to app communication; it's a kind of
    agreement between apps, mediated by the operating system, that allows apps to
    communicate indirectly. Let's look at two common examples of contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Share contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **share contract** operates between an app that is a **share source** (has
    something to share) and a **share target** app (that wants to do something with
    the shared data). An application can be a share source, a share target, or both.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing is usually initiated by using the Share charm. When activated from a
    share source app, a list of possible target apps is provided by Windows—all the
    installed apps that implement the share target contract, and accept at least one
    of the data types provided by the source. Let's see how to create a share source
    and a share target.
  prefs: []
  type: TYPE_NORMAL
- en: Share source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Becoming a share source is easier than being a share target. A share source
    needs to notify Windows of any potential data it can provide. Most of the work
    required for share resides in the `Windows::ApplicationMode::DataTransfer` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'A share source must register for the `DataTransferManager::DataRequested` event
    when the application or the main page initializes, with code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code registers the `OnDataRequested` private method as the handler that
    is invoked by the Share Broker Windows component that manages the sharing operation.
    When the method is called, the application needs to provide the data. Here''s
    a simple app that shows the flags of the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Share source](img/5022_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This app wants to share a selected flag image and some text, being the name
    of the selected country. The `OnDataRequested` method is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the method does is check whether any flag is selected (`_gridFlags`
    is a `GridView` holding all flags). If nothing is selected then the method simply
    exits. If the user tries to share when nothing is selected, Windows displays a
    message, **There's nothing to share right now**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s possible to set another text line to indicate to the user the exact reason
    why sharing was unavailable. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `DataRequestedEventArgs` has a single property (`Request`, of type `DataRequest`),
    which has a `Data` property (a `DataPackage` object), that's used to fill in sharing
    data. In the preceding code snippet, a string is set with the `DataPackage::SetText`
    method. Next, `DataPackage::SetBitmap` is used to set an image (with the helper
    `RandomAccessStreamReference` class).
  prefs: []
  type: TYPE_NORMAL
- en: A package also contains a bunch of properties that can be set, of which `Title`
    is the only one that's required. The example sets the thumbnail to the same flag
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Other formats are acceptable by the `DataPackage`, with methods such as `SetHtmlFormat`,
    `SetUri`, `SetRtf`, and `SetStorageItems` (sharing of files/folders).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another method, `SetDataProvider`, allows the app to register a delegate that
    will be queried when the data is actually needed, and not before that. This may
    be useful if obtaining the data is expensive, and should only be done if actually
    needed; also, it provides a way to share custom data.
  prefs: []
  type: TYPE_NORMAL
- en: Once the method completes, the data is available to a share target.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DataRequest` has a `GetDeferral` method that allows the app to make asynchronous
    calls without the sharing broker considering the data ready when the method returns
    (a similar mechanism to the one we''ve seen for background tasks). Calling `DataRequestDeferral::Complete`
    signals the actual readiness of the data to be shared.'
  prefs: []
  type: TYPE_NORMAL
- en: Share target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Becoming a share target is more difficult than a share source. One reason for
    this, is that the share target application may not be running when sharing is
    requested. This means the system must know beforehand which applications are capable
    of being share targets and what kind of data these applications can receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in becoming a share target is declaring in the application manifest
    that the app is, in fact, a share target, and specifying the kinds of data it''s
    willing to accept. Here''s a screenshot of the manifest showing an application
    that is willing to receive bitmaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Share target](img/5022_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A share target app must support at least one data format (**Bitmap** in this
    example), or at least one file type (such as `.doc`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how this app appears in the share pane when a flag is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Share target](img/5022_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The application named **ShareTargetDemo** is part of the downloadable code for
    this chapter, which is a simple image viewer for the Pictures library.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user selects our application, it's activated (executed) if not already
    in memory. The system calls the virtual method `Application::OnShareTargetActivated`.
    This method indicates the app is being activated as a share target, and must respond
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, the application must provide some user interface for the share
    pane, indicating what data it's about to consume and provide some button control
    to allow the user to actually confirm the share.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple share page UI that allows for some text labels, an image,
    and a **Share** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The bindings expect a relevant `ViewModel` to use, which is defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The target app in this case is willing to accept images. The `Image` element
    would show a preview of the image to accept. Once the user clicks the **Share**
    button, the sharing operation is executed and the entire sharing operation is
    deemed complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Application::OnShareTargetActivated` override is responsible for activating
    the share page UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`SharePage` is the class holding the share UI defined previously. The `Activate`
    method is an application-defined method that should extract the sharing information
    and initialize the UI as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to do is to save the operation object for later use when the
    **Share** button is clicked (`_operation` is a field of type `ShareOperation`
    located in the `Windows::ApplicationModel::DataTransfer::ShareTarget` namespace).
    The sharing data itself is in the `ShareOperation::Data` property (a `DataPackageView`
    object, similar to a `DataPackage` object on the share source side, but a read-only
    view of that data).
  prefs: []
  type: TYPE_NORMAL
- en: Next, the required information is extracted from the data object and placed
    in the `ShareViewModel` instance. If a thumbnail is provided, it's extracted by
    opening the `RandomAccessStreamReference` object and using a `BitmapImage` to
    load the image before placing it into the `ImageSource` used by the `ShareViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `DataContext` is set to the `ShareViewModel` instance and the
    page is made the current window content before actual activation. Here''s how
    this looks when the share source is the flags application (China''s flag is selected
    before sharing):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Share target](img/5022_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the user can interact with the sharing pane. If closed, nothing happens
    and the target application is terminated, if it wasn't running prior to share
    activation. If, on the other hand, the user decides to do the actual share (by
    clicking the **Share** button), the application needs to do whatever is appropriate
    for such a case. For example, the built-in Mail application shows a new e-mail
    UI that adds the shared data (typically text) to an empty e-mail that can be sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our sharing target app wants to save the provided image to the Pictures library
    for the current user. Here''s the `Click` handler for the **Share** button for
    this app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code may seem complex, because it attempts to save the provided image to
    a file, and because most of the operations are asynchronous, several tasks are
    involved to make sure the operations are performed in the right order. Here''s
    a quick rundown of the performed operations:'
  prefs: []
  type: TYPE_NORMAL
- en: A check is made to make sure the data package indeed includes a bitmap; this
    is somewhat redundant in this case, as the application has indicated in the manifest
    that bitmaps is the only supported data. Still, this check may be useful in more
    complex scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bitmap is extracted using `DataPackageView::GetBitmapAsync`, returning a
    `RandomAccessStreamReference` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RandomAccessStreamReference::OpenReadAsync` is called to get the image data
    as an `IRandomAccessStream` object. This object is used to instantiate a `BitmapDecoder`
    object that is capable of decoding the image bits, by calling the static factory
    method `BitmapDecoder::CreateAsync`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `BitmapDecoder` and `BitmapEncoder` types are located in the `Windows::Graphics::Imaging`
    namespace. The factory method that creates the `BitmapDecoder` automatically identifies
    the stored bitmap format.
  prefs: []
  type: TYPE_NORMAL
- en: Once the resulting decoder is obtained, a new file is created named `SharedImage.jpg`
    in the Pictures library (`KnownFolders::PicturesLibrary` returns a `StorageFolder`).
    Then the file is opened for read/write access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `BitmapEncoder` is created based on the decoder information (`BitmapEncoder::CreateForTranscodingAsync`)
    and the image saving is completed by the call to `BitmapEncoder::FlushAsync`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last thing to do (for any sharing operation) is to indicate to the system
    that the operation is complete by calling `ShareOperation::ReportComplete`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text, URLs, and images are not the only things that applications can share.
    Files can be shared as well, by calling the `DataPackage::SetStorageItems` from
    a source sharing app. These storage items can actually be files or folders (based
    on the `IStorageItem` interface).
  prefs: []
  type: TYPE_NORMAL
- en: On the share target side, the storage items are available using the `DataPackageView::GetStorageItemsAsync`
    method, returning a read-only collection (`IVectorView`) of `IStorageItem` objects.
    The app can then access these files/folders in any way that's appropriate for
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing page UI generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visual Studio provides a default page template for a share target operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing page UI generation](img/5022_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This adds a default UI for sharing, including a default `ViewModel` for data
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the app project was created with the "Blank App" template, Visual Studio
    will add some helper classes that exist in other project templates, such as `SuspensionManager`,
    `LayoutAwarePage`, and so on because the share page it creates derives from `LayoutAwarePage`.
  prefs: []
  type: TYPE_NORMAL
- en: FileOpenPicker contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `FileOpenPicker` class is used to pick a file from the filesystem—that''s
    pretty obvious; what''s not so obvious is that this same `FileOpenPicker` can
    be used to get a file from any application supporting the `FileOpenPicker` contract.
    When an application calls `FileOpenPicker::PickSingleFileAsync` or `PickMultipleFilesAsync`,
    a hosting process running the image `PickerHost.exe` is launched, where the `FileOpenPicker`
    is created. Besides the list of folders and files we can see applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FileOpenPicker contract](img/5022_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The listed applications (**Bing**, **Camera**, and so on) are implementing the
    `FileOpenPicker` contract, so they can be contacted to get back a file. For example,
    SkyDrive allows browsing through the user's files and selecting a file or files
    to download. The Camera application provides a user interface that allows taking
    a picture right here and now with some camera connected, or embedded, in the device,
    returning the resulting image file to the calling application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a FileOpenPicker contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step in implementing the `FileOpenPicker` contract is to declare
    this in the app manifest. This is required, as the implementing app may not be
    running at the time a `FileOpenPicker` is opened from some other app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a FileOpenPicker contract](img/5022_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen from the image, the app can support any file type, or a set of
    predefined file types, such as `.jpg`, `.doc`, and so on. This limits the applications
    that are considered candidates to be listed in the `FileOpenPicker`, depending
    on the file types specified with the `FileOpenPicker::FileTypeFilter` property
    by the calling application.
  prefs: []
  type: TYPE_NORMAL
- en: If the user actually selects the app within the `FileOpenPicker`, the app is
    launched (if it's not already running), and the `Application::OnFileOpenPickerActivated`
    virtual method is called. This idea is similar to the share target scenario we've
    looked at previously in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileOpenPicker` window is built with a header with the app's name (this
    is customizable by the app) and a footer with the **Open** and **Cancel** buttons.
    The middle section is where the app's specific selection UI is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example makes the Flags application a `FileOpenPicker` provider.
    The app should provide a view of the flags, allowing selection when an image is
    requested. The user interface for the flag selection is built like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GridView` hosts the collection of flags, bound to a collection of objects
    of type `CountryInfo`, defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `DataTemplate` for the `GridView` uses both properties to show an image
    of the flag and its corresponding country name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GridView` event `SelectionChanged` is handled to provide the `FileOpenPicker`
    files to select or deselect. Before we get to that, we need to implement the `Application::OnFileOpenPickerActivated`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code simply instantiates our custom `FileOpenPickerPage` class and calls
    an app-specific method on that page named `Activate`, passing the activation information
    provided by the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding `Activate` method does very little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `FileOpenPickerActivatedEventArgs` is saved in the `_filePickerArgs` field,
    to be used later when flags are actually selected or deselected. The call to `OnNavigatedTo`
    sets up all flag data and the new page becomes the `Window`'s content and is activated.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnNavigatedTo` does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The flag's image files are retrieved from the application installation location
    (`ms-appx:` scheme) and the country name is extracted from the image `Uri` by
    the helper method `FlagUriToName` (not shown); the country collection is updated,
    and finally the `DataContext` is set to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the app is deployed (using a full build or by selecting **Build** | **Deploy
    Solution** in the Visual Studio menu), we can do a basic picker test by launching
    another app, such as the simple image viewer demonstrated in [Chapter 1](ch01.html
    "Chapter 1. Introduction to Windows 8 Apps"), *Introduction to Windows 8 Apps*.
    When clicking the **Open Image** button, the Flags application is displayed in
    the picker''s custom apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a FileOpenPicker contract](img/5022_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the Flags app is selected, the following is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a FileOpenPicker contract](img/5022_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this time, selecting any flag does nothing—the **Open** button remains disabled.
    We need to tell the `FileOpenPicker` that a file is selected. This is handled
    by the `SelectionChanged` event of the `GridView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The class keeps track of the currently selected file with the `_currentFile`
    field. If nothing is selected in the `GridView` and a file was previously selected,
    the `FileOpenPickerUI::RemoveFile` method is called to indicate this file should
    be removed from selection; if this is the last one selected, the **Open** button
    is disabled by the `FileOpenPicker`.
  prefs: []
  type: TYPE_NORMAL
- en: If a flag is selected (`GridView::SelectedIndex` is zero or greater), the file
    for the flag image is obtained by calling the static `StorageFile::GetFileFromApplicationUriAsync`
    method, and passed into `FileOpenPickerUI::AddFile`. The result (`AddFileResult`
    enumeration) indicates whether this succeeded or not. This can fail if the `FileOpenPicker`
    was not opened with that file type in mind. For example, in an image viewer that
    did not specify the GIF file extension, the addition would fail, as all flag images
    are in GIF format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simple code provided here is a bit too simple. One thing that is not handled
    is multiselection. The `GridView` is configured to use single selection only,
    but this should really be configured according to the way the `FileOpenPicker`
    was opened. This information is available in the `FileOpenPickerUI::SelectionMode`
    property (`Single` or `Multiple`).
  prefs: []
  type: TYPE_NORMAL
- en: If used as intended, the `SelectionChanged` event handler should use the `AddedItems`
    and `RemovedItems` properties of the `SelectionChangedEventArgs` object to manage
    selection and deselection.
  prefs: []
  type: TYPE_NORMAL
- en: Note, that just as with share targets, Visual Studio provides a page template
    for the `FileOpenPicker` contract.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Debugging contracts may seem difficult at first, as the application may not
    be running at the time, so setting a breakpoint will not automatically attach
    Visual Studio''s debugger to the launched instance. This can be easily handled
    with one of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Attach the Visual Studio debugger after the specific app is selected from the
    file picker. This is enough to hit a breakpoint when selecting or unselecting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the application with the debugger as usual, and then navigate to another
    app that shows a file picker. If the app is selected, any breakpoint will hit
    as usual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extensions are a kind of contract between an app and the operating system. Extensions
    are implemented similarly to contracts, by overriding certain methods and providing
    certain functionality expected by the OS. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The distinction between contracts and extensions is not important in practice.
    They both have one important trait in common: implement some functionality defined
    by Windows, whether it''s for app to app communication, or app to Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Settings extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Settings charm opens up a Settings pane; its lower part shows standard Windows
    customization options, such as **Volume**, **Brightness**, **Power**, and so on.
    The top part of the settings pane can be used by applications to add app-specific
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although Settings is documented as being a contract rather than extension, I
    feel it's an extension, as it does not involve another app—just the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we''ll add a settings extension to the Flags application, to allow
    the user to view the flags in three different sizes. The first thing to do is
    indicate to the system that the app is interested in supporting the settings extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This call registers the `SettingsPane::CommandRequested` event, raised when
    the user opens the Settings pane and the application is in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the event is fired, we can add commands to be displayed in the settings
    pane like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SettingsCommand` constructor accepts an app-specific command ID that can
    be used to disambiguate commands in a common handler. The second argument is the
    text to show and the third is the handler to the command. In this example, all
    commands are handled by the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `IUICommand` interface (in the `Windows::UI::Popups` namespace) provided
    is actually a `SettingsCommand` object which is currently the only class implementing
    that interface. It holds the properties of the command (`Id`, `Label`, and `Invoked`—the
    exact arguments to `SettingsCommand`, in that order).
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageWidth` and `ImageHeight` are properties bound to the `DataTemplate` that
    drives the flags image appearance. This is how the Settings pane looks when opened
    from the Flags'' application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Settings extension](img/5022_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Permissions** command is provided by the system and lists the capabilities
    that the application requires (such as internet connection, webcam, Pictures library,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Other contracts and extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some other contracts and extensions, not shown here, include:'
  prefs: []
  type: TYPE_NORMAL
- en: File save picker – similar to a file open picker, but for save operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search – provides a way for the app to participate in search, providing results
    that users can use to activate the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cached file updater – used to track file changes (used by SkyDrive, for instance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto play – allows the app to be listed when new devices are plugged in to the
    machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File activation – allows the app to be registered as handling a file type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game explorer – allows the app to register as a game, providing a way for family
    safety features to be considered for the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contracts and extensions provide ways for an application to integrate better
    with Windows and other applications; for example, users can share data by using
    the Share charm, regardless of the kind of app. Contracts and extensions provide
    consistency in the user experience, not just the programming model. This makes
    the application more useful; it looks as though a lot of thought and care has
    been poured into the app. In general, this makes the app more likely to be used—which
    is one very important goal when building applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next (and last) chapter we'll take a quick look at application deployment
    and the Windows Store.
  prefs: []
  type: TYPE_NORMAL
