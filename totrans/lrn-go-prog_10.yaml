- en: Chapter 10. Data IO in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previous chapters of this book focused mainly on fundamentals. In this and
    future chapters, readers are introduced to some of the powerful APIs provided
    by Go''s standard library. This chapter discusses in detail how to input, process,
    transform, and output data using APIs from the standard library and their respective
    packages with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: IO with readers and writers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The io.Reader interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The io.Writer interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the io package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatted IO with fmt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffered IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding and decoding data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IO with readers and writers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to other languages, such as Java, Go models data input and output as
    a stream that flows from sources to targets. Data resources, such as files, networked
    connections, or even some in-memory objects, can be modeled as streams of bytes
    from which data can be *read* or *written* to, as illustrated in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IO with readers and writers](img/image_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The stream of data is represented as a **slice of bytes** (**[]byte**) that
    can be accessed for reading or writing. As we will explore in this chapter, the
    `*io*` package makes available the `io.Reader` interface to implement code that
    *reads* and transfers data from a source into a stream of bytes. Conversely, the
    `io.Writer` interface lets implementers create code that reads data from a provided
    stream of bytes and *writes* it as output to a target resource. Both interfaces
    are used extensively in Go as a standard idiom to express IO operations. This
    makes it possible to interchange readers and writers of different implementations
    and contexts with predictable results.
  prefs: []
  type: TYPE_NORMAL
- en: The io.Reader interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `io.Reader` interface, as shown in the following listing, is simple. It
    consists of a single method, `Read([]byte)(int, error)`, intended to let programmers
    implement code that *reads* data, from an arbitrary source, and transfers it into
    the provided slice of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Read` method returns the total number of bytes transferred into the provided
    slice and an error value (if necessary). As a guideline, implementations of the
    `io.Reader` should return an error value of `io.EOF` when the reader has no more
    data to transfer into stream `p`. The following shows the type `alphaReader`,
    a trivial implementation of the `io.Reader` that filters out non-alpha characters
    from its string source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/reader0.go
  prefs: []
  type: TYPE_NORMAL
- en: Since values of the `alphaReader` type implement the `io.Reader` interface,
    they can participate anywhere a reader is expected as shown in the call to `io.Copy(os.Stdout,
    &str)`. This copies the stream of bytes emitted by the `alphaReader` variable
    into a writer interface, `os.Stdout` (covered later).
  prefs: []
  type: TYPE_NORMAL
- en: Chaining readers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chances are the standard library already has a reader that you can reuse -
    so it is common to wrap an existing reader and use its stream as the source for
    the new implementation. The following snippet shows an updated version of `alphaReader`.
    This time, it takes an `io.Reader` as its source as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/reader1.go
  prefs: []
  type: TYPE_NORMAL
- en: The main change to note in this version of the code is that the `alphaReader`
    type is now a struct which embeds an `io.Reader` value. When `alphaReader.Read()`
    is invoked, it calls the wrapped reader as `a.src.Read(p)`, which will inject
    the source data into byte slice `p`. Then the method loops through `p` and applies
    the filter to the data. Now, to use the `alphaReader`, it must first be provided
    with an existing reader which is facilitated by the `NewAlphaReader()` constructor
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of this approach may not be obvious at first. However, by using
    an `io.Reader` as the underlying data source the `alphaReader` type is capable
    of reading from any reader implementation. For instance, the following code snippet
    shows how the `alphaReader` type can now be combined with an `os.File` to filter
    out non-alphabetic characters from a file (the Go source code itself):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/reader2.go
  prefs: []
  type: TYPE_NORMAL
- en: The io.Writer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `io.Writer` interface, as shown in the following code, is just as simple
    as its reader counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The interface requires the implementation of a single method, `Write(p []byte)(c
    int, e error)`, that copies data from the provided stream `p` and *writes* that
    data to a sink resource such as an in-memory structure, standard output, a file,
    a network connection, or any number of `io.Writer` implementations that come with
    the Go standard library. The `Write` method returns the number of bytes copied
    from `p` followed by an `error` value if any was encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the implementation of the `channelWriter`
    type, a writer that decomposes and serializes its stream that is sent over a Go
    channel as consecutive bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/writer1.go
  prefs: []
  type: TYPE_NORMAL
- en: The `Write` method uses a goroutine to copy each byte, from `p`, and sends it
    across the `c.Channel`. Upon completion, the goroutine closes the channel so that
    consumers are notified when to stop consuming from the channel. As an implementation
    convention, writers should not modify slice `p` or hang on to it. When an error
    occurs, the writer should return the current number of bytes processed and an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `channelWriter` type is simple. You can invoke the `Write()` method
    directly or, as is more common, use `channelWriter` with other IO primitives in
    the API. For instance, the following snippet uses the `fmt.Fprint` function to
    serialize the `"Stream me!"` string as a sequence of bytes over a channel using
    `channelWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/writer1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous snippet, the serialized bytes, queued in the channel, are consumed
    using a `for…range` statement as they are successively printed. The following
    snippet shows another example where the content of a file is serialized over a
    channel using the same `channelWriter`. In this implementation, an `io.File` value
    and `io.Copy` function are used to source the data instead of the `fmt.Fprint`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/writer2.go.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the io package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The obvious place to start with IO is, well, the `io` package ([https://golang.org/pkg/io](https://golang.org/pkg/io)).
    As we have already seen, the `io` package defines input and output primitives
    as the `io.Reader` and `io.Writer` interfaces. The following table summarizes
    additional functions and types, available in the `io` package, that facilitate
    streaming IO operations.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `io.Copy()` | The `io.Copy` function (and its variants `io.CopyBuffer` and
    `io.CopyN`) make it easy to copy data from an arbitrary `io.Reader` source into
    an equally arbitrary `io.Writer` sink as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iocopy.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `PipeReader PipeWriter` | The `io` package includes the *PipeReader* and
    *PipeWriter* types that model IO operations as an in-memory pipe. Data is written
    to the pipe''s `io.Writer` and can independently be read at the pipe''s `io.Reader`.
    The following abbreviated snippet illustrates a simple pipe that writes a string
    to the writer `pw`. The data is then consumed with the `pr` reader and copied
    to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iopipe.goNote that the pipe writer will block until the reader
    completely consumes the pipe content or an error is encountered. Therefore, both
    the reader and writer should be wrapped in a goroutine to avoid deadlocks. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.TeeReader()` | Similar to the `io.Copy` function, `io.TeeReader` transfers
    content from a reader to a writer. However, the function also emits the copied
    bytes (unaltered) via a returned `io.Reader`.The TeeReader works well for composing
    multi-step IO stream processing. The following abbreviated snippet first calculates
    the SHA-1 hash of a file content using the `TeeReader`. The resulting reader,
    `data`, is then streamed to a gzip writer `zip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'golang.fyi/ch10/ioteerdr0.goIf we wanted to calculate both SHA-1 and MD5, we
    can update the code to nest the two `TeeReader` values as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/ioteerdr1.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.WriteString()` | The `io.WriteString` function writes the content of
    string into a specified writer. The following writes the content of a string to
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iowritestr.go |
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.LimitedReader` | As its name suggests, the `io.LimitedReader` struct is
    a reader that reads only *N* number of bytes from the specified `io.Reader`. The
    following snippet will print the first 19 bytes from the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iolimitedrdr.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `io.SectionReader` | The `io.SectionReader` type implements seek and skip
    primitives by specifying an index (zero-based) where to start reading and an offset
    value indicating the number of bytes to read as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/iosectionrdr.goThis example will print `jumps over the lazy
    dog`. |
  prefs: []
  type: TYPE_NORMAL
- en: '| Package `io/ioutil` | The `io/ioutil` sub-package implements a small number
    of functions that provide utilitarian shortcuts to IO primitives such as file
    read, directory listing, temp directory creation, and file write. |'
  prefs: []
  type: TYPE_TB
- en: Working with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os` package ([https://golang.org/pkg/os/](https://golang.org/pkg/os/))
    exposes the `os.File` type which represents a file handle on the system. The `os.File`
    type implements several IO primitives, including the `io.Reader` and `io.Writer`
    interfaces, which allows file content to be processed using the standard streaming
    IO API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and opening files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `os.Create` function creates a new file with the specified path. If the
    file already exists, `os.Create` will overwrite it. The `os.Open` function, on
    the other hand, opens an existing file for reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following source snippet opens an existing file and creates a copy of its
    content using the `io.Copy` function. One common, and recommended practice to
    notice is the deferred call to the method `Close` on the file. This ensures a
    graceful release of OS resources when the function exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/file0.go
  prefs: []
  type: TYPE_NORMAL
- en: Function os.OpenFile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `os.OpenFile` function provides generic low-level functionalities to create
    a new file or open an existing file with fine-grained control over the file's
    behavior and its permission. Nevertheless, the `os.Open` and `os.Create` functions
    are usually used instead as they provide a simpler abstraction then the `os.OpenFile`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `os.OpenFile` function take three parameters. The first one is the path
    of the file, the second parameter is a masked bit-field value to indicate the
    behavior of the operation (for example, read-only, read-write, truncate, and so
    on) and the last parameter is a posix-compliant permission value for the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following abbreviated source snippet re-implements the file copy code,
    from earlier. This time, however, it uses the `os.FileOpen` function to demonstrate
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/file1.go
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you already have a reference to an OS file descriptor, you can also use the
    `os.NewFile` function to create a file handle in your program. The `os.NewFile`
    function is rarely used, as files are usually initialized using the file functions
    discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Files writing and reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen how to use the `os.Copy` function to move data into or
    out of a file. Sometimes, however, it will be necessary to have complete control
    over the logic that writes or reads file data. The following code snippet, for
    instance, uses the `WriteString` method from the `os.File` variable, `fout,` to
    create a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/filewrite0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, the source of your data is not text, you can write raw bytes directly
    to the file as shown in the following source snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/filewrite0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'As an `io.Reader`, reading from of the `io.File` type directly can be done
    using the *Read* method. This gives access to the content of the file as a raw
    stream of byte slices. The following code snippet reads the content of file `../ch0r/dict.txt`
    as raw bytes assigned to slice `p` up to 1024-byte chunks at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fileread.go
  prefs: []
  type: TYPE_NORMAL
- en: Standard input, output, and error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `os` package includes three pre-declared variables, `os.Stdin`, `os.Stdout`,
    and `os.Stderr`, that represent file handles for standard input, output, and error
    of the OS respectively. The following snippet reads the file `f1` and writes its
    content to `io.Stdout`, standard output, using the `os.Copy` function (standard
    input is covered later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/osstd.go
  prefs: []
  type: TYPE_NORMAL
- en: Formatted IO with fmt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most widely used packages for IO is `fmt` ([https://golang.org/pkg/fmt](https://golang.org/pkg/fmt)).
    It comes with an amalgam of functions designed for formatted input and output.
    The most common usage of the `fmt` package is for writing to standard output and
    reading from standard input. This section also highlights other functions that
    make `fmt` a great tool for IO.
  prefs: []
  type: TYPE_NORMAL
- en: Printing to io.Writer interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fmt` package offers several functions designed to write text data to arbitrary
    implementations of io.Writer. The `fmt.Fprint` and `fmt.Fprintln` functions write
    text with the default format while `fmt.Fprintf` supports format specifiers. The
    following code snippet writes a columnar formatted list of `metalloid` data to
    a specified text file using the `fmt.Fprintf` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fmtfprint0.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the `fmt.Fprintf` function uses format specifiers to
    write formatted text to the io.File `file` variable. The `fmt.Fprintf` function
    supports a large number of format specifiers whose proper treatment is beyond
    the scope of this text. Refer to the online documentation for complete coverage
    of these specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Printing to standard output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fmt.Print`, `fmt.Printf`, and `fmt.Println` have the exact same characteristics
    as the previous `Fprint`-series of functions seen earlier. Instead of an arbitrary
    `io.Writer` however, they write text to the standard output file handle `os.Stdout`
    (see the section *Standard output, input, and error* covered earlier).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following abbreviated code snippet shows an updated version of the previous
    example that writes the list of metalloids to a standard output instead of a regular
    file. Note that it is the same code except for the use of the `fmt.Printf` instead
    of the `fmt.Fprintf` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fmtprint0.go
  prefs: []
  type: TYPE_NORMAL
- en: Reading from io.Reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fmt` package also supports formatted reading of textual data from `io.Reader`
    interfaces. The `fmt.Fscan` and `fmt.Fscanln` functions can be used to read multiple
    values, separated by spaces, into specified parameters. The `fmt.Fscanf` function
    supports format specifiers for a richer and flexible parsing of data input from
    `io.Reader` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following abbreviated code snippet uses the function `fmt.Fscanf` for the
    formatted input of a space-delimited file (`planets.txt`) containing planetary
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fmtfscan0.go
  prefs: []
  type: TYPE_NORMAL
- en: The code reads from the `io.File` variable `data`, until it encounters an `io.EOF`
    error indicating the end of the file. Each line of text it reads is parsed using
    format specifiers `"%s %d %d %s\n"` which matches the space-delimited layout of
    the records stored in the file. Each parsed token is then assigned to its respective
    variable `name`, `diam`, `moons`, and `hasRing,` which are printed to the standard
    output using the `fm.Printf` function.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from standard input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of reading from an arbitrary `io.Reader`, the `fmt.Scan`, `fmt.Scanf`,
    and `fmt.Scanln` are used to read data from standard input file handle, `os.Stdin`.
    The following code snippet shows a simple program that reads text input from the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/fmtscan1.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous program, the `fmt.Scanf` function parses the input using the
    format specifier `"%d"` to read an integer value from the standard input. The
    function will throw an error if the value read does not match exactly the specified
    format. For instance, the following shows what happens when character `D` is read
    instead of an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Buffered IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most IO operations covered so far have been unbuffered. This implies that each
    read and write operation could be negatively impacted by the latency of the underlying
    OS to handle IO requests. Buffered operations, on the other hand, reduces latency
    by buffering data in internal memory during IO operations. The `bufio` package
    ([https://golang.org/pkg/bufio](https://golang.org/pkg/bufio)/) offers functions
    for buffered read and write IO operations.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered writers and readers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `bufio` package offers several functions to do buffered writing of IO streams
    using an `io.Writer` interface. The following snippet creates a text file and
    writes to it using buffered IO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/bufwrite0.go
  prefs: []
  type: TYPE_NORMAL
- en: In general, the constructor functions in the `bufio` package create a buffered
    writer by wrapping an existing `io.Writer` as its underlying source. For instance,
    the previous code creates a buffered writer using the `bufio.NewWriter` function
    by wrapping the io.File variable, `fout`.
  prefs: []
  type: TYPE_NORMAL
- en: To influence the size of the internal buffer, use the constructor function `bufio.NewWriterSize(w
    io.Writer, n int)` to specify the internal buffer size. The `bufio.Writer` type
    also offers the methods `Write` and `WriteByte` for writing raw bytes and `WriteRune`
    for writing Unicode-encoded characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading buffered streams can be done simply by calling the constructor function
    *bufio.NewReader* to wrap an existing `io.Reader`. The following code snippet
    creates a `bufio.Reader` variable `reader` by wrapping the `file` variable as
    its underlying source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: golang`.fyi/ch10/bufread0.go`
  prefs: []
  type: TYPE_NORMAL
- en: The previous code uses the `reader.ReadString` method to read a text file using
    the `'\n'` character as the content delimiter. To influence the size of the internal
    buffer, use the constructor function `bufio.NewReaderSize(w io.Reader, n int)`
    to specify the internal buffer size. The `bufio.Reader` type also offers the *Read*,
    *ReadByte*, and *ReadBytes* methods for reading raw bytes from a stream and the
    *ReadRune* method for reading Unicode-encoded characters.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning the buffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `bufio` package also makes available primitives that are used to scan and
    tokenize buffered input data from an `io.Reader` source. The `bufio.Scanner` type
    scans input data using the *Split* method to define tokenization strategies. The
    following code snippet shows a reimplementation of the planetary example (from
    earlier). This time, the code uses `bufio.Scanner` (instead of the `fmt.Fscan`
    function) to scan the content of the text file using the `bufio.ScanLines` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/bufscan0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `bufio.Scanner` is done in four steps as shown in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, use `bufio.NewScanner(io.Reader)` to create a scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `scanner.Split` method to configure how the content is tokenized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traverse the generated tokens with the `scanner.Scan` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the tokenized data with the `scanner.Text` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code uses the pre-defined function `bufio.ScanLines` to parse the buffered
    content using a line-delimiter. The `bufio` package comes with several pre-defined
    splitter functions including *ScanBytes* to scan each byte as a token, *ScanRunes*
    to scan UTF-8 encoded tokens, and *ScanWords* which scan each space-separated
    words as tokens.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bytes` package offers common primitives to achieve streaming IO on blocks
    of bytes, stored in memory, represented by the `bytes.Buffer` type. Since the
    `bytes.Buffer` type implements both `io.Reader` and `io.Writer` interfaces it
    is a great option to stream data into or out of memory using streaming IO primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet stores several string values in the `byte.Buffer` variable,
    `book`. Then the buffer is streamed to `os.Stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/bytesbuf0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The same example can easily be updated to stream the content to a regular file
    as shown in the following abbreviate code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/bytesbuf1.go
  prefs: []
  type: TYPE_NORMAL
- en: Encoding and decoding data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common aspect of IO in Go is the encoding of data, from one representation
    to another, as it is being streamed. The encoders and decoders of the standard
    library, found in the *encoding* package ([https://golang.org/pkg/encoding/](https://golang.org/pkg/encoding/)),
    use the `io.Reader` and `io.Writer` interfaces to leverage IO primitives as a
    way of streaming data during encoding and decoding.
  prefs: []
  type: TYPE_NORMAL
- en: Go supports several encoding formats for a variety of purposes including data
    conversion, data compaction, and data encryption. This chapter will focus on encoding
    and decoding data using the *Gob* and *JSON* format for data conversion. In [Chapter
    11](ch11.html "Chapter 11. Writing Networked Services"), *Writing Networked Programs*,
    we will explore using encoders to convert data for client and server communication
    using **remote procedure calls** (**RPC**).
  prefs: []
  type: TYPE_NORMAL
- en: Binary encoding with gob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gob` package ([*https://golang.org/pkg/encoding/gob*](https://golang.org/pkg/encoding/gob))
    provides an encoding format that can be used to convert complex Go data types
    into binary. Gob is self-describing, meaning each encoded data item is accompanied
    by a type description. The encoding process involves streaming the gob-encoded
    data to an io.Writer so it can be written to a resource for future consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an example code that encodes variable `books`,
    a slice of the `Book` type with nested values, into the `gob` format. The encoder
    writes its generated binary data to an os.Writer instance, in this case the `file`
    variable of the `*os.File` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/gob0.go
  prefs: []
  type: TYPE_NORMAL
- en: Although the previous example is lengthy, it is mostly made of the definition
    of the nested data structure assigned to variable `books`. The last half-dozen
    or more lines are where the encoding takes place. The gob encoder is created with
    `enc := gob.NewEncoder(file)`. Encoding the data is done by simply calling `enc.Encode(books)`
    which streams the encoded data to the provide file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decoding process does the reverse by streaming the gob-encoded binary data
    using an `io.Reader` and automatically reconstructing it as a strongly-typed Go
    value. The following code snippet decodes the gob data that was encoded and stored
    in the `books.data` file in the previous example. The decoder reads the data from
    an `io.Reader`, in this instance the variable `file` of the `*os.File` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/gob1.go
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a previously encoded gob data is done by creating a decoder using `dec
    := gob.NewDecoder(file)`. The next step is to declare the variable that will store
    the decoded data. In our example, the `books` variable, of the `[]Book` type,
    is declared as the destination of the decoded data. The actual decoding is done
    by invoking `dec.Decode(&books)`. Notice the `Decode()` method takes the address
    of its target variable as an argument. Once decoded, the `books` variable will
    contain the reconstituted data structure streamed from the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of this writing, gob encoder and decoder APIs are only available in the Go
    programming language. This means that data encoded as gob can only be consumed
    by Go programs.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding data as JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The encoding package also comes with a *json* encoder sub-package ([https://golang.org/pkg/encoding/json/](https://golang.org/pkg/encoding/json/))
    to support JSON-formatted data. This greatly broadens the number of languages
    with which Go programs can exchange complex data structures. JSON encoding works
    similarly as the encoder and decoder from the gob package. The difference is that
    the generated data takes the form of a clear text JSON-encoded format instead
    of a binary. The following code updates the previous example to encode the data
    as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json0.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is exactly the same as before. It uses the same slice of nested structs
    assigned to the `books` variable. The only difference is the encoder is created
    with `enc := json.NewEncoder(file)` which creates a JSON encoder that will use
    the `file` variable as its `io.Writer` destination. When `enc.Encode(books)` is
    executed, the content of the variable `books` is serialized as JSON to the local
    file `books.dat`, shown in the following code (formatted for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: File books.dat (formatted)
  prefs: []
  type: TYPE_NORMAL
- en: The generated JSON-encoded content uses the name of the struct fields as the
    name for the JSON object keys by default. This behavior can be controlled using
    struct tags (see the section, *Controlling JSON mapping with struct tags*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consuming the JSON-encoded data in Go is done using a JSON decoder that streams
    its source from an `io.Reader`. The following snippet decodes the JSON-encoded
    data, generated in the previous example, stored in the file `book.dat`. Note that
    the data structure (not shown in the following code) is the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json1.go
  prefs: []
  type: TYPE_NORMAL
- en: The data in the books.dat file is stored as an array of JSON objects. Therefore,
    the code must declare a variable capable of storing an indexed collection of nested
    struct values. In the previous example, the `books` variable, of the type `[]Book` is
    declared as the destination of the decoded data. The actual decoding is done by
    invoking `dec.Decode(&books)`. Notice the `Decode()` method takes the address
    of its target variable as an argument. Once decoded, the `books` variable will
    contain the reconstituted data structure streamed from the file.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling JSON mapping with struct tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the name of a struct field is used as the key for the generated
    JSON object. This can be controlled using `struct` type tags to specify how JSON
    object key names are mapped during encoding and decoding of the data. For instance,
    the following code snippet declares struct fields with the `json:` tag prefix
    to specify how object keys are to be encoded and decoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json2.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The tags and their meaning are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tags** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Title string `json:"book_title"`` | Maps the `Title` struct field to the
    JSON object key, `"book_title"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `PageCount int `json:"pages,string"`` | Maps the `PageCount` struct field
    to the JSON object key, `"pages",` and outputs the value as a string instead of
    a number. |'
  prefs: []
  type: TYPE_TB
- en: '| `ISBN string `json:"-"`` | The dash causes the `ISBN` field to be skipped
    during encoding and decoding. |'
  prefs: []
  type: TYPE_TB
- en: '| `Authors []Name `json:"auths,omniempty"`` | Maps the `Authors` field to the
    JSON object key, `"auths"`. The annotation, `omniempty,` causes the field to be
    omitted if its value is nil. |'
  prefs: []
  type: TYPE_TB
- en: '| `Publisher string `json:",omniempty"`` | Maps the struct field name, `Publisher,`
    as the JSON object key name. The annotation, `omniempty,` causes the field to
    be omitted when empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `PublishDate time.Time `json:"pub_date"`` | Maps the field name, `PublishDate,`
    to the JSON object key, `"pub_date"`. |'
  prefs: []
  type: TYPE_TB
- en: 'When the previous struct is encoded, it produces the following JSON output
    in the `books.dat` file (formatted for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice the JSON object keys are titled as specified in the `struct` tags. The
    object key `"pages"` (mapped to the struct field, `PageCount`) is encoded as a
    string. Finally, the struct field, `ISBN,` is omitted, as annotated in the `struct`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Custom encoding and decoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JSON package uses two interfaces, *Marshaler* and *Unmarshaler*, to hook
    into encoding and decoding events respectively. When the encoder encounters a
    value whose type implements `json.Marshaler`, it delegates serialization of the
    value to the method `MarshalJSON` defined in the Marshaller interface. This is
    exemplified in the following abbreviated code snippet where the type `Name` is
    updated to implement `json.Marshaller` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json3.go
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, values of the `Name` type are serialized as a JSON
    string (instead of an object as earlier). The serialization is handled by the
    method `Name.MarshallJSON` which returns an array of bytes that contains the last
    and first name separated by a comma. The preceding code generates the following
    JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For the inverse, when a decoder encounters a piece of JSON text that maps to
    a type that implements `json.Unmarshaler`, it delegates the decoding to the type''s
    `UnmarshalJSON` method. For instance, the following shows the abbreviated code
    snippet that implements `json.Unmarshaler` to handle the JSON output for the `Name` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch10/json4.go
  prefs: []
  type: TYPE_NORMAL
- en: The `Name` type is an implementation of `json.Unmarshaler`. When the decoder
    encounters a JSON object with the key `"Authors"`, it uses the method `Name.Unmarshaler`
    to reconstitute the Go struct `Name` type from the JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Go standard libraries offer additional encoders (not covered here) including
    `base32`, `bas364`, `binary`, `csv`, `hex`, `xml`, `gzip`, and numerous encryption
    format encoders.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides a high-level view of Go's data input and output idioms
    and the packages involved in implementing IO primitives. The chapter starts by
    covering the fundamentals of a stream-based IO in Go with the `io.Reader` and
    `io.Writer` interfaces. Readers are walked through the implementation strategies
    and examples for both an `io.Reader` and an `io.Writer`.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter goes on to cover packages, types, and functions that that support
    the streaming IO mechanism including working with files, formatted IO, buffered,
    and in-memory IO. The last portion of the chapter covers encoders and decoders
    that convert data as it is being streamed. In the next chapter, the IO theme is
    carried further when the discussion turns to creating programs that use IO to
    communicate via networking.
  prefs: []
  type: TYPE_NORMAL
