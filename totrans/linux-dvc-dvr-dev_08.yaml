- en: SPI Device Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Serial Peripheral Interface** (**SPI** ) is a (at least) four-wire bus--**Master
    Input Slave Output** (**MISO** ), **Master Output Slave Input** (**MOSI** ), **Serial
    Clock** (**SCK** ), and **Chip Select** (**CS** ), which is used to connect a
    serial flash, AD/DA converter. The master always generates the clock. Its speed
    can reach up to 80 MHz, even if there is no real speed limitation (much faster
    than I2C as well). The same for the CS line, which is always managed by the master.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these signal names has a synonym:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you sees SIMO, SDI, DI, or SDA, they refer to MOSI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOMI, SDO, DO, SDA will refer to MISO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SCK, CLK, SCL will refer to SCK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'S̅ S̅ is the slave select line, also called CS. CSx can be used (where x is
    an index, CS0, CS1), EN and ENB too, meaning enable. The CS is usually an active
    low signal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SPI topology (image from wikipedia)
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will walk through SPI driver concepts such as:'
  prefs: []
  type: TYPE_NORMAL
- en: SPI bus description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver architecture and data structure descriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data sending and receiving in both half and full duplex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring SPI devices from DT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing SPI devices from user space, in both half and full duplex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The driver architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The required header for SPI stuff in the Linux kernel is `<linux/spi/spi.h>`
    . Before talking about the driver structure, let us see how SPI devices are defined
    in the kernel. An SPI device is represented in the kernel as an instance of `spi_device`
    . The instance of the driver that manages them is `struct spi_driver` structure.
  prefs: []
  type: TYPE_NORMAL
- en: The device structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`struct spi_device` structure represents an SPI device, and is defined in `include/linux/spi/spi.h`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Some fields that are not meaningful for us have been removed. That says, the
    following is the meaning of elements in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`master` : This represents the SPI controller (bus) on which the device is
    connected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_speed_hz` : This is the maximum clock rate to be used with this chip (on
    the current board); this parameter can be changed from within the driver. You
    can override that parameter using `spi_transfer.speed_hz` for each transfer. We
    will discuss SPI transfer later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chip_select` : This lets you enable the chip you need to talk to, distinguishing
    chips handled by the master. The `chip_select` is active low by default. This
    behavior can be changed in mode, by adding the `SPI_CS_HIGH` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode` : This defines how data should be clocked. The device driver may change
    this. The data clocking is **Most Significant Bit** (**MSB** ) first, by default
    for each word in a transfer. This behavior can be overridden by specifying `SPI_LSB_FIRST`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq` : This represents the interrupt number (registered as device resource
    in your board `init` file or through the DT) you should pass to `request_irq()`
    to receive interrupts from this device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A word about SPI modes; they are built using two characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CPOL` : This is the initial clock polarity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` : Initial clock state low, and the first edge is rising'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` : Initial clock state high, and the first state is falling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPHA` : This is the clock phase, choosing at which edge the data will be sampled:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` : Data latched at falling edge (high to low transition), whereas output
    changes at rising edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` : Data latched at rising edge (low to high transition), and output at falling
    edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This allows for four SPI modes, which are defined in the kernel according to
    the following macro in `include/linux/spi/spi.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then produce the following array to summarize things:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **CPOL** | **CPHA** | **Kernel macro** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | `#define SPI_MODE_0 (0&#124;0)` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | `#define SPI_MODE_1 (0&#124;SPI_CPHA)` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 0 | `#define SPI_MODE_2 (SPI_CPOL&#124;0)` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 | 1 | `#define SPI_MODE_3 (SPI_CPOL&#124;SPI_CPHA)` |'
  prefs: []
  type: TYPE_TB
- en: 'The following is the representation of each SPI mode, as defined in the preceding
    array. That said, only the MOSI line is represented, but the principle is the
    same for MISO:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Commonly used modes are `SPI_MODE_0` and `SPI_MODE_3` .
  prefs: []
  type: TYPE_NORMAL
- en: spi_driver structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`struct spi_driver` represents the driver you develop to manage your SPI device.
    Its structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The probe() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Its prototype is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You may refer to [Chapter 7](text00189.html) , *I2C Client Drivers* in order
    to see what is to be done in a `probe` function. The same steps apply here. Therefore,
    unlike an I2C driver that has no capability to change the controller bus parameters
    (CS state, bit per word, clock) at runtime, an SPI driver can. You can set up
    the bus according to your device properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical SPI `probe` function would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `struct spi_device*` is an input parameter, given to the `probe` function
    by the kernel. It represents the device you are probing. From within your `probe`
    function, you can get the `spi_device_id` that triggered the match using `spi_get_device_id`
    (in case of `id_table match` ) and extract the driver data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Per-device data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `probe` function, it is a common task to track a private (per-device)
    data to be used during the module lifetime. This has been discussed in [Chapter
    7](text00189.html) , *I2C Client Drivers.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are prototypes of functions one uses for setting/getting per-device
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The remove() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `remove` function must release every resource grabbed in the `probe` function.
    Its structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical `remove` function may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Driver initialization and registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For device sitting on a bus, whether it is a physical one or the pseudo platform
    bus, most of the time, everything is done in the `probe` function. The `init`
    and `exit` functions are just used to register/unregister the driver with the
    bus core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That said, if you do not do anything else but register/unregister the driver,
    the kernel offers a macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will internally call `spi_register_driver` and `spi_unregister_driver`
    . It is exactly the same thing as what we have seen in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Driver and devices provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we need `i2c_device_id` for I2C devices, we must use `spi_device_id` for
    SPI devices, in order to provide a `device_id` array to match our devices. It
    is defined in `include/linux/mod_devicetable.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to embed our array into a `struct spi_device_id` in order to inform
    the SPI core about the device ID we need to manage in the driver and call `MODULE_DEVICE_TABLE`
    macro on the driver structure. Of course, the first parameter of the macro is
    the name of the bus on which the device sits. In our case, it is SPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Instantiate SPI devices in board configuration file – old and depreciated way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Device should be instantiated in board file only if the system does not support
    device tree. Since device tree has come, this method of instantiating is deprecated.
    Therefore, let us just remember that the board file resides in `arch/` directory.
    The structure used to represent an SPI device is `struct spi_board_info` , not
    the `struct spi_device` we used in the driver. It is only when you have filled
    and registered the `struct spi_board_info` using the `spi_register_board_info`
    function that the kernel will build a `struct spi_device` (which will be passed
    to your driver and register with the SPI core).
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to look at the `struct spi_board_info` field in `include/linux/spi/spi.h`
    . The definition of `spi_register_board_info` can be found in `drivers/spi/spi.c`
    . Now let us have a look at some SPI device registration in the board file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: SPI and device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like I2C devices, SPI devices belong to the non memory mapped devices family
    in the DT, but are addressable too. Here, the address means the CS index among
    the list of CS (starting from 0) given to the controller (the master). As an example,
    we may have three different SPI devices seating on the SPI bus, each with its
    CS line. The master will be given a set of GPIO, each representing CS to activate
    a device. If the device X uses the second GPIO line as CS, we must set its address
    to 1 (as we always start from 0) in `reg` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a real DT listing for SPI devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a new property introduced in SPI device nodes: `spi-max-frequency`
    . It represents the maximum SPI clocking speed of the device in Hz. Whenever you
    access the device, the bus controller driver will ensure the clock does not cross
    this limit. Other properties commonly used are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spi-cpol` : This is a Boolean (empty property) indicating the device requires
    inverse clock polarity mode. It corresponds to CPOL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-cpha` : This is an empty property indicating the device requires shifted
    clock phase mode. It corresponds to CPHA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-cs-high` : By default, SPI devices require CS low to be active. This is
    a Boolean property indicating the device requires CS active high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That said, for a complete list of SPI binding elements, you can refer to *Documentation/devicetree/bindings/spi/spi-bus.txt*
    in the kernel sources.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate SPI devices in device tree - the new way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By filling our device node in the DT properly, the kernel will build a `struct
    spi_device` for us, and give it as a parameter to our SPI core functions. The
    following is just an excerpt from the SPI DT listing defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Define and register SPI driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again the principle is the same as that for I2C drivers. We need to define
    a `struct of_device_id` to match devices in the DT, and call the `MODULE_DEVICE_TABLE`
    macro to register with the OF core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then define our `spi_driver` as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then improve the `probe` function this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Accessing and talking to the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SPI I/O model consists of a set of queued messages. We submit one or more
    `struct spi_message` structures, which are processed and completed synchronously
    or asynchronously. A single message consists of one or more `structspi_transfer`
    objects, each of which represents a full duplex SPI transfer. These are two main
    structures to exchange data between the driver and the device. They are both defined
    in `include/linux/spi/spi.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SPI message structure
  prefs: []
  type: TYPE_NORMAL
- en: '`struct spi_transfer` represents a full duplex SPI transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the meaning of the structure elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tx_buf` : This buffer contains the data to be written. It should be NULL or
    left as it is in case of a read-only transaction. It should be `dma` -safe in
    the case where you need to perform SPI transactions through **Direct Memory Access**
    (**DMA** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rx_buf` : This is a buffer for data to be read (with the same properties as
    `tx_buf` ), or NULL in a write-only transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tx_dma` : This is the DMA address of `tx_buf` , in case `spi_message.is_dma_mapped`
    is set to `1` . DMA is discussed in [Chapter 12](http://post) , *DMA – Direct
    Memory Access* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rx_dma` : This is the same as `tx_dma` , but for `rx_buf` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len` : This represents the size of `rx` and `tx` buffers in bytes, meaning
    they must have the same size if both are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`speed_hz` : This overrides the default speed, specified in `spi_device.max_speed_hz`
    , but only for the current transfer. If `0` , the default value (provided in `struct
    spi_device` structure) is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bits_per_word` : Data transfer involves one or more words. A word is a unit
    of data, whose size in bits may vary according to the need. Here, `bits_per_word`
    represents the size in bits of a word for this SPI transfer. This override the
    default value provided in `spi_device.bits_per_word` . If `0` , the default (from
    `spi_device` ) is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cs_change` : This determines the state of the `chip_select` line after this
    transfer completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay_usecs` : This represents the delay (in microseconds) after this transfer
    before (optionally) changing the `chip_select` status, then starting the next
    transfer or completing this `spi_message` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the other side, the `struct spi_message` is used atomically to wrap one
    or more SPI transfers. The SPI bus used will be hogged by the driver until every
    transfer that constitutes the message is completed. SPI message structure is defined
    in `include/linux/spi/spi.h` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`transfers` : This is the list of transfers that constitutes the message. We
    will see later how to add a transfer to this list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_dma_mapped` : This informs the controller whether to use DMA (or not) to
    perform the transaction. Your code is then responsible in providing DMA and CPU
    virtual addresses for each transfer buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complete` : This is a callback called when the transaction is done, and `context`
    is the parameter to be given to the callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame_length` : This will be set automatically with the total number of bytes
    in the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actual_length` : This is the number of bytes transferred in all successful
    segments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status` : This reports the transfers status. Zero on success, else `-errno`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi_transfer` elements in a message are processed in a FIFO order. Until the
    message is completed, you have to make sure not to use transfer buffer, in order
    to avoid data corruption. You make completion call to make sure one can.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before a message can be submitted to the bus, it has to be initialized with
    `void spi_message_init(struct spi_message *message),` which will zero each element
    in the structure and initialize the `transfers` list. For each transfer to be
    added to the message, you should call `void spi_message_add_tail(struct spi_transfer
    *t, struct spi_message *m)` on that transfer, which will result in enqueuing the
    transfer into `transfers` list. Once done, you have two choices to start the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronously, using the `int spi_sync(struct spi_device *spi, struct spi_message
    *message)` function, which may sleep and which is not to be used in an interrupt
    context. Completion of the callback is not necessary here. This function is a
    wrapper around the second function (`spi_async()` ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronously, using the `spi_async()` function, which can be used in an atomic
    context too, and whose prototype is `int spi_async(struct spi_device *spi, struct
    spi_message *message)` . It is good practice to provide callback here, since it
    will be executed upon message complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is what a single transfer SPI message transaction may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us write a multi-transfer message transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other helper functions, all built around `spi_sync()` . Some of them
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Please have a look at `include/linux/spi/spi.h` to see the complete list. These
    wrappers should be used with small amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps needed to write SPI client drivers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare device IDs supported by the driver. You can do that using `spi_device_id`
    . If DT is supported, use `of_device_id` too. You can make an exclusive use of
    DT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `MODULE_DEVICE_TABLE(spi, my_id_table);` to register your device list with
    the SPI core. If DT is supported, you must call `MODULE_DEVICE_TABLE(of, your_of_match_table);`
    to register your device list with the `of` core.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `probe` and `remove` functions according to their respective prototypes.
    The `probe` function must identify your device, configure it, define per-device
    (private) data, configure the bus if needed (SPI mode and so on) using `spi_setup`
    function, and register with the appropriate kernel framework. In the `remove`
    function, simply undo everything done in the `probe` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare and fill a `struct spi_driver` structure, set the `id_table` field with
    the array of IDs you have created. Set `.probe` and `.remove` fields with the
    name of the corresponding functions you have written. In the `.driver` substructure,
    set the `.owner` field to `THIS_MODULE` , set the driver name, and finally set
    the `.of_match_table` field with the array of `of_device_id` , if the DT is supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `module_spi_driver` function with your `spi_driver` structure you just
    filled before `module_spi_driver(serial_eeprom_spi_driver);` in order to register
    your driver with the kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SPI user mode driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways of using the user mode SPI device driver. To be able to
    do that, you need to enable your device with `spidev` driver. An example would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call either the read/write functions or an `ioctl()` . With calling
    read/write you can only read or write at a time. If you need full-duplex read
    and write, you have to use the **Input Output Control** (**ioctl** ) commands
    . Examples for both are provided. This is the read/write example. You can compile
    it either with the cross-compiler of the platform or with the native compiler
    on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With IOCTL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advantage of using IOCTL is that you can work in full duplex. The best example
    you can find is `documentation/spi/spidev_test.c` , in the kernel source tree,
    of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, the preceding example using read/write did not change any SPI configuration.
    However, the kernel exposes to user space a set of IOCTL commands, which you can
    use in order to set up the bus according to the need, just like what is done in
    DT. The following example shows how you can change the bus settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have a look at *Documentation/spi/spidev* for more information on spidev
    ioctl commands. When it comes to sending data over the bus, you can use `SPI_IOC_MESSAGE(N)`
    request, which offers full-duplex access, and composite operations without chipselect
    de-activation, thus offering multi-transfer support. It is the equivalent of kernel
    `spi_sync()` . Here a transfer is represented as an instance of `struct spi_ioc_transfer`
    , which is the equivalent of kernel `struct spi_transfer` , and whose definition
    can be found in `include/uapi/linux/spi/spidev.h` . The following is an example
    of usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just dealt with SPI drivers and now can take advantage of this faster serial
    (and full duplex) bus. We walked through data transfer over SPI, which is the
    most important section. That said, you may need more abstraction in order not
    to bother with SPI or I2C APIs. This is where the next chapter comes in, dealing
    with Regmap API, which offers a higher and unified level of abstraction, so that
    SPI (or I2C) commands will become transparent to you.
  prefs: []
  type: TYPE_NORMAL
