- en: Debugging Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning Python interpreter basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging through logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving your debugging skills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code is not easy. Actually, it is very hard. Even the best programmer
    in the world can't foresee any possible alternative and flow of the code.
  prefs: []
  type: TYPE_NORMAL
- en: This means that executing our code will always produce surprises and unexpected
    behavior. Some will be very evident and others will be very subtle, but the ability
    to identify and remove these defects in the code is critical to building solid
    software.
  prefs: []
  type: TYPE_NORMAL
- en: These defects in software are known as **bugs**, and therefore removing them
    is called **debugging**.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the code just by reading it is not great. There are always surprises,
    and complex code is difficult to follow. That's why the ability to debug by stopping
    execution and taking a look at the current state of things is important.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone, EVERYONE introduces bugs in the code, normally to be surprised by
    them later. Some people have described debugging as *being the detective in a
    crime movie where you are also the murderer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any debugging process roughly follows this path:'
  prefs: []
  type: TYPE_NORMAL
- en: You realize there's a problem
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You understand what the correct behavior should be
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You discover why the current code produces the bug
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You change the code to produce the proper result
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 95% of the time, everything but step 3 is trivial, which is the bulk of the
    debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Realizing the why of a bug, at its core, uses the scientific method:'
  prefs: []
  type: TYPE_NORMAL
- en: Measure and observe what the code is doing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Produce a hypothesis on why that is
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate or disprove that's correct, maybe through an experiment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the resulting information to iterate the process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Debugging is an ability, and as such, it will improve over time. Practice plays
    an important role in developing intuition on what paths look promising to identify
    an error, but there are some general ideas that may help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Divide and conquer: **Isolate small parts of the code, so that it is possible
    to understand the code. Simplify the problem as much as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s a format of this called the **Wolf fence algorithm**, described by
    Eduard Gauss:'
  prefs: []
  type: TYPE_NORMAL
- en: '"There''s one wolf in Alaska; how do you find it? First build a fence down
    the middle of the state, wait for the wolf to howl, determine which side of the
    fence it is on. Repeat process on that side only, until you get to the point where
    you can see the wolf."'
  prefs: []
  type: TYPE_NORMAL
- en: '**Move backwards from the error: **If there''s a clear error at a specific
    point, the bug is likely located in the surroundings. Move progressively backwards
    from the error, following the track until the source of the error is found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You can assume anything you want, as long as you prove your assumption:** Code
    is very complex to keep in your head all at once. You need to validate small assumptions
    that, when combined, will provide solid ground to move forward with detecting
    and fixing the problem. Make small experiments, which will allow you to remove
    from your mind parts of the code that actually work and focus on untested ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or in the words of Sherlock Holmes:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Once you eliminate the impossible, whatever remains, no matter how improbable,
    must be the truth."'
  prefs: []
  type: TYPE_NORMAL
- en: But remember to prove it. Avoid untested assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: All of this sounds a bit scary, but actually most of the bugs are pretty evident.
    Maybe a typo, or a piece of code not ready for a particular value. Try to keep
    things simple. Simple code is easier to analyze and debug.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see some of the tools and techniques for debugging,
    and apply them specifically to Python scripts. The scripts will have some bugs
    that we will fix as part of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Python interpreter basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll cover some of Python's built-in capabilities to examine
    code, to investigate what's going on, and to detect when things are not behaving
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: We can also verify when things are working as expected. Remember that being
    able to discard part of the code as the source of a bug is incredibly important.
  prefs: []
  type: TYPE_NORMAL
- en: While debugging, we typically need to analyze unknown elements and objects that
    come from an external module or service. Given the dynamic nature of Python, the
    code is highly discoverable at any point in the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in this recipe is included by default in Python's interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Import `pprint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new dictionary called `dictionary`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Display `globals` into this environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the `globals` dictionary in a readable format with `pprint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Display all of the attributes of the `dictionary`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Show the help for the `dictionary` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the import of `pprint` (pretty print) in step 1, we create a new dictionary
    to work as the example in step 2.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 shows how the global namespace contains, among other things, the defined
    dictionary and the module. `globals()` displays all imported modules an other
    global variables.
  prefs: []
  type: TYPE_NORMAL
- en: There's an equivalent `locals()` for local namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '`pprint` helps to display the `globals` in a more readable format in step 4,
    adding more space and separating the elements by line.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 shows how to use `dir()` to obtain all the attributes of a Python object.
    Note this includes all the double underscore values, such as `__len__`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the built-in `help()` function will display relevant information
    for objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`dir()` in particular is extremely useful for inspecting unknown objects, modules,
    or classes. If you need to filter out the default attributes, and clarify the
    output, you can filter the output this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, if you're searching for a particular method (such as something
    that starts with `set`), you can filter in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '`help()` will display the `docstring` of a function or class. `docstring` is
    the string defined just after the definition to document the function or class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice how in the next example, the  *This is help for something* string is
    defined just after the definition of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '`docstring` is normally enclosed in triple quotes to allow writing string with
    multiple lines. Python will treat everything inside triple-quotes as a big string,
    even if there are newlines. You can use either `''` or `"` characters,  as long
    as you use three of them. You can find more information about `docstrings` at [https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/).'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for the built-in functions can be found at [https://docs.python.org/3/library/functions.html#built-in-functions](https://docs.python.org/3/library/functions.html#built-in-functions),
    and the full documentation for `pprint` can be found at [https://docs.python.org/3/library/pprint.html#](https://docs.python.org/3/library/pprint.html#).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Improving your debugging skills* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging through logging* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging through logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is, after all, detecting what's going on inside our program and what
    unexpected or incorrect effects may be happening. A simple, yet very effective,
    approach is to output variables and other information at strategic parts of your
    code to follow the flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of this approach is called **print debugging**, or inserting
    print statements at certain points to print the value of variables or points while
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: But taking this technique a little bit further and combining it with the logging
    techniques presented in [Chapter 2](6b1d9f13-f2de-41f1-a87b-6896ceb7b280.xhtml), *Automating
    Tasks Made Easy* allows us to create a semi-permanent trace of the execution of
    the program, which can be really useful when detecting issues in a running program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the `debug_logging.py` file from GitHub: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_logging.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_logging.py).
  prefs: []
  type: TYPE_NORMAL
- en: It contains an implementation of the bubble sort algorithm ([https://www.studytonight.com/data-structures/bubble-sort](https://www.studytonight.com/data-structures/bubble-sort)),
    which is the simplest way to sort a list of elements. It iterates several times
    over the list, and on each iteration, two adjacent values are checked and interchanged,
    so the bigger one is after the smaller. This makes the bigger values ascend like
    bubbles in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort is a simple but naive way of implementing a sort, and there are
    better alternatives. Unless you have an extremely good reason not to, rely on
    the standard `.sort` method in lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, it checks the following list to verify that it is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have a bug in this implementation, so we can fix it as part of the recipe!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the `debug_logging.py` script and check whether it fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the dubug logging, changing the second line of the `debug_logging.py`
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding line to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note the different `level`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script again, with more information inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After analyzing the output, we realize that the last element of the list is
    not sorted. We analyze the code and discover an off-by-one error in line 7\. Do
    you see it? Let''s fix it by changing the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding line to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: (Notice the removal of the `-1` operation.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Run it again and you will see that it works as expected. The debug logs are
    not displayed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 1 presents the script and shows that the code is faulty, as it's not properly
    sorting the list.
  prefs: []
  type: TYPE_NORMAL
- en: The script already has some logs to show the start and end result, as well as
    some debug logs that show each intermediate step. In step 2, we activate the display
    of the `DEBUG` logs, as in step 1 only the `INFO` ones were shown.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the logs are displayed by default in the standard error output. This
    is displayed by default in the Terminal. If you need to direct the logs somewhere
    else, such as a file, see how to configure a different handler. See the logging
    configuration in Python for more details: [https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html).
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 runs the script again, this time displaying extra information, showing
    that the last element in the list is not sorted.
  prefs: []
  type: TYPE_NORMAL
- en: The bug is an off-by-one error, a very common kind of error, as it should iterate
    to the whole size of the list. This is fixed in step 4.
  prefs: []
  type: TYPE_NORMAL
- en: Check the code to understand why there's an error. The whole list should be
    compared, but we made the mistake of reducing the size by one.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 shows that the fixed script runs correctly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have strategically located the debug logs beforehand, but
    that may not be the case in a real-life debugging exercise. You may need to add
    more or change the location as part of the bug investigation.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of this technique is that we're able to see the flow of
    the program, being able to inspect one moment of the code execution to another,
    and make sense of the flow. But the disadvantage is that we can end with a wall
    of text that doesn't provide specific information about our problem. You need
    to find a balance between too much and too little information.
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, try to limit very long variables unless they're necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to turn down the logging level after fixing the bug. It is likely that
    some logs that you discover to be irrelevant may need to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The quick and dirty version of this technique is to add print statements instead
    of debug logs. While some people are resistant to this, it is actually a valuable
    technique to use for debug purposes. But remember to clean them up when you're
    done.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the introspection elements are available, so you can create logs that display,
    for example, all the attributes of a `dir(object)` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Anything that can be displayed as a string is able to be presented in a log,
    including any text manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning Python interpreter basics* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Improving your debugging skills* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a ready-to-go debugger called `pdb`. Given that Python code is interpreted,
    this means that stopping the execution of the code at any point is possible by
    setting a breakpoint, which will jump into a command line where any code can be
    used to analyze the situation and execute any number of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the `debug_algorithm.py` script, available from GitHub: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_algorithm.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_algorithm.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will analyze the execution of the code in detail. The code checks
    whether numbers follow certain properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is possible that you recognize what the code is doing, but bear with me so
    that we can analyze it interactively.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the code to see all the assertions are valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add  `breakpoint()`, after the `while` loop, just before line 7, resulting
    in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code again, and see that it stops at the breakpoint, entering into
    the interactive `Pdb` mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the value of the candidate and the two operations. This line is checking
    whether the dividing of `candidate` by `lower` is an integer (the float and integer
    division is the same):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue to the next instruction with `n`. See that it ends the while loop
    and returns `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue the execution until another breakpoint is found with `c`. Note that
    this is the next call to `valid()`, which has 15 as an input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue running and inspecting the numbers until what the `valid` function
    is doing makes sense. Are you able to find out what the code does? (If you can''t,
    don''t worry and check the next section.) When you''re done, exit with `q`. This
    stops the execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code is, as you probably know already, checking whether a number is a prime
    number. It tries to divide the number by all integers lower than it. If at any
    point is divisible, it returns a `False` result, because it's not a prime.
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a very inefficient way of checking for a prime number, as it
    will take a very long time to deal with big numbers. It is fast enough for our
    teaching purposes, though. If you're interested in finding primes, you can take
    a look at math packages such as SymPy ([https://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#sympy.ntheory.primetest.isprime](https://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#sympy.ntheory.primetest.isprime)).
  prefs: []
  type: TYPE_NORMAL
- en: After checking the general execution in step 1, in step 2, we introduced a `breakpoint`
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: When the code is executed in step 3, it stops at the `breakpoint` position,
    entering into an interactive mode.
  prefs: []
  type: TYPE_NORMAL
- en: In the interactive mode, we can inspect the values of any variable as well as
    perform any kind of operation. As demonstrated in step 4, sometimes, a line of
    code can be better analyzed by reproducing its parts.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be inspected and regular operations can be executed in the command
    line. The next line of code can be executed by calling `n(ext)`, as done in step
    5 several times, to see the flow of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 shows how to resume the execution with the `c(ontinue)` command in order,
    to stop in the next breakpoint. All these operations can be iterated to see the
    flow and values, and to understand what the code is doing at any point.
  prefs: []
  type: TYPE_NORMAL
- en: The execution can be stopped with `q(uit)`, as demonstrated in step 7.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see all the available operations, you can call `h(elp)` at any point.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the surrounding code at any point using the `l(ist)` command.
    For example, in step 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The other two main debugger commands are `s(tep)`, which will execute the next
    step, including entering a new call, and `r(eturn)`, which will return from the
    current function.
  prefs: []
  type: TYPE_NORMAL
- en: You can set up (and disable) more breakpoints using the `pdb` command `b(reak)`.
    You need to specify the file and line for the breakpoint, but it's actually more
    straightforward and less error-prone to just change the code and run it again.
  prefs: []
  type: TYPE_NORMAL
- en: You can overwrite variables as well as read them. Or create new variables. Or
    make extra calls. Or anything else you can imagine. The full power of the Python
    interpreter is at your service! Use it to check how something works or verify whether
    something is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid creating variables with names that are reserved for the debugger, such
    as calling a list `l`. It will make things confusing and interfere when trying
    to debug, sometimes in non-obvious ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `breakpoint()` function is new in Python 3.7, but it''s highly recommended
    if you''re using that version. In previous versions, you need to replace it with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: They work in exactly the same way. Note the two statements in the same line,
    which is not recommended in Python in general, but it's a great way of keeping
    the breakpoint in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to remove any `breakpoints` once `debugging` is done! Especially when
    committing to a version-control system such as Git.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the new `breakpoint` call in the official PEP describing
    its usage at: [https://www.python.org/dev/peps/pep-0553/](https://www.python.org/dev/peps/pep-0553/).
  prefs: []
  type: TYPE_NORMAL
- en: The full `pdb` documentation can be found here: [https://docs.python.org/3.7/library/pdb.html#module-pdb](https://docs.python.org/3.7/library/pdb.html#module-pdb).
    It includes all the debug commands.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning Python interpreter basics* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Improving your debugging skills* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving your debugging skills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will analyze a small script that replicates a call to an external
    service, analyzing it and fixing some bugs. We will show different techniques
    to improve the debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The script will ping some personal names to an internet server (`httpbin.org`,
    a test site) to get them back, simulating its retrieval from an external server.
    It will then split them into first and last name and prepare them to be sorted
    by surname. Finally, it will sort them.
  prefs: []
  type: TYPE_NORMAL
- en: The script contains several bugs that we will detect and fix.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the `requests` and `parse` modules and include
    them in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `debug_skills.py` script is available from GitHub: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills.py).
    Note that it contains bugs that we will fix as part of this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the script, which will generate an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Analyze the status code. We get 405, which means that the method we sent is
    not allowed. We inspect the code and realize that for the call in line 24, we
    used `GET`, when the proper one is `POST` (as described in the URL). Replace the
    code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We keep the old buggy code commented with `(old)` for clarity of changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code again, which will produce a different error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a breakpoint in line 33, one preceding the error. Run it again and enter
    into debugging mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Running `n` does not produce an error, meaning that it's not the first value.
    After a few runs on ` c`, we realize that this is not the correct approach, as
    we don't know what input is the one generating the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we wrap the line with a `try...except` block and produce a breakpoint
    at that point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the code again. This time the code stops at the moment the data produced
    an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The cause is now clear, line 35 only allows us to split two words, but raises
    an error if a middle name is added. After some testing, we settle into this line
    to fix it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the script again. Be sure to remove the `breakpoint` and `try..except`
    block. This time, it generates a list of names! And they are sorted alphabetically
    by surname. However, a few of the names look incorrect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Who's called `O'Carroll, S\\u00e9amus` ?
  prefs: []
  type: TYPE_NORMAL
- en: 'To analyse this particular case, but skip the rest, we must create an `if`
    condition to break only for that name in line 33\. Notice the `in` to avoid having
    to be totally correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script once more. The breakpoint stops at the proper moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Move upward in the code and check the different variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `result.json()` dictionary, there''s actually a different field that
    seems to be rendering the name properly, which is called `''json''`. Let''s look
    at it in detail; we can see that it''s a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Change the code, instead of parsing the raw value in `'data'`, use directly
    the `'json'` field from the result. This  simplifies the code, which is great!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code again. Remember to remove the `breakpoint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This time, it's all correct! You have successfully debugged the program!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of the recipe is divided into three different problems. Let''s
    analyze it in small blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First error—Wrong call to the external service**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After showing the first error in step 1, we read with care the resulting error,
    saying that the server is returning a 405 status code. This corresponds to a method
    not allowed, indicating that our calling method is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspect the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It gives us the indication that we are using a `GET` call to one URL that's
    defined for `POST`, so we make the change in step 2.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there has been no extra debugging steps as such in this error, but
    a careful reading of the error message and the code. Remember to pay attention
    to error messages and logs. Often, this is enough to discover the issue.
  prefs: []
  type: TYPE_NORMAL
- en: We run the code in step 3 to find the next problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Second error—Wrong handling of middle names**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In step 3, we get an error of too many values to unpack. We create a `breakpoint`
    to analyze the data in step 4 at this point, but discover that not all the data
    produces this error. The analysis done in step 4 shows that it may be very confusing
    to stop the execution when an error is not produced, having to continue until
    it does. We know that the error is produced at this point, but only for certain
    kind of data.
  prefs: []
  type: TYPE_NORMAL
- en: As we know that the error is being produced at some point, we capture it in
    a `try..except` block in step 5\. When the exception is produced, we trigger the
    `breakpoint`.
  prefs: []
  type: TYPE_NORMAL
- en: This makes step 6 execution of the script to stop when the `full_name` is `'John
    Paul Smith'`. This produces an error as the `split` expects two elements, not
    three.
  prefs: []
  type: TYPE_NORMAL
- en: This is fixed in step 7, allowing everything except the last word to be part
    of the first name, grouping any middle name(s) into the first element. This fits
    our purpose for this program, to sort by last name.
  prefs: []
  type: TYPE_NORMAL
- en: Names are actually quite complex to handle. Check out this article if you want
    to be delighted with the great amount of wrong assumptions one can make regarding
    names: [https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/](https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line does that with `rsplit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It divides the text by words, starting from the right and making a maximum of
    one split, guaranteeing that only two elements will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: When the code is changed, step 8 runs the code again to discover the next error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Third error—Using a wrong returned value by the external service**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the code in step 8 displays the list and does not produce any errors.
    But, examining the results, we can see that some of the names are incorrectly
    processed.
  prefs: []
  type: TYPE_NORMAL
- en: We pick one of the examples in step 9 and create a conditional breakpoint. We
    only activate the `breakpoint` if the data fulfills the `if` condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` condition in this case stops at any time the `"O'Carroll"` string appears,
    not having to make it stricter with an equal statement. Be pragmatic about this
    code, as you'll need to remove it after the bug is fixed anyway.
  prefs: []
  type: TYPE_NORMAL
- en: The code is run again in step 10\. From there, once validated that the data
    is as expected, we worked *backward* to find the root of the problem. Step 11
    analyzes previous values and the code up to that point, trying to find out what
    lead to the incorrect value.
  prefs: []
  type: TYPE_NORMAL
- en: We then discover that we used the wrong field in the returned value from the
    `result` from the server. The value in the `json` field is better for this task
    and it's already parsed for us. Step 12 checks the value and sees how it should
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: In step 13, we change the code to adjust. Notice that the `parse` module is
    no longer needed and that the code is actually cleaner using the `json` field.
  prefs: []
  type: TYPE_NORMAL
- en: This result is actually more common than it looks, especially when dealing with
    external interfaces. We may use it in a way that works, but maybe it's not the
    best. Take a little bit of time to read the documentation and keep an eye on improvements
    and learn how to better use the tools.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is fixed, the code is run again in step 14\. Finally, the code is
    doing what's expected, sorting the names alphabetically by surname. Notice that
    the other name that contained strange characters is fixed as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fixed script is available from GitHub: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills_fixed.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills_fixed.py).
    You can download it and see the differences.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways of creating conditional breakpoints. There's actually support
    from the debugger to create breakpoints that stop, but only if some conditions
    are met. When possible, we find it easier to work directly with code, as it is
    persistent between runs and easier to remember and operate. You can check how
    to create it in the Python `pdb` documentation: [https://docs.python.org/3/library/pdb.html#pdbcommand-break](https://docs.python.org/3/library/pdb.html#pdbcommand-break).
  prefs: []
  type: TYPE_NORMAL
- en: The kind of breakpoint catching an exception shown in the first error is a demonstration
    of how making conditions in code is straightforward. Just be careful to remove
    them afterwards!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other debuggers available that have an increased set of features.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ipdb` ([https://github.com/gotcha/ipdb](https://github.com/gotcha/ipdb)):
    Adds tab completion and syntax highlights'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pudb` ([https://documen.tician.de/pudb/](https://documen.tician.de/pudb/)):
    Displays an old-style, semi-graphical, text-based interface, in the style of early
    90s tools that display the environment variables automatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web-pdb` ([https://pypi.org/project/web-pdb/](https://pypi.org/project/web-pdb/)):
    Opens a web server to access a graphic interface with the debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check their documentations to know how to install them and run them.
  prefs: []
  type: TYPE_NORMAL
- en: There are more debuggers available, a search on the internet will give you more
    options, including Python IDEs. In any case, be aware of adding dependencies.
    It is always good to be able to use the default debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new breakpoint commands in Python 3.7 allow us to change easily between
    debuggers using the `PYTHONBREAKPOINT` environment variable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This starts `ipdb` on any breakpoint in the code. You can see more about this
    in the `breakpoint()` documentation can be found: [https://www.python.org/dev/peps/pep-0553/#environment-variable](https://www.python.org/dev/peps/pep-0553/#environment-variable).
  prefs: []
  type: TYPE_NORMAL
- en: An important effect on this is to disable all breakpoints by setting `PYTHONBREAKPOINT=0`,
    which is a great tool to ensure that code in production is never interrupted by
    a `breakpoint()` left by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `pdb` documentation can be found here: [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)
    The whole documentation of the `parse` module can be found at [https://github.com/r1chardj0n3s/parse](https://github.com/r1chardj0n3s/parse) and
    the whole `requests` documentation at [http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning Python interpreter basics* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging with breakpoints* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
