- en: Chapter 7. Learning Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first announcement of functional programming, many functional languages
    didn''t have the loop feature to iterate the sequence. All we had to do was construct
    the recursion process to iterate the sequence. Although C# has iteration features
    such as `for` and `while` , it is better if we discuss recursion in the functional
    approach. Recursion will also simplify our code. To do that, in this chapter,
    we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the recursive routine works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring an iteration into a recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distinguishing tail recursion between the accumulator-passing style and the
    continuation-passing style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding indirect recursion over direct recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying recursion in the functional approach using the Aggregate LINQ operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recursive function is a function that calls itself. Like the iteration loop,
    for instance, the `while` and `for` loop--it is used to solve a complicated task
    one piece at a time and combine the results. However, there is a difference between
    the `for` loop and `while` loop. The iteration will keep repeating until the task
    is done, while the recursion will break the task up into smaller pieces in order
    to solve the larger problem and then combine the result. In the functional approach,
    the recursion is closer to the mathematical approach since it is often shorter
    than iteration, although it's somehow more difficult to design and test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional Style in
    C#") , *Tasting Functional Style in C#,* we were acquainted with recursive functions,
    when we discussed the concepts of functional programming. There, we analyzed the
    factorial function named `GetFactorial()` in the imperative and functional approach.
    To refresh our memory, following is the `GetFactorial()` function implementation,
    which we can find in the `SimpleRecursion.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From our discussion in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting
    Functional Style in C#") , *Tasting Functional Style in C#* we know that the factorial
    of the non-negative integer `N` is the multiplication of all positive integers
    less than or equal to `N` . So, suppose we have the following function to calculate
    the factorial of five:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can predict, if we invoke the preceding `GetFactorialOfFive()` method,
    we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring recursion](img/Image00083.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Back to the `GetFactorial()` method again; we see in the implementation of
    this method there is code that will end the recursion, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the preceding code is the base case of the recursion and the
    recursion usually has the base case. This base case will define the end of the
    recursion chain since, in this case, the method will change the state of `intNumber`
    every time the recursion is run, and the chain will be stopped if `intNumber`
    is zero.
  prefs: []
  type: TYPE_NORMAL
- en: Working of the recursive routine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to understand how the recursive routine works, let''s examine the
    state of `intNumber` if we find the factorial of five, as shown in the following
    flow of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding flow, it becomes clearer how the recursion works. The base
    case we have defines the end of the recursion chain. A programming language compiler
    converts the specific case of recursion into an iteration when applicable because
    a loop-based implementation becomes more efficient by eliminating the need for
    a function call.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when applying the recursion in your program logic. If you miss a
    base case or give a wrong value to it, you may go off into an infinite recursion.
    For instance, in the preceding `GetFactorial()` method, if we pass `intNumber
    < 0` , then our program will never end.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring an iteration to the recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recursion makes our programs more readable, and it is essential in the functional
    programming approach. Here, we are going to refactor the for loop iteration to
    the recursion method. Let''s take a look at the following code, which we can find
    in the `RefactoringIterationToRecursion.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `FindMaxIteration()` method is used to pick the maximum number
    in the array of numbers. Consider that we have the following code in order to
    run the `FindMaxIteration()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can expect, we will have the following output in the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring an iteration to the recursion](img/Image00084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s refactor the `FindMaxIteration()` method to the recursive function.
    The following is the implementation of the `FindMaxRecursive()` method, which
    is the recursion version of the `FindMaxIteration()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the preceding `FindMaxRecursive()` method using the same code
    as we did in the `FindMaxIteration()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding method, we have the following base case to define
    the end of the recursion chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, we will get the same result as the one we got
    in our previous method, as shown in the following console screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring an iteration to the recursion](img/Image00085.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s take a look at the following flow to know how we can get this result
    when we use the recursion function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding flow, we can distinguish every state change in the maximum
    number we get every time the `FindMaxRecursive()` method is called. Then, we can
    prove that the maximum number in the given array is `98` .
  prefs: []
  type: TYPE_NORMAL
- en: Using tail recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `GetFactorial()` method we discussed previously, traditional recursion
    is used to calculate the factorial number. This recursion model performs the recursive
    call first and returns the value, and then it calculates the result. Using this
    recursion model, we won't get the result until the recursive call is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the traditional recursion model, we have another recursion called tail
    recursion. The tail call becomes the last thing in the function and it doesn''t
    do anything after the recursion at all. Let''s look at the following code, which
    we can find in the `TailRecursion.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, the tail is executed when `iTotalRecursion` has reached
    `0` , as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `TailCall()` method and pass `5` for the `iTotalRecursion`
    argument, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using tail recursion](img/Image00086.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s examine the state change every time the function is called recursively
    in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding flow of recursion, the process is only run in the last recursion
    call. After that, nothing happens to the other recursive calls. In other words,
    we can conclude that the flow will actually be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, the flow of our tail recursion is obvious and clear. The idea of tail recursion
    is to minimize the use of the stack that is sometimes the expensive resource we
    have. Using tail recursion, the code doesn't need to remember the last state it
    has to come back to when the next step returns, since it has the temporary result
    in the accumulator parameter in this case. The following topic is the two styles
    that follow tail recursion; they are **accumulator-passing style** ( **APS** )
    and **continuation-passing style** ( **CPS** ).
  prefs: []
  type: TYPE_NORMAL
- en: Accumulator-passing style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the **accumulator-passing style** ( **APS** ), the recursion performs the
    calculation first, executes the recursive call, and then passes the result of
    the current step to the next recursive step. Let''s take a look at the following
    accumulator passing style of the tail recursive code we refactor from the `GetFactorial()`
    method, which we can find in the `AccumulatorPassingStyle.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to the `GetFactorial()` method, we now have a second parameter named
    accumulator in the `GetFactorialAPS()` method. Since the result of the factorial
    `0` is `1` , we give the default value of 1 to the accumulator parameter. Instead
    of just returning a value, it now returns the calculation of the factorial every
    time the recursive function is called. To prove this, consider that we have the
    following code in order to invoke the `GetFactorialAPS()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding method, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accumulator-passing style](img/Image00087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s examine every call of the `GetFactorialAPS()` method to see the
    state change inside the method from the following flow of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding flow, since it performs the calculation every
    time it''s called, we now have the result of the calculation in the last call
    of the function, when the `intNumber` parameter has reached `0` , as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also refactor the preceding `GetFactorialAPS()` method into the `GetFactorialAPS2()`
    method in order to not return any value, so it will become more obvious how the
    APS of tail recursion works. The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we have the following `GetFactorialOfFiveUsingAPS2()` method to call
    the `GetFactorialAPS2()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we will get the following output on the console if we invoke the preceding
    `GetFactorialOfFiveUsingAPS2()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accumulator-passing style](img/Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the flow of the `GetFactorialAPS2()` method becomes clearer, as shown
    in the following flow of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding flow, we can see that we calculate the accumulator every
    time the `GetFactorialAPS2()` method is invoked. The result of this recursion
    type is that we do not need to use the stack anymore since the function doesn't
    need to memorize its start position when it calls the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: Continuation-passing style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **continuation-passing style** ( **CPS** ) has the same purpose as APS in
    implementing the recursive function using a tail call, but it has explicit continuation
    in processing the operation. The return of the CPS function will be passed on
    to the continuation function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s refactor the `GetFactorial()` method into the following `GetFactorialCPS()`
    method, which we can find in the `ContinuationPassingStyle.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, instead of using the accumulator, as we did in the `GetFactorialAPS()`
    method, we now use `Action<T>` to delegate an anonymous method, which we use as
    a continuation. Suppose we have the following code to invoke the `GetFactorialCPS()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `GetFactorialOfFiveUsingCPS()` method, we will get
    the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuation-passing style](img/Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Indeed, we get the same result compared to the `GetFactorial()` method or the
    `GetFactorialAPS2()` method. However, the flow of recursion now becomes a little
    bit different, as shown in the following explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The return of each recursion now is passed to the continuation process, in this
    case, the `Console.WriteLine()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Indirect recursion over direct recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have discussed recursion methods earlier. Actually, in our previous discussion,
    we applied direct recursion since we only dealt with a single method and we invoked
    it over and over again until the base case was executed. However, there''s another
    recursive type, which is called indirect recursion. Indirect recursion involves
    at least two functions, for instance, function A and function B. In the application
    of an indirect recursion, function A calls function B, and then function B makes
    a call back to function A. It''s considered a recursion because when method B
    calls method A, function A is actually active when it calls function B. In other
    words, the invocation of function A has not finished when function B calls function
    A again. Let''s take a look at the following code, which demonstrates the indirect
    recursion that we can find in the `IndirectRecursion.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two functions in the preceding code: `IsOdd()` and `IsEven()` . Each
    function calls the other function every time the comparison results `false` .
    The `IsOdd()` function will call `IsEven()` when `targetNumber` is not zero and
    so will the `IsEven()` function. The logic of each function is simple. For instance,
    the `IsOdd()` method decides whether or not `targetNumber` is odd by investigating
    whether or not the previous number, which is `targetNumber - 1` , is even. Likewise,
    the `IsEven()` method decides whether or not `targetNumber` is even by investigating
    whether or not the previous number is odd. They all subtract `targetNumber` by
    one until it becomes zero, and since zero is an even number, it''s now quite easy
    to determine whether `targetNumber` is odd or even. Now, we add the following
    code to examine whether the number `5` is even or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `CheckNumberFive()` method, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indirect recursion over direct recursion](img/Image00090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to make this clearer, let''s take a look at the following indirect recursion
    flow involving the `IsOdd()` and `IsEven()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding flow, we can see that when we check whether number 5 is even
    or not, we move down to number 4 and check whether it is odd. We then check number
    3 and so on, until we reach 0\. By reaching 0, we can easily determine whether
    it's odd or even.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion in a functional approach using LINQ Aggregate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we deal with a factorial formula, we can use LINQ Aggregate to refactor
    our recursive function into a functional approach. LINQ Aggregate will accumulate
    the given sequence, and then we will have the result of the recursion from the
    accumulator. In [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional
    Style in C#") , *Tasting Functional Style in C#* we have already done this refactoring.
    Let''s borrow the code from the chapter to analyze the use of the `Aggregate`
    method. The following code will use the `Aggregate` method, which we can find
    in the `RecursionUsingAggregate.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `GetFactorialAggregate()` method and pass `5` as the
    parameter, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursion in a functional approach using LINQ Aggregate](img/Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding console screenshot, we get the exact same result
    compared to what we get with the use of nonaggregate recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into the Aggregate method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed earlier, the `Aggregate` method will accumulate the given sequence.
    Let''s take a look at the following code, which we can find in the `AggregateExample.csproj`
    project file, to demonstrate how the `Aggregate` method works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we have a list of `int` data types,
    which contains numbers from 1 to 6\. We then invoke the `Aggregate` method to
    sum up the members of `listInt` . Here is the flow of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `AggregateInt()` method, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Delving into the Aggregate method](img/Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Actually, the `Aggregate` method not only adds the number, but it also adds
    the string. Let''s examine the following code, which demonstrates the `Aggregate`
    method used to add the string sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `AggregateString()` method, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Delving into the Aggregate method](img/Image00093.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a declaration of the `Aggregate` method that we can find in
    MSDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the flow of the `AggregateUsage()` method based on the previous
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding flow, we can concatenate all strings in `listString` using
    the `Aggregate` method. This proves that not only can the `int` data type be handled,
    but the string data type can be handled as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although C# has a feature to iterate a sequence using the `for` or `while` loop,
    it's better for us to approach functional programming using recursion to iterate
    the sequence. We already discussed how the recursion routine works and refactored
    the iteration into recursion. We know that in the recursion, we have a base case
    that will define the end of the recursion chain.
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional recursion model, the recursive call performs first then returns
    the value and then calculates the result. The result won't be displayed until
    the recursive call is finished. Whereas, the tail recursion doesn't do anything
    after recursion at all. There are two styles in tail recursion; they are APS and
    CPS.
  prefs: []
  type: TYPE_NORMAL
- en: Besides direct recursion, we also discussed indirect recursion. Indirect recursion
    involves at least two functions. Then, we applied recursion into the functional
    approach using the **Aggregrate LINQ** operator. We also delved into the Aggregate
    operator and discussed how it works.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss optimizing techniques to make our code
    more efficient. We will use laziness thinking so the code will be executed at
    the perfect time and also caching techniques so the code doesn't need to execute
    every time it's required.
  prefs: []
  type: TYPE_NORMAL
