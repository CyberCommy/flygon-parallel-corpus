- en: Exit Codes, Signals, and Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue on from the previous one and will demonstrate the
    communication between parent and child processes. In particular, the chapter will
    show you how communication can be managed with the correct usage of exit codes,
    through custom signal handling and by connecting processes with pipes. These forms
    of communication will be used to allow our application to communicate effectively
    with the operating system and other processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Returning exit codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading exit codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercepting signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using other stream utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, you can refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Using exit codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An exit code, or exit status, is a small integer number that is passed from
    a process to its parent when the process exits. It is the simplest way of notifying
    you of the result of the application execution. In [Chapter 2](1c402360-b565-4d0b-b201-fdd6baaa5c5c.xhtml), *Unix
    OS Components,* we briefly mentioned exit codes. We will now learn how to use
    them inside applications and how to interpret the exit codes of child processes.
  prefs: []
  type: TYPE_NORMAL
- en: Sending exit codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exit codes are the way in which a process notifies its parent about its status
    after terminating. In order to return any exit status from the current process,
    there is one function that does the job in a straightforward way: `os.Exit`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function takes one argument, that is, an integer, and represents the exit
    code that will be returned to the parent process. This can be verified using a
    simple program, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/-6GIY7EaVD_V](https://play.golang.org/p/-6GIY7EaVD_V).
  prefs: []
  type: TYPE_NORMAL
- en: The exit code, `0`, is used when the application is executed successfully. Any
    other exit code symbolizes some type of error that may have occurred during the
    execution. When the main function finishes, it returns a `0`; when a panic is
    not recovered, it returns a `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes in bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every time a command gets executed in a shell, the resulting exit code gets
    stored in a variable. The status of the last command executed gets stored in the `$?`
    variable, and it can be printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the exit code only works when you run a binary
    obtained with `go build` or `go install`. If you use `go run`, it will return
    `1` for any code that is not `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The exit value bit size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exit status is an 8-bit integer; this means that even if the argument for
    the Go function is an integer, then the status that is returned will be the result
    of a modulo operation between the passed value and `256`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/vzwI1kDiGrP](https://play.golang.org/p/vzwI1kDiGrP).[ ](https://play.golang.org/p/vzwI1kDiGrP)
  prefs: []
  type: TYPE_NORMAL
- en: This will have an exit status of `255` even if the function argument is `-1`
    because `(-1)%256=255`. This happens because the exit code is an 8-bit number
    (`0`, `255`).
  prefs: []
  type: TYPE_NORMAL
- en: Exit and deferred functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important caveat about this function's use is that deferred functions are
    not executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will have no output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/2zbczc_ckgb](https://play.golang.org/p/2zbczc_ckgb).
  prefs: []
  type: TYPE_NORMAL
- en: Panics and exit codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the application terminates for a panic that is not recovered, then the deferred
    function will be executed, but the exit code will be `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/mjOMb0KsM3e](https://play.golang.org/p/mjOMb0KsM3e).
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes and goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the `os.Exit` function happens in a goroutine, all the goroutines (including
    the main one) will terminate immediately without executing any deferred call,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/JVEB5MTcEoa](https://play.golang.org/p/JVEB5MTcEoa).
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary for you to use `os.Exit` carefully because, since all the deferred
    operations will not be executed, this could lead to resource leaks or errors,
    such as not flushing a buffer and not writing all the content to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Reading child process exit codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We explored how to create child processes in the previous chapter. Go makes
    it possible for you to easily check child exit codes, however, it's not straightforward
    because there is a field in the `exec.Cmd` struct that has an `os.ProcessState`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os.ProcessState` attribute has a `Sys` method that returns an interface.
    Its value is a `syscall.WaitStatus` struct in Unix, which makes it possible to
    access the exit code using the `ExitCode` method. This is demonstrated using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the command variable cannot be accessed, then the error returned is `exec.ExitError`
    and this wraps the `os.ProcessState` attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see that obtaining the exit code is not straightforward and requires
    some typecasting.
  prefs: []
  type: TYPE_NORMAL
- en: Handling signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals are the other inter-process communication tools that Unix operating
    systems offer. They are integer values that can be sent from one process to another
    process, giving our application the capability of communicating with more processes
    than just the parent. By doing so, the application is capable of interpreting
    the incoming signals and can also send signals to other processes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling incoming signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The normal behavior for a Go application is to handle some incoming signals,
    including `SIGHUP`, `SIGINT`, and `SIGABRT`, by terminating the application. We
    can replace this standard behavior with a custom behavior that intercepts all
    or some of the signals and acts accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The signal package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The custom behavior is accomplished using the `os/signal` package, which exposes
    the necessary functions.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if the application does not need to intercept a signal, the `signal.Ignore`
    function allows you to add a signal to the ignored list. The `signal.Ignored` function
    also permits you to verify whether a certain signal has been ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to intercept signals with a channel, you can use the core function,
    that is, `signal.Notify`. This makes it possible to specify a channel and to choose
    which signals should be sent to that channel. The application can then use the
    channel in any goroutine to handle signals with a custom behavior. Note that if
    no signal is specified, then the channel will receive all the signals that are
    sent to the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `signal.Stop` function is used to halt the reception of signals from a certain
    channel, while the `signal.Reset` function stops intercepting one or more signals
    to all channels. In order to reset all the signals, no argument needs to be passed
    to `Reset`.
  prefs: []
  type: TYPE_NORMAL
- en: Graceful shutdowns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application executes a graceful shutdown when it waits for a task to finish
    and clears all of its resources before terminating. Using custom signal handling
    is a very good practice, because it gives us time to release resources that are
    still open. Before shutting down, we can perform any other task that should be
    done before exiting the application; for instance, saving the current status.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how exit codes work, we can introduce the `log` package. This
    will be used from now on to print a statement to the standard output instead of `fmt`.
    This makes it possible to execute the `Print` statement and the `Fatal` statement, which
    is the equivalent of printing and executing `os.Exit(1)`. The `log` package also
    allows the user to define log flags to print the date, time, and/or file/line
    with each print.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with a very basic example, handling all signals as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In order to test this application, you can use two different Terminals. First,
    you can launch the application in the first Terminal and use the other Terminal
    to execute the `ps` command to find the PID application, in order to send signals
    to it with the `kill` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method, which uses just one Terminal, launches the application in
    the background. This will show the PID on the screen and will be used in the `kill` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you're using macOS, you'll get an `abort trap` signal name.
  prefs: []
  type: TYPE_NORMAL
- en: Exit cleanup and resource release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more practical and common example of a clean shutdown is resource cleanup.
    When using exit statements, deferred functions such as `Flush` for a `bufio.Writer` struct
    are not executed. This can lead to information loss, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If a `TERM` signal is sent to this application before it finishes, the file
    will be created and truncated, but the flush will never be executed—resulting
    in an empty file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This could, perhaps, be the intended behavior, but this is rarely the case.
    It is better to do any cleanup in the signal handling part, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are using a goroutine in combination with the signal channel
    to flush the writer before exiting. This will ensure that whatever is written
    to the buffer gets persisted on the file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration reload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals can be used for more than just terminating an application. An application
    can react differently to each signal, so that it can be used to accomplish different
    functions, making it possible to control the application flow.
  prefs: []
  type: TYPE_NORMAL
- en: The next example will have some settings stored in a text file. The settings
    will be of the `time.Duration` type stored as its  string version. A duration
    is an `int64` value with a string version that is in a human-readable format,
    such as `2m10s`, which also has many useful methods. This is used in different
    functions of the `time` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will execute a certain operation with a frequency that depends on the
    current settings value. Possible operations with signals include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP (1)`: This loads the interval from the settings file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM (2)`: This saves the current interval values, and exits the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGQUIT (6)`: This exits without saving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGUSR1 (10)`: This increases the interval by doubling it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGUSR2 (11)`: This decreases the interval by halving it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGALRM (14)`: This saves the current interval value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capturing these signals is done with the `signal.Notify` function, which is
    called for all the different signals. The value received from the channel requires
    a condition statement, a type switch, to allow the application to execute a different
    action according to the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handleSignal` function will contain the `switch` statement in the signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following describes the different behaviors that will be implemented in
    the signal handing function:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the value will just use the duration pointer to store the new value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading will try to scan the content of the file (if present) as a duration
    and change the settings value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Saving will write the duration to the file, and it will use its string format.
    The following code depicts this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the path of the user''s home directory in the `init` function and
    use it to compose the path of the `settings` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can launch the application in a Terminal and use another Terminal to send
    signals, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Terminal 1** | **Terminal 2** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In the left column, we can see the output from the application; in the right
    column, we can see the commands we launched to trigger them. In order to get the
    PID of the running application, we are using the `pgrep` command and nesting in
    `kill`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending signals to other processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing the way in which incoming signals are handled, let's take a look
    at how to send signals to other processes programmatically. The `os.Process` structure
    is the only tool we need—its `Signal` method makes it possible to send a signal
    to the project. It's that easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'The less simple part is obtaining the process. There are two use cases, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The process is a child, and we have the process value already as a result of
    `os.StartProcess` or `exec.Command` structs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process is already existing but we do not have it, so we need to search
    for it using its PID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first use case is simpler, as we already have the process as a variable,
    or as an attribute of an `exec.Cmd` variable, and we can call the method directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other use case requires searching for the process by PID using the `os.FindProcess`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have `os.Process`, we can use its `Signal` method to send a specific
    signal to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The type of signal we will send to a process depends on the destination process
    and the behavior we want to suggest, such as an interruption or a termination.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streams in Go are an abstraction that makes it possible to see any sort of communication
    or data flow as a series of readers and writers. We have already learned that
    streams are an important element of Go. We'll now learn how to use what we already
    know about input and output to control the streams related to a process—the input,
    output, and error.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes are one of the best ways of connecting input and output in a synchronous
    way, allowing processes to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Different commands can be chained in a sequence when using a shell, making
    one command output the following command input. For example, consider the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are displaying a file, using the preceding command to filter rows containing
    a certain string and, finally, using the filtered output to count the lines.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done programmatically in Go when the processes are created inside
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `io.Pipe` function returns a reader/writer couple that is connected; whatever
    gets written to the pipe writer will be read by the pipe reader. The write operation
    is a blocking one, which means that all of the written data has to be read before
    a new write operation can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: We already saw that `exec.Cmd` allows generic streams for its output and input—this
    allows us to use the values returned by the `io.Pipe` function to connect one
    process to the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the three commands, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cat` with index `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep` with index `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wc` with index `2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we can define the two pipes we need, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we link the input and output streams. We connect the `cat` (command `0`)
    output and the `grep` (command `1`) input, and we do the same for the `grep` output
    and the `wc` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We then start our commands, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We wait until the end of the execution of each command and we close the respective
    pipe writer; otherwise, the next command reader will hang. To make things easier,
    each pipe writer is an element in a slice, and each writer has the same index
    as the command that it is linked to. The last one is `nil` because the last command
    is not linked by a pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There are also other tools provided by the `io` package that can help simplify
    some operations.
  prefs: []
  type: TYPE_NORMAL
- en: Standard input and output pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `io.MultiWriter` function makes it possible to write the same content to
    several readers. This will be extremely useful when the output of a command needs
    to be broadcast to a series of different commands automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we want to do what we did before (that is, look for a word in
    a file), but for different words. We can use the `MultiWriter` function to copy
    the output to a series of `grep` commands, each of which will be connected to
    its own `wc` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use two auxiliary methods of `exec.Command` in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cmd.StdinPipe`: This returns a `PipeWriter` struct that will be connected
    to the command standard input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cmd.StdoutPipe`: This returns a `PipeReader` struct that will be connected
    to the command standard output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by defining a list of search terms: one for the command''s tuples
    (`grep` and `wc`), one for writers connected to the first command, and one for
    the final output of each command chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define the commands and their connection—each `grep` command will
    be connected on one side to `cat` using the `MultiWriter` function with the piped
    writers, and on the other side to the input of the `wc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the main `cat` command and, when it finishes, we can close the first
    set of writing pipes, so that the `grep` command can terminate, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can wait for the other command to finish and show the results, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that, when the `StdinPipe` method is used, the resulting writer must be
    closed, but this is not necessary with `StdoutPipe` method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to handle communications between processes
    using three main functionalities: exit codes, signals, and pipes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes are 8-bit values between `0` and `255` that are returned by a process
    to their parent. An exit code of `0` means that the application execution was
    successful. It's pretty easy to return an exit code in Go, but doing so using
    the `os.Exit` function shortcuts the execution of the deferred functions. When
    a panic occurs, all the deferred functions are executed and the returned code
    is `2`. Getting an exit code from a child process is relatively trickier, because
    it's OS-dependent; however, in Unix systems, it can be accomplished using a series
    of type assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Signals are used to communicate with any process. They are 6-bit values, between
    1 and 64, sent from one process to another using a system call. Receiving signals
    can be done using a channel and the `signal.Notify` function. Sending signals
    is easily done with the `Process.Signal` method.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes are a tuple of input and output streams that are synchronously connected. They
    are used to connect a process input to another process output. We saw how to connect
    multiple commands in the same way that a Terminal does and we learned how to use
    `io.MultiReader` to broadcast one command output to many commands.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to dig into network programming, starting
    from TCP all the way up to HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an exit code? Who makes use of it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when an application panics? Which exit code is returned?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default behavior of a Go application when receiving all signals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you intercept signals and decide how the application must behave?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you send signals to other processes? If so, how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are pipes and why are they important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
