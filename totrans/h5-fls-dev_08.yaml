- en: Chapter 8. Exporting to HTML5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Code Once, Release Everywhere"), *Code
    Once, Release Everywhere,* we spent some time learning about the CreateJS JavaScript
    framework as well as the CreateJS Toolkit plugin for Flash Professional CS6 ([http://www.adobe.com/ca/products/flash/flash-to-html5.html](http://www.adobe.com/ca/products/flash/flash-to-html5.html))
    and how they can easily integrate your pre-existing knowledge of Flash development
    directly into HTML5 projects. Over the last year, Adobe has adopted this framework
    to be the official way to work with Flash-based assets in your HTML5 projects.
    That being said, there are actually a number of other ways that you can achieve
    somewhat of the same effect when attempting to directly move your Flash-based
    applications and games into pure HTML5\. In this chapter, we will continue to
    look at some of the third-party tools and applications that may aid you in your
    asset and code development flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically generating HTML5 projects from a Flash SWF with Google's Swiffy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually converting animated assets to HTML5-ready sprite sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your JavaScript libraries and frameworks in ActionScript 3 with Jangaroo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Targeting all of your platform development needs in a single language source
    with Haxe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building robust web applications using Google's Dart programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Swiffy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swiffy project created by Google ([https://www.google.com/doubleclick/studio/swiffy](https://www.google.com/doubleclick/studio/swiffy))
    is one of the easiest ways to port your pre-existing Flash applications into HTML5
    projects. The aim of the project is to take in the already compiled Flash SWF
    files, and convert the data within into a JSON object with SVG vector animation
    data. The resulting Swiffy compiled JavaScript, can then be run directly within
    a modern web browser with the aid of the Google Swiffy Runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this project is still in Beta and has many limitations, Swiffy supports
    Flash projects written in both ActionScript 2 and ActionScript 3 allowing you
    to possibly avoid having to ever think about manually converting your AS2 to AS3
    projects manually. The support for more complex Flash assets within your projects
    is growing at a steady rate, however, it will be worth your time to check out
    the current browser and feature-support lists on the project website prior to
    usage as it may not fully cover the application you intend to convert ([https://www.google.com/doubleclick/studio/swiffy/gettingstarted.html](https://www.google.com/doubleclick/studio/swiffy/gettingstarted.html)).
    ActionScript 3 support within Swiffy is limited to using specific methods within
    specific classes to be sure the conversion can properly take place. At the time
    of writing this book, the ActionScript 3 support within Swiffy contains the following
    limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling is not supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional arguments are not supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML handling is not supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of object initialization and construction is not constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the full, up-to-date documentation for current ActionScript 3 support
    on the Swiffy ActionScript 3 Support page on the project website (https://www.google.com/doubleclick/studio/swiffy/actionscript3.html).
    If you head over to the ActionScript Support page, you can get a better sense
    of what classes and methods can be used within your Flash applications. If your
    application exceeds the supported properties listed in the project support page,
    there is a very high likelihood of your application not converting properly.
  prefs: []
  type: TYPE_NORMAL
- en: How does Swiffy work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get an idea of how Swiffy works and to see the output and limitations first
    hand, let''s create a simple Flash application and convert it to HTML5 and view
    what happens. We will start with what is possibly the best case scenario for Swiffy
    conversions. Our Flash project will contain assets and animations completely created
    from within the Flash Professional IDE and avoid the use of any ActionScript for
    the time being. To make this example a little closer to a real-world example,
    we can pretend this Flash application is a pre-existing banner ad or other simple
    Flash movie which we would like to display on mobile devices or any other devices
    that don''t have access to the Adobe Flash Player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How does Swiffy work?](img/3325OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As ugly as the preceding example is, it actually represents some important
    factors to test. First off, we have a circle which has been motion tweened around
    the stage. Second, we have a rectangle filled with a gradient background color,
    again in the vector format. Finally, we have two lines of text: one is a simple
    use of the **Times New Roman** font and the other is a test of a more complex
    font such as **Wingdings**. Just like the two shapes, the text will be animated
    across the stage upon playback. The idea with this test is to see how well Swiffy
    deals with the extremely common SWF setup of just timeline modified elements.
    To make this test less complicated, we will also leave out any ActionScript and
    assume the timeline will loop infinitely.'
  prefs: []
  type: TYPE_NORMAL
- en: With the timeline created, we can go ahead and output a SWF of this movie into
    our project directory. All Swiffy requires to generate its Web-ready output is
    the single SWF created from your Flash project, so open up a web browser and head
    over to the Swiffy project website ([https://www.google.com/doubleclick/studio/swiffy](https://www.google.com/doubleclick/studio/swiffy)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, Swiffy will allow you to upload any SWF file
    that equals or is less than 1 MB in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are all ready to convert your SWF, use the form on the front page
    of the project website to upload your SWF to the Swiffy servers. It should only
    take a moment or two for the results to appear, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How does Swiffy work?](img/3325OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The results should display something like the preceding screenshot. A preview
    of the converted SWF will appear in Web-ready display as well as all of the output
    messages and links to download the output. The supplied QR code on every SWF conversion
    page will allow you to easily test the generated source on a mobile device to
    verify it is working properly. As displayed on the output page, you can easily
    download the HTML document along with all the other data by right-clicking on
    the link to the external output example (in this case, `Banner-Test.html`) and
    save the referenced page that way.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Swiffy-generated code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the content saved onto your local machine, let''s take a quick moment
    to review exactly what has been done, and how we could transplant this asset into
    a pre-existing website. After opening up the HTML file, the first thing to take
    note of is the use of external libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This JavaScript call is importing the Google Swiffy runtime from the Google
    file server and is required to properly display the data following it. Just like
    CreateJS, the code that has been created is a hybrid of JavaScript and needs a
    final interpreter in order to properly function. This is a critically important
    thing to note about Swiffy. Including the `runtime.js` file is an absolute requirement
    to your project provided any assets generated from Swiffy were added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Directly after the Swiffy runtime inclusion, you will notice a huge blob of
    text contained in more HTML `<script>` tags. The following is a snippet of what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This data is the JavaScript object which represents all of the data from your
    assets and animations included in the original SWF. Since our example contained
    no Bitmap images, and everything within it was vector based, the entire application
    has been compiled down to 100 percent code and can be displayed with a couple
    lines of further JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finding Swiffy's limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of this is fine and dandy until we start to make things a little more complicated.
    In the next example, I have created a very simple game in ActionScript 3\. The
    idea of the game is to control the position of the box on the stage by moving
    your mouse around the visible stage. As time passes, your box will begin to grow
    and take up more space on the stage. The goal of the game is to go as long as
    possible without letting your box touch any of the randomly moving black dots.
    For simplicity, I have not included any user interface in this game. All of the
    results and output will just be sent to the web browser developer console for
    the time being. As always, you can check out the example in the working form as
    it is contained in the downloadable chapter example files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding Swiffy''s limits](img/3325OT_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Yes, it is extremely crude, but it covers many common aspects of Flash applications
    in a manageable number of lines of code, which is perfect for our purposes of
    demonstration. As mentioned, there is no user interface in the game as any of
    the game output will just be sent to the Flash output debug window. Let''s take
    a look at the code before going any further so you can take note of the specific
    features, classes, and variable types that have been utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are interested in actually compiling the source of this application,
    you can find all of the files to open it within Flash Builder as an ActionScript
    project. Compile the application to a SWF and test the application locally to
    confirm it is working. If all is well, let''s attempt to send this file to Swiffy
    and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding Swiffy''s limits](img/3325OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Provided you followed the steps properly, Swiffy will fail when attempting to
    convert this SWF and generate the error list in the previous screenshot. Let take
    a quick look at what went wrong, the limitations, and workarounds that could be
    put into place to correct the issue. To begin, the first error listed the notice
    that arrays are not supported by the Swiffy compiler. In our application's case,
    we used an array to contain all of the bad-guy instances in a single global variable.
    Without the use of arrays in this or any application, the requirement to manage
    data in a more primitive manner is required. This issue alone can be the deciding
    factor when deciding to use Swiffy to do your conversion. Although there are many
    ways to get around this issue, the fact of the matter is, if you have an application
    that is littered with arrays, chances are the current version of Swiffy will not
    be able to help you. Regardless of all that bad news, let's move on to the second
    issue. Not surprisingly, the `hitTestObject` method, which is common in ActionScript
    3 development, is not supported by the compiler either.
  prefs: []
  type: TYPE_NORMAL
- en: 'This easy-to-use method can be a life saver when simple collision detection
    is required in Flash development, but since there is no direct JavaScript equivalent
    to convert it to. Again, this can be compensated for but the resulting code would
    be far larger then calling a single method as one is used to in typical ActionScript
    3 development. So this can be considered an issue, but not a dead end provided
    your collision detection is only using the supported methods and properties. The
    final error listed in our conversion attempt was the use of the `Sprite.graphics`
    class. If you recall, the code example specifically used MovieClips rather than
    Sprites, as Sprites are not supported by the Swiffy compiler. However, unlike
    the `Player` object, which was originally created within the Flash Professional
    IDE and saved into a SWC, the bad guy objects were created within the code with
    the use of the internal ActionScript 3 Graphics API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These three lines are the reason for the final error. Since the `MovieClip`
    object in Flash is built on top of the `Sprite` class, the resulting error follows
    suit. Since the SWC deals with the creation of the `Player` object, no errors
    are passed for that object. However, it is worth noting that even with these errors
    fixed by removing all of the bad guys and only having a box moving around, the
    successfully converted result still displays nothing on the HTML version of the
    game. At the moment, it seems Swiffy doesn't support the use of SWC's in the ActionScript
    3 project, it is more comfortable using the old school pure Flash IDE development
    style of application development.
  prefs: []
  type: TYPE_NORMAL
- en: All of this being said, the reality is that the majority of the work Swiffy
    can reliably do for you is simple Flash applications and movie conversions, not
    your typical Flash game or application. Despite the lack for many features that
    have commonly been used in Flash development for years, Swiffy can still be a
    very handy tool for assets such as integrated website animations or advertisement
    banners.
  prefs: []
  type: TYPE_NORMAL
- en: Generating sprite sheets in Flash Professional CS6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ever intend to port or copy some of your pre-existing Flash-based timeline
    animations to a HTML5 project, you are going to have to do some conversion of
    your own. As you have seen in the examples in this book, timeline animations just
    don't exist in the HTML5 stack. Therefore, you will need to convert the animation
    sequence into a new format that can be displayed properly on the Web. One of the
    easiest options is converting the animation into a video file and using the `<video>`
    tag element to play it back. Unfortunately, converting bitmap or vector assets
    into a video file that can properly be played back on the Web will result in a
    ton of quality loss. To top that off, the video playback will be very heavy resulting
    in slower application load times. Finally, videos in HTML5 lack many important
    features such as support of alpha transparency, resulting in all of your assets
    contained in a fully visible rectangular container. To get around all of these
    issues, many web developers are turning to the tried and true method of sprite
    sheets. The concept behind sprite sheets is pretty simple. Take all of the frames
    in your animation sequence, place them all side by side on the same image (with
    a transparent background), and save the image as an uncompressed PNG file. This
    way, when loaded by a client over the Web, downloading a single file is all that
    is needed to have the entire animation sequence in memory ready for playback.
    Converting your Flash-based timeline animations into sprite sheets manually, by
    copy and pasting each frame into a PNG document, is a long a tedious undertaking.
    Thankfully, it is one undertaking you will not need to deal with as Flash Professional
    CS6 has incorporated a sprite sheet generator right in the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Using the sprite sheet generator in Flash CS6 is painfully simple. The good
    folks at Adobe have managed to create a tool that will easily have you using your
    Flash animations in your HTML5 projects in minutes. Though simple to use, the
    feature can be a little hidden, so let's quickly take a look at the sprite sheet
    generator in action and place some of the results in a working HTML5 document
    to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example purposes, I have created a very simple example of a Flash animation
    on the timeline which includes only three different shapes. Each shape is displayed
    for only 5 frames for a total of 15 frames of animation:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, you can find all the example files in the downloadable chapter examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Locate the MovieClip within the library of the Flash project and right-click
    on it. Reviewing the context menu displayed when right-clicking on any MovieClip,
    you will find a **Generate Sprite Sheet** option. Select this option and you will
    be presented with the new, feature rich, **Generate** **Sprite Sheet** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Upon initial inspection, you can see every frame in your animation has automatically
    been appended to the same document and lined up in a grid format. As mentioned,
    this animation contains 15 frames, therefore, every frame has been appended to
    the sprite sheet **Preview** window and is displayed with the default configuration.
    Before saving this output, let's check out some of the options available to see
    if we can optimize this sprite sheet any further.
  prefs: []
  type: TYPE_NORMAL
- en: We can start by getting a general overview of what we are about to export. At
    the bottom-left corner of the **Generate Sprite Sheet** window, you will find
    the details of the current MovieClip containing the frame count and duration based
    on a specific frame rate. On the right side of the window, you can see an easy-to-view
    preview of what the sprite sheet will look like when generated under the current
    configuration. Selecting the second **Preview** tab will display the animation
    running in its native form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the preview window is all of the configuration properties available to
    you when exporting the animation assets and dataset. The dimensions of the exported
    image can be automatically sized by Flash or configured manually to set the available
    area where your animation frame can be placed. The image format can also be configured
    as PNG or JPG formats to allow for further compression on the exported image.
    It is recommended that you set this as PNG with no background unless required
    to allow for proper image background transparency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The right size of the configuration properties contains the settings for the
    dataset export. Since the image exported for the sprite sheet will only contain
    the frame assets and no animation data, the sprite sheet will require some form
    of data in order to properly playback. You will usually have no issue when using
    the basic algorithm from the available slicing algorithms. With the basic setting,
    sprites are arranged in nice uniform rows in an easy-to-use grid layout. This
    is the optimal output setting when dealing with any simple animation. The other
    current option for algorithms is the **MaxRects** option. This option is used
    to attempt to pack the frames as tightly together as possible. The reason one
    would do this is to minimize the exported image filesize to allow for faster download
    times over an Internet connection. Once an algorithm has been selected, we can
    move on to probably the most important setting in this export window. The **Data
    format** selection allows you to set the data export format to specifically work
    with how ever you are developing your HTML5 application. Support for **The Sparrow
    Framework** for iOS development ([http://gamua.com/sparrow](http://gamua.com/sparrow)),
    **The Starling Framework** for ActionScript 3 ([http://gamua.com/starling/](http://gamua.com/starling/)),
    as well as **Cocos2D** ([http://cocos2d.org/](http://cocos2d.org/)) have been
    included. As a HTML5 developer, the three main export settings you will probably
    be most interested in are the **JSON**, **JSON-Array**, and **easeljs** options.
    Exporting the dataset as a simple JSON export will allow you to use the data universally
    as JSON in the open standard for human-readable data storage. The **JSON-Array**
    setting is extremely similar with the difference of storing the data in JSON arrays
    rather than direct objects. The difference between the two will really only affect
    how you interpret the data within your code. Finally, the **easlejs** export setting
    allows you to automatically prepare the exported animation for inclusion in your
    CreateJS, or EaselJS project. This export setting is handy when you are attempting
    to include an external asset within another Flash project into a pre-existing
    CreateJS toolkit-based project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final settings in the configuration are the **Trim** and **Stack frames**
    options. Trimming the frames in the sprite sheet will remove any unused empty
    space between each of the elements within. This will again optimize your end result
    by minimizing the exported image filesize. Finally, the **Stack frames** option
    allows you to further optimize your animation by removing or stacking any frames
    that are identical in your animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there will be no need to store the same image twice since the exported
    dataset will contain the timeline information, these assets can be removed without
    issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With all of these settings covered, let''s export this animation with the settings
    in the previous screenshot to see what we get for an output. When the **Export**
    button is clicked, the window will close when completed, and you will be able
    to find the exported material in the root of your project directory. With the
    **JSON** setting appended to the **Data format** option, two files are exported.
    The first file is the sprite sheet image in the PNG format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating sprite sheets in Flash Professional CS6](img/3325OT_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second file is our JSON output containing all of the frame positions and
    sizes of the animation. The following is a snippet from the exported JSON containing
    the animation data for the first three frame of animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is extremely simple to read and understand which is good, as from
    this point out without the use of a game development framework or CreateJS, we
    have to interpret and display this data and assets ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Due to the tremendous support for CreateJS in Flash Professional CS6, the export
    and usage of the EaselJS setting for sprite sheets is definitely the easiest way
    to go. However, as demonstrated in the previous code snippet, with the standardized
    JSON export methods, you can implement any Flash animation as a sprite sheet into
    your HTML5 projects with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested in learning more about sprite sheets but you don't want
    to spend time creating all of the assets, head over to Google images and search
    for sprite sheets. You will find an endless resource of great sprite sheets to
    test your applications with. Of course, you should always be sure to have permission
    or ownership of any asset when used on a public facing website.
  prefs: []
  type: TYPE_NORMAL
- en: Jangaroo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The story behind the development of Jangaroo ([http://www.jangaroo.net](http://www.jangaroo.net))
    is actually pretty interesting. Created by the development team at CoreMedia ([http://www.coremedia.com](http://www.coremedia.com)),
    Jangaroo was built out of the frustrations the internal development team had with
    the current JavaScript development capabilities. Rather than dealing with many
    of the common syntax issues that JavaScript possess, the development team at CoreMedia
    set about to create a ActionScript 3 to JavaScript compiler written in Java. As
    absurd as that may sound, the actuality is that Flash developers can easily continue
    writing in a familiar syntax while specifically targeting HTML5-based web development.
    Jangaroo aims to allow developers to write high quality JavaScript frameworks
    and applications with the power of ActionScript 3\. In a nutshell, it will take
    in ActionScript 3 files, and with the use of its compiler written in Java, convert
    them into ready to use JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jangaroo](img/3325OT_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So why would anyone want to avoid writing native JavaScript and begin writing
    ActionScript 3 for the next HTML5 project? Well, as a developer with previous
    experience writing ActionScript 3, you can probably already answer this question
    from all of the examples and overviews so far in this book. When it comes to writing
    large robust applications in HTML5, the lack of packages, classes, and proper
    inheritance in JavaScript can begin to create a minefield of code which can be
    tricky to manage. By allowing yourself to continue developing your applications
    in a language that you are not only used to, but allows for easier management
    of the classes in your project, you can surpass many common hurdles that would
    have arisen during a pure JavaScript development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The heart of the Jangaroo project is the Jangaroo ActionScript 3 to JavaScript
    compiler called `jooc`. The compiler will take in your ActionScript `.as` files
    and export them as compiled JavaScript `.js` files. To install and run Jangaroo,
    you will need to begin by making sure you have installed an up-to-date version
    of the Java Runtime Environment ([http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html))
    as well as Maven ([http://maven.apache.org](http://maven.apache.org)). The installation
    and setup of these two pieces of software may seem intimidating, but be sure the
    process is extremely straightforward and well-documented, so I will leave that
    process up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One note worth making when dealing with installing the Java Runtime Environment
    on your computer is to be sure the `JAVA_HOME` environment variable is properly
    set. If you encounter any issue during the installation of testing process of
    Jangaroo, this will be a good place to start debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an example of a simplified development cycle of a JavaScript-driven
    application created with ActionScript 3 and compiled with Jangaroo, let''s use
    the HelloWorld example that can be found on the project website ([http://www.jangaroo.net/tutorial](http://www.jangaroo.net/tutorial)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code example, the syntax available to your ActionScript
    classes is a hybrid of common ActionScript 3 as well as some special window and
    document object references to allow you to integrate your application into the
    browser properly. If you are interested in learning more about the language and
    code syntax options when preparing ActionScript 3 for the Jangaroo compiler, head
    over to the **Writing Code** page in the official Jangaroo documentation ([http://www.jangaroo.net/tutorial/writing_code](http://www.jangaroo.net/tutorial/writing_code)).
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of Jangaroo is open source and the project code and assets can be found
    on the CoreMedia Github page ([https://github.com/CoreMedia](https://github.com/CoreMedia)).
  prefs: []
  type: TYPE_NORMAL
- en: Haxe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keeping on the topic of compiling applications and other programming languages
    directly to JavaScript, I should take a moment and cover some of the exciting
    features in the world of Haxe development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Haxe](img/3325OT_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Haxe** ([http://haxe.org](http://haxe.org)) is its own standalone open source
    programming language. Where most programming languages are built for a specific
    application type in mind, JavaScript for the Web, ActionScript for Flash, Haxe
    can be compiled and run on a variety of platforms and devices all from the same
    source code. Haxe source can selectively be compiled into JavaScript, Flash, PHP,
    C++, C#, and Java and with your prior experience with ActionScript 3 and new skills
    you have learned in JavaScript, learning the Haxe language syntax is a breeze.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although cross-platform development may not be of interest to you right now,
    having at least a basic understanding of what languages such as Haxe offer may
    allow you to fill some more gaps in your development skill set. Just for some
    final clarity before we move on, let''s take a quick peek at an example snippet
    of Haxe code which can be found on the **Code Snippets** page on the Haxe project
    website ([http://haxe.org/doc/snip](http://haxe.org/doc/snip)). The following
    code is an example of implementing the popular sorting method, Quicksort ([http://en.wikipedia.org/wiki/Quicksort](http://en.wikipedia.org/wiki/Quicksort)).
    Since we already have an idea of what this sorting algorithm is attempting to
    accomplish, let''s review this code to mainly get an idea of class, method, and
    variable syntax in the Haxe programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see directly in the first line, Haxe has full class support unlike
    JavaScript. This concept alone may be a selling point as ActionScript developers
    moving over into Haxe will find many more similarities which are unavailable in
    JavaScript. Other features such as static functions, strict variable typing, and
    common debug methods such as `trace()` are just a couple more of the great features
    within Haxe that specifically let a developer with previous ActionScript 3 development
    experience shine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are interested in learning more about the exciting world of Haxe development,
    checkout the book *Haxe 2 Beginners Guide*, *Packt Publishing* ([http://www.packtpub.com/haxe-2-beginners-guide/book](http://www.packtpub.com/haxe-2-beginners-guide/book)).
  prefs: []
  type: TYPE_NORMAL
- en: Haxe itself is a beast of a project. The ability to cross compile your application
    source code directly to almost every modern platform available is an extremely
    valuable asset when you are developing a project with very specific platform requirements.
    Even if you intend to target only HTML5 web projects with your Haxe source code,
    having the ability to move your application to another platform with only a couple
    clicks of the mouse is pretty amazing. Also, as with many of the other platforms
    and compilers we have reviewed in this chapter, Haxe can alleviate many of the
    common complaints web developers have with JavaScript syntax. The project is still
    relatively new although many developers have already jumped on the bandwagon.
    If developing your next application in Haxe sounds like an interesting challenge,
    I highly recommend looking into it some more.
  prefs: []
  type: TYPE_NORMAL
- en: Google Dart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the goal of helping developers from all platforms build complex, high-performance
    client apps for the modern Web, Google''s Dart ([https://code.google.com/p/dart/](https://code.google.com/p/dart/))
    is another great example of pushing web development, more specifically JavaScript
    development, to the limit. Just like Haxe, Dart is an open-source project that
    uses its own specific programming language to compile into Web-ready JavaScript
    documents and just like Jangaroo, Dart was built out of the frustrations with
    the limits of the current web development platforms. In an attempt to bring a
    new structured, single language workflow Google has released a *Technology Preview*
    of the Dart project for early testing and feedback from the web development community:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Dart](img/3325OT_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, since Dart is built on its own language syntax, there will be a learning
    curve involved when first starting out. To aid in the strain of learning a new
    language, I highly recommend checking out the official Dart Editor. The Dart Editor
    ([http://www.dartlang.org/docs/editor/](http://www.dartlang.org/docs/editor/))
    is probably the easiest way to get up and running with Dart development.
  prefs: []
  type: TYPE_NORMAL
- en: 'It supports features such as real-time error and syntax checking to alert you
    of any issues before you compile, as well as code completion to help you understand
    what can be done with each method and property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Dart](img/3325OT_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Dart Editor, like many others, is built on the popular Eclipse IDE. As simplified
    as the code editor is, this can be considered another win for anyone with Flash
    Builder experience as the interface will be extremely familiar. I say this editor
    is simplified because the editor does not come as a plugin for Eclipse, instead
    it comes packaged as its own standalone Eclipse-based editor with all of the unnecessary
    elements removed from it.
  prefs: []
  type: TYPE_NORMAL
- en: Like the overview of Haxe, I will keep this brief as Dart is still a very new
    project and I have yet to personally meet anyone who has developed a popular web
    application with it. That being said, there is absolutely no reason to discredit
    a language such as Dart. As the JavaScript specification evolves and browser support
    follow suit, the need for these projects may become less. However, as any Flash
    developer knows, the ability to compile projects with a proper debug and output
    flow can allow them to find and fix issues faster than many traditional methods
    of writing client-side scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of this chapter, we spent some time looking at some projects
    that are pushing the limits of web application development from websites and libraries
    such as Google's Swiffy project that easily allow you to convert simple Flash
    SWF files directly to a Web-friendly HTML and JavaScript configuration, to familiar
    methods of exporting Flash vector and bitmap animations into Web-ready sprite
    sheets right from within the Flash Professional IDE. Projects such as Haxe, Dart,
    and Jangaroo give developers new options when attempting to create their HTML5
    projects. The native JavaScript that will drive their application can actually
    be written in a completely different language altogether. Extending the capabilities
    of JavaScript into other languages may seem backwards at first, but the reasons
    for creating these projects generally all come down to the lack of common language
    syntax and development flow issues developers have when writing JavaScript. As
    mentioned earlier, none of the projects or features within specific applications
    mentioned in this chapter are required when developing you next HTML5 project.
    Arming yourself with the knowledge of what projects and platforms web developers
    have available to them right now will allow you to come to better conclusions
    as to the best way for you to tackle your next HTML5 project.
  prefs: []
  type: TYPE_NORMAL
- en: I have to stress, the list of applications, features, and compilers mentioned
    in this chapter is only a small fraction of what is available to you when working
    with JavaScript. If you are interested in seeing more projects that can compile
    to and or extend JavaScript, head over to [http://altjs.org](http://altjs.org)
    to get a start. There you will find a listing of projects that target beginner
    to advanced developer styles, so I am sure there will be something there to interest
    you. Many of these projects are based off of CoffeeScript ([http://coffeescript.org](http://coffeescript.org)),
    yet another dedicated language that compiles directly to JavaScript, which is
    yet another great project I recommend checking out. The number of projects related
    to extending JavaScript's development flow and abilities seems endless, and growing
    every day. No one can ever expect you to know all of them, but having a general
    understanding of what is out there and what many of these platforms can do will
    allow you to make faster and better decisions when setting out to develop your
    next project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we will begin taking everything we have covered up
    to this point into an actual HTML5 application development flow. We will cover
    many of the important aspects every developer should be aware of when developing
    for the Web as well as a way to properly test your application as you develop.
    Finally to wrap everything up, we will take that application to the Internet and
    cover some ways to publish and maintain your project once it is live.
  prefs: []
  type: TYPE_NORMAL
