- en: Chapter 10. Concurrent Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using join/fork framework in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the reusable synchronization barrier Phaser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ConcurrentLinkedDeque class safely with multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the LinkedTransferQueue class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting multiple threads using the ThreadLocalRandom class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Support for concurrent applications has been improved in Java 7\. Several new
    classes have been introduced that support the parallel execution of tasks. The
    `ForkJoinPool` class is used for applications, which use the divide-and-conquer
    technique to solve a problem. Each subproblem is forked (split) as a separate
    thread and later joined, if necessary to provide a solution. The threads used
    by this class are normally subclasses of the `java.util.concurrent.ForkJoinTask`
    class and are lightweight threads. The use of this approach is illustrated in
    the *Using join/fork framework in Java* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `java.util.concurrent.Phaser` class has been introduced to
    support the execution of a collection of threads in a series of phases. A group
    of threads are synchronized, so that they all execute and then wait for the completion
    of the others. Once they have all completed, they can be re-executed for a second
    phase or subsequent phase. The *Using the reusable synchronization barrier Phaser*
    recipe illustrates the use of this class in a game engine setting.
  prefs: []
  type: TYPE_NORMAL
- en: The *Using the java.util.concurrent.ConcurrentLinkedDeque class safely with
    multiple threads* and *Using the java.util.concurrent.LinkedTransferQueue class*
    recipes introduced two new classes designed to work safely with multiple threads.
    Examples of their use in support of the producer/consumer framework are illustrated.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.concurrent.ThreadLocalRandom` class is new and provides better
    support for random number generation used between multiple threads. It is discussed
    in the *Supporting multiple threads using the ThreadLocalRandom class* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Two new constructors have been added to the `java.util.ConcurrentModificationException`
    class. They both accept a `Throwable` object used to specify the cause of the
    exception. One of the constructors also accepts a string that provides a detail
    message regarding the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 has improved the use of class loaders by modifying the locking mechanism
    to avoid deadlocks. In multi-threaded custom class loaders prior to Java 7, certain
    custom class loaders were prone to deadlocks, when they used a cyclic delegation
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following scenario. Thread1 tries to use a ClassLoader1 (locking
    ClassLoader1) to load class1\. It then delegates the loading of class2 to ClassLoader2\.
    At the same time, Thread2 uses ClassLoader2 (locking ClassLoader2) to load class3,
    and then delegates the loading of class4 to ClassLoader1\. Since both class loaders
    are locked and both the threads need both loaders, a deadlock situation occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The desired behavior of a concurrent class loader is to load different classes
    from the same instance of the class loader concurrently. This requires locking
    at a finer level of granularity, such as locking a class loader by the name of
    the class being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization should not be done at the class loader level. Instead, a lock
    should be made on a class level, where the class loader allows only a single instance
    of the class to be loaded at a time by that class loader.
  prefs: []
  type: TYPE_NORMAL
- en: Some class loaders are capable of loading classes concurrently. This type of
    class loader is called **parallel capable class loaders**. They are required to
    register themselves during their initialization process using the `registerAsParallelCapable`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: If the custom class loader uses an acyclic hierarchal delegation model, no changes
    are needed in Java. In a hierarchal delegation model, delegation is first made
    to its parent class loader. Class loaders that do not use the hierarchical delegation
    model should be constructed as parallel capable class loaders in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid deadlock for custom class loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `registerAsParallelCapable` method in the class initialization sequence.
    This indicates that all instances of the class loader are multi-thread safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure that the class loader code is multi-thread safe. This involves:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an internal locking scheme, such as the class name locking scheme used
    by `java.lang.ClassLoader`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing any synchronization on the class loader lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that critical sections are multi-thread safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended that the class loader overrides the `findClass(String)` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `defineClass` methods are overridden, then ensure that they are only
    called once per class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More detail about this problem can be found at [http://openjdk.java.net/groups/core-libs/ClassLoaderProposal.html](http://openjdk.java.net/groups/core-libs/ClassLoaderProposal.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using join/fork framework in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **join/fork** framework is an approach that supports breaking a problem
    into smaller and smaller pieces, solving them in parallel, and then combining
    the results. The new `java.util.concurrent.ForkJoinPool` class supports this approach.
    It is designed to work with multi-core systems, ideally with dozens or hundreds
    of processors. Currently, few desktop platforms support this type of concurrency,
    but future machines will. With fewer than four processors, there will be little
    performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: The `ForkJoinPool` class is derived from the `java.util.concurrent.AbstractExecutorService`
    making it an `ExecutorService`. It is designed to work with `ForkJoinTasks`, though
    it can be used with normal threads. The `ForkJoinPool` class differs from other
    executors, in that its threads attempt to find and execute subtasks created by
    other currently running tasks. This is called **work-stealing**.
  prefs: []
  type: TYPE_NORMAL
- en: The `ForkJoinPool` class can be used for problems where the computation on the
    subproblems is either modified or returns a value. When a value is returned, a
    `java.util.concurrent.RecursiveTask` derived class is used. Otherwise, the `java.util.concurrent.RecursiveAction`
    class is used. In this recipe we will illustrate the use of the `RecursiveTask`
    derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the fork/join framework for a task that returns a result for each subtask:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a subclass of `RecursiveTask` that implements the computation needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `ForkJoinPool` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `ForkJoinPool` class' `invoke` method with the instance of the subclass
    of the `RecursiveTask` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This application is not intended to be implemented in the most efficient manner,
    but is used to illustrate the fork/join task. As a result, on systems with a small
    number of processors, there may be little or no performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new console application. We will use a static inner class that is
    derived from `RecursiveTask` to compute the sum of squares of the integers in
    the `numbers` array. First, declare the `numbers` array as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `SumOfSquaresTask` class as follows. It creates a subrange of array
    elements and either uses an iterative loop to compute their sum of squares or
    breaks the array into smaller pieces based on a threshold size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `main` method. For comparison purposes, the sum of squares
    is computed using a for loop and then using the `ForkJoinPool` class. The execution
    time is calculated and displayed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should be similar to the following. However,
    you should observe different execution times depending on your hardware configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sum of squares: 18103503627376**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterative solution time: 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sum of squares: 18103503627376**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork/join solution time: 23**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the iterative solution is faster than the one using the fork/join
    strategy. As mentioned earlier, this approach is not always more efficient, unless
    there are a large number of processors.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application repeatedly will result in different results. A more
    aggressive testing approach would be to execute the solution repeatedly under
    possibly different processor loading conditions and then take the average of the
    result. The size of the threshold will also affect its performance.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `numbers` array was declared as a 100,000 element integer array. The `SumOfSquaresTask`
    class was derived from the `RecursiveTask` class using the generic type `Long`.
    A threshold of 1000 was set. Any subarray smaller than this threshold was solved
    using iteration. Otherwise the segment was divided in half and two new tasks were
    created, one for each half.
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrayList` was used to hold the two subtasks. This was strictly not needed
    and actually slows down the computation. However, it would be useful if we decided
    to partition the array into more than two segments. It provides a convenient way
    of recombining the elements when the subtasks are joined.
  prefs: []
  type: TYPE_NORMAL
- en: The `fork` method was used to split up the subtasks. They entered the thread
    pool and will eventually be executed. The `join` method returned the results when
    the subtask completed. The sum of the subtasks was added together and then returned.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` method, the first code segment computed the sum of squares using
    a `for` loop. The start and stop time were based on the current time measured
    in milliseconds. The second segment created an instance of the `ForkJoinPool`
    class, and then used its `invoke` method with a new instance of the `SumOfSquaresTask`
    object. The arguments passed to the `SumOfSquaresTask` constructor, instructed
    it to start with the first element of the array and end with the last. Upon completion,
    the execution time was displayed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ForkJoinPool` class has several methods that report on the state of the
    pool, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPoolSize:` This method returns the number of threads that are started but
    are not completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRunningThreadCount:` This method returns an estimate of the number of threads
    that are not blocked but are waiting to join other tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveThreadCount:` This method returns an estimate of the number of threads
    executing tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ForkJoinPool` class'' `toString` method returns several aspects of the
    pool. Add the following statement immediately after the `invoke` method is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program executes, you will get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**forkJoinPool: java.util.concurrent.ForkJoinPool@18fb53f6[Running, parallelism
    = 4, size = 55, active = 0, running = 0, steals = 171, tasks = 0, submissions
    = 0]**'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the reusable synchronization barrier Phaser* recipe offers a different
    approach for executing multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Using the reusable synchronization barrier Phaser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.concurrent.Phaser` class is concerned with the synchronization
    of threads that work together in cyclic type phases. The threads will execute
    and then wait for the completion of the other threads in the group. When all of
    the threads are completed, one phase is done. The `Phaser` can then be used to
    coordinate the execution of the same set of threads again.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.concurrent.CountdownLatch` class provided a way of doing this,
    but required a fixed number of threads, and is executed once by default. The `java.util.concurrent.CyclicBarrier`,
    which was introduced in Java 5, also used a fixed number of threads, but is reusable.
    However, it is not possible to advance to the next phase. This is useful when
    a problem is characterized by a series of steps/phases that advance from one phase
    to the next based on some criteria.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of the `Phaser` class in Java 7, we now have a concurrency
    abstraction that combines the features of `CountDownLatch` and `CyclicBarrier`
    and adds support of a dynamic number of threads. The term, phase, refers to the
    idea that the threads can be coordinated to execute in distinct phases, or steps.
    All of the threads will execute and then wait for the others to complete. Once
    they have completed, they will then begin anew and complete a second or subsequent
    phase of operation.
  prefs: []
  type: TYPE_NORMAL
- en: A barrier is a type of block that prevents a task from proceeding further until
    some condition is met. A common condition is when all of the related threads have
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Phaser` class provides several features, which makes it useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Parties can be added and removed from the thread pool dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a unique phase number associated with each phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Phaser` can be terminated causing any waiting threads to return immediately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions that occur do not affect the state of the barrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `register` method increments the number of parties that are participating.
    The termination of a phaser occurs when the internal count reaches zero or as
    determined by some other criteria set.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop an application that mimics the operation of a game engine. The
    first version will create a series of tasks representing participants in a game.
    We will use the `Phaser` class to coordinate their interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `Phaser` class to synchronize the start of a set of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a collection of `Runnable` objects that will participate in the phaser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Phaser` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each participant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the participant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new thread using the participants' `Runnable` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `arriveAndAwaitAdvance` method to wait for the other tasks to be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Phaser` object's `arriveAndDeregister` to start the execution of the
    participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application with a class called `GamePhaserExample`. We
    will create a simple hierarchy of inner classes that represent the participants
    in a game. Add the `Entity` class as the base abstract class, defined as follows.
    While not absolutely necessary, we''ll be using inheritance to simplify the development
    of these types of applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create two derived classes: `Player` and `Zombie`. These classes
    implement the `run` method and a `toString` method. The `run` method uses the
    `sleep` method to simulate the work performed. As expected, zombies are slower
    than humans:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the example clearer, add the following `main` methoid to the `GamePhaserExample`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following `execute` method where we create a list of participants
    and then call the `gameEngine` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gameEngine` method follows. A `for each` loop creates a thread for each
    participant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The output is non-deterministic, but should be similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Player #1 joined the game**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 joined the game**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #2 joined the game**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 waiting for the remaining participants**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 waiting for the remaining participants**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #3 joined the game**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phaser continuing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #3 waiting for the remaining participants**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #2 waiting for the remaining participants**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #3 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #3 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #2 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #2 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #3 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #2 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `Phaser` object waits until all of the participants have joined
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sleep` method was used to simulate the work involved by that entity. Notice
    the use of the `ThreadLocalRandom` class. Its `nextInt` method returned a random
    number between the values specified in its parameters. When using concurrent threads,
    this is the preferred way of generating random numbers as detailed in the *Supporting
    multiple threads using the ThreadLocalRandom class* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the `AtomicInteger` class was used to assign unique IDs to each
    object created. This is a safe way of generating numbers in threads. The `toString`
    method returns a simple string representation of the entity.
  prefs: []
  type: TYPE_NORMAL
- en: In the `execute` method, we created an `ArrayList` to hold the participants.
    Notice the use of the diamond operator in the creation of the `ArrayList`. This
    Java 7 language improvement is explained in the *Using the diamond operator for
    constructor type inference* recipe in [Chapter 1](ch01.html "Chapter 1. Java Language
    Improvements"), *Java Language Improvements*. One player and three zombies were
    added. The zombies always seem to outnumber the humans. The `gameEngine` method
    was then called.
  prefs: []
  type: TYPE_NORMAL
- en: A `Phaser` object was created with an argument of one and that represented the
    first participant. It is not an entity and simply served as a mechanism to help
    control the phaser.
  prefs: []
  type: TYPE_NORMAL
- en: In the for each loop, the number of parties in the phaser was incremented by
    one using the `register` method. A new thread was created using an anonymous inner
    class. In its `run` method, the entity was not started until all of the participants
    arrived. The `arriveAndAwaitAdvance` method resulted in the notification that
    a participant has arrived, and that the method should not return until all of
    the participants have arrived and the phase has finished.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of each iteration of the `while` loop, the number of registered
    participants was one larger than the number of participants who have arrived.
    The `register` method incremented this internal count by one. The internal count
    was then two more than the number that had arrived. When the `arriveAndAwaitAdvance`
    method is executed, the number of participants who are waiting now will be one
    more than those who had registered.
  prefs: []
  type: TYPE_NORMAL
- en: After the loop terminated, there was still one more registered party than participants
    who had arrived. However, when the `arriveAndDeregister` method executed, the
    internal count of the number of participants who had arrived matched the number
    of participants, and the threads started. In addition, the number of registered
    parties was decreased by one. When all of the threads terminated, the application
    terminated.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to register a group of parties using the `bulkRegister` method.
    This method takes a single integer argument specifying the number of parties to
    register.
  prefs: []
  type: TYPE_NORMAL
- en: Under some conditions, it may be desirable to force the termination of the phaser.
    The `forceTermination` method is used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the execution of a phaser, there are several methods that will return
    information about the state of the phaser as detailed in the following table.
    If the phaser has terminated, then these methods will have no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getRoot` | Returns the root Phaser. Used with a tree of Phasers |'
  prefs: []
  type: TYPE_TB
- en: '| `getParent` | Returns the parent of the Phaser |'
  prefs: []
  type: TYPE_TB
- en: '| `getPhase` | Returns the current phase number |'
  prefs: []
  type: TYPE_TB
- en: '| `getArrivedParties` | The number of parties that have arrived at this current
    phase |'
  prefs: []
  type: TYPE_TB
- en: '| `getRegisteredParties` | The number of registered parties |'
  prefs: []
  type: TYPE_TB
- en: '| `getUnarrivedParties` | The number of parties that have not yet arrived at
    this current phase |'
  prefs: []
  type: TYPE_TB
- en: A tree of phasers can be constructed, where a phaser is created as a branch
    of the task. The `getRoot` method is useful in this situation. The phaser construct
    is discussed at [http://www.cs.rice.edu/~vs3/PDF/SPSS08-phasers.pdf](http://www.cs.rice.edu/~vs3/PDF/SPSS08-phasers.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Using a phaser to repeat a series of tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use the `Phaser` class to support a series of phases where tasks
    are executed, a possible intermediate action is performed, and then the series
    of tasks are repeated again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this behavior, we will modify the `gameEngine` method. The modification
    will include:'
  prefs: []
  type: TYPE_NORMAL
- en: The addition of an `iterations` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overriding of the `Phaser` class' `onAdvance` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `while` loop within each task's `run` method controlled by the `isTerminated`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a variable called `iterations` and initialize it to `3`. This is used to
    specify how many phases we will use. Also, override the `onAdvance` method shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each phase is uniquely numbered and starts at zero. A call to the `onAdvance`
    passes the current phase number and the current number of parties registered to
    the phaser. The default implementation of this method returns `true` when the
    number of registered parties becomes zero. This results in the phaser being terminated.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of this method resulted in the method returning `true` only
    if the phase number exceeded the `iterations` value, that is, minus 1, or there
    are no registered parties using the phaser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `run` method as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The entity is allowed to run first, and then it waits for the other participants
    to complete and arrive. As long as the phaser has not been terminated as determined
    by the `isTerminated` method, the next phase will be executed when everyone is
    ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to use the `arriveAndAwaitAdvance` method to advance the phaser
    to the next phase. Again, as long as the phaser has not terminated, the phaser
    will advance to the next phase when every participant has arrived. Use the following
    code sequence to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program using only one player and one zombie. This will reduce
    the amount of output and should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 joined the game**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 joined the game**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 waiting for the remaining participants during phase 0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 waiting for the remaining participants during phase 0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase number 0 completed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 waiting for the remaining participants during phase 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 waiting for the remaining participants during phase 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase number 1 completed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 starting run**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player #1 waiting for the remaining participants during phase 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 stopped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zombie #1 waiting for the remaining participants during phase 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phase number 2 completed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Phaser continuing**'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Using a random number generator isolated to the current thread* recipe
    for further information about generating random numbers for multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new ConcurrentLinkedDeque safely with multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.concurrent.ConcurrentLinkedDeque` class, which is a member of
    the Java Collections Framework, offers the ability for multiple threads to safely
    access the same data collection concurrently. The class implements a double-ended
    queue, known as a **deque**, and allows for the insertion and removal of elements
    from both ends of the deque. It is also known as a head-tail linked list and,
    like other concurrent collections, does not allow the usage of null elements.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will demonstrate a basic implementation of the `ConcurrentLinkedDeque`
    class and illustrate the use of some of the most common methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use a `ConcurrentLinkedDeque` in a producer/consumer framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of a `ConcurrentLinkedDeque`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the element to place into the deque.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a producer thread to generate elements to be placed in the deque.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a consumer thread to remove elements from the deque.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new console application. Declare a private static instance of a `ConcurrentLinkedDeque`
    using a generic type of `Item`. The `Item` class is declared as an inner class.
    Include get methods and constructors, as shown in the following code, using two
    attributes, `description` and `itemId:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a producer class to generate elements of the type `Item`. For this
    recipe''s purposes, we are only going to generate seven items and then print out
    a statement to demonstrate that the item has been added to the deque. We use the
    `ConcurrentLinkedDeque` class'' `add` method to add the elements. After each addition,
    the thread sleeps briefly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a consumer class. To ensure that the deque will have elements
    in it by the time the consumer thread tries to access it, we make the thread sleep
    for one second prior to retrieving elements. Then we use the `pollFirst` method
    to retrieve the first element in the deque. If the element is not null then we
    pass the element to a `generateOrder` method. In this method, we print out information
    about the item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our `main` method, we start both threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the program, you should see output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**New Item Added:Item1 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item2 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item3 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item4 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item5 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item6 6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item7 7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**para'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 7**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we started both threads, we gave the producer thread a head start to populate
    our deque with items. After a second, the consumer thread began retrieving elements.
    The use of the `ConcurrentLinkedDeque` class allowed both threads to safely access
    elements of the deque at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we made use of the methods `add` and `pollFirst` to add and
    remove elements of the deque. There are a number of methods available, many of
    which operate in essentially the same fashion. The *There's more..*. section provides
    more detail about the various options for accessing the deque elements.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will cover several topics including:'
  prefs: []
  type: TYPE_NORMAL
- en: Problems with asynchronous concurrent threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding elements to the deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving elements from the deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a specific element of the deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems with asynchronous concurrent threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the fact that multiple threads may be accessing the collection at any
    given moment, the `size` method is not always going to return an accurate result.
    This is also true when using the `iterator` or `descendingIterator` methods. Additionally,
    any bulk data operations, such as `addAll` or `removeAll`, are not always going
    to achieve the desired results. If one thread is accessing an item in the collection
    and another thread tries to pull all items, the bulk action is not guaranteed
    to function atomically.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two `toArray` methods available for retrieving all elements of the
    deque and storing them in an array. The first returns an array of objects representing
    all of the elements of the deque and can be cast to the appropriate data type.
    This is useful when the elements of the deque are of different data types. The
    following is an example of how to use the first form of the `toArray` method using
    our previous thread example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The other `toArray` method requires an initialized array of a specific data
    type as an argument and returns an array of elements of that data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Adding elements to the deque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table lists some of the methods available for adding elements
    to the deque. The methods that are grouped together in the following table perform
    essentially the same function. This variety of similar methods is the result of
    the `ConcurrentLinkedDeque` class implementing slightly different interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method name | Adds an element to |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add(Element e)``offer(Element e)``offerLast(Element e)``addLast(Element
    e)` | End of the deque |'
  prefs: []
  type: TYPE_TB
- en: '| `addFirst(Element e)``offerFirst(Element e)``push(Element e)` | Front of
    the deque |'
  prefs: []
  type: TYPE_TB
- en: Retrieving elements from the deque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some of the methods available for retrieving elements from
    the deque:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method name | Error action | Function |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `element()` | Throws exception if deque is empty | Retrieves but does not
    remove the first element of the deque |'
  prefs: []
  type: TYPE_TB
- en: '| `getFirst()` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `getLast()` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `peek()` | Returns null if deque is empty |   |'
  prefs: []
  type: TYPE_TB
- en: '| `peekFirst()` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `peekLast()` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | Throws exception if deque is empty | Retrieves and removes first
    element of deque |'
  prefs: []
  type: TYPE_TB
- en: '| `removeFirst()` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `poll()` | Returns null if deque is empty |   |'
  prefs: []
  type: TYPE_TB
- en: '| `pollFirst()` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| `removeLast()` | Throws exception if deque is empty | Retrieves and removes
    last element of deque |'
  prefs: []
  type: TYPE_TB
- en: '| `pollLast()` | Returns null if deque is empty |   |'
  prefs: []
  type: TYPE_TB
- en: Accessing a specific element of the deque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some of the methods available for accessing specific elements
    of a deque:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method name | Function | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `contains(Element e)` | Returns `true` if the deque contains at least one
    element that equals `Element e` |   |'
  prefs: []
  type: TYPE_TB
- en: '| `remove(Element e)``removeFirstOccurrence(Element e)` | Removes the first
    occurrence of an element in the deque that equals `Element e` | If the element
    does not exist in the deque, the deque is unchanged. Throws exception if `e` is
    null |'
  prefs: []
  type: TYPE_TB
- en: '| `removeLastOccurrence(Element e)` | Removes the last occurrence of an element
    in the deque that equals `Element e` |   |'
  prefs: []
  type: TYPE_TB
- en: Using the new LinkedTransferQueue class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.concurrent.LinkedTransferQueue` class implements the `java.util.concurrent.TransferQueue`
    interface and is an unbounded queue that follows a **First In First Out** model
    for the queue elements. This class provides blocking methods and non-blocking
    methods for retrieving elements and is an appropriate choice for concurrent access
    by multiple threads. In this recipe we will create a simple implementation of
    a `LinkedTransferQueue` and explore some of the methods available in this class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use a `LinkedTransferQueue` in a producer/consumer framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of a `LinkedTransferQueue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a type of element to place into the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a producer thread to generate elements to be placed in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a consumer thread to remove elements from the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Declare a private static instance of a `LinkedTransferQueue`
    using a generic type of `Item`. Then create the inner class `Item` and include
    get methods and constructors, as shown in the following code, using two attributes,
    `description` and `itemId` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a producer class to generate elements of the type `Item`. For
    this recipe''s purposes, we are only going to generate seven items and then print
    out a statement to demonstrate that the item has been added to the queue. We will
    use the `LinkedTransferQueue` class'' `offer` method to add the elements. After
    each addition, the thread sleeps briefly and we print out the name of the item
    added. We then use the `hasWaitingConsumer` method to determine if there are any
    consumer threads waiting for items to become available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a consumer class. To demonstrate the function of the `hasWaitingConsumer`
    method, we make the thread sleep for one second prior to retrieving elements to
    ensure there is no waiting consumer at first. Then, within a `while` loop, we
    use the `take` method to remove the first item in the list. We chose the `take`
    method because it is a blocking method and will wait until the queue has an available
    element. Once the consumer thread is able to take an element, we pass the element
    to the `generateOrder` method, which prints out information about the item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our `main` method, we start both threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the program, you should see output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**New Item Added:Item1 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item2 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item3 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item4 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hurry up!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item5 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hurry up!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item6 6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hurry up!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part Order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item description: Item7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Item ID # 7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Item Added:Item7 7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hurry up!**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we started both threads, we gave the producer thread a **head start** to
    populate our queue with items by sleeping for one second in the `ItemConsumer`
    class. Notice that the `hasWaitingConsumer` method returned `false` initially
    because the `take` method had not yet been executed by the consumer thread. After
    a second, the consumer thread began retrieving elements. With each retrieval,
    the `generateOrder` method printed out information about the element retrieved.
    After all elements in the queue were retrieved, notice a final *Hurry up!* statement,
    indicating there is still a consumer waiting. In this example, because the consumer
    is using a blocking method within a `while` loop, the thread will never terminate.
    In a real life situation, the thread should be terminated in a more graceful manner,
    such as sending a terminate message to the consumer thread.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we used the methods `offer` and `take` to add and remove elements
    of the queue. There are other methods available and these are discussed in the
    *There's more..*. section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Problems with asynchronous concurrent threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding elements to the queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving elements from the deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems with asynchronous concurrent threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the fact that multiple threads may be accessing the collection at any
    given moment, the `size` method is not always going to return an accurate result.
    Additionally, any bulk data operations, such as `addAll` or `removeAll`, are not
    always going to achieve the desired results. If one thread is accessing an item
    in the collection and another thread tries to pull all items, the bulk action
    is not guaranteed to function atomically.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements to the queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some of the methods available for adding elements to the
    queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method name | Adds element to the | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add(Element e)` | End of the queue | Queue is unbounded, so the method will
    never return `false` or throw an exception |'
  prefs: []
  type: TYPE_TB
- en: '| `offer(Element e)` |   | Queue is unbounded, so the method will never return
    `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `put(Element e)` |   | Queue is unbounded, so the method will never block
    |'
  prefs: []
  type: TYPE_TB
- en: '| `offer(Element``e, Long t`,`TimeUnit u)` | End of the queueWait for t time
    units of type u before giving up | Queue is unbounded, so the method will always
    return `true` |'
  prefs: []
  type: TYPE_TB
- en: Retrieving elements from the deque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some of the methods available for retrieving elements from
    the deque:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method name | Function | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `peek()` | Retrieves, but does not remove the first element of the queue
    | Returns null if the queue is empty |'
  prefs: []
  type: TYPE_TB
- en: '| `poll()` | Removes the first element of the queue | Returns null if the queue
    is empty |'
  prefs: []
  type: TYPE_TB
- en: '| `poll(Long t, TimeUnit u)` | Removes element from front of the queue, waiting
    time t (in units u) before giving up | Returns null if the time limit is up before
    an element is available |'
  prefs: []
  type: TYPE_TB
- en: '| `remove(Object e)` | Removes element from the queue that equals `Object e`
    | Returns `true` if the element is found and removed |'
  prefs: []
  type: TYPE_TB
- en: '| `take()` | Removes the first element of the queue | Throws an exception if
    interrupted while blocking |'
  prefs: []
  type: TYPE_TB
- en: '| `transfer(Element e)` | Transfers an element to the consumer thread, waiting
    if necessary | Will insert an element at the end of the queue and wait for the
    consumer thread to retrieve it |'
  prefs: []
  type: TYPE_TB
- en: '| `tryTransfer(Element e)` | Transfers an element immediately to the consumer
    | Returns `false` if the consumer is not available |'
  prefs: []
  type: TYPE_TB
- en: '| `tryTransfer(Element e, Time t, TimeUnit u)` | Transfers an element to the
    consumer immediately, or within time specified by t (in units u) | Returns `false`
    if the consumer is not available when the time limit has elapsed |'
  prefs: []
  type: TYPE_TB
- en: Supporting multiple threads using the ThreadLocalRandom class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.concurrent` package has a new class, `ThreadLocalRandom`, which
    supports functionality similar to the `Random` class. However, the use of this
    new class, with multiple threads, will result in less contention and better performance
    as compared to their use with the `Random` class. When multiple threads need to
    use random numbers, the `ThreadLocalRandom` class should be used. The random number
    generator is local to the current thread. This recipe examines how to use this
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The recommended way of using this class is to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the static `current` method to return an instance of the `ThreadLocalRandom`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the methods of the class against this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Add the following code to the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program. Your output should appear similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Five random integers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**4232237**'
  prefs: []
  type: TYPE_NORMAL
- en: '**178803790**'
  prefs: []
  type: TYPE_NORMAL
- en: '**758674372**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1565954732**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Random double number between 0.0 and 35.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.196571144914888**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Five random Long numbers between 1234567 and 7654321**'
  prefs: []
  type: TYPE_NORMAL
- en: '**7525440**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2545475**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1320305**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1240628**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1728476**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nextInt` method was executed five times with its return value being displayed.
    Notice that the method returns 0 initially. The `ThreadLocalRandom` class extends
    the `Random` class. However, the `setSeed` method is not supported. If you try
    to use it, it will throw an `UnsupportedOperationException.`
  prefs: []
  type: TYPE_NORMAL
- en: The `nextDouble` method was then executed. This version of the overloaded method
    returned a number between 0.0 and 35.0\. The `nextLong` method was executed five
    times using two parameters, which specified its starting (inclusive) and ending
    (exclusive) range values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The methods of this class return uniformly distributed numbers. The following
    table summarizes its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a range is specified, the start value is inclusive and the end value is
    exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Parameters | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `current` | None | The thread''s current instance |'
  prefs: []
  type: TYPE_TB
- en: '| `next` | Integer value representing the number of bits for the return value
    | An integer in the range specified by the number of bits |'
  prefs: []
  type: TYPE_TB
- en: '| `nextDouble` | doubledouble, double | A double number between 0.0 and its
    argumentA double number between its arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `nextInt` | int, int | An integer number between its arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `nextLong` | longlong, long | A long number between 0 and its argumentA long
    number between its arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `setSeed` | long | Throws `UnsupportedOperationException` |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examples of its use are found in the *Using the reusable synchronization barrier
    Phaser* recipe.
  prefs: []
  type: TYPE_NORMAL
