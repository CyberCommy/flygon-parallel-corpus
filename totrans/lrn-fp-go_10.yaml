- en: Monads, Type Classes, and Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional programming in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: “Not sure if it’s a good idea, but let’s try it anyway.”
  prefs: []
  type: TYPE_NORMAL
- en: '"Fun to think about;  Not sure how to use it."'
  prefs: []
  type: TYPE_NORMAL
- en: '"The Y-Combinator is a theoretical concept with no practical value."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Who can understand the code in this Monad package. Lambda what? Generics?"'
  prefs: []
  type: TYPE_NORMAL
- en: Please put your prejudices aside, work through this chapter, and then ask yourself,
    How relevant is functional programming in Go?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goals in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand how a Monad works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to compose functions using the `bind` operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how the `Success` and `Failure` paths work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how a Monad deals with impure operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work through a Monadic workflow implementation in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn what Lambda Calculus is and what it has to do with Monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how Lambda Calculus implements recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how the Y-Combinator works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Y-Combinator to control workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to write concise workflow code and handle all errors at the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how `Type` classes work and implement a few in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the pros and cons of generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mother Teresa Monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Who are you? Are you a good person or a bad person? What would other people
    say? How did you become the person you are now?
  prefs: []
  type: TYPE_NORMAL
- en: Ponder those questions for a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Monad?
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation is like answering the question: How were you raised as a child
    and what have you become?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we explore a Monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85062f95-936f-4bd1-9029-605db3113f17.png)'
  prefs: []
  type: TYPE_IMG
- en: The chain of blue boxes represents moments in the flow of Mother Teresa’s life.
  prefs: []
  type: TYPE_NORMAL
- en: The closed blue boxes represent her private time from birth to death. The open
    boxes represent events in which she opened herself up to interactions with the
    world around her.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose she was nurtured as a baby and received positive input (the blue
    incoming arrow). Also suppose that along the way, she was exposed to some negative
    input (the dark incoming arrows) as well as positive input. Her life (the data)
    was transformed in some way during every interaction. As she grew, her actions
    were her side effects (the outgoing arrows from the open box).
  prefs: []
  type: TYPE_NORMAL
- en: Success might be defined as entering the gates of Heaven after death (or Hell,
    for failure).
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a Monad? It’s a mechanism into which data flows, interacts with
    an impure environment, is transformed, and eventually comes out the other end;
    it's a way to structure and control the workflow in a real application that interfaces
    with external endpoints, such as log files, external APIs, notifications, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram should prompt a few questions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaa61d9a-9347-43d8-a1b3-6a28798f1dca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 4](../Text/Ch04.xhtml)*, SOLID Design in Go*, we saw how a function
    **f** receives **a** and returns **b**, but we also recognized that in the real
    world, where connections fail and RAM and disk space might fill up, errors may
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f240bdf3-e10c-4774-8809-4ab6fd3db71b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To keep our diagram clean-looking, we’ll just move the errors arrow up and
    shoot it out the right side, rather than underneath. We’ll also color the input
    and output arrows blue. That’s our pure, happy path. See? No side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6861edad-2f1c-4bc4-a1ab-51bf44b9e134.png)'
  prefs: []
  type: TYPE_IMG
- en: But real programs can have side-effects, right? Real programs interface with
    external APIs, accept input from users, print invoices, and send emails, right?
    Where’s the real stuff?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/626d32fa-3ca4-4221-a3fc-d1e29374fd4a.png)'
  prefs: []
  type: TYPE_IMG
- en: We have two inputs matching our two outputs so that we can easily link our blue
    boxes into a chain. Remember when we discussed the decomposition of finite state
    machines? We pulled apart the pieces (**C1**, **C2**, and **C5**) of our application.
    These are our *reusable components*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9da2dd7-73a6-4bad-8b2d-109d381446cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That was done in order to fill our toolbox with individual components, which
    we can subsequently use to re-compose our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a11dbf4-f3ea-454d-8777-b7d90703bc0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Ever wonder how our pieces will fit back together?
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not going to work if all our pieces look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/144f9738-0d14-4f05-9f81-d15a3d65554a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, consider if the pieces looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca9657ab-fc8e-4f21-bcc7-15d1f1dcc93d.png)'
  prefs: []
  type: TYPE_IMG
- en: Then they will all fit together like legos! See how they fit together?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd0c509c-eb4f-458b-a9b0-80699dcca0b7.png)'
  prefs: []
  type: TYPE_IMG
- en: How can we go from a one-input to a two-input thing?
  prefs: []
  type: TYPE_NORMAL
- en: The bind operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We accomplish this feat using the Monad''s bind operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07c89347-d1df-40ec-a06f-6777445ed542.png)'
  prefs: []
  type: TYPE_IMG
- en: In Haskell, it’s called the `bind` operation. Other names for bind include `flatMap`,
    `flatten`, `andThen`, `collect`, and `SelectMany`. (That's part of what makes
    functional programming confusing--different languages use different names for
    the same thing.) The Lexical Workflow calls it `Next`.
  prefs: []
  type: TYPE_NORMAL
- en: More descriptive names might be adapt, link, or even hard shove. (In our code
    example, we'll use the name `Next`, because it makes the most sense in the context
    of moving to the `Next` step.) Bind is a pattern that adapts the one-input, two-output
    block to a two-input, two-output block.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about the two paths--the top blue path is the `Success` path.
    That’s our *Happy Path*, through which our data flows, as long as all goes well.
    The bottom red path is where errors go.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/455761cf-fe6f-40a8-9b0b-d04bc5679c21.png)'
  prefs: []
  type: TYPE_IMG
- en: The lift operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s examine what happens when an error occurs in the lift operation of our
    second component in the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/507a1ede-9f0c-404e-93de-cdc5e8b79831.png)'
  prefs: []
  type: TYPE_IMG
- en: Lifting lifts a function into a *wrapped* type. Lift connects our functions
    from one world and another.
  prefs: []
  type: TYPE_NORMAL
- en: A functor lifts single parameter functions. An applicative functor lifts second
    multi parameter functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the type definition of the the lift operation in Haskell:'
  prefs: []
  type: TYPE_NORMAL
- en: '`liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c`'
  prefs: []
  type: TYPE_NORMAL
- en: See the following terminal console for an example of using the lift operation
    (`liftA2`) to transform the the `replicate` function into a wrapped type. We're
    using the *applicative style* since we are lifting with an arbitrary number of
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d6315e9-fa8f-429f-8c45-f6eeec9c1312.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we do not throw an exception (or panic); instead, we move our application
    flow from the `Success` path to the `Failure` path. Practically, what this means
    is that we no longer need to check for errors after executing each command that
    could possibly fail in our code. Using the monad pattern, we are able to redirect
    program flow to the `Failure` path and handle all of our errors for this execution
    chain at the tail end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand why and how we got two inputs and two outputs, let’s
    look at what’s going on under our chain of blue boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/831dcc03-20ab-4f75-ba23-76abb2a8d543.png)'
  prefs: []
  type: TYPE_IMG
- en: See the open box with the arrows coming in and going out? Those are impure arrows.
  prefs: []
  type: TYPE_NORMAL
- en: Remember our discussion about the action of lowering elements into the gutter
    of mutation in [Chapter 9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics,*
    in the section about functors?
  prefs: []
  type: TYPE_NORMAL
- en: This is where our monad allows us to open our box outside the pure world of
    FP. Our monad is a functor, and here, we're using the functor operation of lifting.
  prefs: []
  type: TYPE_NORMAL
- en: For details about lifting, see the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The in arrow represents interactions with the external world. Things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepting input from external APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The out arrow represents interactions with the external world. Things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending output to external APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, in pure functional programming, if a program receives a certain input
    value, then it will always return the same output. However, when a program writes
    to a log file, how could it possibly have the same timestamp each time? Monads
    allow pure FP programs to remain pure and still interact with an impure world.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae6b607b-efb1-48d0-89d7-1110c55d35ef.png)'
  prefs: []
  type: TYPE_IMG
- en: This is where the mapping/data transformation function is applied to the data.
  prefs: []
  type: TYPE_NORMAL
- en: In our Mother Teresa life monad example, this (in the box) is where the positive
    interactions, perhaps with her loving mother, occurred, which helped to point
    her in a positive direction. What other interactions might have occurred to transform
    her life?
  prefs: []
  type: TYPE_NORMAL
- en: How can any useful application not manage state? How can an FP application manage
    state and remain pure? Monads. (See the state monad in the upcoming table.)
  prefs: []
  type: TYPE_NORMAL
- en: Why use Monads to manage state? Monads allow the manipulation of state in an
    elegant, type-safe, constrained, deferred, and controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elegant? What’s elegant about a Monad? Elegance is in the eye of the beholder.
    Elegance gets out of the way. It is simple, obvious, straightforward, and allows
    us to very little intellectual effort to immediately understand our code''s purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's a Monad. It's clutter-free and it's easy to see what the workflow does.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred? What are we talking about? Why not just bake in all the control flow
    logic up front? We know what should happen in all our use cases. Why not write
    all our if/then/else logic and for loops and bake them all into a single executable?
  prefs: []
  type: TYPE_NORMAL
- en: With Monads, we attempt to write our applications using as many pure, side effect
    free functions as possible. This style of programming mostly defers the decisions
    about how and when to mutate states until the moment they are required. That’s
    what happens when we open the box.
  prefs: []
  type: TYPE_NORMAL
- en: Constrained? What’s constrained? Well, that’s an overloaded term. From a framework
    perspective, we are constraining/quarantining our side effect causing and real-world
    interfacing code to this little, purposeful box. Its job is to perform the specific
    data mapping transformation functions that have been provided to it. If any errors
    occur, the framework will capture them and package the errors for us, and will
    ensure that they quickly travel down the `Failure` path until they get spit out
    the end of the execution pipe, where all errors for this execution chain are handled.
    From a data perspective, we use our type system to constrain the input to only
    valid data types. (If we have a division operation, we can constrain our input
    type to be `PositiveNumbers` to ensure that a divide by zero exception will never
    occur.) From a type class perspective, our operations are constrained by the laws
    of Monads.
  prefs: []
  type: TYPE_NORMAL
- en: 'What operations? What laws? The operations are the sequences of tasks that
    we chain together to perform various operations on our data. If we start with
    a list of cars, we might want to transform our list by applying the following
    transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And finally, what do we mean by controlled? This is where the Monad shines.
    The Monad provides the structure for chaining the transformation operations. It
    provides the `Success` and `Failure` paths. Now, rather than littering our code
    with `if err != nil` error checking blocks, we can put all of our error handling
    logic at the end of all of the steps we need to perform for our particular use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more time: What is a Monad? A Monad is a design pattern that provides a
    way of chaining operations together. The `bind` function is what links the operations
    together in a chain; it takes the output from one step and feeds it into the next
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: We can write the calls that directly use the `bind` operator, or we can use
    a sugar syntax, in a language like Haskell, which makes the compiler insert those
    function calls for use. But either way, each step is separated by a call to the `bind`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Since Haskell is a fully baked pure functional programming language, we'll often
    refer to its FP in order to think about how we can best incorporate that method
    of thinking/design into our Go solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Haskell, there are many kinds of monads. What makes each monad unique and
    especially useful is what it does in addition to the `bind` operation. We can
    use the following table of monads found in Haskell as a starting point for building
    a package of monads in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Monad** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Either** | The `Either` type is similar to the `Maybe` type, with one key
    difference--it can carry attached data of both `Success` and `Failure`. The `Left`
    return value to indicates failure, and `Right` indicates success. Here''s a useful
    pun: use *Either* to get the *Right* answer. |'
  prefs: []
  type: TYPE_TB
- en: '| **Error** | Allows us to define exactly how exception handling works for
    our application. For example, we can choose to ignore a specific exception if
    a similar one has been handled in the past 60 seconds. |'
  prefs: []
  type: TYPE_TB
- en: '| **Eval** | Used for modularizing parallel code by separating the algorithm
    from the parallelism, allowing us to change the way we parallelize our code by
    replacing the `Strategy` function. `Eval` and the swappable `Strategies` leverage
    lazy evaluation to express parallelism. |'
  prefs: []
  type: TYPE_TB
- en: '| **Failure** | Aborts the chain of execution steps automatically without requiring
    an `if err != nil` conditional error check after every function call. |'
  prefs: []
  type: TYPE_TB
- en: '| **Free** | Allows us to construct a monad from an arbitrary type. The free
    monad allows us to abstractly specify control flow between pure functions and
    separately define an implementation. We use monads to glue together pure functions
    with special purpose control-flow, such as fail fast error handling (`Maybe/Either`)
    or asynchronous computation. |'
  prefs: []
  type: TYPE_TB
- en: '| **Identity** | The `Identity` monad is a monad that does not embody any computational
    strategy. It simply applies the bound function to its input without any modification.
    Computationally, there is no reason to use the `Identity` monad instead of the
    much simpler act of applying functions to their arguments. The purpose of the
    `Identity` monad is its fundamental role in the theory of monad transformers.
    Any Monad transformer applied to the `Identity` monad yields a non-transformer
    version of that Monad. The `Identity` monad is like the number zero in addition.
    You cannot increase another number with zero, but zero comes in handy when you
    need to write a `Reduce` function. |'
  prefs: []
  type: TYPE_TB
- en: '| **If** | Provides simple control flow to evaluate the results of a clause
    if the logic condition is true, or else it will evaluate the false block (if one
    is provided). |'
  prefs: []
  type: TYPE_TB
- en: '| **IO** | Separates I/O from the rest of the (pure) language. In Haskell,
    it''s the return statement that takes the impure I/O and puts it into the `IO`
    Monad. It allows access to impure I/O sources, such as memory, global variables,
    network, native operating system calls, standard input, and so on. The following
    example Haskell code illustrates the IO monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lazy** | It''s the same as the `StateThread` (ST) monad, except that this
    monad delays the evaluation of state operations until a value depending on them
    is required. |'
  prefs: []
  type: TYPE_TB
- en: '| **List** | We can make each step return a list of results. Our bind function
    can iterate over the list, feeding each one into the next step. This eliminates
    the need to write looping constructs to iterate over lists of elements. Write
    it once and reuse it. |'
  prefs: []
  type: TYPE_TB
- en: '| **Maybe** | Used to deal with nil values, as it deals with computations that
    might not return results. Instead of returning nil (or throwing an exception/panic),
    monadic operations return a `Just` value or `Nothing`. Errors are propagated down
    the monad structure until they reach the exit point at which all errors are handled.Here’s
    how it’s defined in Haskell:`data Maybe a = Nothing &#124; Just a` |'
  prefs: []
  type: TYPE_TB
- en: '| **Option** | Used as the return type for data that might otherwise return
    a nil/null value. If the data is invalid, `None` is returned inside the `Option`
    monad, or else `Some` is returned with the valid data inside of it. The monadic
    functions will then chain fail states, so if a function requires the data is valid
    but receives an `Option` with `None` in it, it will simply return `Option None`
    to the `Next` function. This pattern is similar to returning `Null` in an imperative
    language and it solves the [Billion Dollar Mistake](https://en.wikipedia.org/wiki/Null_pointer).
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Par** | Used for modularizing parallel code by requiring the programmer
    to provide more details about the data dependencies. Par provides more control
    and does not rely on lazy evaluation to manage parallel tasks. |'
  prefs: []
  type: TYPE_TB
- en: '| **Parser** | Used to create a parser. For example, our grammar might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use our Parser monad to perform math operations such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pause** | Used when computations need to be interrupted and resumed. Could
    provide a step function, which runs the computation until it calls the yield function
    where the computation is paused, returning to the caller enough information to
    resume the computation later. For an example of about a dozen possible implementations,
    see [stackoverflow.com/questions/10236953/the-pause-monad](https://stackoverflow.com/questions/10236953/the-pause-monad)[.](https://stackoverflow.com/questions/10236953/the-pause-monad)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Reader** | Provides access to the global state. During initialization,
    an application can read configuration into a single context that can be passed
    along to subsequent steps. Also known as **Environment**. |'
  prefs: []
  type: TYPE_TB
- en: '| **State** | Provides access to state values. A run function that performs
    some computation will update the state and return the final state. For example,
    in an online first person shooter video game, the player needs to know the state
    of the player during every phase of the game: their health, amount of ammo, types
    of weapons on hand, location, or an overlay a map of the surrounding area. State
    is not global, but rather, a new state created in each step of the game. Since
    the state is not actually performing destructive updates, reverting to an older
    version or performing undo operations is easier. |'
  prefs: []
  type: TYPE_TB
- en: '| **ST** | Allows us to safely work with a mutable states. For example, we
    can thaw an immutable/frozen array and modify it in place and freeze a new immutable
    array. ST also allows us to create data structures that we can then modify, as
    we can do in imperative languages. Also known as a **State Thread monad**. |'
  prefs: []
  type: TYPE_TB
- en: '| **STM** | The **Software Transactional Memory** (**STM**) monad helps us
    with the problem of synchronizing multiple tasks by preventing us from accidentally
    performing non-transactional I/O operations that may cause deadlocks. In order
    to perform concurrent programming in imperative programming, we use threads that
    must share data. We must be careful that the different threads don''t improperly
    update the shared data. We often lock data blocks using a a technique called a
    **semaphore lock**. With STM, we don''t need to worry about semaphores since our
    code contains no locks. Note that in Go, the language constructs we use to perform
    concurrent programming include Goroutines, channels, and `sync.WaitGroup`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Writer** | Used to signal some side effect. Often used for logging or debug
    printing. |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to learning from Haskell''s implementation of Monads, other features
    we can learn from include:'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax based on layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching on data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounded and Parametric polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out more about Haskell at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Haskell_(programming_language)](https://en.wikipedia.org/wiki/Haskell_(programming_language))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.haskell.org/](https://www.haskell.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://learnyouahaskell.com/](http://learnyouahaskell.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.huffingtonpost.com/aaroncontorer/haskell-the-language-most_b_4242119.html](https://www.huffingtonpost.com/aaroncontorer/haskell-the-language-most_b_4242119.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monadic functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Monads are implemented as a type class with two methods, `return` and bind
    (`>>=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that `m` refers to a type constructor, such as `Either` or `Maybe,` that
    implements the `Monad` type class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll include a few more monadic functions from the Standard Library in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **fail** | The fail function supports a monad''s implementation of failure.
    We get the `fail` function from the `Monad` type class, and it enables a failed
    pattern matching to result in a failure in the context of the current monad instead
    of a program crash. For example, the `fail` function is called when pattern matching
    fails in a do expression. `fail :: Monad m => String -> m a` |'
  prefs: []
  type: TYPE_TB
- en: '| **fmap** | `fmap` comes from the Functor type class. `fmap` applies a function
    over ordinary values `a -> b`, and lifts them to become a function over containers
    `f a -> f b`, where `f` is the container type:`fmap :: Functor f => (a -> b) ->
    f a -> f b` |'
  prefs: []
  type: TYPE_TB
- en: '| **mplus****mzero** |'
  prefs: []
  type: TYPE_TB
- en: '`MonadPlus` is a type class which extends a `Monad` class and provides `mzero`
    and `mplus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class Monad m => MonadPlus m where`'
  prefs: []
  type: TYPE_NORMAL
- en: '`mzero :: m a`'
  prefs: []
  type: TYPE_NORMAL
- en: '`mplus :: m a -> m a -> m a``mplus` combines two results into one.`mzero` represents
    an empty result. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **return** | Return is our lift function. Don''t confuse `return` with what
    return means in Go. Think of it like this: **Return** a pure value **a** (of type
    **A**) into a monad **m a** (of type **Monad A**). The Lexical Workflow Solution
    calls this function `Get`. |'
  prefs: []
  type: TYPE_TB
- en: '| **(>>=)** | (`>>=`) runs an action and then passes its result to a function
    that also returns an action. Both actions are run and the final result is the
    result of the second action. We can think of (`>>=`) as our chaining function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to your Haskell ghci console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '(`>>=`) is also known as **bind**. The Lexical Workflow Solution calls this
    function `Get`.Here''s its type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **(>>)** | (`>>`)  performs two actions in sequence. The result of the first
    action is discard. What we keep is the result of the second operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '(`>>`) is defined in terms of the `bind` operation that discarded its argument.
    The following says that (`>>`) has a left and right argument that are monadic
    with types `m a` and `m b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Basic monadic functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following table consists of some of the more frequently used Monads (for
    composition, looping, and mapping):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **forM** | `forM` acts like an iterator that maps an action over a list and
    returns the transformed list. `forM` serves the same purpose as `mapM` and exists
    for readability. The rule of thumb is that if there are multiple lines of code
    in the for loop, then use `forM`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **forever** |'
  prefs: []
  type: TYPE_TB
- en: '`forever` is a combinator used to repeat an action `forever`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **mapM** | The `map` operation performs mutations when it transforms elements
    in a list, right? But how can that be? Pure functions cannot mutate variables.
    We''re able to execute actions indirectly by using `mapM`. `mapM` can change the
    element''s values in the list because it runs in the IO monad, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **sequence** | Used to evaluate each action in the sequence from left to
    right and collect the results, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **void** | Used to discard the return value of an IO action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **(=<<)** | This is the same as `>>=` but with the arguments interchanged,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **(>=>)** | Used to compose monads via left-to-right Kleisli composition,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **(<=<)** | This is the same as `>=>` but with the arguments interchanged
    (using right-to-left Kleisli composition), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `functionName_` functions not listed here are used for side-effects.
    For example, when we want to evaluate such a list for effects, we use `sequence_`
    and `mapM_`, which discard the results.
  prefs: []
  type: TYPE_NORMAL
- en: Monadic list functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The thing to remember with lists is that they model non-determinism. A list
    of values `a` represents a number of different possibilities for the value of
    `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **filterM** | Used in place of `filter` inside a monad, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **foldM** | Used in place of foldl where monadic computations built from
    a list are bound left-to-right, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **join** | Used to flatten the nesting of groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **msum** | A list based concat function that is best described by the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **replicateM** | Used to perform an action `n` times and gather the results,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **zipWithM** | Used to merge two lists together, applying a special rule
    in the process. `zipWithM` is a monadic version of the `zipWith` function on lists.
    It is useful when only the side-effects of the monadic computation matter, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Monadic workflow implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by reading our car data in from a file with base64 encoded text
    strings that represent cars, found in `cars.base64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our car processing monad will take that base64 text, timestamp it, and output
    JSON, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let’s start by looking at `main.go`. We import two project packages, `workflow`
    and `utils`. We also import `bufio` and `os` from the Go Standard Library for
    processing our `base64` text file.
  prefs: []
  type: TYPE_NORMAL
- en: We put our project packages at the top of our list of imported packages. We
    import *workflow* and *utils*. In this book, we use the logging and configuration
    features from the utils package a lot. In order to be lazy, we'll just remember
    that we can use the `Config` object anywhere we want and refer to a value from
    our `config.toml` file. Similarly, to use our info logger, we can simply type
    `Info.Println`.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, it is considered best practice to write tests first. That's called **test
    driven development**. We discussed that in the first chapter. You should code
    your applications that way. However, after [Chapter 2](../Text/Ch02.xhtml), M*anipulating
    Collections,* example code is more frequently found in the `main.go` file (with
    no test files). I did that because I am a lazy programmer and don't like to type
    more than is absolutely necessary, and I think it conveys the lesson quicker/better.
    I used similar reasoning when I chose to eliminate the package reference requirement
    when calling Config and the Info, Debug, and Error loggers. Should you use a global
    logger and config object at your job? Probably not. Why? Because they are dependencies
    that should be explicitly passed into each function that uses them. [Chapter 7](../Text/Ch07.xhtml)*,
    Functional Parameters*, illustrates how this can can accomplished. For more information,
    see [http://peter.bourgon.org/go-best-practices-2016/](http://peter.bourgon.org/go-best-practices-2016/).
  prefs: []
  type: TYPE_NORMAL
- en: In the following `main.go` we import packages and run our initializer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `init` function will be executed before our `main` function. We call `GetOptions`
    to read the values in our `config.toml` file into a global `Config` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Yes. It’s a global variable. And there’re more. For example, Debug, Info, and
    Error are our global loggers.
  prefs: []
  type: TYPE_NORMAL
- en: Are you wondering why I would dare put global variables in an example application
    using a pure FP concept like Monads?
  prefs: []
  type: TYPE_NORMAL
- en: This book is about improving the way you approach application development. Go
    is a multi paradigm language and allows us to mix pure FP with our existing code.
    The `01_car_steps` application consists of an imperative framework with a global
    logger object, as well as some pure FP code to handle workflow.
  prefs: []
  type: TYPE_NORMAL
- en: This is a small application, so having one global logger is convenient. If this
    were a larger project, it would be better to have one logger for each instance
    of your service.
  prefs: []
  type: TYPE_NORMAL
- en: While this book does cover theory as well as some of the history of pure FP,
    this book’s main goal is to be practical. I hope you will be able to use some
    of the code in this book in your own projects (or at least some of the concepts)
    to build better applications yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Debug, Info, and Error are each assigned a `log.New` object ([https://golang.org/pkg/log/#New](https://golang.org/pkg/log/#New))
    that returns a `*Logger` . If you want to use it concurrently from various goroutines,
    you should pass those logger objects around as pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can adjust our application settings in the `config.toml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The last setting can tell our application which translation file to use. Later
    in this chapter, we'll see how we can use `go-i18n` to use message IDs to reference
    the appropriate message, and how to change the translation text based on the appropriate
    language/locale. We won't add the internationalization (I18N) of error messages
    in this first example to keep things simple, and so that we can focus on understanding
    how monads work.
  prefs: []
  type: TYPE_NORMAL
- en: The `log_ settings` can affect what gets logged as our application runs. We’ll
    see a few examples of how to use them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Our `main` function initializes a `carCntr` to count how many cars we’ve processed.
    Next, we open our data file using the `Config.DataFilepath` value set in our config
    file.
  prefs: []
  type: TYPE_NORMAL
- en: An idiom is a manner of speaking that is natural to the native speakers of a
    language. In English, idioms often have figurative meanings, utilizing pictures
    to help us visualize that meaning. For example, *Hit the nail on the head*, *A
    hot potato*, *It takes two to tango*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The following `if` statement that opens a file in idomatic style Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Config.DataFilepath` value, `./data/cars.base64`, comes from our `config.toml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look closely at that line of code to see what we can learn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb80947b-9568-433a-a564-234239c7d76d.png)'
  prefs: []
  type: TYPE_IMG
- en: We start with the if statement, like in a typical `if...then` else statement,
    but rather than immediately checking for a Boolean (true/false), after the `if`,
    we execute a statement that opens our data file. That statement assigns err a
    value. If `err == nil`, then we know the file opened successfully. This particular
    idiom is used about 100 times in the Go standard library. The coding styles we
    find in the Go Standard Library should be emulated, especially ones that appear
    that many times.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this book is not to remove idiomatic Go from your toolbox, but rather
    to add simple yet powerful FP tools to it. *If your only hammer is imperative
    in programming, then every iterative nail looks like a for loop*. That's just
    not the case. Some iterative tasks are better solved with maps, filters, reductions,
    functors, monoids, and/or monads.
  prefs: []
  type: TYPE_NORMAL
- en: In the following `main` function we initialize our car counter and open our
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After opening a file, it’s best practice to immediately defer the closing of
    the file. (The Go standard library uses defer over 100 times.) This way, we won’t
    forget to close our file, which is a frequent mistake that causes memory leaks
    and can be difficult to troubleshoot. defer is another delightful tool Go gives
    us to help us write better code.
  prefs: []
  type: TYPE_NORMAL
- en: We execute bufio's `NewScanner` command to open the file and load its contents
    into the scanner variable in order to read the file line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, we chose to read cars from a file, but we could read our data
    from a stream of input coming from another I/O source such as:'
  prefs: []
  type: TYPE_NORMAL
- en: ActiveMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NATS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kafka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kestrel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby-NATS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ZeroMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s important is that the interface to the source you read from needs to
    implement the `Reader` interface. If we look at the `NewScanner` implementation
    in the Go standard library, we can see it takes an `io.Reader:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `io.Reader` is an interface with one method, `Read`. So, in other words,
    the API that we get our data from needs to have a `Read` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another pattern that we should learn to emulate from the Go Standard
    Library: *Program to the interface*. Here, the interface of interest is an object
    with a `Read` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the scanner''s `Scan` method in a for loop. We will continue to
    iterate until there are no more lines to be read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’re in the loop and have printed out the first line read (the first
    car):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call our monad to execute the workflow required to process our input
    line (our first car):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After we process our input, we check for errors and output the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The remainder of `main` prints a few dashes, checks for scanner errors and closes
    another if else block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens when we run this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We import `utils` so that we can log errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our `ProcessCar` function clearly expresses our business intent. It accepts
    a base64 encoded string and, in idiomatic Go style, returns an error and result
    (`carJson`). If all goes well, our error will be nil and `carJson` will be populated.
  prefs: []
  type: TYPE_NORMAL
- en: The workflow embodies our business logic. The rest of our code is framework.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `ProcessCar` is not cluttered with error checking code, but rather,
    each step in the workflow is self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram illustrates each step in our workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/465e5ef6-1e15-4644-ba5c-e6a0183b6546.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We initialize our step variable by calling the `Get` function with our input
    `lineBase64`. This starts our workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look in `monad.go` for the `Get` function''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/workflow/monad.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That’s the empty interface! Look out for pirates!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d393554d-c2db-4385-9802-566f98cf005f.png)'
  prefs: []
  type: TYPE_IMG
- en: This pirate is right. In our example, we do use reflection in our toolbox of
    functions. For example, in order to get the filename to pass to the `ioutil.Readfile`
    function, we must downcast our filename argument from the empty `interace{}` data
    to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a snippet from `src/workflow/toolbox.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If Go supported generics, we would not need to do this. We''d just need to
    modify our code slightly to accept generic data types. So, the above `ReadFile`
    function would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That’s about 30% less code, and it will run faster because typecasting is a
    relatively expensive operation. In this case, if Go supported generics, the compiler
    would create a string shaped hole in the compiled `ReadFile` function, into which
    we could pass our string.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, if Go supported generics, we’d have about 30% less code to write
    and our code would be type-safe and very fast.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to see why so many programmers are making such a big deal about this
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: If the runtime cost of reflection is too much to bear, then we can leverage
    meta-programming tools like `clipperhouse/gen` to generate the repetitive, boilerplate
    code necessary to handle all the data types that reflection would otherwise handle
    for us. (If we went down this type-safe route, and we compared the code necessary
    to support type-safe, reflection free code to what we'd need to write if Go supported
    generics, we’d likely find that we’d have around 80% less code to maintain than
    if we had generics.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start thinking about jumping onto the Haskell or Java bandwagon
    for generics, consider what is good about Go: simplicity, performance, concurrency
    support, and so on. It''s easy enough to use tools to generate type-safe code,
    and when Go does one day (fingers crossed) support generics, we should be able
    to fairly easily remove our generated boilerplate code and simply use generics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our `Monad` type. It is a function that accepts an `error` and returns
    transformed `Data` and an `error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: What can we guess about the way a `Monad` works? Maybe if it gets an error,
    it will fail fast and pass the error along, or otherwise, it will continue processing
    and pass the data along with nil for the error?
  prefs: []
  type: TYPE_NORMAL
- en: Sounds a bit like `Continuation Passing Style` (`CPS`) programming, but how
    does it work? Remember in [Chapter 4](../Text/Ch04.xhtml)*, SOLID Design in Go,* when
    we learned that Monads are purple?
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw a composition of functions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dc0ccef-5432-4615-930c-3a708bb716e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We learned that in order to be a Monad, we need our functions to accept **a**
    and return a like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d9ffdfa-2d10-4599-ad86-b591d650307a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That would give us associativity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd30e598-7cd2-4e2e-91dc-5b594d12b128.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ll call the `Get` method that lifts our data into the world of pure FP.
    It accepts data and returns a `Monad`. Note that our `Data`, `d`, is curried:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where we put our data in the first blue box in our monad chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8fbd316-efd6-426c-a369-ab5d4cc4c4d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After initializing our step, we call our first data transformation function,
    `Base64ToBytes` (in `workflow/process_car_steps.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s jump back to `monad.go` and look at `Next` function''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `Next` function accepts a monad and a function that returns a monad and
    itself returns a monad.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. This is how we get purple Monads that take a and return a.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a10fa0f-8f49-48c8-a416-6f4ffd7a96ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line in our `Next` function looks familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s because that line is exactly the same as the first line in our Get method.
    In the line that follows, we call our monad, passing our error as its parameter,
    and get transformed data, `newData`, as well as the `newError` value in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It is here that our stack fills up with `workflow.Next` monad functions. Our
    call stack will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where we wire up our steps and jump back to `Get` to grab our data
    (in the return statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If we were electricians, we’d turn off the power, wire up the lights in the
    house, and turn the power back on to see if our wiring was correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as execution returns from the `return d, e` statement, we hit the `if
    newError != nil`  error check block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If an error occurs, then we return nil for the data and the `newError`; all
    subsequent error checks will pass the same `newError` along until our execution
    spits out the error at the end of the monad chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an error does not occur, the last return is executed: `return f(newData)(newError)`. What
    is this? Ever seen a function call like this before?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This language construct is known as the Y-Combinator. Before diving into the
    details of the Y-Combinator implementation in Go, let's think about what it is
    and its origin, the Lambda Calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda calculus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Lambda calculus defines what a function is from a computational perspective.
    It''s comprised of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables (x, y, z, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of creating functions (with the "\" notation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to apply functions (substitution)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else is defined in terms of encoding those three things.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 7](../Text/Ch07.xhtml), Fu*nctional Parameters,* we defined a function
    where **f** is the function name, **x** is the input value, and the result is
    the whole expression **f(x)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0672ab83-0174-4330-8dc7-c871712ae272.png)'
  prefs: []
  type: TYPE_IMG
- en: If *f(x) = x + 2*, then we know that every time we input the value three, five
    will always be the output value. So, functions are like black boxes where we put
    values in and get different values out. There’s neither internal hidden data nor
    side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: However, in lambda calculus, we use anonymous, unnamed functions. How would
    we express *f(x) = x + 2* in lambda calculus?
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we build functions in lambda calculus is with expressions, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5940174-48d8-43a2-8f35-396358e65d76.png)'
  prefs: []
  type: TYPE_IMG
- en: The period after `\x` is just a notation that separates our function signature
    (its arguments, x) from its body (`x+2` in our example ).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `3` is the input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The result is `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In math class, we’re used to writing function applications like this: f(3).
    In lambda calculus, we say (f 3).'
  prefs: []
  type: TYPE_NORMAL
- en: The function application associates to the left, so `(f a b c) = (((f a) b)
    c)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function is applied, we are simply substituting our parameter for x
    in our body, where the computation, such as `x+2`, is performed. Let’s try another
    one that takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns one parameter function that also returns one parameter function,
    which then returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21b640c5-cff5-49e1-a198-4ca5c72c000b.png)'
  prefs: []
  type: TYPE_IMG
- en: What we just did was called **currying**, where functions of multiple arguments
    are really just higher order functions that take one argument and return function(s).
  prefs: []
  type: TYPE_NORMAL
- en: The numbers we used earlier (**2**, **3**, **5**) and the operators (+, /) are
    not part of lambda calculus. We just used them to encode computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda calculus does not have data types, but we can represent data types by
    using functions. Let''s create the Boolean data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Boolean functions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `true := \x.\y.x` | The `true` function is a function of two parameters (x
    and y) and returns the first parameter (x). |'
  prefs: []
  type: TYPE_TB
- en: '| `false := \x.\y.y​` | The `false` function is a function of two parameters
    (x and y) and returns the second parameter (y). |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s define the logical negation function, not:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Boolean expressions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| (\b. b false true ) true | lambda b b applied to false and true returns true
    |'
  prefs: []
  type: TYPE_TB
- en: '| (\b. b true false ) false | lambda b b applied to true and false returns
    false |'
  prefs: []
  type: TYPE_TB
- en: 'We''ve seen that the Fibonacci function is recursive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9e29fdd-7ed4-48ff-b45e-d8692638366b.png)'
  prefs: []
  type: TYPE_IMG
- en: We defined the `fib` function in terms of itself. That makes the fib function
    recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by defining a for loop using Lambda Calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe we could form an expression a that would call itself, as in, apply the
    function to itself. That would that look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2db74003-ff22-4e84-ab95-9b107250c28a.png)'
  prefs: []
  type: TYPE_IMG
- en: '`\x.x x` takes input `x` and applies `x` to itself. Our function takes `x`
    as its input and makes two copies of `x`. That''s called self application.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is about defining something in terms of itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what it looks like when we perform recursion twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b574874e-0187-4506-ab08-9dd58519e9cb.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see how this process can continue indefinitely. This is how we encode
    for loop behavior using Lambda calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to encode a for loop, how can we encode recursion?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a general recursive function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: That reads, recursive `f` equals `f` applied to recursive `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this function, it will repeatedly apply `f` and we''ll get:  `f(f(f(...)))`. The
    following is the Y-Combinator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It's not recursive, but it encodes recursion. This is how we can implement recursion
    in a language that does not support recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Ready to see how to implement the Y-Combinator in Go?
  prefs: []
  type: TYPE_NORMAL
- en: But wait, there's more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s stop to think about where the Y-Combinator could be used in bioengineering.
    The recursive genome function could be modeled using the Y-Combinator. What proof
    is there that the Lambda Calculus is practical? Look in the mirror:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4955fe3-7619-4e03-96c4-0aa419fc089e.png)'
  prefs: []
  type: TYPE_IMG
- en: For more information on the *Recursive Genome Function - the Pellionisz Principle*,
    see [http://www.junkdna.com/recursivegenomefunction/](http://www.junkdna.com/recursivegenomefunction/).
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that your genes can be sequenced and anomalies detected to indicate
    your predisposition to certain diseases, like Parkinson's Disease? The sooner
    you know, the sooner preventative measures can be taken.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://en.wikipedia.org/wiki/Disease_gene_identification](https://en.wikipedia.org/wiki/Disease_gene_identification).
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda Calculus (which provides recursion) and Monads (which control the
    composition of operations) are deeply woven into the fabric of life. What happens
    when we sleep? Have you ever worked long hours to solve a problem without success,
    only to wake the next morning with the solution in mind? Did you know that we
    are about 25% more susceptible to illness when we are sleep deprived? What do
    you think causes DNA mutations that lead to cancerous cell growth? What is it
    about restorative time (sleep) that allows our body to compose properly?
  prefs: []
  type: TYPE_NORMAL
- en: When we follow basic rules, we thrive.
  prefs: []
  type: TYPE_NORMAL
- en: '"Early to bed, early to wise makes a man healthy wealthy and wise."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Benjamin Franklin'
  prefs: []
  type: TYPE_NORMAL
- en: Y-Combinator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Y-combinator is one of most beautiful ideas in all of programming. This
    code demonstrates how amazingly powerful the simple ideas of functional programming
    are. The Y-Combinator is a higher order function. It accepts a single argument,
    which is a function that isn't recursive. It returns a copy of the function which
    is recursive. It requires that our language supports first class functions and
    that functions be named or anonymous. Go supports all of that.
  prefs: []
  type: TYPE_NORMAL
- en: The Y in Y-Combinator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ever wonder the Y in the Y-Combinator comes from?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8937b02c-0771-4fd0-9e6c-5ae1d63666f0.png)'
  prefs: []
  type: TYPE_IMG
- en: See how **A** and **B** and **C** connect the dots to form the top part of the
    "y"?
  prefs: []
  type: TYPE_NORMAL
- en: How the Y-Combinator works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The diagram below illustrates how the Y-Combinator works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbc5c483-225c-4d80-96a2-1925fcaa77c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the steps to wire up the Y-Combinator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f(newData)` calls `Base64ToByes` with the `base64` encoded text. `dString`
    is downcast into a string.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `return func(e error) (Data, error) {` statement is executed and returns
    execution back to the return statement in the `Next` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At that time, `f(newData)`, which itself is a function, has its `newError` parameter
    populated and can now be executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Runtime execution returns to the `return func(e error) (Data, error)` line in
    `Base64ToBytes` and enters its code block, which is the return statement that
    decodes the `base64` string into a regular string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execution again returns to `Next`, in the last return line. This is where recursion
    happens. It calls itself, passing the error value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On *line 14* we call our next monad. This is where continuation passing happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We wrote a recursive function of one bound variable using only functions of
    one variable and no assignments. The Y-combinator performs the magic of associating
    the anonymous inner function (`func(e error) (Data, error) {`) with the parameter
    name (`newError`) of the function (`f`) that was originally passed to `Next`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how one of our reusable functions in `toolbox.go` works, we
    don’t need to go through the rest of them. They all work the same way. We can
    simply move on to the `Next` step through each line of our workflow until we come
    out the other end. If an error is encountered in any of our reusable functions,
    we simply kick the can down the road.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it easy and simple to handle errors. Errors only need to be handled
    at the very end of the process, in one place. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: The Lexical Workflow solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''s our entire `ProcessCar` workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How's that for clarity? Each step one after the next and error handling at the
    very end.
  prefs: []
  type: TYPE_NORMAL
- en: This Go idiomatic Monadic workflow solution needs a label, and because I thought
    of it first, its name is The Lexical Workflow. It's how we can do Monadic composition
    of impure components in Go. Lex means **law**, and since it controls and rules
    over our workflow, the name fits. (The fact that it has my name in it must be
    purely coincidental!)
  prefs: []
  type: TYPE_NORMAL
- en: Is our ProcessCar method idomatic Go code?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start with what's not idiomatic.
  prefs: []
  type: TYPE_NORMAL
- en: The non idiomatic parts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no if `err != nil` error checks until the end of our processing pipeline. That’s
    by design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using a monadic pipeline are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Enables us to clearly express business logic without the clutter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminates if `err != nil` error checks after every operative line of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides structure for pipeline processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orders all of our `Next` steps in our workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a framework for plugging in reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idiomatic parts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have a typical if `err != nil` error check at the end of our pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is where we should perform error checking, so having an error check is
    natural.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could choose to implement an `Either` monad to wrap our response in a struct
    that might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We could include a sum or union type which would return only either `Success()`
    or `Failure()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we would have to create another interface to convert our `Either` to a
    `Success` or a `Failure`. It might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: But we'll no longer pursue these monadic error handling techniques. The Go idiomatic
    error check works great for our purposes (to handle errors for this workflow)
    and it does so without the added complexities of additional layers of interfaces
    or other external dependencies (that we'll discuss at the end of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: An alternative workflow option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we have a text file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will read three sets of two characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can improve our code by defining a struct with an error field and an `io.Reader`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You might remember from [Chapter 3](../Text/Ch03.xhtml), *Using High-Order
    Functions,* that the `io.Reader` interface only requires one method, read. So,
    we implement that and add the `logInfo` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our code to print three sets of two bytes looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Much better! But that is more like a utility function than a workflow solution.
    It simplifies our code and reduces the number of ` if err != nil`  blocks.
  prefs: []
  type: TYPE_NORMAL
- en: However, for every step in our workflow, if possible, we’d need to create a
    separate utility function, and each would have its own `if err != nil`  blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Compare that to our monad workflow pipeline that only requires one  `if err
    != nil` block.
  prefs: []
  type: TYPE_NORMAL
- en: Business use case scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The monad workflow provides a solution for business use case scenarios. If we
    work with a team that implements application features or manages tasks using use
    case scenarios, the steps in the monad workflow pipeline would likely correspond
    directly to our task’s requirements. Using this workflow could simplify testing,
    as well as development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that requires five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7829288-5fff-4310-a0dd-62b37dbd0098.png)'
  prefs: []
  type: TYPE_IMG
- en: Each requirement maps directly to a workflow step (as well as a test).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make it through the last step with no errors, then we downcast our data
    into a string. It will contain JSON and look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Y-Combinator re-examined
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at another Y-Combinator example in Go to improve our grasp of the
    topic. Remember the `Fibonacci` function in [Chapter 1](../Text/Ch01.xhtml), *Pure
    Functional Programming in Go*? It looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If it passes a `0`, `1`, or `2`, it simply returns a value (`0` or `1`). Otherwise,
    it will call itself (recursion) with two functions that look like this--`fib(x-2)
    + fib(x-1)`. Since values are continually being decremented by two or one, processing
    will eventually complete, at which time the accumulated values will be summed
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates this recursive processing. The orange and
    red boxes highlight functions that only need to be executed once. Referential
    integrity allows us to store the value of those functions. Subsequent execution
    only needs to look up the stored value, rather than re-execute the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/695320f1-fb9f-49d4-b948-d1658e2aa050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We define three function types in `main.go`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Func`: A simple function that takes an int and returns an `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FuncFunc`: A function that takes a function of type `Func` and returns a function
    of type `Func`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecursiveFunc`: A function that takes a `RecursiveFunc` function and returns
    a function of type `Func`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what happens when we initialize the `yCombo` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `yCombinator` function is called and we initialize our `g` variable with
    a recursive lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the wiring that occurs when we initialize the
    `yCombo` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fd202ce-337f-4a96-8b36-2ef87d8c4589.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compare that to the minimal wiring required for the basic recursive variable
    initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2029b1cb-2c02-466a-90ef-219a56e102a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The execution path looks to be nearly the opposite when we evaluate our Lambda
    expressions on *line 13* and *line 14*. The slightly wider red lines are the two
    steps the `yCombo` function requires to evaluate the expression. The thinner black
    lines are the eight (plus one) steps that it takes to evaluate the regular recursive
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01cf266f-2eb8-4911-aeb5-978c75e91836.png)'
  prefs: []
  type: TYPE_IMG
- en: These patterns of execution indicate major differences. The `yCombinator` (lambda
    expression) does hold on to state and only references the argument (`x`). In contrast,
    the regular recursive function holds on to the state of `x` after arriving at
    the `Recurse` function (*step 2*). When `Recurse` gets to *step 6* (*line 43*),
    the value for `x` is supplied from *line 42* (left there from *step 2*).
  prefs: []
  type: TYPE_NORMAL
- en: Since the `yCombinator` (lambda expression) has been prewired, when it's time
    to evaluate the lambda expression (*line 13*), only two steps are required. Compare
    that to the twelve steps required to evaluate the regular recursive function (`Recurse`).
  prefs: []
  type: TYPE_NORMAL
- en: Since recursion is necessary in our lambda expression implementation, now would
    be a good time to re-emphasize the need for the Go compiler to support **Tail
    Call Optimization** (**TCO**). [Chapter 3](../Text/Ch03.xhtml), *Using High-Order
    Functions,* mentioned that TCO avoids creating a new stack by making the last
    call in a recursion the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: What is tail recursion?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recursion is where a function calls itself. Tail recursion is where a recursive
    call is the last line of our function. For example, the last line of our `fib`
    function calls itself twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this case, there is no reason to preserve the state. There are no other lines
    of code left to execute in the function and we don’t care about any values of
    any variables that may have been assigned prior to reaching our return statement.
  prefs: []
  type: TYPE_NORMAL
- en: If our return statement occurred in the middle of our function, the Go runtime
    would need to remember our function’s address in order to return to it, and it
    would need to store function-local variable values for when our recursive call
    completes and returns to resume execution.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we currently have is that Go treats all recursive calls the same.
    Even though tail recursion has no need for a return address or to access any other
    function-local variable values, Go does it anyway.
  prefs: []
  type: TYPE_NORMAL
- en: If Go were tail call optimized, then it would not allocate additional space
    on the stack but would instead execute a `GOTO` statement from the tail call directly
    to itself. That would improve performance and save stack space.
  prefs: []
  type: TYPE_NORMAL
- en: Why not optimize tail calls? One reason is that inserting `GOTO` statements
    could make debugging stack frame information more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: When was the last time you debugged a stack frame? I’m sure system programmers
    debug stack frames all day, but most of us don’t. It’s probably safe to assume
    that we all care about performance. Perhaps a trade-off would be to allow functional
    programmers to add an annotation above a tail call to indicate to the compiler
    to perform TCO for us?
  prefs: []
  type: TYPE_NORMAL
- en: Without TCO, we need to be aware of recursion depth, because in Go each level
    of recursion means another layer of information that Go runtime needs to store
    on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: If we are traversing a binary tree, our recursive algorithm will likely be **O(log
    n)**, which means that we will likely not run into runtime performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: However, if our recursion depth is **O(n)**, this could lead to some troubles
    with stack. Anything over that should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Big-Oh notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Big-Oh notation is frequently used to indicate the relative complexity of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s used to indicate the order of an algorithm. For example, if we have three
    algorithms, one O(n), one O(n log n), and one O(n2), the times for various n are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **n** | **O(n)** | **O(n log n)** | **O(n2)** |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 10 | 33 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 100 | 664 | 10000 |'
  prefs: []
  type: TYPE_TB
- en: '| 500 | 500 | 4483 | 250000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 1000 | 9966 | 1000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 5000 | 5000 | 61438 | 25000000 |'
  prefs: []
  type: TYPE_TB
- en: Let’s assume our unit of measurement is one second per operation. The first
    line in the table tells us that executing 10 operations takes from 10 seconds
    for an **O(n)** algorithm to about 1.5 minutes for a **O(n2)** algorithm. The
    last line tells us that executing 5,000 operations would take from 1.4 hours for
    the **O(n)** to around three quarters of a year for the **O(n2)** algorithm. Order
    of magnitude matters.
  prefs: []
  type: TYPE_NORMAL
- en: What does this have to do with tail recursion? Recursive function calls make
    our stack grow linearly **O(n)**. So, the lack of TCO probably won't make our
    applications crash, but it will definitely slow them down. Performing computations
    with an order of magnitude greater than **O(n)** would be difficult at best.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, when we use recursive function calls, we can quickly run out
    of stack space. TCO can reorganize/optimize our code so that our program uses
    constant stack space, which will prevent our stack from growing too large and
    will reduce stack errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of TCO are:'
  prefs: []
  type: TYPE_NORMAL
- en: Improved execution speed, since no stack pushes and pops are required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function recursion depth is no longer a constraint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack overflow runtime errors will not be an issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The languages that support TCO are:'
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript (ECMAScript 6.0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Racket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tcl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elixir
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where's Haskell? Haskell performs more optimized optimizations than just the
    tail call elimination. Haskell uses *guarded* recursion. It's a lazy runtime system
    that does not evaluate a thunk unless it has to.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few reasons to not include it. With TCO enabled, calls would no
    longer be clearly delineated, making debugging stack frames more difficult. How
    would TCO affect defer statements?
  prefs: []
  type: TYPE_NORMAL
- en: What if Go supported an annotation (such as `//@tco`) that would allow us to
    turn on TCO for a particular function call?
  prefs: []
  type: TYPE_NORMAL
- en: See the  *How to Propose Changes To Go *section of the appendix for more information
    about Go and TCO.
  prefs: []
  type: TYPE_NORMAL
- en: InternationalizatioN (I18N) package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember earlier in the chapter when we looked at the monad workflow and saw
    how we could push all errors that occurred in any step into the error pipe and
    wait until the very end to process them?
  prefs: []
  type: TYPE_NORMAL
- en: One thing we might need to do when we process errors is to localize the error
    messages for the language of the individuals tasked with reading them.
  prefs: []
  type: TYPE_NORMAL
- en: This sample application explores how we might do that using the `go-i18n` library.
  prefs: []
  type: TYPE_NORMAL
- en: The Go package **go-i18n** ([https://github.com/nicksnyder/go-i18n](https://github.com/nicksnyder/go-i18n)) a
    command ([https://github.com/nicksnyder/go-i18n#goi18n-command](https://github.com/nicksnyder/go-i18n#goi18n-command))
    that helps you translate Go programs into multiple languages. It supports pluralized
    strings ([http://cldr.unicode.org/index/cldr-spec/plural-rules](http://cldr.unicode.org/index/cldr-spec/plural-rules))
    for all 200+ languages in the **Unicode Common Locale Data Repository** (**CLDR**)
    [http://www.unicode.org/cldr/charts/28/supplemental/language_plural_rules.html](http://www.unicode.org/cldr/charts/28/supplemental/language_plural_rules.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.go`, we import the `github.com/nicksnyder/go-i18n/i18n` library as
    well at the text/template library from Go’s Standard Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we initialize the `funcMap` function with the `"T"` key, and give it
    the value `i18n.TranslateFunc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define our templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We define their corresponding functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that if our error message accepts parameters, then we define them in
    the body of the Execute function. For example, `illegalBase64` defines `BytePos`.
    Here’s how it might be output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main function, we load our translation files. In this sample application,
    we’ll show the support for English and German:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we range over a list of our two languages, `en-US`, and `de-DE`, printing
    out three messages for each language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where we tell `i18n` which translation to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Three lines follow, in which we assign our en-US translation function to the
    `"T"` key of our `tmplIllegalBase64Data` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: When it is evaluated, the `Funcs` method in `text/template/template.go` is executed
    and is passed to our `funcMap` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what `Funcs` looks like (mine is in `/usr/local/Cellar/go/1.9/libexec/src/text/template/template.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Notice that since `Func` is a method of `*Template` and returns a `*Template`,
    `Func` can be chained.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the range loop, we call our error message printing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The English translation file `4-purely-functional/ch10-monads/04_i18n/en-us.all.json`
    has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The German translation file `4-purely-functional/ch10-monads/04_i18n/de-de.all.json`
    has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: I used Google Translate. Just type sentences in your native language in the
    left pane (English) and select the language you want it translated to (German)
    in the right pane's drop-down.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Google Translate to translate sentences into other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4c7f951-2355-458b-a0a5-73e2bfaf9a5c.png)'
  prefs: []
  type: TYPE_IMG
- en: Assuming you are using the init script that is included in every Go project
    for this book, you should have the `get-go-binary` Bash function loaded in your
    shell and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the workflow to initialize our project and install i18n:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3e8b6dc-67ae-4339-a7fd-f093289dd165.png)'
  prefs: []
  type: TYPE_IMG
- en: The i18n site describes a workflow we can use if we are sending our files out
    to a translation service.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type classes allow us to define behavior on types.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 3](../Text/Ch03.xhtml), *Using High-Order Functions*,
    type classes add an additional layer to our type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We accomplish this by:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining behavior using Go interfaces (parent type class)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declaring a new type (base type class) to wrap base types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing behavior on our new type classes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look at our `Equals` type class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parent class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Equals is our parent type class. All base classes must implement the `Equals`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Base class definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll define two base types, `Int` and `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Int base class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Equals` method of Int will check whether other types are equal, using
    whatever logic we deem appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: String base class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It''s just like the `Int` class, but for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Our main.go file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We start by importing our typeclass code (located in the `src` directory, where
    we store all project-local packages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Sum parent type class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s create another type class to sum values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Sum is our parent type class. All base type classes must implement the `Sum`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Sum base classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are our base classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: We can see from our type definitions that we will be able to sum any two of
    these base types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `Int32` implementation of `Sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we return zero if the value we are trying to add our `Int32` to
    is not in the accepted list of types.
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to implement a result type, like Haskell’s Either type.
    This is a recent Golang specification addition which was rejected. For details,
    see [https://github.com/golang/go/issues/19991](https://github.com/golang/go/issues/19991).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sum implementations for `Int64` and `Float64` are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In our implementation for int slices, we implement a range iteration for each
    type we wish to add to our slice of ints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we exercise our `Sum` type classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Generics revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the last chapter, we discussed some of the benefits of generics:'
  prefs: []
  type: TYPE_NORMAL
- en: Type safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminates the need to write repetitive, boilerplate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuses and shares code for different types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforces consistent APIs across different types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time spent optimizing generic code has more impact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t need to re-implement algorithms that are hard to get right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to specify domain constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given the following type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of writing both of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the price sums as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'If Go supported generics, we could write it once. It would look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the price sums as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Covariance and contravariance ([https://www.ibm.com/developerworks/library/j-jtp01255/index.html](https://www.ibm.com/developerworks/library/j-jtp01255/index.html)) refers
    to the ability to use a less specific or more more specific type than originally
    specified. Covariant and contravariant generic type parameters provide greater
    flexibility when assigning and using generic types.
  prefs: []
  type: TYPE_NORMAL
- en: Considering that example code, what's not to love about generics?
  prefs: []
  type: TYPE_NORMAL
- en: Go's fast compilation speed is partly due to incremental compilation. Incremental
    compilation is not possible with generics because the concrete type only knows
    where the generic function is used at runtime, not where it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not counting the fact that the implementation of generics into the Go compiler
    would be incredibly complex, in terms of both semantics and implementation, here
    are some of the disadvantages of adding generics to Go from a developer''s perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic algorithms tend to accumulate features (affecting code quality).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to optimize generic algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to debug generic code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling complexities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage complexities: covariance, contravariance, erasure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slows down compile time (or runtime).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic/existing non-generic code incompatibilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth and the seventh disadvantage and 7 are the most concerning.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s better understand what is meant by error handling complexities.
    What about `Maybe`, `Either`, and `Option` solving the nil pointer errors?
  prefs: []
  type: TYPE_NORMAL
- en: In order for pure FP monadic error handling to work, all the packages referenced
    in our applications would need to return a monadic error type, like Either. (Either
    it succeeded or not, but nil would never be returned.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Granted, that would eliminate the need for the the following ubiquitous error
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: However, we would now need to change the way we handle errors, using new language
    extensions like `Maybe` monads, `Either`, `Option`, `Nothing`, `Just`, and so
    on. (For some code examples, see `2-design-patterns/ch04-solid/02_maybe`.) That’s
    another layer of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, how would we integrate this new error handling paradigm into existing
    applications? If we were creating a new application, but wanted to use any standard
    library packages or any package that had not been converted to use generics-compatible
    error handling, would we write an adapt layer? That's another layer of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The impact of going generic would be signification. What percentage of the Go
    Standard Library would need to change?
  prefs: []
  type: TYPE_NORMAL
- en: Do we replace the ubiquitous slice with a collection type? How much existing
    code would be affected by that?
  prefs: []
  type: TYPE_NORMAL
- en: How would support for generics affect concurrency?
  prefs: []
  type: TYPE_NORMAL
- en: How would performance be impacted if go were to lose type erasure and implement
    reification in order to add explicit type annotations to generic arguments?
  prefs: []
  type: TYPE_NORMAL
- en: Impact of Golang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A minimal set of language constructs that would need modification includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Type assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are all deeply impactful, and the last one is deep and broad.
  prefs: []
  type: TYPE_NORMAL
- en: The entire type system will likely need an overhaul.
  prefs: []
  type: TYPE_NORMAL
- en: Personal opinion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before writing this book, I was of the opinion that the benefits of generics
    far outweighed its disadvantages. Writing this book forced me to really think
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: I thought about the pros and cons as well as alternatives, such as using metaprogramming
    and code generation tools (see the clipperhouse/gen tool in the last chapter).
  prefs: []
  type: TYPE_NORMAL
- en: I thought about how monadic error handling works and its similarities to Go’s
    `return successValue, err  error` handling idiom (as well as its similarities
    to the Unix `stdout` / `stderr`). I found a way to get the most significant feature
    from pure FP (Monads) to work in Go while maintaining Go’s error handling idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using The Lexical (Monadic) Workflow Solution in Go are:'
  prefs: []
  type: TYPE_NORMAL
- en: Type-safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No empty interfaces/unboxing/downcasting/reflection required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressive, easy-to-understand workflow code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get(data)` then `Next(step)`, `Next(step)` until done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mostly idiomatic error handling in one place (at the end)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly mirrors business requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows us to compose new workflows easily using reusable components (see `toolbox.go`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designed to be optimized for horizontal scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not impose any requirements on external packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not require additional Monadic error handling logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this solution uses a lambda expression, there is recursion, and since
    Go currently does not provide TCO, there is a performance hit, but the recursion
    is limited to controlling the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The burden is that I must manually create repetitive code or generate the generic
    code (using a tool like clipperhouse/gen) to avoid the performance penalty of
    using the empty `interface{}` and reflection.
  prefs: []
  type: TYPE_NORMAL
- en: I concluded that generics are a trade-off between compilation time, runtime,
    and my time. Given the risk and the list of disadvantages of adding generics to
    Go, I’m okay with doing a little more work.
  prefs: []
  type: TYPE_NORMAL
- en: '"Simplicity and elegance are unpopular because they require hard work and discipline
    to achieve and education to be appreciated."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Edsger Dijkstra'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function programming in Go is a paradigm shift, a fundamentally different approach
    to the way we write software. Just like we can get the results we want with an
    imperative Turing Machine or with Lambda Calculus, we can choose to code imperatively
    with idiomatic Go or declaratively using the FP style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: We began our journey with a light introduction to FP. We learned how to write
    intermediate functions like `Map`, `Filter`, and `Sort`, as well as terminal functions
    like `Reduce` and `Join`, to transform collections. We saw how to use tools like
    Gleam and Itertool and implemented lazy evaluation using Go routines and a Go
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: We thought about the characteristics of FP and worked through examples of function
    composition, closures, and high order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We studied both the imperative-functional and pure-functional styles of software
    design (and later mixed both styles). We learned how the Reader/Writer interface
    in Go implements the single responsibility principle. Just one whiff of OOP gave
    us an appreciation for the simplicity (and honesty) of pure FP. (FP contracts
    don''t lie.)  The secret to function composition was revealed to us: Monads chain
    continuations.'
  prefs: []
  type: TYPE_NORMAL
- en: We learned how `Map` and `Reduce` work. As the constant flow of diagrams began
    to heighten our awareness of the value of FP, we were tossed back to the world
    of imperative programming using functions.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing, embedding, the decorator, strategy, and pipeline patterns, inversion
    of control, dependency injection, the use of channels to control the flow of events
    in a concurrent program... we even learned how to avoid circular dependencies
    using a layered application architecture. We learned the difference between currying
    and partial application and how to implement functional parameters to improve
    our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Category theory was presented in a way never seen before: using over 100 images,
    17 tables of information, and code samples, along with simple and concise wording.
    We led you through the history of functional programming and learned the deep
    connection between category theory, logic, and type theory. We learned that the
    math we learned in grade school, middle school, and high school is applicable
    to functional programming. (Maybe that even inspired someone to send their old
    math teacher a note of appreciation?)'
  prefs: []
  type: TYPE_NORMAL
- en: With a solid understanding of category theory, we embarked on a pure FP journey
    where we learned how to map between worlds using functors. We built a few monoids
    and learned how to write a reduce function. We also learned how to use a generics
    code generation tool to solve the boilerplate problem.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the knowledge of pure and imperative functional programming, we dove
    into the world of Monads. We learned about Lambda Calculus and how the Y-Combinator
    works, and how to use it to control workflow.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the Lexical Workflow Solution that leveraged the Y-Combinator
    to control a sequence of impure operations. We witnessed our data as it was transformed
    from one step to the next. We saw how the `Success` and `Failure` pipes work and
    how we could handle all errors at the end of the pipeline using the idiomatic
    Go techniques. We gained a much better understanding of the pros and cons of adding
    generics to Go.
  prefs: []
  type: TYPE_NORMAL
- en: Where to go from here
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Look for places to use the Lexical Workflow Solution to control data transformation
    workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a reusable set of components, to put in your toolbox, that you can use
    in our workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build your own type classes, monads and pure FP components in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support the request to add TCO to Go (see the [Appendix](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=7&action=edit),
    *Miscellaneous Information and How-To's*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope the information you found in this book is useful for what you're building
    both today and tomorrow and that it inspires you to continue to improve upon these
    ideas so that we can all build even better applications going forward.
  prefs: []
  type: TYPE_NORMAL
- en: '"Talk is cheap. Show me the code."'
  prefs: []
  type: TYPE_NORMAL
- en: - Linus Torvalds
  prefs: []
  type: TYPE_NORMAL
