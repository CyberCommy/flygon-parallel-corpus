- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the Importance of Software Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software architecture is one of the most discussed topics in the software industry
    today, and its importance will certainly grow more in the future. The more we
    build complex and fantastic solutions, the more we need great software architectures
    to maintain them. But the speed at which new features are added to these software
    solutions keeps increasing, and new architectural opportunities keep emerging.
    That is the reason why you decided to read this book; it's the reason why we decided
    to write its second edition.
  prefs: []
  type: TYPE_NORMAL
- en: It's not a simple task to write about this important topic, which offers so
    many alternative techniques and solutions. The main objective of this book is
    not to build an exhaustive and never-ending list of available techniques and solutions,
    but to show how various families of techniques are related, and how they impact,
    in practice, the construction of a maintainable and sustainable solution.
  prefs: []
  type: TYPE_NORMAL
- en: The need to keep our focus on creating actual, effective enterprise solutions
    keeps increasing; users always need more new features in their applications. Moreover,
    the need to deliver frequent application versions (due to a quickly changing market)
    increases our obligation to have sophisticated software architecture and development
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The understanding of what software architecture is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some software development process models that may help you as a software architect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process for gathering the right information to design high-quality software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design techniques for helping in the process of development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cases where the requirements impact the system results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the case study of the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case study of this book will take you through the process of creating the
    software architecture for a travel agency called **World Wild Travel Club** (**WWTravelClub**).
    The purpose of this case study is to help you understand the theory explained
    in each chapter, and to provide an example of how to develop an enterprise application
    with Azure, Azure DevOps, C# 9, .NET 5, ASP.NET, and other technologies that will
    be introduced in this book.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to understand exactly what the
    mission of software architecture is. You will also learn what Azure is, and how
    to create your account on the platform. You'll also get an overview of software
    processes, models, and other techniques that will enable you to conduct your team.
  prefs: []
  type: TYPE_NORMAL
- en: What is software architecture?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are reading this book today, you should thank the computer scientists
    who decided to consider software development as an engineering area. This happened
    in the last century, more specifically, at the end of the sixties, when they proposed
    that the way we develop software is quite like the way we construct buildings.
    That is why we have the name **software architecture**. Like an architect designs
    a building and oversees its construction based on that design, the main goal of
    a software architect is to ensure that the software application is implemented
    well; and good implementation requires the design of a great solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a professional development project, you must do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the customer requirements for the solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design a great solution to meet those requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the designed solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the solution with your customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deliver the solution in the working environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software engineering defines these activities as the software development life
    cycle. All the theoretical software development process models (waterfall, spiral,
    incremental, agile, and so on) are somehow related to this cycle. No matter which
    model you use, if you do not work with the essential tasks presented earlier during
    your project, you will not deliver acceptable software as a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main point about designing great solutions is foundational to the purpose
    of this book. You must understand that great real-world solutions bring with them
    a few fundamental constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: The solution needs to meet user requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution needs to be delivered on time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution needs to adhere to the project budget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution needs to deliver good quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution needs to guarantee safe and effective future evolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great solutions need to be sustainable, and you must understand that there is
    no sustainable software without great software architecture. Nowadays, great software
    architectures depend on both modern tools and modern environments to perfectly
    fit users' requirements.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, this book will use some great tools provided by Microsoft.
    The company has announced .NET 5 as a unified platform for software development,
    which gives us a great opportunity to create fantastic solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing .NET 5 | .NET Blog](img/B16756_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: .NET 5 platform'
  prefs: []
  type: TYPE_NORMAL
- en: NET 5 is delivered together with C# 9\. Considering the .NET approach of targeting
    so many platforms and devices, C# is now one of the most used programming languages
    in the world and runs on small devices up to huge servers in different operating
    systems and environments.
  prefs: []
  type: TYPE_NORMAL
- en: The book will also use **Azure**, which is Microsoft's cloud platform, where
    you will find all the components the company provides to build advanced software
    architecture solutions. One of them is **Azure DevOps**, an application life cycle
    management environment where you can build solutions using the latest approach
    for developing software.
  prefs: []
  type: TYPE_NORMAL
- en: Being a software architect means understanding the aforementioned technologies,
    and a lot of others, too. This book will guide you on a journey where, as a software
    architect working in a team, you will provide optimal solutions with the tools
    listed. Let us start this journey by creating your Azure account.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Microsoft Azure** is one of the best cloud solutions currently available
    on the market. It is important to know that, inside Azure, we will find a selection
    of components that can help us define the architecture of twenty-first-century
    solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to check the variety of components Microsoft Azure has, just check
    this incredible website developed by Alexey Polkovnikov: [https://azurecharts.com/](https://azurecharts.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: This subsection will guide you in creating an Azure account. If you already
    have one, you can skip this part.
  prefs: []
  type: TYPE_NORMAL
- en: Start your access into Azure using the website address [https://azure.microsoft.com](https://azure.microsoft.com).
    There, you will find the information you need to start your subscription. Translation
    to your native language is usually set automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have accessed this portal, it is possible to sign up. If you have never
    done this before, it is possible to **Start free**, so you will be able to use
    some Azure features without spending any money. Please check the options for free
    plans at [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process for creating a free account is quite simple, and you will be guided
    by a form that requires you to have a **Microsoft Account** or **GitHub Account**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the process you will also be asked for a credit card number, to verify
    your identity and to keep out spam and bots. However, you will not be charged
    unless you upgrade the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish the assignment, you will need to accept the subscription agreement,
    offer details, and privacy statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you finish the form, you will be able to access the Azure portal. As you
    can see in the following screenshot, the panel shows a dashboard that you can
    customize, and a menu on the left, where you can set up the Azure components you
    are going to use in your solution. Throughout this book, we will come back to
    this screenshot to set up the components to help us create modern software architecture.
    To find the next page, just select the left-menu icon (hamburger menu) and click
    on **All services**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: The Azure portal'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your Azure account created, you are ready to understand how a
    software architect can conduct a team to develop software, taking advantage of
    all the opportunities offered by Azure. However, it is important to keep in mind
    that a software architect needs to go beyond technologies because this role is
    played by people who are expected to define how the software will be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Today, a software architect not only architects the basis of a software, but
    also determines how the whole software development and deployment process is conducted.
    The next topic will cover some of the most widely used software development paradigms
    the world over. We'll start by describing what the community refers to as traditional
    software engineering. After that, we'll cover the agile models that have changed
    the way we build software nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: Software development process models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a software architect, it's important for you to understand some of the common
    development processes that are currently used in most enterprises. A software
    development process defines how people in a team produce and deliver software.
    In general, this process relates to a software engineering theory, called a **software
    development process model**. From the time software development was defined as
    an engineering process, many process models for developing software have been
    proposed. Let us review the traditional software models, and then look at the
    agile ones that are currently common.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing traditional software development process models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the models introduced in the software engineering theory are already
    considered traditional and quite obsolete. This book does not aim to cover all
    of them, but here, we will give a brief explanation of the ones that are still
    used in some companies – waterfall and incremental models.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the waterfall model principles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This topic may appear strange in a software architecture book from 2020, but
    yes, you may still find companies where the most traditional software process
    model remains the guideline for software development. This process executes all
    fundamental tasks in sequence. Any software development project consists of the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements, where a product requirement document is created, and it is the
    basis for the software development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design, where the software architecture is developed according to requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation, where the software is programmed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verification, where tests are taken in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintenance, where the cycle starts again, after a delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us look at a diagrammatic representation of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: The waterfall development cycle (https://en.wikipedia.org/wiki/Waterfall_model)'
  prefs: []
  type: TYPE_NORMAL
- en: Often, the use of waterfall models causes problems related to delays in the
    delivery of a functional version of the software, and user dissatisfaction due
    to the distance between expectations and the final product delivered. Besides,
    in my experience, having application tests start only after the completion of
    development always feels terribly stressful.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the incremental model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Incremental development is an approach that tries to overcome the biggest problem
    of the waterfall model: the user can test the solution only at the end of the
    project. The idea of this model is to give the users opportunities to interact
    with the solution as early as possible so that they can give useful feedback,
    which will help during the development of the software.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: The incremental development cycle (https://en.wikipedia.org/wiki/Incremental_build_model)'
  prefs: []
  type: TYPE_NORMAL
- en: The incremental model presented in the preceding picture was introduced as an
    alternative to the waterfall approach. The idea of the model is to run for each
    increment a set of practices related to software development (**Communication**,
    **Planning**, **Modeling**, **Construction**, and **Deployment**). Although it
    mitigated the problems related to the lack of communication with the customer,
    for big projects, fewer increments were still a problem because the increments
    remained too long.
  prefs: []
  type: TYPE_NORMAL
- en: When the incremental approach was used on a large scale—mainly at the end of
    the last century—many problems related to project bureaucracy were reported, due
    to the large amount of documentation required. This clunky scenario caused the
    rise of a very important movement in the software development industry – **agile**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding agile software development process models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this century, developing software was considered one of
    the most chaotic activities in engineering. The percentage of software projects
    that failed was incredibly high, and this fact proved the need for a different
    approach to deal with the flexibility required by software development projects.
  prefs: []
  type: TYPE_NORMAL
- en: In 2001, the Agile Manifesto was introduced to the world, and from that time
    forward various agile process models were proposed. Some of them have survived
    up until now and are still very common.
  prefs: []
  type: TYPE_NORMAL
- en: The Agile Manifesto is translated into more than 60 languages. Please check
    out its link at [https://agilemanifesto.org/](https://agilemanifesto.org/).
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest differences between agile models and traditional models is
    the way developers interact with the customer. The message that all agile models
    transmit is that the faster you deliver software to the user, the better. This
    idea is sometimes confusing for software developers who understand this as – *let's
    try coding, and that's all, folks!*
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is an important observation of the Agile Manifesto that many
    people do not read when they start working with agile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Manifesto for Agile software development'
  prefs: []
  type: TYPE_NORMAL
- en: A software architect always needs to remember this. Agile processes do not mean
    a lack of discipline. Moreover, when you use the agile process, you'll quickly
    understand that there is no way to develop good software without discipline. On
    the other hand, as a software architect, you need to understand that *soft* means
    flexibility. A software project that refuses to be flexible tends to ruin itself
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 12 principles behind agile are foundational to this flexible approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuously delivering valuable software to satisfy the customer must be the
    highest priority of any developer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing requirements needs to be understood as an opportunity to make the customer
    more competitive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do use a weekly timescale to deliver software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A software team must be composed of business people and developers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A software team needs to be trusted and should have the correct environment
    to get the project done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The best way to communicate with a software team is face to face.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can understand the greatest software team achievement as when the software
    is really working on production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Agile is working properly when it delivers sustainable development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The more you invest in techniques and good design, the more agile you are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplicity is essential.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The more self-organized the teams are, the better-quality delivery you will
    have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Software teams tend to improve their behavior from time to time, analyzing and
    adjusting their process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even 20 years after the launch of the Agile Manifesto, its importance and connection
    to the current needs of software teams remain intact. Certainly, there are many
    companies where this approach is not well accepted, but as a software architect
    you should understand this as an opportunity to transform practices and evolve
    the team with you are working.
  prefs: []
  type: TYPE_NORMAL
- en: There are many techniques and models that were presented to the software community
    with the agile approach. The next subtopics will discuss Lean software development,
    Extreme Programming, and Scrum, so that you can decide, as a software architect,
    which ones you might use to improve your software delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Lean software development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the Agile Manifesto, the approach of Lean software development was introduced
    to the community as an adaptation of a well-known movement in automobile engineering;
    Toyota's model for building cars. The worldwide Lean manufacturing method delivers
    a high level of quality even with few resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mary and Tom Poppendieck listed seven Lean principles for software development,
    really connected to agile and to the approach of many companies of this century.
    I''ve listed them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eliminate waste**: You may consider waste to be anything that will interfere
    with the delivery of the real need of a customer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build quality in**: An organization that wants to guarantee quality needs
    to promote it in processes that build code from the beginning, instead of only
    consider it after code is being tested.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create knowledge**: Companies that achieved excellence have a common pattern
    of generating new knowledge by disciplined experimentation, documenting it, and
    guaranteeing that this knowledge is spread all over the organization.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Defer commitment**: Plan decisions to its last chance before causing damage
    to the project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deliver fast**: The faster you deliver software, the more elimination of
    waste you have. Companies that compete using time frequency have significant advantages
    over their competitors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Respect people**: Giving reasonable objectives to the team, together with
    plans that will guide them to self-organize their routine, is a matter of respecting
    people that you work with.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Optimize the whole**: A Lean company improves all the cycle of value; from
    the moment it receives a new requirement up to the one it delivers when the software
    is done.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Lean principles cause a team or company approach to improve the quality
    of the features that the customer really needs. It also creates a reduction in
    time spent on features that will not be used by the time the software is delivered
    to the customer. In Lean, deciding the features that are important to the customer
    guides the team in delivering software that matters, and this is exactly what
    the Agile Manifesto intends to promote in software teams.
  prefs: []
  type: TYPE_NORMAL
- en: Extreme Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just before the release of the Agile Manifesto, some of the participants who
    designed the document, especially Kent Beck, presented to the world the **Extreme
    Programming** (**XP**) **methodology** for developing software.
  prefs: []
  type: TYPE_NORMAL
- en: XP is based on values of simplicity, communication, feedback, respect, and courage.
    It was considered later as a social change in programming, according to Beck in
    his second book about the topic. It certainly promotes a huge change in the flow
    of development.
  prefs: []
  type: TYPE_NORMAL
- en: XP indicates that every team should have the simplicity to do only what it was
    asked for, communicating face to face daily, demonstrating the software early
    to get feedback, respecting the expertise of each member of the team, and having
    the courage to tell the truth about progress and estimates, considering the team's
    work as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: XP also delivers a set of rules. These rules may be changed by the team if they
    detect something is not working properly, but it's important to always maintain
    the values of the methodology.
  prefs: []
  type: TYPE_NORMAL
- en: 'These rules are divided into planning, managing, designing, coding, and testing.
    Don Wells has mapped XP at the site [http://www.extremeprogramming.org/](http://www.extremeprogramming.org/).
    Although some of the ideas of the methodology were criticized strongly by many
    companies and specialists, there are many good practices that are used today:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing software requirements using user stories**: User stories are considered
    an agile approach to describe user needs, together with the acceptance tests that
    will be used to guarantee the correct implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Divide software into iterations and deliver small releases**: The practice
    of iterating in software development is defended by all methodologies after waterfall.
    The fact of delivering faster versions decreases the risks of not achieving the
    customer''s expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid working overtime and guarantee a sustainable velocity**: Although this
    must be one of the hardest tasks a software architect may deal with, overtime
    working indicates something is not working properly in the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep things simple**: While developing solutions, it is quite common to try
    to anticipate features that the customer would like to have. This approach increases
    the complexity of the development and the time to market the solution. A different
    approach will cause high costs, and probably a low level of features that are
    actually used, in the system you are developing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring**: The approach of refactoring the code continuously is good
    because it enables the evolution of your software and guarantees the design improvement
    that will truly be necessary due to the normal technical changes of the platforms
    you use to develop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep the customer always available**: If you follow the rule from XP, you
    should have an expert customer inside your team. This is certainly something that
    is hard to get and deal with, but the main idea of this approach is guaranteeing
    that the customer is involved in all parts of development. As another bonus, having
    the customer close to your team means they understand the difficulties and expertise
    the team has, enabling an increase of the trust between the parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous integration**: This practice is one of the bases of the current
    DevOps approach. The less difference you have between your personal code repository
    and the main code repository, the better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code the unit test first**: A unit test is an approach where you program
    specific code for testing a single unit (class/method) of your project. This is
    discussed in a current development methodology called **Test-Driven Development**
    (**TDD**). The main goal here is to guarantee that every business rule has its
    own unit test case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code must be written to agreed standards**: The need of determining standards
    for coding is connected to the idea that no matter which developer you have working
    on a specific part of the project, the code must be written so that any of them
    will understand it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pair programming**: Pair programming is another difficult approach to achieve
    in every single minute of a software project, but the technique itself—one programmer
    coding and the other actively observing and offering comments, criticism, and
    advice—is useful in critical scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance tests**: The adoption of acceptance tests to meet user stories
    is a good way to guarantee that new released versions of the software do not cause
    damage to its current needs. An even better option is to have these acceptance
    tests automated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth mentioning that many of these rules are today considered vital practices
    in different software development methodologies, including DevOps and Scrum. We
    will discuss DevOps later in this book, in *Chapter 20*, *Understanding DevOps
    Principles*. Let's get into the Scrum model right now.
  prefs: []
  type: TYPE_NORMAL
- en: Getting into the Scrum model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scrum is an agile model for the management of software development projects.
    The model comes from Lean principles and is one of the widely used approaches
    for developing software nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please check this link for more information about the Scrum framework: [https://www.scrum.org/](https://www.scrum.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following figure, the basis of Scrum is that you have
    a flexible backlog of user requirements (**Product Backlog**) that needs to be
    discussed in each agile cycle, called a **Sprint**. The Sprint goal (**Sprint
    Backlog**) is determined by the Scrum Team, composed of the Product Owner, the
    Scrum Master, and the Development Team. The **Product Owner** is responsible for
    prioritizing what will be delivered in that Sprint. During the Sprint, this person
    will help the team to develop the required features. The person who leads the
    team in the Scrum process is called the **Scrum Master**. All the meetings and
    processes are conducted by this person.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: The Scrum process'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to notice that the Scrum process does not discuss how the software
    needs to be implemented, nor which activities will be done. Again, you must remember
    the basis of software development, discussed at the beginning of this chapter;
    that means Scrum needs to be implemented together with a process model. DevOps
    is one of the approaches that may help you use a software development process
    model together with Scrum. Check *Chapter 20*, *Understanding DevOps Principles*,
    to understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering the right information to design high-quality software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fantastic! You just started a software development project. Now, it's time to
    use all your knowledge to deliver the best software you can. Your first question
    is probably – *How do I start?* Well, as a software architect, you're going to
    be the one to answer it. And you can be sure your answer is going to evolve with
    each software project you lead.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a software development process is the first task. This is generally
    done during the project planning process, or might happen before it starts.
  prefs: []
  type: TYPE_NORMAL
- en: Another very important task is to gather the software requirements. No matter
    which software development process you decide to use, collecting real user needs
    is part of a difficult and continuous job. Of course, there are techniques to
    help you with this, and you can be sure that gathering requirements will help
    you to define important aspects of your software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: These two tasks are considered by most experts in software development as the
    keys to success at the end of the development project journey. As a software architect,
    you need to enable them so that you can avoid as many problems as possible while
    guiding your team.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the requirements gathering process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different ways to represent the requirements. The most traditional
    approach consists of you having to write a perfect specification before the beginning
    of the analysis. Agile methods suggest instead that you need to write user stories,
    as soon as you are ready to start a development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Remember**: You do not write requirements just for the user; you write them
    for you and your team too.'
  prefs: []
  type: TYPE_NORMAL
- en: The truth is, that no matter the approach you decide to adopt in your projects,
    you will have to follow some steps to gather requirements. This is what we call
    **requirements engineering**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Requirements engineering process'
  prefs: []
  type: TYPE_NORMAL
- en: During this process, you need to be sure that the solution is feasible. In some
    cases, the feasibility analysis is part of the project planning process too, and
    by the time you start the requirements elicitation, you will have the feasibility
    report already done. So, let us check the other parts of this process, which will
    give you a lot of important information for the software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting exact user needs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a lot of ways to detect what exactly the user needs for a specific
    scenario. This process is known as elicitation. In general, this can be done using
    techniques that will help you to understand what we call user requirements. Here,
    you have a list of common techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The power of imagination**: If you are an expert in the area where you are
    providing solutions, you may use your own imagination to find new user requirements.
    Brainstorming can be conducted together so that a group of experts can define
    user needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Questionnaires**: This tool is useful for detecting common and important
    requirements such as the number and kind of users, peak system usage, and the
    commonly used **operating system** (**OS**) and web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interviews**: Interviewing the users helps you as an architect to detect
    user requirements that perhaps questionnaires and your imagination will not cover.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observation**: There is no better way to understand the daily routine of
    a user than being with them for a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as you apply one or more of these techniques, you will have great and
    valuable information about the user's needs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Remember**: You can use these techniques in any situation where the real
    need is to gather requirements, no matter if it is for the whole system or for
    a single story.'
  prefs: []
  type: TYPE_NORMAL
- en: At that moment, you will be able to start analyzing these user needs, and detecting
    the user and system requirements. Let's see how to do so in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you''ve detected the user needs, it''s time to begin analyzing the requirements.
    To do so, you can use techniques such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prototyping**: Prototypes are fantastic to clarify and to materialize the
    system requirements. Today, we have many tools that can help you to mock interfaces.
    A nice open source tool is the **Pencil Project**. You will find further information
    about it at [https://pencil.evolus.vn/](https://pencil.evolus.vn/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use cases**: The **Unified Modeling Language** (**UML**) use case model is
    an option if you need detailed documentation. The model is composed of a detailed
    specification and a diagram. **ArgoUML** is another open source tool that can
    help you out with this. You can see the model created in *Figure 1.8*:![](img/B16756_01_08.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 1.8: Use case diagram example'
  prefs: []
  type: TYPE_NORMAL
- en: While you are analyzing the requirements of the system, you will be able to
    clarify exactly what the users' needs are. This is helpful when you're not sure
    about the real problem you need to solve, and is much better than just starting
    to program the system and hoping for the best. Time invested in requirements analysis
    is time invested in better code later.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you finish the analysis, it's important to register it as a specification.
    The specification document can be written using traditional requirements, or user
    stories, which are commonly used in agile projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A requirements specification represents the technical contract between the
    user and the team. There are some basic rules that this document needs to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: All stakeholders need to understand exactly what is written in the technical
    contract, even if they are not technicians.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The document needs to be clear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to classify each requirement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use simple future tense to represent each requirement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bad example: A common user registers himself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Good example: A common user shall register himself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambiguity and controversy need to be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some additional information can help the team to understand the context of
    the project they are going to work on. Here are some tips about how to add useful
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: Write an introductory chapter to give a full idea of the solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a glossary to make understanding easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the kind of user the solution will cover.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write functional and non-functional requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional requirements are quite simple to understand because they describe
    exactly what the software will do. On the other hand, non-functional requirements
    determine the restrictions related to the software, which means scalability, robustness,
    security, and performance. We will cover these aspects in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach documents that can help the user to understand rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you decide to write user stories, a good tip to follow is to write short
    sentences representing each moment in the system with each user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This approach will explain exactly the reason why that feature will be implemented.
    It's also a good tool to help you analyze the stories that are most critical,
    and prioritize the success of the project. They can also be great for informing
    the automated acceptance tests that should be built.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of scalability, robustness, security, and performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Detecting requirements is a task that will let you understand the software you
    are going to develop. However, as a software architect, you have to pay attention
    to more than just the functional requirements for that system. Understanding the
    non-functional requirements is important, and one of the earliest activities for
    a software architect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at this in more detail in *Chapter 2*, *Non-Functional
    Requirements*, but at this point, it''s important to know that the principles
    of scalability, robustness, security, and performance need to be applied for the
    requirements gathering process. Let us look at each concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: As a software developer, globalization gives you the opportunity
    to have your solution running all over the world. This is fantastic, but you,
    as a software architect, need to design a solution that provides that possibility.
    Scalability is the possibility for an application to increase its processing power
    as soon as it is necessary, due to the number of resources that are being consumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robustness**: No matter how scalable your application is, if it is not able
    to guarantee a stable and always-on solution, you are not going to get any peace.
    Robustness is important for critical solutions, where you do not have the opportunity
    for maintenance at any time due to the kind of problem that the application solves.
    In many industries, the software cannot stop, and lots of routines run when nobody
    is available (overnight, holidays, and so on). Designing a robust solution will
    give you the freedom to live while your software is running well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: This is another really important area that needs to be discussed
    after the requirements stage. Everybody worries about security, and different
    laws dealing with it are in place and being proposed in different parts of the
    world. You, as a software architect, must understand that security needs to be
    provided by design. This is the only way to cope with all the needs that the security
    community is discussing right now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: The process of understanding the system you are going to develop
    will probably give you a good idea of what you''ll need to do to get the desired
    performance from the system. This topic needs to be discussed with the user, to
    identify most of the bottlenecks you will face during the development stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth mentioning that all these concepts are requirements for the new
    generation of solutions that the world needs. What differentiates good software
    from incredible software is the amount of work done to meet the project requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have the specification written, it is time to confirm with the stakeholders
    whether they agree with it. This can be done in a review meeting, or can be done
    online using collaboration tools.
  prefs: []
  type: TYPE_NORMAL
- en: This is when you present all the prototypes, documents, and information you
    have gathered. As soon as everybody agrees with the specification, you are ready
    to start studying the best way to implement this part of your project.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that you might use the process described here for both
    the complete software or for a small part of it.
  prefs: []
  type: TYPE_NORMAL
- en: Using design techniques as a helpful tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining a solution is not easy. Determining its technology increases the difficulty
    of doing so. It is true that, during your career as a software architect, you
    will find many projects where your customer will bring you a solution *ready for
    development*. This can get quite complicated if you consider that solution as
    the correct solution; most of the time, there will be architectural and functional
    mistakes that will cause problems in the solution in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some cases where the problem is worse—when the customer does not
    know the best solution for the problem. Some design techniques can help us with
    this, and we will introduce two of them here: **Design Thinking** and **Design
    Sprint**.'
  prefs: []
  type: TYPE_NORMAL
- en: What you must understand is that these techniques can be a fantastic option
    to discover real requirements. As a software architect, you are committed to helping
    your team to use the correct tools at the correct time, and these tools may be
    the right options to ensure the project's success.
  prefs: []
  type: TYPE_NORMAL
- en: Design Thinking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Design Thinking** is a process that allows you to collect data directly from
    the users, focusing on achieving the best results to solve a problem. During this
    process, the team will have the opportunity to discover all *personas* that will
    interact with the system. This will have a wonderful impact on the solution since
    you can develop the software by focusing on the user experience, which can have
    a fantastic impact on the results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is based on the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Empathize**: In this step, you must execute field research to discover the
    users'' concerns. This is where you find out about the users of the system. The
    process is good for making you understand why and for whom you are developing
    this software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Define**: Once you have the users'' concerns, it is time to define their
    needs to solve them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ideate**: The needs will provide an opportunity to brainstorm some possible
    solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype**: These solutions can be developed as mock-ups to confirm whether
    they are good ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**: Testing the prototypes will help you to understand the prototype
    that is most connected to the real needs of the users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The focus of a technique like this one is to accelerate the process of detecting
    the right product, considering the **minimum viable product** (**MVP**). For sure,
    the prototype process will help stakeholders to understand the final product and,
    at the same time, engage the team to deliver the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: Design Sprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Design Sprint** is a process focused on solving critical business questions
    through design in a five-day sprint. This technique was presented by Google, and
    it is an alternative that allows you to quickly test and learn from an idea, needing
    to build and launch a solution to market.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is based on a week dedicated by experts to solve the problem mentioned,
    in a war room prepared for that purpose. The week is separated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monday**: The focus of this day is to identify the target of the sprint and
    map the challenge to achieve it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuesday**: After understanding the goal of the sprint, participants start
    sketching solutions that may solve it. It is time to find customers to test the
    new solution that will be provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wednesday**: This is when the team needs to decide the solutions that have
    the greatest chance to solve the problem. Besides, on Wednesday the team must
    draw these solutions into a storyboard, preparing a plan for the prototype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thursday**: It is time to prototype the idea planned on the storyboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friday**: Having completed the prototype, the team presents it to customers,
    learning by getting information from their reaction to the solution designed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in both techniques, the acceleration of collecting reactions
    from customers comes from prototypes that will materialize your team's ideas into
    something more tangible for the end-user.
  prefs: []
  type: TYPE_NORMAL
- en: Common cases where the requirements gathering process impacted system results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the information discussed up to this point in the chapter is useful if you
    want to design software following the principles of good engineering. This discussion
    is not related to developing by using traditional or agile methods, but focuses
    on building software professionally or as an amateur.
  prefs: []
  type: TYPE_NORMAL
- en: It's also a good idea to know about some cases where failing to perform the
    activities you read about caused some trouble for the software project. The following
    cases intend to describe what could go wrong, and how the preceding techniques
    could have helped the development team to solve the problems.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, simple action could have guaranteed better communication between
    the team and the customer, and this easy communication flow would have transformed
    a big problem into a real solution. Let's examine three common cases where the
    requirements gathering impacted the results of performance, functionality, and
    usability.
  prefs: []
  type: TYPE_NORMAL
- en: Case 1 – my website is too slow to open that page!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performance is one of the biggest problems that you as a software architect
    will deal with during your career. The reason why this aspect of any software
    is so problematic is that we do not have infinite computational resources to solve
    problems. Besides, the cost of computation is still high, especially if you are
    talking about software with a high number of simultaneous users.
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot solve performance problems by writing requirements. However, you
    will not end up in trouble if you write them correctly. The idea here is that
    requirements must present the desired performance of a system. A simple sentence,
    describing this, can help the entire team that works on the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-functional requirement**: Performance – any web page of this software
    shall respond in at least 2 seconds, even when 1,000 users are accessing it concurrently.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding sentence just makes everybody (users, testers, developers, architects,
    managers, and so on) sure that any web page has a target to achieve. This is a
    good start, but it's not enough. A great environment to both develop and deploy
    your application is also important. This is where .NET 5 can help you a lot; especially
    if you are talking about web apps, ASP.NET Core is considered one of the fastest
    options to deliver solutions today.
  prefs: []
  type: TYPE_NORMAL
- en: If you talk about performance, you, as a software architect, should consider
    the use of the techniques listed in the following sections together with specific
    tests to guarantee this non-functional requirement. It's also important to mention
    that ASP.NET Core will help you to use them easily, together with some **Platform
    as a Service** (**PaaS**) solutions delivered by Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caching is a great technique to avoid queries that can consume time and, in
    general, give the same result. For instance, if you are fetching the available
    car models in a database, the number of cars in the database can increase, but
    they will not change. Once you have an application that constantly accesses car
    models, a good practice is to cache that information.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that a cache is stored in the backend and that
    cache is shared by the whole application (*in-memory caching*). A point to focus
    on is that when you are working on a scalable solution, you can configure a *distributed
    cache* to solve it using the Azure platform. In fact, ASP.NET provides both, so
    you can decide on the one that bests fits your needs. *Chapter 2*, *Non-Functional
    Requirements*, covers scalability aspects in the Azure platform.
  prefs: []
  type: TYPE_NORMAL
- en: Applying asynchronous programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you develop ASP.NET applications, you need to keep in mind that your app
    needs to be designed for simultaneous access by many users. Asynchronous programming
    lets you do this simply, giving you the keywords `async` and `await`.
  prefs: []
  type: TYPE_NORMAL
- en: The basic concept behind these keywords is that `async` enables any method to
    run asynchronously. On the other hand, `await` lets you synchronize the call of
    an asynchronous method without blocking the thread that is calling it. This easy-to-develop
    pattern will make your application run without performance bottlenecks and better
    responsiveness. This book will cover more about this subject in *Chapter 2*, *Non-Functional
    Requirements*.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with object allocation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One very good tip to avoid a lack of performance is to understand how the **Garbage
    Collector** (**GC**) works. The GC is the engine that will free memory automatically
    when you finish using it. There are some very important aspects of this topic,
    due to the complexity that the GC has.
  prefs: []
  type: TYPE_NORMAL
- en: Some types of objects are not collected by the GC if you do not dispose of them.
    The list includes any object that interacts with I/O, such as files and streaming.
    If you do not correctly use the C# syntax to create and destroy this kind of object,
    you will have memory leaks, which will deteriorate your application performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The incorrect way of working with I/O objects is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct way of working with I/O objects is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It might be worth noting that this correct approach also ensures the file gets
    written (it calls Flush). In the incorrect example, the contents might not even
    be written to the file. Even though the preceding practice is mandatory for I/O
    objects, it is totally recommended that you keep doing this in all disposable
    objects. Indeed, using code analyzers in your solutions with warnings as errors
    will prevent you from accidentally making these mistakes! This will help the GC
    and will keep your application running with the right amount of memory. Depending
    on the type of object, mistakes here can snowball, and you could end up with other
    bad things at scale, for instance, port/connection exhaustion.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect that you need to know about is that the time spent
    by the GC to collect objects will interfere with the performance of your app.
    Because of this, avoid allocating large objects; otherwise, it can cause you trouble
    waiting for the GC to finish its task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting better database access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common performance Achilles' heels is database access. The reason
    why this is still a big problem is the lack of attention while writing queries
    or lambda expressions to get information from the database. This book will cover
    Entity Framework Core in *Chapter 8*, *Interacting with Data in C# – Entity Framework
    Core*, but it is important to know what to choose and the correct data information
    to read from a database. Filtering columns and lines is imperative for an application
    that wants to deliver on performance.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing is that best practices related to caching, asynchronous programming,
    and object allocation fit completely into the environment of databases. It's only
    a matter of choosing the correct pattern to get better-performance software.
  prefs: []
  type: TYPE_NORMAL
- en: Case 2 – the user's needs are not properly implemented
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The more that technology is used in a wide variety of areas, the more difficult
    it is to deliver exactly what the user needs. Maybe this sentence sounds weird
    to you, but you must understand that developers, in general, study how to develop
    software, but they rarely study to deliver the needs of a specific area. Of course,
    it is not easy to learn how to develop software, but it is even more difficult
    to understand a specific need in a specific area. Software development nowadays
    delivers software to all possible types of industries. The question here is *how
    can a developer, whether a software architect or not, evolve enough to deliver
    software in the area they are responsible for?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Gathering software requirements will help you in this tough task; writing them
    will make you understand and organize the architecture of the system. There are
    several ways to minimize the risks of implementing something different from what
    the user really needs:'
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping the interface to achieve an understanding of the user interface
    faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the data flow to detect gaps between the system and the user operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequent meetings to be updated on the user's current needs and aligned to incremental
    deliveries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, as a software architect, you will have to define how the software will
    be implemented. Most of the time, you are not going to be the one who programs
    it, but you will always be the one responsible for this. For this reason, some
    techniques can be useful to avoid the wrong implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements are reviewed with the developers to guarantee that they understand
    what they need to develop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code inspection to validate a predefined code standard. We will cover this in
    *Chapter 19*, *Using Tools to Write Better Code*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meetings to eliminate impediments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, the implementation matching the user needs is your responsibility.
    Use every tool you can to meet it.
  prefs: []
  type: TYPE_NORMAL
- en: Case 3 – the usability of the system does not meet user needs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usability is a key point for the success of a software project. The way the
    software is presented and how it solves a problem can help the user to decide
    whether they want to use it or not. As a software architect, you must keep in
    mind that delivering software with good usability is mandatory nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: There are basic concepts of usability that this book does not intend to cover,
    but a good way to meet the correct user needs when it comes to usability is by
    understanding who is going to use the software. Design Thinking can help you a
    lot with that, as was discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the user will help you to decide whether the software is going
    to run on a web page, or a cell phone, or even in the background. This understanding
    is very important to a software architect because the elements of a system will
    be better presented if you correctly map who will use them.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you do not care about that, you will just deliver software
    that works. This can be good for a short time, but it will not exactly meet the
    real needs that made a person ask you to architect the software. You must keep
    in mind the options and understand that good software is designed to run on many
    platforms and devices.
  prefs: []
  type: TYPE_NORMAL
- en: You will be happy to know that .NET 5 is an incredible cross-platform option
    for that. So, you can develop solutions to run your apps in Linux, Windows, Android,
    and iOS. You can run your applications on big screens, tablets, cell phones, and
    even drones! You can embed apps on boards for automation or in HoloLens for mixed
    reality. Software architects must be open-minded to design exactly what their
    users need.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – introducing World Wild Travel Club
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, the case study of this book
    will take you on a journey of creating the software architecture for a travel
    agency called **World Wild Travel Club** (**WWTravelClub**).
  prefs: []
  type: TYPE_NORMAL
- en: WWTravelClub is a travel agency that was created to change the way people make
    decisions about their vacations and other trips around the world. To do so, they
    are developing an online service where every detail of a trip experience will
    be assisted by a club of experts specifically selected for each destination.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of this platform is that you can be both a visitor and a destination
    expert at the same time. The more you participate as an expert in a destination,
    the higher the points you will score. These points can be exchanged for tickets
    that people buy online using the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The customer came with the following requirements for the platform. It is important
    to know that, in general, customers do not bring the requirements ready for development.
    That is why the requirements gathering process is so important:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common user view:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promotional packages on the home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Details for each package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buy a package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Buy a package with a club of experts included:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment on your experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask an expert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate an expert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register as a common user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Destination expert view:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same view as the common user view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer the questions asking for your destination expertise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manage the points you scored answering questions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchange points for tickets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Administrator view:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage common users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage destination experts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To finish this, it is important to note that WWTravelClub intends to have more
    than 100 destination experts per package and will offer around 1,000 different
    packages all over the world.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding user needs and system requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To summarize the user needs of WWTravelClub, you can read the following user
    stories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`US_001`: As a common user, I want to view promotional packages on the home
    page, so that I can easily find my next vacation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_002`: As a common user, I want to search for packages I cannot find on
    the home page so that I can explore other trip opportunities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_003`: As a common user, I want to see the details of a package, so that
    I can decide which package to buy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_004`: As a common user, I want to register myself, so that I can start
    buying the package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_005`: As a registered user, I want to process the payment, so that I can
    buy a package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_006`: As a registered user, I want to buy a package with an expert recommendation
    included, so that I can have an exclusive trip experience'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_007`: As a registered user, I want to ask for an expert, so that I find
    out the best things I can do on my trip'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_008`: As a registered user, I want to comment on my experience, so that
    I can give feedback from my trip'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_009`: As a registered user, I want to evaluate an expert who helps me,
    so that I can share with others how fantastic they were'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_010`: As a registered user, I want to register as a destination expert
    view, so that I can help people who travel to my city'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_011`: As an expert user, I want to answer questions about my city, so that
    I can score points to be exchanged in the future'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_012`: As an expert user, I want to exchange points for tickets, so that
    I can travel around the world more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_013`: As an administrator user, I want to manage packages, so that users
    can have fantastic opportunities to travel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_014`: As an administrator user, I want to manage registered users, so that
    WWTravelClub can guarantee good service quality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_015`: As an administrator user, I want to manage expert users, so that
    all of the questions regarding our destinations are answered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_016`: As an administrator user, I want to offer more than 1,000 packages
    around the world, so that different countries can experience the WWTravelClub
    service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_017`: As the CEO, I want to have more than 1,000 users simultaneously accessing
    the website, so that the business can scale effectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_018`: As a user, I want to access WWTravelClub in my native language, so
    that I can easily understand the package offered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_019`: As a user, I want to access WWTravelClub in the Chrome, Firefox,
    and Edge web browsers, so that I can use the web browser of my preference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`US_020`: As a user, I want to know my credit card information is stored securely,
    so I can buy packages safely'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that while you start writing the stories, information related to non-functional
    requirements such as security, environment, performance, and scalability can be
    included.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, some system requirements may be omitted when you write user stories
    and need to be included in the software specification. These requirements can
    be related to legal aspects, hardware, and software prerequisites, or even points
    of attention for the correct system delivery. They need to be mapped and listed
    as well as user stories. The WWTravelClub system requirements are presented in
    the following list. Notice that requirements are written in the future because
    the system does not exist yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SR_001`: The system shall use Microsoft Azure components to deliver the scalability
    required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_002`: The system shall respect **General Data Protection Regulation** (**GDPR**)
    requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_003`: The system shall run on the Windows, Linux, iOS, and Android platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_004`: Any web page of this system shall respond in at least 2 seconds with
    a 1,000-user concurrently access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of having this list of user stories and system requirements is to help
    you understand how complex the development of a platform might be if you think
    about it from an architectural perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the purpose of a software architect in a software
    development team. Also, this chapter covered the basics of software development
    process models and the requirements gathering process. You also had the opportunity
    to learn about how to create your Azure account, which will be used during the
    case study of this book, which was presented to you in the previous section. Moreover,
    you even learned about functional and non-functional requirements and how to create
    them using user stories. These techniques will help you deliver a better software
    project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will have the opportunity to understand how important
    functional and non-functional requirements are for software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the expertise that a software architect needs to have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can Azure help a software architect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a software architect decide the best software development process model
    to use in a project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a software architect contribute to gathering requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of requirements does a software architect need to check in a requirement
    specification?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do Design Thinking and Design Sprint help a software architect in the process
    of gathering requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do user stories help a software architect in the process of writing requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are good techniques to develop very good performance software?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a software architect check whether a user requirement is correctly
    implemented?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, you have some books and links you may consider reading to gather more
    information about this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Azure information, check these out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/overview/what-is-azure/](https://azure.microsoft.com/en-us/overview/what-is-azure/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.microsoft.com/en-us/hololens](https://www.microsoft.com/en-us/hololens)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://azurecharts.com/](https://azurecharts.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET 5 information can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/](https://docs.microsoft.com/en-us/dotnet/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/](https://docs.microsoft.com/en-us/aspnet/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core](https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices](https://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Software development process model links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://agilemanifesto.org/](https://agilemanifesto.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.amazon.com/Software-Engineering-10th-Ian-Sommerville/dp/0133943038](https://www.amazon.com/Software-Engineering-10th-Ian-Sommerville/dp/0133943038)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.amazon.com/Software-Engineering-Practitioners-Roger-Pressman/dp/0078022126/](https://www.amazon.com/Software-Engineering-Practitioners-Roger-Pressman/dp/0078022126/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://scrumguides.org/](https://scrumguides.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/professional-scrummasters-handbook](https://www.packtpub.com/application-development/professional-scrummasters-handbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Incremental_build_model](https://en.wikipedia.org/wiki/Incremental_build_model)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Waterfall_model](https://en.wikipedia.org/wiki/Waterfall_model)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.extremeprogramming.org/](http://www.extremeprogramming.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.gv.com/sprint/](https://www.gv.com/sprint/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
