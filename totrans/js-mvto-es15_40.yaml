- en: Chapter 12. New Features of Angular 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 1 was based on the MVC architecture whereas Angular 2 is based on a
    components-and-services architecture. Angular 1 and Angular 2 are completely different
    in terms of architecture and APIs, so previous knowledge of Angular 1 is unlikely
    to help you much in learning Angular 2\. In this chapter, we will learn Angular
    2 without comparing it with Angular 1 as doing that will create confusion and
    is unnecessary. Even if you don't have knowledge about Angular 1, you can continue
    with this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Web components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Angular 2 architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component inputs and outputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component life cycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And much more...
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The Angular 2 architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 2 is a framework for building the client side of web applications, based
    on a services-and-components architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: An Angular 2 application is composed of a view and various services. Services
    are simple JavaScript objects that hold application logic and state. Services
    should be reusable. Views consume services, and services can also interact with
    each other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Views and services are loosely coupled so that an Angular 2 view can be used
    with any other architecture, such as Flux. Similarly, services can be used with
    any other view, such as React.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 views are based on component-oriented architecture. In component-oriented
    architecture, the application UI is divided into reusable components. A component
    has a UI with code to update the UI and handle user actions on the UI. A custom
    tag is associated with a component, and whenever the custom tag appears, a new
    instance of the component is created and rendered. So, we can say that component-oriented
    architecture is architecture for the view of an application. Actually, the components
    consume the services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous two chapters, we studied React, which is also based on component-oriented
    architecture, since with React, we build an application as a set of components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram from the official Angular 2 website ([https://angular.io](https://angular.io))
    that shows the complete architecture of Angular 2:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![The Angular 2 architecture](img/00151.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that the UI of a **Component** is defined using a **Template**.
    Templates are written using template HTML, that is, a combination of HTML and
    many other tokens. A component also holds the UI state and event handlers of the
    UI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn't store application logic and state inside a component, as it will
    have an impact on code reusability and cause issues while developing large and
    complex apps. Application state and logic should be stored in services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 only implements one-way data binding. This makes large and complex
    apps easier to debug.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Services are injected into specific components that need them, and not all the
    components.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Introducing web components
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into web components, you need to know why we are learning about
    them. Well, we are learning about web components because Angular 2 components
    utilize shadow DOM and templates, which are a part of web components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, web components are a collection of four different browser specifications
    that enable the creation of reusable components in web pages. These four specifications
    are **HTML imports**, **shadow DOM**, **templates**, and **custom elements**.
    They can be used together or separately.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Web components provide native implementation of component-oriented architecture.
    A component created using web components is called a web component as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Before we learn about web components, let's consider a project for demonstration
    purposes. Create a directory named `web-components`, and then create a file named
    `index.html` in it. Web components have pretty poor browser support, so let's
    download `webcomponents.js polyfill`. Download the `webcomponents.js` file from
    [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)
    and place it in the `web-components` directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, place this code in the `index.html` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's now look at an overview of shadow DOM, templates, and custom elements
    by building a component to display a card that has an image, title, and description.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Templates** are used to define reusable code. A template is defined using
    the `<template>` tag. Code for the template is placed inside this tag. We can
    place any tag, such as `<script>` and `<style>`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The code inside the `<template>` tag is only parsed, not rendered.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to create a template. Place this code in the `body`
    tag:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the template holds the UI code for the card component. Now, if you open
    the `index.html` file in a browser, you won't see anything because the `<template>`
    tag is only parsed, not rendered.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Custom elements
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Custom elements** let us define new types of HTML elements (that is, new
    types of HTML tags). When we use a tag name that''s not recognized by the browser,
    the browser simply treats it like a `<span>` tag. But when we register a `custom`
    tag, it gets recognized by the browser. It can inherit other elements, lets us
    perform different operations on different stages of the element lifecycle, and
    much more.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a `custom` element for our component. Wherever the tag appears,
    a new instance of the component will be displayed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to display the `custom` element. Place it in the `<body>`
    tag:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have to use the `-` character in the custom element name. This is compulsory
    because this restriction allows the parser to distinguish custom elements from
    regular elements and ensures forward compatibility when new tags are added to
    HTML. Here, we are passing properties of the component as data attributes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define `<custom-card>` as a custom element and place the template
    code inside the tag whenever a new instance of `<custom-card>` is created. To
    do that, place this code in the `<script>` tag:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is how the code works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: By default, custom elements inherit methods and properties of `HTMLElement`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To register a custom element, we need to use the `document.registerElement`
    method. The first argument is the custom tag name and the second argument is an
    optional object. This optional object can take a property called **prototype**.
    The `prototype` property defines the HTML element it inherits, that is, the properties
    and methods of the HTML element it inherits. By default, it's assigned to `Object.create(HTMLElement.prototype)`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also add new properties and methods to our custom element by adding new
    properties and methods to the object assigned to the `prototype` property.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we've added a method called `createdCallback`, which is invoked whenever
    an instance of a custom element is created, that is, either an instance created
    using JavaScript or HTML.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside `createdCallback`, we are retrieving our template and setting the image
    source, title, and description and then appending it to the custom element by
    creating a clone of it, as many custom elements will share the same template.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if you open `index.html` in a browser, you will see this output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom elements](img/00152.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Shadow DOM
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Shadow DOM** allows HTML elements to get a new kind of node called a shadow
    root associated with them. An element that has a shadow root associated with it
    is called a shadow host. The content of a shadow host isn''t rendered; the content
    of the shadow root is rendered instead. A shadow root can have another shadow
    root below it.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of shadow DOM is that CSS styles defined inside a shadow root won't
    affect its parent document, and CSS styles defined outside the shadow root will
    not affect the elements inside the shadow root. This is useful to define styles
    specific to the components. In short, we can say that shadow DOM provides style
    encapsulation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Style encapsulation is not the only benefit of shadow DOM. The HTML inside the
    shadow root is protected from accidental modification from JavaScript. We can
    still inspect the shadow root in browser developer tools.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Many native element, such as `<video>` and `<audio>`, have a shadow root, but
    when you inspect it, you won't see the shadow root. Browsers by default hide the
    shadow roots of these elements. To see their shadow roots, you need to change
    browser-specific settings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the previous custom element code to render the template inside
    shadow DOM. Replace the previous `createdCallback` method with this one:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, instead of appending the template code directly to the custom element,
    we created a shadow root using `createShadowRoot` and appended the template code
    to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Angular 2 project
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 2 code can be written in JavaScript, TypeScript, or Dart. In case you
    are writing Angular 2 code in TypeScript or Dart, you will need to transpile the
    code to JavaScript before serving to the client. We will use JavaScript to write
    Angular 2 code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `angular2-demo`. Then, inside the directory, create
    the `app.js` and `package.json` files. Then, create a directory named `public`,
    and inside the directory, create four more directories named `html`, `js`, `componentTemplates`,
    and `componentStyles`. Now, create a file named `index.html` and place it in the
    `html` directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Then, download `angular2-polyfills.js`, `Rx.umd.js`, and `angular2-all.umd.js`
    from [https://cdnjs.com/libraries/angular.js/](https://cdnjs.com/libraries/angular.js/)
    and place them in the `angular2-demo/js` directory. These files are what they
    sound like. You can also enqueue the CDN links directly if you want to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `index.html` file, place this starting code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the `app.js` file, place this code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the server-side code. It's self-explanatory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `package.json` file, place this code and run `npm install` to download
    the `express` package:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To start the server, run `node app.js`. Then, open the app using `localhost:8080`
    as the address in a browser.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 fundamentals
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Angular 2 application is completely split into components. Technically, an
    Angular 2 component is a reusable `custom` tag that is mutable and encapsulated
    with an embedded state, that is, changes to the state or properties will mutate
    the UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that Angular 2 doesn't register the custom tag name as a custom element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: All the components of the application are arranged in a tree structure, with
    a component as the root node.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to create a component. It creates a card component
    that displays an image, title, and description. Place this code in the `<script>`
    tag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, create a file named `card-template.html`, and place it in the `componentTemplates`
    directory. Place this code in the file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that, create a file named `card-style.css` and place it in the `componentStyles`
    directory. Place this code in the file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is how these three code snippets work:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: A component needs to be created by chaining `Component` and `Class` methods
    that belong to an `ng.core` object.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Component` method takes a configuration object with various properties,
    whereas the `Class` method takes an object with component lifecycle methods, constructors,
    and UI action handlers.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the configuration properties we've provided are `selector`, `inputs`,
    `templateUrl`, and `styleUrls`. The `selector` property is used to define the
    custom tag for the component. The `inputs` property is used to define the attributes
    that the custom tag takes. The `templateUrl` property is used to define the file
    containing the template of the component. You can also use `template` if you want
    to inline the template code. Finally, `styleUrls` is used to define the CSS files
    containing the style for the component. You can also use the `styles` property
    to inline CSS code, or you can define CSS using a `<style>` tag inside the template
    itself. CSS defined in any of these three ways won't affect other components,
    that is, it's encapsulated to the component itself.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们提供的配置属性是`selector`、`inputs`、`templateUrl`和`styleUrls`。`selector`属性用于定义组件的自定义标签。`inputs`属性用于定义自定义标签所需的属性。`templateUrl`属性用于定义包含组件模板的文件。如果要内联模板代码，也可以使用`template`。最后，`styleUrls`用于定义包含组件样式的CSS文件。您还可以使用`styles`属性来内联CSS代码，或者可以在模板本身内部使用`<style>`标签来定义CSS。以这三种方式定义的CSS不会影响其他组件，即它是封装在组件本身的。
- en: In the `Class` method, we will have to provide the `constructor` method even
    if it does nothing. It's invoked during the construction of a new instance of
    the component. By construction of the component, I mean the construction of the
    component in memory—not resolving attributes, resolving its children, rendering
    its view, and so on. The primary use of the `constructor` method is to inject
    services into the component. Services cannot be injected automatically as we may
    sometimes need to initialize services for every component, and Angular is unaware
    of how to do this. The `constructor` method has access to the state of the component
    but not its properties. Here, we shouldn't do any heavy work or something else
    that would slow down or cause the construction of the component to fail. `constructor`
    is not a component lifecycle method.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Class`方法中，即使它什么也不做，我们也必须提供`constructor`方法。它在构建组件的新实例时被调用。构建组件时，我指的是在内存中构建组件，而不是解析属性、解析其子级、渲染其视图等等。`constructor`方法的主要用途是将服务注入到组件中。服务不能自动注入，因为有时我们可能需要为每个组件初始化服务，而Angular不知道如何做到这一点。`constructor`方法可以访问组件的状态，但不能访问其属性。在这里，我们不应该做任何繁重的工作或其他可能导致组件构建失败或变慢的事情。`constructor`不是组件的生命周期方法。
- en: Then, we have the component template code. In this template file, we are simply
    rendering the properties passed to the component. To render anything that's in
    the component state, we need to use the `{{}}` token.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有组件模板代码。在这个模板文件中，我们只是渲染传递给组件的属性。要渲染组件状态中的任何内容，我们需要使用`{{}}`标记。
- en: Let's create another component called `Cards`, which displays a list of cards.
    It gets information about cards from a service.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`Cards`的组件，它显示一个卡片列表。它从一个服务中获取有关卡片的信息。
- en: 'Place this code in the `<script>` tag of the `index.html` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入`index.html`文件的`<script>`标签中：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, create a file named `cards-template.html` in the `componentTemplates`
    directory and place this code in it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`componentTemplates`目录中创建一个名为`cards-template.html`的文件，并将以下代码放入其中：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, create a file named `app-template.html` in the `componentTemplates` directory
    and place this code in it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`componentTemplates`目录中创建一个名为`app-template.html`的文件，并将以下代码放入其中：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, in the `<body>` tag of the `index.html` file, place this code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`index.html`文件的`<body>`标签中放入以下代码：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is how these four code snippets work:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个代码片段的工作方式如下：
- en: To create a service, we need to use the `ng.core.Class` method. It takes an
    object with the `constructor` method and other methods or properties that the
    service exposes. While injecting the service into other services or components,
    a new instance of the service is created and injected. While creating a new instance
    of a service, the `constructor` method is called. We have to provide this method
    even if it doesn't do anything. The primary purpose of this method is to inject
    services that this service depends on. Here, our `CardsService` method is not
    dependent on any other service, so we have no code inside the `constructor` method.
    Then, we defined a `getCards` method, which returns data of three different cards
    to display.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个服务，我们需要使用`ng.core.Class`方法。它接受一个带有`constructor`方法和其他方法或属性的对象，该服务公开。在将服务注入到其他服务或组件时，将创建并注入服务的新实例。在创建服务的新实例时，将调用`constructor`方法。即使`constructor`方法什么也不做，我们也必须提供这个方法。这个方法的主要目的是注入此服务所依赖的服务。在这里，我们的`CardsService`方法不依赖于任何其他服务，所以我们在`constructor`方法中没有任何代码。然后，我们定义了一个`getCards`方法，它返回三张不同卡片的数据以显示。
- en: Then, we created a `Cards` component. It takes the data from `CardsService`
    and renders a `Card` component for each card data. While creating the `Cards`
    component, we provide `viewProviders` and `directives` properties to the configuration
    object. `viewProviders` is the list of services the component is dependent on,
    and `directives` is the list of other components this component renders. Here,
    you can see that instead of directly assigning a function to the `constructor`
    property, we are assigning an array with a list of services the component depends
    upon and the last array item as the actual function. This is the format of injecting
    services into components. Inside the `constructor` method, we store references
    to the methods or properties of the service that the component needs, that is,
    we can use services inside the `constructor` method. We will learn more about
    `viewProviders` later on. The `this` keyword in any of the methods passed to the
    `Class` method points to the state of the component. After a component instance
    has been created, whenever the component state changes, the template bindings
    are updated. We have another method here, called `ngOnInit`. It's a lifecycle
    method that's invoked after a new instance of the component has been created and
    its attributes resolved. Inside this, we call the `getCards` method and store
    the returned value inside the `cards` property of the state. Note that the attributes
    passed to a component tag are accessible using the `this` keyword after the component
    instance has been created.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the template of `CardsComponent`, we are using the `*ngFor` directive
    to display the cards. We will learn more about directives later.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create an `App` component, which acts as the root of our component.
    Inside this component, we are displaying the `Cards` component.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we initialize the application. An Angular 2 application is initialized
    explicitly. While initializing it, we need to provide a reference to the root
    component. This is done to ensure that applications are composed of nested components
    all the way down. The root component is the one that's added to the `<body>` tag.
    Adding tags of other components to the body tag will not do anything.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, if you refresh your `localhost:8080` page in your browser, you will see
    this output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular 2 fundamentals](img/00153.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Styling components and shadow DOM
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we saw that there are three ways of defining styles specific to components
    (styles encapsulated in the component template scope). A component's CSS doesn't
    even affect the components it owns.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 doesn't use shadow DOM by default; instead, it uses a different technique
    to achieve style encapsulation. This is due to the lack of browser support.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Angular 2 modifies the CSS selector in such a way that it only
    targets the elements in the component, and it then places the CSS in the `<head>`
    tag of the page. If you inspect our current app using browser developer tools,
    you will see this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling components and shadow DOM](img/00154.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that the CSS has been modified and inserted into the `<head>`
    tag.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: To force Angular 2 to use shadow DOM, we need to assign the encapsulation property
    of the component configuration object to `ng.core.ViewEncapsulation.Native`. By
    default, it's assigned to `ng.core.ViewEncapsulation.Emulated`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'When you inspect the app after assigning the encapsulation property of the
    `Card` and `Cards` components to `ng.core.ViewEncapsulation.Native`, you will
    see something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling components and shadow DOM](img/00155.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that shadow DOM was used to achieve style encapsulation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you don't want style encapsulation for a component, you can assign the
    encapsulation property to `ng.core.ViewEncapsulation.None`. In this case, all
    of the CSS will be placed directly in the `<head>` tag.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 change detection
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Change detection** is the process of detecting component state change. The
    state of a component is stored and manipulated using the `this` keyword. Therefore,
    there is no direct way for Angular 2 to detect when the state changes. So, Angular
    2 uses complex algorithms and third-party libraries to detect state changes.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The first thing Angular 2 does for detecting state changes is that it pretends
    that all the changes happen asynchronously. Then, it uses the `zone.js` library
    to monitor browser events, timers, AJAX requests, WebSockets, and other asynchronous
    things that are supported by `zone.js`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever any of these asynchronous activities takes place, it checks everything
    that could change, including object properties and array elements of the `this`
    keyword of all the components from the root node; if any change is detected, then
    the template bindings of the component are updated. Angular 2 doesn't simply re-render
    the whole component. Instead, it checks for the bindings that have changed and
    selects and updates them specifically.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Some components can have a lot of state data, and checking the state for every
    asynchronous operation will unnecessarily impact app performance if their state
    has not changed. Therefore, Angular 2 provides an option to mark such kinds of
    components so that it does not check their states unless the component itself
    tells Angular 2 to check its state during the next detection cycle, that is, when
    the next asynchronous activity occurs. Let's look at an example to demonstrate
    this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this code above the `App` component code in the `<script>` tag of the
    `index.html` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add `SampleComponent1` to the `directives` array of the `App` component.
    So now, the `App` component''s code should be this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, add this code to the end of the `app-template.html` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is how these three code snippets work:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are displaying a value that gets incremented every 2 seconds
    and the template is re-rendered to display the updated value.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At first, we create a component called `SampleComponent1`. It simply displays
    `value`. We have set the `changeDetection` property to `ng.core.ChangeDetectionStrategy.Detached`,
    which tells Angular 2 to not check its state change. By default, the `changeDetection`
    property is assigned to `ng.core.ChangeDetectionStrategy.Default`, which tells
    Angular 2 to check its state change during every change-detection cycle. We then
    inject the `ng.core.ChangeDetectorRef` service into the component, which provides
    various APIs related to change detection. And then, in the `ngOnInit` method,
    we increment the value of `value` every 2 seconds, after which we call the `markForCheck`
    method of `ng.core.ChangeDetectorRef`, which tells Angular 2 to check for changes
    in the state of the component during the next change-detection cycle. `markForCheck`
    will make Angular 2 check for a change in state for the next detection cycle only,
    not for the ones after that.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we simply display `SampleComponent1` in the `App` component.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a component depends only on its inputs and/or UI events or if you want a
    component's state change, check only whether its inputs have changed or events
    have been fired; then, you can assign `changeDetection` to `ng.core.ChangeDetectionStrategy.OnPush`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If at any time you want to force a change-detection cycle instead of waiting
    for an asynchronous operation to happen, you can call the `detectChanges` method
    of the `ng.core.ChangeDetectorRef` service.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Understanding view children and content children
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elements present inside the tags of a component are called **content children**,
    and elements present inside the template of a component are called **view children**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: To display the content children of a component in the component's view, we need
    to use the `<ng-content>` tag. Let's look at an example of this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this code above the `App` component''s code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, change the `App` component''s code to this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To the end of the `app-template.html` file, add this code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of this code is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding view children and content children](img/00156.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'This is how these three code snippets work:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: In the `App` component's template file, we add a `<list>` tag, which displays
    a list. And inside its opening and closing tags, we define the individual list
    items that it should display.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create `ListItem` and `List` components that are bound to `<list>` and `<item>`
    tags, respectively.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `List` component to the `directives` property of the `App` component,
    not `List`, because the `<list>` tag is present in the template of the `App` component,
    and the `App` component is responsible for creating its instances.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `App` component looks for the `<ng-content>` tag in the template of the
    `List` component and renders the `List` component instances there.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<ng-content>` takes an optional `select` attribute that''s assigned to a CSS
    selector that indicates which elements of the content children we want to display.
    There can be multiple `<ng-content>` tags in a template. If the `select` attribute
    has not been provided, then all the content children will be rendered. Here, the
    `select` attribute is not required; we are using it just for demonstration.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the reference of components of content children and view children
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get access to the reference of components of view children or content children,
    we can use the `ng.core.ContentChildren`, `ng.coreViewChildren`, `ng.core.ContentChild`,
    and `ng.core.ViewChild` constructors. The difference between `ng.core.ContentChildren`
    and `ng.core.ContentChild` is that the first one returns all the references of
    a given component whereas the second one returns the reference of the first occurrence.
    The same difference also stands for `ng.core.ViewChild` and `ng.core.ViewChildren`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `ng.core.ContentChildren`. Replace the code
    for the `List` component with this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of this code in the console is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Most of this code is self-explanatory. What's new is the `ngAfterContentInit`
    lifecycle method. It's triggered after the content children have been initialized.
    Similarly, if we want to access the view children, we need to use the `ngAfterViewInit`
    lifecycle method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Note that we only have access to the state of the components—nothing else.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Local template variables
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can assign a local template variable to a content child or view child. Local
    template variables let us get the reference of any element of the content children
    or view children, that is, component references or HTML element references.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: To assign a local template variable to an element of the view children or content
    children, we need to place `#variable_name` in the opening tag.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how local template variables work. Place
    this code above the `App` component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change the `App` component''s code to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then, add this code to the end of the `app-template.html` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of this code is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Local template variables](img/00157.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Here is how these three code snippets work:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We create a new component named `SampleComponent2`, which displays an HTML input
    text element. We assign the input element to a local template variable named `input`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the `ng.core.ViewChild` to get a reference to the element. If we
    pass a string to `ng.core.ViewChild`, `ng.core.ViewChildren`, `ng.core.ContentChild`,
    and `ng.core.ContentChildren`, then they will look for the elements with the same
    local variable name as the string, and if we pass a component, they will look
    for the component, like we saw before.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reference of the components we get from the local template variable is of
    the same interface we got before. But for HTML element references, we can access
    the real DOM of the element by using the `nativeElement` property.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Component lifecycle methods
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a `component` tag appears, Angular 2 creates an instance of a component,
    renders it, checks for changes in attributes, checks for changes in state, and
    destroys it when it's no longer needed. These steps together form the lifecycle
    of a component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 lets us register methods that are called at various stages of the
    component lifecycle.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the various lifecycle methods provided by Angular 2; lifecycle hooks
    are explained in the order they occur:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnChanges`: This is invoked whenever the attributes of a component change.
    It''s also invoked after the attributes of a component are resolved for the first
    time after the creation of a new instance of the component. It''s invoked after
    the state has been changed due to the attributes but before the view is updated.
    This method receives the current and previous values of the attributes.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnInit`: This is invoked after the first instance of `ngOnChanges`. It states
    that the component has been successfully created and attributes have been read.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngDoCheck`: This is called during every change-detection cycle and right after
    `ngOnInit`. We can detect and act upon changes that Angular 2 can''t or won''t
    detect on its own. This is invoked after Angular 2 is done checking state changes
    for the component and has updated the state if there was any change in the attributes
    but before the component view is updated. After this call is over, the view is
    rendered, and while rendering it, `ngAfterContentInit`, `ngAfterContentChecked`,
    `ngAfterViewInit`, and `ngAfterViewChecked` are invoked.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterContentInit`: This is invoked after content children have been initialized
    but not yet rendered, that is, after the `ngOnChanges`, `ngOnInit`, `ngDoCheck`,
    `ngAfterContentInit`, and `ngAfterContentChecked` methods of the content children
    have been called.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterContentChecked`: This is invoked whenever the change-detection cycle
    checks whether the content children have changed as well as right after `ngAfterContentInit`.
    If there is a change, it''s invoked before the views of the content children are
    updated. Before invoking it, the query results of `ng.core.ViewChildren`, `ng.core.ContentChildren`,
    and so on are updated, that is, it''s invoked after `ngAfterContentChecked` of
    the content children has been invoked. After this call, the content children views
    are updated.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterViewInit`: This is invoked after view children have been initialized
    but not yet rendered, that is, after the `ngOnChanges`, `ngOnInit`, `ngDoCheck`,
    `ngAfterContentInit`, `ngAfterContentChecked`, `ngAfterViewInit`, and `ngAfterViewChecked`
    methods of the view children have been called.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterViewChecked`: This is invoked whenever the change-detection cycle checks
    whether the view children have changed as well as right after `ngAfterViewInit`.
    If there is a change, it''s invoked before the views of the view children are
    updated but after the `ngAfterViewChecked` methods of the view children have been
    invoked.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnDestroy`: This is invoked before a component is destroyed. The `ngOnDestroy`
    method of a component is invoked before the `ngOnDestroy` methods of its content
    children and view children.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing templates
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to use template language to write component templates. Template language
    is composed of HTML along with the `{}`, `[]`, `()`, `[()]`, `*`, `|`, and `#`
    tokens. Let's see what each of these is used for and how to use them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a value
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simply render a property of the `this` keyword, we need to use the `{{}}`
    token. Inside these braces, we can simply place the property name.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'We can only place expressions inside braces. The expressions we place inside
    them look like JavaScript. But there are a few JavaScript expressions that we
    are not allowed to use inside these braces. Here they are:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Assignments (`=`, `+=`, `-=`)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `new` operator
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining expressions with `;` or `,`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment and decrement operators (`++` and `--`)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bitwise operators `|` and `&`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also place `pipes` in braces. A pipe is a function that accepts an input
    value and returns a transformed value. A pipe is represented by the `|` operator.
    The final result of expressions inside braces can be transformed using pipes.
    There can be as many pipes in the braces as we want. A pipe can also take parameters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular 2 provides some built-in pipes: `date`, `uppercase`, `lowercase`, `currency`,
    and `percent`. We can also create our own pipes.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `{{}}`. Place this code above the `App` component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Replace the `App` component code with this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then, place this in the `app-template.html` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the code is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipes](img/00158.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the final result of the expression inside the braces is converted
    into a string if the final value is not a string.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle events of elements in a template, we need to use the `()` operator.
    Here is an example of how to handle events. Place this code above the `App` component
    code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Replace the `App` component code with this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Place this code in `app-template.html`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is self-explanatory.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Binding state to element attributes
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bind the value of a property of the `this` keyword to the attribute of an
    element in a template, we can simply use `{{}}`, like this, for example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: But if you want to pass an object, this method will not work, as the expression
    inside the `{{}}` token is always converted to a string. Therefore, Angular 2
    provides the `[]` operator, which enables a component to pass an object through
    attributes to a component in its template.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this. Place this code above the `App` component
    code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Place this code at the end of the `app-template.html` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of this code is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding state to element attributes](img/00159.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that while assigning attributes to an HTML tag, if we assign an attribute
    that's not native to the element, we need to prefix the attribute name using `attr.`.
    For example, to assign a `value` attribute to a `<span>` tag, we need to name
    the attribute `attr.value`, not simply `value`. Otherwise, Angular 2 will throw
    an error. This is because while interpreting a template and creating its DOM,
    Angular 2 sets the attributes by assigning the values to the properties of DOM
    elements. So when we use the `attr.` prefix, it signals Angular 2 to use `setAttribute`
    instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Angular 2 doesn't use two-way data binding. It uses unidirectional
    binding but offers the `[()]` operator for two-way data binding, if needed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `[()]`. Place this code above the `App` component''s
    code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Replace the `App` component code with this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Place this code in the `app-template.html` file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of this code is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way data binding](img/00160.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Here, enter something in the text field and click on the button. You will see
    an alert box with the text field's value.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: To capture the value of HTML form elements, we need to place `ngModel` inside
    the `[()]` brackets. We can place an attribute name if we are setting up two-way
    data binding between inputs and outputs. We will learn more about outputs later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Directives** are used to change the DOM based on the state. There are two
    types of directives: attribute directives and structural directives. Let''s look
    at each of them.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **attribute directive** changes the appearance or behavior of a DOM element
    based on a change in state. `ngClass` and `ngStyle` are the built-in attribute
    directives. We can also create our own attribute directives.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The `ngClass` directive is used to add or remove CSS classes from an element
    whereas the `ngStyle` directive is used to set inline styles.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use the `ngClass` and `ngStyle` directives. Place
    this code above the `App` component''s code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And then, place this code at the end of the `app-template.html` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, if you inspect the `<sampleeight>` tag in browser developer tools, you
    will see this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Attribute directives](img/00161.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: Most of this code is self-explanatory. You can see that the same `[]` token
    is also used for attribute directives. When the `[]` token is used, Angular 2
    first checks to see whether a built-in attribute directive or custom directive
    is present with that name, and if not, it treats it as an attribute.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **structural directive** changes the DOM layout by adding or removing DOM
    elements. `ngIf`, `ngSwitch`, and `ngFor` are the three built-in structural directives.
    We can also create our own custom structural directives.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate `ngIf` and `ngSwitch`. We have already seen
    an example of `ngFor` previously. Place this code above the `App` component''s
    code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a file named `samplecomponent9-template.html`, and place it in the `componentTemplates`
    directory. Place this code in that file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, place this code in the `app-template.html` file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of this code is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Structural directives](img/00162.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: Most of this code is self-explanatory. You can see that we are using the `*`
    token for structural directives. The `*` token treats the element as a template,
    that is, it doesn't render the element but uses it as a template to create the
    DOM.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, both attribute and structural directives are written using the `[]`
    token, but writing code using structural directives with the `[]` token makes
    the code longer. Therefore, Angular 2 introduced the `*` token, which makes it
    easy to write code using structural directives. Internally, Angular 2 translates
    the code that uses the `*` token to use the `[]` token. Learn more about it here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[https://angular.io/docs/ts/latest/guide/template-syntax.html#](https://angular.io/docs/ts/latest/guide/template-syntax.html#)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Outputs** allow components to emit custom events. For example, if we have
    a component that displays a button and we want the parent component to be able
    to add an event handler for the click event of the child component, we can achieve
    this using outputs.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to integrate outputs. Place this code above the `App`
    component''s code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, place this code at the end of the `app-template.html` file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, you will start seeing a counter appear on the page.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The `outputs` property is used to define the events the component emits. We
    need to create a property in this keyword with the same name as the output and
    assign it to a new instance of `ng.core.EventEmitter` so that it can emit events.
    `ng.core.EventEmitter` provides observer patterns to objects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: To capture events, we need to use the `()` token, just like we used it to capture
    native UI events.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we need to assign output to a new instance of `ng.core.EventEmitter`
    inside the constructor property, that is, during the creation of a new instance
    of the component.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding with inputs and outputs
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can implement two-way data binding between inputs and outputs. For example,
    if a parent component passes an attribute to a component of the view children
    and the child component notifies the parent component whenever the input value
    changes, then instead of using `()` and `[]` separately, we can use `[()]`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this. Place this code above the `App` component''s
    code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, add this code to the end of the `app-template.html` file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, the output is same as the previous example. Most of the things are self-explanatory.
    The only thing you need to know is that both these code snippets do the same thing:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Understanding providers
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **provider** tells Angular 2 how to create an instance of a service while
    injecting it. A provider is set using the `providers` or `viewProviders` properties
    of a component.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of how to create providers. Place this code above
    the `App` component''s code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, add this to the end of the `app-template.html` file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is the console output of the code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is how it works:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create four services: `Service1`, `Service2`, `Service3`, and `Service4`.
    They all have a `getValue` method, which returns a string. `Service4` is dependent
    on `Service2` and `Service3`.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create a component called `ServiceTest1`. It's dependent on `Service1`.
    In the `viewProviders` property, we passed an array of providers. A provider is
    created using the `ng.core.provide` method. It takes two arguments; the first
    one is the service name, and the second one is the configuration object, which
    states how to create an instance of this service. The `useClass` property tells
    Angular 2 to create a instance of this service when an instance of the service
    in the first argument is requested. So here, when an instance of `Service1` is
    required, an instance of `Service4` is what is actually created. Similarly, `useValue`
    is used to provide a value, and `useFactory` is used to pass control to a function
    to decide what to return when a new instance is requested. So here, when an instance
    of `Service2` is requested, we get the `def` string, and when `Service3` is requested,
    we get the `mno` string.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Earlier in this chapter, we were simply assigning `viewProviders` to the services
    themselves. A service also implements the interface of a provider such that it
    creates the instance of the service itself.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple providers matching a service, then the latest one overrides
    the previous one.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The difference between providers and the viewProviders property
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `viewProviders` property allows us to make providers available to the component's
    view only, whereas the `providers` property makes a provider available to its
    content children and view children.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'The `providers` property creates a service instance only once and provides
    the same to whichever component asks for it. We have already seen how `viewProviders`
    works. Let''s look at an example of how `providers` works. Place this code above
    the App component''s code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Replace the `App` component''s code with this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, at the end of the `app-template.html` file, place this code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The console output of this code is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Most of the things in this code are self-explanatory. We are using `providers`
    instead of `viewProviders`. The `ServiceTest2` component is dependent on `Service5`,
    but it doesn't have a provider for `Service5`, so Angular 2 uses the provider
    provided by `ServiceTest3`, as `ServiceTest3` is its parent. If `ServiceTest3`
    hadn't had a provider for `Service5`, Angular 2 would have gone further above
    and looked for the provider in the `App` component.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ng.platform.browser.bootstrap` method also takes a second argument, which
    is a list of providers that is available to all the components. So, instead of
    passing providers in the `App` component, we can pass them through the `ng.platform.browser.bootstrap`
    method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Angular 2\. We saw what components are, how
    to write templates, how to create services, and so on. We also learned about web
    components and how Angular 2 takes advantage of them. You should now be comfortable
    with building Angular 2 applications.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to build an SPA using Angular 2 by building
    a complete app.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
