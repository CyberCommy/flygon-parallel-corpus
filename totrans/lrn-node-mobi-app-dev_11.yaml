- en: Chapter 11. Working with Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User management and conditional access in various forms has become almost ubiquitous
    in modern apps, and modern users expect the possibility of logging in with an
    account that they already have or registering and using a new one. Further, they
    expect that the data that they make available under their accounts will remain
    secure and in compliance with the applicable privacy legislation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how we can add security to our Ionic application,
    which meets most of these demands. We will start by explaining how routing between
    views in Ionic works and how we can secure access to individual routes. Finally,
    we will give some pointers to further reading, including advanced authentication
    concepts such as **OAuth**.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of client-side security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start off by briefly discussing some core concepts that are involved
    in securing client applications, such as the apps that we are developing in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side security is a convenience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that you need to know about client-side security is that there
    really is no such thing as client-side security. The app that you deliver to your
    users, whether native or hybrid, is exposed to the possibility of tampering, reverse
    engineering, cracking, and a number of other things that fundamentally compromise
    its integrity. Thus, you can never really trust client applications with the important
    part of security in your app, which is ultimately required to safeguard your users'
    private information and make sure that unauthorized users cannot access data that
    they should not be allowed to access. In particular, this data is private and
    cannot be accessed by other users. In fact, many of the most severe blows in terms
    of security failures of larger companies has been due to user data being compromised
    and leaked en-masse to unauthorized parties.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can provide security that is good enough for the app's intended
    use. For example, even if it will not guarantee complete security, you can still
    attempt to deter less severe privacy invaders from trying to glean personal data
    from an app by using more advanced security measures such as fingerprint scanners
    on some devices, or by using encryption on local data while forcing users to pick
    very strong encryption keys.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that client-side security is not a final measure in safeguarding your
    users' data should of course not deter you from using it. In fact, client-side
    security brings a lot of benefits in terms of how we structure our apps. Importantly,
    it allows us to to create rich user experiences, where the sections of the app
    accessible to the user can be limited based on the users' authentication status.
  prefs: []
  type: TYPE_NORMAL
- en: The basic components of client-side security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While details may vary across different systems and implementations, there
    are some fundamental concepts of client-side security that are in use almost everywhere.
    The following are some of the concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication tokens**: These are data that uniquely identify an authenticated
    user in a system. They are granted by the system itself—or an associated, trusted
    system—in response to the user providing legitimate authentication information
    to the system. For example, this information can be a username-password pair,
    a fingerprint/iris scan, or some other trusted means of authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure local storage**: In order to improve user experience, we most certainly
    do not want to force our users to authenticate themselves every single time they
    use the app. Just imagine a situation where you had to log in again to every single
    account on your device every time you restarted it! In order to work around this,
    we use some kind of secure storage, where the access tokens stored under the previous
    step are preserved. The app itself then simply extracts the token from this storage
    and uses it in order to perform authenticated communication with the server. The
    term secure local storage implies some necessary security measures as regards
    how access tokens are stored and retrieved. This is necessary since a compromised
    access token will allow an unauthorized party to be masked as the legitimate user.
    On most mobile devices, there are native features for storage where security is
    handled by the resident operating system. In other cases, developers can opt to
    use other solutions, such as an encrypted file storage that require some external
    mechanism to unlock the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure communication**: Access tokens can be compromised in storage. Furthermore,
    they are also open to theft while in transit. For example, various types of man-in-the-middle
    attack, where an attacker is masked as a legitimate endpoint for a network connection,
    can be used in order to intercept an access token during a transfer in order to
    steal it and consequently, the user''s access privileges. In most cases, secure
    communication is nothing that you as a developer have to worry about implementing
    manually. Encrypted connections via HTTPS are increasingly becoming the standard
    way of communication across the Internet, and they provide very robust security
    for data over network endpoints. Meanwhile, support for it is present in the network
    stacks of virtually all major operating systems, both for stationary and mobile
    devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a secure app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a better understanding of client-side security and its drawbacks,
    let''s put it into practice by developing an app with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a public home screen that can be seen by everybody who uses the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a private part that shows some personal information about a user, which
    is only accessible to authenticated users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is logic for the authentication of users through a simple log-in form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is logic for the authorization and authentication of users to access the
    otherwise private parts of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the configuration of our basic project structure. If you
    have read the book until this point, this should be second nature to you by now!
    Go to a desired project directory, and from there, just run the following from
    your terminal or command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a basic, blank Ionic app. Let''s add some basic structure
    to it. The first thing that we want to do is add two basic navigation states—home
    and public. Navigate to your app''s `www/js` folder and make sure that `app.js`
    has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set up the essential navigation states for the app, which fortunately
    are very few at this point! However, we still need to add the necessary templates.
    Inside the `www` directory, create a `templates` directory and add the following
    three files to the path `www/templates/menu.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet represents the `home.html` templates at the path
    `www/templates/home.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet represents the `private.html` templates at the path
    `www/templates/private.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all that we need for the basic setup. You can verify it by running
    the following in a terminal or command line in the `root` folder of your directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting off](img/B04653_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A dire warning indeed! Let''s see if we can get around it. If you click on
    the app icon at the top left of the app screen (either for Android or iOS), you
    can bring out the navigation drawer that we created in the `www/templates/menu.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting off](img/B04653_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you select the **Private** link from the list, you would expect the app
    to stop us from accessing information that could potentially put an end to Flipper
    once and for all, but alas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting off](img/B04653_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not good! To remedy this, we will need to find a way to block the user from
    accessing certain content unless they are authenticated and that, even if they
    hack their way into accessing the content, there is no useful data for them to
    find anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: A basic authentication service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in adding basic security to our app is to create an authentication
    service, which can be used in order to carry out authentication requests. We want
    this service to provide the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: It should be able to log a user in. This function should take a username and
    password and, if they match, return an authentication token that the user can
    use in order to verify their identity to the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be able to check whether a user is currently authenticated in the
    app. This will be necessary whenever we wish to check whether a user should have
    access to the system or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and build such a service. Add the `services.js` file in the
    `www/js` folder and insert the following content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a skeleton to work with. Let's start adding some meat to it incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: The login function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of the login function is simply to take a username and password
    and check them against an existing list of such pairs. To get it working, we will
    first need to add some mock data to our service (in real life, you will of course
    pull the data from a remote server).
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and make sure that the `LoginFactory` contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we simply need to add the following to the body of the login function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What we do here in terms of authentication is really quite simple. We only match
    `usernames` and `passwords` against a pre-defined array. If a match is found,
    we cache the matched user and add it to the `factories` context. It will now be
    accessible via the `getCurrent()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The isAuthenticated function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of this function is to allow the system to check whether the current
    user is presently logged in or not. We can simply implement it in terms of whether
    there is a cached user from a successful login event available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The getCurrent function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function is simple, and it simply returns the current cached user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Implementing route authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a working authentication service, let''s use it in order to
    safeguard the world''s dolphins and seal off the private part of our app. To do
    so, first make sure that the `index.html` file correctly imports the new service,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the `app.js` file to import that file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `app.js` file, modify the routing `config` for the private part
    of the app so that it looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What is going on here? To answer this, consider what we want to achieve. If
    the user is not authenticated, we want to send them back to the home screen until
    they have logged in. In order to do so, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We add a resolve hook for the transition to the `app.private` state. In terms
    of the router, this is a function that has to be resolved before the navigation
    commences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this hook, we use the `AuthFactory.isAuthenticated` function that we
    defined earlier. However, for `resolve` to work as expected, the return value
    of the hook needs to be a `promise` method. Thus, we use `$q` to return a when
    resolution if the user is logged in and a reject event if they are not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user is not logged in, we use `$state` in order to tell the router to
    redirect the control to the home page again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, all we need to do is add an actual login screen for the app. To do
    so, start by adding a new file to keep `controllers` for our app at the path `www/js/controllers.js`.
    Make sure that this file has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To render the login screen itself, add a template for to the path `www/templates/login.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s tie everything together by making sure that the app loads our
    newly defined controller. Load it in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make sure that it is listed as a dependency in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are now building our app. You can try it out by running it yourself. Try
    logging in with wrong credentials (according to the ones that we defined) in order
    to convince yourself that the app really blocks the user from going where they
    should not.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you gained a basic understanding of how client-side authentication
    works and what its basic limitations are. You also saw how to create a basic app
    that implements some of the basic concepts to create an app in order to see how
    the app works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to set up web socket communication through
    the app in order to subscribe to dynamic notifications from a server.
  prefs: []
  type: TYPE_NORMAL
