- en: '*Chapter 8*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Data Structures in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a Binary Search Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use enumerations to handle constants better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the logic behind uniqueness in HashSet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous lessons, you learned about various data structures in Java,
    such as lists, sets, and maps. You also learned about how to iterate on the many
    data structures, compare objects in many different ways; and sort these collections
    in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: In this lesson, you will learn the implementation details of advanced data structures
    such as linked lists and binary search trees. As we progress, you'll also learn
    about a powerful concept called enumerations and explore how to use them effectively
    instead of constants. At the end of the lesson, you will gain an understanding
    of the magic and mystery behind `equals()` and `hashCode()`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Custom Linked List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A list has two implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ArrayList**: This is implemented using arrays as the underlying data structure.
    It comes with the same limitations as arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linked List**: Elements in linked lists are distributed across the memory,
    contrary to in an array, where they are contiguous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of ArrayList
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Disadvantages of ArrayList are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Though ArrayList is dynamic and the size need not be mentioned during creation.
    However as the size of arrays is fixed, therefore ArrayLists often need to be
    implicitly resized when more elements are added to the list. Resizing follows
    the procedure of creating a new array and adding all the elements of the previous
    array into a new array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a new element at the end of the ArrayList is often faster than adding
    in between, however, it's expensive when elements are added in between the list,
    because room has to be created for the new elements, and to create room existing
    elements have to shift.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the last element of the ArrayList is often faster, however, it's expensive
    when elements are deleted in between, because the element has to be adjusted,
    shifting elements to the left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of Linked List over Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the advantages of linked lists over arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic sizing, as the size is not fixed, there are no resizing problems. Every
    node holds a reference to the next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and deleting elements at random places within a linked list, is much
    simpler as compared to vectors and arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this topic, you will learn how to build a custom linked list for specific
    purposes. By doing this, we will appreciate the power of linked list and understand
    the implementation details as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagrammatic representation of a linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Representation of a linked list](img/C09581_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Representation of a linked list'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dynamic memory allocation is a popular application of linked lists. Other applications
    of linked lists include implementation of data structures such as stacks, various
    implementations of queues, graphs, trees and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 31: Adding Elements to a Linked list'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a simple linked list that allows us to add integers, and print
    the elements in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class `SimpleIntLinkedList` as follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another class `Node` that represents each element in a linked list.
    Each node will have data (an Integer value) that it needs to hold; and it will
    have a reference to the next `Node`. Implement getters and setter for the data
    and the `next` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `add(Object item)` method so that any item/object can be added
    into this list. Construct a new `Node` object by passing the `newItem = new Node(item)`
    item. Start with the `head` node, and move towards the end of the list, visiting
    each node. In the last node, set the next node as our newly created node (`newItem`).
    Increment the index by invoking `incrementIndex()` to keep track of the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a `toString()` method to represent this object. Starting from the
    `head` node, iterate all the nodes until the last node is found. On each iteration,
    construct a string representation of an Integer stored in each node. The representation
    will look similar to this: `[Input1,Input2,Input3]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Create a member attribute of type `Node` (pointing to the `head` node) for the
    `SimpleIntLinkedList`. In the `main` method, create an object of `SimpleIntLinkedList`
    and add five integers one after the other (13, 39, 41, 93, 98) into it respectively.
    Print the `SimpleIntLinkedList` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 32: Creating a Custom Linked List in Java'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our exercise, we created a Linked list that could take Integer values. As
    an activity, let's create a custom linked list that can take any object into it
    and display all the elements added to the list. Additionally, let's add two more
    methods to get and remove the values from the linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class name `SimpleObjLinkedList` and create a member attribute of type
    Node (pointing to the head node). Add a member attribute of type `int` (pointing
    to the current index or position in a node)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class Node that represents each element in a Linked List. Each node
    will have an object that it needs to hold and it will have the reference to the
    next Node. The `LinkedList` class will have a reference to the head node and will
    be able to traverse to the next Node by using `Node.getNext()`. Because `head`
    is the first element, we could traverse to the next element by moving next in
    the `current` node. Like this, we could traverse till the last element of the
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `add(Object item)` method so that any item/object could be added
    to this list. Construct a new `Node` object by passing the `newItem = new Node(item)`
    item. Starting at the `head` node, crawl to the end of the list. In the last node,
    set the `next` node as our newly created node (`newItem`). Increment the index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `get(Integer index)` method to retrieve the item from the list
    based on the index. Index must not be less than 0\. Write logic to crawl to the
    specified index and identify the node and return the value from the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `remove(Integer index)` method to remove the item from the list
    based on the index. Write logic to crawl to the one node before the specified
    index and identify the node. In this node, set the next as `getNext()`.Return
    true if the element was found and deleted. If element not found, return false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `toString()` method to represent this object. Starting from head
    Node, iterate all the nodes until the last node is found. On each iteration construct
    a string representation of the object stored in each node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `main` method and add create an object of `SimpleObjLinkedList` and
    add five Strings one after the other ("INPUT-1", "INPUT-2", "INPUT-3", "INPUT-4","INPUT-5")
    into it respectively. Print the `SimpleObjLinkedList` object. In the main method,
    get the item from the list using `get(2)` and print the value of the item retrieved,
    also remove the item from the list `remove(2)` and print the value of the list.
    One element should have been deleted from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 356.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of Linked List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The drawbacks of linked lists are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The only way to access elements is starting from the first element, and moving
    sequentially; accessing an element at random is not possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching is slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists require extra space in the memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Binary Search Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already had a brief look at trees in *Lesson 7*, *The Java Collections Framework
    and Generics* let's look at a special implementation of trees known as **binary
    search trees (BSTs)**.
  prefs: []
  type: TYPE_NORMAL
- en: To understand BSTs, let's take a look at what binary tree is. A tree in which
    each node in the tree has at most two child nodes, is a **binary tree**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A BST is a special implementation of a binary tree, where the left-child node
    is always less than or equal to the parent node, and the right-child node is always
    greater than or equal to the parent node. This unique structure of the binary
    search tree makes it easier to add, delete, and search for elements of the tree.
    The following diagram represents a BST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Representation of a binary search tree](img/C09581_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Representation of a binary search tree'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The applications of binary search tree are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To implement a dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement multilevel indexing in a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement a searching algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 32: Creating a Binary Search Tree in Java'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will create a binary search tree and implement left and
    right traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `BinarySearchTree` class with a `Node` class in it. The `Node` class
    should have two elements pointing to its left and right node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will create a `add(int data)` function, which will check whether the parent
    node is empty. If it is empty, it will add the value to the parent node. If the
    parent node has data, we need to create a new `Node(data)` and find the right
    node (according to the BST rule) to attach this new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To help find the right node, a method, `add(Node root, Node newNode)`, has been
    implemented to use the recursive logic to go deeper and find the actual node to
    which this new node should belong.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per BST rules, if the root data is greater than the `newNode` data, then
    `newNode` has to be added to the left Node. Again, recursively check whether it
    has child nodes, and the same logic of BST applies until it reaches the leaf node
    to add a value. If the root data is less than the `newNode` data, `newNode` has
    to be added to the right node. Again, recursively check whether it has child nodes,
    and the same logic of BST applies until it reaches the leaf node to add a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `traverseLeft()` function to traverse and print all the values of
    the BST in the left-hand side of the root node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `traverseRight()` function to traverse and print all the values of
    the BST on the right-hand side of the root node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an example program to test the functionality of the BST:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 33: Implementing the Methods in the BinarySearchTree Class to Find
    the Highest and Lowest Value in the BST'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a method, `getLow()`, that implements a `while` loop to iteratively check
    whether the parent node has any left children, and returns the node with no left
    child in the left BST as the lowest value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method, `getHigh()`, that implements a `while` loop to iteratively
    check if the parent node has any right children, and returns the node with no
    right child in the right BST as the highest value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main` method, add elements to the binary search tree, using the `add`
    method implemented earlier and call the `getLow()` and the `getHigh()` methods
    to identify the highest and the lowest values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 360.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumeration in Java (or enum) is a special type in Java whose fields consist
    of constants. It is used to impose compile-time safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the days of the week, they are a set of fixed constants,
    therefore we can have an enum defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can simply check if a variable that stores a day is part of the declared
    enum. We can also declare enums for non-universal constants, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will enforce the job-type to be the constants declared in the `Jobs` enum.
    Here''s an example enum holding currencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 33: Using Enum to Store Directions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will create an enum and will find values and compare enums.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class `EnumExample` and in the `main` method. Get and print the enum
    using the value as enum. Get and print enum using the values as String:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a enum holding directions with an integer value representing
    the directions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 34: Using an Enum to Hold College Department Details'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's build a full-fledged enum to hold college departments and their numbers
    `(BE ("Bachelor of Engineering", 100))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `DeptEnum` enum using the `enum` keyword. Add two private attributes
    (String `deptName` and int `deptNo`) to hold the values to be kept in the enum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: . Override a constructor to take an acronym and `deptNo` and place it in the
    member variables. Add enum constants adhering to the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add getter methods for `deptName` and `deptNo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s write a `main` method and sample program to demonstrate the use of enums:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 362.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 35: Implementing Reverse Lookup'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write an application that takes in a value of
  prefs: []
  type: TYPE_NORMAL
- en: Create an enum `App`, that declares constants BE, BCOM, BSC and BARC, along
    with their full forms and department numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also declare two private variables `accronym` and `deptNo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a parameterized constructor and assign the variables `accronym` and `deptNo`
    with values passed as arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a public method `getAccronym()` that returns the variable `accronym`
    and a public method `getDeptNo()` that returns the variable `deptNo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement reverse look up that takes in the course name, and searches the corresponding
    acronym in the `App` enum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the main method, and run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your output should be similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 363.
  prefs: []
  type: TYPE_NORMAL
- en: Set and Uniqueness in Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this topic, we are going to learn the logic behind a set that finds the uniqueness
    of an object being added and understand the importance of two object-level methods.
  prefs: []
  type: TYPE_NORMAL
- en: The magic lies in two methods of the `Object` class
  prefs: []
  type: TYPE_NORMAL
- en: '`hashCode()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equals()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Rules for the equals() and hashCode() Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two objects can be identical only when the value returned using the `hashcode()`
    method is identical and the `equal()` method returns true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the two objects return the same `hashCode()` value, it doesn't necessarily
    mean both objects are the same (as hash values may collide with other objects
    as well). In that case, it's necessary to find the equality by calling `equals()`
    and verifying the identity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can't use `hashCode()` alone to find out the equality; we need to use `equals()`
    as well to do this. However, `hashCode()` alone is enough to find the inequality.
    If the `hashCode()` returns different values, it's safe to consider the objects
    different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an Object to a Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Though many things happen when we add an object into a set, we will just look
    at details related to our subject of study:'
  prefs: []
  type: TYPE_NORMAL
- en: The method first calls the `hashCode()` method on that object and gets the `hashCode`,
    then `Set` compares it to the `hashCode` of other objects and checks whether any
    object matches that `hashCode`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If none of the objects in the set match the `hashCode` of the added object,
    then we can be 100% confident that no other object is available with the same
    identity. A newly added object will be added safely to the set (without needing
    to check `equals()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of the objects match the `hashCode` of the object added, it means it
    might be an identical object added (as `hashCode` may be the same for two different
    objects). In this case, to confirm the suspicion, it will use the `equals()` method
    to see if the objects are really equal. If equal, the newly added object will
    not be rejected, else newly added objected will be rejected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 34: Understanding the Behavior of equals() and hashCode()'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a new class and walk through the behavior of `Set` before implementing
    `equals()` and `hashCode()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Student class with three attributes: `Name` (`String`), `Age` (`int`),
    and `Year of passing` (`int`). Also create getters and setters for these private
    members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a sample class, `HashCodeExample`, to demonstrate the set behavior. In
    the main method, create three objects of `Students` with different names and other
    details (Raymonds, Allen, and Maggy):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `HashSet` to hold these students'' objects (`set`). Add the three
    objects, one after the other, to the `HashSet`. Then, print the values in the
    `HashSet`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` method, create another `Student` object resembling one of the
    three objects created (for example: let''s create a student, similar to Allen).
    Add this newly created `Student` object to the `HashSet` in which three students
    have already been `added(set)`. Then, print the values in the `HashSet`. You will
    notice that Allen has been added into the set twice (which means duplicates were
    not handled in the Set):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`Allen` has indeed been added to the set twice (which means duplicates have
    not been handled in the Set yet). It needs to be handled in `Student` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 35: Overriding equals() and hashCode()'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s override `equals()` and `hashCode()` for `Student` and see how the behavior
    of Set changes after this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Students` class, let''s override the `equals()` method by checking
    each attribute of the `Student` object (`name`, `age`, and `yearOfPassing` are
    of equal importance to verify the identity). The `equals()` method in the `Object`
    level takes `Object` as an argument. To override the method, we need to provide
    logic with which we compare the self-attribute (`this`) to the `object o` argument.
    The logic of equality here is that two students are said be identical if, and
    only if, their `name`, `age`, and `yearOfPassing` is the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Student` class, let''s override the `hashCode()` method. The basic
    requirement is it should return the same integer for identical objects. One simple
    way to implement `hashCode` is taking the `hashCode` of each attribute in the
    object and summing it up. The rationale behind this is, if the `name`, `age`,
    or `yearOfPassing` is different, then `hashCode` will return different values,
    and it will be evident that no two objects are the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the main method of `HashCodeExample` to demonstrate the behavior of
    the set after overriding `equals()` and `hashCode()` in the Student object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After adding `hashCode()` and `equals()`, our `HashSet` has the intelligence
    to identify and remove duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't override `equals()` and `hashCode()`, JVM assigns a unique hash
    code value to each object when they are created in memory, and if developers don't
    override the `hashcode` method, then there is no guarantee that the two objects
    return the same hash code value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, we learned what a BST is and the steps to implement the basic
    functionalities of a BST in Java. We also learned a technique to traverse a BST
    to the right and left. We looked at the use of enums over constants and gained
    an understanding of the types of problems they solve. We also built our own enums
    and wrote code to fetch and compare the values of enums.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how `HashSet` is able to identify duplicates and looked at the
    significance of overriding `equals()` and `hashCode()`. Also, we learned how to
    correctly implement `equals()` and `hashCode()`.
  prefs: []
  type: TYPE_NORMAL
