- en: '*Chapter 16*: Kernel Tuning and Managing Performance Profiles with tuned'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described occasionally in previous chapters, each system performance profile
    must be adapted to the expected usage for our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel tuning plays a key role in this optimization, and we will be exploring
    this further in this chapter in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying processes, checking memory usage, and killing processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting kernel scheduling parameters to better manage processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing `tuned` and managing tuning profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom `tuned` profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how kernel tuning is applied, how
    quick profiles can be used via `tuned` to suit general use cases for different
    system roles, and how to further extend those customizations for your servers.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, identifying processes that have become a resource hog and how
    to terminate them and or prioritize them will be a useful way of getting a bit
    more juice out of our hardware when most needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get hands-on and learn about these topics!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can continue the practice of using the **virtual machine** (**VM**) created
    at the beginning of this book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*. Any additional packages required for this chapter will be
    indicated alongside the text.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying processes, checking memory usage, and killing processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A process is a program that runs on our system—it might be a user logged in
    via **Secure Shell** (**SSH**) that has a bash terminal process running, or even
    the portion of the SSH daemon listening and replying to remote connections, or
    it could be a program such as a mail client, a file manager, and so on being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, processes take up resources in our system: memory, **Central Processing
    Unit** (**CPU**), disk, and so on. Identifying or locating ones that might be
    misbehaving is a key task for system administrators.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the basics were already covered in [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059),
    *Tools for Regular Operations*, but it would be a good idea to have a refresher
    on these before continuing; however, we will be showing and using some of those
    tools in the context of performance tuning here, such as—for example—the `top`
    command, which allows us to see processes and sort lists based on CPU usage, memory
    usage, and so on. (Check the output of `man top` for a refresher on how to change
    the sorting criteria.)
  prefs: []
  type: TYPE_NORMAL
- en: One parameter to watch while checking system performance is the load average,
    which is a moving average made by the processes ready to run or waiting for `1`,
    `5`, and `15` minutes—and gives an idea of whether a load is increasing or lowering.
    A rule of thumb is that if a load average is below 1, there is no resource saturation.
  prefs: []
  type: TYPE_NORMAL
- en: The load average is shown with many other tools, such as the aforementioned
    `top`, or with `uptime` or `w`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the system-load average is growing, CPU or memory usage is spiking, and
    if some processes are listed there, it will be easier to locate. If the load average
    is also high and increasing, it might be possible that the I/O operations are
    increasing it. It is possible to install the `iotop` package, which provides the
    `iotop` command to monitor disk activity. When executed, it will show the processes
    in a system and the disk activity: reads, writes, and swaps that might give us
    some more hints about where to look.'
  prefs: []
  type: TYPE_NORMAL
- en: Once a process has been identified as taking too many resources, we can send
    a **signal** to control it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A signal list can be obtained with the `kill –l` command, as illustrated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Available signals to send to processes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – Available signals to send to processes
  prefs: []
  type: TYPE_NORMAL
- en: Note that each signal contains a number and a name—both can be used to send
    the signal to the process via its **process identifier** (**PID**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the most common ones, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_16.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the list shown in *Figure 16.1*, it''s important to know that each signal
    has a `man 7 signal`, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – Listing of signals, number equivalent, disposition (action),
    and behavior (man 7 signal)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.2 – Listing of signals, number equivalent, disposition (action), and
    behavior (man 7 signal)
  prefs: []
  type: TYPE_NORMAL
- en: One of the most typical usages when arriving at this point is to terminate processes
    that are misbehaving, so a combination of locating the process, obtaining the
    PID, and sending a signal to it is a very common task... so common that there
    are even tools that allow you to combine these stages in one command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can compare `ps aux|grep -i chrome|grep –v grep|awk ''{print
    $2}''|xargs kill –9` with `pkill –9 –f chrome`: both will perform the same action,
    search processes named `chrome`, and send signal `9` (kill) to them.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, even a user logging in is a process in the system (running SSH or
    the shell, and more); we can find the processes started by our target user via
    a similar construction (with `ps`, `grep`, and others) or with `pgrep` options
    such as `pgrep –l –u user`.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that, as the signals indicate, it's better to send a `TERM` signal
    to allow the process to run its internal cleanup steps before exiting, as directly
    killing them might result in leftovers in our system.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting command that was widely used before terminal multiplexers such
    as `tmux` or `screen` became commonplace was `nohup`, which was prepended to commands
    that would last longer—for example, downloading a big file. This command captured
    the terminal hangout signal, allowing the process executed to continue execution,
    storing the output in a `nohup.out` file that could later be checked.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to download the latest **Red Hat Enterprise Linux** (**RHEL**)
    **Image Standard Optical** (**ISO**) file from the Customer Portal, select one
    release—for example, 8.4—and once logged in at [https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.4/x86_64/product-software](https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.4/x86_64/product-software),
    we will select the binary ISO and right-click to copy the **Uniform Resource Locator**
    (**URL**) for the download.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The URLs obtained when copying from the **Customer Portal** are timebound, meaning
    they are only valid for a short period of time, and afterward, the download link
    is no longer valid and a new one should be obtained after refreshing the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, we will then execute the following command with the copied URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, `nohup` will not close the processes on terminal
    hang-up (disconnection), so `wget` will continue downloading the URL, and the
    ending ampersand symbol (`&`) detaches the execution from the active terminal,
    leaving it as a background job we can check with the `jobs` command until it has
    finished.
  prefs: []
  type: TYPE_NORMAL
- en: If we forgot to add the ampersand, the program will be blocking our input, but
    we can press *Ctrl* + *Z* on the keyboard and the process will be stopped. However,
    as we really want it to be continuing execution but in the background, we will
    execute `bg`, which will continue the execution of it.
  prefs: []
  type: TYPE_NORMAL
- en: In case we want to bring back the program to receive our input and interact
    with it, we can move it to the foreground with the `fg` command.
  prefs: []
  type: TYPE_NORMAL
- en: If we press *Ctrl* + *C* instead, while the program has our input, it will receive
    a petition to interrupt and stop execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that workflow in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Suspending the process, resuming to the background, bringing
    to the foreground, and aborting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.3 – Suspending the process, resuming to the background, bringing to
    the foreground, and aborting
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're downloading the Fedora 34 installation ISO (8 `nohup` and
    `wget`; as we forgot to add the ampersand, we executed *Ctrl* + *Z* (appearing
    on screen as `^Z`).
  prefs: []
  type: TYPE_NORMAL
- en: The job was reported as job `[1]` with a status of `Stopped` (also reported
    when executing `jobs`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we bring the job to the background execution with `bg`, and now, `jobs`
    reports it as `Running`.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, we bring the job back to the foreground with `fg` and execute *Ctrl*
    + *C*, represented as `^C` on the screen, to finalize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature enables us to run multiple background commands—for example, we
    can copy a file in parallel to several hosts, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Sample for loop to copy a file to several servers with nohup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.4 – Sample for loop to copy a file to several servers with nohup
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the copy operation performed over `scp` will be happening in
    parallel, and, in the event of disconnection from our terminal, the job will continue
    execution and the output will be stored on `nohup.out` files in the folder we
    were executing it from.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Processes launched with `nohup` will not be getting any additional input, so
    in case the program asks for input, it will just stop execution. If the program
    asks for input, it's recommended to use `tmux` instead as it will still protect
    from terminal disconnection but also allow interaction with the launched program.
  prefs: []
  type: TYPE_NORMAL
- en: Not always will we be willing to kill processes or to stop or resume them; we
    may just want to deprioritize or prioritize them—for example, for long-running
    tasks that might not be critical.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about this feature in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting kernel scheduling parameters to better manage processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux kernel is a highly configurable piece of software, so there''s a
    whole world of tunables that can be used for adjusting its behavior: for processes,
    for network cards, for disk, for memory, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: The most common tunables are the `nice` process value and the I/O priority,
    which regulate respectively the prioritization versus other processes of the CPU
    and I/O time.
  prefs: []
  type: TYPE_NORMAL
- en: For interacting with processes we're about to start, we can use `nice` or `ionice`
    commands, prepending the command we want to execute with some parameters (remember
    to check the `man` contents for each one to get the full available range of options).
    Just remember that for `nice`, processes can go from –20 to +19, with 0 being
    the standard one, -20 the highest priority, and 19 the lowest priority (the higher
    the value, the nicer the process is).
  prefs: []
  type: TYPE_NORMAL
- en: Each process has a likelihood of getting kernel attention to run; by changing
    the priority via `nice` before execution or via `renice` once it's running, we
    can alter it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about a long-running process such as performing a backup—we want
    the task to succeed, so we will not be stopping or killing the process, but at
    the same time, we don't want it to alter the production or level of service of
    our server. If we define the process with a `nice` value of 19, this means that
    any process in the system will get more priority—that is, our process will keep
    running but will not make our system busier.
  prefs: []
  type: TYPE_NORMAL
- en: This gets us into an interesting topic—many new users arriving in the Linux
    world, or administrators of other platforms, get a shock when they see that the
    system, with plenty of memory (**random-access memory**, or **RAM**), is using
    swap space, or system load is high. It is clear that some slight usage of swap
    and having lots of free RAM just means that the kernel has optimized the usage
    by swapping out unused memory to disk. As long as the system doesn't feel sluggish,
    having a high load just means that the system has a long queue of processes to
    be executed, but—for example—if the processes are *niced* to 19, they are in the
    queue, but as mentioned, any other process will get ahead of it.
  prefs: []
  type: TYPE_NORMAL
- en: When we're checking the system status with `top` or `ps`, we can also check
    for how long a process has been running, and that is also accounted for by the
    kernel. A new process just created that starts eating CPU and RAM has a higher
    chance of being killed by the kernel to ensure system operability (remember the
    **out-of-memory** (**OOM**) killer mentioned in [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059),
    *Tools for Regular Operations*?).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s `renice` the process running our backup (containing the
    backup pattern in the process name to the lowest priority) with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `pgrep` has collected a list of PIDs, and that list has been
    piped as arguments for `renice` with a priority adjustment of 19, making processes
    nicer to others actually running in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s repeat the preceding example in our system by running a pi (π) calculation
    using `bc`, as illustrated in the man page for `bc`. First, we will time how long
    it takes for your system, and then, we will execute it via `renice`. So, let''s
    get hands-on—first, let''s time it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In my system, this was the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run it with `renice`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In my system again, this was the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a slight difference of 1 second, but you can try running more processes
    to generate system activity in your environment to make it more visible and add
    more zeros to the scale to increase the time of execution. Similarly, `ionice`
    can adjust the priority of I/O operations that a process is causing (reads, writes)—for
    example, repeating the action over the processes for our backup, we could run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, it will not output information, but we can check the value via
    execution of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've moved our backup processes so that I/O requests are handled
    when the system is idle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class, which we specified with the `–c` argument, can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: Real-time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: Best-effort'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: Idle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `–p`, we specify the processes to act on.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the settings that we can apply to our system came from specific ones,
    applied to each PID via the `/proc/` virtual filesystem, such as—for example—adjusting
    the `oom_adj` file to reduce the value shown on the `oom_score` file, which in
    the end determines if the process should be higher in the list when OOM has to
    kill some process to try saving the system from catastrophe.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are system-level settings such as `/proc/sys/vm/panic_on_oom`
    that can tune how the system has to react (panic or not) in case the OOM has to
    be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The disks also have a setting to define the scheduler being used—for example,
    for a disk named `sda`, it can be checked via `cat /sys/block/sda/queue/scheduler`.
  prefs: []
  type: TYPE_NORMAL
- en: The scheduler used for a disk has different approaches and depends on the kernel
    version—for example, it used to be `noop`, `deadline`, or `cfq` in RHEL 7, but
    in RHEL 8 those were removed, and we have `md-deadline`, `bfq`, `kyber`, and `none`.
  prefs: []
  type: TYPE_NORMAL
- en: This is such a big and complex topic that there is even a specific manual for
    it at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html-single/tuning_guide/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html-single/tuning_guide/index),
    so if you're interested in going deeper, have a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope to have achieved two things here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Making clear that the system has a lot of options for tuning and that it has
    its own documentation for it, and even a Red Hat Certified Architect exam for
    it at [https://www.redhat.com/en/services/training/rh442-red-hat-enterprise-performance-tuning](https://www.redhat.com/en/services/training/rh442-red-hat-enterprise-performance-tuning).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s not an easy task—several times in this book, one idea has been reinforced:
    test everything using your system''s workload, as results might vary from one
    system to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, there's no need to feel afraid about system tuning—it's something
    we can become more proficient in with experience at all levels (knowledge, hardware,
    workloads, and so on), but on the other hand, systems also include some easier
    ways to perform quick adjustments that will fit many scenarios, as we will see
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing tuned and managing tuning profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, after a bit of scaremongering happening in the previous section,
    you already have a mindset prepared for an easier path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just in case, ensure the `tuned` package is installed, or install it with `dnf
    –y install tuned`. The package provides a *tuned* service that must be enabled
    and started for operation; as a refresher, we achieve this by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We're now ready to interact and get more information about this service, which
    announces itself at `dnf info tuned` as a daemon that tunes the system dynamically
    based on some observation and is currently acting on an Ethernet network and hard
    disks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interaction with the daemon is performed via the `tuned-adm` command. For illustration,
    we''re showing in the following screenshot the command-line options available
    and a list of profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – The tuned-adm command-line options and profiles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.5 – The tuned-adm command-line options and profiles
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are some options for listing, disabling, and grabbing information
    about a profile, getting recommendations on which profile to use, verifying that
    settings have not been altered, automatically selecting a profile, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to bear in mind is that newer versions of the `tuned` package might
    bring additional profiles or configurations (stored in the `/usr/lib/tuned/` folder
    hierarchy), so the output might differ in your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review some of the most common ones in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_16.1_a.jpg)![](img/Table_16.1_b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned, each configuration is always a trade-off: more power consumption
    is required when increasing performance, or improving throughput might also increase
    latency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enable the `latency-performance` profile for our system. To do so, we
    will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that it has been activated with `tuned-adm active`, where we
    can see it shows `latency-performance`, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – The tuned-adm profile activation and verification'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.6 – The tuned-adm profile activation and verification
  prefs: []
  type: TYPE_NORMAL
- en: We additionally modified the system with `sysctl -w vm.swappiness=69` (on purpose)
    to demonstrate the `tuned-adm verify` operation, as it reported that some settings
    changed from the ones defined in the profile.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic tuning is by default disabled as of this writing—to enable or to check
    the current status, check that `dynamic_tuning=1` appears in the `/etc/tuned/tuned-main.conf`
    file. It is disabled in the performance profiles as it by default tries to balance
    between power consumption and system performance, which is the opposite of what
    performance profiles try to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, bear in mind that the **Cockpit** interface introduced in this
    book also features a way to change the performance profile—as seen in the following
    screenshot—once you have clicked on the **Performance profile** link in the main
    Cockpit page, opening up this dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Changing tuned profile within Cockpit web interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.7 – Changing tuned profile within Cockpit web interface
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine how tuned profiles work under the hood
    and how to create a custom one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom tuned profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we've commented on the different tuned profiles... *How do they work? How
    to create one?*
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine, for example, `latency-performance` in the next lines of code,
    by checking the `/usr/lib/tuned/latency-performance/tuned.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the syntax of the file is described in the `man tuned.conf` page,
    but the file, as you will be able to examine, is an *initialization (ini)-file*—that
    is, a file organized in categories, expressed between brackets and pairs of keys
    and values assigned by the equals (`=`) sign.
  prefs: []
  type: TYPE_NORMAL
- en: The main section defines a summary of the profile if it inherits from another
    profile via `include`, and the additional sections depend on the plugins installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn about the available plugins, the documentation included in the man
    page (`man tuned.conf`) instructs us to execute `rpm -ql tuned | grep ''plugins/plugin_.*.py$''`,
    which provides an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Available tuned plugins in our system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.8 – Available tuned plugins in our system
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If two or more plugins try to act over the same devices, the `replace=1` setting
    will mark the difference between running all of them or only the latest one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to the `latency-performance` profile, this has three sections:
    `main`, `cpu`, and `sysctl`.'
  prefs: []
  type: TYPE_NORMAL
- en: For the CPU, it sets the performance governor, which we can check—if supported
    via `cat /sys/devices/system/cpu/*/cpufreq/scaling_governor`—for each CPU available
    in our system. Bear in mind that in some systems, the path might differ or may
    even not exist, and we can check the available ones via execution of `cpupower
    frequency-info –governors`, with `powersave` and `performance` being the most
    common ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the section for each plugin might be arbitrary if we specify the
    `type` keyword to indicate which plugin to use, and we can use some devices to
    act on via the `devices` keyword, allowing—for example—the definition of several
    disk sections with different settings based on the disk being configured. For
    example, we might want some settings for the system disk—let''s say `sda`—and
    for the disk we use for data backups at `sdb`, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the disk named `sda` gets configured with `readahead`
    (which reads sectors ahead of current utilization to have the data cached before
    actually being requested to access it), and we're telling the system to `spindown`
    data disks that might be used only at backup time, thus reducing noise and power
    consumption when not in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting plugin is `sysctl`, used by several of the profiles, which
    defines settings in the same way we might do with the `sysctl` command, and because
    of this, the possibilities are huge: defining **Transmission Control Protocol**
    (**TCP**) window sizes for tuning networking, virtual memory management, transparent
    huge pages, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to start from scratch with any performance tuning, and as `tuned`
    allows us to inherit settings from a parent, it makes sense to find which one
    of the available profiles is the closest to what we want to achieve, check what
    is being configured in it, and—of course—compare it with the others (as we can
    see, there are also examples for other plugins) and apply it to our custom profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea about how the defined system profiles touch a system, my RHEL
    8 system shows the following output for `cat /usr/lib/tuned/*/tuned.conf|grep
    -v ^#|grep ''^\[''|sort –u`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Sections in system-supplied profiles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_16_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.9 – Sections in system-supplied profiles
  prefs: []
  type: TYPE_NORMAL
- en: So, as we can see, they touch a lot of areas, and I would like to highlight
    the `script` section, which defines a shell script to execute used by the `powersave`
    profile, and the `variables` section, used by `throughput-performance` to define
    regular expressions for later matching and applying settings based on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Once we're ready, we will create a new folder at `/etc/tuned/newprofile`. A
    `tuned.conf` file must be created, containing the main section with the summary
    and the additional sections for the plugins we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new profile, it might be easier if we copy the profile we're
    interested in from `/usr/lib/tuned/$profilename/` into our `/etc/tuned/newprofile/`
    folder and start the customization from there.
  prefs: []
  type: TYPE_NORMAL
- en: Once it's ready, we can enable the profile with `tuned-adm profile newprofile`,
    as we introduced earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the profiles available in the official documentation
    at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/monitoring_and_managing_system_status_and_performance/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/monitoring_and_managing_system_status_and_performance/index).
  prefs: []
  type: TYPE_NORMAL
- en: With this, we've set up our own custom profile for tuning our performance settings.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about identifying the processes, checking their
    resource consumption, and how to send signals to them.
  prefs: []
  type: TYPE_NORMAL
- en: About the signals, we learned that some of them have some additional behavior,
    such as terminating processes nicely or abruptly, or just sending a notification
    that some programs understand as reload configuration without restarting, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Also, related to processes, we learned about how to adjust their priority compared
    to other processes in terms of CPU and I/O so that we can adjust long-running
    processes or disk-intensive ones to not affect other services running.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we introduced the `tuned` daemon, which includes several general use-case
    profiles that we can use directly in our system, allowing `tuned` to apply some
    dynamic tuning, or we can fine-tune the profiles by creating one of our own to
    increase system performance or optimize power usage.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about how we can work with containers, registries,
    and other components so that applications can run as provided by the vendor while
    being isolated from the server running them.
  prefs: []
  type: TYPE_NORMAL
