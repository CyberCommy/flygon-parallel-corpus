- en: Chapter 9. User Interfaces – UI and UMG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing using Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Slate Widgets to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating screen size-aware scaling for the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and hiding a sheet of UMG elements in-game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching function calls to Slate events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Data Binding with Unreal Motion Graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling widget appearance with Styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom `SWidget`/`UWidget`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying feedback to the player is one of the most important elements within
    game design, and this will usually involve some sort of HUD, or at least menus,
    within your game.
  prefs: []
  type: TYPE_NORMAL
- en: In previous versions of Unreal, there was simple HUD support, which allowed
    you to draw simple shapes and text to the screen. However, it was somewhat limited
    in terms of aesthetics, and so, solutions such as **Scaleform** became common
    to work around the limitations. Scaleform leveraged Adobe's Flash file format
    to store vector images and UI scripts. It was not without its own cons for developers,
    though, not least the cost—it was a third-party product requiring an (at times
    expensive) license.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, Epic developed Slate for the Unreal 4 editor and the in-game UI
    framework. Slate is a collection of widgets (UI elements) and a framework allowing
    a cross-platform interface for the Editor. It is also usable in-game to draw widgets,
    such as sliders and buttons, for menus and HUDs.
  prefs: []
  type: TYPE_NORMAL
- en: Slate uses declarative syntax to allow an xml-style representation of user interface
    elements in their hierarchy in native C++. It accomplishes this by making heavy
    use of macros and operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: That said, not everybody wants to ask their programmers to design the game's
    HUD. One of the significant advantages of using Scaleform within Unreal 3 was
    the ability to develop the visual appearance of game UIs using the Flash visual
    editor, so visual designers didn't need to learn a programming language. Programmers
    could then insert the logic and data separately. This is the same paradigm espoused
    by the **Windows Presentation Framework** (**WPF**), for example.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion, Unreal provides **Unreal Motion Graphics** (**UMG**).
    UMG is a visual editor for Slate widgets that allows you to visually style, layout,
    and animate user interfaces. UI widgets (or controls if you've come from a Win32
    background) can have their properties controlled by either Blueprint code (written
    in the Graph view of the UMG window) or from C++. This chapter primarily deals
    with displaying UI elements, creating widget hierarchies, and creating base `SWidget`
    classes that can be styled and used within UMG.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing using Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Canvas** is a continuation of the simple HUD implemented within Unreal 3\.
    While it isn''t so commonly used within shipping games, mostly being replaced
    by Slate/UMG, it''s simple to use, especially when you want to draw text or shapes
    to the screen. Canvas drawing is still used extensively by console commands used
    for debugging and performance analysis such as the `stat game` and other `stat`
    commands. Refer to [Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* for the recipe for creating your own console commands.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your `<Module>.build.cs` file, and uncomment/add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `GameMode` called `CustomHUDGameMode` using the editor class wizard.
    Refer to [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components,* if you need a refresher
    on doing this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the constructor implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Create a new HUD subclass called `CustomHUD`, again using the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `override` keyword to the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Compile** your code, and launch the editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the editor, open the **World Settings** panel from the **Settings** drop-down
    menu:![How to do it...](img/00212.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **World Settings** dialog, select `CustomHUDGameMode` from the list under
    **GameMode Override**:![How to do it...](img/00213.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play and verify that your custom HUD is drawing to the screen:![How to do it...](img/00214.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the UI recipes here will be using Slate for drawing, so we need to add a
    dependency between our module and the Slate framework so that we can access the
    classes declared in that module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The best place to put custom Canvas draw calls for a game HUD is inside a subclass
    of `AHUD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to tell the engine to use our custom subclass, though, we need to create
    a new `GameMode`, and specify the type of our custom class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the constructor of our custom Game Mode, we assign the `UClass` for our
    new HUD type to the `HUDClass` variable. This `UClass` is passed onto each player
    controller as they spawn in, and the controller is then responsible for the `AHUD`
    instance that it creates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our custom `GameMode` loading our custom HUD, we need to actually create
    the said custom HUD class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AHUD` defines a virtual function called `DrawHUD()`, which is invoked in every
    frame to allow us to draw elements to the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we override that function, and perform our drawing inside the implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first method used is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`DrawText` requires a font to draw with. The default font used by `stat` and
    other HUD drawing commands in the engine code is actually stored in the `GEngine`
    class, and can be accessed by using the `GetSmallFont` function, which returns
    an instance of the `UFont` as a pointer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remaining arguments that we are use are the actual text that should be rendered,
    as well as the offset, in pixels, at which the text should be drawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DrawText` is a function that allows you to directly pass in the data that
    is to be displayed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The general `DrawItem` function is a Visitor implementation that allows you
    to create an object that encapsulates the information about the object to be drawn
    and reuse that object on multiple draw calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe, we create an element that can be used to represent a progress
    bar. We encapsulate the required information regarding the width and height of
    our box into an `FCanvasBoxItem`, which we then pass to the `DrawItem` function
    on our Canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third item that we draw is a filled rectangle. This function uses convenience
    methods defined in the HUD class rather than on the Canvas itself. The filled
    rectangle is placed at the same location as our `FCanvasBox` so that it can represent
    the current value inside the progress bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding Slate Widgets to the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe used the `FCanvas` API to draw to the screen. However, `FCanvas`
    suffers from a number of limitations, for example, animations are difficult to
    implement, and drawing graphics on the screen involves creating textures or materials.
    `FCanvas` also doesn't implement anything in the way of widgets or window controls,
    making data entry or other forms of user input more complex than it needs to be.
    This recipe will show you how to begin creating HUD elements onscreen using Slate,
    which provides a number of built-in controls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add `Slate` and `SlateCore` to your module's dependencies if you haven't done
    so already (see recipe *Drawing using Canvas* for how to do this).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `PlayerController` subclass, `ACustomHUDPlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the `BeginPlay` `virtual` method within your new subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code for your overridden `BeginPlay()` inside the subclass''
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to compile now, you''ll get some errors regarding classes not being
    defined. This is because we need to include their headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `GameMode` called `SlateHUDGameMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor inside the Game Mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following includes to the implementation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After adding the include to the implementation file, compile your game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the Editor, open **World Settings** from the toolbar:![How to do it...](img/00215.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside **World Settings**, override the level's Game Mode to be our `SlateHUDGameMode`.![How
    to do it...](img/00216.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level, and see your new UI displayed on the screen:![How to do it...](img/00217.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for us to reference Slate classes or functions in our code, our module
    must link with the `Slate` and `SlateCore` modules, so we add those to the module
    dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to instantiate our UI in one of the classes that loads when the game
    runs, so for this recipe, we use our custom `PlayerController`, in the `BeginPlay`
    function, as the place to create our UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `BeginPlay` implementation, we create a new `SVerticalBox` using
    the `SNew` function. We add a slot for a widget to our box, and set that slot
    to both horizontal and vertical centering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the slot, which we access using square brackets, we create a button that
    has `Textblock` inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Textblock`, we set the `Text` property to a string literal value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the UI now created, we call `AddViewportWidgetForPlayer` to display this
    widget on the local player's screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our custom `PlayerController` ready, we now need to create a custom `GameMode`
    to specify that it should use our new `PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the custom `PlayerController` being loaded at the start of the game, when
    `BeginPlay` is called, our UI will be shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The UI is very small at this screen size. Refer to the next recipe for information
    on how to scale it appropriately for the resolution of the game window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating screen size-aware scaling for the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have followed the previous recipe, you will notice that when you use
    **Play In Editor**, the button that loads is unusually small.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is UI Scaling, a system that allows you to scale the user
    interface based on the screen size. User interface elements are represented in
    terms of pixels, usually in absolute terms (the button should be 10 pixels tall).
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this is that if you use a higher-resolution panel, 10 pixels
    might be much smaller, because each pixel is smaller in size.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UI scaling system in Unreal allows you to control a global scale modifier,
    which will scale all the controls on the screen based on the screen resolution.
    Given the earlier example, you might wish to adjust the size of the button so
    that its apparent size is unchanged when viewing your UI on a smaller screen.
    This recipe shows two different methods for altering the scaling rates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a custom `PlayerController` subclass. Call it `ScalingUIPlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the class, override `BeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code in the implementation of that function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `GameMode` subclass called `ScalingUIGameMode`, and give it a
    default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the default constructor, set the default player controller class to
    `ScalingUIPlayerController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This should give you a user interface like the one from the previous recipe.
    Note that the UI is very tiny if you use Play In Editor:![How to do it...](img/00218.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To alter the rate at which the UI scales down or up, we need to change the scaling
    curve. We can do that through two different methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The In-Editor method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Launch Unreal, then open the **Project Settings** dialog through the **Edit**
    menu:![The In-Editor method](img/00219.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **User Interface** section, there is a curve that can be used to alter
    the UI scaling factor based on the short dimension of your screen:![The In-Editor
    method](img/00220.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the second dot, or keypoint, on the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its output value to 1.![The In-Editor method](img/00221.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Config file method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Browse to your project directory, and look inside the `Config` folder:![The
    Config file method](img/00222.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `DefaultEngine.ini` inside your text editor of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `[/Script/Engine.UserInterfaceSettings]` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Look for a key called `UIScaleCurve` in that section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the value for that key, you'll notice a number of `(Time=x,Value=y)` pairs.
    Edit the second pair so that its `Time` value is `720.000000` and the `Value`
    is `1.000000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the editor if you have it open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Play In Editor preview to confirm that your UI now remains readable
    at the **PIE** screen's resolution (assuming you are using a 1080p monitor so
    that the PIE window is running at 720p or thereabouts):![The Config file method](img/00223.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also see how the scaling works if you use a **New Editor Window** to
    preview your game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do so, click on the arrow to the right of **Play** on the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New Editor Window**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this window, you can use the console command `r.setreswidthxheight` to
    change the resolution, and observe the changes that result from doing so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, when we want to use a custom `PlayerController`, we need a custom
    `GameMode` to specify which `PlayerController` to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create both, a custom `PlayerController` and `GameMode`, and place some `Slate`
    code in the `BeginPlay` method of `PlayerController` so that some UI elements
    are drawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the main game viewport is usually quite small within the Unreal editor,
    the UI initially shows in a scaled-down fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is intended to allow for the game UI to take up less room on smaller resolution
    displays, but can have the side effect of making the text very difficult to read
    if the window isn't being stretched to fit the full screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unreal stores the configuration data that should persist between sessions, but
    not necessarily be hard-coded into the executable inside config files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Config files use an extended version of the `.ini` file format that has been
    commonly used with Windows software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Config files store data using the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unreal has a `UserInterfaceSettings` class, with a property called `UIScaleCurve`
    on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That `UPROPERTY` is marked as config, so Unreal serializes the value to the
    `.ini` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, it stores the `UIScale` data in the `DefaultEngine.ini` file, in
    the `Engine.UserInterfaceSettings` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data is stored using a text format, which contains a list of key points.
    Editing the `Time`, `Value` pairs alters or adds new key points to the curve.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Project Settings** dialog is a simple frontend for directly editing the
    `.ini` files yourself, and for designers, it is an intuitive way to edit the curve.
    However, having the data stored textually allows for programmers to potentially
    develop build tools that modify properties such as `UIScale` without having to
    recompile their game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Time` refers to the input value. In this case, the input value is the narrower
    dimension of the screen (usually, the height).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Value` is the universal scaling factor applied to the UI when the screen''s
    narrow dimension is approximately the height of the value in the `Time` field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, to set the UI to remain normal-sized at a 1280x720 resolution, set the time/input
    factor to 720, and the scale factor to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can refer to the UE4 documentation for more information regarding config
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and hiding a sheet of UMG elements in-game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we have already discussed how to add a widget to the viewport, which means
    that it will be rendered on the player's screen.
  prefs: []
  type: TYPE_NORMAL
- en: However, what if we want to have UI elements that are toggled based on other
    factors, such as proximity to certain Actors, or a player holding a key down,
    or if we want a UI that disappears after a specified time?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `GameMode` class called `ToggleHUDGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `BeginPlay` and `EndPlay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UPROPERTY`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly add this member variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `BeginPlay` with the following code in the method body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `EndPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Compile** your code, and start the editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the Editor, open **World Settings** from the toolbar:![How to do it...](img/00224.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside **World Settings**, override the level's **Game Mode** to be our `AToggleHUDGameMode`:![How
    to do it...](img/00225.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level, and verify that the UI toggles its visibility every 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with most of the other recipes in this chapter, we are using a custom `GameMode`
    class to display our single-player UI on the player''s viewport for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: We override `BeginPlay` and `EndPlay` so that we can correctly handle the timer
    that will be toggling our UI on and off for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make that possible, we need to store a reference to the timer as a `UPROPERTY`
    to ensure it won't be garbage collected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `BeginPlay`, we create a new `VerticalBox` using the `SNew` macro, and
    place a button in its first slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buttons have `Content`, which can be some other widget to host inside them,
    such as `SImage` or `STextBlock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this instance, we place a `STextBlock` into the `Content` slot. The contents
    of the text block are irrelevant as long as they are long enough for us to be
    able to see our button properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having initialized our widget hierarchy, we add the root widget to the player's
    viewport so that it can be seen by them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we set up a timer to toggle the visibility of our widget. We are using a
    timer to simplify this recipe rather than having to implement user input and input
    bindings, but the principle is the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this, we get a reference to the game world, and its associated timer manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the Timer manager in hand, we can create a new timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, we need to actually specify the code to run when the timer expires.
    One simple way to do this is to use a `lambda` function for our toggle the hud
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lambdas are anonymous functions. Think of them as literal functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To link a `lambda` function to the timer, we need to create a `timer` delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `FTimerDelegate::CreateLambda` function is designed to convert a `lambda`
    function into a delegate, which the timer can call at the specified interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `lambda` needs to access the `this` pointer from its containing object,
    our `GameMode`, so that it can change properties on the widget instance that we
    have created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To give it the access it needs, we begin our `lambda` declaration with the `[]`
    operators, which enclose variables that should be captured into the `lambda`,
    and accessible inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The curly braces then enclose the function body in the same way they would with
    a normal function declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the function, we check if our widget is visible. If it is visible, then
    we hide it using `SWidget::SetVisibility`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the widget isn't visible, then we turn it on using the same function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the rest of the call to `SetTimer`, we specify the interval (in seconds)
    to call the timer, and set the timer to loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One thing we need to be careful of, though, is the possibility of our object
    being destroyed between two timer invocations, potentially leading to a crash
    if a reference to our object is left dangling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to fix this, we need to remove the timer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that we set the timer during `BeginPlay`, it makes sense to clear the
    timer during `EndPlay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`EndPlay` will be called whenever `GameMode` either ends play or is destroyed,
    so we can safely cancel the timer during its implementation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `GameMode` set as the default game mode, the UI is created when the game
    begins to play, and the timer delegate executes every 5 seconds to switch the
    visibility of the widgets between `true` and `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you close the game, `EndPlay` clears the timer reference, avoiding any
    problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attaching function calls to Slate events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While creating buttons is all well and fine, at the moment, any UI element you
    add to the player's screen just sits there without anything happening even if
    a user clicks on it. We don't have any event handlers attached to the Slate elements
    at the moment, so events such as mouse clicks don't actually cause anything to
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows you how to attach functions to these events so that we can
    run custom code when they occur.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `GameMode` subclass called `AClickEventGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `private` members to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `public` functions, noting the override for `BeginPlay()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `.cpp` file, add the implementation for `BeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add an implementation for `ButtonClicked()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Compile** your code, and launch the editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the game mode in **World Settings** to be `AClickEventGameMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preview in the editor, and verify that the UI shows a button that changes from
    **Click Me!** to **Clicked!** when you use the mouse cursor to click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with most of the recipes in this chapter, we use `GameMode` to create and
    display our UI to minimize the number of classes extraneous to the point of the
    recipe that you need to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within our new game mode, we need to retain references to the Slate Widgets
    that we create so that we can interact with them after their creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we create two shared pointers as member data within our `GameMode`—one
    to the overall parent or root widget of our UI, and the other to the label on
    our button, because we're going to be changing the label text at runtime later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We override `BeginPlay`, as it is a convenient place to create our UI after
    the game has started, and we will be able to get valid references to our player
    controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also create a function called `ButtonClicked`. It returns `FReply`, a `struct`
    indicating if an event was handled. The function signature for `ButtonClicked`
    is determined by the signature of `FOnClicked`, a delegate which we will be using
    in a moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our implementation of `BeginPlay`, the first thing we do is call the
    implementation we are overriding to ensure that the class is initialized appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, as usual, we use our `SNew` function to create `VerticalBox`, and we add
    a slot to it which is centered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new `Button` inside that slot, and we add a value to the `OnClicked`
    attribute that the button contains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OnClicked` is a delegate property. This means that the `Button` will broadcast
    the `OnClicked` delegate any time a certain event happens (as the name implies
    in this instance, when the button is clicked).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To subscribe or listen to the delegate, and be notified of the event that it
    refers to, we need to assign a delegate instance to the property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do that using the standard delegate functions such as `CreateUObject`, `CreateStatic`,
    or `CreateLambda`. Any of those will work—we can bind `UObject` member functions,
    static functions, lambdas, and other functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates,*
    to learn more on delegates to see about the other types of function that we can
    bind to delegates.
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateUObject` expects a pointer to a class instance, and a pointer to the
    member function defined in that class to call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The function has to have a signature that is convertible to the signature of
    the delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen here, `OnClicked` delegate type is `FOnClicked`—this is why the
    `ButtonClicked` function that we declared has the same signature as `FOnClicked`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By passing in a pointer to this, and the pointer to the function to invoke,
    the engine will call that function on this specific object instance when the button
    is clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting up the delegate, we use the `Content()` function, which returns
    a reference to the single slot that the button has for any content that it should
    contain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use `SAssignNew` to create our button's label, using the `TextBlock`
    widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SAssignNew` is important, because it allows us to use Slate''s declarative
    syntax, and yet assigns variables to point to specific child widgets in the hierarchy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SAssignNew` first argument is the variable that we want to store the widget
    in, and the second argument is the type of that widget.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `ButtonLabel` now pointing at our button's `TextBlock`, we can set its
    `Text` attribute to a static string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the widget to the player's viewport using `AddViewportWidgetForPlayer`,
    which expects, as parameters, `LocalPlayer` to add the widget to, the widget itself,
    and a depth value (higher values to the front).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get the `LocalPlayer` instance, we assume we are running without split screen,
    and so, the first player controller will be the only one, that is, the player's
    controller. The `GetFirstLocalPlayerFromController` function is a convenience
    function that simply fetches the first player controller, and returns its local
    player object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to focus the widget so the player can click on it, and display
    a cursor so that the player knows where their mouse is on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We know from the previous step that we can assume the first local player controller
    is the one we're interested in, so we can access it and change its `ShowMouseCursor`
    variable to `true`. This will cause the cursor to be rendered on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SetInputMode` allows us to focus on a widget so that the player can interact
    with it amongst other UI-related functionality, such as locking the mouse to the
    game''s viewport.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses an `FInputMode` object as its only parameter, which we can construct
    with the specific elements that we wish to include by using the `builder` pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `FInputModeUIOnly` class is a `FInputMode` subclass that specifies that
    we want all input events to be redirected to the UI layer rather than the player
    controller and other input handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `builder` pattern allows us to chain the method calls to customize our object
    instance before it is sent into the function as the parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We chain `SetLockMouseToViewport(false)` to specify that the player's mouse
    can leave the boundary of the game screen with `SetWidgetToFocus(Widget)`, which
    specifies our top-level widget as the one that the game should direct player input
    to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have our actual implementation for `ButtonClicked`, our event handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the function is run due to our button being clicked, we change our button's
    label to indicate it has been clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then need to return an instance of `FReply` to the caller to let the UI framework
    know that the event has been handled, and to not continue propagating the event
    back up the widget hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FReply::Handled()` returns `FReply` set up to indicate this to the framework.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could have used `FReply::Unhandled()`, but this would have told the framework
    that the click event wasn't actually the one we were interested in, and it should
    look for other objects that might be interested in the event instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Data Binding with Unreal Motion Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been assigning static values to the attributes of our UI widgets.
    However, what if we want to be more dynamic with widget content, or parameters
    such as border color? We can use a principle called data binding to dynamically
    link properties of our UI with variables in the broader program.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal uses the Attribute system to allow us to bind the value of an attribute
    to the return value from a function, for example. This means that changing those
    variables will automatically cause the UI to change in response, according to
    our wishes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `GameMode` subclass called `AAtributeGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `private` member to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `public` functions, noting the override for `BeginPlay()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the implementation for `BeginPlay` within the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add an implementation for `GetButtonLabel()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Compile** your code, and launch the editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the game mode in **World Settings** to be `AAtributeGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that in a Play In Editor session, the value on the UI's button changes
    as the player moves around the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like almost all other recipes in this chapter, the first thing we need
    to do is create a game mode as a convenient host for our UI. We create the UI
    in the same fashion as in the other recipes, by placing `Slate` code inside the
    `BeginPlay()` method of our game mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The interesting feature of this recipe concerns how we set the value of our
    button''s label text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax is unusually verbose, but what it is actually doing is
    comparatively simple. We assign something to the `Text` property, which is of
    the type `FText`. We can assign `TAttribute<FText>` to this property, and the
    `TAttribute Get()` method will be called whenever the UI wants to ensure that
    the value of `Text` is up to date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create `TAttribute`, we need to call the static `TAttribute<VariableType>::Create()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function expects a delegate of some description. Depending on the type
    of delegate passed to `TAttribute::Create`, `TAttribute::Get()` invokes a different
    type of function to retrieve the actual value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the code for this recipe, we invoke a member function of `UObject`. This
    means we know we will be calling the `CreateUObject` function on some delegate
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use `CreateLambda`, `CreateStatic`, or `CreateRaw` to invoke a `lambda`,
    a `static`, or a `member` function respectively on a raw C++ class. This will
    give us the current value for the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: But what delegate type do we want to create an instance of? Because we're templating
    the `TAttribute` class on the actual variable type that the attribute will be
    associated with, we need a delegate that is also templated on the variable type
    as its return value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is to say, if we have `TAttribute<FText>`, the delegate connected to it
    needs to return an `FText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the following code within `TAttribute`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `FGetter` delegate type is declared inside the `TAttribute` class, so its
    return value can be templated on the `ObjectType` parameter of the `TAttribute`
    template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that `TAttribute<Typename>::FGetter` automatically defines a delegate
    with the correct return type of `Typename`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So we need to create a `UObject`-bound delegate of type and signature for `TAttribute<FText>::FGetter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have that delegate, we can call `TAttribute::Create` on the delegate
    to link the delegate's return value to our `TextBlock` member variable `Text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our UI defined and a binding between the `Text` property, a `TAttribute<FText>`,
    and a delegate returning `FText`, we can now add the UI to the player's screen
    so that it's visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every frame, the game engine checks all properties to see if they are linked
    to `TAttributes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there's a connection, then the `TAttribute` `Get()` function is called, invoking
    the delegate, and returning the delegate's return value so that Slate can store
    it inside the widget's corresponding member variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our demonstration of the process, `GetButtonLabel` retrieves the location
    of the first player pawn in the game world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use `FString::Printf` to format the location data into a human readable
    string, and wrap that in an `FText` so that it can be stored as the `TextBlock`
    text value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Controlling widget appearance with Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've been creating UI elements that use the default
    visual representation. This recipe shows you how to create a Style in C++ that
    can be used as a common look-and-feel across your whole project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class header in your project. Name the file `"CookbookStyle.h"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a corresponding implementation cpp file for this class, and add the
    following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Game Mode subclass, `StyledHUDGameMode`, and add the following
    code to its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, implement `GameMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, create a 54x54 pixel png file with a border around it for our button.
    Save it to the `Content` | `Slate` folder with the name `Button.png`:![How to
    do it...](img/00226.jpeg)![How to do it...](img/00227.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to set our game''s module to properly initialize the style
    when it is loaded. In your game module''s implementation file, ensure it looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Compile** code, and set your game mode override to the new game mode as we''ve
    done in the other recipes this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play the game, you will see that your custom border is around the button,
    and the text is white rather than black.![How to do it...](img/00228.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for us to create styles that can be shared across multiple Slate widgets,
    we need to create an object to contain the styles and keep them in scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Epic provides the `FSlateStyleSet` class for this purpose. `FSlateStyleSet`
    contains a number of styles that we can access within Slate's declarative syntax
    to skin widgets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, it's inefficient to have multiple copies of our `StyleSet` object scattered
    through the program. We really only need one of these objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because `FSlateStyleSet` itself is not a singleton, that is, an object that
    can only have one instance, we need to create a class that will manage our `StyleSet`
    object and ensure that we only have the single instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the reason we have the `FCookbookStyle` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It contains an `Initialize()` function, which we will call in our module's startup
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Initialize()` function, we check if we have an instance of our `StyleSet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we do not have a valid instance, we call the private `Create()` function
    to instantiate one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then register the style with the `FSlateStyleRegistry` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When our module is unloaded, we will need to reverse this registration process,
    then erase the pointer so it does not dangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have an instance of our class, created during module initialization by
    calling `Create()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll notice that `Create` is wrapped by a number of macros that all have similar
    form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These macros are defined before the function, and undefined after it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These macros make it easier for us to simplify the code required within the
    `Create` function by eliminating the need to specify a path and extension for
    all the image resources that our Style might want to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `Create` function, we create a new `FSlateStyleSet` object using
    the function `FSlateGameResources::New()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`New()` needs a name for the style, and the folder paths that we want to search
    for in this Style Set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows us to declare multiple Style Sets pointing to different directories,
    but using the same names for the images. It also allows us to skin or restyle
    the whole UI simply by switching to a Style Set in one of the other base directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`New()` returns a shared reference object, so we retrieve the actual `FStyleSet`
    instance using the `Get()` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this reference in hand, we can create the styles we want this set to contain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add styles to a set, we use the `Set()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set expects the name of the style, and then a style object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Style objects can be customized using the `builder` pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We first add a style called `"NormalButtonBrush"`. The name can be arbitrary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we want to use this style to change the appearance of buttons, we need
    to use `FButtonStyle` for the second parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To customize the style to our requirements, we use the Slate builder syntax,
    chaining whatever method calls that we need to set properties on our style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first style in this set, we just change the visual appearance of the
    button when it isn't being clicked or is in a non-default state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That means we want to change the brush used when the button is in the normal
    state, and so the function we use is `SetNormal()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `BOX_BRUSH` macro, we tell Slate that we want to use `Button.png`,
    which is an image of 54x54 pixel size, and that we want to keep the 14 pixels
    in each corner unstretched for the purposes of nine-slice scaling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more visual explanation of the nine-slice scaling functionality, take
    a look at `SlateBoxBrush.h` in the engine source.
  prefs: []
  type: TYPE_NORMAL
- en: For the second style in our Style Set, we create a style called `"NormalButtonText"`.
    For this style, we don't want to change everything from defaults in the style;
    we just want to alter one property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we access the default text style, and clone it using the copy constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our fresh copy of the default style, we then change the color of the text
    to white, first creating a linear color of R=1 G=1 B=1 A=1, then converting that
    to a Slate color object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our Style Set configured with our two new styles, we can then return it
    to the calling function, which is `Initialize`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Initialize` stores our Style Set reference, and eliminates the need for us
    to create further instances.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our style container class also has a `Get()` function, which is used to retrieve
    the actual `StyleSet` for use in Slate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because `Initialize()` has already been called at the module startup, `Get()`
    simply returns the `StyleSet` instance that was created within that function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the game module, we add the code which actually calls `Initialize` and
    `Shutdown`. This ensures that while our module is loaded, we will always have
    a valid reference to our Slate Style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As always, we create a Game Mode as the host for our UI, and we override `BeginPlay`
    so that we can create the UI when the game starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The syntax for creating the UI is exactly the same as we've used in previous
    recipes—creating a `VerticalBox` using `SNew`, and then using Slate's declarative
    syntax to populate the box with other widgets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to note the two following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines are part of the declarative syntax for our button, and the
    text that makes its label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we set the style for our widgets using a `<Class>Style()` method, we pass
    in two parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is our actual Style Set, retrieved using `FCookbookStyle::Get()`,
    and the second is a string parameter with the name of the style that we want to
    use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these minor changes, we override the styling of the widgets to use our
    custom styles so that when we add the widgets to the player's viewport, they display
    our customizations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom SWidget/UWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes in this chapter so far have shown you how to create UIs using the
    existing primitive widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is convenient for developers to use composition to collect a number
    of UI elements together, for example, to define a button class that automatically
    has a `TextBlock` as a label rather than manually specifying the hierarchy every
    time they are declared.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if you are manually specifying the hierarchy in C++, rather than
    declaring a compound object consisting of subwidgets, you won't be able to instantiate
    those widgets as a group using UMG.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows you how to create a compound `SWidget` that contains a group
    of widgets and exposes new properties to control elements of those subwidgets.
    It will also show you how to create a `UWidget` wrapper, which will expose the
    new compound `SWidget` class to UMG for use by designers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to add the UMG module to our module's dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `<YourModule>.build.cs`, and add UMG to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class called `CustomButton`, and add the following code to its
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the class with the following in the corresponding cpp file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Create a second class, this time based on `UWidget`, called `UCustomButtonWidget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the following delegates before the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following protected members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add the following public members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the implementation for `UCustomButtonWidget`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Widget Blueprint by right-clicking on the **Content Browser**,
    selecting **User Interface**, and then **Widget Blueprint**:![How to do it...](img/00229.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your new **Widget Blueprint** by double-clicking on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Custom Button Widget** in the Widget Palette:![How to do it...](img/00230.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of it out into the main area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the instance selected, change the **Label** property in the **Details**
    panel:![How to do it...](img/00231.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that your button has changed its label.![How to do it...](img/00232.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will create a binding to demonstrate that we can link arbitrary blueprint
    functions to the label property on our widget, which, in turn, drives the Widget's
    textblock label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Bind** to the right of the **Label** property, and select **Create
    Binding**:![How to do it...](img/00233.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the graph that is now displayed, place a **Get Game Time in Seconds**
    node:![How to do it...](img/00234.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the return value from the Get Game Time node to the **Return Value** pin
    in the function:![How to do it...](img/00235.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A convert float to string node will be automatically inserted for you:![How
    to do it...](img/00236.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open the **Level Blueprints** by clicking on the **Blueprints** button
    on the taskbar, then selecting **Open Level Blueprint**:![How to do it...](img/00237.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a construct widget node into the graph:![How to do it...](img/00238.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the class of widget to spawn as the new Widget Blueprint that we created
    a moment ago within the editor:![How to do it...](img/00239.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag away from the **Owning Player** pin on the create widget node,
    and place a **Get Player Controller** node:![How to do it...](img/00240.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, drag away from the return value of the create widget node, and place
    a **Add to Viewport** node.![How to do it...](img/00241.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, link the `BeginPlay` node to the execution pin on the create widget
    node.![How to do it...](img/00242.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preview your game, and verify that the widget we've displayed onscreen is our
    new custom button with its label bound to the number of seconds that have elapsed
    since the game started:![How to do it...](img/00243.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use the `UWidget` class, our module needs to include the UMG module
    as one of its dependencies, because `UWidget` is defined inside the UMG module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first class that we need to create, however, is our actual `SWidget` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we want to aggregate two widgets together into a compound structure,
    we create our new widget as a `CompoundWidget` subclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CompoundWidget` allows you to encapsulate a widget hierarchy as a widget itself.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the class, we use the `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS` macros
    to declare an internal `struct` called `FArguments` on our new `SWidget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS`, the `SLATE_ATTRIBUTE` and `SLATE_EVENT`
    macros are used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SLATE_ATTRIBUTE` creates `TAttribute` for the type we give it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this class, we declare `TAttribute` called `_Label`, which is more specifically
    a `TAttribute<FString>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SLATE_EVENT` allows us to create member delegates that we can broadcast when
    something happens internally to the widget.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `SCustomButton`, we declare a delegate with the signature `FOnClicked`, called
    `ButtonClicked`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SLATE_ARGUMENT` is another macro, unused in this recipe, which creates an
    internal variable with the type and name you provide, appending an underscore
    to the start of the variable name.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Construct()` is the function that widgets implement to self-initialize when
    they are being instantiated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll notice we also create a `TAttribute` and a `FOnClicked` instance ourselves,
    without the underscores. These are the actual properties of our object into which
    the arguments that we declared earlier will be copied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the implementation of `Construct`, we retrieve the arguments that were
    passed to us in the `FArgumentsstruct`, and store them inside our actual member
    variables for this instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign `Label` and `ButtonClicked` based on what was passed in, then we actually
    create our widget hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the same syntax as usual for this with one thing to note, namely, the
    use of `Text_Lambda` to set the text value of our internal text block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use a `lambda` function to retrieve the value of our `Label` `TAttribute`
    using `Get()`, then convert it to `FText`, and store it as our text block's `Text`
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our `SWidget` declared, we need to create a wrapper `UWidget`
    object that will expose this widget to the UMG system so that designers can use
    the widget within the **WYSIWYG** editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This class will be called `UCustomButtonWidget`, and it inherits from `UWidget`
    rather than `SWidget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UWidget` object needs a reference to the actual `SWidget` that it owns,
    so we place a protected member in the class that will store it as a shared pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A constructor is declared, so is a `ButtonClicked` delegate that can be set
    in blueprint. We also mirror a `Label` property that is marked as `BlueprintReadWrite`
    so that it can be set in the UMG editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we want to be able to bind our button's label to a delegate, we add
    the last of our member variables, which is a delegate that returns a `String`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SynchronizeProperties` function applies properties that have been mirrored
    in our `UWidget` class across to the `SWidget` that we are linked with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RebuildWidget` reconstructs the native widget this `UWidget` is associated
    with. It uses `SNew` to construct an instance of our `SCustomButton` widget, and
    uses the Slate declarative syntax to bind the UWidget''s `OnButtonClicked` method
    to the `ButtonClicked` delegate inside the native widget.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that when the native widget is clicked, the `UWidget` will be notified
    by having `OnButtonClicked` called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OnButtonClicked` re-broadcasts the clicked event from the native button via
    the UWidget''s `ButtonClicked` delegate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that UObjects and the UMG system can be notified of the button being
    clicked without having a reference to the native button widget themselves. We
    can bind to `UCustomButtonWidget::ButtonClicked` to be notified about it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OnButtonClicked` then returns `FReply::Handled()` to indicate that the event
    does not need to propagate further.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `SynchronizeProperties`, we call the parent method to ensure that any
    properties in the parent are also synchronized properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `OPTIONAL_BINDING` macro to link the `LabelDelegate` delegate in
    our `UWidget` class to `TAttribute`, and in turn, the native button's label. It
    is important to note that the `OPTIONAL_BINDING` macro expects the delegate to
    be called `NameDelegate` based on the second parameter to the macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OPTIONAL_BINDING` allows for the value to be overridden by a binding made
    via UMG, but only if the UMG binding is valid.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that when `UWidget` is told to update itself, for example, because
    the user customizes a value in the **Details** panel within UMG, it will recreate
    the native `SWidget` if necessary, then copy the values set in Blueprint/UMG via
    `SynchronizeProperties` so that everything continues to work as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
