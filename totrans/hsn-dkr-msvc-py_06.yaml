- en: Creating a Pipeline and Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pipeline that runs automatically in a workflow, through different stages,
    will detect problems early and help your team collaborate in the most efficient
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will follow continuous integration practices, running the
    pipeline automatically and on every change, to be sure that all our code follows
    high quality standards, and that it runs and passes all tests. We'll also get
    a container ready to go to production.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to leverage tools such as GitHub and Travis CI to create images
    with minimal intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding continuous integration practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Travis CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing Docker images from Travis CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you'll know how to automatically run tests on every
    code change and how to create a safety net that will allow you to develop faster
    and more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You require a GitHub account and need to be the owner of the project you'll
    set up for continuous integration. We will create a Travis CI account as part
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can checkout the full code referred to in this chapter in the `Chapter04`
    subdirectory from GitHub ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter04)).
    The file ending with `.travis.yml` is in the root directory ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/.travis.yml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/.travis.yml)).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding continuous integration practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** (usually abbreviated as **CI**) is a series of software
    engineering practices that ensure that code is always in a working state.'
  prefs: []
  type: TYPE_NORMAL
- en: The term continuous integration comes from historically having to integrate
    software frequently, often multiple times a day. This arose from the fact that
    developers worked with local code that was not necessarily joined with other people's
    code automatically. Nowadays, using a source-control versioning software such
    as Git makes some of the elements automatically available.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration emphasizes on having potentially releasable code at all
    times. This makes releases possible very often, with small increments of code.
  prefs: []
  type: TYPE_NORMAL
- en: Making more releases more often actually generates an increase in the quality
    of each release. More deployments also mean that each deployment is smaller, reducing
    the possibility of a big problem. Even if it sounds counterintuitive, faster deployment
    is highly correlated with higher quality in deployments and fewer production problems.
  prefs: []
  type: TYPE_NORMAL
- en: The objective here is to be able to increase the deployment speed. But for that,
    we need to be sure to build a good safety net that checks (automatically) that
    what we're doing is safe to release. That's where all the CI practices come into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite possible, after setting all the processes and infrastructure in
    place, to implement releases multiple times a day (assuming that the code is generated
    fast enough). It can take a while to get there, but be sure to take your time
    to understand the process and produce all the necessary tools to be certain that
    you gain speed without sacrificing stability. And, trust me, it is totally achievable!
  prefs: []
  type: TYPE_NORMAL
- en: Producing automated builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core element in CI is generating automated builds integrated with a source
    control system. A software build is a process that (starting from the source code)
    performs a series of actions and produces an output. If the project is written
    in a compiled language, the output will typically be the compiled program.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to have quality software, then part of the build involves checking
    that the produced code follows code standards. If the code doesn't follow those
    standards, then the build will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: A common way of describing errors on a build is to say that the *build is broken*.
    A build can break in different ways, and some kinds of error may stop it early
    (such as a compilation error before running tests) or we can continue to detect
    further issues (such as running all tests to return all possible errors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of steps that can be a part of the build are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python usually doesn't need to be compiled, but it might be required if you
    use C extensions (modules written in C and imported from Python: [https://docs.python.org/3/extending/](https://docs.python.org/3/extending/))
    or tools such as Cython ([https://cython.org/](https://cython.org/)[).](https://cython.org/)
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running static code analysis tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building one or more containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking dependencies for known vulnerabilities with a tool such as Safety ([https://pyup.io/safety/](https://pyup.io/safety/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a binary or source package for distribution. For example, RPM ([https://rpm.org/](https://rpm.org/)),
    Debian packages ([https://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics](https://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics)),
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running other kinds of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating reports, diagrams, or other assets from the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything that can run automatically can be a part of a build. A local build
    can be generated at any time, even with code that's still in progress. This is
    important for debugging and solving issues. But automated builds will run against
    each individual commit, and not at any intermediate stage. This makes it very
    explicit to check what code is expected to run in production and what code is
    still work in progress.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a single commit may still be work in progress, but it will be worth
    committing anyway. Maybe it's a single step toward a feature, more than one person
    is working on the same part of the code, or it's work spread over several days
    and the code gets pushed at the end of the day. No matter, each commit is a reproducible
    step that can be built and checked whether the build is successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: Running the build for each commit detects problems very quickly. If commits
    are small, a breaking change is easy to pinpoint. It also makes it easy to revert
    changes that break the build and go back to known working code.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the advantages of using Docker for builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main traditional problems with builds was having an adequate build
    environment with all the dependencies needed to run the full build. This could
    include things such as the compiler, the test framework to run the tests, any
    static analysis tools, and the package manager. A discrepancy in versions could
    also produce errors.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen before, Docker is a fantastic way of encapsulating our software.
    It allows us to create an image that contains both our code and all tools that
    are able to proceed through all the steps.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to run unit tests in a single command, based
    on a build image. The image itself can run its own unit tests. This abstracts
    the test environment and explicitly defines it. The only dependency necessary
    here is to have Docker installed.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that a single build could generate multiple images and make them
    work in coordination. We saw how to run unit tests in the previous chapter—by
    generating service image and a database image—but there are more possible usages.
    For example, you could check the test running on two different operating systems,
    creating two images from each of the operating systems or different Python interpreter
    versions, and checking whether the tests pass in all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of Docker images allows for standardization in all environments. We
    can locally run images in a development environment, using the same commands that
    we did in our automated environment. This streamlines finding bugs and problems,
    as it creates the same environment, including an encapsulated operating system,
    everywhere the build is run.
  prefs: []
  type: TYPE_NORMAL
- en: Do not underestimate this element. Before that, a developer working on a laptop
    running Ubuntu and keen to run code to be deployed in CentOS needed to install
    a **Virtual Machine** (**VM**) and follow steps to have an environment similar
    to the one in production. But invariably, the local VM would deviate as it was
    difficult to keep every developer's local VM in sync with the one in production;
    also, any automated-build tool might also have requirements, such as not supporting
    an old version of CentOS running in production.
  prefs: []
  type: TYPE_NORMAL
- en: To make things worse, sometimes different projects were installed on the same
    VM, to avoid having one VM per project, and that may cause compatibility problems.
  prefs: []
  type: TYPE_NORMAL
- en: Docker massively simplifies this problem, in part forcing you to explicitly
    declare what the dependencies are, and reducing the surface actually required
    to run our code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't necessarily need to create a single step that runs the whole
    build; it could be several Docker commands, even making use of different images.
    But the requirement is that they are all contained in Docker, the only software
    required to run it.
  prefs: []
  type: TYPE_NORMAL
- en: The main product of a build using Docker is Docker image or images. We will
    need to properly tag them, but only if the build is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the pipeline concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI tools help to clarify how a build should proceed and work around the concept
    of a pipeline. A pipeline is a collection of stages. If any of them are not successful,
    the pipeline stops.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage in the pipeline can produce elements that could be used at later
    stages or are available as the final product of the full build. These final elements
    are known as artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/11e95cdf-0c76-4701-9c4a-69964b4b49dd.png)'
  prefs: []
  type: TYPE_IMG
- en: The first stage pulls the latest commit from the source control system. Then,
    we build all the containers and run both tests and the static analysis. If all
    has been successful, we tag the resulting `server` container and push it to the
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: The order in which these stages run should be oriented at detecting problems
    as quickly as possible to give quick feedback. For example, if the `static-analysis`
    stage is much faster than the `test` stage, putting the analysis stage first will
    make a failing build finish earlier. Be aware of which parts can be executed earlier
    to reduce the feedback time.
  prefs: []
  type: TYPE_NORMAL
- en: CI tools normally allow great configuration in pipelines, including the possibility
    of running different stages in parallel. To be able to run stages in parallel,
    they need to be able to be parallelizable, meaning that they should not change
    the same elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the chosen CI tool allows running stages in parallel, the pipeline could
    be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7754936-9bc7-4507-a412-2ad09198cb3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we build the database and the test images in parallel. The next stage
    builds the rest of the elements, which are already available in the cache, so
    it will be very quick. Both the tests and the static analysis can run in parallel,
    in two different containers.
  prefs: []
  type: TYPE_NORMAL
- en: This may speed up complex builds.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to validate that the amount of time taken reduces. There are cases where
    the time taken will be very similar. For example, static analysis could be very
    fast or the hardware you run it on may be not powerful enough to build things
    in parallel, making the time taken to build in parallel and sequentially very
    similar. So, always validate your assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline is described in a script specific to the Travis CI tool. We'll
    look at an example with Travis CI later.
  prefs: []
  type: TYPE_NORMAL
- en: Branching, merging, and ensuring a clear main build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When do we run a build? Every time a commit is pushed. But every result is
    not the same. When dealing with a source control system such as Git, we typically
    have two kinds of branches:'
  prefs: []
  type: TYPE_NORMAL
- en: One main branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They implement a particular feature or bugfix, which will be merged into the
    main branch when ready, as is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6510d21-1c6b-4fa8-9d99-fc0e7b0b6a57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we see how the main branch (**master**) is branched to develop
    **feature** **A**. **Feature** **A** is introduced briefly after that. There is
    a **feature B** that hasn''t been merged yet since it''s not ready. With the extra
    information on what builds have been successful or not, we can know when it is
    safe to merge a feature branch into the main branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f477c83f-b377-42f2-b128-2d526c862899.png)'
  prefs: []
  type: TYPE_IMG
- en: Breakage in a feature branch that is not yet merged is not great, but while
    it is work in progress, it is expected to happen. Meanwhile, a breakage in the
    main branch is an event that should be fixed as soon as possible. If the main
    branch is in good shape, that means that it is potentially releasable.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub has a model for this: pull requests. We will configure pull requests
    to automatically check whether the build has passed and avoided merging or not.
    If we force any feature branch to also be up-to-date with the main branch before
    merging back, the main branch ends up being very stable.'
  prefs: []
  type: TYPE_NORMAL
- en: For dealing with branches in Git to define releases, the most popular model
    is Git-flow, defined in this influential blog post ([https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)).
    The following CI practices allow simplify things a bit and don't deal with elements
    such as release branches. This blog post is a highly recommended read.
  prefs: []
  type: TYPE_NORMAL
- en: Having an uninterrupted line of successful builds in the main branch is also
    very helpful to develop a sense of stability and quality in the project. If main
    branch breakages are very rare, confidence in creating a new release with the
    latest main branch is very high.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Travis CI ([https://travis-ci.com/](https://travis-ci.com/)) is a popular continuous
    integration service that's freely available for public GitHub projects. Integration
    with GitHub is very simple and it allows you to configure the platform it runs
    on, such as macOS, Linux, or even iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Travis CI integrates tightly with GitHub, so you only need to log in to GitHub
    to be able to access it. We'll see how to connect our project to it.
  prefs: []
  type: TYPE_NORMAL
- en: For clarity, only the code in this chapter will be hooked up to Travis.
  prefs: []
  type: TYPE_NORMAL
- en: Travis works a bit differently from other CI tools in that it creates independent
    jobs by starting a new VM. This means that any artifact created for a previous
    stage needs to be copied somewhere else to be downloaded at the start of the next
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: This makes things a bit unpractical sometimes, and an easy solution is to build
    multiple times for each individual job.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a remote system such as Travis CI can be a little frustrating sometimes,
    as it requires you to push a commit to be built to see if the configuration is
    correct. Also, it gets configured with a YAML file, which can be a bit temperamental
    in terms of syntax. It will take you a few attempts to get something stable, but
    don't worry. Once it is set up, you can change it only via a specific pull request
    as the configuration file is also under source control.
  prefs: []
  type: TYPE_NORMAL
- en: You can also check the requests in the Travis CI configuration to see if a `.yml`
    file creates a parse error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check full Travis CI documentation here: [https://docs.travis-ci.com/](https://docs.travis-ci.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: To configure Travis CI, let's start off by adding a repository from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a repo to Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a repo to Travis CI, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first stage is to go to the Travis CI web page and log in with your GitHub
    credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you'll need to grant Travis access to GitHub, by activating it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select which repo you want to build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest starting point is to fork the repo with the examples from this book
    in [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python).
    Feel free to do so!
  prefs: []
  type: TYPE_NORMAL
- en: But remember to change the usernames, credentials, and registry information
    to match your own.
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to have owner permissions for the GitHub repos and then you're ready
    to go!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the .travis.yml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main element in Travis CI is the creation of the `.travis.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to name it exactly like this (including the initial dot and the `.yml`
    extension) and include it in the root directory of your GitHub repo. If not, Travis
    CI builds won't start. Please note that, in the example repo, the file is in the
    **root directory** and **not** under the `Chapter04` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: '`.travis.yml` describes the build and its different steps. A build gets executed
    in one or more VMs. Those VMs can be configured by specifying the general operating
    system and the specific version. By default, they run in Ubuntu Linux 14.04 Trusty.
    You can find more information about available operating systems here: [https://docs.travis-ci.com/user/reference/overview/](https://docs.travis-ci.com/user/reference/overview/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker allows us to abstract most of the operating system differences,
    but we need to ensure the specific `docker` and `docker-compose` version that
    we use is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start `.travis.yml`, ensuring that a valid `docker-compose` version
    (1.23.2) is present, by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `before_install` block will be executed in all our VMs. Now, to run the
    tests, we add a `script` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We build all the images to use and then run the tests. Note that running the
    tests using the PostgreSQL database requires you to build the `db` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a small detail about the `db` container: the Travis VM doesn''t allow
    us to open port `5432`. We removed `ports` in `docker-compose` for that. Note
    that this only makes PostgreSQL available externally for debugging purposes; internally,
    the containers can talk to each other through their internal network.'
  prefs: []
  type: TYPE_NORMAL
- en: We created a `db-debug` service that's a copy of `db` but it exposes the port
    for local development. You can check it in the `docker-compose.yaml` file at [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter04/docker-compose.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter04/docker-compose.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: 'This runs all the tests. After pushing into the repo, we can see that the build
    starts in Travis CI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cbc98740-909b-426f-a13c-87ee5e1bb86a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it finishes, we can tell that the build was successful by the fact that
    it''s flagged in green. The logs can then be checked for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7eb1ed98-42f7-4c6c-bc9c-a9490165daf5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And now you can see the tests at the end of the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/299c2d36-633a-4dc6-acce-bd4a49d3c8fb.png)'
  prefs: []
  type: TYPE_IMG
- en: This is useful for detecting problems and build breaks. Now, let's look at how
    jobs work in Travis.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Travis jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Travis divides the whole build into a collection of stages that will run one
    after another. At each stage, there can be several jobs. All of the jobs in the
    same build will run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve seen before, we can configure tests and static analysis to run in
    parallel, by replacing the `script` section with a `jobs` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates two jobs implicitly in one stage. The stage is named `tests` and
    the jobs are called `"Unit Tests"` and `"Static Analysis"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results appear on the Travis page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4644a76d-718c-4224-ae01-55a00fcfed62.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that, in both cases, as the jobs are independent, they need to build the
    required images. As the unit test job needs to build the `db` image, which takes
    a couple of minutes, it is slower than the static analysis one.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the detailed logs on each job. Note how the environment setting
    and `before_install` actions get executed in all jobs.
  prefs: []
  type: TYPE_NORMAL
- en: This division can not only speed up the build quite dramatically, but it can
    also clarify what the problems are. At a brief glance, you can see that the breaking
    factor was either the unit tests or the static analysis. This removes clutter.
  prefs: []
  type: TYPE_NORMAL
- en: Sending notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Travis CI will send an email to notify the result of a build, but
    only when the build is broken or when a broken build is fixed. This avoids constantly
    sending *success* emails and acts only when action is required. The email is only
    sent to the committer (and the commit author, if different) by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there's a difference between *failed* builds and *errored* builds.
    The latter are failures in the job setup, which means that there's a problem in
    the `before_install`, `install`, or `before_script` sections, while failed builds
    arise because the script part returned a non-zero result. *Errored* builds are
    common while changing Travis configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Travis allows us to configure notification emails and hook up more notification
    systems, including Slack, IRC, or even OpsGenie, which is capable of sending SMS
    messages based on on-call schedules. Check the full documentation here for more
    information: [https://docs.travis-ci.com/user/notifications/](https://docs.travis-ci.com/user/notifications/).'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To take full advantage of our configured CI system, we need to ensure that
    we check the build before merging it into the main branch. To do so, we can configure `master`
    in GitHub as the main branch and add requirements before merging into it:'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure that the `.travis.yaml` file contains the proper credentials if you
    fork the repo. You'll need to update them with your own.
  prefs: []
  type: TYPE_NORMAL
- en: Go to Settings and Branches in our GitHub repo and click Add rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we enable the Require status checks to pass before merging option with
    the status checks from `travis-ci`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2516fab5-583a-48a2-be37-387f168305a1.png)'
  prefs: []
  type: TYPE_IMG
- en: We also select the Require branches to be up to date before merging option.
    This ensures that there are no merges into `master` that haven't been run before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the other possibilities that GitHub offers. In particular, enforcing
    code reviews is advisable to make code to be reviewed before being merged and
    disseminating knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new branch and a new pull request designed to fail static
    tests, we can see how tests are added to GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e488d600-6062-4a6b-8d20-7c7e5a45be61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Details links take you to Travis CI and the specific builds. You can also
    see a history of the builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d635138-eae4-4a5d-9387-7c4c490e4a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the build is finished, GitHub won''t let you merge the pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fec96e7a-1b64-408a-8df3-aea645993129.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The details can be found on the build page in Travis CI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f036c07-0a5a-4372-87a7-8c15e38b626f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fixing the problem and pushing the code will trigger another build. This time,
    it will be successful, and the pull request will be merged successfully. You can
    see how each commit has its own build information, whether it is correct or incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6325f284-fdb6-4df2-b7c4-d0dda7ffe9c5.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now merge into the master branch with confidence that the `master` branch
    won't break when it runs its tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are two builds in the pull request: one for the branch and
    another for the pull request. By default, Travis CI has that configuration. If
    you force it to always create a pull request before merging, the request will
    be redundant, though it can help in some cases when the branch gets pushed before
    creating a pull request. You can enable or disable it in the Travis project configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature that can be configured is automatically canceling
    builds if a newer commit is pushed. This helps to reduce the total number of builds
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Build result can also be checked in the Commits view in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing Docker images from Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After our build creates a Docker image, we need to be able to share it with
    the rest of the team or deploy it. We will use the Docker registry in Docker Hub,
    as explained in the previous chapter, to push the images.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by setting the secret variables.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the secret variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to push to the Docker repo, we first need to configure a password
    to log in to the Docker registry. This needs to be done through the secrets configuration
    in Travis CI, to avoid committing sensible information in the GitHub repo:'
  prefs: []
  type: TYPE_NORMAL
- en: It's worth repeating: **do not commit secrets in your GitHub repo**. These techniques
    can be used for any other required secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `travis` command line using `gem`. This assumes that you have `gem`
    installed on your system (Ruby 1.93 or later). If you don''t, check the installation
    instructions ([https://github.com/travis-ci/travis.rb#installation](https://github.com/travis-ci/travis.rb#installation)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to Travis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a secure variable with the Docker Hub username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to add the encrypted data to the environment variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, note the new `global` section and repeat step 3 with the Docker Hub password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another secure variable, after the first one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation creates two environment variables, available during the builds.
    Do not worry—they will be not shown in the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the proper login command in the `before_install` section so
    that Docker service can connect and push images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next stage is to build and tag the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging and pushing builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code will add a new stage that will build, tag, and finally push
    the result to the Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This first part builds the final image for the server and tags it with the
    name of the branch. To deploy it, we will add a `deploy` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `deploy` section will execute a `script` command when the branch is `master`.
    Now, our build will also generate a final image and push it. This will ensure
    our registry gets the latest version in our main branch.
  prefs: []
  type: TYPE_NORMAL
- en: We can add more `deploy` conditions to push the tag; for example, if we create
    a new Git tag, we can push the resulting image with the proper tag.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that tags, as discussed in the previous chapter, are a way to mark
    an image as significant. Normally, this will mean it's ready for some to be used
    outside automatic tests, for example, in deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the tags to the `deploy` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that here we push whether the branch is the master or there's a defined
    tag, as both conditions won't be matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the full deployment documentation here: [https://docs.travis-ci.com/user/deployment](https://docs.travis-ci.com/user/deployment).
    We''ve covered the `script` provider, which is a way of creating our own commands,
    but offers support for providers such as Heroku, PyPI (in the case of creating
    a Python package), and AWS S3.'
  prefs: []
  type: TYPE_NORMAL
- en: Tagging and pushing every commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to push every single built image to the registry, identified
    by its Git SHA. This can be useful when work in progress can be shared for demo
    purposes, tests, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need to create an environment variable with the Git SHA in the
    `before_install` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `push` section then adds the tag and push of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As this action happens before the `deploy` part, it will be produced on every
    build that reaches this section.
  prefs: []
  type: TYPE_NORMAL
- en: This method will produce a lot of tags. Depending on how your registry manages
    them, that may be costly. Be sure that it is a sensible thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this same approach can be used for other conditional pushes.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the registry needs to be adapted to your own registry details.
    If you clone the example repo, the later will need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented continuous integration practices and explored
    how Docker helps to implement them. We also looked at how to design a pipeline
    that ensures that our code always follows high standards and detects deviations
    as soon as possible. Using Git branches and pull requests in GitHub plays along
    with this, as we can determine when the code is ready to be merged into the main
    branch and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: We then introduced Travis CI as a great tool to work with alongside GitHub to
    achieve continuous integration, and discussed its features. We learned how to
    create a pipeline in Travis CI, from the creation of the `.travis.yml` file, how
    to configure jobs, how to make the build push a validated Docker image to our
    Docker registry, and how to be notified.
  prefs: []
  type: TYPE_NORMAL
- en: We described how to speed up running sections in parallel, as well as how to
    set values as secrets. We also configured GitHub to ensure that the Travis CI
    pipeline has run successfully before merging new code into our main branch.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about basic Kubernetes operations and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does increasing the number of deployments reduce their quality?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe what a pipeline is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we know if our main branch can be deployed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main configuration source for Travis CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When will Travis CI send a notification email by default?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we avoid merging a broken branch into our main branch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we avoid storing secrets in a Git repo?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about continuous integration and other tools, you can check out
    the book *Hands-On Continuous Integration and Delivery* ([https://www.packtpub.com/eu/virtualization-and-cloud/hands-continuous-integration-and-delivery](https://www.packtpub.com/eu/virtualization-and-cloud/hands-continuous-integration-and-delivery)),
    which covers not only Travis CI but other tools such as Jenkins and CircleCI.
    If you want to dig deeper into GitHub and all its possibilities, including how
    to effectively collaborate and the different workflows it enables, find out more
    in *GitHub Essentials* ([https://www.packtpub.com/eu/web-development/github-essentials-second-edition](https://www.packtpub.com/eu/web-development/github-essentials-second-edition)).
  prefs: []
  type: TYPE_NORMAL
