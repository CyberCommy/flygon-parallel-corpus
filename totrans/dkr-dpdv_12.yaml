- en: '10: Docker Swarm'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to install Docker, pull images, and work with containers,
    the next thing we need is a way to work with things at scale. That’s where Docker
    Swarm comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level Swarm has two major components:'
  prefs: []
  type: TYPE_NORMAL
- en: A secure cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An orchestration engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As usual, we’ll split this chapter into the usual three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The TLDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The examples and outputs we’ll use will be from a Linux-based swarm. However,
    most commands and features work with Docker on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Docker Swarm is two things: an enterprise-grade secure cluster of Docker hosts,
    and an engine for orchestrating microservices apps.'
  prefs: []
  type: TYPE_NORMAL
- en: On the clustering front, it groups one or more Docker nodes and lets you manage
    them as a cluster. Out-of-the-box you get an encrypted distributed cluster store,
    encrypted networks, mutual TLS, secure cluster join tokens, and a PKI that makes
    managing and rotating certificates a breeze! And you can non-disruptively add
    and remove nodes. It’s a beautiful thing!
  prefs: []
  type: TYPE_NORMAL
- en: On the orchestration front, swarm exposes a rich API that allows you to deploy
    and manage complicated microservices apps with ease. You can define your apps
    in declarative manifest files, and deploy them with native Docker commands. You
    can even perform rolling updates, rollbacks, and scaling operations. Again, all
    with simple commands.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, Docker Swarm was a separate product that you layered on top of
    the Docker engine. Since Docker 1.12 it’s fully integrated into the Docker engine
    and can be enabled with a single command. As of 2018, it has the ability to deploy
    and manage native swarm apps as well as Kubernetes apps. Though at the time of
    writing, support for Kubernetes apps is relatively new.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm - The Deep Dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll split the deep dive part of this chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Swarm primer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a secure swarm cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy some swarm services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The examples cited will be based on Linux, but they will also work on Windows.
    Where there are differences we’ll be sure to point them out.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm mode primer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On the clustering front, a *swarm* consists of one or more Docker *nodes*. These
    can be physical servers, VMs, Raspberry Pi’s, or cloud instances. The only requirement
    is that all nodes can communicate over reliable networks.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes are configured as *managers* or *workers*. *Managers* look after the control
    plane of the cluster, meaning things like the state of the cluster and dispatching
    tasks to *workers*. *Workers* accept tasks from *managers* and execute them.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration and state of the *swarm* is held in a distributed *etcd* database
    located on all managers. It’s kept in memory and is extremely up-to-date. But
    the best thing about it is the fact that it requires zero configuration — it’s
    installed as part of the swarm and just takes care of itself.
  prefs: []
  type: TYPE_NORMAL
- en: Something that’s game changing on the clustering front is the approach to security.
    TLS is so tightly integrated that it’s impossible to build a swarm without it.
    In today’s security conscious world, things like this deserve all the props they
    get! Anyway, *swarm* uses TLS to encrypt communications, authenticate nodes, and
    authorize roles. Automatic key rotation is also thrown in as the icing on the
    cake! And it all happens so smoothly that you wouldn’t even know it was there!
  prefs: []
  type: TYPE_NORMAL
- en: On the application orchestration front, the atomic unit of scheduling on a swarm
    is the *service*. This is a new object in the API, introduced along with swarm,
    and is a higher level construct that wraps some advanced features around containers.
  prefs: []
  type: TYPE_NORMAL
- en: When a container is wrapped in a service we call it a *task* or a *replica*,
    and the service construct adds things like scaling, rolling updates, and simple
    rollbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level view is shown in Figure 10.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 High-level swarm](images/figure10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 High-level swarm
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough of a primer. Let’s get our hands dirty with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Build a secure Swarm cluster
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section we’ll build a secure swarm cluster with three *manager nodes*
    and three *worker nodes*. You can use a different lab with different numbers of
    *managers* and *workers*, and with different names and IPs, but the examples that
    follow will use the values in Figure 10.2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2](images/figure10-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2
  prefs: []
  type: TYPE_NORMAL
- en: Each of the nodes needs Docker installed and needs to be able to communicate
    with the rest of the swarm. It’ also beneficial if name resolution is configured
    — it makes it easier to identify nodes in command outputs and helps when troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the networking front, you should have the following ports open on routers
    and firewalls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2377/tcp:` for secure client-to-swarm communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`7946/tcp and 7946/udp:` for control plane gossip'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4789/udp:` for VXLAN-based overlay networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve satisfied the pre-requisites, you can go ahead and build a swarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of building a swarm is sometimes called *initializing a swarm*,
    and the high-level process is this: Initialize the first manager node > Join additional
    manager nodes > Join worker nodes > Done.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a brand new swarm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Docker nodes that are not part of a swarm are said to be in *single-engine mode*.
    Once they’re added to a swarm they’re switched into *swarm mode*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 Swarm mode vs single-engine mode](images/figure10-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 Swarm mode vs single-engine mode
  prefs: []
  type: TYPE_NORMAL
- en: Running `docker swarm init` on a Docker host in *single-engine mode* will switch
    that node into *swarm mode*, create a new *swarm*, and make the node the first
    *manager* of the swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Additional nodes can then be *joined* as workers and managers. This obviously
    switches them into *swarm mode* as part of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps will put **mgr1** into *swarm mode* and initialize a new
    swarm. It will then join **wrk1**, **wrk2**, and **wrk3** as worker nodes — automatically
    putting them into *swarm mode*. Finally, it will add **mgr2** and **mgr3** as
    additional managers and switch them into *swarm mode*. At the end of the procedure
    all 6 nodes will be in *swarm mode* and operating as part of the same swarm.
  prefs: []
  type: TYPE_NORMAL
- en: This example will use the IP addresses and DNS names of the nodes shown in Figure
    10.2\. Yours may be different.
  prefs: []
  type: TYPE_NORMAL
- en: Log on to **mgr1** and initialize a new swarm (don’t forget to use backticks
    instead of backslashes if you’re following along with Windows in a PowerShell
    terminal).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`The command can be broken down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker swarm init` tells Docker to initialize a new swarm and make this node
    the first manager. It also enables swarm mode on the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--advertise-addr` is the IP and port that other nodes should use to connect
    to this manager. It’s an optional flag, but it gives you control over which IP
    gets used on nodes with multiple IPs. It also gives you the chance to specify
    an IP address that does not exist on the node, such as a load balancer IP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--listen-addr` lets you specify which IP and port you want to listen on for
    swarm traffic. This will usually match the `--advertise-addr`, but is useful in
    situations where you want to restrict swarm to a particular IP on a system with
    multiple IPs. It’s also required in situations where the `--advertise-addr` refers
    to a remote IP address like a load balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend you be specific and always use both flags.
  prefs: []
  type: TYPE_NORMAL
- en: The default port that swarm mode operates on is **2377**. This is customizable,
    but it’s convention to use `2377/tcp` for secured (HTTPS) client-to-swarm connections.`
  prefs: []
  type: TYPE_NORMAL
- en: '`*   List the nodes in the swarm'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice that **mgr1** is currently the only node in the swarm, and is listed
    as the *Leader*. We’ll come back to this in a second.` `*   From **mgr1** run
    the `docker swarm join-token` command to extract the commands and tokens required
    to add new workers and managers to the swarm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice that the commands to join a worker and a manager are identical apart
    from the join tokens (`SWMTKN...`). This means that whether a node joins as a
    worker or a manager depends entirely on which token you use when joining it. **You
    should ensure that your join tokens are protected, as they are all that is required
    to join a node to a swarm!**` `*   Log on to **wrk1** and join it to the swarm
    using the `docker swarm join` command with the worker join token.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`The `--advertise-addr`, and `--listen-addr` flags optional. I’ve added them
    as I consider it best practice to be as specific as possible when it comes to
    network configuration.` `*   Repeat the previous step on **wrk2** and **wrk3**
    so that they join the swarm as workers. Make sure you use **wrk2** and **wrk3’s**
    own IP addresses for the `--advertise-addr` and `--listen-addr` flags.*   Log
    on to **mgr2** and join it to the swarm as a manager using the `docker swarm join`
    command with the token used for joining managers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`*   Repeat the previous step on **mgr3**, remembering to use **mgr3’s** IP
    address for the `advertise-addr` and `--listen-addr` flags.*   List the nodes
    in the swarm by running `docker node ls` from any of the manager nodes in the
    swarm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5][PRE6][PRE7]`'
  prefs: []
  type: TYPE_NORMAL
