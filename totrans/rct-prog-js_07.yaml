- en: Chapter 7. Not Reinventing the Wheel – Tools for Functional Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at a few out of the many good tools for building
    on top of "bare-metal" JavaScript, as discussed briefly in the last chapter. JavaScript
    is not interesting only for its properties as a core language; browser JavaScript
    is home to an ecosystem, or perhaps multiple ecosystems. Regarding tools for functional
    reactive programming, the total set of offerings represents a good, healthy, and
    sprawling bazaar, next to which the direct use of JavaScript alone for all web
    development looks more like a cathedral. We will be taking a small sample of this
    bazaar, with the understanding that this chapter does not intend to cover all
    that is good, interesting, or worthwhile. That's very hard to do in a bazaar!
  prefs: []
  type: TYPE_NORMAL
- en: 'The tools that we will cover include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ClojureScript and Om
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bacon.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fluxxor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of tools we would include, or not include, in a chapter such as this
    involves drawing lines that are up for, and making judgment calls. Readers interested
    in a more comprehensive treatment can look at the link compendium at [http://tinyurl.com/reactjs-complementary-tools](http://tinyurl.com/reactjs-complementary-tools),
    and drill down to the tools that are of interest to their specific concerns. There
    is a lot there, and probably a lot of gems for almost any purpose.
  prefs: []
  type: TYPE_NORMAL
- en: ClojureScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ClojureScript, and perhaps Clojure in general, represents an important watershed
    in software and web development. ClojureScript proves by example that it is possible
    to have a solid foundation and environment for development in a language other
    than JavaScript, and this pioneering language is a Lisp dialect. (This is fitting
    perhaps, for one of the two oldest programming languages in common use. Lisp was
    good when it came out, and it's still a good language today.) Furthermore, Lisp
    may enjoy a good advantage compared to JavaScript, and be alive due to some of
    the same reasons. JavaScript is the language of web browsers and Lisp is the language
    of Emacs. Also, Lisp offers a sort of proto-JavaScript; before there were web
    browsers that were programmable in JavaScript, there were Emacsen programmable
    in Lisp, and someone who said Lisp was the better language in comparison to JavaScript
    would hardly be contested.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is good reason to suggest that Lisp, and not the Emacs default key bindings,
    is responsible for the classical Emacs learning curve in this "classical learning
    curves" cartoon that has been floating around on the Internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ClojureScript](img/B04148_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As suggested in an earlier chapter, the uniformity of everybody programming
    directly in JavaScript may give way to a beautiful diversity, or a patchwork quilt.
    In this beautiful patchwork quilt, JavaScript may still be pre-eminent, but JavaScript's
    pre-eminence may serve as the new "bare metal." We may have a collection of high-level
    languages and tools for frontend development. Again, as Alan Perlis said, "A language
    is low-level when it requires attention to the irrelevant." On those grounds,
    JavaScript is low-level.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these tools may have a better portfolio of good parts with respect to
    the bad parts. They may lend themselves to frontend work that may still finally
    be executed in JavaScript. But they may also open up frontend web development
    in which new developers are no longer told, "Here is the language that we will
    use, and here are some large portions of the language that you should try to avoid
    as much as possible because they are fundamentally toxic." Newer versions of ECMAScript
    (the formal name for JavaScript, and it is not particularly connected to Emacs)
    may offer better collections of features, but it is still desirable to work in
    high-level languages that offer a better terrain for productive work and results.
  prefs: []
  type: TYPE_NORMAL
- en: ClojureScript says, with bells on, that it is possible to have a good high-level
    language that will run on browsers, and this isn't good news only for Lisp hackers.
    It is good news for everyone. It demonstrates an open door to the possibility
    of web development in other high-level languages and potentially a better web
    development environment with fewer tar pits.
  prefs: []
  type: TYPE_NORMAL
- en: 'ClojureScript can be used both for client-side work and on the server side
    with Node.js. *Hello, World!* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Om
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Om is a wrapper that makes ReactJS available for ClojureScript. Apart from the
    fact that ClojureScript is usually fast, a certain part of Om is actually about
    two times faster than in JavaScript. The difference has to do with identifying
    changes so as to optimally and appropriately update the DOM when ReactJS does
    that. The reason is that ReactJS, in its diffing algorithm (by dealing with mutable
    JavaScript data structures), has to perform a deep comparison to see what, if
    anything, in the (pure JavaScript) synthetic virtual DOM has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is still lightning fast compared to direct DOM manipulations, so fast
    that it''s really not the bottleneck for most ReactJS users. But it''s faster
    in Om. The reason is that ClojureScript, like a good functional programming language,
    has immutable data. You can easily enough get a mutated copy of something, but
    you cannot tamper with the original or trip up anyone who has access to the original.
    This means that Om can get by with only comparing top-level references and not
    digging into the depths of data structures. This is enough to make Om faster than
    the original JavaScript use of ReactJS. *Hello, World!* in Om is written like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Bacon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that discussing ReactJS and Bacon.js alone does not qualify as an exhaustive
    list. To mention one alternative suite, Microsoft has tried to create RxJS, RxCpp
    [Rx for C++], Rx.NET, and Rx* for various JavaScript frameworks and libraries,
    and they've at least tried to make a polyglot-friendly portfolio for multiple
    languages and optimized versions for multiple JavaScript frameworks and libraries.
    There is really a lot available that offers some form of functional reactive programming.
    And while most of the few (at the time of writing this book) functional reactive
    programming and ReactJS resources on the Web are golden, there are some that aren't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Andre Stalz writes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"So you''re curious in learning this new thing called Reactive Programming,
    particularly its variant comprising of Rx, Bacon.js, RAC, and others.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning it is hard, even harder by the lack of good material. When I started,
    I tried looking for tutorials. I found only a handful of practical guides, but
    they just scratched the surface and never tackled the challenge of building the
    whole architecture around it. Library documentations often don''t help when you''re
    trying to understand some function. I mean, honestly, look at this:*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rx.Observable.prototype.flatMapLatest(selector, [thisArg])*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Projects each element of an observable sequence into a new sequence of observable
    sequences by incorporating the element''s index and then transforms an observable
    sequence of observable sequences into an observable sequence producing values
    only from the most recent observable sequence."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I now understand what the quotation is saying, but that's because I've learned
    from other resources that have communicated better. Part of the intent behind
    this book you are reading is to make good documentation a little less difficult
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a famous question in the open source community: would you buy a car
    with the hood welded shut? ReactJS can be described as a car that most people
    can drive without opening the hood. It''s not that ReactJS is closed-source, or
    that Facebook shows any signs of making it harder to read as much of the source
    code as you want. But to pick one salient example, **Denotative continuous-time
    semantics** was part of Conal Elliott''s second thoughts about what would be a
    better name for what is now called functional reactive programming. Whether one
    agrees or disagrees with his suggestion for a better and more descriptive name,
    such second thoughts from a leading light can be very insightful and illuminating.
    And with ReactJS, if it''s working correctly, a novice programmer can be given
    the same explanation that Calvin''s father (a patent attorney!) in Calvin and
    Hobbes gives when Calvin asks how a lamp, or a vacuum cleaner, works—*It''s magic!*
    Looking at a newcomer''s question, "How is continuous time handled?" the reply
    is *It''s magic!* "How can you get away with discarding and recreating the DOM
    every single time?"—*It''s magic!*; "But how does ReactJS achieve an astonishing
    60 fps on a non-JIT iPhone?"—*It''s magic!*'
  prefs: []
  type: TYPE_NORMAL
- en: Functional reactive programming describes certain tasks that need to be accomplished,
    such as the appropriate handling of event streams, but the ReactJS documentation
    doesn't seem to explain how to address this handling because the responsibility
    is offloaded to ReactJS; *It's magic!*
  prefs: []
  type: TYPE_NORMAL
- en: Not only does Bacon.js not weld the hood shut, but you are also expected to
    tinker under the hood. Bacon.js seems closer to the roots of basic functional
    reactive programming. Some programmers, intending to work in ReactJS, might find
    it profitable to "lift weights" a bit and strengthen themselves with Bacon.js.
    One significant area of functional reactive programming is dealing with emitted
    streams of events, and as far as ReactJS goes, *It's magic!*
  prefs: []
  type: TYPE_NORMAL
- en: In Bacon.js, it is in fact not magic that all is done without you ever moving
    a finger; it is something that the programmer needs to work out, and they are
    given good tools to do so. On these grounds, it could help form a developer for
    a solid reactive programming foundation to use ReactJS. If the selling point of
    ReactJS is that it is a tool optimized to allow good user interface work while
    drawing on the strengths of functional reactive programming, the selling point
    of Bacon.js is that it is a tool in JavaScript that is optimized for (learning
    and) performing solid functional reactive programming in theory and practice as
    a whole.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between ReactJS and Bacon.js doesn't seem to be a matter of unearthing
    that one framework is simply better than the other. It is rather a matter of taking
    stock of what you want to do and accomplish, recognizing that ReactJS and Bacon.js
    (besides being worthy competitors) have different areas where they really shine,
    and deciding whether your work sounds more like a ReactJS sweet spot or a Bacon.js
    sweet spot. Moreover, with respect to the topic of sweet spots, Bacon.js (unlike
    ReactJS) has a name meant to make your mouth water, and the `~` functional operator
    is called "bacon" in the references.
  prefs: []
  type: TYPE_NORMAL
- en: Brython – a Python browser implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brython ([http://brython.info](http://brython.info)), a browser and Python implementation,
    is another example of an alternative to programming a browser in JavaScript, and
    while it would be a bit unfair to Brython to call it merely experimental, it is
    also not necessarily appropriate to call it mature—certainly not in the same sense
    that ClojureScript has some significant maturity. ClojureScript is developed well
    enough to essentially replace "bare metal" JavaScript for a frontend developer
    who'd really prefer to use Lisp rather than JavaScript. In other words, unless
    we are talking about something performance-critical or possibly special cases,
    there aren't too many cases where ClojureScript experts would answer the question,
    "How do I do this in ClojureScript?" with, "Use JavaScript directly for this kind
    of problem." Brython is included not because the sun rises or sets on Python but
    as an illustration that Lisp in ClojureScript is not a fundamental exception in
    terms of being the only non-JavaScript language that works for frontend web development,
    but perhaps the first of many.
  prefs: []
  type: TYPE_NORMAL
- en: Brython is meant for world domination. Its home page boldly announces, "Brython
    is intended to replace JavaScript as the scripting language for the Web," and
    it will, perhaps, never reach that quite naïve goal. Brython takes surprisingly
    long to load and is slow to run after it has loaded. It may be better to use one
    of the Python-to-JavaScript compilers (which would be closer to ClojureScript),
    but Brython really offers quite a lot of Python's goodness and may be someday
    be seen as significant. Yet, I would suggest that it is silly to try to be the
    next JavaScript and take the place of every other transpiler that renders JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Brython, the goal of world domination also lends itself to a blind spot:
    failing to see how important it is to be able to interoperate with tools written
    in other languages. But the good news is that Brython or other Python-to-JavaScript
    approaches may be significant without needing to become the "One Language to Rule
    Them All." Python is hardly the only backend language available, but it''s a good
    player, and there is every reason for good implementations of Python to be worthwhile
    players in a patchwork quilt composed of multiple languages that can all be used
    profitably for frontend web development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, at least a *Hello,World!* program with ReactJS is straightforward
    to implement in Brython. A *Hello, World!* program, as run after gathering Brython
    and ReactJS on a page, includes first JavaScript (not JSX) commented out, and
    then the Python code that calls React in the browser via Brython:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays what is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Brython – a Python browser implementation](img/B04108_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the entire first script tag and contents, and not just the JavaScript
    inside them, are in an HTML comment. This means that the first (JavaScript) script,
    shown here for clarity, is not active, the second (Python) script being the one
    that runs and displays its message.
  prefs: []
  type: TYPE_NORMAL
- en: The second script is an interesting one; the included Python code is equivalent
    (apart from the message) to the commented-out JavaScript text and does the same
    thing. This is quite a feat, especially when combined with how Brython successfully
    implements most features in the 3.x branch of Python. Even if Brython is looked
    into for a project and deemed not the right solution, it remains an achievement.
  prefs: []
  type: TYPE_NORMAL
- en: In one sense, Brython is presented here as an example of a possibility rather
    than, in any sense, the only member of its class that is worth attention. The
    point is not specifically that Python can be used for frontend development; it's
    that ClojureScript Lisp may not be the only additional language besides JavaScript
    that is available for use in frontend development.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable.js – permanent protection from change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutable.js, with its home page at [http://facebook.github.io/immutable-js](http://facebook.github.io/immutable-js)
    and a tagline of **Immutable collections for JavaScript**, was originally named
    for persistence. Then it went through a name change to something that would register
    more quickly by referring to the immutable. Immutable.js plugs a gap in JavaScript
    as a functional language and offers significantly more functional-friendly data
    structures for collections (which is the point for which it was created).
  prefs: []
  type: TYPE_NORMAL
- en: It offers data structures for collections that are immutable. They support the
    creation of modified copies gracefully enough, but it is always the copy that
    is changed, never the original. Though this is more of a minor point, it greatly
    reduces the need for "defensive copying" and related workarounds for not using
    immutable data where there are multiple programmers. The original code could be
    chugging along with a different and modified copy of the data structure that you
    want, but your copy, which you have kept as a reference, is guaranteed to be entirely
    untouched. The library is intended to support other niceties, such as easy conversion
    to and from staple JavaScript data structures.
  prefs: []
  type: TYPE_NORMAL
- en: However, data structures of Immutable.js are not only immutable; they are also
    lazy in some aspects, and the document clearly marks which aspects of an application
    are eager. (as a reminder, lazy data structures are treated in a print-on-demand
    fashion when needed, while eager operations are done at once and upfront). Furthermore,
    certain functional idioms are baked into Immutable.js facilities. For instance,
    there is a .`take(n)` method offered. It returns the first *n* items of a list
    in the classic functional fashion. Other functional staples, such as `map()`,
    `filter()`, and `reduce()`, are also available. In general, runtime complexity
    is as good as a computer scientist could reasonably request.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several data types provided by Immutable.js; these include the following
    (the descriptions in this and the next table are partly based on the official
    documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Immutable.js class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Collection` | This is an abstract base class for Immutable.js data structures.
    It cannot be directly instantiated. |'
  prefs: []
  type: TYPE_TB
- en: '| `IndexedCollection` | A collection that represents indexed values in a particular
    order. |'
  prefs: []
  type: TYPE_TB
- en: '| `IndexedIterable` | This is an iterable with indexed numeric keys that support
    some array-like interface features, such as `indexOf()` (An iterable is something
    that you can iterate through like a list, but it may or may not be a list in the
    internals). |'
  prefs: []
  type: TYPE_TB
- en: '| `IndexedSeq` | A `Seq` that supports an ordered indexed list of values. |'
  prefs: []
  type: TYPE_TB
- en: '| `Iterable` | A set of (key and index) values that can be iterated through.
    This class is the base class for all collections. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyedCollection` | A collection that represents key-value pairs. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyedIterable` | An iterable with discrete keys tied to each iterable. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyedSeq` | A sequence that represents key-value pairs. |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | An ordered collection, somewhat like a (dense) JavaScript array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Map` | A keyed iterable of key-value pairs. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderedMap` | A map that does everything that a map does and, in addition,
    guarantees that iterations will produce keys in the order in which they are set.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderedSet` | A set that does everything that a set does and, in addition,
    guarantees, that iterations will produce values in the order in which they are
    set. |'
  prefs: []
  type: TYPE_TB
- en: '| `Record` | A class that produces concrete records. Conceptually, this is
    different from the other records here. The other elements are, conceptually, collections
    of "whatnots," perhaps objects that have a similar structure. The `Record` class
    is closer to the records one encounters in school, where one record is similar
    to a row in a database table, while result sets or tables are more like container
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq` | A sequence of values, which may or may not be backed by a concrete
    data structure. |'
  prefs: []
  type: TYPE_TB
- en: '| `Set` | A collection of unique values. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetCollection` | A collection of values without keys or indices. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetIterable` | Iterables representing values without keys or indices. |'
  prefs: []
  type: TYPE_TB
- en: '| `SetSeq` | A sequence representing a set of values. |'
  prefs: []
  type: TYPE_TB
- en: '| `Stack` | A standard stack with `push()` and `pop()`. Semantics always go
    to first element, unlike JavaScript arrays. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Record` is slightly different from the others; it is similar to a JavaScript
    object that meets certain criteria. The other elements are related container classes
    that provide functional access to some collection of objects and tend to have
    a similar list of methods supported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods for List, to pick one example, include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Immutable.List method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `asImmutable` | A function that takes a (mutable) JavaScript collection and
    renders an Immutable.js collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `asMutable` | This is a concession to "not-the-best" programming. The proper
    way to handle mutations based on an Immutable.js collection is to use with Mutations.
    Even if `asMutable` is available, it should only be used inside of functions and
    never be made available or returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `butLast` | This produces a similar new List, but it lacks the last entry.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` | Concatenate (that is, append) two iterables of the same type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `contains` | This is true if the value exists in this List. |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Return the size of this List. |'
  prefs: []
  type: TYPE_TB
- en: '| `countBy` | Group the List''s contents with a grouper function, and then
    emit counts for the keys as partitioned by the grouper. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete` | Create a new List without this key. |'
  prefs: []
  type: TYPE_TB
- en: '| `deleteIn` | Remove a key from a keypath, which allows traversal from an
    outer collection to an inner collection, much like the way a filesystem path allows
    traversal of the filesystem from an outer directory to an inner directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `entries` | An iteration of the List as `key`, `value tuples`. |'
  prefs: []
  type: TYPE_TB
- en: '| `entrySeq` | Create a new `IndexedSeq` of key, value tuples. |'
  prefs: []
  type: TYPE_TB
- en: '| `equals` | This is a full equality comparison. |'
  prefs: []
  type: TYPE_TB
- en: '| `every` | This is true if a predicate is true for all entries in this List.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `filter` | Returns the elements of a List for which the provided predicate
    holds true. |'
  prefs: []
  type: TYPE_TB
- en: '| `filterNot` | Returns the elements of a List for which the provided predicate
    returns false. |'
  prefs: []
  type: TYPE_TB
- en: '| `find` | Returns the value for which the provided predicate holds true. |'
  prefs: []
  type: TYPE_TB
- en: '| `findIndex` | Returns the first index for which the provided predicate holds
    true. |'
  prefs: []
  type: TYPE_TB
- en: '| `findLast` | Returns the last element for which the provided predicate holds
    true. |'
  prefs: []
  type: TYPE_TB
- en: '| `findLastIndex` | Returns the last index for which the provided predicate
    holds true. |'
  prefs: []
  type: TYPE_TB
- en: '| `first` | The first value in the List. |'
  prefs: []
  type: TYPE_TB
- en: '| `flatMap` | This flat-maps, or collapses, a potential List of Lists into
    a List that is one deep. |'
  prefs: []
  type: TYPE_TB
- en: '| `flatten` | This flattens nested iterables. |'
  prefs: []
  type: TYPE_TB
- en: '| `forEach` | Executes a function for each entry in the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `fromEntrySeq` | Return a `KeyedSeq` of any iterable of the key, value tuples.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get` | Returns the value for a key. |'
  prefs: []
  type: TYPE_TB
- en: '| `getIn` | Traverses a key path (like a filesystem path) to get a key, if
    available. |'
  prefs: []
  type: TYPE_TB
- en: '| `groupBy` | Converts a List into a List of Lists keyed by the grouping of
    a provided grouper function. |'
  prefs: []
  type: TYPE_TB
- en: '| `has` | This is true if a key exists in this List. |'
  prefs: []
  type: TYPE_TB
- en: '| `hashCode` | This calculates a hash code for this collection. It is appropriate
    for use in a hash table. |'
  prefs: []
  type: TYPE_TB
- en: '| `hasIn` | This is true if a collection''s equivalent to a filesystem walk
    finds the value in question. |'
  prefs: []
  type: TYPE_TB
- en: '| `indexOf` | The index of the first occurrence in this List, for example,
    `Array.prototype.indexOf`. |'
  prefs: []
  type: TYPE_TB
- en: '| `interpose` | Interpose a separator between individual List entries. |'
  prefs: []
  type: TYPE_TB
- en: '| `interleave` | Interleave the provided Lists into one list of the same type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isEmpty` | This tells whether this iterable has values or not. |'
  prefs: []
  type: TYPE_TB
- en: '| `isList` | This is true if the value is a List. |'
  prefs: []
  type: TYPE_TB
- en: '| `isSubset` | True if every value in the comparison iterable is in this List.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isSuperset` | True if every value in this List is in the comparison iterable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `join` | This joins together as a string with a separator (default). |'
  prefs: []
  type: TYPE_TB
- en: '| `keys` | An iterator of this List''s keys. |'
  prefs: []
  type: TYPE_TB
- en: '| `keySeq` | Returns a `KeySeq` for this iterable, discarding all values. |'
  prefs: []
  type: TYPE_TB
- en: '| `last` | The last value in the List. |'
  prefs: []
  type: TYPE_TB
- en: '| `lastIndexOf` | Returns the last index at which a value can be found in this
    List. |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | The constructor for lists. |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | Returns a new List with values passed through a map function. |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | Returns the maximum value in this collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `maxBy` | This is like max, but with more fine-grained control. |'
  prefs: []
  type: TYPE_TB
- en: '| `merge` | Merges iterables or JavaScript objects into one List. |'
  prefs: []
  type: TYPE_TB
- en: '| `mergeDeep` | A recursive analog to merge. |'
  prefs: []
  type: TYPE_TB
- en: '| `mergeDeepIn` | Performs a deep merge, starting at a given keypath. |'
  prefs: []
  type: TYPE_TB
- en: '| `mergeDeepWith` | This is like `mergeDeep`, but uses a provided merger function
    when nodes conflict. |'
  prefs: []
  type: TYPE_TB
- en: '| `mergeIn` | This is a combination of update and merge. It performs a merger
    at a specified keypath. |'
  prefs: []
  type: TYPE_TB
- en: '| `mergeWith` | This is like merge, but uses a provided merger function when
    nodes conflict. |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | Returns the minimum value in the List. |'
  prefs: []
  type: TYPE_TB
- en: '| `minBy` | Returns the minimum value in the List as determined by a helper
    function you provide. |'
  prefs: []
  type: TYPE_TB
- en: '| `of` | Creates a new list containing its arguments as values. |'
  prefs: []
  type: TYPE_TB
- en: '| `pop` | This returns everything in this List but the last. Note that this
    differs from the standard push semantics, but a regular `push()` can be simulated
    by calling `last()` before `push()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `push` | Returns a new list with the specified value (or values) appended
    at the end. |'
  prefs: []
  type: TYPE_TB
- en: '| `reduce` | Calls the reducing function for every value and returns the accumulated
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `reduceRight` | This is similar to reduce, but starts at the right and moves
    progressively to the left, the opposite of the basic reduce. |'
  prefs: []
  type: TYPE_TB
- en: '| `rest` | Returns the tail of a List, that is, all entries but the first.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse` | Provides a List in reverse order. |'
  prefs: []
  type: TYPE_TB
- en: '| `set` | Returns a new List with the value at the index. |'
  prefs: []
  type: TYPE_TB
- en: '| `setIn` | Return a new List with this value at the keypath. |'
  prefs: []
  type: TYPE_TB
- en: '| `setSize` | Creates a new List with the size that you specify, truncating
    or adding undefined values as needed. |'
  prefs: []
  type: TYPE_TB
- en: '| `shift` | Creates a new list with the first value subtracted and all other
    values shifted down. |'
  prefs: []
  type: TYPE_TB
- en: '| `skip` | Returns all that is left of the List when the first *n* entries
    are not included. |'
  prefs: []
  type: TYPE_TB
- en: '| `skipLast` | Returns all that is left of the List when the last n entries
    are not included. |'
  prefs: []
  type: TYPE_TB
- en: '| `skipUntil` | Returns a new iterable containing all entries after the first
    where a provided predicate is true. |'
  prefs: []
  type: TYPE_TB
- en: '| `skipWhile` | This returns a new iterable containing all entries before a
    provided predicate is false. |'
  prefs: []
  type: TYPE_TB
- en: '| `slice` | Returns a new iterable containing this list''s contents from the
    start value to one before the last, inclusive. |'
  prefs: []
  type: TYPE_TB
- en: '| `some` | True if a predicate returns true for any element of the List. |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | Returns a new List sorted by an optional comparator. |'
  prefs: []
  type: TYPE_TB
- en: '| `sortBy` | Returns a new List sorted by an optional comparator value mapper,
    with more detailed information available for the comparator and therefore more
    refined results. |'
  prefs: []
  type: TYPE_TB
- en: '| `splice` | Replaces a segment of the first list with the second, or deletes
    it if no second list is provided. |'
  prefs: []
  type: TYPE_TB
- en: '| `take` | Creates a new List containing exactly the first n entries in a List.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `takeLast` | Creates a new List containing exactly the last *n* entries in
    a List. |'
  prefs: []
  type: TYPE_TB
- en: '| `takeUntil` | This returns a new List containing all entries as long as the
    predicate returns false; then it stops. |'
  prefs: []
  type: TYPE_TB
- en: '| `takeWhile` | This returns a new List containing all entries as long as the
    predicate returns true; then it stops. |'
  prefs: []
  type: TYPE_TB
- en: '| `toArray` | Shallowly converts this List to an Array, discarding the keys.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toIndexedSeq` | Return an `IndexedSeq` of this List, discarding the keys.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toJS` | Deeply converts this List into an Array. This method has `toJSON()`
    as an alias, although the documentation does not clearly state whether or not
    `toJS()` returns JavaScript objects, while `toJSON()` returns a JSON-encoded string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toKeyedSeq` | Returns a `KeyedSeq` from this List where indices are treated
    as keys. |'
  prefs: []
  type: TYPE_TB
- en: '| `toList` | Returns itself. |'
  prefs: []
  type: TYPE_TB
- en: '| `toMap` | Converts this List into a Map. |'
  prefs: []
  type: TYPE_TB
- en: '| `toObject` | Shallowly converts this List into an Object. |'
  prefs: []
  type: TYPE_TB
- en: '| `toOrderedMap` | Convert this List into a Map, preserving the order of iteration.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toSeq` | Returns an `IndexedSeq`. |'
  prefs: []
  type: TYPE_TB
- en: '| `toSet` | Converts this List to a Set, discarding the keys. |'
  prefs: []
  type: TYPE_TB
- en: '| `toSetSeq` | Converts this List to a `SetSeq`, discarding the keys. |'
  prefs: []
  type: TYPE_TB
- en: '| `toStack` | Convert this List to a Stack, discarding the keys. |'
  prefs: []
  type: TYPE_TB
- en: '| `unshift` | Prepend the provided values to a List. |'
  prefs: []
  type: TYPE_TB
- en: '| `update` | Update an entry on a List by a provided updater function. |'
  prefs: []
  type: TYPE_TB
- en: '| `updateIn` | Update an entry, as in update(), but at a given key path. |'
  prefs: []
  type: TYPE_TB
- en: '| `values` | An iterator of this List''s values. |'
  prefs: []
  type: TYPE_TB
- en: '| `valueSeq` | An `IndexedSeq` of this List''s values. |'
  prefs: []
  type: TYPE_TB
- en: '| `withMutations` | This is an optimization (recall "Premature optimization
    is the root of all evil," said by Donald Knuth) hook meant to allow more performant
    work when multiple mutations are performed. It is to be used when there are known
    and persistent performance issues where other tools have demonstrably not solved
    the problem. |'
  prefs: []
  type: TYPE_TB
- en: '| `zip` | Returns an iterable zipped (that is, joined pairwise to make a list
    of 2-tuples) with this List. |'
  prefs: []
  type: TYPE_TB
- en: '| `zipWith` | Returns an iterable zipped with a custom zipping function. |'
  prefs: []
  type: TYPE_TB
- en: The documentation for the API, which is under the **Documentation** link available
    on the home page, is pretty clear. But as a rule, Immutable.js collections do
    what a functional programmer would expect them to do as much as possible, and
    indeed there appears to be a presumable overriding design consideration of "do
    what a functional programmer would want as much as we can."
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing that might be an unpleasant surprise to functional programmers is
    that the documentation does not explain how to create infinite lists. It is not
    obvious how one might create a generator for a list (if they do so at all), or
    produce lists of mathematical sequences, such as all counting all numbers, positive
    even numbers, squares, primes, Fibonacci numbers, powers of 2, factorials, and
    so on. Such functionality is apparently not supported (at the time of writing
    this book). Lazy sequences cannot build infinite lists with Immutable.js because
    constructing a collection includes an eager inclusion of all elements ever in
    the list, which must therefore be finite. It shouldn't be terribly difficult to
    create lazy, and potentially infinite, data structures in the style of Immutable.js
    that have a memoized generator inside and allow you to XYZ.take(5). But Immutable.js
    appears not to have expanded into that territory yet.
  prefs: []
  type: TYPE_NORMAL
- en: Jest – BDD unit testing from Facebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest is a JavaScript unit testing framework intended to support behavior-driven
    development. It is built on top of Jasmine, and in the future, it may be able
    to interact with other foundations. It has been used for a couple of years and
    is used on Facebook, though there appears to be no decisive endorsement that ReactJS
    development is best done using Jest. (Facebook uses JSX with ReactJS internally
    but tends to make a relatively unopinionated statement that about half of ReactJS
    users opt to use JSX. It is actually designed to be entirely optional.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JSX—the *X* boldly meaning XML at a time when XML has fallen out of favor—is
    a well-made syntactic sugar that "puts angle brackets in your code." This loosely
    means that you can put HTML into your JavaScript in `.jsx` files and things just
    work. Also, you can use almost anything that you can build on a page that has
    been built into a ReactJS component. You can include things such as images that
    have been part of HTML from the beginning, and you can just as easily include
    a calendar as defined in this title, a threaded networked discussion, or a draggable
    and zoomable fractal. Like subroutines, once a component is defined, it can be
    used zero, one, or many times anywhere in your web app. The JSX syntactic sugar
    allows components that you and others have defined as easily as old HTML tags.
    The JSX for the outer shell in the project in chapters 8 to 11 is "dirt simple"
    in terms of allowing us to incorporate the other components that we have developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One Facebook employee said that he had made Jest open source for "selfish reasons,"
    namely that he wanted to use it in his personal projects. This may give a good
    hint about why Jest is at least worth considering. It is nice enough for at least
    one user to really want to use Jest, so much so that he was willing to make proprietary
    intellectual property open source, and did this even when no one told him to.
  prefs: []
  type: TYPE_NORMAL
- en: It is arguable that in its beginnings, unit testing has served what is most
    easily unit tested, which means that unit testing has washed its hands of integration
    and user interface testing. So, you might see a blog article on unit testing that
    tests and confirms a "red, green, refactor" approach to a function that converts
    your language's integers to Roman numerals, which is a pretty good example of
    a problem that serves the needs of primitive unit testing. If you want to test
    whether your code is interacting with its database appropriately, that's a slightly
    taller order. And Jest, like other frameworks, doesn't really have which is pretensions
    of obviating the need for good, old-fashioned budget usability testing as Jakob
    Nielsen and others advocate. There is an old (pre-IT) business distinction between
    asking, "Are we building the product right?" and "Are we building the right product?"
  prefs: []
  type: TYPE_NORMAL
- en: Both of these questions are valuable and have their place, but unit testing
    helps more with the first than the second, and it is dangerous to let a good test
    suite that addresses the first question well lull you to sleep which is regarding
    addressing the second question well. Nonetheless, Jest offers something more useful
    than just testing whether a unit of code will successfully take input of a primitive
    data type, such as an integer, a float, or a string, and return the correct and
    expected output of a primitive data type (such as the right Roman numeral for
    an input integer). Though this is not true only for Jest, Jest simulates the user
    interface so as to support (for instance) user interface events, such as clicks
    on an element, and supports testing user interface changes, such as the text on
    a label (compare the Jasmine home page, where the first several examples involve
    assertions using primitive data types only).
  prefs: []
  type: TYPE_NORMAL
- en: Jest is intended to provide layers on top of Jasmine (and potentially other
    backends in the future), but with significant added value. Besides certain features,
    such as running tests in parallel so that testing becomes more responsive, Jest
    is a solution intended to require a minimum amount of time and fuss to get good
    test coverage, based on the thought that it is desirable for developers to spend
    most of their time on their main development and not on writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest is intended to mock everything, or almost everything, pulled in with `require()`.
    You can opt out for individual elements by calling `jest.dontMock()`, and it is
    boilerplate practice that tests usually call `jest.dontMock()` for the components
    that they are testing. It automatically finds and runs tests in the `__tests__`
    directory. Jest can handle JSX if ReactJS''s preprocessor is included in, for
    example, `preprocessor.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `package.json` file needs to be told what to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we will lightly adapt Facebook's example. Facebook provides an example `CheckboxWithLabel`
    class. This class displays one label when the checkbox is unchecked and another
    when it is checked. The Jest unit test here simulates a click and confirms that
    the label changes appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CheckboxWithLabel.js` file reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__tests__/CheckboxWithLabel-test.js` test file reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the Flux Architecture using Fluxxor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in earlier chapters, Flux is an architecture that was developed
    by Facebook and used by them as something largely complementary to ReactJS. It
    helped untangle a genuine rat's nest of crossed wires and let Facebook eradicate
    a recurrent message count bug that kept coming back—the Flux Architecture killed
    it permanently. **Fluxxor**, by Brandon Tilley ([http://fluxxor.com](http://fluxxor.com)),
    is a tool intended to help people implement the Flux Architecture in their applications.
    There is no need to use the Flux Architecture in order to use ReactJS, or use
    the Fluxxor tool to implement the Flux Architecture. But Flux, and perhaps Fluxxor,
    is at least worth considering to make things easier.
  prefs: []
  type: TYPE_NORMAL
- en: Fluxxor has classes for the Flux Architecture overall, including a `Fluxxor.Flux`
    container (which includes a dispatcher) and `Action` and `Store` classes. The
    sample code was concise and readable and seemed to have little boilerplate. Two
    ReactJS-friendly mixin classes are provided for ease of use. Sample code is written
    using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: I might also comment with reference to Fluxxor's author that [http://fluxxor.com](http://fluxxor.com)
    has a link at the bottom of the page asking people to report an issue on GitHub
    if something is unclear or if there is an issue. I noticed a common usability
    defect—visited and unvisited links being the same color—and reported the issue
    on GitHub. The author apologized immediately, and the issue I opened was *Closed
    fixed* within no more than 15 minutes. I think he is the kind of person one likes
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's see what we covered in this chapter. We explained Om and ClojureScript,
    which allow Lisp-based development that takes advantage of ReactJS's abilities.
    It is said that ClojureScript may be the leading light of solutions that allow
    a beautiful patchwork of different languages that are usable for frontend development,
    compiling, or interpreting JavaScript as the new "bare metal."
  prefs: []
  type: TYPE_NORMAL
- en: Bacon.js is a very respectable technology that competes with ReactJS that allows
    good functional reactive programming in the browser. This is presented, not as
    the "one and only" good example, but as an example of good stuff that is beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered Brython, a browser-based Python environment. It is not perfect
    but interesting. It is highlighted as an example of what can be used as a language
    outside of Lisp other than JavaScript for web development. As a reminder, [http://tinyurl.com/reactjs-compiled-javascript](http://tinyurl.com/reactjs-compiled-javascript)
    offers a directory of other languages that compile to JavaScript or can be interpreted
    in a web browser, ranging from syntactic sugar such as CoffeeScript to JavaScript
    extensions to separate languages such as Ruby, Python (including Brython), Erlang,
    Perl, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable.js plugs a hole in functional JavaScript by providing mainly collections
    that allow copy-on-mutate without disrupting the functional advantages of immutable
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Jest is a behavior-driven development JavaScript unit testing framework that
    is used by Facebook for ReactJS. Fluxxor is an implementation of controllers,
    actions, and stores intended to make it easier to apply the Flux Architecture
    to JavaScript development, including ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: Join us in the next chapter as we explore a more in-depth example using ReactJS.
  prefs: []
  type: TYPE_NORMAL
