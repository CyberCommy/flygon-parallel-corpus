- en: Scanning and Evasion Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe the process of discovering devices on a target
    network using various tools in Kali Linux, as well as other tools available from
    GitHub. We will be looking into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A description of the target-discovery process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method used to identify target machines using the tools in Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The steps required to find the operating systems of the target machines (operating
    system fingerprinting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated scanning with Striker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymization with Nipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help you understand these concepts easily, we will use a virtual network
    as the target network.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimal hardware requirements: 6 GB RAM, quad-core 2.4 GHz processor, and 500
    GB HDD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux 2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtual machine for testing, for example, Metasploitable or BadStore, and
    so on. (Refer to [Chapter 2](573e3579-5017-4c33-acd8-01e866ed66d8.xhtml), *Setting
    Up Your Test Lab*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the target machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools included in this category are used to identify the target machines
    that can be accessed by a penetration tester. Before we start the identification
    process, we need to know our client's terms and agreements. If the agreements
    require us to hide penetration-testing activities, we need to conceal our activities.
    Stealth techniques may also be applied for testing the **Intrusion Detection System**
    (**IDS**) or **Intrusion Prevention System** (**IPS**) functionality. If there
    are no such requirements, we may not need to conceal our penetration-testing activities.
  prefs: []
  type: TYPE_NORMAL
- en: ping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ping` is the most famous tool that is used to check whether a particular host
    is available. The `ping` tool works by sending an **Internet Control Message Protocol**
    (**ICMP**) echo request packet to the target host. If the target host is available
    and the firewall is not blocking the ICMP echo request packet, it will reply with
    the ICMP echo reply packet.'
  prefs: []
  type: TYPE_NORMAL
- en: The ICMP echo request and ICMP echo reply are two of the available ICMP control
    messages. For other ICMP control messages, you can refer to the following URL: [https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Control_messages](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Control_messages).
  prefs: []
  type: TYPE_NORMAL
- en: Although you can't find `ping` in the Kali Linux menu, you can open the console
    and type the `ping` command, along with its options.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `ping`, you can just type `ping` and the destination address, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5882d01e-65a8-4141-a511-2b5bfc104150.png)'
  prefs: []
  type: TYPE_IMG
- en: In Kali Linux, by default, `ping` will run continuously until you press *Ctrl*
    + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ping` tool has a lot of options, but the following are a few that are
    often used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `-c` **count**: This is the number of echo request packets to be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `-I` **interface address**: This is the network interface of the source
    address. The argument may be a numeric IP address (such as `192.168.56.102`) or
    the name of the device (such as `eth0`). This option is required if you want to
    ping the IPv6 link-local address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `-s` **packet size**: This specifies the number of data bytes to be
    sent. The default is 56 bytes, which translates into 64 ICMP data bytes when combined
    with the 8 bytes of the ICMP header data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's use the preceding information in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are starting with internal penetration-testing work. The customer
    gave you access to their network using a LAN cable and they also gave you the
    list of target servers' IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you would want to do before launching a full penetration-testing
    arsenal is to check whether these servers are accessible from your machine. You
    can use `ping` for this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The target server is located at `172.16.43.156`, while your machine has an
    IP address of `172.16.43.150`. To check the target server availability, you can
    give the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Besides IP addresses, `ping` also accepts hostnames as the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the result of the preceding `ping` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d932a749-c492-4bb2-9089-1532e50438fc.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we know that one ICMP echo request packet was
    sent to the destination (IP address = `172.16.43.156`). Also, the sending host
    (IP address = `172.16.43.150`) received one ICMP echo reply packet. The round-trip
    time required was `.869 ms`, and there was no packet loss during the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the network packets that are transmitted and received by our machine.
    We are going to use Wireshark, a network protocol analyzer, on our machine to
    capture these packets, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f2ce614-5024-4845-a39e-2eb550f5a864.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that our host (`172.16.43.150`) sent
    one ICMP echo request packet to the destination host (`172.16.43.156`). Since
    the destination is alive and allows the ICMP echo request packet, it sent the
    ICMP echo reply packet back to our machine. We will cover *Wireshark* in more
    detail in the *Network sniffers* section in Chapter 9, *Privilege Escalation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your target is using an IPv6 address, such as `fe80::20c:29ff:fe18:f08`,
    you can use the `ping6` tool to check its availability. You need to give the `-I`
    option for the command to work against the link-local address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the packets sent to complete the `ping6` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ea32c68-8b3c-4cef-9699-55f171770f7a.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we know that `ping6` is using the `ICMPv6` request
    and reply.
  prefs: []
  type: TYPE_NORMAL
- en: To block the `ping` request, the firewall can be configured to only allow the
    ICMP `echo` request packet from a specific host and to drop the packets sent from
    other hosts.
  prefs: []
  type: TYPE_NORMAL
- en: fping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between `ping` and `fping` is that the `fping` tool can be used
    to send a ping (ICMP echo) request to several hosts at once. You can specify several
    targets on the command line, or you can use a file containing the hosts to be
    pinged.
  prefs: []
  type: TYPE_NORMAL
- en: In the default mode, `fping` works by monitoring the reply from the target host.
    If the target host sends a reply, it will be noted and removed from the target
    list. If the host doesn't respond within a certain time limit, it will be marked
    as `unreachable`. By default, `fping` will try to send three ICMP echo request
    packets to each target.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access `fping`, you can use the console to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will display the description of usage and options available in `fping`.
  prefs: []
  type: TYPE_NORMAL
- en: The following scenarios will give you an idea of `fping` usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to know the alive hosts of `172.16.43.156`, `172.16.43.150`, and
    `172.16.43.155` at once, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also generate the host list automatically without defining the IP addresses
    one by one and identifying the alive hosts. Let''s suppose we want to find the
    alive hosts in the `172.16.43.0/24` network; we can use the `-g` option and define
    the network to check, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to change the number of ping attempts made to the target, we can
    use the `-r` option (retry limit) as shown in the following command line. By default,
    there are three ping attempts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The cumulative statistics can be displayed by employing the `-s` option (print
    cumulative statistics), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of the preceding command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: hping3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `hping3` tool is a command-line network-packet generator and analyzer tool.
    The capability to create custom network packets allows `hping3` to be used for
    TCP/IP and security testing, such as port scanning, firewall-rule testing, and
    network-performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are several other uses of `hping3`, according to the developer:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing firewall rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing IDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting known vulnerabilities in the TCP/IP stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access `hping3`, go to the console and type `hping3`.
  prefs: []
  type: TYPE_NORMAL
- en: You can give commands to `hping3` in several ways, via the command line, interactive
    shell, or script.
  prefs: []
  type: TYPE_NORMAL
- en: Without any given command-line options, `hping3` will send a null TCP packet
    to port `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to change to a different protocol, you can use the following options
    in the command line to define the protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '| No. | Short option | Long option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `-0` | `--raw-ip` | This sends raw IP packets |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `-1` | `--icmp` | This sends ICMP packets |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `-2` | `--udp` | This sends UDP packets |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `-8` | `--scan` | This indicates the use of scan mode |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `-9` | `--listen` | This indicates the use of listen mode |'
  prefs: []
  type: TYPE_TB
- en: 'When using the TCP protocol, we can use the TCP packet without any flags (this
    is the default behavior) or we can give one of the following flag options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| No. | Option | Flag name |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `-S` | `syn` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `-A` | `ack` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `-R` | `rst` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `-F` | `fin` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `-P` | `psh` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `-U` | `urg` |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `-X` | `xmas: flags fin, urg, psh set` |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `-Y` | `ymas` |'
  prefs: []
  type: TYPE_TB
- en: Let's use `hping3` for several cases, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Send one ICMP echo request packet to a `192.168.56.101` machine. The options
    used are `-1` (for the ICMP protocol) and `-c 1` (to set the count to one packet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can identify that the target machine is alive,
    because it has replied to our ICMP echo request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify this, we captured the traffic using `tcpdump` and the following screenshot
    shows the packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25cc7916-3d6e-4715-bfcc-57e48b1ef1e0.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the target has responded with an ICMP echo reply packet.
  prefs: []
  type: TYPE_NORMAL
- en: Besides giving the options in the command line, you can also use `hping3` interactively.
    Open the console and type `hping3`. You will then see a prompt where you can type
    your Tcl commands.
  prefs: []
  type: TYPE_NORMAL
- en: The following links are resources for Tcl: [http://www.invece.org/tclwise/](http://www.invece.org/tclwise/) and  [http://wiki.tcl.tk/](http://wiki.tcl.tk/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the preceding example, the following is the corresponding Tcl script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a command-line window and give the following command to get a response
    from the target server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After that, open another command-line window to input the sending request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response received:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a53f30f2-3af0-492b-b7ef-79185a9a28c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use `hping3` to check for a firewall rule. Let''s suppose you
    have the following firewall rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept any TCP packets directed to port `22` (SSH)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept any TCP packets related to an established connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drop any other packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check these rules, you can give the following command in `hping3`, in order
    to send an ICMP echo request packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the target machine has not responded to our ping probe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Send a TCP packet with the SYN flag set to port `22`, and we will get the result
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1bbdb6f-f19d-4945-836e-d23f3541daea.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that the target machine's firewall
    allows our SYN packet to reach port `22`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check whether the UDP packet is allowed to reach port `22`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20077aed-0b61-48f6-8506-2358bdb76a65.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that the target machine's firewall
    does not allow our UDP packet to reach port `22`.
  prefs: []
  type: TYPE_NORMAL
- en: There are other things that you can do with `hping3`, but, in this chapter,
    we'll only discuss a small subset of its capabilities. If you want to learn more,
    you can consult the `hping3` documentation site at [http://wiki.hping.org](http://wiki.hping.org).
  prefs: []
  type: TYPE_NORMAL
- en: OS fingerprinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we have established that the target machine is alive, we can then find
    out which operating system is used by the target machine. This method is commonly
    known as **Operating System** (**OS**) fingerprinting. There are two methods of
    doing OS fingerprinting: active and passive.'
  prefs: []
  type: TYPE_NORMAL
- en: In the active method, the tool sends network packets to the target machine and
    then analyzes the response it receives to determine the operating system of the
    target machine. The advantage of this method is that the fingerprinting process
    is fast. However, the disadvantage is that the target machine may notice our attempt
    to get its operating system's information.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the active method's disadvantage, a passive method of OS fingerprinting
    exists. This method was pioneered by Michal Zalewsky when he released a tool called
    `p0f`. The major advantage of passive OS fingerprinting is that it does the work
    while reducing the interaction between the testing machine and the target, greatly
    increasing the stealth of the fingerprinting. The most significant disadvantage
    of the passive method is that the process will be slower than for the active method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will describe a couple of tools that can be used for OS
    fingerprinting.
  prefs: []
  type: TYPE_NORMAL
- en: p0f
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `p0f` tool is used to fingerprint an operating system passively. It can
    be used to identify an operating system on the following machines:'
  prefs: []
  type: TYPE_NORMAL
- en: Machines that connect to your box (SYN mode; this is the default mode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machines you connect to (`SYN` + `ACK` mode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machines you cannot connect to (`RST`+ mode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machines whose communications you can observe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `p0f` tool works by analyzing the TCP packets sent during the network activities.
    Then, it gathers the statistics of special packets that are not standardized by
    default by any corporations. An example is that the Linux kernel uses a 64-byte
    ping datagram, whereas the Windows operating system uses a 32-byte ping datagram
    or the **Time To Live** (**TTL**) value. For Windows, the TTL value is `128`,
    while for Linux this TTL value varies among Linux distributions. This information
    is then used by `p0f` to determine the remote machine's operating system.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `p0f` tool included with Kali Linux, we were not able to fingerprint
    the operating system on a remote machine. We figured out that the `p0f` tool hadn't
    updated its fingerprint database. Unfortunately, we couldn't find the latest version
    of the fingerprint database. So, we used `p0f v3` (version 3.06b) instead. To
    use this version of `p0f`, just download the `TARBALL` file from [http://lcamtuf.coredump.cx/p0f3/releases/p0f-3.06b.tgz](http://lcamtuf.coredump.cx/p0f3/releases/p0f-3.06b.tgz)
    and compile the code by running the `build.sh` script. By default, the fingerprint
    database file's (`p0f.fp`) location is in the current directory. If you want to
    change the location, for example, to `/etc/p0f/p0f.fp`, you need to change this
    in the `config.h` file and recompile `p0f`. If you don't change the location,
    you may need to use the `-f` option to define the fingerprint database file location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access `p0f`, open a console and type `p0f -h`. This will display its usage
    and options description. Let''s use `p0f` to identify the operating system used
    in a remote machine we are connecting to. Just type the following command in your
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will read the fingerprint database from the file and save the log information
    to the `p0f.log` file. It will then display the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, you need to generate network activities involving a TCP connection, such
    as browsing the remote machine or letting the remote machine connect to your machine.
    For the purposes of this demonstration, a connection to the HTTP site on the 2
    machine was established.
  prefs: []
  type: TYPE_NORMAL
- en: If `p0f` has successfully fingerprinted the operating system, you will see information
    on the remote machine's operating system in the console and in the log file (`p0f.log`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the abridged information displayed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the content of the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41626c39-148b-4afa-8380-8c1ff649db33.png)'
  prefs: []
  type: TYPE_IMG
- en: Based on the preceding result, we know that the target is a `Linux 2.6` machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the information from the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3389df6-946c-43f7-aeb6-0a148c974037.png)'
  prefs: []
  type: TYPE_IMG
- en: By comparing this information, we know that `p0f` got the OS information correctly.
    The remote machine is using Linux Version 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: You can stop `p0f` by pressing the *Ctrl* + *C* key combination.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing port scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest definition of port scanning is that it is a method used to determine
    the state of the **Transmission Control Protocol** (**TCP**) and **User Datagram
    Protocol** (**UDP**) ports on the target machines. An open port may mean that
    there is a network service listening on the port and the service is accessible,
    whereas a closed port means that there is no network service listening on that
    port.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the port's state, an attacker will then check the version of the
    software used by the network service and find out the vulnerabilities of that
    version of software. For example, suppose that server A has web-server software
    version 1.0\. A few days ago, there was a security advisory released. The advisory
    gave information about the vulnerability in web-server software Version 1.0\.
    If an attacker finds out about server A's web server and is able to get the version
    information, the attacker can use this information to attack the server. This
    is just a simple example of what an attacker can do after getting information
    about the services available on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dig into the world of port scanning, let's discuss a little bit of
    TCP/IP protocol theory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TCP/IP protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the TCP/IP protocol suite, there are dozens of different protocols, but the
    most important ones are TCP and IP. IP provides addressing, datagram routing,
    and other functions for connecting one machine to another, while TCP is responsible
    for managing connections and provides reliable data transport between processes
    on two machines. IP is located in the network layer (layer 3) in the **Open Systems
    Interconnection** (**OSI**) model, whereas TCP is located in the transport layer
    (layer 4) of OSI.
  prefs: []
  type: TYPE_NORMAL
- en: Besides TCP, the other key protocol in the transport layer is UDP. You may be
    asking what the differences between these two protocols are.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, TCP has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**This is a connection-oriented protocol**: Before TCP can be used for sending
    data, the client and the server that want to communicate must establish a TCP
    connection using a three-way handshake mechanism, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client initiates the connection by sending a packet containing a SYN (synchronize)
    flag to the server. The client also sends the **Initial Sequence Number** (**ISN**)
    in the sequence number field of the SYN segment. This ISN is chosen randomly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server replies with its own SYN segment containing its ISN. The server acknowledges
    the client's SYN by sending an ACK (acknowledgment) flag containing the client
    `ISN` + `1` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client acknowledges the server by sending an ACK flag containing the server
    ISN + `1`. At this point, the client and the server can exchange data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To terminate the connection, the TCP must follow this mechanism:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client sends a packet containing a `FIN` (finish) flag set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server sends an `ACK` (acknowledgment) packet to inform the client that
    the server has received the FIN packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the application server is ready to close, the server sends a FIN packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client then sends the `ACK` packet to acknowledge receiving the server's
    `FIN` packet. In a normal case, each side (client or server) can terminate its
    end of the communication independently by sending the `FIN` packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**This is a reliable protocol**: TCP uses a sequence number and an acknowledgment
    to identify packet data. The receiver sends an acknowledgment when it has received
    the packet. When a packet is lost, TCP will automatically retransmit it if it
    hasn''t received any acknowledgment from the receiver. If the packets arrive out
    of order, TCP will reorder them before submitting them to the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications that need to transfer files or important data use a TCP, such as
    **Hypertext Transport Protocol** (**HTTP**) and **File Transfer Protocol** (**FTP**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UDP has opposing characteristics to TCP, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a connectionless protocol. To send data, the client and the server don't
    need to establish a UDP connection first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will do its best to send a packet to the destination, but if a packet is
    lost, UDP will not automatically resend it. It is up to the application to retransmit
    the packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications that can bear the loss of some packets, such as video streaming
    and other multimedia applications, use UDP. The other well-known applications
    that use UDP are **Domain Name System** (**DNS**), **Dynamic Host Configuration
    Protocol** (**DHCP**), and **Simple Network Management Protocol** (**SNMP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'For applications to be able to communicate correctly, the transport layer uses
    addressing, called ports. A software process listens on a particular port number
    on the server side, and the client machine sends data to that server port to be
    processed by the server application. The port numbers have a 16-bit address, and
    the number can range from `0` to `65,535`. To avoid a chaotic usage of port numbers,
    there are universal agreements on port number ranges, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Well-known port numbers (**`0` **to** `1,023`**)**: Port numbers in this
    range are reserved port numbers and are usually used by the server processes that
    are run by a system administrator or privileged user. Examples of the port numbers
    used by an application server are SSH (port `22`), and HTTP (port `80`), HTTPS
    (port `443`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registered port numbers (**`1,024` **to** `49,151`**)**: Users can send a
    request to the **Internet Assigned Number Authority** (**IANA**) to reserve one
    of these port numbers for their client-server application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private or dynamic port numbers (**`49,152` **to** `65,535`**)**: Anyone
    can use the port numbers in this range without registering them with the IANA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After discussing the differences between TCP and UDP in brief, let's describe
    TCP and UDP message formats.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TCP and UDP message formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A TCP message is called a segment. A TCP segment consists of a header and a
    data section. The TCP header is often 20 bytes long (without TCP options). It
    can be described using the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d90b6e9-1c4f-4cc3-bb4a-5c50dd27e726.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a brief description of each field:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Source Port** and the **Destination Port** have a length of 16 bits each.
    The source port is the port on the sending machine that transmits the packet,
    while the destination port is the port on the target machine that receives the
    packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Sequence Number (32 bits)**, in a normal transmission, is the sequence
    number of the first byte of data of this segment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Acknowledgment Number (32 bits)** contains the sequence number from the
    sender, increased by one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**H.Len. (4 bits)** is the size of the TCP header in 32-bit words.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rsvd.** is reserved for future use. It is a 4-bit field and must be zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Control Bits** (control flags) contain eight 1-bit flags. In the original
    specification (RFC 793; the RFC can be downloaded from [http://www.ietf.org/rfc/rfc793.txt](http://www.ietf.org/rfc/rfc793.txt)),
    TCP only has six flags, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SYN**: This flag synchronizes the sequence numbers. This bit is used during
    session establishment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ACK**: This flag indicates that the **Acknowledgment** field in the TCP header
    is significant. If a packet contains this flag, it means that it is an acknowledgement
    to the previously received packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RST**: This flag resets the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FIN**: This flag indicates that the party has no more data to send. It is
    used to tear down a connection gracefully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PSH**: This flag indicates that the buffered data should be pushed immediately
    to the application rather than wait for more data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**URG**: This flag indicates that the **Urgent Pointer** field in the TCP header
    is significant. The urgent pointer refers to important data-sequence numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Later on, RFC 3168 (the RFC can be downloaded from [http://www.ietf.org/rfc/rfc3168.txt](http://www.ietf.org/rfc/rfc3168.txt))
    added two more extended flags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Congestion Window Reduced (CWR)**: This is used by the data sender to inform
    the data receiver that the queue of outstanding packets to be sent has been reduced
    due to network congestion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit Connection Notification-Echo (ECN-Echo)**: This indicates that the
    network connection is experiencing congestion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Window Size (16 bits)** specifies the number of bytes the receiver is willing
    to accept'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checksum (16 bits)** is used for the error checking of the TCP header and
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flags can be set independently of each other.
  prefs: []
  type: TYPE_NORMAL
- en: To get more information on TCP, consult RFC 793 and RFC 3168.
  prefs: []
  type: TYPE_NORMAL
- en: 'When performing port scanning on the TCP port using a SYN packet sent to the
    target machine, an attacker might face the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: The target machine responds with the SYN+ACK packet. If we receive this packet,
    we know that the port is open. This behavior is defined in the TCP specification
    (RFC 793), which states that the SYN packet must be responded to with the SYN
    + ACK packet if the port is open, without considering the SYN packet payload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target machine sends back a packet with the RST and ACK bits set. This means
    that the port is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target machine sends an ICMP message, such as `ICMP Port Unreachable`, which
    means that the port is not accessible to us, most likely because it is blocked
    by the firewall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target machine sends nothing back to us. This may indicate that there is
    no network service listening on that port or that the firewall is blocking our
    SYN packet silently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a pentester's point of view, interesting behavior is when the port is open,
    because this means that there is a service available on that port that can be
    tested further.
  prefs: []
  type: TYPE_NORMAL
- en: If you conduct a port-scanning attack, you should understand the various TCP
    behaviors listed in order to be able to attack more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'When scanning for UDP ports, you will see different behaviors; these will be
    explained later on. Before we go on to see various UDP behaviors, let''s see the
    UDP header format first, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e576d8b1-6b82-466e-bda0-d05398d3f967.png)'
  prefs: []
  type: TYPE_IMG
- en: The following is a brief explanation of each field in the UDP header depicted
    in the preceding figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the TCP header, the UDP header also has the **Source Port** and the
    **Destination Port**, each of which has a length of 16 bits. The source port is
    the port on the sending machine that transmits the packet, while the destination
    port is the port on the target machine that receives the packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Length** is the length of the UDP header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UDP Checksum (16 bits)** is used for the error checking of the UDP header
    and data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that there are no sequence-number, acknowledgement-number, and control-bits
    fields in the UDP header.
  prefs: []
  type: TYPE_NORMAL
- en: 'During a port-scanning activity to the UDP port on the target machine, an attacker
    might face the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: The target machine responds with a UDP packet. If we receive this packet, we
    know that the port is open.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target machine sends an ICMP message, such as `ICMP Port Unreachable`. It
    can be concluded that the port is closed. However, if the message sent is not
    an ICMP unreachable message, it means that the port is filtered by the firewall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The target machine sends nothing back to us. This may indicate one of the following
    situations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port is closed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inbound UDP packet is blocked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response is blocked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP port scanning is less reliable when compared to TCP port scanning because,
    sometimes, the UDP port is open but the service listening on that port is looking
    for a specific UDP payload. Hence, the service will not send any replies.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have briefly described port-scanning theory, let's put this into
    practice. In the following sections, we will look at several tools that can be
    used to help us perform network scanning.
  prefs: []
  type: TYPE_NORMAL
- en: For the practical scenarios in this chapter, we will utilize a Metasploitable
    virtual machine, as explained in [Chapter 2](573e3579-5017-4c33-acd8-01e866ed66d8.xhtml),
    *Setting up your Test Lab*, as our target machine. It has an IP address of `172.16.43.156`,
    while our attacking machine has an IP address of `172.16.43.150`.
  prefs: []
  type: TYPE_NORMAL
- en: The network scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at several tools that can be used to find open
    ports, fingerprint the remote operating system, and enumerate the services on
    the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Service enumeration is a method that is used to find the service version that
    is available on a particular port on the target system. This version information
    is important because, with this information, the penetration tester can search
    for security vulnerabilities that exist for that software version.
  prefs: []
  type: TYPE_NORMAL
- en: While standard ports are often used, sometimes systems administrators will change
    the default ports for some services. For example, an SSH service may be bound
    to port `22` (as a convention), but a system administrator may change it to be
    bound to port `2222`. If the penetration tester only does a port scan to the common
    port for SSH, it may not find that service. The penetration tester will also have
    difficulties when dealing with proprietary applications running on non-standard
    ports. By using the service enumeration tools, these two problems can be mitigated,
    so there is a chance that the service can be found, regardless of the port it
    is bound to.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap is a port scanner that is comprehensive, feature- and fingerprint-rich,
    and widely used by the IT security community. It is written and maintained by
    Fyodor. It is a must-have tool for a penetration tester because of its quality
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides being used as a port scanner, Nmap has several other capabilities,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Host discovery**: Nmap can be used to find live hosts on the target systems.
    By default, Nmap will send an ICMP echo request, a TCP SYN packet to port `443`,
    a TCP ACK packet to port `80`, and an ICMP timestamp request to carry out host
    discovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service/version detection**: After Nmap has discovered the ports, it can
    further check for the service protocol, the application name, and the version
    number used on the target machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating system detection**: Nmap sends a series of packets to the remote
    host, and examines the responses. Then, it compares these responses with its operating
    system fingerprint database and prints out the details if there is a match. If
    it is not able to determine the operating system, Nmap will provide a URL to which
    you can submit the fingerprint to update its operating system fingerprint database.
    Of course, you should submit the fingerprint if you know the operating system
    used on the target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network traceroute**: This is performed to determine the port and protocol
    that are most likely to reach the target system. Nmap traceroute starts with a
    high value of TTL and decrements it until the TTL value reaches zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nmap Scripting Engine**: With this feature, Nmap can be extended. If you
    want to add a check that is not included with the default Nmap, you can do so
    by writing the check using the Nmap scripting engine. Currently, there are checks
    for vulnerabilities in network services and for enumerating resources on the target
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is good practice to always check for new versions of Nmap. If you find the
    latest version of Nmap that is available for Kali Linux, you can update your Nmap
    by issuing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To start Nmap, you can navigate to Applications and then to Information Gathering.
    You can also start Nmap by going to the console to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will display all of the Nmap options with their descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: A user who is new to Nmap will find the available options quite overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, you only need one option to scan for the remote machine. That
    option is your target IP address or hostname, if you have set up the DNS correctly.
    This is done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of the scan without any other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding result, we can see that the target machine is very vulnerable
    to attack because it has many open ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue to use Nmap, let''s take a look at the port states that
    can be identified by Nmap. There are six port states that are recognized by Nmap,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open**: This means that there is an application accepting a TCP connection,
    UDP datagram, or SCTP association.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closed**: This means that although the port is accessible, there is no application
    listening on the port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtered**: This means that Nmap can''t determine whether the port is open
    or not because there is a packet-filtering device blocking the probe to reach
    the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unfiltered**: This means that the port is accessible, but Nmap cannot determine
    whether it is open or closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open|Filtered**: This means that Nmap is unable to determine whether a port
    is open or filtered. This happens when a scan of open ports doesn''t give a response.
    It can be achieved by setting the firewall to drop packets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closed|Filtered**: This means Nmap is unable to determine whether a port
    is closed or filtered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After describing the port states, we will describe several options that are
    commonly used during penetration testing, and, after that, we will use those options
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap target specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap will treat everything on the command line that isn't an option or option
    argument as a target host specification. We suggest that you use the IP address
    specification instead of the hostname. By using the IP address, Nmap doesn't need
    to do DNS resolution first. This will speed up the port-scanning process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current version, Nmap supports the following IPv4 address specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports a single host, such as `172.16.43.156`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports a whole network of adjacent hosts by using the CIDR notation, such
    as `172.16.43.0/24`. This specification will include 256 IP addresses ranging
    from `172.16.43.0` to `172.16.43.255`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It supports an octet range addressing, such as `172.16.2-4,6.1`. This addressing
    will include four IP addresses: `172.16.2.1`, `172.16.3.1`, `172.16.4.1`, and
    `172.16.6.1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports multiple host specifications, such as `172.16.43.1 172.168.3-5,9.1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the IPv6 address, Nmap only supports a fully qualified IPv6 format and hostname,
    such as `fe80::a8bb:ccff:fedd:eeff%eth0`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides getting the target specification from the command line, Nmap also accepts
    a target definition from a text file by using the `-iL <inputfilename>` option.
    This option is useful if we already have the IP addresses from another program.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the entries in that file use the Nmap-supported target-specification
    format. Each entry must be separated by spaces, tabs, or a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a sample of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's scan a network for `172.16.430/24`. We want to see the packets sent
    by Nmap. To monitor the packets sent, we can use a packet-capture utility, such
    as `tcpdump`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a console and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `172.16.43.150` IP address belongs to our machine, which launches Nmap.
    You need to adjust it to your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another console on the same machine and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `tcpdump` console, you will see the following packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding packet information, we know that the attacking machine sent
    a packet with a SYN flag set from port `49270` to the target machine port `23`
    (Telnet). The SYN flag is set by default if Nmap is run by a privileged user,
    such as `root` in Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a packet sent by the attacking machine to other
    machines and ports on the target network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c288704-bc73-47b4-97be-79bf2b971c5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the remote machine responds, the response packet will look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the flag sent is denoted by the character `R`, which is reset. It
    means that port `1720` in the target machine is closed. We can verify this with
    the previous Nmap result.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the port is open, you will see the following network traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the packet in the preceding code is to acknowledge the sequence
    number from the previous packet displayed. This packet has an acknowledgement
    number of `239440323`, while the previous packet had a sequence number of `239440322`.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap TCP scan options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to use most of the TCP scan options, Nmap needs a privileged user
    (a root-level account in the Unix world or an administrator-level account in the
    Windows world). This is used to send and receive raw packets. By default, Nmap
    will use a TCP SYN scan, but if Nmap doesn''t have a privileged user, it will
    use the TCP connect scan. The various scans used by Nmap are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP connect scan (**`-sT`**)**: This option will complete the three-way handshake
    with each target port. If the connection succeeds, the port is considered open.
    As a result of the need to do a three-way handshake for each port, this scan type
    is slow and it will most likely be logged by the target. This is the default scan
    option used if Nmap is run by a user who doesn''t have any privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SYN scan (**`-sS`**)**: This option is also known as **half-open** or **SYN
    stealth**. With this option, Nmap sends a SYN packet and then waits for a response.
    A SYN/ACK response means that the port is listening, while an RST/ACK response
    means that the port is not listening. If there is no response or an ICMP-unreachable
    error-message response, the port is considered to be filtered. This scan type
    can be performed quickly, and, because the three-way handshake is never completed,
    it is unobtrusive and stealthy. This is the default scan option if you run Nmap
    as a privileged user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP NULL scan (**`-sN`**), FIN scan (**`-sF`**), and XMAS scan (**`-sX`**)**:
    The `NULL` scan doesn''t set any control bits. The FIN scan only sets the FIN
    flag bit, and the `XMAS` scan sets the FIN, `PSH`, and URG flags. If an RST packet
    is received as a response, the port is considered closed, while no response means
    that the port is open/filtered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP Maimon scan (**`-sM`**)**: The TCP Maimon scan was discovered by Uriel
    Maimon. A scan of this type will send a packet with the FIN/ACK flag bit set.
    BSD-derived systems will drop the packet if the port is open, and will respond
    with RST if the port is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP ACK scan (**`-sA`**)**: This scan type is used to determine whether a
    firewall is stateful or not, and which ports are filtered. A network packet of
    this type only sets the ACK bit. If RST is returned, it means that the target
    is unfiltered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP Window scan (**`-sW`**)**: This scan type works by examining the TCP
    Window field of the RST packet''s response. An open port will have a positive
    **TCP Window** value, while a closed port will have a zero TCP Window value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP Idle scan (**`-sI`**)**: Using this technique, no packets are sent to
    the target by your machine; instead, the scan will bounce off to a zombie host
    you specify. An IDS will report the zombie as the attacker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap also supports you in creating your own custom TCP scan by giving you the
    option of **scanflags**. The argument to that option can be numerical, such as
    `9` for PSH and FIN, or symbolic names. Just put together any combination of URG,
    ACK, PSH, RST, SYN, FIN, ECE, CWR, ALL, and NONE in any order; for example, `--scanflags
    URGACKPSH` will set the flags URG, ACK, and PSH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling host discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a host is blocking a ping request, Nmap may detect that the host is not active;
    so, Nmap may not perform heavy probing, such as port scanning, version detection,
    and operating system detection. To overcome this, Nmap has a feature for disabling
    host discovery. With this option, Nmap will assume that the target machine is
    available and will perform heavy probing against that machine.
  prefs: []
  type: TYPE_NORMAL
- en: This option is activated using the `-Pn` option.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap UDP scan options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the TCP scan has many types of scans, the UDP scan only has one type,
    which is the UDP scan (`-sU`). Even though the UDP scan is less reliable than
    the TCP scan, as a penetration tester, you should not ignore this scan, because
    there may be interesting services located on these UDP ports.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with the UDP scan is how to perform the scan quickly. A
    Linux kernel limits the sending of the `ICMP Port Unreachable` message to one
    message per second. Doing a UDP scan of 65,536 ports to a machine will take more
    than 18 hours to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help mitigate this problem, there are several methods that can be used,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Running the UDP scan in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning the most popular ports first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning behind the firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the `--host-timeout` option to skip slow hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods can help to decrease the time required for doing UDP port scans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a scenario where we want to find which UDP ports are open on
    the target machine. To speed up the scanning process, we will only check for ports
    `53` (DNS) and `161` (SNMP). The following is the command used to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Nmap port specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the default configuration, Nmap will only scan randomly the 1,000 most common
    ports for each protocol. The `nmap-services` file contains a popularity score
    for the selection of the top ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change that configuration, Nmap provides several options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-p` **port range**: This scans only the defined ports. To scan ports `1` to
    `1024`, the command is `-p 1-1024`. To scan ports `1` to `65535`, the command
    is `-p-`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-F` **(fast)**: This will scan only 100 common ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r` **(don''t randomize port)**: This option will set sequential port scanning
    (from lowest to highest).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--top-ports <1 or greater>`: This option will only scan the `N` highest-ratio
    ports found in the `nmap-service` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To scan for ports `22` and `25` using the TCP NULL scan method, you can use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command lines are the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the packet''s dumped snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'From the packets displayed in the preceding code, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first and second packets, the attacking machine checks whether port `22`
    on the target machine is open. After a period of time, it checks port `25` on
    the target machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third and fourth packets, the attacking machine checks whether port `25`
    on the target machine is open. After a period of time, it checks port `22` on
    the target machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After waiting for some time, as there is still no response from the target machine,
    Nmap concludes that those two ports are open or filtered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap output options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Nmap result can be saved to an external file. This option is useful if you
    want to process Nmap result with other tools. Even if you save the output to a
    file, Nmap still displays the result on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nmap supports several output formats, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interactive output**: This is a default output format, and the result is
    sent to the standard output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal output (**`-oN`**)**: This format is similar to the interactive output,
    but it doesn''t include the runtime information and warnings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML output (**`-oX`**)**: This format can be converted to an HTML format,
    parsed by the Nmap graphical user interface (GUI), or imported to the database.
    We suggest you use this output format as much as you can.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grepable output (**`-oG`**)**: This format is deprecated, but it is still
    quite popular. Grepable output consists of comments (lines starting with a pound
    sign (`#`)) and target lines. A target line includes a combination of six labeled
    fields that are separated by tabs and followed by a colon. The fields are `Host`,
    `Ports`, `Protocols`, `Ignored State`, `OS`, `Seq Index`, `IP ID Seq`, and `Status`.
    We sometimes use this output if we want to process the Nmap output using the UNIX
    commands, such as `grep` and `awk`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `-oA` option to save Nmap results in the three formats at once
    (normal, XML, and grepable).
  prefs: []
  type: TYPE_NORMAL
- en: 'To save a scan result to an XML file (`myscan.xml`), use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a snippet of the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For brevity purposes, a number of the ports have been removed from the previous
    snippet. In the XML output, you will see each port that Nmap scans against. The
    following shows each of the ports being scanned separately and what the response
    is. Again, for brevity''s sake, all of the ports have not been included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML output is a bit daunting to look at. To make it easier, you can convert
    the Nmap XML file to HTML. This allows you to have clean-looking output for reporting
    purposes, as some of the non-technical personnel you may report to may not be
    used to viewing raw outputs. To convert the XML file, you can use the `xsltproc`
    program. The following command is used to convert the XML file to an HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a part of the HTML report, as displayed by the Firefox ESR
    browser included in Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85f43d2b-f099-4327-8fec-0994fc3f867c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to process the Nmap XML output to your liking, there are several
    programming language generic XML libraries that you can use for this purpose.
    Also, there are several libraries specifically developed to work with an Nmap
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Perl**: Nmap-Parser ([http://search.cpan.org/dist/Nmap-Parser/](http://search.cpan.org/dist/Nmap-Parser/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python**: python-nmap ([http://xael.org/norman/python/python-nmap/](http://xael.org/norman/python/python-nmap/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ruby**: Ruby Nmap ([http://rubynmap.sourceforge.net/](http://rubynmap.sourceforge.net/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PowerShell**: PowerShell script to parse Nmap XML output ([http://www.sans.org/windows-security/2009/06/11/powershell-script-to-parse-nmap-xml-output](http://www.sans.org/windows-security/2009/06/11/powershell-script-to-parse-nmap-xml-output))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap timing options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nmap comes with six timing modes that you can set with options (`-T`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`paranoid (0)`: In this timing mode, a packet is sent every five minutes. The
    packets are sent serially. This mode is useful for avoiding IDS detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sneaky (1)`: This mode sends a packet every 15 seconds, and there are no packets
    sent in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`polite (2)`: This mode sends a packet every 0.4 seconds, and there is no parallel
    transmission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normal (3)`: This mode sends multiple packets to multiple targets simultaneously.
    This is the default timing mode used by Nmap. It balances between time and network
    load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aggressive (4)`: Nmap will scan a given host for only five minutes before
    moving on to the next target. Nmap will not wait more than 1.25 seconds for a
    response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insane (5)`: In this mode, Nmap will scan a given host for only 75 seconds
    before moving on to the the next target. Nmap will not wait for more than 0.3
    seconds for a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our experience, the default timing mode usually works well unless you want
    to have a stealthier or faster scan.
  prefs: []
  type: TYPE_NORMAL
- en: Useful Nmap options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss several Nmap options that are quite useful
    when doing a penetration-testing job.
  prefs: []
  type: TYPE_NORMAL
- en: Service version detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap can also be asked to check the service version when doing port scanning.
    This information is very useful when you perform the vulnerability-identification
    process later on.
  prefs: []
  type: TYPE_NORMAL
- en: To use this feature, give Nmap the `-sV` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example for this feature''s usage. We want to find the
    software version used on port `22`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a839fe05-ccce-47e3-88f5-6a440c1a7a6b.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding information, we know that on port `22` there is an SSH service
    using the `OpenSSH` software version 4.7p1, and the SSH protocol is `2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Operating system detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap can also be asked to check the operating system used on the target machine.
    This information is very useful when you perform the vulnerability-identification
    process later on.
  prefs: []
  type: TYPE_NORMAL
- en: To use this feature, give Nmap the `-O` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of this feature''s usage. We want to find the operating
    system used on the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command lines are the result of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16d75c31-92c3-4c68-9052-bf0d2a833834.png)'
  prefs: []
  type: TYPE_IMG
- en: Based on the preceding information, we can see that the remote system is a Linux
    operating system using Linux kernel versions `2.6.9 - 2.6.33`. If there are vulnerabilities
    on those Linux kernels, we can exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: Aggressive scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you use the `-A` option, it will enable the following probe:'
  prefs: []
  type: TYPE_NORMAL
- en: Service-version detection (`-sV`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating-system detection (`-O`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script scanning (`-sC`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traceroute (`--traceroute`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It may take some time for this scan type to finish. The following command can
    be used for aggressive scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the abridged result of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bbd9901-bb24-40b6-af62-ed66cb8ab16b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the detailed information about ports, services, and the certificates,
    further down the result we get detailed information concerning the Apache Webserver
    configured on this target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ac74298-c7a0-422d-985e-31a6c59ef639.png)'
  prefs: []
  type: TYPE_IMG
- en: Nmap for scanning the IPv6 target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we mentioned that you can specify an IPv6 target in
    Nmap. In this section, we will discuss this in depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this scenario, the following is the IPv6 address of each machine involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To scan an IPv6 target, just use the `-6` option and define the IPv6 target
    address. Currently, you can only specify individual IPv6 addresses. The following
    is a sample command to port scan the IPv6 address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f52fa5e0-9c8d-4aa1-b95a-ba9681002f98.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that, in IPv6 testing, the number of ports open is less than in the
    IPv4 testing. This may be caused by services on the remote machine that do not
    support IPv6 yet.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with Netdiscover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netdiscover is another discovery tool, and is built into Kali Linux 2018.2\.
    Currently at the .03-pre-beta7 version and written by Jaime Penalba, Netdiscover
    can reform reconnaissance and discovery on both wireless and switched networks
    using ARP requests.
  prefs: []
  type: TYPE_NORMAL
- en: To launch Netdiscover, type `netdiscover –h` to view the usage options. (Should
    you only type the `netdiscover` command by itself, Netdiscover will launch a default
    scan.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fdecc99-2a53-4356-890a-bf3081d6490a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To scan a range of IPs , type `netdiscover –r` followed by the IP range. For
    this example, we''ve used `netdiscover –r 10.10.0.0/24`. You may also choose to
    do a passive scan using the `netdiscover –p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26f29542-14fe-47d3-aee9-3a95e00f644e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding scan, we can see that the discovery includes Dell and HP workstations,
    Cisco devices, and even Xerox multi-function devices.
  prefs: []
  type: TYPE_NORMAL
- en: The Nmap scripting engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Nmap itself has already become a powerful network-exploration tool,
    with the additional scripting engine capabilities, Nmap becomes a much more powerful
    tool. With the **Nmap Scripting Engine** (**NSE**), users can automate various
    networking tasks, such as checking for new security vulnerabilities in applications,
    detecting application versions, or other capabilities that are not available in
    Nmap. Nmap has already included various NSE scripts in its package, but users
    can also write their own scripts to suit their needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The NSE scripts utilize the Lua programming language ([http://www.lua.org](http://www.lua.org))
    embedded in Nmap, and, currently, the NSE scripts are categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`auth`: The scripts in this category are used to find the authentication set
    on the target system; for example, by using the brute-force technique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: These scripts are run using the `-sC` or `-A` options. A script
    will be grouped in the default category if it satisfies the following requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to produce valuable and actionable information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its output needs to be verbose and concise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be reliable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should not be intrusive of the target system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should divulge information to the third party
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discovery`: These scripts are used to find the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DoS**: The scripts in this category may cause **Denial of Service** (**DoS**)
    on the target system. Please use them carefully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exploit`: These scripts will exploit security vulnerabilities on the target
    system. The penetration tester needs to have permission to run these scripts on
    the target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external`: These scripts may divulge information to third parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fuzzer`: These scripts are used to do fuzzing on the target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intrusive`: These scripts may crash the target system or use all of the target
    system''s resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malware`: These scripts will check for the existence of malware or backdoors
    on the target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`safe`: These scripts are not supposed to cause a service crash, **Denial of
    Service** (**DoS**), or exploit the target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: These scripts are used with the version detection option (`-sV`)
    to carry out advanced detection for the service on the target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vuln`: These scripts are used to check for security vulnerabilities on the
    target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Kali Linux, these Nmap scripts are located in `the /usr/share/nmap/scripts`
    directories, and, currently, Nmap Version 7.70, which is included with Kali Linux,
    contains 588 scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several command-line arguments that can be used to call NSE, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-sC or --script=default`: This performs a scan using default scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--script <filename> | <category> | <directories>`: This performs a scan using
    the script defined in filenames, categories, or directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--script-args <args>`: This provides a script argument. An example of these
    arguments is the username or the password if you use the `auth` category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To port scan the `172.16.43.156` host and utilize the default script categories,
    we can give the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an abridged result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding information, you can see that the Nmap result is now more
    thorough. This is because it utilizes the NSE default scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you only want specific information on the target system, you can
    use the script by itself. If we want to collect information about the HTTP server,
    we can use several HTTP scripts in NSE, such as `http-enum`, `http-headers`, `http-methods`,
    and `http-php-version`, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce668a8e-e17b-439b-948a-a521cfadb95f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By utilizing four NSE scripts related to HTTP, we gain more information regarding
    the target system''s web server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several interesting directories to check: `Tikiwiki`, `test`, and
    `phpMyAdmin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have an interesting file: `phpinfo.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know the server is using PHP version `5.2.3 -5.2.5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After discussing Nmap, let's discuss another port-scanner tool.
  prefs: []
  type: TYPE_NORMAL
- en: There is a useful NSE script called Nmap NSE Vulscan ([http://www.computec.ch/mruef/software/nmap_nse_vulscan-1.0.tar.gz](http://www.computec.ch/mruef/software/nmap_nse_vulscan-1.0.tar.gz))
    that can help you to map the version information you obtain from a target machine
    with a vulnerability database, such as CVE ([http://cve.mitre.org/](http://cve.mitre.org/)),
    VulDB ([https://vuldb.com/?](https://vuldb.com/?)), SecurityTracker ([http://securitytracker.com/](http://securitytracker.com/)),
    and SecurityFocus ([http://www.securityfocus.com/](http://www.securityfocus.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the sample result of the CVE script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b42f504b-c463-4634-b76c-123e03fa979d.png)'
  prefs: []
  type: TYPE_IMG
- en: Nmap options for firewall/IDS evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During penetration testing, you may encounter a system that is using a firewall
    and an IDS to protect the system. If you just use the default settings, your action
    may get detected or you may not get the correct result from Nmap. The following
    options may be used to help you evade the firewall/IDS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f` **(fragment packets)**: The purpose of this option is to make it harder
    to detect the packets. By specifying this option once, Nmap will split the packet
    into 8 bytes or fewer after the IP header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--mtu`: With this option, you can specify your own packet-size fragmentation.
    The **Maximum Transmission Unit** (**MTU**) must be a multiple of eight, or Nmap
    will give an error and exit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-D` **(decoy)**: By using this option, Nmap will send some of the probes from
    the spoofed IP addresses specified by the user. The idea is to mask the true IP
    address of the user in the log files. The user IP address is still in the logs.
    You can use `RND` to generate a random IP address, or `RND:number` to generate
    the `<number>` IP address. The hosts you use for decoys should be up, or you will
    flood the target. Also remember that, by using many decoys, you can cause network
    congestion, so you may want to avoid that, especially if you are scanning your
    client''s network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--source-port <portnumber> or -g (spoof source port)`: This option will be
    useful if the firewall is set up to allow all incoming traffic that comes from
    a specific port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--data-length`: This option is used to change the default data length sent
    by Nmap in order to avoid being detected as Nmap scans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--max-parallelism`: This option is usually set to one in order to instruct
    Nmap to send no more than one probe at a time to the target host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--scan-delay <time>`: This option can be used to evade an IDS/IPS that uses
    a threshold to detect port-scanning activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also experiment with other Nmap options for evasion, as explained in
    the Nmap manual ([http://nmap.org/book/man-bypass-firewalls-ids.html](http://nmap.org/book/man-bypass-firewalls-ids.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Automated scanning with Striker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Striker is an automated scanning and deep information-gathering tool built into
    Python, which performs port/service and vulnerability scanning. Much like the
    automated tools we used in the previous chapter (Red_Hawk and Devploit), Striker
    is simple to install and use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must first download Striker. To do so, open a Terminal and change to the
    `Desktop` (or directory of your choice) by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following to clone Striker to your desktop or (or directory of your
    choice):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/43032ee7-6c3c-42c7-a787-6d2f322fd574.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the download has completed successfully (with objects and deltas at 100%,
    as seen in the previous screenshot), change to the Striker directory by typing
    `cd Striker` and then using the `ls` command to list the files within the Striker
    folder. You should see five files listed, including `requirements.txt` and `striker.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61a0865f-64fa-4da7-abdd-96f580ac3100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For Striker to run without errors, we must first use the package management
    installer (`pip`) to ensure that all of the requirements necessary to run Striker
    are met, including the Whois module (which is necessary for information gathering).
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we run the following two commands, `pip install -r requirements.txt`
    followed by `pip install whois`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cc78dab-f95c-413c-837a-25ccc92a6469.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once all requirements have been installed successfully, type `pip install whois`
    (even though the requirement may have already been installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d78d1aa-0b15-453d-9588-499324b0244d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, to run Striker, we type `python striker.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50b626aa-534b-42a0-bdf0-5ab1b39da866.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Striker GUI will now run. As a fully automated tool, all that is required
    from this point onward is the target IP or URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we have used the [http://scanme.nmap.org/](http://scanme.nmap.org/)
    website that is used in the Nmap scanning section. Compare the results of the
    scan with those found by Nmap earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f527c7bc-f3e1-492c-95e1-dc8e358f1afe.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that Striker also found DNS record information as well as two email addresses,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eda44f2-6431-47f2-95b2-749c267e8c36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Anonymity using Nipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nipe is a tool that utilizes the Tor network as a user's default gateway, thereby
    routing all traffic through the Tor network, which is commonly used to offer some
    level of privacy and anonymity. It should be noted that, when using a tool for
    privacy and anonymity, masking the IP address alone will not offer anonymity,
    as DNS information may still be available. Both IP and DNS information must be
    masked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first install Nipe by cloning it to our machine on the desktop or directory
    of your choice. Open a terminal and change directories to the Desktop (or directory
    of your choice):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone Nipe to your machine by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/523e0fd8-b899-464c-9039-6b762b5234ee.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Change to the Nipe directory by typing `cd Nipe`, and then list the contents
    of the directory by typing `ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4a53e4e-c19c-4fe8-8e06-933ffb8c891a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To install Nipe, type `cpan install Switch JSON LWP::UserAgent`. When prompted
    to perform an automatic installation, press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77d30371-85ab-4ea6-9b5a-ca954dcab123.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To install Nipe dependencies, run the command, `perl nipe.pl install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/861f0543-4641-44e5-bc9f-534b131266de.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before starting Nipe, check your public IP address and DNS IP, and compare them
    to the given IPs after starting Nipe. Some examples of websites you can use to
    view your public IP are [www.whatsmyipaddress.com](http://www.whatsmyipaddress.com)
    and [www.dnsleak.com](http://www.dnsleak.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the Nipe service type `perl nipe.pl start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/febcafd0-2fb9-4b59-872f-34bd0941ec02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also restart the service to mask your IP to different regions by typing
    `perl nipe.pl restart`. All commands used for installing and using the Nipe tool
    can also be found on its GitHub page at [https://github.com/GouveaHeitor/nipe](https://github.com/GouveaHeitor/nipe).
  prefs: []
  type: TYPE_NORMAL
- en: Use the IP and DNS verification websites previously listed to check that your
    settings have indeed changed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed the target-discovery process. We started by discussing
    the purposes of target discovery: identifying the target machine and finding out
    the operating system used by the target machine. Then, we continued with the tools
    included with Kali Linux and GitHub that can be used for discovering and identifying
    target machines.'
  prefs: []
  type: TYPE_NORMAL
- en: We discussed several tools for host discovery and scanning, such as `ping`,
    Nmap, `p0f`, and Striker, and also looked at masking your IP and DNS using Nipe to
    evade detection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about vulnerability scanning and the tools
    that can be used in Kali Linux for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which tool can be used to send ICMP echo requests to several hosts at once?
    (`fping`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many scripts are available in Nmap 7.7? (588 scripts)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the FIN flag? (It indicates that there is no more data
    to be sent and that the connection should be terminated.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a filtered port indicate? (A packet-blocking device is preventing
    the probe from reaching the target.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Nmap option can be used to make it harder to detect packets when evading
    firewalls and IDS? (`-f`, which is used to fragment packets)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the command used to scan a range of IPs using the Netdiscover tool?
    (netdiscover `-r`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which option can be used in Netdiscover to run a passive scan? (`-p`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which website can be used to ensure that DNS information is not being leaked?
    ([www.dnsleak.com](http://www.dnsleak.com/))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux networking tools: [https://gist.github.com/miglen/70765e663c48ae0544da08c07006791f](https://gist.github.com/miglen/70765e663c48ae0544da08c07006791f)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nmap scripting engine: [https://nmap.org/book/nse.html](https://nmap.org/book/nse.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Port scanning techniques: [https://nmap.org/book/man-port-scanning-techniques.html](https://nmap.org/book/man-port-scanning-techniques.html)'
  prefs: []
  type: TYPE_NORMAL
