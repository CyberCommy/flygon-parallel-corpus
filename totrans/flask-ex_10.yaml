- en: Chapter 10. Template Inheritance and WTForms in Waiter Caller Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a rudimentary user account system. However,
    we only made a very simple route access controlled—the one that simply showed
    the string "You are logged in". In this chapter, we'll add some more of the desired
    functionality, and allow logged-in users to add restaurant tables, see the URLs
    associated with these tables, and view attention requests from customers. One
    of the problems we'll come across is that of wanting to reuse the same elements
    for different pages of our application. You'll see how to solve this problem without
    code duplication by using Jinja's inheritance system. As mentioned in the previous
    chapter, we do not communicate very well with our user when mistakes, such as
    entering an incorrect password, are made. To address this, we'll take a look at
    another Flask extension, WTForms, and see how it can simplify creating and validating
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding account and dashboard pages to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortening URLs using the bitly API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding functionality for handling attention requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding user feedback through WTForms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the Account and Dashboard pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to add two new pages to our application: ''Dashboard'', where all requests
    from the patrons of a particular restaurant can be seen, and ''Account'', where
    the restaurants can manage their tables and view the URLs that they need to make
    available on the tables.'
  prefs: []
  type: TYPE_NORMAL
- en: We could simply create two new `.html` files in our `templates` directory and
    write the HTML from scratch. But we'll soon find that we need many of the same
    elements from our home page (at the very least, the parts that include and configure
    Bootstrap). Then we'll be tempted to just copy and paste the HTML from the home
    page and start working on our new page from there.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Jinja templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copying and pasting code is usually a sign that something is wrong. In application
    code, it means that you haven't modularized your code well, and you need to create
    some more classes and probably add a couple of `import` statements to include
    the reused code wherever it is needed. Using Jinja, we can follow a very similar
    pattern, by using *template inheritance*. We'll first split our home page into
    two separate template files, `base.html` and `home.html`, with all the elements
    that we want to reuse in the base file. We can then have all three of our other
    pages (Home, Account, and Dashboard) inherit from the *base template*, and only
    write the code that differs across the three.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja handles inheritance by using the concept of *blocks*. Each parent template
    can have named blocks, and a child that extends a parent can fill in these blocks
    with its own custom content. The Jinja inheritance system is quite powerful, and
    accounts for nested blocks and overwriting existing blocks. However, we're only
    going to scratch the surface of its functionality. We'll have our base template
    contain all the reusable code, and it'll contain one blank block named `content`
    and one named `navbar`. Each of our three pages will extend from the base template,
    providing their own version of the content block (for the main page content) and
    the navigation bar. We'll need to make the navigation bar dynamic, because the
    **Login** fields of the bar at the top of the page will only appear if the user
    isn't logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the base template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new file called `base.html` in your `templates` directory, and insert
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have all our header and our page footer code—elements
    that will be common across all our pages—in one file. We define two blocks, using
    the Jinja syntax, which is similar to the other Jinja statements that we have
    seen, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `content` and `navbar` are the names of our blocks, and we
    can choose these freely, while `block` and `endblock` are Jinja keywords, and
    the `{% %}` symbols are used to indicate the Jinja statements as in earlier examples.
    This is in itself a completely valid Jinja template; even though the content block
    is empty, we can render the template directly from our Flask app, and we would
    see a page that simply pretended that the content block didn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: We can also extend this template, though; that is, we can create children using
    it as the parent. Children have the option of *overwriting* any of the specified
    blocks simply by declaring them again. We declared `navbar` as a block as our
    home page will use the navigation bar that we wrote earlier—the one that includes
    a login form. Once logged in, however, our pages for dashboard and account will
    have exactly the same navigation bar—the one we define in our base template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the dashboard template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our dashboard page will eventually show all customers'' requests for service
    so that a waiter can easily see which tables need attention. For now though, we''ll
    just create an outline of the page. Create a new file in your `templates` directory
    called `dashboard.html`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The most important line in the preceding code snippet is the first one—we use
    the Jinja `extends` keyword to indicate that this template should inherit all
    the code contained in another template. The keyword is followed by the filename
    of the template to inherit from, contained within inverted commas.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we simply create the content block in exactly the same way we
    did in our base template. This time, instead of leaving it blank, we add some
    HTML to be displayed on our dashboard page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the account template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The account page will be the one where the user can add new tables, delete
    tables, or get the URL for the existing tables. Again, as we do not yet have any
    application code to represent a table, we''ll just create an outline of the page.
    Create a file called `account.html` in your `templates` directory, and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating the home template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `home.html` template contains the entire code specific to our home page,
    and which isn't part of the base template. The code can be seen in the code bundle
    as `templates/home_1.html`, but is not included here as it is too long. Have a
    look at it and see how we define a new `navbar` block which contains the `login`
    form, and which overrides the default one provided in the base template. Similarly,
    it defines the content block, which replaces the empty content block that we defined
    in our base template. The end result hasn't changed—we'll still see exactly the
    same home page, but now the code is split between the `base.html` and `home.html`
    files, allowing us to reuse large parts of it for the new pages that we created
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the routing code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need our Python code to return the new template files when `/account` and
    `/dashboard` are visited. Add the `dashboard()` function to your `waitercaller.py`
    file, and modify the account `function()` to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the new pages a go! Start the application locally as before, by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `http://localhost:5000` to see the home page. Log in using the
    form, and now, instead of the bare message we had before, you should see a nicer
    looking skeleton of the **Account** page, as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the routing code](img/B04312_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Dashboard** link in the navigation bar at the top, and you should
    see the skeleton for that page, too, as seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the routing code](img/B04312_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating restaurant tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to introduce the concept of a *table* to our application, and be
    able to represent this both in our database and in our application code. A table
    should have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: An ID number that uniquely identifies that table across all users of our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name that is user-definable and unique within a specific user's tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An owner so that we will know to which user a table belongs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we were following an **Object Oriented Programming** style religiously, we
    would create a `Table` class which had these properties. We would then also create
    a bunch of other classes for everything in our application. Following this approach,
    we would also create methods to serialize each of our objects into something that
    can be stored in our database, and more methods to *deserialize* them from the
    database back to objects.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, and because our model is simple enough, we'll be taking
    a shortcut that is sure to offend some, and simply use Python dictionaries to
    represent most of our objects. We'll see when we add MongoDB to our application
    that these dictionaries will be trivial to write to and read from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the restaurant table code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's have a brief look at what our tables need to do. First, the user of our
    app will need to be able to add and remove new tables on the `account` page—both
    initially when an account is registered and later if changes need to be made.
    Secondly, the user should be able to view the URL associated with each table,
    so that these URLs can be printed and made available at the physical tables. When
    a new table is added, we'll need to create a mock database.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by providing our users with an input box on the `account` page,
    where they can input the name or number of a new table in order to create it.
    When a new table is created, we'll create a unique ID number and use that to create
    a new URL. We'll then use the bitly API to create a shortened version of the URL—one
    that our users' patrons will be able to type into a smartphone more easily. We'll
    then store the table name, ID, and shortened URL in our mock database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the create table form
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the `account.html` template, add the following directly beneath the line
    `<h2>Tables</h2>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very basic form with a single input for a new table name and a button
    to submit the form. If you load the application and navigate to the **Account**
    page, you should now see something like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the create table form](img/B04312_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the create table route
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating a table backend is not too complicated, but it has subtleties that
    are important to understand. First, our users can give the table any name they
    want. For most users, these names will probably just be incrementing numbers starting
    from 1 and ending at the number of tables in the restaurant, as this is a common
    way for restaurants to name their tables. Because many restaurant managers will
    be using our application, we can't assume that these names will be unique across
    all accounts. Most users of our application will probably have a table called
    `1`. Therefore, when a restaurant patron indicates that he or she is at Table
    1 and wants service, we have to be able to pick the correct Table 1 from potentially
    many restaurants. To solve this, each table in our database will have a unique
    ID that we'll use for table identification in the URLs, but we'll display the
    user-chosen name (for example, `1`) on the **Account** page to allow our users
    to easily manage their personal list of tables.
  prefs: []
  type: TYPE_NORMAL
- en: When we insert a new item into our database, we'll get the unique ID of that
    item. But, because we want to use the ID as part of the URL, we get into a sort
    of chicken-or-egg-first situation where we need to insert the table into the database
    in order to get the ID, but we also need the ID in order to create the URL before
    we can properly insert the table into the database.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, we have to insert a half-created table into our database
    to get the ID, then use the ID to create the URL, and then update the table we
    just created to associate it with the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following route to your `waitercaller.py` file which does this (or
    rather, will do this once we''ve created the required functions in our database
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that we structure all the functionality of our application that is related
    to our account page under a `sub-route /account/`. We preface the function name
    for routes that belong to the account with `account_`. This helps us have clearer
    sections in our application code, which can become messy and unmaintainable as
    we add more and more routes.
  prefs: []
  type: TYPE_NORMAL
- en: We have to associate each table with an owner, so we use the `FlaskLogin current_user`
    functionality to get the currently logged-in user's ID. We're also going to use
    our `config.py` file to define the base URL to be associated with the tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following imports to `waitercaller.py` in order to use the `current_user`
    functionality and access our `config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the `config.py` file (remember, this isn''t part of the
    Git repository, so this value is only used for local development):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding URL is exactly equivalent to `localhost:5000` that we've been
    using, as `127.0.0.1` is a special IP address that always points back to your
    own machine. However, we'll use an IP address in our `config` instead of `localhost`
    to maintain compatibility with the Bitly API that we'll use in the next section,
    Shortening URL's using the bitly API, of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the create table database code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The mock database code for our tables is similar to that for our users and
    passwords. Create the following list of dictionaries at the top of the `mockdbhelper.py`
    file to store your tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code also creates a single table, `1`, and assigns it to our mock
    user. Note that `1,` which is the value of the `_id` key, is the ID number that,
    for our production system, will be unique across all user accounts. The `1` that
    is the value of the `number` key is the user-chosen value that might be duplicated
    across different users of our system. Because we only have one test user, we'll
    simplify our mock code, and always use the same value for both the unique ID and
    the user-chosen number.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our mock database, adding a table is simply appending a new dictionary
    that represents a table to our list of existing mock tables. Add the following
    method to the `mockdbhelper.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We return `number` from this function, which is the mock ID. In our test code,
    this is the same value that was input to this function. In our real code, this
    number will be the generated ID, and will be different from the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add the `update_table()` method that will allow us to associate
    a URL with a table. Add the following method to `mockdbhelper.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our application code gives the preceding method both the table ID generated
    by the `add_table()` method and the URL to associate with the table. The `update_table()`
    method then finds the correct table and associates the URL with the table. Again,
    the for loop through a list might look inefficient as opposed to using a dictionary,
    but it's important for our mock database code to use the same ideas as the real
    database code that we'll write in the next chapter. As our real database will
    store a collection of tables, our mock code emulates this by storing them in a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the view table database code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now have the functionality for adding new tables in place, but we can't see
    them yet. We want all the existing tables to be listed on the account page so
    that we can see which tables exist, have the ability to delete them, and view
    their URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the following method to `mockdbhelper.py` will allow us to access the
    existing tables of a specific user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Again, we simplify and have our test code ignore the `owner_id` argument and
    return all the tables (as we only have one test user). However, it's important
    that our mock methods take the same inputs and outputs as our real methods will,
    as we don't want our application code to be aware of whether it is running production
    or test code.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the account route to pass table data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We should get the latest information about the tables from the database and
    display these tables to the user each time our account page is loaded. Modify
    the `/account` route in `waitercaller.py` to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This preceding method now gets the tables from the database and passes the data
    through to the template.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the template to show the tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our template now has access to the table data, so all we need to do is to loop
    through each table and display the relevant information. The terminology used
    could get a bit confusing at this point, as we will use an HTML table to display
    information about our virtual restaurant tables, even though the uses of the word
    table are unrelated. HTML tables are a way to display tabulated data, which in
    our case is data about the restaurant tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `account.html` file, add the following code beneath the line `<h2>tables</h2>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a simple table of tables, displaying the table number
    (user chosen), the URL, and a delete button for each table. Each table is, in
    fact, a form that submits a request to delete that specific table. In order to
    do this, we also use a hidden input containing the unique ID of each table. This
    ID is passed along with the `delete` request so that our application code knows
    which table to delete from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the delete table route to our backend code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following route to your `waitercaller.py` file, which simply accepts
    the table ID that needs to be deleted and then asks the database to delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following method in `mockdbhelper.py`, which accepts a table ID
    and deletes that table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the update code that we wrote earlier, it's necessary to loop through
    the mock tables to find the one with the correct ID before we can delete it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the restaurant table code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve added quite a lot of code to our application. Since a lot of the different
    sections of code that we''ve added depend on each other, it has been difficult
    to actually run the code while writing it. However, now we have the functionality
    to create, view, and delete tables, so we can now give our application another
    test run. Fire up the application, log in, and navigate to the **Account** page.
    You should see the single mock table and be able to add more using the create
    table form. Play around by adding new tables and deleting the existing ones. When
    you add tables, they should get a URL associated with them based on their number
    (remember that for our production application, this number will be a long unique
    identifier instead of simply the number that we choose for our table). The interface
    should look like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the restaurant table code](img/B04312_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also take another look at the mobile view for this page by resizing the browser
    window, making it narrow enough to trigger the layout switch. Note that because
    we''ve used Bootstrap''s responsive layout features, the **Delete** buttons shunt
    up closer to the URLs and the **Create** button moves beneath the text input,
    as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the restaurant table code](img/B04312_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This might not look quite as good as the full-sized view, but it'll certainly
    be helpful to our visitors who want to use our site from their phones, as they
    won't need to worry about zooming in or scrolling sideways to access all the functionality
    of our site.
  prefs: []
  type: TYPE_NORMAL
- en: Shortening URLs using the bitly API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our users will not want to type in the long URLs that we currently provide for
    calling a waiter to their table. We'll now look at using the bitly API to create
    shorter equivalents of the URLs that we've already created. The shorter URLs,
    which can be typed into address bars (especially on mobile devices) more easily,
    will then be shown as being associated with the corresponding tables instead of
    the longer ones we have now.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Bitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The premise behind Bitly—and many similar services—is simple. Given a URL of
    arbitrary length, the service returns a shorter URL of the form `bit.ly/XySDj72`.
    Bitly and similar services normally have very short root domains (bit.ly is five
    letters), and they simply maintain a database that links the short URLs they create
    to the longer ones input by the users. Because they use a combination of lower-
    and uppercase characters as well as digits to create the shortened URLs, there
    is no shortage of combinations to use, even while keeping the total length of
    the URL very short.
  prefs: []
  type: TYPE_NORMAL
- en: Using the bitly API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the other APIs that we have used, bitly is free to use within certain
    limitations, but requires registration in order to get an API token. The bitly
    API is accessed over HTTPS and returns JSON responses (similar to what we've seen
    before). To interface with the API, we'll use a few lines of Python along with
    the `urllib2` and `json` standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a bitly oauth token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, bitly offers two ways of authenticating with their API.
    The first is to use an API token given to you when you register. The second way
    is to use an oauth token. As API tokens are being deprecated by bitly, we'll be
    using an oauth token.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to register an account on [bitly.com](http://bitly.com) and
    confirm your e-mail address. Simply head over to [bitly.com](http://bitly.com),
    hit the **Sign up** button, and give a username, e-mail address and password.
    Click the confirmation link that they send to the provided e-mail, and sign in
    to your bitly account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register for an oauth token, go to [https://bitly.com/a/oauth_apps](https://bitly.com/a/oauth_apps)
    and enter your password again when prompted. You should now see your new oauth
    token displayed on the screen. Copy this, as we''ll need it in the Python code
    that we''re about to write. It should look something like this: `ad922578a7a1c6065a3bb91bd62b02e52199afdb`'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the bitlyhelper file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the pattern we've used throughout the building of this web application,
    we'll create a `BitlyHelper` class to shorten the URLs. Again, this is good practice,
    as it allows us to easily replace just this module with another link shortening
    service if we ever need to. Create a file named `bitlyhelper.py` in your `waitercaller`
    directory and add the following code, substituting your bitly oauth token as appropriate.
    The token in the following snippet is valid for this Waiter Caller application.
    You should substitute the token that you received by following the steps outlined
    above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This class, `BitlyHelper`, provides a single method that takes in a long URL
    and returns a short one. There should be nothing about the last code snippet that
    is difficult to understand, as it only uses the ideas we've already seen while
    using JSON-based APIs over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Using the bitly module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use our bitly code, we simply need to create a `BitlyHelper` object in our
    main application code, and then use it to create a short URL every time a new
    restaurant table is created. Modify the globals section of `waitercaller.py` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the import for `BitlyHelper()` to the imports section of `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now modify the `createtable` method to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Fire up the app and go to the account page again. Create a new table, and you
    should see that the URL of the new table is a bitly URL. If you visit this URL
    in the browser, you'll see that it automatically redirects to something like `http://127.0.0.1/newrequest/2`
    (which, in turn, should throw a server error at this point).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can associate a short URL with every new table created, we need
    to add the idea of a *request* to our application, so that when our users' patrons
    visit these URLs, we notify the restaurant of the request for attention.
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality to handle attention requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to deal with two aspects of attention requests. The first, as discussed
    earlier, is to create new requests when a user visits a URL. The second is to
    allow the waiters of the restaurant to view these requests and mark them as resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the attention request code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a user visits a URL, we should create an attention request and store it
    in the database. This attention request should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: The time the request was made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The table from which the request was made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As before, we'll just use a Python dictionary to represent the *attention request
    object*. We need to have our application code create new attention requests and
    allow these requests to be added, retrieved, and deleted from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the attention request route
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following route to `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This route matches a dynamic table ID. Since our URLs use the globally unique
    table ID and not the user-chosen table number, we don't need to worry about which
    restaurant owns the table. We tell our database to create a new request, which
    contains the table ID and the current time. We then display a message to the patron,
    notifying him or her that the request was successfully made. Note that this is
    the only route for the application that our users' patrons will use. The rest
    of the routes are all intended to be used only by the restaurant managers or waiters
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need the Python `datetime` module to get the current time. Add the
    following line to your imports section in `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Adding the attention request database code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The database code for the attention requests uses the same ideas as the code
    we recently added for dealing with restaurant tables. Add the following global
    at the top of `mockdbhelper.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding global creates a single mock attention request for table number
    1 (an existing mock table) and sets the time of the request to be the time when
    we started the `waitercaller` app by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we make changes to our app during development, the server restarts,
    and this time will also be updated to the current time whenever this happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add the import for the `datetime` module to the top of the
    `dbconfig.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For the actual `add_request()` method, it is again important to distinguish
    between the table number (user chosen) and the table ID (globally unique across
    all our users). The URL used for creating the request made use of the globally
    unique ID, but the waiters will want to see the human readable table name next
    to the request notification. At the time of adding a request, we therefore find
    the table number associated with the table ID and include that as part of the
    stored request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to `mockdbhelper.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use `table_id` as the unique ID for our dictionary that represents
    a request. As before, when we add a real database, we will generate a new request
    ID here, which will not be the same as our table ID.
  prefs: []
  type: TYPE_NORMAL
- en: Add the get and delete methods for attention requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While we are editing the database code, add the following methods as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first method gets all attention requests for a specific user and will be
    used to populate our dashboard page with all the unresolved requests that require
    attention from waiters. The second deletes a specific request and will be used
    (also from the dashboard page) when waiters mark a request as resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If our Waiter Caller application aimed to provide more advanced functionality,
    we might add a property to requests to mark them as resolved, instead of deleting
    them outright. If we wanted to provide an analysis on how many requests were being
    made, how long they took on an average to be resolved, and so on, then keeping
    the resolved requests would be essential. For our simple implementation, resolved
    requests are of no further use, and we simply delete them.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the dashboard route to use attention requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the restaurant manager or waiter opens the dashboard of the app, they should
    see all current attention requests along with the time when the request was made
    (so that the patrons who have been waiting for longer can be prioritized). We
    have the time the request was logged, so we'll calculate the time elapsed since
    the request was made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `dashboard()` route in `waitercaller.py` to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The modified `dashboard()`route grabs all the attention requests that belong
    to the currently logged in user, using `current_user.get_id()` as before. We calculate
    a *delta time* for each request (the current time minus the request time) and
    add this as an attribute for each request in our requests list. Then we pass the
    updated list through to the template.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the template code to display attention requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want our dashboard code to check if any attention requests exist and then
    to display each of these in a way similar to the way the tables are displayed
    on the account page. Every attention request should have a **Resolve** button
    to allow the waiter to indicate that he has dealt with the request.
  prefs: []
  type: TYPE_NORMAL
- en: If no attention requests exist, we should display the same message we had displayed
    on the dashboard page previously, indicating that all the patrons are currently
    satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the body of `dashboard.html`, removing the placeholder
    statement that we added previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very similar to the table code we saw for the `accounts`
    template. Instead of the **Delete** button, we have a **Resolve** button, which
    similarly uses a hidden text input containing the request ID to resolve the correct
    attention request.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the resolve request application code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add the application code to handle resolving requests. Similar to the
    way we used the sub-route `/account` for all our account functionality, we use
    `/dashboard` in the form discussed earlier. Add the following route to `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We've already added the database code to remove an attention request, so here
    we simply need to call that code with the correct request ID, which we have from
    the hidden field in our template.
  prefs: []
  type: TYPE_NORMAL
- en: With that, most of the functionality of our application should be testable.
    Let's try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the attention request code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fire up the app, and test out all the new functionality. First, navigate to
    the **Account** page and then, in a new tab, navigate to the URL listed for the
    test table (or add a new table and use the new URL to retest the earlier code
    as well). You should see the ''**Your request has been logged and a waiter will
    be with you shortly**'' message as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the attention request code](img/B04312_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now go back to the application and navigate to the **Dashboard** page. You
    should see the mock request as well as the new request you just created by visiting
    the URL, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the attention request code](img/B04312_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Refresh the page and note that the values in the '**Wait**' column get incremented
    appropriately (every refresh will recalculate the deltas in the application code).
  prefs: []
  type: TYPE_NORMAL
- en: Auto-refreshing the dashboard page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The waiters will not want to constantly refresh the dashboard in order to check
    for new requests and to update the wait times on the existing one. We'll add a
    meta HTML tag to tell the browser that the page should be refreshed at regular
    intervals. We'll add a generic placeholder for meta tags in our base template
    and then override it with the refresh tag in our `dashboard.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `dashboard.html` file, add a Jinja block that contains the meta HTML
    tag above the content block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Meta HTML tags indicate messages that don't directly relate to the content that
    we are serving. They can also be used to add information about the author of a
    page or to give a list of keywords that search engines may use while indexing
    the page. In our case, we're specifying a meta tag that asks the browser to refresh
    every ten seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `base.html` file, create an equivalent empty placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now open the app in your browser again and navigate to the dashboard page. Every
    10 seconds, you should see the page refresh and the wait times update. If you
    create new attention requests, you'll see these appear after the automatic refresh
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding user feedback with WTForms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a web application that is largely functional, but still fails to
    provide the user with helpful feedback, especially when it comes to submitting
    web forms. Let's look at how to make our application more intuitive by providing
    feedback when the user succeeds or fails to complete various actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our life easier, we''ll use another Flask add-on, WTForms, which lets
    us validate inputs by using prespecified patterns or by creating our own. We''ll
    use WTForms to implement all our web forms, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: The registration form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sign-in form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The create table form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing WTForms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that creating the registration form for new users to
    sign up for our web app was a bit cumbersome. We had to create the HTML form in
    our template file and then fetch all the input data when the form was submitted
    in our Python backend code. In order to do this, we had to use the same strings,
    such as `email` and `password`, in our HTML code (for the `name` attribute) and
    in our Python code (to load the data from the various fields into variables).
    These strings, `email` and `password`, are examples of what are sometimes called
    *magic strings*. It might seem obvious to us, while creating the application,
    that the strings have to be the same in both the files, but to another developer
    who might need to maintain the application in the future, or even to our future
    selves, this implicit link might be a lot less obvious and more confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we had to use a fairly ugly `if` statement in our application code
    to make sure that the passwords matched. It turns out that we want to do much
    more validation on user input than just checking that the passwords match. We
    probably want to also validate that the e-mail address looks like an e-mail address,
    that the password isn't too short, and possibly more besides. As our user-input
    forms get longer, and the validation rules get more complicated, we can see that
    our application code would quickly get pretty messy if we carried on developing
    forms as we have been doing so far.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as mentioned earlier, our forms failed to provide the user with helpful
    feedback when things went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: WTForms solves all of these problems in a simple and intuitive way. We'll soon
    explain how to create Python classes to represent forms. These classes will contain
    validation rules, field types, field names, and feedback messages, all in the
    same place. Our Jinja templates and our application code can then use the *same
    object* to render the form (when the user views the page) and to process the input
    (when the user submits the form). Using WTForms therefore allows us to keep our
    code cleaner and to speed up development. We'll take a quick look at installing
    WTForms for Flask, before diving into how we can use it for improving our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note that WTForms is a general Python web development add-on that works with
    many different Python web development frameworks (such as Flask, Django, and others)
    and template managers (such as Jinja2, Mako, and others). We'll install a Flask-specific
    extension that will install WTForms and make it easy to interface with our Flask
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Flask-WTF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to install the WTForms add-on for Flask. This is done in the same way
    as our previous extensions. Simply run the following command (as always, remembering
    to do it both locally and on your VPS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating the registration form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s take a look at building forms. We''ll be building a few forms, so
    we''ll create a new Python file in our project to hold all of these. In your `waitercaller`
    directory, create a file called `forms.py` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The class, `RegistrationForm`, inherits from `Form`, a generic form object that
    we find inside the `flask_wtf` extension. Everything else is from the `wtforms`
    module directly (and not from the Flask-specific extension). The form is built
    from a number of different fields—in our case, an `EmailField`, two `PasswordFields`,
    and a `Submit` field. All of these will be rendered as their HTML equivalents
    in our template. We assign each of these desired fields to variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use these variables to render the fields and to retrieve data from the
    fields. Each time we create a field, we pass in some arguments. The first is a
    string argument to name the form. The second argument is a list of Validators.
    **Validators** are sets of rules that we can use to differentiate between valid
    input and invalid input. WTForms provides all the validators that we need, but
    it''s also easy to write custom validators. We use the following validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataRequired`: This simply means that if the field is left blank, the form
    is invalid for all fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Email`: This uses a regular expression to ensure that the e-mail address is
    made up of alphanumeric characters, and has an @ symbol and a full-stop in their
    appropriate places. (Fun fact: this is a surprisingly complicated problem! See
    [http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html).)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EqualTo`: This ensures that the data entered in the field is the same as the
    data entered into another field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Length`: This validator takes optional min and max arguments to define the
    number of characters the data should contain. We set this to a minimum of 8 to
    ensure that our users don''t pick very weak passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall our discussion of the trade-offs between backend and frontend validation
    and note that these are all backend validation methods, completed server-side.
    Therefore, it is still worthwhile to add the `Email` validator even if the user's
    browser supports HTML5; the fact that it is an `email` field will prevent the
    user from submitting an invalid e-mail address (using a frontend validation check).
  prefs: []
  type: TYPE_NORMAL
- en: Another thing about validators is that we can add a message argument for each
    validator—not just for each field—and each field can have more than one validator.
    We'll see later how to display this message to the user if that specific validation
    check fails.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the variable names you choose for each form field
    (`email`, `password`, and `password2` in the registration form that we created
    previously) are more important than most variable names because the `name` and
    `id` attributes for the final HTML field will be taken from the variable names.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the registration form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to use our form object for rendering an empty registration
    form when a user loads our home page. To do this, we have to modify both our application
    code (to create an instance of the registration form class and pass it to the
    template) and our frontend code (to render our fields from the variables of the
    class, instead of hardcoding them in HTML).
  prefs: []
  type: TYPE_NORMAL
- en: Updating the application code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our `waitercaller.py` file, we need to import the form we created, instantiate
    it, and pass it to our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an import for our registration form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now instantiate the form in our `home()` function and pass the form on to the
    template. The final `home()` function should read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Updating the template code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that our template has access to an instantiated `RegistrationForm` object,
    we can use Jinja to render the fields of our form. Update the registration form
    in `home.html` to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The Bootstrap boilerplate (the div tags specifying Bootstrap classes) remains
    unchanged, but now, instead of creating input fields in HTML, we call functions
    belonging to our `registrationform` variable that was passed in from the `home()`
    route. Each variable that we declared in our `RegistrationForm` class (`email`,
    `password`, `password2`, and `submit`) is available as a function to which we
    can pass additional HTML attributes as arguments. The `name` and `id` attributes
    will be set automatically based on the variable names we provided when we wrote
    the form, and we can add further attributes, such as `class` and `placeholder`
    by passing them in here. As before, we use '`form-control`' as the class of our
    inputs, and also specify the '`placeholder`' values to prompt the user to input
    information.
  prefs: []
  type: TYPE_NORMAL
- en: We also render the `csrf_token` field at the beginning of the new code. This
    is a very useful security default that WTForms provides. One of the more common
    web application vulnerabilities is called **Cross Site Request Forgery** (**CSRF**).
    Although a detailed description of this vulnerability falls outside the scope
    of this book, in short, it exploits the fact that cookies are implemented at the
    browser level rather than at a web page level. Because cookies are used for authentication,
    if you log into your one site that is vulnerable to CSRF, and then in a new tab,
    navigate to a malicious site that can exploit a CSRF vulnerability, the malicious
    site can carry out actions on the vulnerable site on your behalf. This is achieved
    by sending across the legitimate cookie (that you created when you logged into
    the vulnerable site), along with an action that requires authentication. In the
    worst case scenario, the vulnerable site is your online banking, and the malicious
    site carries out financial transactions on your behalf, without your knowledge,
    using the CSRF vulnerability. The CSRF token mitigates against this vulnerability
    by adding a hidden field to every form with a cryptographically secure set of
    randomly generated characters. Because the malicious site cannot access this hidden
    field (even though it can access our cookies), we know that a POST request that
    includes these characters originates from our site, and not a malicious third-party
    one. If you find this level of web application security interesting, read more
    about the CSRF vulnerability on the **Open Web Application Security Project**
    (**OWASP**) website ([https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))).
    Either way, you should always include the CSRF field in all forms—in fact, the
    validation step will fail if you omit it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the new form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we used the same Id and name attributes for our form as we did before,
    our application code for handling the processing of data when the form is submitted
    will still work. Therefore, fire up the application and make sure that everything
    is still working at this point. If all has gone well, the home page of the application
    will look identical to when we last tested our application. You should also be
    able to use your browser's 'view source' function to check that the various form
    fields were converted into various HTML input types as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Using WTForms in our application code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to update our application code to use WTForms for catching
    data that has been input through the form. Now, instead of having to remember
    which "name" attributes we used, we can simply instantiate a new `RegistrationForm`
    object and populate it from the post data received backend. We can also easily
    run all our validation rules and get a list of errors for each field.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `waitercaller.py`, modify the `register()` function to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the first change is the first line of the function. We
    instantiate a new `RegistrationForm` and populate it by passing in the `request.form`
    object, from which we previously pulled each field individually. As mentioned
    before, it's great that we don't have to hardcode the field names now! We can
    instead access the user's input data through the forms properties, such as `form.email.data`.
  prefs: []
  type: TYPE_NORMAL
- en: The second line is also a big change. We can call `form.validate()` to run all
    our validation rules, and this will return `True` only if all the rules pass,
    else it will populate the form object with all the relevant failure messages.
    The last line of the function, therefore, will only get called if there are validation
    errors. In this case, we now re-render our home page template, passing across
    a fresh copy of the form (which now has a reference to the errors. We'll see how
    to display these in the next step).
  prefs: []
  type: TYPE_NORMAL
- en: If the e-mail address is found in our database, we now append an error message
    to the error messages for the e-mail field and re-render the template to pass
    this error back to the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Note that previously, our three return options were all simply redirected to
    the home page, made using the Flask `redirect()` function. Now we have replaced
    them all with `render_template()` calls, as we need to pass the new form (with
    the error messages added) along to the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying errors to our user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final step for our new registration form is to display any errors to the
    user so that the user can fix them and resubmit the form. To do this, we'll add
    some Jinja `if` statements to our template to check if any errors exist in the
    form object and display them if they do. Then we'll add some CSS to make these
    errors appear in red. Finally, we'll look at how we could do all of this more
    concisely (which we'd definitely want if we had more and larger forms).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the errors in our template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All we need to do to display the errors is add an `if` statement above each
    of our input fields, checking if there are any errors to display for that field
    (remember WTForms automatically populates the error lists for our form object
    when we run the `validate()` method). If we find errors to display for that field,
    we need to loop through all of them and display each one. Although, in our case,
    each field can only have a single error, remember that we can add more than one
    validator to each field, so it's definitely possible to have forms which have
    several errors for each field. We don't want the user to have to fix one error
    and resubmit, only to find out that there are still others—instead, the user would
    want to be informed of all errors after a single submission of the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the registration form in `home.html` to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that we display our errors by building a list (within the `<ul>` tags),
    and that we assign these lists the class attribute of `errors`. We don't have
    any CSS code yet to define what error lists should look like, so let's fix that
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CSS for the errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The CSS code for the errors is the only custom CSS code we'll be using in the
    project (the rest of our CSS is all free with Bootstrap). Therefore, it's fine
    to add our CSS directly into the `base.html` template file (we'll use it in our
    other templates as well), instead of creating a new external CSS file or editing
    the Bootstrap files.
  prefs: []
  type: TYPE_NORMAL
- en: If you're curious, take a look at the `bootstrap.min.css` file inside the `static/css`
    directory and note that it's quite difficult to read and modify (it's all in a
    single line!). The reason for this is to make the page load faster—every space
    and newline character makes the file a little bit bigger, which means our users'
    browsers would take longer to download the CSS file that is needed to display
    the web page. This is why large CSS and JavaScript libraries (such as the Bootstrap
    ones) come with a *minified* version (this is what the 'min' in `bootstrap.min.css`
    stands for). If we wanted to add our new CSS code to the Bootstrap file, we'd
    probably add it to the non-minified version and then re-minify it to create the
    minified one that we'd use in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following style between the `<head>` tags of the `base.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first line in the preceding styling code means that it should only apply
    to `<ul>` elements which have a class of errors (that is, the feedback messages
    we just added to our home page). The next three lines remove the bullet point
    that lists use by default, remove the indent that lists use by default, and set
    the font color to red.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the final registration form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our registration form is now finished. It now uses WTForms, so it is cleaner
    and easier to maintain, and we don't have to rely on a developer knowing that
    the HTML `name` attribute has to match up with the Python code. Let's have a look
    to make sure everything still works and that our new error messages are displayed
    when we expect them to be and are not shown when we don't want them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your application again and try to register a new account. Try out various
    combinations of errors, such as using an already registered e-mail address (remember
    that our test database is cleared every time we restart the application), using
    a password that is too short, using non-matching strings for the two `password`
    fields, or using an invalid e-mail address. If all has gone according to plan,
    your form with errors should look similar to the one below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the final registration form](img/B04312_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a couple of interesting things to note about the last image. First,
    note that the e-mail address `g@1` is taken to be valid by the HTML5 input box
    (frontend validation), but not by the `Email()` validator (backend validation).
    This is why I could submit the form even though I'm using a browser that supports
    the HTML5 e-mail field, and was only told that the e-mail address was invalid
    after the data went to the backend. Second, note that after the form was submitted,
    the e-mail address was repopulated automatically, while the password fields are
    now blank. This is a useful default of most browsers. We are likely to want to
    submit similar information the second time round, after fixing the errors, but
    for security reasons, we always want to get rid of passwords as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note the '**Invalid email address**.' message in the preceding image. In our
    `forms.py` file, we only specified the error message for the case when the password
    was too short, but WTForms provides default messages for its built-in validators.
    Similarly, if you leave the password field blank, you'll see the message '**This
    field is required**'—another useful default that we did not have to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s most of the heavy lifting done for form validation and user feedback.
    Now that you have a good conceptual grasp of how everything works, we''ll go over
    it quickly once:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying feedback when the user's registration is successful (at the moment,
    we rather pessimistically only seem to be confirmed with failure, but the user
    will want to know that an account has been successfully registered if everything
    goes well).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving our login form to WTForms and adding feedback for when users fail to
    log in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving our '`new table`' form to WTForms and adding feedback where necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a successful registration notification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, we would show the user a new page after a successful registration,
    thanking them for registering and informing them that everything has been successful
    (see the next chapter for a more complete list of things we could improve on if
    we were writing this application for a production environment instead of using
    it as an educational project). To keep our application to as few pages as possible,
    and to prevent this book from growing too long, we'll show the user a JavaScript
    popup box instead. Generally, when creating user interfaces, we want to avoid
    as many popups as possible, as users find them irritating. However, they are occasionally
    necessary, so using one here will help keep our application simple and give us
    an opportunity to learn a bit more JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is event-based. This means that we can write code that is triggered
    by user actions (such as a mouse click) or other events such as an '`onload`'
    event, which is triggered when a specific resource loads in the user's browser.
    Previously, in our Crime Map project, we used this to initialize the JavaScript
    Google Map widget after the `<body>` tag had loaded. Now we'll do something similar,
    but use this to display a JavaScript alert box instead. We'll also make our message
    dynamic and pass it to the frontend from the backend code.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the message from the application code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The backend change for this is easy. Simply change the `register()` function
    to pass in the appropriate message if we process all the input data without any
    errors. In `waitercaller.py`, update the `register()` function to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Using the message in the template code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The change is slightly trickier to implement in our template because we don't
    actually have access to the `<body>` tag (where we want to specify the JavaScript
    alert) in our `home.html` template. Instead, our `<body>` is defined in our `base.html`
    skeleton template from which all our other templates inherit.
  prefs: []
  type: TYPE_NORMAL
- en: To modify the `<body>` tag only in our `home.html` template, we need to make
    the `<body>` tag appear within an inheritable Jinja block, similar to our content
    block. To do this, we need to make changes to our `base.html` template and to
    our `home.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `base.html`, make the following change where the `<body>` tag is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `<body>` tag can be overwritten by child templates, as it appears inside
    a configurable block. In `home.html`, we''ll overwrite the `<body>` block directly
    after the first line, if an alert message is specified. Remember that if this
    message is not specified, the `home.html` template will simply inherit the default
    `<body>` tag from the `base.html` template. In `home.html`, add the following
    code directly after the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The only slightly tricky part is matching up all the quotation marks and brackets
    in the `onload` attribute. The entire `alert` function (the JavaScript we want
    to run) should appear within double quotation marks. The string inside the `alert`
    function (the message that is actually displayed to the user) should be inside
    single quotation marks. Finally, the `onloadmessage` variable should be inside
    double braces, so that we get the contents of the variable rather than the string
    of the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after a successful registration, the user will see an alert confirming
    that everything went well and that a login is possible, as seen in the following
    image. It would be better to add a new page to properly inform the user of the
    successful registration, but to keep our app simple (and so we could introduce
    the onload functionality, which is generally useful), we opted for a slightly
    messier way of communicating this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the message in the template code](img/B04312_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Modifying the login form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The changes necessary to move the login form to WTForms are very similar to
    the changes we made for the registration form, so we'll provide the code with
    minimal discussion. Refer to the code bundle if you are unsure where to insert
    the code or make changes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new LoginForm in the application code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `forms.py`, add the `LoginForm` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we specify a custom message for the password field's `DataRequired` validator,
    as the error messages won't align with the fields as nicely as they did for the
    registration form. We also use the variable names `loginemail` and `loginpassword`,
    as these will become the HTML element `id` and `name` attributes, and it's preferable
    that they don't get overridden by the `login` and `password` fields in the registration
    form on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `waitercaller.py`, add the import for the login form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And rewrite the `login()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It may seem that the "**Email or password invalid**" error is quite vague and
    could be more specific. It's true that the user may find it helpful to know where
    the mistake lies, as many people use many different e-mail addresses and different
    passwords. Thus, it would be convenient to know whether you, as a user, have entered
    the wrong e-mail and need to try to remember which e-mail address you signed up
    for, or if you have the correct e-mail address and have misremembered your anniversary
    or date of birth or whatever mnemonic you use to remember your password. However,
    the convenience is offset by yet another security issue. If we display "**Invalid
    password**" when the user enters a correct e-mail address but the incorrect password,
    this would allow a malicious attacker to try a large list of e-mail addresses
    against our website, and slowly build up a list of e-mail addresses that belong
    to our users. The attacker could then target these users in a phishing attack
    by using the knowledge that these users are our customers. This is yet another
    case that shows how developers have to be constantly vigilant against what information
    they might be allowing an attacker to infer, even if it's not directly provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last backend changes that we need to make are to initialize and pass in
    a new `LoginForm` object whenever we render the `home.html` template. These changes
    have to be made:'
  prefs: []
  type: TYPE_NORMAL
- en: Once in the `home()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three times in the `register()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change the `home()` function to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the last two lines of the `register()` function to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `return` statement in the middle of the `register()` function to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Using the new LoginForm in the template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the template changes, `home.html` should now use the following `login`
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Instead of displaying the errors above each field, as we did for the registration
    form, we'll just display all the errors above the login form. To do this, we can
    use the `loginform.errors` property, which is a dictionary mapping of each field
    to a list of its errors. The error displaying code is therefore slightly more
    verbose, as it has to loop through all the keys and values of this dictionary,
    and we use the `convenient |dictsort` Jinja notation to sort the dictionary before
    displaying the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the create table form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last form change we need to make is to the create table form, for when
    an already logged-in user adds a new restaurant table to his or her account. The
    new form to be added to `forms.py` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires a new import in `forms.py` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In `waitercaller.py`, we need to import the new form with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `account_createtable()` function to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `account()` route to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the form in the `account.html` template should be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'At the moment, if the user leaves the field blank and hits the **Create** button,
    we can only ever have a single error displayed on the `create table` form, that
    is, ''**This field is required**'', which we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying the create table form](img/B04312_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this in mind, it is debatable whether the for loop should loop through
    all the error messages. On the one hand, it is bad to 'future proof' too much,
    as you are left with a code base that contains a lot of unnecessary code that
    is over complicated. On the other hand, we may well add more error messages to
    the WTForm (such as if the user tries to create a table with a number that already
    exists), and therefore, it is arguably worthwhile to add the for loop.
  prefs: []
  type: TYPE_NORMAL
- en: The one form left that we have not converted to WTForms is the `delete table`
    form. As this is only a single **Submit** button, it is left as an exercise (the
    CSRF protection would still be a worthwhile gain in moving this form to WTForms.).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've fleshed out our application's functionality, and it's now a lot more powerful.
    We added **Dashboard** and **Account** pages, and wrote all the application code,
    database code, and frontend code to handle our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at Jinja templates as a way to avoid duplicating the frontend code,
    and we also looked at how to use the bitly API to shorten links.
  prefs: []
  type: TYPE_NORMAL
- en: We then added WTForms, and saw how this could make our user feedback easier,
    our forms easier to validate, and our web application more secure. Our users are
    now kept up-to-date with information about their registration, login, and usage
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll add a real database to our code and then work on
    some finishing touches.
  prefs: []
  type: TYPE_NORMAL
