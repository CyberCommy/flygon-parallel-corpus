- en: Creating a Simple React Native App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding styles to elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using images to mimic a video player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a toggle button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a list of items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using flexbox to create a layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and using navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Native is a fast-growing library. Over the last few years it has become
    very popular among the open source community. There's often a new release every
    other week that improves performance, adds new components, or provides access
    to new APIs on the device.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about the most common components in the library. To
    step through all of the recipes in this chapter, we'll have to create a new application,
    so make sure you have your environment up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Adding styles to elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have several components at our disposal, but containers and text are the
    most common and useful components to create layouts or other components. In this
    recipe, we'll see how to use containers and text, but most importantly we'll see
    how styles work in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the instructions in the previous chapter in order to create a new application.
    We'll name this application `fake-music-player`.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new application with Expo, a small amount of boilerplate code
    will be added to the `App.js` file in the `root` folder. This will be the starting
    point of any React Native application you build. Feel free to remove all boilerplate
    at the beginning of each recipe, as all code (including what's used in the `App.js`
    boilerplate) will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `App.js` file, we''re going to create a stateless component. This component
    will mimic a small music player. It will only display the name of the song and
    a bar to show the progress. The first step is importing our dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve imported the dependencies, we can build out the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have our component ready, so now we need to add some styles, to add colors
    and fonts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as our simulator and emulator are running our application, we should
    see the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b811e149-433a-4eb0-89bf-57e9676bc390.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*, we included the dependencies of our component. In this case, we
    used `View`, which is a container. If you're familiar with web development, `View`
    is similar to `div`. We could add more `Views` inside other `Views`, `Texts`,
    `Lists`, and any other custom component that we create or import from a third-party
    library.
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with React you'll notice that, this is a stateless component,
    which means it doesn't have any state; it's a pure function and doesn't support
    any of the life cycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: We're defining a `name` constant in the component, but in real-world applications
    this data should come from the props. In the return, we're defining the **JavaScript XML **(**JSX**)
    that we're going to need to render our component, along with a reference to the
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: Each component has a attribute called `style`. This property receives an object
    with all of the styles that we want to apply to the given component. Styles are
    not inherited (except for the `Text` component) by the child components, which
    means we need to set individual styles for each component.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we defined the styles for our component. We're using the `StyleSheet`
    API to create all of our styles. We could have used a plain object containing
    the styles, but by using the `StyleSheet` API instead of an object, we gain some
    performance optimizations, as the styles will be reused for every renderer, as
    opposed to creating an object every time the render method gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''d like to call your attention to the definition of the `title` style in
    *step 3*. Here, we''ve defined a property called `backgroundColor` and set `transparent`
    as its value. As a good exercise, let''s comment this line of code and see the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/92ede04a-de11-4f51-865a-d278c011698c.png)'
  prefs: []
  type: TYPE_IMG
- en: On iOS, the text will have an orange background color and it might not be what
    we really want to happen in our UI. In order to fix this, we need to set the background
    color of the text as transparent. But the question is, why is this happening?
    The reason is that React Native adds some optimizations to the text by setting
    the color from the parent's background color. This will improve the rendering
    performance because the rendering engine won't have to calculate the pixels around
    each letter of the text and the rendering will be executed faster.
  prefs: []
  type: TYPE_NORMAL
- en: Think carefully when setting the background color to `transparent`. If the component
    is going to be updating the content very frequently, there might be some performance
    issues with text, especially if the text is too long.
  prefs: []
  type: TYPE_NORMAL
- en: Using images to mimic a video player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are an important part of any UI, whether we use them to display icons,
    avatars, or pictures. In this recipe, we'll use images to create a mock video
    player. We'll also display the icons from the local device and a large image from
    a remote server (hosted by Flickr).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow the steps in this recipe, let's create a new application.
    We're going to name it `fake-video-player`.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to display a few images in our application to mimic a video player,
    so you'll need corresponding images for your application. I recommend using the
    icons I used by downloading them from the repository for this recipe on GitHub
    at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/fake-video-player/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/fake-video-player/images).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we're going to do is create a new folder called `Images` in
    the root of the project. Add the images you've downloaded to the new folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `App.js` file, we include all of the dependencies we''ll need for this
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to `require` the images that''ll be displayed in our component. By
    defining them in constants, we can use the same image in different places:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use a stateless component to render the JSX. We''ll use all
    of the images we''ve declared in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the elements that we''re going to render, we need to define the
    styles for each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re done! Now, when you view the application, you should see something like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2570e533-9f2c-4a85-ae1d-6a02846bfa88.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we required the `Image` component. This is the component responsible
    for rendering images from the local filesystem on the device or from a remote
    server.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we required all of the images. It's good practice to require the
    images outside of the component in order to only require them once. On every renderer,
    React Native will use the same image. If we were dealing with dynamic images from
    a remote server, then we'd need to require them on every renderer.
  prefs: []
  type: TYPE_NORMAL
- en: The `require` function accepts the path of the image as a parameter. The path
    is relative to the folder that our class is in. For remote images, we need to
    use an object defining `uri` for where our file is.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, a stateless component was declared. We used `remoteImage` as the
    background of our application via an `ImageBackground` element, since `Image` elements
    cannot have child elements. This element acts similarly to the `background-url`
    property in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `source` property of `Image` accepts an object to load remote images or
    a reference to the required file. It''s very important to explicitly require every
    image that we want to use because when we prepare our application for distribution,
    images will be added to the bundle automatically. This is the reason we should
    avoid doing anything dynamic, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code won''t include the images in the final bundle. As a result,
    we''ll have errors when trying to access these images. Instead, we should refactor
    our code to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This way, the bundle will include both images when preparing our application
    for distribution, and we can decide which image to display dynamically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we defined the styles. Most of the properties are self-explanatory.
    Even though the images we're using for icons are white, I've added the `tintColor`
    property to show how it can be used to color images. Give it a try! Change `tintColor`
    to `#f00` and watch the icons turn red.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox is being used to align different portions of the layout. Flexbox in
    React Native behaves essentially the same as it does in web development. We'll
    discuss flexbox more in the *Using flexbox to create a layout* recipe later in
    this chapter, but the complexities of flexbox itself are outside the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a toggle button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buttons are an essential UI component in every application. In this recipe,
    we'll create a toggle button, which will be unselected by default. When the user
    taps on it, we'll change the styles applied to the button to make it appear selected.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to detect the tap event, use an image as the UI, keep the state
    of the button, and add styles based on the component state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a new app. We're going to name it `toggle-button`. We're going
    to use one image in this recipe. You can download the assets for this recipe from
    the corresponding repository hosted on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/toggle-button/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/toggle-button/images).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to create a new folder called `images` in the root of the project
    and add the heart image to the new folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s import the dependencies for this class next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For this recipe, we need to keep track of whether the button has been pressed.
    We''ll use a `state` object with a `liked` Boolean property for this purpose.
    The initial class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define the content of our new component inside the `render` method.
    Here, we''re going to define the `Image` button and a `Text` element underneath
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define some styles to set dimensions, position, margins, colors, and
    so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the project on the simulators, we should have something similar
    to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/48d16278-db2d-4bd2-8c50-b6b59c3153f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to respond to the tap event, we need to define the content of the
    `handleButtonPress` function and assign it as a callback to the `onPress` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we test our code, we won''t see anything changing on the UI, even though
    the state on the component changes when we press the button. Let''s add a different
    color to the image when the state changes. That way, we''ll be able to see a response
    from the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we imported the `TouchableHighlight` component. This is the component
    responsible for handling the touch event. When the user touches the active area,
    the content will be highlighted based on the `underlayColor` value we have set.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we defined the state of `Component`. In this case, there's only
    one property on the state, but we can add as many as needed. In [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml),
    *Implementing Complex User Interfaces – Part I*, we'll see more recipes about
    handling the state in more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we used the `setState` method to change the value of the `liked`
    property. This method is inherited from the `Component` class that we're extending.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 7*, based on the current state of the `liked` property, we used the
    styles to set the color of the image to red or we returned `undefined` to avoid
    applying any styles. When assigning the styles to the `Image` component, we used
    an array to assign many objects. This is very handy because the component will
    merge all of the styles into one single object internally. The objects with the
    highest index will overwrite the properties with the lowest object index in the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7af91424-5d64-4f7d-aa3e-72a9c2e7b3e1.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a real application, we're going to use several buttons, sometimes with an
    icon aligned to the left, a label, different sizes, colors, and so on. It's highly
    recommended to create a reusable component to avoid duplicating code all over
    our app. In [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*, we'll create a button component to handle some
    of these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a list of items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lists are everywhere: a list of orders in the user''s history, a list of available
    items in a store, a list of songs to play. Nearly any application will need to
    display some kind of information in a list.'
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we're going to display several items in a `list` component.
    We're going to define a JSON file with some data, then we're going to load this
    file using a simple `require` to finally render each item with a nice but simple
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating an empty app. We'll name this application `list-items`.
    We're going to need an icon to display on each item. The easiest way to get images
    is to download them from this recipe's repository hosted on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/list-items/images](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-2/list-items/images).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by creating an `images` folder and adding `basket.png` to it. Also,
    create an empty file in the root of the project called `sales.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `sales.json` file, we''ll define the data that we''re going to display
    in the list. Here''s some sample data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To avoid cluttering the pages of this book, I've only defined one record, but
    go ahead and add more content to the array. Copying and pasting the same object
    multiple times will do the trick. In addition, you could change some values on
    the data so that each item displays unique data in the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `App.js` file, let''s import the dependencies we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create the class to render the list of items. We''re going
    to keep the sales data on the state; that way, we could insert or remove elements
    easily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` method, we need to define the `ListView` component and we''ll
    use the `renderRow` method to render each item. The `dataSource` property defines
    the array of elements that we''re going to render on the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the contents of `renderRow`. This method receives each object
    containing all of the information we need. We''re going to display the data in
    three columns. In the first column, we''ll show an icon; in the second column,
    we''ll show the number of items for each sale and the address where this order
    will ship; and the third column will display the date and the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the JSX defined, it''s time to add the styles. First, we''ll define
    colors, margins, paddings, and so on for the main container, title, and row container.
    In order to create the three columns for each row, we need to use the `flexDirection:
    ''row''` property. We''ll learn more about this property in the *Using flexbox
    to create a layout* recipe later in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the simulators, we should see something similar to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0eb4c14f-0cae-4506-b78e-c90f26015e80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, inside the `StyleSheet` definition, let''s add styles for the icon. We''re
    going to add a yellow circle as the background and change the color of the icon
    to white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After this change, we''ll see a nice icon on the left side of each row, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/24055416-5280-4b11-b86c-16713a744c15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we''ll add the styles for the text. We need to set `color`, `size`,
    `fontWeight`, `padding`, and a few other properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3d839666-d353-4e9e-ba3a-320e4fd5f698.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 5*, we created the data source and added data to the state. The `ListView.DataSource`
    class implements performance data processing for the `ListView` component. The
    `rowHasChanged` property is required, and it should be a function to compare the
    next element. In our case, if the changes are different from the current data,
    which is represented as `(r1, r2) => r1 !== r2`, then React Native will know to
    respond and re-render the UI.
  prefs: []
  type: TYPE_NORMAL
- en: When filling up the data source with data, we need to call the `cloneWithRows`
    method and send an array of records.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to add more data, we should call the `cloneWithRows` method again with
    an array containing the previous and new data. The data source will make sure
    to compute the differences and re-render the list as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 7*, we define the JSX to render the list. Only two properties are
    required for the list: the data source we already have from *step 6* and `renderRow`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `renderRow` property accepts a function as a value. This function needs
    to return the JSX for each row.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've created a simple layout using flexbox; however, there's another recipe
    in this chapter where we'll dive into more detail about using flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our list, chances are that we're going to need to see the detail
    of each order. You can use the `TouchableHighlight` component as the main container
    for each row, so go ahead and give it a try. If you are not sure how to use the
    `TouchableHighlight` component, take a look at the *Creating a toggle button*
    recipe from earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using flexbox to create a layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn about flexbox. In the previous recipes in this chapter,
    we've been using flexbox to create layouts, but in this recipe, we'll focus on
    the properties we have at our disposal by recreating the layout from a random
    name generator application on the App Store called *Nominazer* ([https://itunes.apple.com/us/app/nominazer/id765422087?mt=8](https://itunes.apple.com/us/app/nominazer/id765422087?mt=8)).
  prefs: []
  type: TYPE_NORMAL
- en: Working in flexbox in React Native is essentially the same as working with flexbox
    in CSS. This means if you're comfortable developing websites with a flexbox layout,
    then you already know how to create layouts in React Native! This exercise will
    cover the basics of working with flexbox in React Native, but for a list of all
    of the layout props you can use, refer to the documentation on Layout Props ([https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by creating a new blank app. We'll name it `flexbox-layout`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `App.js`, let''s import the dependencies we''ll need for our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application only needs a `render` method since we''re building a static
    layout.  The rendered layout consists of a container `View` element and three
    child `View` elements for each colored section of the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can begin adding our styles. The first style we''ll add will be applied
    to the `View` element that wraps our entire app. Setting the `flex` property to
    `1` will cause all children elements to fill all empty space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the styles for the three child `View` elements. Each section
    has a `flexGrow` property applied to it, which dictates how much of the available
    space each element should take up. `topSection` and `bottomSection` are both set
    to `3`, so they''ll take up the same amount of space. Since the `middleSection`
    has the `flexGrow` property set to `1`, this element will take up one third of
    the space that `topSection` and `bottomSection` take up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open our application in the simulators, we should already be able to
    see the basic layout taking shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f05a61bb-3f96-4511-b497-9d169b08efe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can add a `Text` element to each of the three child `View` elements
    we created in *step 2*. Note the newly added code has been highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The text for each section defaults to the top-left corner of that section.
    We can use flexbox to justify and align each of these elements to the desired
    positions. All three child `View` elements have the `alignItems` flex property set
    to `''center''`, which will cause the children of each element to be centered along
    the *x* axis. `justifyContent` is used on the middle and bottom sections to define
    how child elements should be justified along the *y* axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left to be done is to add basic styles to the `Text` elements to
    increase `fontSize`, `fontWeight`, and the required `margin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open our application in simulators, we should be able to see our completed
    layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9ce98ba3-6356-4317-bd43-74a4596c41c6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is looking really good, and it was quite easy to accomplish
    by using flexbox. We created three distinct sections by using `View` elements
    that take up different fractions of the screen by setting the `flexGrow` properties
    to `3`, `1`, and `3`, respectively. This causes the top and bottom sections to
    be of equal vertical size, and the middle section to be one third the size of
    the top and bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using flexbox, we have two directions to lay out child content, `row`
    and `column`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`row`: This allows us to arrange the children of the container horizontally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column`: This allows us to arrange the children of the container vertically.
    This is the default direction in React Native.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When setting `flex: 1` as we did with the container `View` element, we''re
    telling that element to take up all available space. If we were to remove `flex:
    1` or set `flex` to `0`, we can see the layout collapse in on itself, since the
    container is no longer flexing into all of the empty space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c28d05ad-a247-4f43-9a90-77d41db556a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Flexbox is great for supporting different screen resolutions as well. Even though
    different devices may have different resolutions, we can ensure consistent layouts
    that will look good on any device.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some differences between how flexbox works in React Native and how
    it works in CSS. First, the default `flexDirection` property in CSS is `row`,
    whereas the default `flexDirection`  property in React Native is `column`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flex` property also behaves a bit differently in React Native. Instead
    of setting `flex` to a string value, it can be set to a positive integer, `0`,
    or `-1`. As the official React Native documentation states:'
  prefs: []
  type: TYPE_NORMAL
- en: When flex is a positive number, it makes the component flexible and it'll be
    sized proportional to its flex value. So, a component with flex set to 2 will
    take twice the space as a component with flex set to 1\. When flex is 0, the component
    is sized according to width and height and is inflexible. When flex is -1, the
    component is normally sized according width and height. However, if there's not
    enough space, the component will shrink to its minWidth and minHeight.
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot more to talk about with flexbox, but for now we've gotten our
    feet wet. In [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*, we'll learn more about layouts.  we'll learn
    more about layouts, and we'll create a complex layout that uses more of the available
    layout properties.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native Layout Props documentation ([https://facebook.github.io/react-native/docs/layout-props.html](https://facebook.github.io/react-native/docs/layout-props.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Native Text Style Props documentation ([https://facebook.github.io/react-native/docs/text-style-props.html](https://facebook.github.io/react-native/docs/text-style-props.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yoga ([https://github.com/facebook/yoga](https://github.com/facebook/yoga))—Facebook's
    Flexbox implementation utilized by React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An excellent Stack Overflow post that covers how React Native flex properties
    work, with examples—[https://stackoverflow.com/questions/43143258/flex-vs-flexgrow-vs-flexshrink-vs-flexbasis-in-react-native](https://stackoverflow.com/questions/43143258/flex-vs-flexgrow-vs-flexshrink-vs-flexbasis-in-react-native)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and using navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For any application that has more than one view, a navigation system is of
    paramount importance. The need for navigation is so pervasive in application development
    that Expo provides two templates when you create a new application: **Blank**
    or **Tab Navigation**. This recipe is based on a very pared down version of the Tab
    Navigation app template provided by Expo. We''ll still begin the recipe with a
    Blank app and build our basic Tab Navigation app from scratch to better understand
    all of the requisite parts. After completing this recipe, I encourage you to start
    a new app with the Tab Navigation template to see some of the more advanced features
    we''ll be covering in later chapters, including push notifications and stack navigation.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a new blank application named `simple-navigation`.
    We''re also going to need a third-party package for handling our navigation. We''ll
    be using 1.5.9 version of the `react-navigation` package. Using a newer version
    of this package will not work properly with this code, as the package''s API has
    recently gone through breaking changes.. In the Terminal, navigate to the root
    of the new project and install this package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: That's all of the setup we need. Let's build!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `App.js` file, let''s import our dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` component for this app will be very simple. We just need an `App`
    class with a `render` function that renders our app container. We''ll also add
    styles for filling the window and adding a white background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step for `App.js` will be to import and use the `MainTabNavigator`
    component, which is a new component that we''ll create in *step 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We'll need to create a new file for our `MainTabNavigator` component. Let's
    create a new folder in the root of the project called `navigation`. In this new
    folder, we'll create `MainTabNavigator.js` for our navigation component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MainTabNavigator.js`, we can import all of the dependencies we need for
    navigation. The dependencies include three screens (`HomeScreen`, `LinksScreen`,
    and `SettingsScreen`). We''ll add these screens in later steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Our navigation component will use the `TabNavigator` method provided by `react-navigation`
    for defining the routes and navigation for our app. `TabNavigator` takes two parameters:
    a `RouteConfig` object to define each route and a `TabNavigatorConfig` object
    to define the options for our `TabNavigator` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we''ll define the `RouteConfig` object, which will create a route map
    for our application. Each key in the `RouteConfig` object serves as the name of
    the route. We set the screen property for each route to the corresponding screen
    component we want to be displayed on that route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`TabNavigatorConfig` has a little more to it. We pass the `TabBarBottom` component
    provided by `react-navigation` to the `tabBarComponent` property to declare what
    kind of tab bar we want to use (in this case, a tab bar designed for the bottom
    of the screen). `tabBarPosition` defines whether the bar is on the top or bottom
    of the screen. `animationEnabled` specifies whether transitions are animated, and `swipeEnabled`
    declares whether views can be changed via swiping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `navigationOptions` property of the `TabNavigatorConfig` object, we''ll
    define dynamic `navigationOptions` for each route by declaring a function that
    takes the navigation prop for the current route/screen. We can use this function
    to decide how the tab bar will behave per route/screen, since it''s designed to
    return an object that sets `navigationOptions` for the appropriate screen. We''ll
    use this pattern to define the appearance of the `tabBarIcon` property for each
    route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tabBarIcon` property is set to a function whose parameters are the props
    for the current route. We''ll use the `focused` prop to decide whether to render
    a colored in icon or an outlined icon, depending on the current route. We get `routeName`
    from the navigation prop via `navigation.state`, define icons for each of our
    three routes, and return the rendered icon for the appropriate route. We''ll use
    the `Ionicons` component provided by Expo to create each icon and define the icon''s
    color based on whether the icon''s route is `focused`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step in setting up `MainTabNavigator` is to create the `Colors` constant
    used to color each icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our routing is now complete! All that's left now is to create the three screen
    components for each of the three routes we imported and defined in `MainTabNavigator.js`.
    For simplicity's sake, each of the three screens will have identical code, except
    for background color and identifying text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the root of the project, we need to create a `screens` folder to house our
    three screens. In the new folder, we'll need to make `HomeScreen.js`, `LinksScreen.js`,
    and `SettingsScreen.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by opening the newly created `HomeScreen.js` and adding the necessary
    dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HomeScreen` component itself is quite simple, just a full color page with
    the word `Home` in the middle of the screen to show which screen we''re currently
    on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to add the styles for our `Home` screen layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left now is to repeat *step 14*, *step 15*, and *step 16* for the
    remaining two screens, along with some minor changes. `LinksScreen.js` should
    look like `HomeScreen.js` with the following highlighted sections updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, inside `SettingsScreen.js`, we can create the third screen component
    using the same structure as the previous two screens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application is complete! When we view our application in the simulator,
    it should have a tab bar along the bottom of the screen that transitions between
    our three routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/10300526-2ca1-44b3-a4d7-8c8e94c3bf5a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we covered one of the most common and fundamental navigation
    patterns in native apps, the tab bar. The React Navigation library is a very robust,
    feature rich navigation solution and will likely be able to provide your app with
    any kind of navigation needed. We'll cover more uses of React Navigation in [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces - Part I.*
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Navigation official documentation ([https://reactnavigation.org/](https://reactnavigation.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expo's guide on routing and navigation ([https://docs.expo.io/versions/latest/guides/routing-and-navigation.html](https://docs.expo.io/versions/latest/guides/routing-and-navigation.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
