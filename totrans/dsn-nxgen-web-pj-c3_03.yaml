- en: Chapter 3. Omni Menu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With media queries, we can activate or deactivate CSS instructions when some
    device or viewport requirements are met. This is especially useful when we have
    to deal with elements that need to have different representations depending on
    the user''s device. The menu is usually such an element. In this chapter we will
    develop a main menu system that displays perfectly on desktop browsers and mobile
    devices; we can call it Omni Menu. We''re going to cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Setup operations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First level
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second level
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving parts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic transitions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some colors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile version
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving speed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next section we''ll start creating a basic HTML menu structure. As usual,
    we can store all of the project''s files in a folder named as the name of the
    project (`omni_menu` in this case). Before we begin, let''s look at a screenshot
    of the final result:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Omni Menu](img/3264OT_03_00.01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Setup operations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To style the menu, we need to define the markup first. Let's write a small HTML
    file, `index.html`, where we will define a classic two-level menu structure using
    `li` and `ul` items. Next, we'll add some basic CSS before moving to the central
    part of the chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We take advantage of the new `data-*` attributes to enhance semantically the
    items in the first level of our menu. We'll also see in a moment how these attributes
    can help us better style this structure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s open `application.css` and define a basic CSS structure to center
    this menu and add a nice background. For this part of the project we don''t focus
    on a mobile layout, so we can use a classic 960 px approach:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The highlighted part in the previous code defines a collapsed gradient in order
    to obtain a striped background. Next we define the size of the `nav` element to
    `960px` and put some nice gradient, shadows, and a border radius on it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'If we load the project in a CSS3 compatible browser, we can view the effects
    of our first styling:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Setup operations](img/3264OT_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Styling the first-level items
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The typical format in many two-level menus is to display the first-level items
    horizontally on the same line and then hide the second-level ones. We will add
    some CSS code to `application.css` to accomplish this, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the inline-block display
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous code, we used `display: inline-block` instead of floating the
    elements as is commonly done. Both these properties are commonly used to align
    elements inline, but the difference is that `display: inline-block` doesn''t break
    the page flow and saves us from using `clearfix`. However, there''s a drawback
    to using the `display: inline-block` property. Let''s see it in a small demo:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we load our demo page in a browser, the result is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the inline-block display](img/3264OT_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'You will notice that there is no space between **THREE** and **FOUR** but there
    are spaces between **ONE**, **TWO**, and **THREE**. Why is that so? This is because
    `display: inline-block` takes into account the spaces between the elements in
    the HTML markup. To avoid this issue, we will take care to ensure that we have
    consistent space or line breaks between each element.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Using new pseudo-selectors
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s move to the next interesting instruction: `nth-last-child(2)`.
    This is one of the many new pseudo-selectors introduced by CSS3\. With `nth-last-child(n)`
    we can target the `nth` element counting from the last, and with `nth-child(n)`
    we can do the same but starting from the top. These two pseudo-selectors can also
    be used to select elements through some kind of pattern. For example, suppose
    we want to highlight only the even elements of the following list:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can achieve this with the following simple CSS code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If instead we want to target only the elements with index greater than three,
    we can use the following CSS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the result of the previous example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Using new pseudo-selectors](img/3264OT_03_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Completing the first level
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We still have to add a few CSS properties to complete the styling of our first-level
    elements:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Well done! Now let''s run the project in a CSS3-compatible browser to appreciate
    the results:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Completing the first level](img/3264OT_03_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Styling submenus
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have to style the second-level items. Well, to be honest, we have already
    hidden them in the previous section in order to obtain a nice first-level styling,
    but now we can enrich the second-level elements with plenty of more properties
    and make sure they show up when users hover the mouse on their first-level parent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the last part we just discussed. In order to display the
    second-level elements, we have to use the `:hover` pseudo-selector:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have intercepted both the hover on the parent and on all of the children
    in order to keep the second-level menu displayed even when the mouse moves on
    them. Once done, we can start with some basic styling:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is just one small thing to underline here. Within the highlighted part
    of the previous code, there is an easy and simple fallback mechanism for browsers
    that do not support CSS3\. If we first declare an `rgb background-color` value
    and then an `rgba` one, we ensure that browsers that do not support CSS3 apply
    the `rgb` instruction and skip the `rgba` one, whereas browsers that do support
    CSS3 overwrite the `rgb` instruction with the `rgba` one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, time to reload the project in our preferred CSS3 browser and test the results:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling submenus](img/3264OT_03_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: In the next section, we're going to add some basic CSS in order to respond to
    mouse movements. For example, activating a particular submenu when the mouse is
    placed over its parent first-level menu.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Moving parts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have added a (yet unused) `<li class="cursor">` element at the end of the
    first and second levels. What we want to create is a block that is able to move
    under the element when the mouse hovers over it. It''s a nice effect, and to achieve
    it we are going to use CSS3 transitions. But first let''s create the same effect
    without animation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The highlighted code shows the special selector we use to toggle the visibility
    of our `.cursor` element. Basically, we display it if one of the previous `li`
    elements are hovered by the mouse.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have to define the absolute position of the `.cursor` element, which
    obviously depends on the `li` element we're hovering. To achieve this behavior,
    we chain the `+` selector in order to precisely move the cursor under the element.
    The same is done for the second-level elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: If we run the project in our browser, we may experience some disappointment.
    The effect is exactly the same as simply changing the `li` background using the
    `:hover` pseudo-selector.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving parts](img/3264OT_03_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Ok, time to add our hidden ingredient: transitions.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Adding transitions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logic behind transitions is simple yet powerful. We can instruct the browser
    to create an animation between two different property values. That''s it! We can
    use the `transition` property to specify that when a change occurs in another
    CSS property (for example, `width`), the element should not switch from one value
    to the other instantaneously but take a desired amount of time, thus creating
    an animation between the two values. The following example illustrates this effect:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `all` keyword tells the browser to take exactly one second to change from
    one property to the other for all the properties that support transition. In this
    case, when we hover the `a` element, the `color` property changes from `black`
    to `red`, but not instantaneously; instead, it covers all the colors between black
    and red in one second with a really cool effect.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding transitions](img/3264OT_03_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'We can do this trick with a lot of other properties and in many other ways,
    as we''ll see in the later chapters of this book. For the moment, we can use what
    we have learned to enhance our project. Let''s add a `transition` statement to
    `application.css`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this simple property, we have obtained a whole new result. Now every time
    we hover an element, the cursor moves under that element in a really smooth animation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding transitions](img/3264OT_03_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, `prefixfree.js` did not support transitions
    and animations in Internet Explorer 10\. So we have to remember to add a copy
    of the transition property with the `-ms-` experimental prefix. This is likely
    to change in the future, both because Microsoft will remove the need of experimental
    vendor prefixes, and because of a new version of this JavaScript library.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Now we have to handle another problem. The second-level menu appears too soon,
    with an unpleasant effect. How can we delay its appearance until the `.cursor`
    element has reached the right position under the `li` element? We will see this
    in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Introducing animations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Animations are one-step-forward transitions. With them, we can control the
    transition between one or more properties in detail. An animation is composed
    of a set of keyframes where each keyframe is basically a way to declare which
    values our chosen properties must have at a specific progress percentage of the
    animation. Let''s explore this feature with the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the `@keyframes` statement, we define the value of some properties of
    our choice during a progression from `0%` to `100%`. Once this is done, we can
    use the `animation` property with a few parameters, defined as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'First parameter: It specifies the name of the animation we want to execute
    on the element (for example, `fouredges` in the previous code).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second parameter: It specifies the total amount of time we want a single loop
    through the animation to take place in.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Third parameter: It specifies the accelerating function. Basically, we can
    decide whether the element should move at a constant velocity (with the keyword
    `linear`) or accelerate during the beginning or ending phase of each step of the
    animation (using `ease-in`, `ease-out`, or `ease`).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fourth parameter: It specifies the delay we want to apply to the beginning
    of the animation.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fifth parameter: It specifies the number of times we want the animation to
    be repeated. `infinite` is a valid value for this parameter as well as positive
    numbers.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sixth parameter: With the keyword `alternate`, we can ask the browser to toggle
    the direction of the animation. In other words, the animation will go first from
    `0%` to `100%`, and then from `100%` to `0%`, and over again.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we try the example we just wrote in a browser, we''ll see a square moving
    along a four-vertex path:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing animations](img/3264OT_03_09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'Well, that sounds interesting, but how can this help us with our project? Simple!
    We can use a delayed animation (an animation with some delay) to create a fade-in
    effect in the second-level menus. So let''s remove the `opacity: 1` temporary
    property we added earlier and add some CSS to `application.css`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `animation-fill-mode: forwards` property tells the browser not to revert
    to `0%` at the end of the animation, but to keep the `100%` position.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: With these new add-ons in our project, we can now try an almost complete desktop
    version in our browser. Enjoy the cursor animation and the second-level menu's
    fade-in effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'With the previous lines of code we have, however, removed the support to browsers
    that don''t handle CSS3 animations, in particular for IE9 and below. To handle
    this problem there are a lot of techniques, most of which will be unveiled during
    the course of this book. The first technique that we''ll implement works by substituting
    the `<html>` tag with something slightly more complex, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By using conditional comments, we can now identify when the user is browsing
    our website using IE9 or less because a new `.lteie9` class gets added to the
    `html` element.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can add a small chunk of code to our CSS file that gets triggered only
    when `.lteie9` is present:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding colors
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily change the color of the `.cursor` element depending on which
    element the mouse is hovering. We''ll also observe how the colors will change
    gradually, thanks to our `transition: all 1s` property, thus creating a really
    nice effect.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some properties to `application.css` to change the color of the
    `.cursor` element, and to add some colors to the second-level menus:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code, we target three different elements. First the `.cursor`
    element when the `li` element with attribute `data-section-portfolio` is in state
    `:hover`, next the second-level menu corresponding to the `li` element with attribute
    `data-section-portfolio`, and finally the `.cursor` element for this second-level
    menu. In this case, it is particularly useful to take advantage of a `data-*`
    attribute to mark semantically each item of the menu.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reload the project in the browser to view and experience the effect:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding colors](img/3264OT_03_10.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: Media queries
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Media queries is a simple yet incredibly powerful tool to activate some CSS
    properties, depending on certain browser and device characteristics, such as the
    browser''s viewport size, the device''s width and height, and orientation. Before
    diving into the details, let''s write a small script to experiment with this feature:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, we instruct the browser to apply the properties enclosed between
    the `@media` curly brackets *only* when the conditions expressed are satisfied.
    Let''s have a look at them:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`screen`: This keyword is one of the available media types, and is used to
    indicate which kind of media must implement the enclosed statements. There are
    plenty of media types described in the dedicated W3C specification ([http://www.w3.org/TR/CSS2/media.html#media-types](http://www.w3.org/TR/CSS2/media.html#media-types)),
    but only a few of them (`screen`, `print`, `projection`) are actually supported
    by today''s browsers.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-width`: This is one of the many conditional keywords we can chain to list
    the characteristics that must be present in a device in order to activate the
    enclosing statements. The `max-width` keyword can be read as "up to", so this
    condition is verified until the browser''s viewport size exceeds the given value.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we run the previous code in a CSS3-compatible browser, we can see something
    like the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Media queries](img/3264OT_03_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'But if we adjust the size of the window below `400px`, the statements within
    the media query get activated and the result will be something like the following
    screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Media queries](img/3264OT_03_12.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'Cool, isn''t it? Of course, there are other conditional keywords besides `max-width`.
    Let''s have a look at them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`min-width`: This keyword can be read as "the viewport width is minimum x",
    where x is the value assigned to the `min-width` property.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-height` and `min-height`: These keywords work in the same way as the `*-width`
    ones, but they are applied to the browser''s viewport height.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min-device-width`, `max-device-width`, `min-device-height`, and `max-device-height`:
    These keywords identify the real dimensions of the device; so if we want to target
    only screens bigger than 1900 x 1200, we have to write a rule such as `(min-device-width:
    1900px)` and `(min-device-height: 1200px)`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orientation`: The value for this property can be either `portrait` or `landscape`.
    It identifies the current orientation of the device.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are even more of such conditional keywords, but those not present in the
    previous list aren't so useful, and furthermore are not yet supported by any browser.
    Anyway, the full list can be viewed at [http://www.w3.org/TR/css3-mediaqueries/#media1](http://www.w3.org/TR/css3-mediaqueries/#media1).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define a media query in a `<link>` declaration using the `media`
    attribute, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, we have to take into account browsers that don''t understand
    media query statements because they will always load the linked CSS regardless
    of the conditions. To prevent this behavior, at least on older versions of Internet
    Explorer, we can wrap the `<link>` element with a conditional comment:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ok, now we know how media queries work, but how can we use this feature to target
    mobile devices? We can do it in two ways, using `max-device-width` or `max-width`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The `max-device-width` property checks the size of the device, which makes it
    difficult to emulate on a desktop web browser or laptop. The other drawback of
    using this property is that we don't want to change our layout based on the size
    of the screen; we want to change it in response to the size of the browser window.
    Therefore, the preferred property is `max-width`, which is the behavior that will
    give us the most flexibility for our menu system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have chosen the behavior to target mobile devices, we have another
    complication to resolve. In order to represent a desktop version of the page and
    then let the user zoom in and out, mobile devices fake their actual resolution.
    To force mobile browsers to expose their true dimensions and disable zoom, we
    can use a `<meta>` tag. This tag basically says that the maximum and minimum zoom
    factor must be equal to 1\. Add the following line to `index.html`, just after
    the `<head>` tag:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Well done! Now all we have to do is find the size we want to use as a trigger
    to enable our "mobile" CSS. We''ll use `320px`, which is the size of an iPhone
    handled in portrait mode. So let''s create a new `application_mobile.css` file
    under the `css` folder, and add the following `link` element just below the previous
    one in our `index.html` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Styling the mobile version
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are ready to start styling the mobile version of this project. To accomplish
    this, we're going to transform the menu from a horizontal shape to a vertical
    one. Instead of having a second-level menu, we will instead create some cards
    and make them slide in when the corresponding first-level menu item is clicked.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first of all, let''s write the necessary CSS to change the shape of our
    menu (within `application_mobile.css`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first highlighted instruction shows how we can take advantage of a really
    useful property called `box-sizing`, which basically says which parts of an element
    are influenced when setting its width. The options are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '`content-box`: In this option, width refers only to the box that surrounds
    the element''s content. Padding, margin, and border widths are excluded.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`padding-box`: This option is the same as the previous one, but this time width
    includes padding. Border and margin widths are still excluded.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`border-box`: This option is the same as the previous two, but this time only
    the margin width is excluded.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So when we write the following, we ask the browser to take care of 30 px of
    padding within the `100%` width:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we now try to load the project in a mobile browser (for example, from the
    iPhone simulator), or if we resize our desktop browser window below 320 px, we
    can experiment with this layout:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling the mobile version](img/3264OT_03_13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'We''ve already added the property `transition: left 1s` in the mobile version
    of the CSS code (`application_mobile.css`), so all we need to do is move the second-level
    menu to `left: 0px` when the corresponding first-level menu is clicked, in order
    to make it overlap the first-level menu. To achieve this, we can take advantage
    of the `:hover` pseudo-selector, which, in a mobile environment, is triggered
    when the user touches an element. So we can write the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The most important statement is the one highlighted; the others are there only
    to adjust some minor visual details. Now we can reload the project to appreciate
    the effects of the code we just wrote:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling the mobile version](img/3264OT_03_14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Handling the new layout on desktop browsers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we did in the last chunk of code works on mobile devices, but fails on
    desktop browsers because of the difference in the behavior of the `:hover` pseudo-selector.
    Even though it is really unlikely that someone would ever explore this project
    from a desktop computer with a browser whose width is less than 320 px, we can
    use a bit of JavaScript to address this problem. The following is the code to
    add to `index.html` before the `</head>` tag:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this code we check if the browser doesn't support touch events (and therefore
    doesn't support the `:hover` behavior we need) and then, if true, we add a `data-status='selected'`
    attribute to the element of the first-level menu that has been clicked by the
    user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this result, we used a very interesting library that we''ll cover
    in detail in the next chapter: Modernizr ([http://modernizr.com/](http://modernizr.com/)).
    This library contains some methods that check the presence of most of the HTML5
    and CSS3 features (for example, `Modernizr.touch`) returning `true` or `false`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, each feature is also expressed in the form of a class attached
    to the `html` element. For example, if there is a support for touch events, the
    `html` element receives the class `touch`; otherwise it receives the class `no-touch`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this step, all we need to do is restrict the selector that uses
    `:hover` to touch-enabled devices only and take care of the new `data-status="selected"`
    attribute. To do so, we need to change a little the `nav > ul > li > .item:hover
    + ul` selector within `application_mobile.css`, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Final adjustments
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now conclude this project by adding some more enhancements with the
    `:after` and `:before` pseudo-selectors. So let''s add this final touch to `application_mobile.css`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Every time we use CSS-generated content, we have to remember that the content
    we inject is not handled by a screen reader; so we have to take care of that either
    by injecting only non-essential content, such as in this case, or by providing
    a fallback mechanism.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, let''s reload the project in our mobile browser simulator for the last
    time to see the final result:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Final adjustments](img/3264OT_03_15.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Improving speed
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to improve the speed of the "slide in" animation, one of the most
    effective change we can implement is removing transparency from the background.
    To do this, we have to add some more CSS to `application_mobile.css` in order
    to overwrite the settings inherited from the desktop version:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementing in older browsers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been careful while developing this project, so even if the animations
    and the gradients are not supported by older browsers, the basic structure works
    perfectly. The following is a screenshot taken from Internet Explorer 8:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing in older browsers](img/3264OT_03_16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we experimented with the power of media queries and we started
    discovering animations and transitions. We also discovered the differences between
    `display:inline-block` and floating elements, and we started collecting a few
    tips on mobile performances. Of course we will have time to dig deeper into these
    new features in the following chapters, to discover many other interesting CSS3
    properties.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们尝试了媒体查询的强大功能，并开始探索动画和过渡效果。我们还发现了`display:inline-block`和浮动元素之间的区别，并开始收集一些关于移动性能的小贴士。当然，在接下来的章节中，我们会有时间深入了解这些新特性，发现许多其他有趣的CSS3属性。
- en: However, now it's time to turn the page and start working on a new interesting
    project involving handling infographics!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在是时候翻开新的一页，开始着手处理一个涉及信息图表的新项目了！
