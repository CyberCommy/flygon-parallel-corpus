- en: Reinventing Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the basics of Metasploit, so now we can move further into the
    underlying coding part of the Metasploit framework. We will start with the basics
    of Ruby programming to understand various syntaxes and its semantics. This chapter
    will make it easy for you to write Metasploit modules. In this chapter, we will
    see how we can design and fabricate various Metasploit modules with the functionality
    of our choice. We will also look at how we can create custom post-exploitation
    modules, which will help us gain better control of the exploited machine.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a scenario where the number of systems under the scope of the penetration
    test is massive, and we crave a post-exploitation feature such as downloading
    a particular file from all the exploited systems. Manually, downloading a specific
    file from each system is not only time-consuming, but inefficient. Therefore,
    in a scenario like this, we can create a custom post-exploitation script that
    will automatically download the file from all of the compromised systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter kicks off with the basics of Ruby programming in the context of
    Metasploit, and ends with developing various Metasploit modules. In this chapter,
    we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Ruby programming in the context of Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring modules in Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom scanners, brute force, and post-exploitation modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding Meterpreter scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the syntaxes and semantics of Metasploit modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing the impossible with **RailGun** by using DLLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's understand the basics of Ruby programming and gather the required
    essentials we need to code the Metasploit modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we delve deeper into coding Metasploit modules, we must have knowledge
    on the core features of Ruby programming that are required to design these modules.
    Why do we need Ruby for Metasploit? The following key points will help us understand
    the answer to this question:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing an automated class for reusable code is a feature of the Ruby language
    that matches the needs of Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby is an object-oriented style of programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby is an interpreter-based language that is fast and reduces development time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby - the heart of Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby is indeed the heart of the Metasploit framework. However, what exactly
    is Ruby? According to the official website, Ruby is a simple and powerful programming
    language and was designed by Yokihiru Matsumoto in 1995\. It is further defined
    as a dynamic, reflective, and general-purpose object-oriented programming language
    with functions similar to Perl.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Ruby for Windows/Linux from: [https://rubyinstaller.org/downloads/](https://rubyinstaller.org/downloads/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to an excellent resource for learning Ruby practically at: [http://tryruby.org/levels/1/challenges/0](http://tryruby.org/levels/1/challenges/0).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Ruby program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby is an easy-to-learn programming language. Now, let's start with the basics
    of Ruby. Remember that Ruby is a broad programming language, and covering all
    of the capabilities of Ruby will push us beyond the scope of this book. Therefore,
    we will only stick to the essentials that are required in designing Metasploit
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Ruby shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby offers an interactive shell, and working with it will help us understand
    the basics. So, let's get started. Open the CMD/Terminal and type `irb` to launch
    the Ruby interactive shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s input something into the Ruby shell and see what happens; suppose I
    type in the number `2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell simply returns the value. Let''s give another input, such as one
    with the addition operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can see that if we input numbers in an expression style, the shell returns
    the result of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform some functions on the string, such as storing the value of a
    string in a variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After assigning values to both variables, `a` and `b`, let''s see what happens
    when we issue `a` and `a+b` on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see that when we typed in `a` as the input, it reflected the value stored
    in the variable named `a`. Similarly, `a+b` gave us `a` and `b` concatenated.
  prefs: []
  type: TYPE_NORMAL
- en: Defining methods in the shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A method or a function is a set of statements that will execute when we make
    a call to it. We can declare methods easily in Ruby''s interactive shell, or we
    can declare them using scripts. Knowledge of methods is important when working
    with Metasploit modules. Let''s see the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To define a method, we use `def` followed by the method name, with arguments
    and expressions in parentheses. We also use an `end` statement, following all
    of the expressions to set an end to the method''s definition. Here, `arg` refers
    to the arguments that a method receives. Also, `expr` refers to the expressions
    that a method receives or calculates inline. Let''s have a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a method named `xorops`, which receives two arguments named `a`
    and `b`. Furthermore, we XORed the received arguments and stored the results in
    a new variable called `res`. Finally, we returned the result using the `return`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see our function printing out the correct value by performing the XOR
    operation. Ruby offers two different functions to print the output: `puts` and
    `print`. When it comes to the Metasploit framework, the `print_line` function
    is primarily used. However, symbolizing success, status, and errors can be done
    using `print_good`, `print_status`, and `print_error` statements, respectively.
    Let''s look at some examples here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These `print` methods, when used with Metasploit modules, will produce the
    following output that depicts the green `+` symbol for good, the blue `*` for
    denoting status messages, and the red `-` symbol representing errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will see the workings of various `print` statement types in the latter half
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and data types in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variable is a placeholder for values that can change at any given time. In
    Ruby, we declare a variable only when required. Ruby supports numerous variable
    data types, but we will just discuss the ones relevant to Metasploit. Let's see
    what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Working with strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are objects that represent a stream or sequence of characters. In Ruby,
    we can assign a string value to a variable with ease, as seen in the previous
    example. By merely defining the value in quotation marks or a single quotation
    mark, we can assign a value to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended to use double quotation marks because if single quotations
    are used, it can create problems. Let''s have a look at the problems that may
    arise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that when we used a single quotation mark, it worked. However, when
    we tried to put `Msf's` instead of the value `Msf`, an error occurred. This is
    because it read the single quotation mark in the `Msf's` string as the end of
    single quotations, which is not the case; this situation caused a syntax-based
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need string concatenation capabilities throughout our journey in dealing
    with Metasploit modules. We will have multiple instances where we need to concatenate
    two different results into a single string. We can perform string concatenation
    using the `+` operator. However, we can elongate a variable by appending data
    to it using the `<<` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we started by assigning the value `"Nipun"` to the variable
    `a`, and then appended `"loves"` and `"Metasploit"` to it using the `<<` operator.
    We can see that we used another variable, `b`, and stored the `"and plays counter
    strike"` value in it. Next, we simply concatenated both of the values using the
    + operator and got the complete output as `"Nipun loves Metasploit and plays counter
    strike"`.
  prefs: []
  type: TYPE_NORMAL
- en: The substring function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s quite easy to find the substring of a string in Ruby. We just need to
    specify the start index and length along the string, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The split function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can split the value of a string into an array of variables using the `split`
    function. Let''s have a look at a quick example that demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have split the value of a string from the `","` position
    into a new array, `b`. The `"mastering,metasploit"` string now forms the 0th and
    1st element of the array, `b`, containing the values `"mastering"` and `"metasploit"`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers and conversions in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use numbers directly in arithmetic operations. However, remember to convert
    a string into an integer when working on user input using the `.to_i` function.
    On the other hand, we can transform an integer number into a string using the
    `.to_s` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at some quick examples, and their output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that when we assigned `a` value to `b` in quotation marks, it was
    considered as a string, and an error was generated while performing the addition
    operation. Nevertheless, as soon as we used the `to_i` function, it converted
    the value from a string into an integer variable, and an addition was performed
    successfully. Similarly, regarding strings, when we tried to concatenate an integer
    with a string, an error showed up. However, after the conversion, it worked perfectly
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: Conversions in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with exploits and modules, we will require tons of conversion
    operations. Let''s see some of the conversions we will use in the upcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal to decimal conversion**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s quite easy to convert a value to a decimal from a hexadecimal in Ruby
    using the inbuilt `hex` function. Let''s look at an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see we got the value `16` for a hexadecimal value of `10`.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decimal to hexadecimal conversion**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The opposite of the preceding function can be performed with the `to_s` function,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Ranges in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ranges are important aspects, and are widely used in auxiliary modules such
    as scanners and fuzzers in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a range, and look at the various operations we can perform on
    this data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see that a range offers various operations, such as searching, finding
    the minimum and maximum values, and displaying all the data in a range. Here,
    the `include?` function checks whether the value is contained in the range or
    not. In addition, the `min` and `max` functions display the lowest and highest
    values in a range.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can simply define arrays as a list of various values. Let''s have a look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, we have covered all the required variables and data types
    that we will need for writing Metasploit modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on variables and data types, refer to the following link:
    [https://www.tutorialspoint.com/ruby/index.htm](https://www.tutorialspoint.com/ruby/index.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to a quick cheat sheet for using Ruby programming effectively at the
    following link: [https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transitioning from another programming language to Ruby? Refer to a helpful
    guide: [http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting).'
  prefs: []
  type: TYPE_NORMAL
- en: Methods in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A method is another name for a function. Programmers with a different background
    than Ruby might use these terms interchangeably. A method is a subroutine that
    performs a specific operation. The use of methods implements the reuse of code
    and decreases the length of programs significantly. Defining a method is easy,
    and their definition starts with the `def` keyword and ends with the `end` statement.
    Let''s consider a simple program to understand how they work for example, printing
    out the square of `50`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `print_data` method receives the parameter sent from the main function,
    multiplies it with itself, and sends it back using the `return` statement. The
    program saves this returned value in a variable named `answer`, and prints the
    value. We will use methods heavily in the latter part of this chapter as well
    as in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Decision-making operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decision-making is also a simple concept, as with any other programming language.
    Let''s have a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also consider the case of string data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider a simple program with decision-making operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we used the word `"Metasploit"`, which sits right
    in the middle of junk data and is assigned to the `a` variable. Next, we send
    this data to the `find_match()` method, where it matches the `/Metasploit/` regex.
    It returns a true condition if the `a` variable contains the word `"Metasploit"`,
    otherwise a false value is assigned to the `bool_b` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Running the preceding method will produce a valid condition based on the decision-making
    operator, `=~`, that matches both the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding program will be somewhat similar to the following
    output when executed in a Windows-based environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Loops in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iterative statements are termed as loops; as with any other programming language,
    loops also exist in Ruby programming. Let''s use them and see how their syntax
    differs from other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code iterates the loop from `0` to `10`, as defined in the range,
    and consequently prints out the values. Here, we have used `#{i}` to print the
    value of the `i` variable in the `print` statement. The `n` keyword specifies
    a new line. Therefore, every time a variable is printed, it will occupy a new
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating loops through `each` loop is also a common practice and is widely
    used in Metasploit modules. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined a method that accepts an array, `a`, and prints
    all its elements using the `each` loop. Performing a loop using the `each` method
    will store elements of the `a` array into `i` temporarily, until overwritten in
    the next loop. `t`, in the `print` statement, denotes a tab.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [http://www.tutorialspoint.com/ruby/ruby_loops.htm](http://www.tutorialspoint.com/ruby/ruby_loops.htm)
    for more on loops.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are used to match a string or its number of occurrences
    in a given set of strings or a sentence. The concept of regular expressions is
    critical when it comes to Metasploit. We use regular expressions in most cases
    while writing fuzzers, scanners, analyzing the response from a given port, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at an example of a program that demonstrates the usage of
    regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where we have a variable, `n`, with the value `Hello world`,
    and we need to design regular expressions for it. Let''s have a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created another variable called `r` and stored our regular expression
    in it, namely, `/world/`. In the next line, we match the regular expression with
    the string using the `match` object of the `MatchData` class. The shell responds
    with a message, `MatchData "world"`, which denotes a successful match. Next, we
    will use another approach of matching a string using the `=~` operator, which
    returns the exact location of the match. Let''s see one other example of doing
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's assign a new value to `r`, namely, `/^world/`; here, the `^` operator
    tells the interpreter to match the string from the start. We get `nil` as an output
    if it is not matched. We modify this expression to start with the word `Hello`;
    this time, it gives us back the location `0`, which denotes a match as it starts
    from the very beginning. Next, we modify our regular expression to `/world$/`,
    which denotes that we need to match the word `world` from the end so that a successful
    match is made.
  prefs: []
  type: TYPE_NORMAL
- en: For further information on regular expressions in Ruby, refer to: [http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm](http://www.tutorialspoint.com/ruby/ruby_regular_expressions.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to a quick cheat sheet for using Ruby programming efficiently at the
    following links: [https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf)
    and [http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting).'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [http://rubular.com/](http://rubular.com/) for more on building correct
    regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up with Ruby basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hello! Still awake? It was a tiring session, right? We have just covered the
    basic functionalities of Ruby that are required to design Metasploit modules.
    Ruby is quite vast, and it is not possible to cover all of its aspects here. However,
    refer to some of the excellent resources on Ruby programming from the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: An excellent resource for Ruby tutorials is available at: [http://tutorialspoint.com/ruby/](http://tutorialspoint.com/ruby/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A quick cheat sheet for using Ruby programming efficiently is available at
    the following links:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf](https://github.com/savini/cheatsheets/raw/master/ruby/RubyCheat.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://hyperpolyglot.org/scripting](http://hyperpolyglot.org/scripting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on Ruby is available at: [http://en.wikibooks.org/wiki/Ruby_Programming](http://en.wikibooks.org/wiki/Ruby_Programming)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing custom modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dig deeper into the process of writing a module. Metasploit has various
    modules such as payloads, encoders, exploits, NOP generators, and auxiliaries.
    In this section, we will cover the essentials of developing a module; then, we
    will look at how we can create our custom modules.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the development of auxiliary and post-exploitation modules.
    Additionally, we will cover core exploit modules in the next chapter. But, for
    this chapter, let's examine the essentials of module building in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Building a module in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving deep into building modules, let's understand how the components
    are arranged in the Metasploit framework, and what they do.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of the Metasploit framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metasploit contains various components, such as necessary libraries, modules,
    plugins, and tools. A diagrammatic view of the structure of Metasploit is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cbc993e-fac3-4a57-83d3-352590424706.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see what these components are and how they work. It is best to start
    with the libraries that act as the heart of Metasploit. We can see the core libraries
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Library name** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `REX` | Handles almost all core functions such as setting up sockets, connections,
    formatting, and all other raw functions |'
  prefs: []
  type: TYPE_TB
- en: '| `MSF CORE` | Provides the underlying API and the actual core that describes
    the framework |'
  prefs: []
  type: TYPE_TB
- en: '| `MSF BASE` | Provides friendly API support to modules |'
  prefs: []
  type: TYPE_TB
- en: 'We have many types of modules in Metasploit, and they differ in functionalities.
    We have payload modules for creating access channels to exploited systems. We
    have auxiliary modules to carry out operations such as information gathering,
    fingerprinting, fuzzing an application, and logging in to various services. Let''s
    examine the basic functionality of these modules, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module type** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Payloads | Payloads are used to carry out operations such as connecting to
    or from the target system after exploitation, or performing a specific task such
    as installing a service, and so on.Payload execution is the very next step after
    a system is exploited successfully. The widely used Meterpreter shell in the previous
    chapter is a typical Metasploit payload. |'
  prefs: []
  type: TYPE_TB
- en: '| Auxiliary | Modules that perform specific tasks such as information gathering,
    database fingerprinting, port scanning, and banner grabbing on a target network
    are auxiliary modules. |'
  prefs: []
  type: TYPE_TB
- en: '| Encoders | Encoders are used to encode payloads and attack vectors to evade
    detection by antivirus solutions or firewalls. |'
  prefs: []
  type: TYPE_TB
- en: '| NOPs | NOP generators are used for alignment, which results in making exploits
    stable. |'
  prefs: []
  type: TYPE_TB
- en: '| Exploits | The actual pieces of code that trigger a vulnerability. |'
  prefs: []
  type: TYPE_TB
- en: Understanding the file structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'File structure in Metasploit is laid out in the scheme shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3af3fb91-752e-4b53-9784-a022dd492b5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will cover the most relevant directories, which will aid us in building
    modules for Metasploit, through the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directory** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `lib` | The heart and soul of Metasploit; it contains all the essential library
    files to help us build MSF modules. |'
  prefs: []
  type: TYPE_TB
- en: '| `modules` | All the Metasploit modules are contained in this directory; from
    scanners to post exploitation modules, every module which was integrated into
    the Metasploit project can be found in this directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `tools` | Command-line utilities that aid penetration testing are contained
    in this folder; from creating junk patterns to finding JMP ESP addresses for successful
    exploit writing, all the necessary command-line utilities are present here. |'
  prefs: []
  type: TYPE_TB
- en: '| `plugins` | All of the plugins, which extend the features of Metasploit,
    are stored in this directory. Standard plugins are OpenVAS, Nexpose, Nessus, and
    various others that can be loaded into the framework using the `load` command.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `scripts` | This directory contains Meterpreter and various other scripts.
    |'
  prefs: []
  type: TYPE_TB
- en: The libraries layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metasploit modules are the buildup of various functions contained in different
    libraries, and general Ruby programming. Now, to use these functions, we first
    need to understand what they are. How can we trigger these functions? What number
    of parameters do we need to pass? Moreover, what will these functions return?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how these libraries are organized; this is illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51674a72-5d3b-4507-9e3e-b78bcd74f75e.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, we have the critical `rex` libraries
    along with all other essential ones in the `/lib` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/base` and `/core` libraries are also a crucial set of libraries, and
    are located under the `/msf` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29673620-c69b-419c-9591-d7f21d6532bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, under the `/msf/core` libraries folder, we have libraries for all the
    modules we used earlier in the first chapter; this is illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a23f5b25-9c52-4dc2-9a2f-ae0995883ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These library files provide the core for all modules. However, for different
    operations and functionalities, we can refer to any library we want. Some of the
    most widely used library files in most of the Metasploit modules are located in
    the `core/exploits/` directory, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/798dd250-a34c-4de1-a0eb-8af6c76244ed.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, it's easy to find all the relevant libraries for various types
    of modules in the `core/` directory. Currently, we have core libraries for exploits,
    payload, post-exploitation, encoders, and various other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Visit the Metasploit Git repository at [https://github.com/rapid7/metasploit-framework](https://github.com/rapid7/metasploit-framework) to
    access the complete source code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the existing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to start writing modules is to delve deeper into the existing Metasploit
    modules, and see how they work internally.
  prefs: []
  type: TYPE_NORMAL
- en: The format of a Metasploit module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The skeleton for Metasploit modules is reasonably straightforward. We can see
    the universal header section in the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A module starts by including the necessary libraries using the `require` keyword,
    which in the preceding code is followed by the `msf/core` libraries. Thus, it
    includes the core libraries from the `/msf` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The next major thing is to define the class type that is to specify the kind
    of module we are going to create. We can see that we have set `MSF::Auxiliary`
    for the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `initialize` method, which is the default constructor in Ruby, we define
    the `Name`, `Description`, `Author`, `License`, `CVE` details, and so on. This
    method covers all the relevant information for a particular module: `Name` generally
    contains the software name that is being targeted; `Description` includes the
    excerpt on the explanation of the vulnerability; `Author` is the name of the person
    who develops the module; and `License` is the `MSF_LICENSE`, as stated in the
    code example listed previously. The auxiliary module''s primary method is the
    `run` method. Hence, all the operations should be performed inside it unless and
    until you have plenty of other methods. However, the execution will still begin
    with the `run` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Disassembling the existing HTTP server scanner module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s work with a simple module for an HTTP version scanner, and see how it
    works. The path to this Metasploit module is: `/modules/auxiliary/scanner/http/http_version.rb`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine this module systematically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss how things are arranged here. The copyright lines, starting
    with the `#` symbol, are the comments and are included in all Metasploit modules.
    The `require ''rex/proto/http''` statement tasks the interpreter to include a
    path to all the HTTP protocol methods from the `rex` library. Therefore, the path
    to all the files from the `/lib/rex/proto/http` directory is now available to
    the module, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be6b1a9a-8d80-4010-80f3-9229193146b7.png)'
  prefs: []
  type: TYPE_IMG
- en: All these files contain a variety of HTTP methods, which include functions to
    set up a connection, the `GET` and `POST` request, response handling, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next line, `Msf::Auxiliary` defines the code as an auxiliary type module.
    Let''s continue with the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding section includes all the necessary library files that contain
    methods used in the modules. Let''s list the path for these included libraries,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Include statement** | **Path** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Exploit::Remote::HttpClient` | `/lib/msf/core/exploit/http/client.rb`
    | This library file will provide various methods such as connecting to the target,
    sending a request, disconnecting a client, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Auxiliary::WmapScanServer` | `/lib/msf/core/auxiliary/wmapmodule.rb`
    | You might be wondering, what is WMAP? WMAP is a web-application-based vulnerability
    scanner add-on for the Metasploit framework that aids web testing using Metasploit.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Auxiliary::Scanner` | `/lib/msf/core/auxiliary/scanner.rb` | This file
    contains all the various functions for scanner-based modules. This file supports
    various methods such as running a module, initializing and scanning the progress,
    and so on. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look at the next piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This part of the module defines the `initialize` method, which initializes
    the basic parameters such as `Name`, `Author`, `Description`, and `License` for
    this module and initializes the WMAP parameters as well. Now, let''s have a look
    at the last section of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The function here is the meat of the scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries and the function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see some essential methods from the libraries that are used in this
    module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functions** | **Library file** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `run_host` | `/lib/msf/core/auxiliary/scanner.rb` | The main method that
    will run once for each host |'
  prefs: []
  type: TYPE_TB
- en: '| `connect` | `/lib/msf/core/auxiliary/scanner.rb` | This is used to make a
    connection to the target host |'
  prefs: []
  type: TYPE_TB
- en: '| `send_raw_request` | `/core/exploit/http/client.rb` | This method is used
    to make raw HTTP requests to the target |'
  prefs: []
  type: TYPE_TB
- en: '| `request_raw` | `/rex/proto/http/client.rb` | The library method to which
    `send_raw_request` passes data to |'
  prefs: []
  type: TYPE_TB
- en: '| `http_fingerprint` | `/lib/msf/core/exploit/http/client.rb` | Parses the
    HTTP response into usable variables |'
  prefs: []
  type: TYPE_TB
- en: '| `report_service` | `/lib/msf/core/auxiliary/report.rb` | This method is used
    to report and store the service found on the target host onto the database |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s now understand the module. Here, we have a method named `run_host` with
    the IP as the parameter to establish a connection to the required host. The `run_host`
    method is referred from the `/lib/msf/core/auxiliary/scanner.rb` library file.
    This method will run once for each host, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27caf839-f795-44f8-adfc-fae97dc3f14c.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we have the `begin` keyword, which denotes the beginning of the code block.
    In the next statement, we have the `connect` method, which establishes the HTTP
    connection to the server, as discussed in the table previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a variable named `res`, which will store the response. We will
    use the `send_raw_request` method from the `/core/exploit/http/client.rb` file
    with the parameter `URI` as `/`, and the `method` for the request as `GET`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb0246ee-c356-4c53-9c28-ecc57b513c24.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding method will help you to connect to the server, create a request,
    send a request, and read the response. We save the response in the `res` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method passes all the parameters to the `request_raw` method from the
    `/rex/proto/http/client.rb` file, where all these parameters are checked. We have
    plenty of parameters that can be set in the list of parameters. Let''s see what
    they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92c14168-346b-41bc-8e3f-23e3ba902d89.png)'
  prefs: []
  type: TYPE_IMG
- en: '`res` is a variable that stores the results. In the next statement, the `http_fingerprint`
    method from the `/lib/msf/core/exploit/http/client.rb` file is used for analyzing
    the data in the `fp` variable. This method will record and filter out information
    such as `Set-cookie`, `Powered-by`, and other such headers. This method requires
    an HTTP response packet to make the calculations. So, we will supply `:response`
    `=> res` as a parameter, which denotes that fingerprinting should occur on the
    data received from the request generated previously using `res`. However, if this
    parameter is not given, it will redo everything and get the data again from the
    source. The next statement prints out a type good informational message with details
    such as IP, port, and the service name, but only when the `fp` variable is set.
    The `report_service` method just stores the information to the database. It will
    save the target''s IP address, port number, service type (HTTP or HTTPS, based
    on the service), and the service information. The last line, `rescue ::Timeout::Error,
    ::Errno::EPIPE`, will handle exceptions if the module times out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run this module and see what the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0a0aa59-585f-4ea4-84cb-465a970676d1.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we have seen how a module works. We can see that on a successful fingerprint
    of the application, the information is posted on the console and saved in the
    database. Additionally, on a timeout, the module doesn't crash and is handled
    well. Let's take this a step further and try writing our custom module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing out a custom FTP scanner module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try and build a simple module. We will write a simple FTP fingerprinting
    module and see how things work. Let''s examine the code for the FTP module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We start our code by defining the type of Metasploit module we are going to
    build. In this case, we are writing an auxiliary module that is very similar to
    the one we previously worked on. Next, we define the library files we need to
    include from the core library set, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Include statement** | **Path** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Exploit::Remote::Ftp` | `/lib/msf/core/exploit/ftp.rb` | The library
    file contains all the necessary methods related to FTP, such as methods for setting
    up a connection, logging in to the FTP service, sending an FTP command, and so
    on. |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Auxiliary::Scanner` | `/lib/msf/core/auxiliary/scanner.rb` | This file
    contains all the various functions for scanner-based modules. This file supports
    various methods such as running a module, initializing, and scanning progress.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Auxiliary::Report` | `/lib/msf/core/auxiliary/report.rb` | This file
    contains all the various reporting functions that help in the storage of data
    from the running modules into the database. |'
  prefs: []
  type: TYPE_TB
- en: 'We define the information of the module with attributes such as name, description,
    author name, and license in the `initialize` method. We also define what options
    are required for the module to work. For example, here, we assign `RPORT` to port
    `21`, which is the default port for FTP. Let''s continue with the remaining part
    of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Libraries and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see some important functions from the libraries that are used in this
    module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functions** | **Library file** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `run_host` | `/lib/msf/core/auxiliary/scanner.rb` | The main method which
    will run once for each host. |'
  prefs: []
  type: TYPE_TB
- en: '| `connect` | `/lib/msf/core/exploit/ftp.rb` | This function is responsible
    for initializing a connection to the host and grabbing the banner that it stores
    in the banner variable automatically. |'
  prefs: []
  type: TYPE_TB
- en: '| `report_service` | `/lib/msf/core/auxiliary/report.rb` | This method is used
    specifically for adding a service and its associated details into the database.
    |'
  prefs: []
  type: TYPE_TB
- en: 'We define the `run_host` method, which serves as the main method. The `connect`
    function will be responsible for initializing a connection to the host. However,
    we supply two parameters to the `connect` function, which are `true` and `false`.
    The `true` parameter defines the use of global parameters, whereas `false` turns
    off the verbose capabilities of the module. The beauty of the `connect` function
    lies in its operation of connecting to the target and recording the banner of
    the FTP service in the parameter named `banner` automatically, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de42a8c6-3d8e-4ec3-b2c9-b017fecadb15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we know that the result is stored in the `banner` attribute. Therefore,
    we just print out the banner at the end. Next, we use the `report_service` function
    so that the scan data gets saved to the database for later use or advanced reporting.
    The method is located in the `report.rb` file in the auxiliary library section.
    The code for `report_service` looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4af7446e-0dbf-4831-8225-8930d668c852.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the provided parameters to the `report_service` method are passed
    to the database using another method called `framework.db.report_service` from
    `/lib/msf/core/db_manager/service.rb`. After performing all the necessary operations,
    we just disconnect the connection with the target.
  prefs: []
  type: TYPE_NORMAL
- en: This was an easy module, and I recommend that you try building simple scanners
    and other modules like these.
  prefs: []
  type: TYPE_NORMAL
- en: Using msftidy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nevertheless, before we run this module, let''s check whether the module we
    just built is correct with regards to its syntax. We can do this by passing the
    module from an in-built Metasploit tool named `msftidy`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f827f0dc-cec6-488a-bf3b-55e4e307eb78.png)'
  prefs: []
  type: TYPE_IMG
- en: We will get a warning message indicating that there are a few extra spaces at
    the end of line 20\. When we remove the additional spaces and rerun `msftidy`,
    we will see that no error is generated, which means the syntax of the module is
    correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run this module and see what we gather:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f5c9ed1-36b9-4ef0-8ed5-5676aa501325.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the module ran successfully, and it has the banner of the service
    running on port `21`, which is `220-FileZilla Server 0.9.60 beta`. The `report_service`
    function in the previous module stores data to the services section, which can
    be seen by running the `services` command, as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: For further reading on the acceptance of modules in the Metasploit project,
    refer to: [https://github.com/rapid7/metasploit-framework/wiki/Guidelines-for-Accepting-Modules-and-Enhancements](https://github.com/rapid7/metasploit-framework/wiki/Guidelines-for-Accepting-Modules-and-Enhancements).
  prefs: []
  type: TYPE_NORMAL
- en: Writing out a custom SSH-authentication with a brute force attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For checking weak login credentials, we need to perform an authentication brute
    force attack. The agenda of such tests is not only to test an application against
    weak credentials, but to ensure proper authorization and access controls as well.
    These tests ensure that the attackers cannot simply bypass the security paradigm
    by trying the non-exhaustive brute force attack, and are locked out after a certain
    number of random guesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Designing the next module for authentication testing on the SSH service, we
    will look at how easy it is to design authentication-based checks in Metasploit,
    and perform tests that attack authentication. Let''s now jump into the coding
    part and begin designing a module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous examples, we have already seen the importance of using `Msf::Auxiliary::Scanner`
    and `Msf::Auxiliary::Report`. Let''s see the other included libraries and understand
    their usage through the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Include statement** | **Path** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Auxiliary::AuthBrute` | `/lib/msf/core/auxiliary/auth_brute.rb` | Provides
    the necessary brute forcing mechanisms and features such as providing options
    for using single entry username and passwords, wordlists, and blank password.
    |'
  prefs: []
  type: TYPE_TB
- en: In the preceding code, we also included two files, which are `metasploit/framework/login_scanner/ssh`
    and `metasploit/framework/credential_collection`. The `metasploit/framework/login_scanner/ssh`
    file includes the SSH login scanner library that eliminates all manual operations
    and provides an underlying API to SSH scanning. The `metasploit/framework/credential_collection`
    file helps to create multiple credentials based on user inputs from the `datastore`.
    Next, we simply define the type of the module we are building.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `initialize` section, we define the basic information for this module.
    Let''s see the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have two objects in the preceding code, which are `cred_collection`
    and `scanner`. An important point to make a note of here is that we do not require
    any manual methods of logging into the SSH service because the login scanner does
    everything for us. Therefore, `cred_collection` is doing nothing but yielding
    sets of credentials based on the `datastore` options set on a module. The beauty
    of the `CredentialCollection` class lies in the fact that it can take a single
    username/password combination, wordlists, and blank credentials all at once, or
    one of them at a time.
  prefs: []
  type: TYPE_NORMAL
- en: All login scanner modules require credential objects for their login attempts.
    The `scanner` object defined in the preceding code initializes an object for the
    SSH class. This object stores the address of the target, port, credentials as
    generated by the `CredentialCollection` class, and other data-like proxy information,
    `stop_on_success` that will stop the scanning on the successful credential match,
    brute force speed, and the value of the attempted timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point in the module, we have created two objects; `cred_collection`,
    which will generate credentials based on the user input, and the `scanner` object,
    which will use those credentials to scan the target. Next, we need to define a
    mechanism so that all the credentials from a wordlist are defined as single parameters
    and are tested against the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen the usage of `run_host` in previous examples. Let''s see
    what other vital functions from various libraries we are going to use in this
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functions** | **Library file** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `create_credential()` | `/lib/msf/core/auxiliary/report.rb` | Yields credential
    data from the result object. |'
  prefs: []
  type: TYPE_TB
- en: '| `create_credential_login()` | `/lib/msf/core/auxiliary/report.rb` | Creates
    login credentials from the result object, which can be used to log in to a particular
    service. |'
  prefs: []
  type: TYPE_TB
- en: '| `invalidate_login` | `/lib/msf/core/auxiliary/report.rb` | Marks a set of
    credentials as invalid for a particular service. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s see how we can achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It can be observed that we used `.scan` to initialize the scan, and this will
    perform all the login attempts by itself, which means we do not need to specify
    any other mechanism explicitly. The `.scan` instruction is exactly like an `each`
    loop in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: In the next statement, the results get saved in the `result` object and are
    assigned to the `credential_data` variable using the `to_h` method, which will
    convert the data to hash format. In the next line, we merge the module name and
    workspace ID into the `credential_data` variable. Next, we run an if-else check
    on the `result` object using the `.success`, variable, which denotes successful
    login attempts into the target. If the `result.success?` variable returns true,
    we mark the credential as a successful login attempt and store it in the database.
    However, if the condition is not satisfied, we pass the `credential_data` variable
    to the `invalidate_login` method that denotes a failed login.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is advisable to run all the modules in this chapter and all the later chapters
    only after performing a consistency check through `msftidy`. Let''s try running
    the module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e86e9fd-7aa8-4071-8b6d-b8121c2cf901.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we were able to log in with `claire` and `18101988` as the
    username and password. Let''s see if we were able to log the credentials into
    the database using the `creds` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78045d49-4632-4ec4-80d9-59d5df3337fa.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we have the details logged into the database, and they can be
    used to carry out advanced attacks, or for reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Rephrasing the equation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are scratching your head after working on the module listed previously,
    let''s understand the module in a step-by-step fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: We've created a `CredentialCollection` object that takes any user as input and
    yields credentials, which means that if we provide `USERNAME` as the root and
    `PASSWORD` as the root, it will yield those as a single credential. However, if
    we use `USER_FILE` and `PASS_FILE` as dictionaries, then it will take each username
    and password from the dictionary file and will generate credentials for each combination
    of username and password from the files, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've created a `scanner` object for SSH, which will eliminate any manual command
    usage and will simply check all the combinations we supplied one after the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've run our `scanner` using the `.scan` method, which will initialize the
    authentication of brute force on the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.scan` method will scan all credentials one after the other and, based
    on the result, will either store it into the database and display the same with
    `print_good`, else it will show it using `print_status` without saving it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing a drive-disabler post-exploitation module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have now seen the basics of module building, we can go a step further
    and try to build a post-exploitation module. A point to remember here is that
    we can only run a post-exploitation module after a target has been compromised
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s begin with a simple drive-disabler module, which will disable the
    selected drive at the target system, which is a Windows 7 OS. Let''s see the code
    for the module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We started in the same way as we did in the previous modules. We added the
    path to all the required libraries we needed for this post-exploitation module.
    Let''s see any new inclusion and their usage in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Include statement** | **Path** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Post::Windows::Registry` | `lib/msf/core/post/windows/registry.rb`
    | This library will give us the power to use registry manipulation functions with
    ease using Ruby Mixins. |'
  prefs: []
  type: TYPE_TB
- en: Next, we define the type of module as `Post` for post-exploitation. Proceeding
    with the code, we describe the necessary information for the module in the `initialize`
    method. We can always define `register_options` to define our custom options to
    use with the module. Here, we describe `DriveName` as a string datatype using
    `OptString.new`. The definition of a new option requires two parameters that are
    `required` and `description`. We set the value of `required` to `true` because
    we need a drive letter to initiate the hiding and disabling process. Hence, setting
    it to `true` won't allow the module to run unless a value is assigned to it. Next,
    we define the description for the newly added `DriveName` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding to the next part of the code, let''s see what important function
    we are going to use in this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functions** | **Library file** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `meterpreter_registry_key_exist` | `lib/msf/core/post/windows/registry.rb`
    | Checks if a particular key exists in the registry |'
  prefs: []
  type: TYPE_TB
- en: '| `registry_createkey` | `lib/msf/core/post/windows/registry.rb` | Creates
    a new registry key |'
  prefs: []
  type: TYPE_TB
- en: '| `meterpreter_registry_setvaldata` | `lib/msf/core/post/windows/registry.rb`
    | Creates a new registry value |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s see the remaining part of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We generally run a post-exploitation module using the `run` method. So, defining
    `run`, we send the `DriveName` variable to the `drive_string` method to get the
    numeric value for the drive.
  prefs: []
  type: TYPE_NORMAL
- en: We created a variable called `key1` and stored the path of the registry in it.
    We will use `meterpreter_registry_key_exist` to check if the key already exists
    in the system or not.
  prefs: []
  type: TYPE_NORMAL
- en: If the key exists, the value of the `exists` variable is assigned `true` or
    `false`. In case the value of the `exists` variable is `false`, we create the
    key using `registry_createkey(key1)` and then proceed to create the values. However,
    if the condition is true, we simply create the values.
  prefs: []
  type: TYPE_NORMAL
- en: To hide drives and restrict access, we need to create two registry values that
    are `NoDrives` and `NoViewOnDrive`, with the value of the drive letter in decimal
    or hexadecimal from, and its type as `DWORD`.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this using `meterpreter_registry_setvaldata` since we are using the
    meterpreter shell. We need to supply five parameters to the `meterpreter_registry_setvaldata`
    function to ensure its proper functioning. These parameters are the key path as
    a string, name of the registry value as a string, decimal value of the drive letter
    as a string, type of registry value as a string, and the view as an integer value,
    which would be 0 for native, 1 for 32-bit view, and 2 for 64-bit view.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of `meterpreter_registry_setvaldata` can be broken down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set the path as `key1`, the value as `NoViewOnDrives`,
    16 as a decimal for drive `D`, `REG_DWORD` as the type of registry, and `REGISTRY_VIEW_NATIVE`,
    which supplies 0.
  prefs: []
  type: TYPE_NORMAL
- en: For 32-bit registry access, we need to provide 1 as the view parameter, and
    for 64-bit, we need to supply 2\. However, this can be done using `REGISTRY_VIEW_32_BIT`
    and `REGISTRY_VIEW_64_BIT`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how we knew that for drive `E` we need to have the value
    of the bitmask as `16`? Let's see how the bitmask can be calculated in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the bitmask for a particular drive, we have the formula `2^([drive
    character serial number]-1)`. Suppose we need to disable drive `E`; we know that
    character E is the fifth character in the alphabet. Therefore, we can calculate
    the exact bitmask value for disabling drive `E`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*2^ (5-1) = 2^4= 16*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bitmask value is `16` for disabling `E` drive. However, in the preceding
    module, we hardcoded a few values in the `drive_string` method using the `case`
    switch. Let''s see how we did that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the previous method takes a drive letter as an argument and
    returns its corresponding numeral to the calling function. Let see how many drives
    there are at the target system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdf52ba4-44f7-4138-a791-b6d112b9abf4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see we have two drives, drive `C` and drive `E`. Let''s also check the
    registry entries where we will be writing the new keys with our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/294642e8-bbf3-4d98-8916-8bab60661226.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see we don''t have an explorer key yet. Let''s run the module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fed15fd8-ff77-444e-9994-4e1d974f0539.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the key doesn''t exist and, according to the execution of our
    module, it should have written the keys in the registry. Let''s check the registry
    once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27fa3f01-dc25-4b67-ab0d-11fe554fd673.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see we have the keys present. Upon logging out and logging back into
    the system, drive `E` should have disappeared. Let''s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b66f51cc-8957-4a98-989a-4d6e7977f66d.png)'
  prefs: []
  type: TYPE_IMG
- en: No signs of drive `E`. Hence, we successfully disabled drive `E` from the user's
    view, and restricted access to the same.
  prefs: []
  type: TYPE_NORMAL
- en: We can create as many post-exploitation modules as we want according to our
    needs. I recommend you put some extra time towards the libraries of Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you have `SYSTEM`-level access for the preceding script to work,
    as `SYSTEM` privileges will not create the registry under the current user, but
    will create it on the local machine. In addition to this, we have used `HKLM`
    instead of writing `HKEY_LOCAL_MACHINE`, because of the inbuilt normalization
    that will automatically create the full form of the key. I recommend that you
    check the `registry.rb` file to see the various available methods.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have system privileges, try using the `exploit/windows/local/bypassuac`
    module and switch to the escalated shell, and then try the preceding module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a credential harvester post-exploitation module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example module, we will attack Foxmail 6.5\. We will try decrypting
    the credentials and store them in the database. Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Quite simple, as we saw in the previous module; we start by including all the
    required libraries and providing the basic information about the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen the usage of `Msf::Post::Windows::Registry` and `Msf::Auxiliary::Report`.
    Let''s look at the details of the new libraries we included in this module, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Include statement** | **Path** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Post::Windows::UserProfiles` | `lib/msf/core/post/windows/user_profiles.rb`
    | This library will provide all the profiles on a Windows system, which includes
    finding important directories, paths, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Post::File` | `lib/msf/core/post/file.rb` | This library will provide
    functions which will aid file operations, such as reading a file, checking a directory,
    listing directories, writing to a file, and so on. |'
  prefs: []
  type: TYPE_TB
- en: 'Before understanding the next part of the module, let''s see what we need to
    perform to harvest the credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: We will search for user profiles and find the exact path for the current user's
    `LocalAppData` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use the previously found path and concatenate it with `\VirtualStore\Program
    Files (x86)\Tencent\Foxmail\mail` to establish a complete path to the `mail` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will list all the directories from the `mail` directory and will store them
    in an array. However, the directory names in the `mail` directory will use the
    naming convention of the username for various mail providers. For example, `nipunjaswal@rocketmail.com`
    would be one of the directories present in the `mail` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will find `Account.stg` file in the accounts directories, found under
    the `mail` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will read the `Account.stg` file and will find the hash value for the constant
    named `POP3Password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will pass the hash value to our decryption method, which will find the password
    in plain text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will store the value in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Quite simple! Let''s analyze the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Before starting to understand the previous code, let''s see what important
    functions are used in it, for a better approach toward its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functions** | **Library file** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `grab_user_profiles()` | `lib/msf/core/post/windows/user_profiles.rb` | Grabs
    all paths for important directories on a Windows platform |'
  prefs: []
  type: TYPE_TB
- en: '| `directory?` | `lib/msf/core/post/file.rb` | Checks if a directory exists
    or not |'
  prefs: []
  type: TYPE_TB
- en: '| `file?` | `lib/msf/core/post/file.rb` | Checks if a file exists or not |'
  prefs: []
  type: TYPE_TB
- en: '| `read_file` | `lib/msf/core/post/file.rb` | Reads the contents of a file
    |'
  prefs: []
  type: TYPE_TB
- en: '| `store_loot` | `/lib/msf/core/auxiliary/report.rb` | Stores the harvested
    information into a file and a database |'
  prefs: []
  type: TYPE_TB
- en: We can see in the preceding code that we grabbed the profiles using `grab_user_profiles()`
    and, for each profile, we tried finding the `LocalAppData` directory. As soon
    as we found it, we stored it in a variable called `full_path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we concatenated the path to the `mail` folder where all the accounts
    are listed as directories. We checked the path existence using `directory?` and,
    on success, we copied all the directory names that contained `@` in the name to
    the `dir_list` using regex match. Next, we created another variable called `full_path_mail`
    and stored the exact path to the `Account.stg` file for each email. We made sure
    that the `Account.stg` file existed by using `file?`. On success, we read the
    file and split all the contents at newline. We stored the split content into the
    `file_content` list. Let''s see the next part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For each entry in `file_content`, we ran a check to find the constant `POP3Password`.
    Once found, we split the constant at `=` and stored the value of the constant
    in a variable, `hash_value`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we directly pass the `hash_value` and `dir_list` (account name) to the
    `decrypt` function. After successful decryption, the plain password gets stored
    in the `decrypted_pass` variable. We create another variable called `data_entry`
    and append all the credentials to it. We do this because we don't know how many
    email accounts might be configured on the target. Therefore, for each result,
    the credentials get appended to `data_entry`. After all the operations are complete,
    we store the `data_entry` variable in the database using the `store_loot` method.
    We supply six arguments to the `store_loot` method, which are named for the harvest,
    its content type, session, `data_entry`, the name of the file, and the description
    of the harvest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the decryption function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the previous method, we received two arguments, which are the hashed password
    and username. The `magic` variable is the decryption key stored in an array containing
    decimal values for the `~draGon~` string, one after the other. We store the integer
    `90` as `fc0`, which we will talk about a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we find the size of the hash by dividing it by two and subtracting one
    from it. This will be the size of our new array, `b`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we split the hash into bytes (two characters each) and store
    the same into array `b`. We perform `XOR` on the first byte of array `b`, with
    `fc0` into the first byte of `b` itself, thus updating the value of `b[0]` by
    performing the XOR operation on it with `90`. This is fixed for Foxmail 6.5.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we copy the array magic twice into a new array, `double_magic`. We also
    declare the size of `double_magic` one less than that of array `b`. We perform
    `XOR` on all the elements of array `b` and the `double_magic` array, except the
    first element of `b` on which we already performed a XOR operation.
  prefs: []
  type: TYPE_NORMAL
- en: We store the result of the XOR operation in array `d`. We subtract the complete
    array `d` from array `b` in the next instruction. However, if the value is less
    than 0 for a particular subtraction operation, we add 255 to the element of array
    `d`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we simply append the ASCII value of the particular element
    from the resultant array `e` into the `decoded` variable, and return it to the
    calling statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we run this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab5556c2-f187-49c8-8b79-7385b72ebc5c.png)'
  prefs: []
  type: TYPE_IMG
- en: It is clear that we easily decrypted the credentials stored in Foxmail 6.5.
  prefs: []
  type: TYPE_NORMAL
- en: Breakthrough Meterpreter scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Meterpreter shell is the most desired type of access an attacker would like
    to have on the target. Meterpreter gives the attacker a broad set of tools to
    perform a variety of tasks on the compromised system. Meterpreter has many built-in
    scripts, which makes it easier for an attacker to attack the system. These scripts
    perform tedious and straightforward tasks on the compromised system. In this section,
    we will look at those scripts, what they are made of, and how we can leverage
    them in Meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: The basic Meterpreter commands cheat sheet is available at: [http://www.scadahackr.com/library/Documents/Cheat_Sheets/Hacking%20-%20Meterpreter%20Cheat%20%20Sheet.pdf](http://www.scadahackr.com/library/Documents/Cheat_Sheets/Hacking%20-%20Meterpreter%20Cheat%20%20Sheet.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Essentials of Meterpreter scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As far as we have seen, we have used Meterpreter in situations where we needed
    to perform some additional tasks on the system. However, now we will look at some
    of the problematic situations that may arise during a penetration test, where
    the scripts already present in Meterpreter seem to be of no help to us. Most likely,
    in this kind of situation, we will want to add our custom functionalities to Meterpreter
    and perform the required tasks. However, before we proceed to add custom scripts
    in Meterpreter, let's perform some of the advanced features of Meterpreter first,
    and understand its power.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up persistent access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have access to the target machine, we can pivot to internal networks,
    as we saw in the previous chapter, but it is also mandatory to retain the hard-earned
    access. However, for a sanctioned penetration test, it should be mandatory only
    for the duration of the test and should be within the scope of the project. Meterpreter
    permits us to install backdoors on the target using two different approaches:
    **MetSVC** and **Persistence**.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see some of the advanced persistence techniques in the upcoming chapters.
    Hence, here we will discuss the MetSVC method. The MetSVC service is installed
    in the compromised system as a service. Moreover, it opens a port permanently
    for the attacker to connect to whenever he or she wants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing MetSVC at the target is easy. Let''s see how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbc90c86-3243-4b22-a01b-0516d64dc105.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the MetSVC service creates a service at port `31337`, and uploads
    the malicious files as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, whenever access is required to this service, we need to use the `metsvc_bind_tcp`
    payload with an exploit-handler script, which will allow us to connect to the
    service again, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccffdeee-c153-4038-9320-6bb14589c054.png)'
  prefs: []
  type: TYPE_IMG
- en: The effect of MetSVC remains even after a reboot of the target machine. MetSVC
    is handy when we need permanent access to the target system, as it saves time
    that is required for re-exploitation of the target.
  prefs: []
  type: TYPE_NORMAL
- en: API calls and mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just saw how we could perform advanced tasks with Meterpreter. This indeed
    makes the life of a penetration tester easier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's dig deeper into the working of Meterpreter and uncover the underlying
    building process of Meterpreter modules and scripts. Sometimes, it might happen
    that we may run out of Meterpreter's offerings and desire customized functionality
    to perform all the required tasks. In that case, we need to build our own custom
    Meterpreter modules that can implement or automate various tasks which are needed
    at the time of exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first understand the basics of Meterpreter scripting. The base for coding
    with Meterpreter is the **Application Programming Interface** (**API**) calls
    and mixins. These are required to perform specific tasks using a specific Windows-based
    **Dynamic Link Library** (**DLL)** and some common tasks using a variety of built-in
    Ruby-based modules.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins are Ruby-programming-based classes that contain methods from various
    other classes. Mixins are extremely helpful when we perform a variety of tasks
    at the target system. In addition to this, mixins are not exactly part of IRB,
    but they can be beneficial to write specific and advanced Meterpreter scripts
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on mixins, refer to: [http://www.offensive-security.com/metasploit-unleashed/Mixins_and_Plugins](http://www.offensive-security.com/metasploit-unleashed/Mixins_and_Plugins).
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you all have a look at the `/lib/rex/post/meterpreter` and
    `/lib/msf/scripts/meterpreter` directories, to check out the various libraries
    used by meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: API calls are Windows-specific calls used to call out specific functions from
    a Windows DLL file. We will learn about API calls shortly in the *Working with
    RailGun* section.
  prefs: []
  type: TYPE_NORMAL
- en: Fabricating custom Meterpreter scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work out a simple example Meterpreter script, which will check whether
    we are an admin user, and then find the explorer process and migrate into it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before looking into the code, let''s see all of the essential methods we will
    be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Functions** | **Library file** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `is_admin` | `/lib/msf/core/post/windows/priv.rb` | Checks if the session
    has admin privileges or not. |'
  prefs: []
  type: TYPE_TB
- en: '| `is_in_admin_group` | `/lib/msf/core/post/windows/priv.rb` | Checks if a
    user belongs to an administrator group. |'
  prefs: []
  type: TYPE_TB
- en: '| `session.sys.process.get_processes()` | `/lib/rex/post/meterpreter/extensions/stdapi/sys/process.rb`
    | Lists all the running processes on the target. |'
  prefs: []
  type: TYPE_TB
- en: '| `session.core.migrate()` | `/lib/rex/post/meterpreter/client_core.rb` | Migrates
    the access from an existing process to the PID specified in the parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `is_uac_enabled?` | `/lib/msf/core/post/windows/priv.rb` | Checks if UAC
    is enabled. |'
  prefs: []
  type: TYPE_TB
- en: '| `get_uac_level` | `/lib/msf/core/post/windows/priv.rb` | Gets the UAC level:
    0,2,5 and so on. 0: Disabled, 2: All, 5: Default. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We just check if the current user is an admin or not in the preceding code.
    The function `is_admin` returns a Boolean value, and based on that we print the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we check if the user belongs to the administrator''s
    group or not. The preceding piece of code is very similar to the previous one
    in terms of logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The segment here is an exciting piece of code. We start by finding the current
    process ID using `session.sys.process.getpid` and then loop through all the processes
    on the target system using the loop on `session.sys.process.get_processes()`.
    If any process is found with the name `explorer.exe`, we print out a message and
    store its ID to an `explorer_ppid` variable. Using the `session.core.migrate()`
    method, we pass the stored process ID (`explorer.exe`) to migrate into the `explorer.exe`
    process. Finally, we just print out the current process ID again to ensure if
    we migrated successfully or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous piece of code, we simply find the current user''s identifier
    using the `sessions.sys.config.getuid` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code checks if UAC is enabled on the target system or not. In
    case UAC is enabled, we further drill down to find the level of UAC by using the
    `get_uac_level` method, and print the status through its response values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s save this code in the `/scripts/meterpreter/gather.rb` directory and
    launch this script from Meterpreter. This will give you an output similar to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c19600f6-ff72-4397-9699-4228a20765f6.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see how easy it was to create Meterpreter scripts, and perform a variety
    of tasks and task automation as well. I recommend you examine all the included
    files and paths used in the module for exploring Meterpreter extensively.
  prefs: []
  type: TYPE_NORMAL
- en: According to the official wiki of Metasploit, you should no longer write Meterpreter
    scripts and instead write post-exploitation modules.
  prefs: []
  type: TYPE_NORMAL
- en: Working with RailGun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RailGun sounds like a top-notch gun spitting out bullets faster than light;
    however, this is not the case. RailGun allows you to make calls to a Windows API
    without the need to compile your own DLL.
  prefs: []
  type: TYPE_NORMAL
- en: It supports numerous Windows DLL files and eases the way for us to perform system-level
    tasks on the victim machine. Let's see how we can perform various tasks using
    RailGun, and carry out some advanced post-exploitation with it.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Ruby shell basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RailGun requires the `irb` shell to be loaded into Meterpreter. Let''s look
    at how we can jump to the `irb` shell from Meterpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d30b74c7-6dae-406e-8b49-bd33212e7df5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see in the preceding screenshot that merely typing in `irb` from Meterpreter
    allows us to drop in the Ruby-interactive shell. We can perform a variety of tasks
    with the Ruby shell from here.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RailGun and its scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RailGun gives us immense power to perform tasks that Metasploit may not be able
    to carry out at times. Using RailGun, we can raise exception calls to any DLL
    file from the breached system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can call a function using basic API calls with RailGun,
    and understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is the basic structure of an API call in RailGun. The `client.railgun`
    keyword defines the need of RailGun functionality for the client. The `DLLname`
    keyword specifies the name of the DLL file to which we will be making a call.
    The `function (parameters)` keyword in the syntax specifies the actual API function
    that is to be provoked with required parameters from the DLL file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43415550-6936-42db-ad36-87e3556a5b50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result of this API call is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/368aa390-7c19-4ffd-9d98-917a0ada5957.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, a call is made to the `LockWorkStation()` function from the `user32.dll`
    DLL file that results in the locking of the compromised system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see an API call, with parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding command runs, it deletes a particular user from the client''s
    machine. Currently, we have the following users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b3f1cfb-ab15-4472-be69-915aedfebbe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try deleting the `Nipun` username:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e76bfca2-5f19-4491-b614-c3fee8538e42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check whether the user has been successfully removed or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/295610ba-e3f2-46e2-ac1c-cb3d70530ecb.png)'
  prefs: []
  type: TYPE_IMG
- en: The user seems to have gone fishing. The RailGun call has removed the user `Nipun`
    successfully. The `nil` value defines that the user is on the local machine. However,
    we can also target remote systems using a value for the name parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Windows API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DLL files are responsible for carrying out the majority of tasks on Windows-based
    systems. Therefore, it is essential to understand which DLL file contains which
    methods. This is very similar to the library files of Metasploit, which have various
    methods in them. To study Windows API calls, we have excellent resources at [http://source.winehq.org/WineAPI/](http://source.winehq.org/WineAPI/)
    and [http://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx).
    I recommend you explore a variety of API calls before proceeding further with
    creating RailGun scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following path to find out more about RailGun-supported DLL files:
    `/usr/share/metasploit-framework/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`.'
  prefs: []
  type: TYPE_NORMAL
- en: Fabricating sophisticated RailGun scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Taking a step further, let''s delve deeper into writing scripts using RailGun
    for meterpreter extensions. First let''s create a script which will add a custom-named
    DLL file to the Metasploit context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Save the code under a file named `urlmon.rb`, under the `/scripts/meterpreter`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding script adds a reference path to the `C:\WINDOWS\system32\urlmon.dll`
    file that contains all the required functions for browsing, and functions such
    as downloading a particular file. We save this reference path under the name `urlmon`.
    Next, we add a function to the DLL file using the DLL file's name as the first
    parameter, and the name of the function we are going to hook as the second parameter,
    which is `URLDownloadToFileA`, followed by the required parameters. The very first
    line of the code checks whether the DLL function is already present in the DLL
    file or not. If it is already present, the script will skip adding the function
    again. The `pcaller` parameter is set to `NULL` if the calling application is
    not an ActiveX component; if it is, it is set to the COM object. The `szURL` parameter
    specifies the URL to download. The `szFileName` parameter specifies the filename
    of the downloaded object from the URL. `Reserved` is always set to `NULL`, and
    `lpfnCB` handles the status of the download. However, if the status is not required,
    this value should be set to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now create another script which will make use of this function. We will
    create a post-exploitation script that will download a freeware file manager and
    will modify the entry for the utility manager on the Windows OS. Therefore, whenever
    a call is made to the utility manager, our freeware program will run instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create another script in the same directory and name it `railgun_demo.rb`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As stated previously, the first line of the script will call the custom-added
    DLL function `URLDownloadToFile` from the `urlmon` DLL file, with the required
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a key, `Utilman.exe`, under the parent key, `HKLMSOFTWAREMicrosoftWindows
    NTCurrentVersionImage File Execution Options`.
  prefs: []
  type: TYPE_NORMAL
- en: We create a registry value of type `REG_SZ` named `Debugger` under the `utilman.exe`
    key. Lastly, we assign the value `a43.exe` to the `Debugger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this script from the Meterpreter to see how things work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/811f4a49-d537-441c-b9f0-7b9e0d639357.png)'
  prefs: []
  type: TYPE_IMG
- en: As soon as we run the `railgun_demo` script, the file manager is downloaded
    using the `urlmon.dll` file and is placed in the `system32` directory. Next, registry
    keys are created that replace the default behavior of the utility manager to run
    the `a43.exe` file. Therefore, whenever the ease-of-access button is pressed from
    the login screen, instead of the utility manager, the `a43` file manager shows
    up and serves as a login screen backdoor on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we press the ease-of-access button from the login
    screen, in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/831b6cc5-2b48-459f-88df-336d3bbc4184.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that it opens an `a43` file manager instead of the utility manager.
    We can now perform a variety of functions including modifying the registry, interacting
    with CMD, and much more, without logging into the target. You can see the power
    of RailGun, which eases the process of creating a path to whichever DLL file you
    want, and allows you to add custom functions to it as well.
  prefs: []
  type: TYPE_NORMAL
- en: More information on this DLL function is available at: [https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85)](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775123(v=vs.85)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary and exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered coding for Metasploit. We worked on modules, post-exploitation
    scripts, Meterpreter, RailGun, and Ruby programming too. Throughout this chapter,
    we saw how we could add our custom functions to the Metasploit framework, and
    make the already powerful framework much more powerful. We began with familiarizing
    ourselves with the basics of Ruby. We learned about writing auxiliary modules,
    post-exploitation scripts, and Meterpreter extensions. We saw how we could make
    use of RailGun to add custom functions, such as adding a DLL file and a custom
    function to the target's DLL files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For additional learning, you can try the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an authentication brute force module for FTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work on at least three post-exploitation modules each for windows, Linux, and
    macOS, which are not yet a part of Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work on RailGun and develop custom modules for at least three different functions from
    any unknown Windows DLLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will look at development in context and exploiting the
    modules in Metasploit. This is where we will begin to write custom exploits, fuzz
    various parameters for exploitation, exploit software, and write advanced exploits
    for software and the web.
  prefs: []
  type: TYPE_NORMAL
