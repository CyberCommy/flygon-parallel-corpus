- en: Chapter 2. Installing Powerful Tools for Your Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a great quote by Charles F. Kettering:'
  prefs: []
  type: TYPE_NORMAL
- en: '"My interest is in the future because I am going to spend the rest of my life
    there."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This brilliant inventor has left software engineers with the single most important
    piece of advice way before we even started thinking how to write software. Yet,
    half a century later, we're still figuring out why we end up with spaghetti code
    or the "spaghetti mental model."
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever been in a situation where you inherit code from a previous developer
    and spend weeks trying to understand how everything works because no blueprints
    were made available, and the pseudo-self-explanatory-code became too hard to debug?
    Better yet, the project keeps growing and so does its complexity. Making or breaking
    changes is dangerous and no one wants to touch that "ugly" legacy code. Rewriting
    the whole codebase is way too expensive, so the current one is supported by introducing
    new bug fixes and patches every day. The cost of maintaining software is way higher
    than the original cost of developing it.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean to write software for the future today? I think it boils down
    to creating a simple mental model that doesn't change, no matter how big your
    project becomes over time. When the size of your project grows, the complexity
    always stays the same. This mental model is your blueprint, and once you understand
    it, you will understand how your software works.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the modern web development, and in particular, the frontend
    development, you'll notice that we live in exciting times. Internet companies
    and individual developers are tackling problems of speed and cost of development
    versus code and user experience quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2013, Facebook released React—an open source JavaScript library for building
    user interfaces. You can read more about it at [http://facebook.github.io/react/](http://facebook.github.io/react/).
    In early 2015, Tom Occhino from Facebook has summarized what makes React so powerful:'
  prefs: []
  type: TYPE_NORMAL
- en: '"React wraps an imperative API with a declarative one. React''s real power
    lies in how it makes you to write code."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Declarative programming results in less code. It tells a computer what to do
    without specifying how, while an imperative style of programming describes how
    to do it. JavaScript calling the DOM API is an example of imperative programming.
    jQuery is another such example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Facebook has been using React in production for years along with Instagram
    and other companies. It works for small projects too; here is an example of a
    shopping list built with React: [http://fedosejev.github.io/shopping-list-react](http://fedosejev.github.io/shopping-list-react).
    I think React is one of the best JavaScript libraries used for building user interfaces
    that is available for developers today.'
  prefs: []
  type: TYPE_NORMAL
- en: My goal is that you understand the fundamental principles of React. To achieve
    this, I will introduce you to one React concept at a time, explain it, and show
    how you can apply it. Step by step we'll build a real-time web application, raise
    important questions along the way, and discuss solutions that React provides us
    with.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about Flux/Redux and the unidirectional flow of data. Together
    with Flux/Redux and React, we'll create a predictable and manageable code base
    that you will be able to expand by adding new features, without scaling its complexity.
    The mental model of how your web application works will stay the same no matter
    how many new features you add later on.
  prefs: []
  type: TYPE_NORMAL
- en: As with any new technology, there are things that work very differently from
    the way that you're used to. React is no exception. In fact, some of the core
    concepts of React might look counter-intuitive, thought provoking, or even like
    a step backward. Don't rush to any conclusions. As you would expect, a lot of
    thought went into how React works, from experienced Facebook engineers who build
    and use React in production in business-critical applications. My advice to you
    is to keep your mind open while learning React, and I believe that at the end
    of this book, these new concepts will settle in and make great sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: Join me in this journey of learning React and following Charles F. Kettering's
    advice. Let's take care of our future!
  prefs: []
  type: TYPE_NORMAL
- en: Approaching our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I firmly believe that the best motivation for learning new technology is a project
    that excites you that you can't wait to build. As an experienced developer, you've
    probably already built a number of successful commercial projects that share certain
    product features, design patterns, and even target audiences. In this book, I
    want you to build a project that feels like a breath of fresh air. A project,
    which you most likely wouldn't build in your day-to-day work. It has to be a fun
    endeavor, which will not only educate you but also satisfy your curiosity and
    stretch your imagination. However, assuming that you're a busy professional, this
    project shouldn't be a time-consuming, long-term commitment for you either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter **Snapterest**—a web application that allows you to discover and collect
    public photos posted on Twitter. Think of it as a Pinterest ([www.pinterest.com](http://www.pinterest.com))
    with the only source of pictures being Twitter. We will implement a fully functional
    website with the following core functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Receiving and displaying tweets in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and removing tweets to/from a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing collected tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting a collection of tweets as an HTML snippet that you can share
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you start working on a new project, the very first thing that you do is
    to get your tools ready. For this project, we will be using a number of tools
    that you might not be familiar with, so let's discuss what they are, and how you
    can install and configure them.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any trouble with installing and configuring tools and modules from
    this chapter, then go to [https://github.com/PacktPublishing/React-Essentials-Second-Edition](https://github.com/PacktPublishing/React-Essentials-Second-Edition)
    and create a new issue; describe what you're doing and what error message you're
    getting. I believe our community will help you to resolve your issue.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I'll assume that you're working on a Macintosh or Windows computer.
    If you're a Unix user, then most likely you would know your package manager very
    well, and it should be easy enough for you to install the tools that you will
    learn about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the installation of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js and npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Node.js** is a platform that allows us to write server-side applications
    with a client-side language that we''re all familiar with—JavaScript. However,
    the real benefit of Node.js is that it uses an event-driven, nonblocking I/O model,
    which is perfect for building data-intensive, real-time applications. It means
    that with Node.js, we should be able to handle an incoming stream of tweets and
    process them as soon as they arrive; just what we need for our project.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's install Node.js. We'll be using version 8.7.0 because at the time of writing
    this book, that's the latest version of Node.js. Jest is a testing framework from
    Facebook that you'll learn about in [Chapter 9](ch09.html "Chapter 9. Testing
    Your React Application with Jest"), *Testing Your React Application with Jest*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the installation package for your OS from one of these links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OS X: [http://nodejs.org/dist/v8.7.0/node-v8.7.0.pkg](http://nodejs.org/dist/v8.7.0/node-v8.7.0.pkg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows 64-bit: [http://nodejs.org/dist/v8.7.0/node-v8.7.0-x64.msi](http://nodejs.org/dist/v8.7.0/node-v8.7.0-x64.msi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows 32-bit: [http://nodejs.org/dist/v8.7.0/node-v8.7.0-x86.msi](http://nodejs.org/dist/v8.7.0/node-v8.7.0-x86.msi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the downloaded package and follow the installation steps that Node.js will
    prompt you with. Once finished, check whether you have successfully installed
    Node.js. Open Terminal/Command Prompt, and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows (don’t worry if your version doesn’t match exactly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Node.js has a very rich ecosystem of modules that is available for us to use.
    A module is a Node.js application that you can reuse in your own Node.js application.
    At the time of writing, there are over 500,000 modules. How do you manage such
    a wide diversity of Node.js modules? Meet **npm**, a package manager that manages
    Node.js modules. In fact, npm is shipped together with Node.js, so you''ve got
    it installed already. Type the following in Terminal/Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output (don’t worry if your version doesn’t match
    exactly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about npm at [www.npmjs.com](http://www.npmjs.com). Now we
    are ready to start with the installation of Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we'll be using Git to install Node.js modules. If you haven't
    installed Git yet, visit [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
    and follow the installation instructions for your OS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data from the Twitter Streaming API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data for our React application will come from Twitter. Twitter has a **Streaming
    API** that anyone can plug into and start receiving an endless flow of public
    tweets in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using the Twitter Streaming API, you''ll need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Twitter account. For this, go to [https://twitter.com](https://twitter.com)
    and sign up; or sign in if you already have an account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Twitter app by navigating to [https://apps.twitter.com](https://apps.twitter.com),
    and click on **Create New App**. You will need to fill the **Application Details**
    form, agree with **Developer Agreement**, and click on **Create your Twitter application**.
    Now you should see your application's page. Switch to the **Keys and Access Tokens**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Application Settings** section of this page, you''ll find two vital
    pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumer Key (API Key)**, for example, `jqRDrAlKQCbCbu2o4iclpnvem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer Secret (API Secret)**, for example, `wJcdogJih7uLpjzcs2JtAvdSyCVlqHIRUWI70aHOAf7E3wWIgD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a note of these; we will need them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to generate an access token. On the same page, you''ll see the
    **Your Access Token** section that is empty. Click on the **Create my access token**
    button. It creates two pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access Token**, for example, `12736172-R017ah2pE2OCtmi46IAE2n0z3u2DV6IqsEcPa0THR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access Token Secret**, for example, `4RTJJWIezIDcs5VX1PMVZolXGZG7L3Ez7Iz1gMdZucDaM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a note of these too. An access token is unique to you and you should not
    share it with anyone. Keep it private.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have everything that we need to start using Twitter's Streaming API.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering data with Snapkite Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The amount of tweets that you'll receive via the Twitter Streaming API is more
    than you can ever consume, so we need to find a way to filter that stream of data
    into a meaningful set of tweets that we can display and interact with. I recommend
    that you take a quick look at the Twitter Streaming API documentation at [https://dev.twitter.com/streaming/overview](https://dev.twitter.com/streaming/overview),
    and in particular, take a look at this page that describes the way you can filter
    an incoming stream at [https://dev.twitter.com/streaming/reference/post/statuses/filter](https://dev.twitter.com/streaming/reference/post/statuses/filter).
    You'll notice that Twitter provides very few filters that we can apply, so we
    need to find a way to filter that stream of data even further.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there is a Node.js application just for this. It's called **Snapkite
    Engine**. It connects to the Twitter Streaming API, filters it using the available
    filters and according to the rules that you define, and outputs the filtered tweets
    to a web socket connection. Our proposed React application can listen to the events
    on that socket connection and process tweets as they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Snapkite Engine. First, you need to clone the Snapkite Engine
    repository. Cloning means that you''re copying the source code from a GitHub server
    to your local directory. In this book, I''ll assume that your local directory
    is your home directory. Open Terminal/Command Prompt and type the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create the `~/snapkite-engine/` folder. We''re now going to install
    all the other node modules that `snapkite-engine` depends on. One of them is the
    `node-gyp` module. Depending on what platform you''re using, Unix or Windows,
    you will need to install other tools that are listed on this web page: [https://github.com/TooTallNate/node-gyp#installation](https://github.com/TooTallNate/node-gyp#installation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you install them, you''re ready to install the `node-gyp` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now navigate to the `~/snapkite-engine` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will install the Node.js modules that Snapkite Engine depends
    on. Now let''s configure Snapkite Engine. Assuming that you''re in the `~/snapkite-engine/`
    directory, copy the `./example.config.json` file to `./config.json` by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you''re using Windows, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `config.json` in your favorite text editor. We will now edit the configuration
    properties. Let''s start with `trackKeywords`. This is where we will tell what
    keywords we want to track. If we want to track the `"my"` keyword, then set it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to set our Twitter Streaming API keys. Set `consumerKey`, `consumerSecret`,
    `accessTokenKey`, and `accessTokenSecret` to the keys you saved when you created
    your Twitter App. Other properties can be set to their defaults. If you're curious
    to learn about what they are, check out the Snapkite Engine documentation at [https://github.com/snapkite/snapkite-engine](https://github.com/snapkite/snapkite-engine).
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to install Snapkite Filters. **Snapkite Filter** is a Node.js
    module that validates tweets according to a set of rules. There are a number of
    Snapkite Filters out there, and we can use any combination of them to filter our
    stream of tweets as we like. You can find a list of all the available Snapkite
    Filters at [https://github.com/snapkite/snapkite-filters](https://github.com/snapkite/snapkite-filters).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we''ll use the following Snapkite Filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is Possibly Sensitive**: [https://github.com/snapkite/snapkite-filter-is-possibly-sensitive](https://github.com/snapkite/snapkite-filter-is-possibly-sensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Has Mobile Photo**: [https://github.com/snapkite/snapkite-filter-has-mobile-photo](https://github.com/snapkite/snapkite-filter-has-mobile-photo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is Retweet**: [https://github.com/snapkite/snapkite-filter-is-retweet](https://github.com/snapkite/snapkite-filter-is-retweet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Has Text**: [https://github.com/snapkite/snapkite-filter-has-text](https://github.com/snapkite/snapkite-filter-has-text)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s install them. Navigate to the `~/snapkite-engine/filters/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then clone all Snapkite Filters by running these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to configure them. In order to do so, you need to create a
    configuration file for each Snapkite Filter in a **JSON** format and define some
    properties in it. Luckily, each Snapkite Filter comes with an example configuration
    file that we can duplicate and edit as needed. Assuming that you''re in the `~/snapkite-engine/filters/`
    directory, run the following commands (use `copy` and replace the forward slashes
    with backward slashes on Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to change any of the default settings in these `config.json` files,
    as they're already configured to fit our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to tell Snapkite Engine which Snapkite Filters it should use.
    Open the `~/snapkite-engine/config.json` file in a text editor and look for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now replace that with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done! You''ve successfully installed Snapkite Engine with a number of
    Snapkite Filters. Now let''s check if we can run it. Navigate to `~/snapkite-engine/`
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You should see no error messages, but if you do and you're not sure how to fix
    them, then go to [https://github.com/fedosejev/react-essentials/issues](https://github.com/fedosejev/react-essentials/issues),
    create a new issue, and copy and paste the error message that you get.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's set up our project's structure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to create our project structure. Organizing source files may sound
    like a simple task, but a well-thought-out project structure organization helps
    us understand the underlying architecture of our application. You'll see an example
    of this later in this book, when we'll talk about the Flux application architecture.
    Let's start by creating our root project directory named `snapterest` inside your
    home directory `~/snapterest/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside it, we will create two other directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`~/snapterest/source/`: Here, we''ll store our source JavaScript files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~/snapterest/build/`: Here, we''ll put compiled JavaScript files and an HTML
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, inside `~/snapterest/source/`, create the `components/` folder so that
    your project structure would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`~/snapterest/source/components/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~/snapterest/build/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now when we have our fundamental project structure ready, let's start populating
    it with our application files. First, we need to create our main application file
    `app.js` in the `~/snapterest/source/` directory. This file will be the entry
    point to our application, `~/snapterest/source/app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Leave it empty for now, as we have a more pressing matter to discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Creating package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever heard of **D.R.Y.** before? It stands for **Don't Repeat Yourself**,
    and it promotes one of the core principles in software development—code reuse.
    The best code is the code that you don't need to write. In fact, one of our goals
    in this project is to write as little code as possible. You might not realize
    this yet, but React helps us achieve this goal. Not only it saves us time, but
    if we also decide to maintain and improve our project in the future, it will save
    us even more time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to not writing our code, we can apply the following strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing our code in a declarative programming style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing code written by someone else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this project, we'll be using both techniques. The first one is covered by
    React itself. React leaves us no choice but to write our JavaScript code in a
    declarative style. This means that instead of telling our web browser how to do
    what we want (like we do with jQuery), we just tell it what we want it to do,
    and the how part is explained by React. That's a win for us.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and npm cover the second technique. I mentioned earlier in this chapter
    that there are hundreds of thousands of different Node.js applications available
    for us to use. This means that most likely someone already implemented the functionality
    that our application depends on.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, where do you get all these Node.js applications that we want
    to reuse? We can install them via the `npm install <package-name>` command. In
    the npm context, a Node.js application is called a **package**, and each **npm
    package** has a `package.json` file that describes the metadata associated with
    that package. You can learn more about the fields that are stored in `package.json`
    at [https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json).
  prefs: []
  type: TYPE_NORMAL
- en: Before we install our dependency packages, we will initialize a package for
    our own project. Normally, `package.json` is only required when you want to submit
    your package to the npm registry so that others can reuse your Node.js application.
    We're not going to build a Node.js application, and we're not going to submit
    our project to npm. Remember that `package.json` is technically only a metadata
    file that the `npm` command understands, and as such, we can use it to store a
    list of dependencies that our application requires. Once we store a list of dependencies
    in `package.json`, we can easily install them anytime with the `npm install` command;
    npm will figure out from where to get them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How do we create the `package.json` file for our own application? Luckily, npm
    comes with an interactive tool that asks us a bunch of questions and then based
    on our answers, creates `package.json` for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you''re located in the `~/snapterest/` directory. In Terminal/Command
    Prompt, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing it will ask you is your package name. It will suggest a default
    name, the name of the directory you''re located in. It should suggest `name: (snapterest)`
    in our case. Press *Enter* to accept the proposed default name (`snapterest`).
    The next question is the version of your package, that is, `version: (1.0.0)`.
    Press *Enter*. These two would be the most important fields if we were planning
    to submit our package to npm for others to reuse. Because we''re not going to
    submit it to npm, we can confidently accept defaults for all the questions that
    we were asked. Keep pressing *Enter* until `npm init` completes its execution
    and exits. Then, if you go to your `~/snapterest/` directory, you will find a
    new file there—`package.json`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to install other Node.js applications that we're going to reuse.
    An application that is built of multiple individual applications is called **modular**,
    whereas individual applications are called **modules**. This is what we'll call
    our Node.js dependencies from now on—Node.js modules.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing Node.js modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier, there will be a step in our development process called
    **building**. During this step, our build script will take our source files and
    all our Node.js dependency packages and transform them into a single file that
    web browsers can successfully execute. The most important part of this building
    process is called **packaging**. But what do we need to package and why? Let's
    think about it. I briefly mentioned earlier that we're not creating a Node.js
    application, but yet we're talking about reusing Node.js modules. Does this mean
    that we'll be reusing Node.js modules in a nonNode.js application? Is that even
    possible? It turns out that there is a way of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Webpack** is a tool used for bundling all your dependency files together
    in such a way that you can reuse Node.js modules in client-side JavaScript applications.
    You can learn more about Webpack at [http://webpack.js.org](http://webpack.js.org).
    To install Webpack, run the following command from inside the `~/snapterest/`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `--save-dev` flag. It tells npm to add Webpack to our `package.json`
    file as a development dependency. Adding a module name to our `package.json` file
    as a dependency allows us to record what dependencies we''re using, and we can
    easily install them later with the `npm install` command, if needed. There is
    a distinction between the dependencies that are required to run your application
    and the ones that are required to develop your application. Webpack is used at
    build time, and not at runtime, so it''s a development dependency. Hence, the
    use of the `--save-dev` flag. If you check the content of your `package.json`
    file now, you''ll see this (don’t worry if your Webpack version doesn’t match
    exactly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that npm created a new folder in your `~/snapterest/` directory called
    `node_modules`. This is the place where it puts all your local dependency modules.
  prefs: []
  type: TYPE_NORMAL
- en: Congrats on installing your first Node.js module! Webpack will allow us to use
    Node.js modules in our client-side JavaScript applications. It will be a part
    of our build process. Now let's take a closer look at our build process.
  prefs: []
  type: TYPE_NORMAL
- en: Building with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, any modern client-side application represents a mix of many concerns
    that are addressed individually by various technologies. Addressing each concern
    individually simplifies the overall process of managing the project's complexity.
    The downside of this approach is that at some point in your project, you need
    to put together all the individual parts into one coherent application. Just like
    the robots in an automotive factory that assemble cars from individual parts,
    developers have something called as build-tools that assemble their projects from
    individual modules. This process is called the **build** process, and depending
    on the size and complexity of your project, it can take anywhere from milliseconds
    to hours to build.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack will help us to automate our build process. First, we need to configure
    Webpack. Assuming you're in your `~/snapterest/` directory, create a new `webpack.config.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s describe our build process in the `webpack.config.js` file. In this
    file, we''ll create a JavaScript object that describes how to bundle our source
    files. We want to export that configuration object as a Node.js module. Yes, we''ll
    treat our `webpack.config.js` file as a Node.js module. To do this, we''ll assign
    our empty configuration object to a special `module.exports` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `module.exports` property is a part of the Node.js API. It''s a way of
    telling Node.js that whenever someone imports our module they will get access
    to that object. So what should this object look like? This is where I recommend
    that you to take a look at Webpack''s documentation and read about the core concepts
    of Webpack, from the following link: [https://webpack.js.org/concepts/](https://webpack.js.org/concepts/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first property of our configuration object will be the `entry` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As the name suggests, the `entry` property describes the entry point to our
    web application. In our case, the value for this property is `./source/app.js`—this
    is the first file that starts our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second property of our configuration object will be the `output` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `output` property tells Webpack where to output the resulting bundle file.
    In our case, we're saying that we want the resulting bundle file to be called
    `snapterest.js` and it should be saved to the `./build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack treats every source file as a module, which means all our JavaScript
    source files will be treated as modules that Webpack will need to bundle together.
    How do we explain this to Webpack?
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this with the help of the third property of our configuration object
    called `module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `module` property gets an object as its value. This object
    has a single property called `rules`—an array of rules where each rule describes
    how to create Webpack modules from different source files. Let's take a closer
    look at our rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a single rule that tells Webpack how to handle our source JavaScript
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule has three properties: `test`, `use`, and `exclude`. The `test` property
    tells Webpack which files this rule applies to. It does this by matching our source
    file names against the RegEx expression that we specified as a value for our `test`
    property: `/\.js$/`. If you''re familiar with RegEx, then you''ll recognise that
    `/\.js$/` will match all filenames that end with `.js`. This is exactly what we
    want: to bundle all our JavaScript files.'
  prefs: []
  type: TYPE_NORMAL
- en: When Webpack finds and loads all source JavaScript files, it tries to interpret
    them as plain JavaScript files. However, our JavaScript files won't be plain JavaScript
    files, instead they will have ECMAScript 2016 syntax, as well as React-specific
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can Webpack understand all that nonplain JavaScript syntax? With the help
    of Webpack loaders we can transform nonplain JavaScript syntax in to plain JavaScript.
    A Webpack loader is a transformation applied to a source file. Our `use` property
    describes a list of transformations that we want to apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one transformation that is responsible for transforming our React-specific
    syntax and ECMAScript 2016 syntax into plain JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Webpack transformations are described with objects that have the `loader` and
    `options` properties. The `loader` property tells Webpack which loader performs
    the transformation, and the `options` property tells it which options should be
    passed to that loader. The loader that will transform our ECMAScript 2016 and
    React-specific syntaxes in to plain JavaScript is called `babel-loader`. This
    specific transformation process is called **transpilation** or **source-to-source
    compilation**—it takes source code written in one syntax and transforms it into
    a source code written in another syntax. We''re using one of the most popular
    JavaScript transpilers today, called **Babel**: [https://babeljs.io](https://babeljs.io).
    Webpack has a Babel loader that uses Babel transpiler to transform our source
    code. Babel loader comes as a separate Node.js module. Let''s install this module
    and add it to the list of our development dependencies. Assuming you''re in your
    `~/snapterest/` directory, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `options` property of our Webpack loader has a couple of Babel presents:
    `latest` and `react` and a Babel `transform-class-properties` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These are Babel plugins that transpile different syntaxes: the `latest` plugin
    transpiles the syntaxes of ECMAScript 2015, ECMAScript 2016, and ECMAScript 2017
    to old JavaScript syntax, and the `react` plugin transpiles React-specific syntax
    to plain JavaScript syntax, while the `transform-class-properties` plugin transpiles
    class properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These Babel plugins are distributed as standalone Node.js modules, which we
    need to install separately. Assuming you''re in your `~/snapterest/` directory,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the third property in our Webpack rule called `exclude`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This property tells Webpack to exclude the `node_modules` directory from our
    transformation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have our `webpack.config.js` file ready. Before we run our bundling
    process for the first time, let''s add a new script called `start` to our `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now if you run `npm run start` or `npm start`, npm will run the `webpack -p
    --config webpack.config.js` command. This command runs Webpack that bundles our
    source files for production using the `webpack.config.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re ready to bundle our source files! Navigate to your `~/snapterest/` directory
    and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: More importantly, if you check your project's `~/snapterest/build/` directory,
    you'll notice that it now has the `snapterest.js` file with some code already
    inside of it—that's our (empty) JavaScript application with some Node.js modules
    that are ready to run in a web browser!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're hungry for some React goodness, then I have great news for you! We're
    almost there. All that's left to do is to create `index.html` with a link to our
    `snapterest.js` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `index.html` file in the `~/snapterest/build/` directory. Add the
    following HTML markup to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `~/snapterest/build/index.html` in a web browser. You should see the following
    text: **I am about to learn the essentials of React.js**. That''s right, we have
    finished setting up our project, and it''s time to get to know React!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned why we should use React to build user interfaces
    for modern web applications. Then, we discussed the project that we'll be building
    in this book. Finally, we installed all the right tools and created the project's
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll install React, take a closer look at how React works,
    and create our first React Element.
  prefs: []
  type: TYPE_NORMAL
