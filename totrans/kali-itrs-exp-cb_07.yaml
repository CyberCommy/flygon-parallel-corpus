- en: Chapter 7. Web Application Exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp for active/passive scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sqlmap to find SQL Injection on the login page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sqlmap to find SQL Injection on URL parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using commix for automated OS command injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using weevely for file upload vulnerability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Shellshock using Burp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Metasploit to exploit Heartbleed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the FIMAP tool for file inclusion attacks (RFI/LFI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web application penetration testing is the phase where we exploit the vulnerabilities
    that we have discovered during vulnerability assessment.
  prefs: []
  type: TYPE_NORMAL
- en: The success of penetration testing depends on how much information and vulnerabilities
    have been discovered so far. It may not be necessary that all the vulnerabilities
    that we have discovered can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: Web application exploitation is not dependent on what tools you use. It is an
    exercise of finding security issues in web applications. A web application is
    nothing but a software that runs on the web instead of locally on your operating
    system. It is meant to perform specific tasks and for specific users. The best
    way to exploit a web application is to understand what the application is about
    and what tasks it accomplishes and focus more on the logical working flow of the
    application. Web applications can be of different types and architectures; take,
    for example, dynamic web pages using PHP/Java/.NET and MySQL/MSSQL/Postgress or
    single page application using Web APIs. It would be far more comprehensive to
    test web applications when you understand the architecture of web applications,
    their underlying technology, and their purpose.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this chapter, we have several tools available in Kali Linux that
    can be used for the exploitation of vulnerabilities found in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not run the tools demonstrated in this chapter against public websites that
    are not your own and are not on your own servers. In this case, we have set up
    three vulnerable web applications running in the Docker to demonstrate the tools/techniques
    in this chapter. *Be careful!*
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp for active/passive scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be using the Burp scanner that is part of the Burp Suite
    Pro, which is a paid software. It costs around $350 per year. It is loaded with
    functionalities, some of which are not available or restricted in the free version.
  prefs: []
  type: TYPE_NORMAL
- en: Burp suite is not as expensive as other web application scanners out there,
    and it provides a lot of functionalities, which are quite helpful in web app penetration
    testing. Not covering these recipes would be inappropriate as it is a widely used
    tool by penetration testers for web application penetration testing. All that
    said, let's quickly dive into it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a running Kali Linux running in Oracle
    Virtualbox or VMware and an Burp Suite Pro license.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Firefox and navigate to **Preferences** | **Advance** | **Network** | **Settings**
    | **Manual Proxy Configuration** and set the host as `127.0.0.1` and the host
    port as `8080` and check **Use this for all protocols**, as shown in the following
    screenshot:![How to do it...](img/image_07_001.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal and pull the Docker container from the Docker hub, if you
    haven''t pulled the Docker image already, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the downloaded Docker image using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, to start Burp go to the **Proxy** tab, click on **turn intercept on** to
    turn it off, and then go to the **HTTP history** tab, as shown here:![How to do
    it...](img/image_07_002.jpg)![How to do it...](img/image_07_003.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, everything is set up and ready; we just need to find out the IP address
    of the container running vulnerable web applications. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should see the following output:![How to do it...](img/image_07_004.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the container ID and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Switch to the Firefox window and type the preceding IP address in the address
    bar, and you should see what is shown in the following screenshot:![How to do
    it...](img/image_07_005.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **dvwa** and then click on **Create/Reset Database**, as shown in the
    following screenshot:![How to do it...](img/image_07_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be redirected to the login page; enter the username as `admin` and
    the password as `password`, which is the default user and password for `dvwa`.
    After login, you should see the following screenshot:![How to do it...](img/image_07_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the whole application, use different modules, and click on all possible
    exercises and try them once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the Burp window and you will see that Burp has captured all the requests
    in the **HTTP history** tab, as shown here:![How to do it...](img/image_07_008.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to the target tab and find your IP address, right-click on it, and click
    on **Add to scope**, as shown in the following screenshot:![How to do it...](img/image_07_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, right-click on the same IP and this time, click on **Spider this host**,
    as shown in the following screenshot:![How to do it...](img/image_07_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answer any pop-up screens that may appear appropriately and note the additional
    application paths being discovered and listed in the **Target** tab, as shown
    in the following screenshot:![How to do it...](img/image_07_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the same IP, and this time, click on **Actively scan this
    host**, as shown in the following screenshot:![How to do it...](img/image_07_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have a few options to select and customize before the scan starts; check
    the last point that says **Remove items with the following extensions [20 items]**,
    as shown in the following screenshot:![How to do it...](img/image_07_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the scanner page; it will show progress of all the running tests on various
    URLs, as shown in the following screenshot:![How to do it...](img/image_07_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, wait for the scans to complete and open the **Target** tab again and you
    will see the different vulnerabilities detected, as shown in the following screenshot:![How
    to do it...](img/image_07_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have configured our browser to use Burp proxy on `127.0.0.1` at `8080` port,
    and then we downloaded the vulnerable web application from the Docker hub using
    the `docker pull <image-name>` command. We then started the Docker image in the
    Docker container using the `docker run <image-name>` command and extracted the
    IP address of the running container using `docker inspect <container-id>`.
  prefs: []
  type: TYPE_NORMAL
- en: We then navigated to the same IP address in the browser and traversed the application,
    and then we saw how Burp captured every request that we made via our browser.
    We added the same domain in our scope and then went through the whole application
    to figure out all possible URLs in the application. We then finally started the
    active scanning on the host, which found out critical bugs, such as SQL Injection,
    cross-site scripting and command injection. In the next few recipes, we will learn
    how to use the knowledge obtained from this scan and how to use specific tools
    in order to exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: Using sqlmap to find SQL Injection on the login page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL Injections are always in the OWASP top three in every iteration of OWASP
    Web Application Top 10 Vulnerabilities for a reason. They are the most damaging
    to web applications and thus to businesses as well. Finding an SQL Injection is
    difficult, but if you happen to find one, exploiting it manually till you get
    access on the server is even harder and time consuming. Therefore, it is important
    to use an automated approach because during the penetration testing activity,
    time is always running out and you will always want to confirm the existence of
    an SQL Injection sooner than later.
  prefs: []
  type: TYPE_NORMAL
- en: Sqlmap is an open source penetration testing tool that automates the process
    of detecting and exploiting SQL Injection flaws and taking over of database servers
    written in Python and being regularly maintained by their developers. SQLMap has
    become a powerful tool and is very reliable in identifying and detecting SQL Injection
    in various parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use sqlmap to find SQL Injection vulnerabilities
    on the login pages of the target web application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux running in Oracle Virtualbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker installed Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intrusion-Exploitation Docker image downloaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and type `sqlmap`, and sqlmap will show its correct usage
    syntax, as shown in the following screenshot:![How to do it...](img/image_07_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use `http://172.17.0.2/bricks/login-1/index.php` as our target. This
    is an OWASP bricks installation:![How to do it...](img/image_07_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Firefox Preference** | **Advanced** | **Network** | **Settings**, as
    shown in the following screenshot:![How to do it...](img/image_07_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Manual proxy configuration** and enter **HTTP proxy** as `127.0.0.1`
    and **Proxy** as `8080` and check **Use this proxy for all protocols**, as shown
    in the following screenshot:![How to do it...](img/image_07_019.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** and come back to the **Bricks Login** page; start Burp Suite
    if you haven't started it already. You can navigate to **Application** | **Web
    Application Analysis** | **Burpsuite**, as shown in the following screenshot:![How
    to do it...](img/image_07_020.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Burp's window will open, and you can select a temporary project and click on
    **Start Burp**; your burp window will look like what is shown in the following
    screenshot:![How to do it...](img/image_07_021.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the bricks login page and enter the username and password with any
    string and click on **Submit**. It doesn't matter what you enter in the username
    and password fields because we will be intercepting the request at Burp; once
    you click on the **Submit** button on the login page, you will see the Burp window,
    as shown here:![How to do it...](img/image_07_022.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere on the Burp window and click on the **Copy to File** menu,
    as shown in the following screenshot:![How to do it...](img/image_07_023.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `sqlmap` command will run its heuristic checks and show the database identified
    as MySQL and ask for your confirmation if you want to skip looking for other possible
    databases; type *Y* and press *Enter*, as it is mostly accurate and it is better
    to generate as few requests as possible on the server. Take a look at the following
    screenshot:![How to do it...](img/image_07_024.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you press *Enter*, it will ask you whether you want to keep level and risk
    to value. What this means is that while looking for SQL Injection, it performs
    as few requests as possible and should be the least risky SQL statement as possible.
    It is always better to start with value `1`, and if that doesn't work, then increase
    the level and risk to 5; for now, we will type *Y* and press *Enter*, as shown
    in the following screenshot:![How to do it...](img/image_07_025.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, sqlmap will prompt you that it is not possible to inject with NULL
    values and ask you whether you wish to use a random integer value for the `- -union-char`
    option. The statement is clear enough to understand; type *Y* and press *Enter*,
    as shown in the following screenshot:![How to do it...](img/image_07_026.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sqlmap has identified username to be injectable and vulnerable; now sqlmap is
    prompting whether you would like to keep looking for other vulnerable parameters
    or whether you want to start with exploiting the one parameter that is found to
    be vulnerable. It is usually a good option to look for all vulnerable parameters,
    as you would be able to report to your development about all the parameters on
    which input validation needs to be done; for now, we will type *Y* and press *Enter*,
    as shown in the following screenshot:![How to do it...](img/image_07_027.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will keep prompting until all the parameters have been tested; once done,
    sqlmap will prompt you to choose which parameters should be exploited, as shown
    in the following screenshot:![How to do it...](img/image_07_028.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can choose any parameters of your choice; for demo, we will choose the username
    parameter and type `**0**` and press *Enter* and immediately sqlmap will start
    retrieving the information you have mentioned in the switches, as shown in the
    following screenshot:![How to do it...](img/image_07_029.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can sqlmap as dump database tables names, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_07_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we learned how to use sqlmap to check whether parameters on
    the login page are vulnerable to SQL Injection or not. In this command, we have
    used the following switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--url`: This switch gives the target URL to sqlmap. This is a mandatory switch
    in order to run sqlmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--data`: This is a specific switch that you need to use in order to send post
    data. In our example, we are sending `wp-username`, `wp-pass`, and `wp-submit`
    and their respective values as post data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This switch can be used instead of the `--url` switch. The `-r` switch
    loads the request file with the post data. `/path/to/file`. You can create the
    request file by capturing the `POST` request to the login page using Burp by right-clicking
    on the proxy and saving it to the file option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dbs`: This switch fetches all database names if any parameter is found to
    be vulnerable and injectable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--tables`: This switch fetches all the table names in the database if any
    parameter is found to be vulnerable and injectable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--is-dba`: This switch checks whether the application using the database user
    has DBA privileges or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QLMAP`: This is used to find SQL Injection in URL parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting SQL Injection on URL parameters using SQL Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL Injection can be found anywhere in the application, for example, on the
    login page, `GET`,`POST` parameters, behind authentication, and sometimes even
    on cookies themselves. Using sqlmap is not very different from how we have used
    it in the previous recipe, but the intention of this recipe is to help you understand
    how sqlmap can also be used to exploit SQL Injections on pages accessible only
    after authentication.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at how we can use sqlmap to exploit SQL Injections
    on authenticated pages. Using the `-r` switch allows sqlmap to use cookies within
    the request while checking for URL, whether they are accessible or not. Since
    sqlmap can process cookies from the saved request, it allows sqlmap to be successfully
    able to identify and exploit SQL Injections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running in Oracle Virtualbox
    and an Internet connection. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use **Damn Vulnerable Web Application** (**DVWA**) hosted at `http://172.17.0.2`.
    Log in using the default DVWA credentials and click on **SQL Injection** present
    at the left-hand side menu. Enter `1` as user ID in the input box, and it will
    show you the details of the user with error messages on the top, as shown in the
    following screenshot:![How to do it...](img/image_07_031.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding error messages clearly point to a potential SQL Injection, and
    we will use sqlmap to exploit this SQL Injection using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: On running the preceding command, sqlmap immediately determines that the backend
    database is MySQL and asks for your confirmation to skip any additional checks
    if possible. Press *Y* and continue as shown in the following screenshot:![How
    to do it...](img/image_07_032.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sqlmap continues and verifies the vulnerable parameter and asks for user input
    to continue to check for other parameters, as shown in the following screenshot:![How
    to do it...](img/image_07_033.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On pressing *N*, it shows you the summary of the vulnerable parameters along
    with the injection type and query used, as shown in the following screenshot:![How
    to do it...](img/image_07_034.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After discovering that the ID parameter is vulnerable to SQL Injection, we
    modify our original command to add additional switches, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: On running the preceding command, you can see the following output:![How to
    do it...](img/image_07_035.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, you can use other switches in sqlmap to go on and completely take
    over the web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have used sqlmap to exploit the ID parameter on the authenticated
    page and extracted the information regarding databases, users, current users,
    current database and hostname, and so on. In the above steps we have used the
    following new switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--cookie`: This switch uses a HTTP cookie header to access authenticated resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dbs`: This switch enumerates DBMS databases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--users`: This switch enumerates DBMS users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--current-user`: This switch retrieves DBMS current user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--current-db`: This switch retrieves DBMS current DB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--hostname`: This switch retrieves DBMS server hostname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using commix for automated OS command injection
  prefs: []
  type: TYPE_NORMAL
- en: In the first recipe of this chapter, we used Burp Scanner to find out the various
    vulnerabilities in web applications. As you can see, we have had the OS command
    injection vulnerability being detected by the Burp scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Now in this recipe, we will learn how to use the commix tool, which is short
    for [comm]and [i]njection e[x]ploiter, and as the name suggests, it is an automated
    tool for command injection and exploitation. We will use commix to exploit the
    entry point identified by the burp scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux running on Oracle Virtualbox/VMware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output of Burp Scanner as shown in first recipe of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable web applications running on Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Burp scanner **Target** window, as demonstrated in the previous recipe:![How
    to do it...](img/image_07_036.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the command injection vulnerability identified by the Burp Scanner,
    go to the **Request** tab, and observe how the modified request was made and the
    response received by the Burp. We will use the same entry point parameter where
    Burp has identified the command injection and we use it in commix, as shown in
    the following screenshot:![How to do it...](img/image_07_037.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now open the terminal and type `commix`; it will display the default help in
    the window, as shown in the following screenshot:![How to do it...](img/image_07_038.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use the following command to start the commix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The commix will detect whether the URL is reachable and will fetch all the possible
    information possible and then ask you whether you want to open a pseudo terminal
    shell, as shown in the following screenshot:![How to do it...](img/image_07_039.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you enter *Y*, you will see the shell prompt, as shown here:![How to do it...](img/image_07_040.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you look closely in the output before the pseudo random shell, you will
    notice that commix and gather the hostname, current user, current user privilege,
    and operating system and password file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_07_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can type various commands in the pseudo terminal shell and get the output
    on screen; for example, type `pwd` for a present working directory and `id` for
    current user privileges, as shown in the following screenshot:![How to do it...](img/image_07_042.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we saw how to use commix for command injection and exploitation.
    Since we have already identified one possible parameter where command injection
    could be possible, we used **INJECT_HERE** in order to help commix identify the
    vulnerable parameter to execute queries and show the output. In addition, we used
    the following switches in the tool, whose purpose and description is mentioned
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--url`: This switch is used to provide the target URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cookie`: This switch is used to provide the cookies to commix if the target
    URL is behind the authentication; commix can use the cookies to be able reach
    the target URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--data`: This switch is used to provide any `POST` body parameters that need
    to be sent to the target URL to be able to make a valid request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--all`: This switch is used to enumerate as much information as possible from
    the target OS X command injection, using which we can further decide which way
    to get the stable shell on the server using `netcat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Weevely for file upload vulnerability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use Weevely to exploit file upload vulnerabilities.
    Weevely is a stealth PHP web shell that simulates a telnet-like connection. It
    is very handy when you need to create a web shell to exploit file upload vulnerability.
    It works so well that you don't need to look for any tool or shell. Let's get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Kali Linux running in Oracle Virtualbox
    and an Internet connection. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the target application file upload page, as shown in the following screenshot:![How
    to do it...](img/image_07_043.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and type `Weevely`; it will display the sample syntax for
    use, as shown in the following screenshot:![How to do it...](img/image_07_044.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will need to generate a shell in PHP, which we can do using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Type `ls` and you will see that a new file has been created, named `weevely.php`,
    since our application allows only images to be uploaded we will need to rename
    this file to a `.jpg` extension, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Open the target browser with the target application file upload module, click
    on **Browse**, and select this file from the `/root` directory and upload it,
    as shown the following screenshot:![How to do it...](img/image_07_045.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A successful message shows the path where the file has been uploaded. Copy
    the path and open the terminal and type `weevely <Complete-path-to-uploaded-file>
    <password>`, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Weevely will try to connect to the uploaded file and will present to you the
    limited (or restricted) shell it has obtained, using which you can run system
    commands and perhaps use it to escalate your privileges, as shown in the following
    screenshot:![How to do it...](img/image_07_046.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another good feature that Weevely provides is that you can use system commands
    directly from a single command. In order to understand this type `weevely help`,
    as shown in the following screenshot:![How to do it...](img/image_07_047.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On running this command, Weevely connects to the backdoor and fetches the `/etc./passwd`
    file, as shown in the following screenshot:![How to do it...](img/image_07_048.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, you can check the rest of the options available with Weevely and
    extract information from the target server. You can also use Weevely via scripting
    for automation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned how to use Weevely to exploit file upload vulnerabilities
    and how to use it to get a stable shell to escalate root privileges or directly
    use Weevely to run system commands on the target server.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Shellshock using Burp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use Burp to exploit the Shellshock (CVE-2014-6271) vulnerability.
    If you haven't heard about the Shellshock vulnerability, which is also known as
    the Bash bug, it was the GNU bash remote code execution vulnerability, which could
    allow an attacker to gain access over a target machine. Since Bash is being widely
    used, this vulnerability had a huge attack surface and given the high severity
    and ease of exploit of this bug, it was one of the highest impact security issues
    identified in 2014; therefore, we decided to demonstrate how it can be exploited
    using Burp.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux running in Oracle Virtualbox/VMware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker installed and running in Kali
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start this recipe by searching and downloading a container from Docker
    hub, which is vulnerable to Shellshock, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_07_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the very first Docker image for the demonstration, and we will
    use the following command to pull the Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will run the Docker image as a container using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since it is a second container running in Kali, it has the `172.17.0.3` IP address;
    you can use `docker inspect <container-name>` to find out the IP address of your
    container. We will now open the browser and visit `72.17.0.3`, and you will see
    the following web page:![How to do it...](img/image_07_050.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we have already configured our browser to use Burp proxy, navigate to
    **Proxy** | **HTTP history** tab, as shown here:![How to do it...](img/image_07_051.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on it and click on **Send it to Repeater**, as shown in the
    following screenshot:![How to do it...](img/image_07_052.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the repeater window and change the user agent to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_07_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now click on **Go** and you will see the `passwd` file contents in the **Response**
    window, as shown in the following screenshot:![How to do it...](img/image_07_054.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is how easy it is to exploit shellshock using Burp.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we searched and downloaded the Docker container image from the
    Docker hub, which is vulnerable to Shellshock. We then started the container and
    pointed our browser to the container IP address. We used the Burp proxy to select
    the `/cgi-bin/` request and sent it to repeater. In the repeater window, we changed
    `user agent` to the Shellshock exploit string to read the `/etc/passwd` file,
    and we got the `passwd` file contents in response.
  prefs: []
  type: TYPE_NORMAL
- en: Using Metasploit to exploit Heartbleed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be using Metasploit, available in Kali Linux, to exploit
    to the Heartbleed vulnerability. It is not mandatory to use Metasploit to exploit
    Heartbleed. It can be done using simple Python script or a simple Burp plugin
    (in the free version) to figure out whether the server/service is vulnerable to
    Heartbleed. However, we wanted to introduce Metasploit exploit and an auxiliary
    module, which can be very helpful at times.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux running on Oracle Virtualbox/VMware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker running on Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable Web Application Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start this recipe by searching and downloading a container from the
    Docker hub that is vulnerable to Shellshock using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_07_055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the very first Docker image for the demonstration, and we will
    use the following command to pull the Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will run the Docker image as a container using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since it is a third container running in our Kali, it has the `172.17.0.4` IP
    address. You can use `docker inspect <container-name>` to find out the IP address
    of your container. We will now open the browser and visit `72.17.0.4`. and you
    will see the following web page:![How to do it...](img/image_07_056.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up your bee-box image using VMware/Virtualbox and open `msfconsole` in your
    Kali Linux, as shown here:![How to do it...](img/image_07_057.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `search heartbleed` to locate Heartbleed-related auxiliary and exploits
    available in Metasploit, as shown here:![How to do it...](img/image_07_058.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we can see, there is an auxiliary module available for Heartbleed. We will
    go ahead and use it for our exploitation using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Type `show options` to see the available options, as shown here:![How to do
    it...](img/image_07_059.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will need to change `rhost` and `rhost` as per your target information;
    in our case, it is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After setting up appropriate settings, we will run the module by typing `run`
    on the `msf` console, and the output will be as shown here:![How to do it...](img/image_07_060.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The module has detected this server as vulnerable to Heartbleed. We will now
    go ahead and change the action to `DUMP` from `SCAN` using the command shown in
    the following screenshot:![How to do it...](img/image_07_061.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After changing the action, we will run the module again and the output will
    be as follows:![How to do it...](img/image_07_062.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data retrieved from the server has been dumped into the file on the directory
    path given by Metasploit. We will go ahead and change the action to `KEYS` from
    `DUMP` and run the module one last time to see whether we can retrieve any private
    keys from the server, as shown here:![How to do it...](img/image_07_063.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After changing the action, run the module once again to see whether Metasploit
    can retrieve private keys from the server, as shown here:![How to do it...](img/image_07_064.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, Metasploit has successfully extracted private keys from the
    vulnerable server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used Metasploit to exploit the SSL Heartbleed vulnerability
    for exploitation, which can dump memory data and extract private keys of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using the FIMAP tool for file inclusion attacks (RFI/LFI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the very first recipe, the Burp Scanner also identified the file path travel
    vulnerability. In this recipe, we will learn how to use Fimap to exploit the file
    path traversal vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Fimap is a Python tool that can help in finding, preparing, auditing and finally
    exploiting local and remote file inclusion bugs in web applications automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To step through this recipe, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux running on Oracle Virtualbox/VMware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker running on Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable Web Application Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the browser and navigate to `http:/dvwa.hackhunt.com/dvwa` and log in with
    the default credentials. Click on **File Inclusion** from the left-hand side menu,
    as shown in the following screenshot:![How to do it...](img/image_07_065.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and type `fimap`, which will show the version and author information,
    as shown in the following screenshot:![How to do it...](img/image_07_066.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use Fimap to exploit the LFI/RFI vulnerability, we need to use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Fimap will start looking for the local file it can read from the server and
    will display it if the target is vulnerable to a file inclusion attack, as shown
    in the following screenshot:![How to do it...](img/image_07_067.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end, Fimap will show all the files it was able to read from the server,
    as shown in the following screenshot:![How to do it...](img/image_07_068.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we will use the command which we used earlier with `-x` at the end in order
    to go ahead and exploit this file inclusion and get us a shell of the server,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Fimap will start an interactive menu as and ask for the input; choose `1` as
    our domain is `dvwa.hackhunt.com`, as shown here:![How to do it...](img/image_07_069.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, it will ask you to choose the vulnerable bug to start with;
    for our example, we will choose `1`, as shown in following screenshot:![How to
    do it...](img/image_07_070.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, it gives you two options. `1` is to spawn a direct shell and
    the second is to create a reverse shell using the pentest monkey script. For our
    demonstration, we will use `1`, as shown in the following screenshot:![How to
    do it...](img/image_07_071.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, we have successfully received the shell, as shown in the following
    screenshot:![How to do it...](img/image_07_072.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use this channel to get us a stable shell and finally escalate to get
    root privileges on the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used Fimap to exploit local and remote file inclusion and
    get shell access on the server. In this recipe, we used the following switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '* `-u`: This indicates the target URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cookie`: Since our point of injection was after the authentication, we had
    to use this option in order to set cookies so that Fimap can access the injection
    point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--enable-blind`: This switch is very helpful when Fimap isn''t able to detect
    something or if there are no error messages appearing. Note that this mode will
    cause lots of requests compared to the'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x`: This is used to exploit the remote file inclusion vulnerability and spawn
    a shell automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
