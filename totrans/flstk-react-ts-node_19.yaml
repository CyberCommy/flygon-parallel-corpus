- en: '*Chapter 16*: Adding a GraphQL Schema – Part II'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to continue completing our client and server code.
    We will complete our Thread screens, which allow us to post new Threads and their
    responses, and also finish the Points system for the site. Please use the source
    code from [*Chapter 15*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222)*, Adding
    a GraphQL Schema – Part I*, to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Thread route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will update our `Thread` component, which provides our
    thread route. We''re going to be touching on a lot of files as we go through this.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `typeDefs` and edit the `Thread` and `ThreadItem` types. Then, add this
    field just below `views`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `ThreadRepo` file and update the `getThreadById` function, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'All we did here was add the following `relations` to our `findOne` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the `getThreadsByCategoryId` function''s call to `Thread.createQueryBuilder`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We've included the relation for the User entity here. The rest of the code for
    this function remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `User.ts` file in your client app and update the `threads` and
    `threadItems` fields so that they''re optional. We need to do this so that we
    can add a `User` account that has not posted anything yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `models/Thread.ts` and `models/ThreadItem.ts` files in the React
    client project and replace the `userName` and `userId` fields with a single field
    user, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to replace the references to the `userName` and `userId` fields
    in our `DataService.ts` file with a user object. Here, I''ve placed an object
    at the top of the file and used it throughout the file to replace those two fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the `DataService.ts` file if you need any help, though this should
    be pretty trivial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve updated our `User` schema type and our entities, we need to
    update some queries. In the `Main.tsx` file, update the `GetThreadsByCategoryId`
    and `GetThreadsLatest` queries, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: const GetThreadsLatest = gql`
  prefs: []
  type: TYPE_NORMAL
- en: query getThreadsLatest {
  prefs: []
  type: TYPE_NORMAL
- en: getThreadsLatest {
  prefs: []
  type: TYPE_NORMAL
- en: '... on EntityResult {'
  prefs: []
  type: TYPE_NORMAL
- en: messages
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '... on ThreadArray {'
  prefs: []
  type: TYPE_NORMAL
- en: threads {
  prefs: []
  type: TYPE_NORMAL
- en: id
  prefs: []
  type: TYPE_NORMAL
- en: title
  prefs: []
  type: TYPE_NORMAL
- en: body
  prefs: []
  type: TYPE_NORMAL
- en: views
  prefs: []
  type: TYPE_NORMAL
- en: points
  prefs: []
  type: TYPE_NORMAL
- en: user {
  prefs: []
  type: TYPE_NORMAL
- en: userName
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: threadItems {
  prefs: []
  type: TYPE_NORMAL
- en: id
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: category {
  prefs: []
  type: TYPE_NORMAL
- en: id
  prefs: []
  type: TYPE_NORMAL
- en: name
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '`;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our `ThreadCard.tsx` file, find the following JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to make some more changes to our `RichEditor.tsx` file. Note that
    our Thread screen will be showing user submitted text. So, once a user has submitted
    what they wish to post, we will make it so that they cannot edit it afterward.
    We'll do this by making the read-only setting a prop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Turn the `RichEditorProps` interface into a class and update it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'const RichEditor: FC<RichEditorProps> = ({ existingBody, readOnly field as
    a parameter. Now, inside the Editable component, add it as an attribute, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `src/components/routes/thread/Thread.tsx` file. This file is our
    main screen for loading the Thread route. Let's update this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we''re adding a new `GetThreadById` query to get our relevant Thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using our `GetThreadById` query, along with our `useLazyQuery`
    Hook, and creating an executor function called `execGetThreadById`, which we will
    run a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `thread` state object is what we will be using to populate our UI and share
    it with other components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`id` is the URL parameter representing the Thread''s `id` value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will use this `readOnly` state to make our `RichEditor` read-only if we are
    dealing with an existing Thread record.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've run our `execGetThreadById` call by using the parameter given by
    the URL for the Thread's `id`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once our `execGetThreadById` call is completed, a `threadData` object is returned.
    We can use this to set our local `thread` state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `thread?.user` object to get our `userName` field, instead
    of `thread?.userName`, which is how we had it set up previously.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`ThreadCategory` has now been updated so that it will set `CategoryDropDown`
    to the `Category` option provided. We''ll look at this later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed the `readOnly` state value to `ThreadBody` since `ThreadBody`
    uses `RichEditor` internally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed the `readOnly` state value to `ThreadResponsesBuilder`, which
    shows our ThreadItem responses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The remaining UI is the same as it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `ThreadCategory` component. Here''s how it looks now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve switched our interface definition so that it takes a `Category` object
    instead of a string. This allows us to pass it down to our `CategoryDropDown`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve used `category?.name` of the `Category` object, whereas previously,
    we used `categoryName` as the necessary parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve explicitly passed in the `preselectedCategory` prop from our component''s
    `category` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update your `ThreadBody` component''s call to `RichEditor` by passing
    the `readOnly` field, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve added the `readOnly` field to our props type; that is, `ThreadBodyProps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s update the `ThreadResponseBuilder` component, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is a `readOnly` prop definition. This is because this component
    uses a `ThreadResponse`, which internally uses `RichEditor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the Thread's `user` object to get the required `userName`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here is our `readOnly` field being passed into `ThreadResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The rest of code is the same as it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have our `ThreadResponse` component, which is updated with the
    `readOnly` prop, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here's the prop definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '}) => {'
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <UserNameAndTime userName={userName}           lastModifiedOn={lastModifiedOn}
    />
  prefs: []
  type: TYPE_NORMAL
- en: '<span style={{ marginLeft: "1em" }}>'
  prefs: []
  type: TYPE_NORMAL
- en: <ThreadPointsInline points={points || 0} />
  prefs: []
  type: TYPE_NORMAL
- en: </span>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="thread-body-editor">
  prefs: []
  type: TYPE_NORMAL
- en: <RichEditor existingBody={body}          readOnly={readOnly} />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It's a bit difficult to see since there's no significant visual clue, but you'll
    notice that on the thread route for any existing Thread, such as `http://localhost:5000/thread/1`,
    your editors for your Thread and any responses will all be in read-only mode,
    which means they can't be edited.
  prefs: []
  type: TYPE_NORMAL
- en: Points system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve set everything up so that we can display points, we need a
    mechanism for setting them. This is what we''ll do now. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Thread.tsx` file and take a look at the code. You will find a component
    called `ThreadPointsBar` near the end of the JSX. This is what shows the vertical
    bar of points in our `ThreadCard` and our `Thread.tsx` route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to add buttons to allow an increment or decrement of points. We've
    already built our backend and resolvers, so the work we'll be doing here will
    just tie that to our client code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `ThreadPointsBar.tsx` file, update the existing JSX, as follows.
    This is a significant change, so let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, we have our `updateThreadPoint` mutation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With that, we've converted our `ThreadPointsBarProps` interface into a class
    so that we can give some of the fields default values. Notice that, among the
    fields, we have a `refreshThread` function, which we'll use to force an update
    to our parent Thread so that once we update the points, this will be reflected
    in our UI. We'll go through the other fields as we use them. Also, we will no
    longer be sharing this prop with our `ThreadPointsInline` component, which I'll
    show later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our `useMutation` does not use `refetchQueries` to refresh Apollo
    Client. Normally, I would use this mechanism, but in testing, I found that the
    Apollo Client cache, which caches all GraphQL queries by default, was unable to
    refresh the Thread properly. These sorts of issues happen from time to time for
    all frameworks. It will be part of your job as a developer to figure out workarounds
    and solutions to these types of problems. So, instead of relying on `refetchQueries`,
    we will use our `refreshThread` function, which we can get from our parent, to
    force a refresh. I will show you the implementation of this function a little
    later in the `Thread` route component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Both these functions, `onClickIncThreadPoint` and `onClickDecThreadPoint`, are
    executing the `execUpdateThreadPoint` mutation before calling `refreshThread`.
    The `refreshThread && refreshThread()` syntax is one of JavaScript's capabilities
    that allows you to write less code. This syntax allows you to check that this
    optional function exists and if it does, execute it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a small bit of logic that uses the `allowUpdatePoints` prop,
    which decides whether to show or hide the icon container that allows the user
    to increment points. We must do the same for the decrement button as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added two new icons, `faChevronUp` and `faChevronDown`. When clicked,
    they will increment or decrement the points of our Thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code remains the same. However, notice that our CSS has changed
    slightly. We've updated the existing `threadcard-points-item` class and added
    a new class called `threadcard-points-item-btn`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `threadcard-points-item` class is now a flexbox on a column so that it can
    show its content vertically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `threadcard-points-item-btn` class converts our icon cursor into a pointer
    so that when a user hovers over it, the cursor becomes a hand, indicating that
    it can be clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve made these changes, we need to update some other relevant components.
    The first thing we want to do is disable `resultCaching` in our `ApolloClient`.
    Open the `index.tsx` file and update the `client` object, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As the name suggests, this setting is supposed to disable query results from
    being cached. However, it does not do this on its own – we have to add another
    setting to our queries.
  prefs: []
  type: TYPE_NORMAL
- en: Update the `Thread.tsx` file. We'll just show the code that has been changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, the `getThreadById` query has been updated slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: const [thread, setThread] = useState<ThreadModel |    undefined>();
  prefs: []
  type: TYPE_NORMAL
- en: const { id } = useParams();
  prefs: []
  type: TYPE_NORMAL
- en: const [readOnly, setReadOnly] = useState(false);
  prefs: []
  type: TYPE_NORMAL
- en: const refreshThread = () => {
  prefs: []
  type: TYPE_NORMAL
- en: if (id && id > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: execGetThreadById({
  prefs: []
  type: TYPE_NORMAL
- en: 'variables: {'
  prefs: []
  type: TYPE_NORMAL
- en: id,
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: useEffect(() => {
  prefs: []
  type: TYPE_NORMAL
- en: if (id && id > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: execGetThreadById({
  prefs: []
  type: TYPE_NORMAL
- en: 'variables: {'
  prefs: []
  type: TYPE_NORMAL
- en: id,
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}, [id, execGetThreadById]);'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: useEffect(() => {
  prefs: []
  type: TYPE_NORMAL
- en: if (threadData && threadData.getThreadById) {
  prefs: []
  type: TYPE_NORMAL
- en: setThread(threadData.getThreadById);
  prefs: []
  type: TYPE_NORMAL
- en: setReadOnly(true);
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: setThread(undefined);
  prefs: []
  type: TYPE_NORMAL
- en: setReadOnly(false);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}, [threadData]);'
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <div className="screen-root-container">
  prefs: []
  type: TYPE_NORMAL
- en: <div className="thread-nav-container">
  prefs: []
  type: TYPE_NORMAL
- en: <Nav />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="thread-content-container">
  prefs: []
  type: TYPE_NORMAL
- en: <div className="thread-content-post-container">
  prefs: []
  type: TYPE_NORMAL
- en: <ThreadHeader
  prefs: []
  type: TYPE_NORMAL
- en: userName={thread?.user.userName}
  prefs: []
  type: TYPE_NORMAL
- en: 'lastModifiedOn={thread ? thread.             lastModifiedOn : new Date()}'
  prefs: []
  type: TYPE_NORMAL
- en: title={thread?.title}
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <ThreadCategory category={thread?.category} />
  prefs: []
  type: TYPE_NORMAL
- en: <ThreadTitle title={thread?.title} />
  prefs: []
  type: TYPE_NORMAL
- en: <ThreadBody body={thread?.body}            readOnly={readOnly} />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="thread-content-points-container">
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: <ThreadPointsBar
  prefs: []
  type: TYPE_NORMAL
- en: points={thread?.points || 0}
  prefs: []
  type: TYPE_NORMAL
- en: responseCount={
  prefs: []
  type: TYPE_NORMAL
- en: thread && thread.threadItems && thread.               threadItems.length
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: userId={thread?.user.id || "0"}
  prefs: []
  type: TYPE_NORMAL
- en: threadId={thread?.id || "0"}
  prefs: []
  type: TYPE_NORMAL
- en: allowUpdatePoints={true}
  prefs: []
  type: TYPE_NORMAL
- en: refreshThread={refreshThread}
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="thread-content-response-container">
  prefs: []
  type: TYPE_NORMAL
- en: <hr className="thread-section-divider" />
  prefs: []
  type: TYPE_NORMAL
- en: <ThreadResponsesBuilder
  prefs: []
  type: TYPE_NORMAL
- en: threadItems={thread?.threadItems}
  prefs: []
  type: TYPE_NORMAL
- en: readOnly={readOnly}
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here's what the Thread route screen now looks like with our new points system
    in place:![Figure 16.1 – Thread route screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – Thread route screen
  prefs: []
  type: TYPE_NORMAL
- en: If you try clicking the points buttons, you'll notice two things. For one, sometimes,
    the points change does not immediately show on the screen, despite all the work
    we did in eliminating caching as an issue. This is because we have a subtle bug
    in our Repository call, which I'll discuss in a bit. The other issue is that our
    user can add or remove more than one point at a time. This is another issue in
    our Styling layer. We'll revisit these two issues once our client code is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update the points capability for our `ThreadItem` and `Thread`
    responses. We''ll start with `ThreadResponsesBuilder`. Update `useEffect`, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now passing the `ThreadReponse` component, which shows the Thread''s
    `ThreadItem`, `userId`, and `threadItemId`. In this component, we have the `ThreadPointsInline`
    component, which displays the like points for `ThreadItem` or `Thread`, depending
    on which was passed in, which I''ll clarify once we get to that control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `ThreadResponse` component can be updated. I'm only showing the changed
    code here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, add the following two fields to the `ThreadResponseProps` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the JSX, we can add our `userId` and `threadItemId` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: </span>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="thread-body-editor">
  prefs: []
  type: TYPE_NORMAL
- en: <RichEditor existingBody={body}         readOnly={readOnly} />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the changes we must make to the `ThreadPointsInline` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following import to the list of existing imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the source code. For the most part, it''s a lot like the `ThreadPointsBar`
    CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added our `updateThreadItemPoint` mutation definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This is now going to be our props list. Notice that we have a field for `threadId`.
    We will be using this `ThreadPointsInline` control to display our Thread points
    on mobile screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing particularly special here – both our `onClickIncThreadItemPoint`
    and `onClickDecThreadItemPoint` calls are doing similar things to the `ThreadPointsBar`
    component in that they call our update mutation and then refresh the Thread data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our JSX, we will do something similar to our `ThreadPointsBar` component
    and include icons that allow us to increment or decrement the entity points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you load the `Thread` route screen again, you should see `ThreadItems`
    for our Thread. Again, your local data will vary, so please make sure your Thread
    contains `ThreadItem` data and their respective points, along with the icon buttons,
    as shown in the following screenshot:![Figure 16.2 – ThreadItem points
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.02_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.2 – ThreadItem points
  prefs: []
  type: TYPE_NORMAL
- en: Again, if you click the increment and decrement buttons, you should see that
    we have the same issue that we had with the Thread points. Our points score does
    not always update, and the user can keep adding or removing points. Let's fix
    this issue now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your server project, open the `ThreadItemPointRepo.ts` file, find the
    `updateThreadItemPoint` function, and go to the first call to `threadItem.save()`.
    Add a prefix to all these calls in the function, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess why this will fix the issue we're having? By calling `await` on
    the `save` call, we are forcing our function to wait until the save completes.
    Then, when we get our `ThreadItem` data, we are assured that it does indeed contain
    the newest `points` value. This is one of the tricky sides of using asynchronous
    code. It's faster, but you have to think about what you're doing; otherwise, you
    may run into issues like this.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and update the `updateThreadPoint` function yourself, similar
    to what we just did with our `updateThreadItemPoint` function. Make sure to update
    every `save` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you try incrementing or decrementing the points, you should see them
    update properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s fix the issue of users being able to keep adding or removing points.
    There''s actually multiple issues in this code path. Our two resolvers that update
    points, `updateThreadPoint` and `updateThreadItemPoint`, do not check for user
    authentication before trying to allow the user to update their points. This is
    obviously wrong. Additionally, our client-side code is actually passing the `userId`
    value of `Thread` or `ThreadItem` instead of the currently logged-in user. We
    can fix both issues together. First, update the `updateThreadPoint` resolver,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We no longer take `userId` as a parameter for this resolver. This is because,
    as shown in the following code, we now check that the user is logged in via the
    `session.userId` field. Then, when we call our `updateThreadPoint` Repository
    query, we pass that `session.userId` field in as the `userId` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Make this same change for the `updateThreadItemPoint` resolver, since they are
    virtually identical calls. Also, don't forget to update our `typeDefs` so that
    the Mutation signatures for these calls no longer have the `userId` parameter.
    We'll also need to update the code paths in our client and remove the `userId`
    parameter there later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add this code to the `updateThreadPoint` Repository call at the top of
    the implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This will prevent any odd values for `userId` getting passed in, and us thinking
    that the user is authenticated when they are not. Add the same code to the `updateThreadItemPoint`
    Repository call.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's fix the client-side code and remove the `userId` parameter. The easiest
    way to do this is to remove the call from the `ThreadPointsBar` and `ThreadPointsInline`
    components. If you then save the code, you'll get the compiler telling you where
    the related calls are via `userId`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `ThreadPointsBar`. Update it like this. Remove `userId` from
    the `UpdateThreadPoint` Mutation parameters. Then, remove it from the props of
    the component's `ThreadPointsBarProps` type. Next, remove it from the props parameters
    of `ThreadPointsBar`. Finally, remove `userId` from the calls to `execUpdateThreadPoints`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the `Thread.tsx` route component, find the call to `ThreadPointsBar`
    and simply remove the `userId` props. Also, remove the `useSelector` call to get
    the user reducer as it's no longer being used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ThreadPointsInline` component also needs the same kind of refactor, but
    I'll leave that change up to you since it's basically the same type of change
    we made for `ThreadPointsBar`. Again, try making the change while beginning with
    the `ThreadPointsInline` component and save your code. The compiler should tell
    you where the references to `userId` still exist.
  prefs: []
  type: TYPE_NORMAL
- en: With that, our points should update properly. The points should only update
    when the user is logged in, and only be able to change by one point, either incremented
    or decremented. The user should also not be allowed to change the points for their
    own `Thread` or `ThreadItem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at something else. When looking at the `Thread` route component
    in mobile mode, you will see that our points counts are no longer visible, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – Thread route screen mobile mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.03_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.3 – Thread route screen mobile mode
  prefs: []
  type: TYPE_NORMAL
- en: 'This, of course, is deliberate since there is so little horizontal room. So,
    let''s put our `ThreadPointsInline` component in this mobile screen and update
    it so that it can work for Threads as well as ThreadItems:'
  prefs: []
  type: TYPE_NORMAL
- en: Because `ThreadPointsInline` is being refactored to use the `updateThreadPoint`
    Mutation that `ThreadPointBar` is using, we must move those calls into their own
    Hook and share them. Create a new file inside the Hooks folder called `useUpdateThreadPoint.ts`
    and add the respective Git source code to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By doing this, we have simply copied most of the code from the `ThreadPointBar`
    component into here. Once we've done this, we return the event handlers to be
    used by our calling component; that is, `onClickIncThreadPoint` and `onClickDecThreadPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s refactor the `ThreadPointBar` component so that it can use this
    Hook. Update it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve imported our new Hook and removed the Mutation for `UpdateThreadPoint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've received the event handlers from our `useUpdateThreadPoint` Hook.
    The rest of the code is identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s refactor `ThreadPointsInline`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve gotten our event handlers from the `useUpdateThreadPoint` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, there''s a tiny bit of logic that decides whether we
    will update the point of a `Thread` or `ThreadItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the same point selection logic here as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the `Thread` route in mobile mode, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Thread route screen on mobile with our points incrementor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.4 – Thread route screen on mobile with our points incrementor
  prefs: []
  type: TYPE_NORMAL
- en: Note that I've made some styling updates to the `ThreadCategory` component so
    that it can be viewed on the Home route in mobile mode as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can view existing Threads on our screen. However, we also need to be
    able to add new Threads, as well as ThreadItems. Let''s add those features now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make a small change to our `createThread` Repository call.
    Open the `ThreadRepo` file and update the last `return` statement for `createThread`,
    which looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now, if our `createThread` is successful, it will only return the ID. This minimizes
    payload sizes but gives our client what it needs to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must make another small change to our `Thread` route. Open `App.tsx`
    and find the route for `Thread`. Update that route like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add a `useHistory` so that we can modify the URL we are on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a new handler for the `Post` button click, which redirects the
    user to the thread screen without any `id`. I''ll show you why that''s important
    in a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have our `button` declaration with that handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code is the same as it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update our `Thread.tsx` component so that when it sees we have
    no `id`, it knows to set itself up so that it can add a new Thread. However, in
    order to do this, we need to update some of its child components. Let''s start
    with `RichEditor`. Update this component as follows. I''ll only show the code
    that''s been changed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '`getTextFromNodes` is a new helper that will allow the Slate.js format of our
    Node array to be translated into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '`InitialValue` is now an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added this additional prop so that when our editor has its text updated,
    that change will go up the component hierarchy to our `Thread.tsx` component.
    `Thread.tsx` needs to know the latest value so that it can send it as a parameter
    when it tries to create a new Thread. We''ll be repeating this *sendOut* pattern
    in these child components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `existingBody` prop is the initial value being sent in from the parent component.
    This value will come in when the `Thread.tsx` route screen is loaded from an existing
    Thread. This Thread is, of course, being loaded from our database, which means
    that the text data will be saved into our database as a string. This is because
    Postgres does not understand Slate.js' `Node` types. The side effect of this is
    that before `setValue` can receive this data, it must first be parsed in JSON
    format, which is why you can see `setValue(JSON.parse(existingBody))`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've set our `val` from the editor, but also sent it back to the parent
    component using `sendOutBody`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The following is a trivial `placeholder` change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to update `ThreadCategory` component. I''ll only show the code
    that has been changed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the `sendOutSelectedCategory` function, which allows us to send
    back a category selection using the `sendOut` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll update our `ThreadTitle` component, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to make our title read-only when we''ve loaded an existing Thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, here, we have the `sendOut` pattern using `sendOutTitle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve set our title and also sent it out to our component''s parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using our new props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s update `ThreadBody`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we need the `sendOut` pattern for the `sendOutBody` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must send the `sendOutBody` function to our `RichEditor` since that
    control handles body updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have the `Thread.tsx` file. We must make a number of changes here.
    Let's look at all of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should be able to add the appropriate imports yourself; for example, here,
    we need the `getTextFromNodes` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, is our new `CreateThread` mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'A new reducer also needs to be added; that is, `threadReducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our `user` object, which only appears if the user is logged in. We
    will only use this object when we''re creating a new Thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our reducer. These fields will be used to submit new Threads during
    creation mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the status of our Thread creation attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our actual `CreateThread` Mutation caller, `execCreateThread`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be using `useHistory()` to switch to the newly created Thread''s route.
    For example, if the new Thread `id` is 25, then the route will be `"/thread/25"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are updating the reducer''s `userId`, in case the user has logged
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have started adding the definitions for our handler functions in the
    `sendOut` pattern, which we''ve been using in our child components. In this case,
    `receiveSelectedCategory` receives the newly set `ThreadCategory` from the `CategoryDropDown`
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The `receiveTitle` and `receiveBody` functions also handle updates that are
    made to `title` and `body` from their respective child components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onClickPost` function handles the `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'If the attempt fails, we show the user a server error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'If the screen is being shown on a mobile device and the thread exists, we show
    this control; otherwise, we don''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of these child components contain the same logic. If the `thread`
    object exists, we display a thread. If not, then we go into Thread Post mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Here is our Thread **Post** button and status message. Again, if our thread
    object exists, we do not show these, whereas if the thread does, we show them.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of code is identical to what we had previously, so I won't show it
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we run the Thread route with no `id`, we get the following screen:![Figure
    16.6 – New Thread screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.6 – New Thread screen
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Since we are now saving Slate.js Nodes as JSON strings inside the `Body` field
    of our `Thread` table, before you can test the code, you must purge any existing
    `Thread` and `ThreadItem` data before you can display it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an issue here. Since we now have JSON strings in the `Body` field
    of our database, when this data comes back, it will look like this on the Home
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Home screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.7 – Home screen
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is not what we want. Here, we need to update this text so that
    it's a normal string. Luckily, we can just use our existing `RichEditor` to display
    the text and keep all the formatting intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `RichEditor` component by putting a `readOnly` check on the `Toolbar`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `ThreadCard` component by replacing the `<div>{thread.body}</div>`
    line in the JSX with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Again, make sure your import of `RichEditor` is also there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see something like this on the Home screen. Your own data will
    vary from what''s being shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Home screen with body'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.8 – Home screen with body
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this will also cause `RichEditor` on our Thread route screen to hide
    the Toolbar in `readOnly` mode. Now, we just need to allow new `ThreadItem` responses
    to be made and we''re done with this section. We will repurpose the `ThreadResponse`
    component so that it also allows ThreadItems to be submitted, instead of just
    being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make some minor adjustments to the server side. Open `ThreadItemRepo`
    and find `createThreadItem`. In the last `return` statement, update it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Just like what we did with our `createThread` function, we are returning the
    ThreadItem's `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inside `ThreadRepo`, update the call to `findOne`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to refactor the `ThreadItem.ts` model in our client-side code
    so that it takes a `thread` object instead of a `threadId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, we receive the `Thread` object from the query we just updated.
  prefs: []
  type: TYPE_NORMAL
- en: Now, update `ThreadResponse`, as shown in the source code. Make sure you have
    all your imports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, you'll see we have our new `CreateThreadItem` Mutation.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ThreadResponseProps` interface, we can see that the `body` prop is the
    initial value of `RichEditor` before any changes are made. We'll also need to
    receive the parent `threadId` if we are going to submit a new `ThreadItem`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we need to get the `user` object from `useSelector`. We're doing
    this because the current user will be submitting new ThreadItems.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have `execCreateThreadItem`, which is our Mutation executor for `CreateThreadItem`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have our status message, `postMsg`, for when the user attempts to save.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the current editing body value, `bodyToSave`, inside `RichEditor`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `useEffect` is used to initialize our `bodyToSave` value from the passed-in
    prop `body` so that we have an initial value to start with.
  prefs: []
  type: TYPE_NORMAL
- en: The `onClickPost` function allows us to do some validation checks before we
    attempt to submit our new `ThreadItem`. Once we've done this, we can submit and
    refresh our parent Thread.
  prefs: []
  type: TYPE_NORMAL
- en: In the `receiveBody` function, we receive our updated text from our `RichEditor`
    component. We use this if we are submitting a new `ThreadItem`.
  prefs: []
  type: TYPE_NORMAL
- en: In the returned JSX, we decide not to show `ThreadPointsInline` if we are not
    in `readOnly` mode. However, if we are in edit mode, we allow the Post button
    and the status message to be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we create a few `ThreadItem` posts, we should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Submitted ThreadItem responses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.09_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.9 – Submitted ThreadItem responses
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the Thread route screen.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost there and you've done a phenomenal job thus far. We've covered
    so much material and code to get to this stage. You should feel wonderful about
    your progress. We have one more section to complete and then we're done with our
    app!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last item we need to configure is `RightMenu`. In this menu, we will list
    up to three of the top ThreadCategories, based on the number of Threads each `ThreadCategory`
    has attributed to it. This will involve a longer multi-part query and is a good
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a new type called `CategoryThread` to the `typeDefs`
    file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Note that `titleCreatedOn` is only there for checking the sort. We won't use
    it in our client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a new model to our repository folder called `CategoryThread.ts` and
    add the following code. Note that this class will not be an Entity in our database.
    Instead, it will be an aggregation class that will contain fields from multiple
    entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Now, get the code from the source and create the `CategoryThreadRepo.ts` file
    with that code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the top, first, we have made our initial query to get `ThreadCategory`
    data from our database using `ThreadCategory.createQueryBuilder("threadCategory")`.
    Notice that we have also included our relationship to the Threads table.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are about to post-process our query to get the results we want. We are
    not doing this work in our TypeORM query because, for more complex sorting and
    filtering, TypeORM is sometimes difficult and finicky to work with. Using standard
    JavaScript will get us what we need more easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the call to `categories.sort`, on line 14, we are doing a descending sort
    based on the number of Thread records each `ThreadCategory` contains. Then, we
    take only the first three records of the result.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we take this result and sort the actual Thread records by their `createdOn`
    timestamp in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, we get, at most, three Thread records for each category, ordered
    by their `createdOn` timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's test this using GraphQL Playground:![Figure 16.10 – GetTopCategoryThread
    sort result
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_16.10_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.10 – GetTopCategoryThread sort result
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the sorts and filters are working.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's finish our client-side code. Open `CategoryThread.ts` and update
    `category` so that it's now `categoryName`. This will match our server-side model
    name for this field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `TopCategory.tsx` and update the line shown in the return JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Change `category` so that it's now `categoryName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `RightMenu.tsx` and update it from the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After making the necessary imports, we need to define our GraphQL query, `GetTopCategoryThread`,
    and then use that query on line 20 by calling `useQuery` on it. Here, we're using
    that query.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on line 26, `useEffect` has been updated to make use of the resulting
    `categoryThreadData`. The `groupBy` method from `lodash` is grouping our data
    by `categoryName` so that it's easier to work with. The original code for this
    was covered in [*Chapter 11*](B15508_11_Final_JC_ePub.xhtml#_idTextAnchor167)*,
    What We Will Learn – Online Forum Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to check for mobile width, which returns either `null` or our
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run our Home screen, we should see our `RightMenu` populated with
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.11 – Home screen with popular categories shown'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.11_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.11 – Home screen with popular categories shown
  prefs: []
  type: TYPE_NORMAL
- en: Again, your local data will vary.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we're done! There was a lot of code, and many frameworks and concepts.
    You've done an amazing job getting through it all. Take a much-deserved break.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the client-side code of our app and how to glue
    it to our backend GraphQL server. We had to tweak our styling and make adjustments
    by refactoring our code. We also had to fix hard-to-find bugs. This is exactly
    what we'll be doing in real life, so this was great practice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final coding chapter, we brought everything together by finishing our
    code and integrating the frontend React app with the backend GraphQL server. We've
    learned an enormous amount in this chapter and this book as a whole. You should
    feel proud of how far you've come.
  prefs: []
  type: TYPE_NORMAL
- en: My suggestion would be, before you move on to the final chapter, to try and
    make changes to the app. Come up with your own ideas for features and try building
    them. Ultimately, this is the only way you will really learn.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter of this book, [*Chapter 17*](B15508_17_Final_JC_ePub.xhtml#_idTextAnchor259)*,
    Deploying an Application to AWS*, we will learn how to deploy our application
    to Linux and NGINX on the Azure cloud.
  prefs: []
  type: TYPE_NORMAL
