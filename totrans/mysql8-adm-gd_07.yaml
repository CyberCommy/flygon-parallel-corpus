- en: Indexing in MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about storage engines. Now we are aware
    what types of storage engines are available and which ones to use for our requirements.
    The previous chapter also covered the `InnoDB` storage engine in detail, along
    with other storage engine information. It also described how to define a custom
    storage engine for use, with a practical example. Now it's time to understand
    one more important functionality of MySQL 8 and that is, indexing. We will cover
    different types of indexes with their functionalities, which will encourage you
    to use indexes and provided you with guidance on how to use them. So, your journey
    into indexes has started! Let's go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview on indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Column-level indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B-Tree indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an optimizer for indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invisible and descending indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview on indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define an index on a table is the best way to improve the performance of
    the `SELECT` operation. An index acts like a pointer for the table rows and permits
    queries to quickly point to matching rows based on the `WHERE` condition. MySQL
    8 allows you to create indexes on all the data types. Although indexing provides
    good performance on queries, it is recommend to define it in the proper way, because
    unnecessary indexes waste space and time (for MySQL 8 to find which index is best
    to use). In addition to that, indexes also add costs to `INSERT`, `UPDATE`, and
    `DELETE` operations, because during these operations, MySQL 8 will update each
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we described previously, an index is a data structure that improves the
    speed of operations. Based on the structure, an index is bifurcated into two major
    forms—a clustered index and a non-clustered index:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clustered index**: A clustered index defines the order in which data is physically
    stored in a table. Therefore, only one clustered index is allowed per table. It
    greatly increases the speed of retrieval when data is retrieved in a sequential
    manner, either in the same order or in reverse order. A clustered index also provides
    better performance when a range of items are selected. A primary key is defined
    as a clustered index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-clustered index**: A non-clustered index doesn''t define the order in
    which data is physically stored. This means a non-clustered index is stored in
    one place, and data is stored in another place. Therefore, more than one non-clustered
    index is allowed per table. It refers to non-primary keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we know, the primary key represents the column, or set of columns, which
    is most widely used for fetching records from the table. The primary key has an
    index associated with it and is used for fast query performance. It provides comparatively
    faster performance because a primary key does not allow a `NULL` value, so no
    check is required on `NULL` values. It is recommended that if your table does
    not have a column or set of columns to define as a primary key, then you define
    one auto increment field as the primary key for better performance. On the other
    hand, if your table contains many columns and there is a need to execute a query
    with a combination of multiple columns, then it is advisable to the less frequently
    used data and transfer in onto a separate table. Relate all the separate tables
    with primary and foreign key references, which will help you in managing data,
    and query retrieval provides you good performance.
  prefs: []
  type: TYPE_NORMAL
- en: Uses of indexes in MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Indexes are mainly used to find a row of specific values without iterating
    a complete table. If an index is not define,d then MySQL 8 will start searching
    from the first row and then read the entire table, which makes for a costly operation.
    MySQL 8 uses indexes for the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: To sort or group tables when it is done on the left-most prefix of an index.
    This means that if all keys are defined for the `DESC` clause, then the keys will
    be considered in reverse order, and if all keys are followed by `ASC`, then the
    keys will be considered in forward order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find rows whose values match with the `WHERE` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of multiple column indexes, any left-most prefix of the index can
    be used to find the row. This topic is covered in the later part of this chapter
    with a detailed example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a case where MySQL has to choose one index from multiple options,
    then it will choose the index which has the smallest set of rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, the query is optimized to get the values without referring to rows.
    For example, if the query uses only columns that are included in indexes, MySQL
    8 will get the selected value from the index tree:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At the time of performing the join, MySQL 8 will use the index in a more efficient
    way, if columns are declared with the same type and size. For example, `VARCHAR
    (15)` and `CHAR(15)` will be considered as the same, but `VARCHAR(10)` and `CHAR(15)`
    will not be considered as the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of `MIN ()` and `MAX ()` functions, if you have used part of the
    index columns, then the optimizer will check whether all the other parts of the
    index columns are available in the `WHERE` condition. If they are mentioned, then
    MySQL 8 will perform a single lookup for the `MIN ()` and `MAX ()` functions and
    replace them with constants. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: SQL commands related to indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 provides two main commands related to indexes. We will discuss these
    commands in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an INDEX command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command enables the user to add indexes into an existing table.
    This command is also used with `CREATE TABLE` and `ALTER TABLE` to create indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `col_name(length)` syntax, the user is able to specify an index prefix
    length, which will consider only a specified number of characters from the string
    value. At the time of defining, the prefix considers the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The prefix is optional for `CHAR`, `VARCHAR`, `BINARY`, and `VARBINARY` column
    indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prefix must be specified in the case of `BLOB `and `TEXT `column indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL 8 will consider prefixes as a number of characters for non-binary string
    types (`CHAR`, `VARCHAR`, `TEXT`) and a number of bytes for binary types (`BINARY`, `VARBINARY`, `BLOB`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prefix is not allowed for the spatial columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A detailed example of the prefix option is described later in this chapter,
    under the *Column indexes* section. A `UNIQUE` index is a constraint which indicates
    that all the values in the index will be unique. If you try to add values which
    already exist, then MySQL 8 displays an error. All types of storage engines with
    a `UNIQUE` index permit multiple null values. In the case of prefixes when you
    use `NULL` values, make sure column values are unique within the prefixes. If
    an index prefix exceeds its size, then MySQL 8 will handle the index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For a non-unique index**: If the strict SQL mode is enabled, then MySQL 8
    will throw an error, and if the strict mode is disabled, then the index length
    is reduced to the maximum column data type size and will produce a warning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For a unique index**: In this case, MySQL 8 produces an error regardless
    of the SQL mode, because it might break the uniqueness of the column. This means
    you have defined a column with 25 length and tried to define an index on the same
    column with a prefix length 27; then MySQL 8 throws an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spatial index characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL 8 follows the following rules for spatial index characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: It is only available for `InnoDB` and `MyISAM` storage engines; if you try to
    use it for other storage engines, then MySQL 8 gives an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `NULL` value is not allowed for indexed columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prefix attribute is not allowed for this column. Full width will be considered
    for the index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-spatial index characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL 8 follows the following rules for non-spatial index characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: A `NULL` value is allowed for an indexed column in the case of `InnoDB`, `MyISAM`,
    and `MEMORY` storage engines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The column prefix length must be specified in the case of each spatial column,
    if it exists under a non-spatial index. The prefix length will be considered in
    terms of bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for `ARCHIVE`, it is supported for all the storage engines which support
    spatial columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `NULL` value is allowed for this index, unless it is defined as a `PRIMARY`
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an `InnoDB` table, run the `ANALYZE TABLE` statement after creating an index
    on that table, if the `innodb_stats_persistent` setting is enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index type will depend on the storage engine; currently, B-Tree is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-spatial index is allowed on a `BLOB` or `TEXT` column only if it is defined
    using `InnoDB` and `MyISAM` tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default value of the `index_col_name` attribute is in ascending order,
    and neither an `ASC` nor `DESC` value is permitted for `HASH` indexes with this
    attribute. MySQL 8 provides any of the following values with the `index_option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KEY_BLOCK_SIZE [=]` value: This parameter defines the size of the index key
    block in bytes. It is an optional parameter and its value is treated as a hint.
    MySQL 8 may use a different size if it is required. If this parameter is defined
    at the individual index level, then it overrides the table-level `KEY_BLOCK_SIZE` value.
    The `InnoDB` engine doesn''t support this parameter at the index level; it allows
    it at the table level only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_type`: MySQL 8 permits the user to define the index type at the time
    of index creation. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following table to find the permissible index types related to
    the storage engine. Consider the first index type as the default type in cases
    where multiple types are defined. If any storage engine is not mentioned in this
    table, it means that the index type is not supported by that engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Storage Engine** | **Permissible Index Types** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `InnoDB` | `BTREE` |'
  prefs: []
  type: TYPE_TB
- en: '| `MyISAM` | `BTREE` |'
  prefs: []
  type: TYPE_TB
- en: '| `MEMORY`/`HEAP` | `HASH`, `BTREE` |'
  prefs: []
  type: TYPE_TB
- en: '| `NDB` | `HASH`, `BTREE` |'
  prefs: []
  type: TYPE_TB
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/create-index.html](https://dev.mysql.com/doc/refman/8.0/en/create-index.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to define an index type which is not supported by the storage engine,
    then MySQL 8 will consider it as a supported index type, without affecting the
    query result. Refer to the following table to learn more about the characteristics
    of indexes, based on storage types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Storage Engine** | **Index Type** | **Index Class** | **Stores NULL Values**
    | **Permits Multiple NULL Values** | **IS NULL Scan Type** | **IS NOT NULL Scan
    Type** |'
  prefs: []
  type: TYPE_TB
- en: '| `InnoDB` | `BTREE` | Primary key | No | No | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Unique | Yes | Yes | Index | Index |'
  prefs: []
  type: TYPE_TB
- en: '| Key | Yes | Yes | Index | Index |'
  prefs: []
  type: TYPE_TB
- en: '| Inapplicable | `FULLTEXT` | Yes | Yes | Table | Table |'
  prefs: []
  type: TYPE_TB
- en: '| Inapplicable | SPATIAL | No | No | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `MyISAM` | `BTREE` | Primary key | No | No | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Unique | Yes | Yes | Index | Index |'
  prefs: []
  type: TYPE_TB
- en: '| Key | Yes | Yes | Index | Index |'
  prefs: []
  type: TYPE_TB
- en: '| Inapplicable | `FULLTEXT` | Yes | Yes | Table | Table |'
  prefs: []
  type: TYPE_TB
- en: '| Inapplicable | SPATIAL | No | No | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `MEMORY` | `HASH` | Primary key | No | No | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Unique | Yes | Yes | Index | Index |'
  prefs: []
  type: TYPE_TB
- en: '| Key | Yes | Yes | Index | Index |'
  prefs: []
  type: TYPE_TB
- en: '| `BTREE` | Primary | No | No | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Unique | Yes | Yes | Index | Index |'
  prefs: []
  type: TYPE_TB
- en: '| Key | Yes | Yes | Index | Index |'
  prefs: []
  type: TYPE_TB
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/create-index.html](https://dev.mysql.com/doc/refman/8.0/en/create-index.html)
  prefs: []
  type: TYPE_NORMAL
- en: '`WITH PARSER parser_name`: This option is valid only for a `FULLTEXT` index
    which was supported by a `InnoDB` and `MyISAM` storage engine. If `FULLTEXT` index
    and searching operations require special handling, then MySQL 8 will use a parser
    plugin with the index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMENT ''string''`: This attribute is optional and allows up to 1024 characters
    in comments. This option also supports the `MERGE_THRESHOLD` parameter whose default
    value is 50\. Consider the following command to define the `MERGE_THRESHOLD`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the page-full percentage for an index is less than the `MERGE_THRESHOLD` value,
    then the `InnoDB` storage engine will merge the index page with a neighboring
    index page.
  prefs: []
  type: TYPE_NORMAL
- en: '`VISIBLE`, `INVISIBLE`: This parameter defines the index visibility. By default,
    all indexes are visible. The optimizer will not use an invisible index during
    the optimization process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ALGORITHM`and `LOCK` attributes will have an impact when you try to use
    the table for reading or writing, and while simultaneously modifying its indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Drop index command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command drops the index from the table. We can also map this
    statement with `ALTER TABLE` to drop the index from the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, only two options are available: the algorithm and the lock.
    Both of these options are useful in the case of concurrent access of index and
    work, similar to the `CREATE INDEX` command. For example, to drop the index of
    an employee table, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: SPATIAL index creation and optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL 8 allows you to create a spatial index on a `InnoDB` and `MyISAM` storage
    engine using the same syntax mentioned in the preceding topic. The only change
    in the standard command is to use the keyword **spatial** at the time of creating
    the index. When you define a spatial index, make sure that the column is declared
    as `NOT NULL`. The following code demonstrates the method to create a spatial
    index on table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The spatial index, by default, creates an R-Tree index. From MySQL 8.0.3 onwards,
    the optimizer checks the **spatial reference identifier** (**SRID**) attribute
    of the indexed column to find the **Spatial Reference System** (**SRS**) for comparisons
    and performs calculations according to SRS. For comparison, each column in a spatial
    index must be SRID-restricted. This means that each column definition must contain
    an SRID attribute, and all the column values must have the same SRID. The spatial
    index performs the following two actions based on the SRID:'
  prefs: []
  type: TYPE_NORMAL
- en: If the column is restricted to a **Cartesian SRID**, then it enables Cartesian
    bounding box computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the column is restricted to a **Geographic SRID**, then it enables geographic
    bounding box computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned above, MySQL 8 will ignore a `SPATIAL INDEX` on a column which
    does not have an SRID attribute, but MySQL still manages these indexes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: These types of indexes are updated when the table is modified with the `INSERT`,
    `UPDATE`, or `DELETE` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These indexes are considered in dump backups and are restored with backward
    compatibility. As mentioned in the previous point, spatial indexes with no SRID
    restricted columns are not used by the optimizer, so in that case, all these columns
    must be modified. To modify them, perform the following steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check all the values of the column that have the same `ST_SRID` with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the query returns multiple rows, then it indicates that the column contains
    mixed SRIDs. If so, change the contents of the column for the same SRID value.
  prefs: []
  type: TYPE_NORMAL
- en: Define an explicit SRID for the column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recreate the `SPATIAL INDEX`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: InnoDB and MyISAM index statistics collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL 8 will consider table statistics based on the value group, which is nothing
    but a set of rows with the same prefix values. The storage engine collects statistics
    related to the table, which are used by the optimizer. From the optimization perspective, average
    value group size is an important statistic. If the average value of the group
    size increases, then the index is not meaningful. So, it''s better to target a
    small number of rows for each index. This can be achieved by table cardinality,
    which is nothing but a number of value group. For `InnoDB` and `MyISAM` tables,
    MySQL 8 provides control on statistics by the `myisam_stats_method` and the `innodb_stats_method`
    system variables. The following are the possible values for these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nulls_ignored`: It indicates that `NULL` values are ignored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nulls_equal`: It indicates all `NULL` values are identical'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nulls_unequal`: It indicates all `NULL` values are not identical'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `innodb_stats_method` system variable has a global value, while the `myisam_stats_method` system
    variable has both global and session values. When we set a global value of a variable,
    it will affect statistics collection for tables from the corresponding storage
    engine. In the case of session value statistics, collection is available only
    for the current client connection. This means that you have to regenerate a table''s
    statistics for the other client on the same table without affecting other clients,
    and need to set it in a session value. To regenerate `MyISAM` statistics, use
    either of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the `myisamchk --stats_method=method_name --analyze` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make changes to the table to make its statistics out of date, and then set `myisam_stats_method` and
    issue an `ANALYZE TABLE` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some points that must be considered before using these two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: These variables are available only for `InnoDB` and `MyISAM` tables. For other
    storage engines, only one method is available to collect table statistics, and
    it is very near to the `nulls_equal` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL 8 provides a way to generate statistics for a table explicitly, but this
    is not always the case. Sometimes, MySQL 8 may also generate statistics automatically,
    if it is required. For example, in the case of any operations, if some of the
    SQL statements modified table data, then MySQL 8 will automatically collect statistics.
    Consider bulk insert or delete operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot say which method was used to generate statistics for a table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Column-level indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 allows you to create an index on a single column, as well as on multiple
    columns. The maximum number of indexes per table and maximum index length depend
    on the storage engine. Mostly, all the storage engines allow at least 16 indexes
    per table and total index lengths of at least 256 bytes, but most of the storage
    engines permit higher limits.
  prefs: []
  type: TYPE_NORMAL
- en: Column indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most common way to define an index where only a single column is
    involved. MySQL 8 stores a copy of column values in a data structure so that rows
    can be accessed quickly. MySQL 8 uses a **B-Tree** data structure to enable values to
    be accessed quickly. The B-Tree execution will work based on operators, such as
    `=`, `<`, `>`, `BETWEEN`, `IN`, and many more, which were defined in the `where`
    condition. You can get details on the B-Tree data structure and its execution
    in the next topic. We will discuss the characters of column indexes in the coming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Index prefixes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This option allows the user to specify the number of characters for indexing
    in the case of a string. MySQL 8 has provided the option `column_name(N)`, in
    index creation to specify a number of characters. Indexing prefers only specified
    characters, which will make the index file smaller. So, at the time of the `BLOB`
    and `TEXT` column, you must specify the prefix length for better performance.
    Consider the following example to create indexes with prefix lengths on the `BLOB`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command creates an index on the `personal_data` column by considering the
    first eight characters. The prefix length varies, based on the storage engine.
    The `InnoDB` storage engine allows up to a 767 byte prefix length for `REDUNDANT` or `COMPACT` row
    formats, while in the case of `DYNAMIC` or `COMPRESSED` row formats, it allows
    up to 3072 bytes. In the case of the `MyISAM` storage engine, the prefix can be
    defined for up to 1,000 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Prefix length will be measured in bytes for binary string types, such as `BINARY`, `VARBINARY`,
    and `BLOB`, while in the case of non-binary string types, it will be considered
    as a number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: FULLTEXT indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name implies, `FULLTEXT` indexes allow `CHAR`, `VARCHAR`, and `TEXT` columns
    only. This index is supported by `InnoDB` and `MyISAM` storage engines. In this
    type, indexing will take place on an entire column, rather than a prefix length.
    MySQL 8 evaluates the full text expression during the optimization phase of the
    query execution. Before making estimations, optimization evaluates the full text
    expression in the process of developing an execution plan. As a result, the `EXPLAIN`
    query of full text is slower than non-full text queries. Full text queries are
    useful in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When a `FULLTEXT` query returns either a document ID or a document ID and search
    rank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a `FULLTEXT` query sorts the matching rows by descending order and uses
    a `LIMIT` clause to fetch *N* number of rows, apply only a single `ORDER BY` clause
    in descending order, and don't use a `WHERE` clause in it for optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a `FULLTEXT` query fetches a `COUNT(*)` value from the rows without any
    additional `WHERE` clauses, apply the `WHERE` clause as `WHERE MATCH(text)` `AGAINST
    ('other_text')`, without any `>` 0 comparison operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spatial Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 allows you to create indexes on spatial data types. The `InnoDB` and
    `MyISAM` storage engines support R-Tree for spatial data, while other storage
    engines use B-Tree. Since MySQL 5.7, spatial indexes are supported in `MyISAM`
    and `InnoDB` database engines.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes in the MEMORY storage engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory storage engines support both `HASH` indexes and B-Tree indexes, but `HASH`
    indexes are, by default, set for the `MEMORY` storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple-column indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL 8 allows you to use multiple columns in a single index creation, which
    is also known as a **composite index**. It permits up to 16 columns in a composite
    index. At the time of composite index use, make sure you follow the same order
    of columns which was mentioned during index creation. A multiple-column index
    contains values generated by concatenating the values of indexed columns. Consider
    the following example in order to understand multiple-column indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As described above, we have defined composite indexes using two columns, `lastname`
    and `firstname`. The following queries use the name index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In all the preceding queries, we can see that the orders of columns are maintained
    in the `WHERE` condition, similar to that of index declaration. Indexes can also
    work when we define only the `lastname` column in the `WHERE` clause, because
    it is the left-most column defined in the index. Now, there are some queries in
    which composite indexes will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Remember, in the case of a multiple-column index, any left-most prefix of the
    index can be used by the optimizer for searching rows. For example, if the index
    was defined on three columns in sequence, `column1`, `column2`, and `column3`,
    then you can use indexed capabilities on (`column1`, `column2`, `column3`), (`column1`),
    (`column1`, `column2`), by defining it in the `WHERE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: B-Tree index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main purpose of the B-Tree index is to reduce the number of physical read
    operations. A B-Tree index is created by sorting the data on the search key and
    maintaining a hierarchical search data structure, which helps to search for the
    correct page of data entries. `InnoDB` and `MyISAM` storage engines, by default,
    use the B-Tree index. B-Tree manages to keep an equal distance from all the leaf
    nodes to the root node. This index speeds up data access because there is no need
    to scan the whole data to get the desired output. Instead, it starts with the
    root node. The root node holds a pointer of child nodes, and the storage engine
    follows these pointers to find the next path. It finds the right path by considering
    values in the node page. The node page defines the upper and lower bounds of values
    in the child nodes. At the end of the search process, the storage engine either
    successfully reaches a leaf page, or concludes that there is no value associated
    with the search. Remember, the leaf pages point to the indexed data, and not to
    other pages. Now, let''s refer to one diagram to understand B-Tree indexes in
    more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea97c77d-fd74-4e49-ae58-5b66ce5342b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As discussed previously, when the query is executed against an index column,
    the MySQL 8 query engine starts from the root node, and through the intermediate
    nodes, it will reach a leaf node. Let''s take an example where you want to find
    the value 89 in an indexed column. In this case, the query engine refers to the
    root node to get the intermediate page reference. So, it will point to **1-100**.
    After that, it determines the next intermediate level, and points to the values
    **51-100**. Then the query engine goes to the third page, which is the next intermediate
    level, **76-100**. From there, it will find the leaf node for the value 89\. The
    leaf node contains either an entire row or a pointer to that row, depending on
    whether the index is clustered or non-clustered. Now, let''s understand how a
    B-Tree index works on a select query by considering the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the table definition index will contains values in combination of three
    columns `firstname`, `lastname`, and `dob`. It will sort values as per the order
    given previously; this means that if some employees have similar names, then they
    will be sorted by their birth dates. Consider the following types of queries which
    will benefit from the B-Tree index:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Match the range of values**: Finds the employees whose last names are Patel
    and Gupta.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Match the full values**: Finds employee whose name is Mohan Patel and was
    born on 28/11/1981.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Match leftmost prefix**: Finds all employee with a last name. These use only
    the first column in the index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Match with column prefix**: Finds the employees whose last names begin with
    M. It uses only the first column in the index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Match one part exactly and with range of another column**: Finds the employee
    whose last name is Patel and whose first name starts with A.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are queries where B-Tree is not useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t use any condition after a range condition**: For example, you have
    put the `WHERE` condition `lastname=''Patel''` and `firstname` like `‘A%''` and
    `dob='' 28/11/1981''`. Here, only the first two columns are considered for the
    index, because `LIKE` is a range condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t skip any of the columns defined in the index**: This means you are
    not allowed to use `lastname` and `dob` to find an employee where `firstname`
    is missing in the `WHERE` condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lookup doesn''t start with left-most side of indexed columns**: For example,
    the index will not work if you find the employee whose `firstname` is `Mohan`
    and whose `dob` is on a certain date. In this query, defined columns are not left-most
    in the index. In the same way, the index does not work in the case where you find
    the employee whose `lastname` ends with something.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is very difficult to find a single value from a large database by following
    complete tree traversals with multiple levels. To overcome this problem, MySQL
    has provided another index type, which is known as a **hash index**. This index
    creates a hash table rather than a tree, which is very flat in structure compared
    to a B-Tree index. Hashing mainly uses hash functions to generate the addresses
    of data. Two important terms related to hashing are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash function**: The mapping function which will be useful to map search-keys
    with the address where actual records are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bucket**: A bucket is a unit of storage where a hash index stores the data.
    A bucket indicates a complete disk block, which will store one or more records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along with the hashing mechanism, a hash index has some special characteristics,
    described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The whole key is used to search the row. While in the case of a B-Tree, only
    the left-most prefix of the key is used to find rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimizer will not use a hash index to speed up `ORDER BY` operations. In
    other words, this index is never used to find the next entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash indexes are used for equality comparison by using `=` or `<=>` operators.
    It will never use comparison operators which will return a range of values. For
    example, the `<` (less than) operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range optimizer cannot actually gauge how many rows are available between
    the two values. And, if we use a hash-indexed `MEMORY` table instead of `InnoDB`
    or `MyISAM`, then it may affect the queries as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Index extension is the feature by which MySQL 8 extends a secondary index by
    appending the primary key. The `InnoDB` engine automatically extends a secondary
    index if it is required. To control the behavior of index extensions, MySQL 8
    has defined a `use_index_extensions` flag in the `optimizer_switch` system variable.
    By default, this option is enabled, but the user is allowed to change it at runtime
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at one example to understand the index extension in detail. Let''s
    create a table and insert the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This table has a primary key on columns `c1`, `c2` and a secondary index `key_d1`
    on column `d1`. Now, to understand the extension effect, first make it off and
    then execute following select query with explain command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we will now turn the extension on and execute the explain
    plan query again to check the effect, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will check the difference between these two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: The `key_len` value changes from 4 bytes to 8 bytes, which indicates that key
    lookups use both the columns d1 and c1, not only d1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ref` value changes from `(const)` to `(const, const)` which indicates key
    lookup uses two key parts instead of one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rows` count changes from 5 to 1, which indicates that `InnoDB` requires
    fewer rows than the first approach to produce the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Extra` value changes from **Using where** to **Using index**. It indicates
    that the rows can be read by using only the index, without consulting any other
    columns in the data row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an optimizer for indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL 8 allows you to create indexes on generated columns. Generated columns
    are the columns whose values are computed from an expression included in a column
    definition. Consider the following example where we have defined one generated
    column, `c2`, and created an index on that column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the previous definition of a table, an optimizer will consider an
    index of a generated column in the execution plan. In addition to that, if we
    specify the same expression in the query using the `WHERE`, `GROUP BY`, or `ORDER
    BY` clauses, then the optimizer will use the index of the generated column. For
    example, if we execute the following query, then the optimizer will use the index
    defined on the generated column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the optimizer will identify that the expression is the same as the definition
    of column `c2`. We can check it using the `EXPLAIN` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some limitations on generated column indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: The query expression must be exactly matched with the generated column definition.
    For example, if we have defined the expression as `c1+1` in a column definition,
    then use the same in query, instead of applying `1+c1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of JSON string use in a generated column definition, use `JSON_UNQUOTE()`
    to remove extra quotes from the values. For example, don''t use the following
    column definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the preceding code, we will use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The optimization applies to these operators: `=`, `<`, `<=`, `>`, `>=`, `BETWEEN`,
    and `IN()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don''t use only references of other columns in generated column expressions.
    That is, don''t use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Use a index hint if the optimizer tries to use the wrong index, which will disabled
    it and force the optimizer to use a different choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invisible and descending indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **invisible index** is a special feature which will mark an index as unavailable
    for the optimizer. MySQL 8 will maintain invisible indexes and keep them up-to-date
    when data is modified. This will apply on indexes other than primary key. As we
    know, indexes are visible by default; we have to make them invisible explicitly
    at the time of creation, or by using the `alter` command. MySQL 8 provides the `VISIBLE` and `INVISIBLE`
    keywords to maintain index visibility. A descending index is the method of storing
    key values in descending order. A descending index is more efficient, as it can
    be scanned in the forward order. Let's see these indexes in detail, with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Invisible index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mention previously, an invisible index is not used by the optimizer. Then
    what is the use of this index? This question comes into our mind, right? We will
    explain to you some of the use cases for invisible indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: When many indexes are defined, but you are not sure which index is not in use.
    In this case, you can make an index invisible and check the performance impact.
    If it has an impact, then you can make that index visible on an immediate basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special cases where only one query is using an index. In this case, an invisible
    index is a good solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we will create an invisible index using `CREATE TABLE`, `CREATE
    INDEX`, or `ALTER TABLE` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the visibility of the indexes, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To get information about an index, execute `INFORMATION_SCHEMA.STATISTICStable`
    or `SHOW INDEX` commands in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'MySQL 8 provides a `use_invisible_indexes` flag in the `optimizer_switch` system
    variable to control invisible indexes used by the query optimizer. If this flag
    is on, then the optimizer uses invisible indexes in execution plan construction,
    while if the flag is off, the optimizer ignores invisible indexes. MySQL 8 provides
    a facility to use an implicit primary key if you have defined a `UNIQUE` index
    on a `NOT NULL` column. Once you define the index on this field, MySQL 8 does
    not allow you to make it invisible. In order to understand this scenario, let''s
    take one example with the following table. Let''s try to execute the following
    command to make the `idx1` index invisible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will now give an error, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the primary key into the table, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will try to make the `idex1` invisible. This time, the server allows
    it, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Descending index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A descending index is an index which stores key values in descending order.
    This index is scanned in the forward order, which gives better performance compared
    to other indexes. Descending indexes allow a user to define multi-column indexes
    in a combination of ascending and descending orders. Practical knowledge is always
    easier to understand than theoretical knowledge, right? So, let''s take a look
    at some examples to understand the descending index in detail. First, create a
    table with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the table definition, MySQL 8 will create four different indexes, and
    as a result, the optimizer performs a forward index scan for each `ORDER BY` clause.
    Consider the following different version of the `ORDER BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at a second scenario for the same table definition,
    which will describe the performance impact of a descending index compared to the
    MySQL 5.7.14 version. Consider the following select queries to measure performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following statistical graph is provided by MySQL 8 on 10 million rows,
    with respect to the previously mentioned queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/436dd2cc-a878-4a84-88b5-fe96a60311e9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reference:[ https://mysqlserverteam.com/mysql-8-0-labs-descending-indexes-in-mysql/](https://mysqlserverteam.com/mysql-8-0-labs-descending-indexes-in-mysql/)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some important points that you should remember at the time of using
    descending indexes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All the data types supported by ascending indexes are also supported by descending
    indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descending indexes are supported for `BTREE` but not for `HASH`, `FULLTEXT`,
    and `SPATIAL` indexes. If you try to use `ASC` and `DESC` keywords explicitly
    for `HASH`, `FULLTEXT`, and `SPATIAL` indexes, then MySQL 8 will generate an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descending indexes only support `InnoDB` storage engines, but the `InnoDB` SQL
    parser does not use descending indexes. Change buffering is not supported for
    secondary indexes if the primary key includes a descending index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISTINCT` can use any index, including a descending key, but for `MIN ()`/`MAX
    ()`, no descending key parts are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both non-generated and generated columns allow use of descending indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything becomes very interesting when you are aware of how it works, right?
    We hope you have found the same thing about indexing in this chapter. We have
    covered very useful information which will help you to define indexes on the right
    columns to get better performance. In addition to that, we have also described
    various types of indexing with their storage structures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will provide you with information about replication.
    We will explain the configuration and implementation of replication in detail.
  prefs: []
  type: TYPE_NORMAL
