- en: Interacting with Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned about the web application security process
    and why it is important to test application security. In this chapter, we''ll
    take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP protocol basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of an HTTP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with a web app using the requests library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing HTTP responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP protocol basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about the HTTP protocol, how it works, and the
    security aspects of it and which methods are supported when performing a request.
  prefs: []
  type: TYPE_NORMAL
- en: This will provide you with the basic knowledge of HTTP, which is important to
    understand how to build tools and test for security issues in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: What is HTTP and how it works?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP was designed to enable communication between clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a TCP/IP-based communication protocol operating in the application layer.
    Normally, we use a web browser to interact with web applications but in this training,
    we will leave the browser behind and use Python to talk with web applications.
    This protocol is media independent.
  prefs: []
  type: TYPE_NORMAL
- en: This means that any type of data can be sent via HTTP as long as the client
    and server know how to handle the data content. And it is stateless, which means
    that the HTTP server and the clients are aware of each other during the request
    to transaction only. Due to this characteristic, neither the client or the server
    retain information between requests, which will later be helpful when you perform
    some attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP protocol is available in two different versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP/1.0**: This uses a new connection for each request/response transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP/1.1**: This is where the connection can be used by one or more request
    response transactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP is not a secure protocol, which means that all communication is clear text,
    which is susceptible to interception and tampering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, HTTP is being served on port `80`. The following is an example of
    what a simple transaction looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On the left, we have the client, which sends an HTTP `GET` request to the server
    asking for the resource `test.html`. The server returns an HTTP response with
    a `200 OK` code, some header, and the content `test.html` if it exists on the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: If it does not exist, it will return a `404 Not Found` response code. This represents
    the most basic `GET` request in the web application world.
  prefs: []
  type: TYPE_NORMAL
- en: In 1994, HTTPS was introduced to add security on top of HTTP. HTTPS is not a
    protocol itself, but the result of layering HTTP on top of **Secure Socket Layer**
    (**SSL**) or **Transport Layer Security** (**TLS**).
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS creates a secure channel over an insecure network. This ensures reasonable
    protection from eavesdroppers and man-in-the-middle attacks provided that adequate
    cipher suites are used and that the service certificate is verified and trusted.
    So, whenever the application handles sensitive information, such as banking payments,
    shopping websites, login pages, and profile pages, it should use HTTPS. Basically,
    if we handle processes or store customer data, it should use HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTTP, methods indicate the desired action to be performed on the chosen
    resource, also known as HTTP verbs. HTTP/1.0 defines three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HEAD`: This will only return the headers and the status code without its content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: This is the standard method used to retrieve resource content given
    a URI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This is a method used to submit content to the server, form data, files,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, HTTP/1.1 introduced the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OPTIONS`: This provides the communication options for the target resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This requests to store a resource identified by the given URI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This removes all representations of the target resource identified
    by the given URI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRACE`: This method echoes the received request so that the client can see
    what changes or editions have been made by intermediate servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONNECT`: This establishes a tunnel to the server identified by a given URI
    used by HTTPS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: This method applies partial modifications to a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`, `GET`, `OPTIONS`, and `TRACE` are by convention defined as safe, which
    means they are intended only for information retrieval and should not change the
    state of the server.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, methods such as `POST`, `PUT`, `DELETE`, and `PATCH` are
    intended for actions that may cause side effects either on the server or external
    side effects. There are more methods than these. I encourage you to explore them.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that HTTP is a client server protocol, which is stateless.
  prefs: []
  type: TYPE_NORMAL
- en: This protocol doesn't provide any security and hence HTTPS was created to add
    a secure layer on top of HTTP. We also learned that there are some different methods
    that will instruct the server to perform different actions on the chosen resources.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an HTTP request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take a look at the structure of a URL, the request and
    response headers, and an example of `GET` requests using Telnet to understand
    how it works at a low level.
  prefs: []
  type: TYPE_NORMAL
- en: 'I bet you have seen thousands of URLs by now. It''s now time to stop and think
    about the URL structure. Let''s see what each part means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first part is the protocol in web applications. The two protocols used are
    HTTP and HTTPS. When using HTTP, the port that will be used is `80`, and when
    using HTTPS, the port will be `443`.
  prefs: []
  type: TYPE_NORMAL
- en: The next part is the host we want to contact. Next, we can see the resource
    or the file location in that server. In this example, the directory is `content`
    and the resource is `section`. Then, we have the question mark symbol that indicates
    what's to come is the query string. These are the parameters that will be passed
    to the section of the page for processing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: There are some alternatives such as adding username and password for authentication
    before the host, or explicitly defining the port for cases where the web server
    is not listening in the standard `80` or `443` ports.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's talk about headers. Headers are a core part of HTTP requests and
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'They describe how the client and the server talk to each other and also provide
    information about the transaction. We have client-side headers, which are sent
    by the browser. Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-agent**: This informs the server what type of OS, browser, and plugins
    the users have.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accept-encoding**: This defines which encoding the browser supports, which
    is usually GZip or Deflate. This will compress the content and reduce the bandwidth
    time for every transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Referer**: This contains the referer URL, basically from which page you clicked
    that link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie**: If our browser has cookies for its site, it will add them in the
    Cookie header. We also have server-side headers, which are set by the web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache-Control**: This defines the directives, which must be obeyed by all
    caching mechanisms along the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location**: This is used for re-directions. Whenever there is a `301` or
    `302` response, the server must send this header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set-Cookie**: This is a header used to set a cookie in the user''s browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WWW-Authenticate**: This header is used by the server to request authentication.
    When the browser sees this header, it will open a login window asking for the
    username and password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of what a response header looks like when making a `GET`
    request to [https://www.packtpub.com/](https://www.packtpub.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have mentioned some of them here such as `cache-control`, `content-encoding`,
    and `content-type`. I suggest you get familiar with all of them. Every time you
    find a new header, read about it to learn its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: GET request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reviewing the URL structure and the headers, let's try a `GET` request
    on a real server.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, I will use the Terminal and `telnet` command to send a raw
    `GET` request to the server. This is our attempt at simulating a browser by typing
    in the Telnet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to our VM and open up the Terminal and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`80` is the port we want Telnet to connect to. `httpbin.org` is a website that
    provides an HTTP request and response service that is useful to test tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we connect, we will see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This means the connection is established.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s type `GET /ip HTTP/1.0` and hit *Enter* twice. This is us telling
    the server that we are using `GET` to request the resource called `/ip`. Then,
    we specify the `HTTP/1.0` protocol followed by pressing *Enter* twice. As a result,
    we get our first response from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we haven't used any headers at all in the request, but we received
    many headers from the server, plus the content of the resource IP.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the content is the IP address of the machine making the request.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take another example, but this time requesting a URL that has a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Terminal and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we used `GET`, but this time we are requesting the resource redirect
    to with the parameter URL in the query string with the value [http://www.bing.com](http://www.bing.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the server basically redirects the browser to the URL provided,
    using the location header and returning a `302` redirection code. In this case,
    nothing happens, as Telnet doesn't interpret that header. Remember, this is a
    rule connection.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with a web app using the requests library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll start to write Python code to perform HTTP requests using
    the requests library.
  prefs: []
  type: TYPE_NORMAL
- en: Requests library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requests is an Apache 2 licensed HTTP library written in Python. It was created
    to reduce the complexity and work needed when using `urllib2` and other HTTP libraries
    available at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of the code needed to perform a request to `api.github.com`
    using authentication when using the `urllib2` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same function but using the `requests` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The simplicity is pretty evident. It really facilitates our job when coding
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Our first script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start programming in Python. In this first example, we''ll perform a
    `GET` request using Python and the `requests` library:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's open the Atom editor in the Virtual Machine and create a new file by navigating
    to File | New File.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll import the `requests` library to start with. This can be done by typing
    `import requests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to create a variable R, where we''ll instantiate a requests object
    with the `GET` method, and the target URL in this case is `httpbin.org/ip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we print the content of the response using `print r.text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file in the `/Examples/Section-2` folder as `Chapter-3.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run it on the Terminal. Open the Terminal and change the directory to
    `/Example/Section-2` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the response body, where we can once again see my IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that `/ip` returns the caller IP in the body.
  prefs: []
  type: TYPE_NORMAL
- en: That was our first script using the `requests` library. Congratulations, you
    are communicating with the web application using Python!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a query string in the `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, we'll add a variable called **payload** with a dictionary,
    where each key is the parameter name and the value will be the value of that parameter.
    In this case, the parameter is the URL and the value will be `http://www.edge-security.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll change the resource to `/redirect-to` instead of IP. This resource
    is expecting the parameter URL with a valid URL, which will redirect us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also need to add the payload as a value for `params` in the request, `params=payload`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then, we'll save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if we run the script, we will see the content of the redirected page in
    the `python Chapter-3.py` Terminal. There you go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we have all the content of `www.edge-security.com` in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: That is how we add parameters to the query string.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to see the return code from the server? We need to add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's print some title by typing `print "Status code:"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we can print some formatting using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can remove `print r.text` to obtain a cleaner response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll save it and run it in the Terminal with Python and the name of the script.
    We can see the status `200` as a result, which means the request was valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We'll now see how to get access to the headers of the response.
  prefs: []
  type: TYPE_NORMAL
- en: We'll go back to the editor in the virtual machine and open the file `Video-3-headers.py`,
    which is ready to save some typing. This script is using the resource/IP again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to access the response headers, we use the method headers of the request
    object.
  prefs: []
  type: TYPE_NORMAL
- en: In order to print them line by line, we can do a loop and unpack the key and
    values from `r.headers:`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try and run this in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll use Python and the script filename. You can see the different headers
    returned by the server plus the response code and the response body content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What if we want to request only the headers to save bandwidth and accelerate
    the reg response transaction times? We go back to the editor and we change the
    `get` method by the `head` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We save the script, then move to the console and run it. We can see that the
    status code is `200` and we''re getting back the headers, but we don''t have the
    response body content anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is because the method used is `head` and we only get the headers from the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll see how to set the headers of the request.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we want to do that? Because we may need to add custom headers that
    are expected by the application. We want to fake our user agent to trick the server
    into thinking that we are a mobile device. We may want to change the `post` header
    to trick the server or load balances, or we may want to brute force or tamper
    with a header value and see how the application handles it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to set a header:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script in the editor. We''ll modify the request, changing the
    method back to `get` and the resource from `ip` to `headers`. This will make `http://bin.org` send
    us back the climb headers it received in the body of the response for debugging
    purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Save it and then run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see that the user agent, the `requests` library, sends `python-requests` with
    every request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the editor and set the `user-agent` header to a random
    test value. We need to add a dictionary called `myheaders` with a key name, user
    agent, and the test value `Iphone 6`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the request, a parameter called headers with the value
    `myheaders`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's run it again in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see that the server received our modified user agent faking an `Iphone
    6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, you know how to manipulate headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we saw a `get` and a `head` request, let''s take a look at a `post`
    request, where we''ll send the form parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the Atom editor and replace the `get` method with the `post`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll also change the URL. This time, we'll use the post resource `http://bin.org/post` and
    add the data dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is typically the form data you see in a web application. In this case,
    we add one parameter in a data dictionary with a key code name and the value `packt`.
    We save it and then run the script in the console. Perfect; we can see in the
    results that we have the dictionary form with the values we have submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you now know how to perform different HTTP requests using Python!
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing HTTP responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the different HTTP response status codes
    and different classes of HTTP response codes.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we'll write examples to see successful responses or errors, and finally,
    we'll see a redirection example.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTTP protocol defines five classes of response codes to indicate the status
    of a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1XX-Informational**: The 100 range codes are used for informational purposes.
    It is only present in HTTP/1.1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2XX-Success**: The 200 range of codes are used to indicate that the action
    requested by the client was received, understood, accepted, and processed. The
    most common is `200 OK`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3XX-Redirection**: The 300 range indicates the client that must take additional
    actions to complete the request. Most of these codes are used in URL redirection.
    The most common of this group is the `302 Found` code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4XX-Client-side error**: The 400 range are used to indicate that the client
    has had an error. The most common is `404 Not Found`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5XX-Server-side error**: The range 500 is used to indicate an error on the
    server side. The most common is `500 Internal Server Error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We suggest you learn the different codes in each group here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code. Let''s open our editor in the virtual machine and create
    a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the `requests` library by typing `import requests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create a variable for our target URL. We''ll use `httpbin.org` again
    and type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll print the response code with `req.status _code`. We do this by
    entering the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the response code for the `req.status_code` string. This can be done
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We'll save the file in `/Example/Section-2` as `Video-4.py` and switch
    to the Terminal to run the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `python Video-4.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see a `200` status code in the response, which means that our request
    was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Well done, let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change the target URL to something that does not exist. In order
    to see an error code, we''ll change the URL and write `fail`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's save it and run this script in the Terminal again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, when we run the server, it will return a `404` status code, which means
    that the resource was not found on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, now we know that we can ask the server for a list of directories and files
    and find which ones exist and which ones do not. Interesting, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we deal with redirections. We''ll use an example page that
    will take a parameter URL and redirect us to that defined URL:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to our script and modify it in order to get a new directory called
    `payload`, which will contain the URL where we want to be redirected to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll use `payload=''url''` to be redirected to `www.bing.com`. We can do
    this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll use this, the resource redirect-to and add the `params` parameter
    and set it to the `payload`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we''ll print the content with `print req.text`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We'll save it and run it again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What do we get now? A `200` code and the content of [https://www.bing.com/](https://www.bing.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The code should be `302`, right? We need to access the history of the request
    to see the redirects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add `print r.history`. The history is a list of all the responses in the
    redirection chain. We will print the URL and the response code for each URL with
    this loop to our script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For `x in req.history`, print this status code concatenated with the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Save it and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can see that before the `200`, there was a `302` redirection code sending
    our browser to [www.bing.com](http://www.bing.com).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a brief introduction to HTTP, and we saw a basic `GET`
    request example. We also saw the different HTTP methods available that we can
    use to interact with web applications.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about HTTP requests. We learned how to interact with a web application
    using Python and the `requests` library. We further learned about the HTTP request
    anatomy and the different HTTP methods and response code.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0042.html#181NK0-5a228e2885234f4ba832bb786a6d0c80), *Web
    Crawling with Scrapy - Mapping the Application*, we'll learn how to write a Web
    Crawler, use Spider using Python, and how to use the Scrappy library.
  prefs: []
  type: TYPE_NORMAL
