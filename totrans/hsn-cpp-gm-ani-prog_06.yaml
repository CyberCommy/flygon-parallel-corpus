- en: '*Chapter 6*: Building an Abstract Renderer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book focuses on animation, not rendering. However, rendering an animated
    model is important. In order to avoid getting caught up in any specific graphics
    APIs, in this chapter, you will build an abstraction layer on top of OpenGL. This
    will be a thin abstraction layer, but it will let you work on your animation in
    later chapters without having to do anything OpenGL-specific.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract renderer you will implement in this chapter is very lightweight.
    It doesn't have a lot of features, only the ones you need to display animated
    models. This should make porting the renderer to other APIs straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should be able to render some debug geometry
    to the window using the abstract rendering code you will create. On a higher level,
    you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to store mesh data in buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to bind those buffers as shader attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to send uniform data to a shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to render with index buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic OpenGL concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and working with simple shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some familiarity with OpenGL will make this chapter much easier to follow. OpenGL,
    lighting models, and shader tricks are out of the scope of this book. For more
    information on these topics, check out [https://learnopengl.com/](https://learnopengl.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Working with shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important part of the abstraction layer is the `Shader` class. To draw
    something, you must bind a shader and attach some attributes and uniforms to it.
    The shader describes how the thing being drawn should be transformed and shaded,
    while attributes define what is being drawn.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will implement a `Shader` class that can compile vertex
    and fragment shaders. The `Shader` class will also return uniform and attribute
    indices.
  prefs: []
  type: TYPE_NORMAL
- en: The Shader class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When implementing the `Shader` class, you will need to declare several protected
    helper functions. These functions will keep the public API of the class clean;
    they are used for things such as reading a file into a string or calling an OpenGL
    code to compile the shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file to declare the `Shader` class in; call it `Shader.h`. The
    `Shader` class should have a handle to the OpenGL shader object and maps for attribute
    and uniform indices. These dictionaries have a string for a key (the name of the
    attribute or uniform) and `unsigned int` for a value (the index of the uniform
    or attribute):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The copy constructor and assignment operator of the `Shader` class should be
    disabled. The `Shader` class is not intended to be copied by value since it holds
    a handle to a GPU resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to declare the helper function in the `Shader` class. The `ReadFile`
    function will read the contents of a file into `std::string`. The `CompileVertexShader`
    and `CompileFragmentShader` functions compile shader source code and return an
    OpenGL handle. The `LinkShader` function will link two shaders into a shader program.
    The `PopulateAttribute` and `PopulateUniform` functions will fill out the attribute
    and uniform dictionaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor of the class will create an empty `Shader` object.
    The overload constructor will call the `Load` method, which loads shaders from
    files and compiles them. The destructor will release the OpenGL shader handle
    that the `Shader` class is holding on to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Before a shader is used, it will need to be bound with the `Bind` function.
    Similarly, after it is no longer in use, it can be unbound with the `UnBind` function.
    The `GetAttribute` and `GetUniform` functions perform lookups in the appropriate
    dictionaries. The `GetHandle` function returns the shader''s OpenGL handle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `Shader` class declaration is done, you will implement it in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Shader class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file, `Shader.cpp`, to implement the `Shader` class in. The `Shader`
    class implementation hides almost all of the actual OpenGL code from the caller.
    Because most OpenGL calls are abstracted this way, in later chapters, you only
    have to call the abstraction layer, not the OpenGL functions, directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uniform arrays are used throughout this book. When a uniform array is encountered
    in a shader (for example, `modelMatrices[120]`) the uniform name returned by `glGetActiveUniform`
    is the first element of the array. In this example, that would be `modelMatrices[0]`.
    When you encounter a uniform array, you want to loop through all the array indices
    and get the explicit uniform indices for each element, but you also want to store
    the uniform name without any subscripts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `Shader` constructors must create a new shader program handle by calling
    `glCreateProgram`. The constructor variant that takes two strings calls the `Load`
    function with the strings. Since `mHandle` is always a program handle, the destructor
    needs to delete the handle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadFile` helper function converts a file into a string using `std::ifstream`
    to read the contents of the file into `std::stringstream`. The string stream can
    be used to return the contents of the file as a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CompileVertexShader` function is boilerplate code for compiling an OpenGL
    vertex shader. First, create the shader object with `glCreateShader`, then set
    the source for the shader with `glShaderSource`. Finally, compile the shader with
    `glCompileShader`. Check for errors with `glGetShaderiv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CompileFragmentShader` function is almost identical to the `CompileVertexShader`
    function. The only real difference is the argument to `glCreateShader`, indicating
    that you are creating a fragment shader, not a vertex shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LinkShaders` helper function is also boilerplate. Attach the shaders to
    the shader program handle that the constructor created. Link the shaders by calling
    `glLinkProgram` and check for errors with `glGetProgramiv`. Once the shaders are
    linked, you only need the program; the individual shader objects can be deleted
    with `glDeleteShader`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PopulateAttributes` function enumerates all the attributes stored inside
    the shader program, then stores them as a key-value pair, where the key is the
    name of the attribute and the value is its location. You can count the number
    of active attributes in a shader program with the `glGetProgramiv` function, passing
    `GL_ACTIVE_ATTRIBUTES` as the parameter name. Then, loop through all the attributes
    by index and use `glGetActiveAttrib` to get the name of each attribute. Finally,
    call `glGetAttribLocation` to get the location of each attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PopulateUniforms` helper function is very similar to the `PopulateAttributes`
    helper function. `glGetProgramiv` needs to take `GL_ACTIVE_UNIFORMS` as the parameter
    name and you need to call `glGetActiveUniform` and `glGetUniformLocation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When a valid uniform is encountered, you need to determine whether the uniform
    is an array or not. To do this, search for the array bracket (`[`) in the uniform
    name. If the bracket is found, the uniform is an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you encounter a uniform array, erase everything out of the string, starting
    with `[`. This will leave you with only the uniform name. Then, enter a loop where
    you try to retrieve every index from the array by appending `[ + index + ]` to
    the uniform name. Once the first invalid index is found, break the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, `uniformName` contains the name of the uniform. If that uniform
    was an array, the `[0]` part of the name has been removed. Store the uniform index
    by name in `mUniforms`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The final helper function is the `Load` function, which is responsible for
    loading the actual shaders. This function takes two strings, which are either
    filenames or inline shader definitions. Once the shaders are read, call the `Compile`,
    `Link`, and `Populate` helper functions to load the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bind` function needs to set the current shader program to active, while
    `UnBind` should make sure no `Shader` objects are active. The `GetHandle` helper
    function returns the OpenGL handle to the `Shader` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need a way of retrieving the bind slots for attributes and uniforms.
    The `GetAttribute` function will check whether a given attribute name is present
    in the attribute map. If it is, the integer representing it is returned. If it
    is not, `0` is returned. `0` is a valid attribute index, so in case of an error,
    an error message is logged as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetUniform` function is implemented almost identically to the `GetAttribute`
    function, except instead of the attribute map, it works on the uniform map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Shader` class has methods to retrieve indices for uniforms and attributes.
    In the next section, you will start implementing an `Attribute` class to hold
    vertex data that is passed to shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Working with buffers (attributes)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attributes are per-vertex data in the graphics pipeline. A vertex is made up
    of attributes. For example, a vertex has a position and a normal, which are both
    attributes. The most common attributes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Position: Often in local space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Normal: The direction the vertex points in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UV or texture coordinate: The normalized (*x*,*y*) coordinate on a texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Color: A `vector3` representing the color of a vertex'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes can have different data types. Throughout this book, you will implement
    support for integers, floats, and vector attributes. For vector attributes, two-,
    three-, and four-dimensional vectors will be supported.
  prefs: []
  type: TYPE_NORMAL
- en: The Attribute class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, `Attribute.h`. The `Attribute` class will be declared in
    this new file. The `Attribute` class will be templated. This will ensure that
    if an attribute is meant to be `vec3`, you cannot accidentally load `vec2` into
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The attribute class will contain two member variables, one for the OpenGL attribute
    handle one to count how much data the `Attribute` class contains. Since the attribute
    data lives on the GPU and you don''t want to have multiple handles to the same
    data, the copy constructor and `assignment operator` should be disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetAttribPointer` function is special, as it will need to be implemented
    once for each type of attribute that will be supported. This will be done explicitly
    in the `.cpp` file, later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the constructor and destructor of the Attribute class as public functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Attribute` class needs a `Set` function, which will upload an array of
    data to the GPU. Each element in the array represents the attribute for one vertex.
    We need a way of binding and unbinding attributes from bind slots defined by the
    shader, as well as accessors for the count and handle of the attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have declared the `Attribute` class, you will be implementing it
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Attribute class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, `Attribtue.cpp`. You will be implementing the `Attribute`
    class in this file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Attribute` class is templated, but none of its functions are marked as
    inline. The template specializations for each attribute type will live in the
    `Attribute.cpp` file. Add specializations for the integer, floating point, `vec2`,
    `vec3`, `vec4`, and `ivec4` types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor should generate an OpenGL buffer and store it in the handle
    of the `Attribute` class. The destructor is responsible for freeing the handle
    that the `Attribute` class is holding on to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Attribute` class has two simple getters, one to retrieve the count and
    one to retrieve the OpenGL handle. The count represents how many total attributes
    there are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Set` function takes an array and a length. It then binds the buffer that
    the `Attribute` class is holding on to and uses `glBufferData` to fill the buffer
    with data. There is a convenience function for `Set` that takes a vector reference
    instead of an array. It calls the actual `Set` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetAttribPointer` function wraps `glVertesAttribPointer` or `glVertesAttribIPointer`.
    The arguments and which function to call are different based on what the type
    of the `Attribute` class is. To remove any ambiguity, provide explicit implementations
    for all supported template types. Start by implementing the `int`, `ivec4`, and
    `float` types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `vec2`, `vec3`, and `vec4` types next. These are all very similar
    to the `float` type. The only difference is the second argument to `glVertexAttribPointer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two functions of the `Attribute` class need to bind and unbind the
    attribute to a slot specified in the `Shader` class. Since the `glVertexAttribPointer`
    function is different based on the templated type of the `Attribute` class, `Bind`
    will call the `SetAttribPointer` helper function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`Attribute` data changes per vertex. There is another type of data you will
    need to set: uniforms. Unlike attributes, uniforms remain the same throughout
    the execution of your shader program. You will implement uniforms in the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with uniforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike attributes, uniforms are constant data; they are set once. The value
    of a uniform remains the same for all vertices processed. Uniforms can be created
    as arrays, a feature you will use in later chapters to implement mesh skinning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `Attribute` class, the `Uniform` class will also be templated. Unlike
    attributes, however, there will never be an instance of a `Uniform` class. It
    only needs public static functions. For each uniform type, there are three functions:
    one to set an individual uniform value, one to set an array of uniform values,
    and a convenience function that sets an array of values but uses a vector for
    input.'
  prefs: []
  type: TYPE_NORMAL
- en: The Uniform class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, `Uniform.h`. You will be implementing the `Uniform` class
    in this new file. The `Uniform` class will never be instantiated since there won''t
    be any instances of this class. Disable the constructor and copy the constructor,
    assignment operator, and destructor. What the class will have is three overloads
    of a static `Set` function. The `Set` function will need to be specified for each
    template type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You just finalized the declaration of the `Uniform` class. In the next section,
    you will start implementing the `Uniform` class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Uniform class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file, `Uniform.cpp`. You will be implementing the `Uniform` class
    in this new file. Like the `Attribute` class, the `Uniform` class is also templated.
  prefs: []
  type: TYPE_NORMAL
- en: In OpenGL, uniforms are set with the `glUniform***` family of functions. There
    are different functions for integers, floating point numbers, vectors, matrices,
    and so on. You want to provide implementations for the `Set` method for each of
    these types but avoid writing nearly identical code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid having to write code that''s almost identical, you will declare a
    #`define` macro. This macro will take three arguments—the OpenGL function to call,
    the template type of the Uniform class, and the data type of the OpenGL function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to define the template specifications for the supported
    uniform types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You only need to implement one of the `Set` methods for each type—the one that
    takes an array and a length. The other `Set` method overloads are for convenience.
    Implement the two convenience overloads—one of them is for setting a single uniform,
    the other is for setting a vector. Both overloads should just call the `Set` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `UNIFORM_IMPL` macro. The first argument will be which OpenGL function
    to call, the second is the type of structure that is being used, and the last
    argument is the data type of the same structure. The `UNIFORM_IMPL` macro assembles
    these pieces of information into a function declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `UNIFORM_IMPL` macro for each uniform data type to generate the appropriate
    `Set` functions. The only data type this method won''t work for is `mat4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Set` function for matrices needs to be specified manually; otherwise,
    the `UNIFORM_IMPL` macro won''t work. This is because the `glUniformMatrix4fv`
    function takes an additional Boolean argument asking whether the matrix should
    be transposed or not. Set the transposed Boolean to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you built an abstraction layer on top of the concept of uniforms.
    In the next section, you will implement index buffers, which are like attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with index buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Index buffers are a type of attribute. Unlike attributes, an index buffer is
    bound to `GL_ELEMENT_ARRAY_BUFFER` and can be used to draw primitives. Because
    of this, you will implement index buffers in their own class, rather than reuse
    the `Attribute` class.
  prefs: []
  type: TYPE_NORMAL
- en: The IndexBuffer class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file, `IndexBuffer.h`. You will be adding the declaration of the
    `IndexBuffer` class to this new file. Like an `Attribute` object, `IndexBuffer`
    will contain an OpenGL handle and a count, with getter functions for both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy constructor and assignment operator need to be disabled to avoid having
    multiple `IndexBuffer` objects referencing the same OpenGL buffer. The `Set` function
    takes an unsigned integer array and the length of the array, but there is a convenience
    overload that takes a vector as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you declared a new `IndexBuffer` class. In the next section,
    you will start to implement the actual index buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the IndexBuffer class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An index buffer allows you to render a model using indexed geometry. Think
    of a human model; almost all triangles in the mesh will be connected. This means
    many triangles might share a single vertex. Instead of storing every single vertex,
    only unique vertices are stored. A buffer that indexes into the list of unique
    vertices, the index buffer, is used to create triangles out of the unique vertices,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `IndexBuffer.cpp`. You will be implementing the `IndexBuffer`
    class in this file. The constructor needs to generate a new OpenGL buffer and
    the destructor needs to delete that buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter functions for count and the OpenGL handle inside of the `IndexBuffer`
    object are trivial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Set` function of the `IndexBuffer` class needs to bind `GL_ELEMENT_ARRAY_BUFFER`.
    Other than that, the logic is the same as it was for attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you built an abstraction around index buffers. In the next
    section, you will learn how index buffers and attributes can be used to render
    geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have classes for dealing with vertex data, uniforms, and index buffers,
    but no code to draw any of it. Drawing will be handled by four global functions.
    You will have two `Draw` functions and two `DrawInstanced` functions. You will
    be able to draw geometry with or without an index buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `Draw.h`. You will be implementing the `Draw` function in
    this file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare an `enum` class that defines what primitive should be used for drawing.
    Most of the time, you will only need lines, points, or triangles, but some additional
    types may be useful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare the `Draw` function. There are two overloads for the `Draw` function—one
    takes an index buffer and a draw mode and the other takes a vertex count and a
    draw mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `Draw`, declare two `DrawInstanced` functions. These functions have a
    similar signature but take an extra argument—`instanceCount`. This `instanceCount`
    variable controls how many instances of the geometry will be rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file, `Draw.cpp`. You will implement the drawing-related functionality
    in this file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to be able to convert the `DrawMode` enum into `GLenum`. We will do
    this with a static helper function. The only thing this function needs to do is
    figure out what the input draw mode is and return the appropriate `GLenum` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Draw` and `DrawInstanced` functions that take a vertex count are simple
    to implement. `Draw` needs to call `glDrawArrays` and `DrawInstanced` needs to
    call `glDrawArraysInstanced`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Draw` and `Drawinstanced` functions that take an index buffer need to
    bind the index buffer to `GL_ELEMENT_ARRAY_BUFFER` and then call `glDrawElements`
    and `glDrawElementsInstanced`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So far, you have written code to load shaders, create and bind GPU buffers,
    and pass uniforms to shaders. Now that the drawing code is implemented as well,
    you can start displaying geometry.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to work with textures to make the rendered
    geometry look more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Working with textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the shaders you will write in this book assume that the diffused color of
    what is being rendered comes from a texture. Textures will be loaded from `.png`
    files. All image loading will be done through `stb_image`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Stb` is a collection of single-file public domain libraries. We''re only going
    to use the image loader; you can find the entire `stb` collection on GitHub at
    [https://github.com/nothings/stb](https://github.com/nothings/stb).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding stb_image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will be loading textures using `stb_image`. You can get a copy of the header
    file from [https://github.com/nothings/stb/blob/master/stb_image.h](https://github.com/nothings/stb/blob/master/stb_image.h).
    Add the `stb_image.h` header file to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `stb_image.cpp`. This file just needs to declare the `stb_image`
    implementation macro and include the header file. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The Texture class declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file, `Texture.h`. You will be declaring the `Texture` class in
    this file. The `Texture` class only needs a few important functions. It needs
    to be able to load a texture from a file, bind a texture index to a uniform index,
    and deactivate a texture index.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the core functions, the class should have a default constructor,
    a convenience constructor that takes a file path, a destructor, and a getter for
    the OpenGL handle contained inside of the `Texture` class. The copy constructor
    and assignment operator should be disabled to avoid having two `Texture` classes
    reference the same OpenGL texture handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the Texture class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file, `Texture.cpp`. The definition of the `Texture` class will
    go in this file. The default constructor of the `Texture` class needs to set all
    member variables to `0`, then generate an OpenGL handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Load` function is probably the most important function in the `Texture`
    class; it''s responsible for loading image files. The actual parsing of the image
    files will be handled by `stbi_load`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The convenience constructor generates a new handle, then calls the `Load` function,
    which will initialize the rest of the class member variables, since every instance
    of the `Texture` class holds a valid texture handle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`stbi_load` takes a path to the image file and references to the width, height,
    and number of channels in the image. The last argument specifies the number of
    components per pixel. By setting it to `4`, all textures are loaded with RGBA
    channels. Next, use `glTexImage2D` to upload the texture to the GPU and `glGenerateMipmap`
    to generate the appropriate mipmaps for the image. Set the wrap mode to repeat:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Set` function needs to activate a texture unit, bind the handle that the
    `Texture` class contains to that texture unit, then set the specified uniform
    index to contain the texture unit that is currently bound. The `Unset` function
    unbinds the current texture from the specified texture unit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetHandle` getter function is simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `Texture` class will always load textures using the same mipmap level and
    wrapping parameters. For the samples in this book, that should be enough. You
    may want to try adding getters and setters for these properties.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will implement vertex and fragment shader programs,
    which is the last step needed to draw something.
  prefs: []
  type: TYPE_NORMAL
- en: Simple shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rendering abstraction is done. Before drawing anything, you need to write
    shaders to direct how things are going to be drawn. In this section, you will
    write a vertex and a fragment shader. The fragment shader will be used throughout
    the rest of this book and the vertex shaders used in later sections of this book
    will be variations of the one presented here.
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vertex shader is responsible for putting each vertex of a model through
    the model, view, and projection pipeline and for passing any required lighting
    data to the fragment shader. Create a new file, `static.vert`. You will be implementing
    the vertex shader in this file.
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader takes three uniforms—a model, a view, and a projection matrix.
    These uniforms are needed to transform a vertex. Each individual vertex is made
    up of three attributes—a position, a normal, and some texture coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex shader outputs three variables to the fragment shader, the normal
    and fragment positions in the world space, and the texture coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is a minimal vertex shader; it only puts the vertex through a model view
    and projection pipeline. This shader can be used to display static geometry or
    CPU skinned meshes. In the next section, you will implement a fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: The fragment shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file, `lit.frag`. The fragment shader in this file will be used
    throughout the rest of the book. Some chapters will introduce new vertex shaders,
    but the fragment shader is always going to remain as this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fragment shader takes the object''s diffused color from a texture, then
    applies a single-directional light. The lighting model is just *N* dot *L*. Because
    there is no ambient term to the light, some parts of the model can appear as all
    black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Important information:'
  prefs: []
  type: TYPE_NORMAL
- en: Want to learn more about lighting models in OpenGL? Go to [https://learnopengl.com/Lighting/Basic-Lighting](https://learnopengl.com/Lighting/Basic-Lighting).
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple fragment shader; the diffuse color is obtained by sampling
    a texture and the intensity is a simple directional light.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write an abstraction layer on top of the
    OpenGL API. For the most part, you will be using these classes to draw things
    throughout the rest of the book, but a few stray OpenGL calls might find their
    way into our code here and there.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting OpenGL in this fashion will let future chapters focus on animation
    without having to worry about the underlying API. It should be straightforward
    to port this API to other backends as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are two samples for this chapter—`Chapter06/Sample00`, which is the code
    used up to this point, and `Chapter06/Sample01`, which shows a simple textured
    and lit plane rotating in place. `Sample01` is a good example of how to use the
    code you have written so far.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sample01` also includes a utility class, `DebugDraw`, that won''t be covered
    in this book. The class is found in `DebugDraw.h` and `DebugDraw.cpp`. The `DebugDraw`
    class can be used to draw debug lines quickly with a simple API. The `DebugDraw`
    class is not very efficient; it''s only meant to be used for debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will start to explore the glTF file format. glTF is
    a standard format that can store both mesh and animation data. It's the format
    that the rest of this book will be using.
  prefs: []
  type: TYPE_NORMAL
