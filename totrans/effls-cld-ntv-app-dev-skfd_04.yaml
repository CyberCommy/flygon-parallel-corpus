- en: '[*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034): Skaffold — Easy-Peasy
    Cloud-Native Kubernetes Application Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned that developing applications with Kubernetes
    is cumbersome and provided some coding examples. This chapter will cover a high-level
    overview of Skaffold. You will also learn and understand Skaffold basic **command-line
    interface** (**CLI**) commands and how these ease developers' pain in developing
    cloud-native microservices with Skaffold. We will demonstrate Skaffold's basic
    features by building and deploying a Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Skaffold?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and deploying a Spring Boot application with Skaffold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a basic understanding of Skaffold
    and will be able to take advantage of Skaffold to accelerate an inner development
    loop while developing cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples of this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDEA [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skaffold CLI ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.5 ([https://start.spring.io](https://start.spring.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK 16 ([https://jdk.java.net/16/](https://jdk.java.net/16/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    or Docker Desktop for macOS and Windows ([https://www.docker.com/products/dockerdesktop](https://www.docker.com/products/dockerdesktop))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code examples for this chapter from the GitHub repository
    at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter03](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: What is Skaffold?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As most developers, Matt Rickard, a Google engineer, also experienced the same
    pain while building and deploying Kubernetes applications in the inner loop. Matt
    decided to take the matter into his own hands and created Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: '**Skaffold** is a CLI tool that automates the build, push, and deploy steps
    for cloud-native applications running on local or remote Kubernetes clusters of
    your choice. Skaffold is not a replacement for Docker or Kubernetes. It works
    in conjunction with them and handles the build, push, and deploy boilerplate part
    for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Skaffold is an open source tool developed by Google. It was generally available
    on November 7, 2019, and is released under the Apache 2.0 license. Skaffold is
    written in the Go programming language. You can visit the Skaffold home page at
    [https://skaffold.dev/](https://skaffold.dev/). Skaffold documentation is available
    at [https://skaffold.dev/docs/](https://skaffold.dev/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: If you are on macOS, then you can use the `homebrew` package manager to install
    Skaffold with the `brew install skaffold` command. However, we will cover various
    ways to install Skaffold in [*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052),
    *Installing Skaffold and Demystifying Its Pipeline Stages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Skaffold is widely popular among the developer community because it provides
    sensible defaults, is simple to use, and has a pluggable architecture. Here''s
    a recent tweet from the official Skaffold account, just confirming this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Skaffold Twitter account tweets on passing 11k stars on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B17385_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Skaffold Twitter account tweets on passing 11k stars on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in the tweet, the number of stars and forks for the Skaffold GitHub
    repository speaks for its popularity itself, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Skaffold GitHub repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B17385_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Skaffold GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: The Skaffold GitHub page is available at [https://github.com/GoogleContainerTools/skaffold](https://github.com/GoogleContainerTools/skaffold).
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand the working of Skaffold by building and deploying a
    Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying a Spring Boot application with Skaffold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand Skaffold commands and concepts better, in this section, we will
    build and deploy a Spring Boot Java application to a local single-node Kubernetes
    cluster using Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we talk about *the Kubernetes cluster for local development* in this
    book, we refer to *the Kubernetes cluster with Docker Desktop*, if not specified
    otherwise. However, Docker Desktop or minikube is not the only tool available
    today for running a local Kubernetes cluster. Skaffold also supports Kind [https://github.com/kubernetes-sigs/kind](https://github.com/kubernetes-sigs/kind)
    and k3d [https://github.com/rancher/k3d](https://github.com/rancher/k3d) as target
    Kubernetes clusters for local development.
  prefs: []
  type: TYPE_NORMAL
- en: Since this will be a sneak-peek of Skaffold, we will not cover everything in
    detail about Skaffold, as we are going to cover this in the upcoming chapters.
    I will, however, try to explain the commands used so that you can understand the
    exact flow. Before we dive into Skaffold, let's first talk about the Spring Boot
    application we are going to build and deploy with Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring Boot application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This Spring Boot application we will be creating will have two **Representational
    State Transfer** (**REST**) endpoints exposed. The `/states` REST endpoint will
    return all Indian states and their capitals, and the `/state?name=statename` REST
    endpoint will return a specific Indian state and its capital. This application
    uses an in-memory `H2` database that inserts rows at the start of the application.
    Similar to previous chapters, we will use [https://start.spring.io](https://start.spring.io)
    to generate stubs for the project. The following screenshot shows the dependencies
    we are going to use to build this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Required dependencies for the Spring Boot application'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B17385_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Required dependencies for the Spring Boot application
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to the Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the dependencies we already discussed, I have added the `jib-maven-plugin`
    plugin to `pom.xml`, which will containerize the Spring Boot application to a
    container image. Jib takes the input as your source code and outputs a ready-to-run
    container image of your application. By the way, there''s a Gradle equivalent
    as well. For Gradle, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**Jib** can create an image without a Docker daemon. This means that you don''t
    have to install and configure Docker and create or maintain a Dockerfile.'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover more about Jib in [*Chapter 6*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074),
    *Working with Skaffold Container Image Builders and Deployers.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin, then, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the layout of the source code directory:![Figure 3.4 – Project layout
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B17385_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Project layout
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the REST controller class annotated with `@RestController`
    annotation for handling incoming **HyperText Transfer Protocol** (**HTTP**) requests.
    The `@GetMapping` annotations on the `getAllStates()` method binds all HTTP `GET`
    requests to it when the `/states` REST endpoint is accessed. Similarly, the `getSpecificState()`
    method handles the HTTP `GET` request for `/state` when the state name is passed
    as a query parameter into the REST **Uniform Resource Locator** (**URL**). If
    no parameter is passed, then it takes a default value of the `Maharashtra` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of writing this book, Java 16 is generally available. I have taken
    the liberty of also introducing you to some of its cool new features. Let''s now
    talk about records. We have the following data carrier `record` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The class type is `record`, and it's a special type that got added as a feature
    in Java 16\. As per the *Java Enhancement Proposal 395* ([https://openjdk.java.net/jeps/395](https://openjdk.java.net/jeps/395)),
    records are a new kind of class in the Java language. They act as transparent
    carriers for immutable data, with less ceremony than for normal classes. Records
    can be thought of as nominal tuples. The `record` class declaration consists of
    a name, optional type parameters, a header, and a body. Another interesting feature
    worth mentioning about the `record` class is that `hashcode()`, `equals()`, `toString()`,
    and a canonical constructor are implicitly generated for us by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `StateRepository` interface that is implemented by the
    `StateService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the `StateService` class, we are using Spring's `JdbcTemplate` to access
    the `H2` database. The `findAll()` method returns all the states and their capitals.
    In the same class as the `findAll()` method, I have used the `RowMapper` functional
    interface. `JdbcTemplate` uses this for mapping rows of a `ResultSet` object and
    returns a `Row` object for the current row.
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure you may have also observed that I have additionally used the `new`
    keyword to initialize the `record` class, which means I can initialize the `record`
    class like I would a normal class in Java. The `findByName()` method returns a
    `String`, which is the capital of the state that comes in the `query` parameter
    request.
  prefs: []
  type: TYPE_NORMAL
- en: I have also used the *Java 15 Text Blocks* ([https://openjdk.java.net/jeps/378](https://openjdk.java.net/jeps/378))
    feature while declaring the **Structured Query Language** (**SQL**) queries, which
    helps in the readability of SQL queries and **JavaScript Object Notation** (**JSON**)
    string values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I explained earlier, we have used the in-memory `H2` database to hold the
    data while the application is running. It gets inserted at the application startup
    using the following SQL statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Data is defined using the following schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Kubernetes manifests—that is, deployment and service—are available under
    the `k8s` directory in the source code, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mydeployment.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`myservice.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have covered all the required building blocks for Skaffold. Now,
    let's talk about the Skaffold configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Skaffold configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's talk about the `skaffold.yaml` Skaffold configuration file, where we describe
    the build and deploy part of the workflow. This file is generated using the `skaffold
    init` command. We will explore this and many other Skaffold CLI commands in [*Chapter
    5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052), *Installing Skaffold and
    Demystifying Its Pipeline Stages*. Skaffold typically expects the `skaffold.yaml`
    configuration file in the current directory, but you can override it by passing
    the `--filename` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the content of the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me just explain the key components in this file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion`: This specifies the **application programming interface** (**API**)
    schema version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: This specifies how images are built with Skaffold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`artifacts`: Here, we have the images to be built.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: This is the name of the image to be built.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jib`: This specifies that the image is built using the Jib Maven plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy`: This specifies how the image is going to be deployed to a local or
    remote Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`: This specifies that the `kubectl` CLI is going to be used for creating
    and updating Kubernetes manifests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifests`: This specifies the Kubernetes manifest file path—that is, deployments
    and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you have understood the Skaffold configuration, the next logical step is
    to build and deploy our Spring Boot application using Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying the Spring Boot application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go ahead with the build and deployment of our Spring Boot application,
    please make sure that Docker is up and running before running the `skaffold` command.
    Otherwise, you will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing now remaining is to run the `skaffold dev` command and start
    the **continuous development** (**CD**) workflow. If you run this command without
    enabling Kubernetes with Docker Desktop, it will fail, with the following error.
    So, watch out for these prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If all the prerequisites are met, then the moment you enter that command, what
    Skaffold will do is watch for changes in your source code directory using its
    **File Watcher** mechanism. It will build an image, push it to the local Docker
    registry, deploy your application, and stream logs from the running pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'How cool is that?!! You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the verbosity of the logs, we have trimmed them down to show only
    the parts that are relevant to our discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there are lots of logs generated and it would be difficult to explain
    them all at once, I have intentionally kept these in chunks to help you understand
    the Skaffold working better through these logs. So far, we can conclude the following
    from the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: Skaffold first tries to figure out the source code dependencies it needs to
    watch based on the builder defined in the `skaffold.yaml` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then generates a tag for the image, as mentioned in the `build` section of
    the `skaffold.yaml` file. You might be wondering why an image tag is generated
    before the image is built. We will cover the Skaffold tagging mechanism specifically
    in [*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052), *Installing
    Skaffold and Demystifying Its Pipeline Stages*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it tries to find the image in the local cache. Images are cached locally
    to improve the execution time if there is no need for compilation. Since the image
    was not available locally, Skaffold started the build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before doing the actual build, Skaffold identified that the Kubernetes context
    is set to `docker-desktop`. It will use a local Docker daemon to create an image.
    Did you see the clever guesses it takes to fasten the inner development loop?
    You can verify the current `kube-context` status with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using the `jib-maven-plugin` plugin and the Kubernetes context
    is set to `docker-desktop`, Skaffold will internally use the `jib:dockerBuild`
    command to create an image. We have used `openjdk:16-jdk-alpine` as the base image
    because it's lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, Jib will try to authenticate with the Docker Hub container registry
    and download the base image using credentials from the `config.json` file located
    at the `/Users/ashish/.docker/config.json` path; then, it will create image layers,
    and finally upload it to the local Docker daemon, as seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can conclude the following from the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, in the `Starting test...` logs, Skaffold runs container-structure
    tests to validate built container images before deploying them to our cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soon after that, Skaffold will create Kubernetes manifests—that is, deployment
    and services available under the `k8s` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the manifests are created, it means the pod is up and running after some
    time. Then, it will also start streaming logs from the pod on your console itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now do some verification to make sure that the pod is actually running.
    We will run the following `kubectl` command for verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Kubernetes resources created'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B17385_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Kubernetes resources created
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have a pod named `skaffold-introduction-667786cc47-khx4q`
    with a `RUNNING` status. Let''s hit the `/states` REST endpoint and see if we
    are getting the desired output or not, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed we are getting the expected output. Let''s hit the other `/state?name=statename`
    REST endpoint as well and see if we are getting the desired output or not, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Yes—we do get the desired output!
  prefs: []
  type: TYPE_NORMAL
- en: When you run the `skaffold dev` command, it creates a CD pipeline. For example,
    if there are any code changes in this mode, Skaffold will automatically rebuild
    and redeploy the image.
  prefs: []
  type: TYPE_NORMAL
- en: In `Skaffold dev` mode, since we are using a local Kubernetes cluster and the
    Kubernetes context is set to `docker-desktop`, Skaffold will not push the image
    to a remote container registry and will load it to a local Docker registry instead.
    It will further help in accelerating the inner development loop.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to clean up everything we have done so far, we can just press *Ctrl*
    + *C*, and Skaffold will take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: We thus reach the end of this demonstration, where we have successfully built
    and deployed a Spring Boot application to a single-node Kubernetes cluster that
    comes with Docker Desktop, using Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to Skaffold and some of its commands and
    concepts. In the example, we have introduced you to only one Skaffold command—that
    is, `skaffold dev`. However, there are many such commands, for example, `skaffold
    run` and `skaffold render`, which we will cover in upcoming chapters. You have
    also learned how to build and deploy applications with Skaffold using commands
    such as `skaffold dev` to the local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Skaffold features and architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learn more about developing Java applications with Spring Boot from *Developing
    Java Applications with Spring and Spring Boot*, published by Packt Publishing
    ([https://www.packtpub.com/product/developing-java-applications-with-spring-and-spring-boot/9781789534757](https://www.packtpub.com/product/developing-java-applications-with-spring-and-spring-boot/9781789534757)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most recent Java 16 release notes are available at [https://jdk.java.net/16/](https://jdk.java.net/16/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
