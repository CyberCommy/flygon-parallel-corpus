- en: Styling Qt Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化Qt应用程序
- en: It is easy to appreciate the clean, native look that Qt effortlessly provides
    by default. But for less business-like applications, plain gray widgets and bog-standard
    fonts don't always set the right tone. Even the drabbest utility or data entry
    application occasionally benefits from the addition of icons or the judicious
    tweaking of fonts to enhance usability. Fortunately, Qt's flexibility allows us
    to take the look and feel of our application into our own hands.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易欣赏到Qt默认提供的清晰、本地外观。但对于不那么商业化的应用程序，普通的灰色小部件和标准字体并不总是设置正确的语气。即使是最沉闷的实用程序或数据输入应用程序偶尔也会受益于添加图标或谨慎调整字体以增强可用性。幸运的是，Qt的灵活性使我们能够自己控制应用程序的外观和感觉。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using fonts, images, and icons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字体、图像和图标
- en: Configuring colors, style sheets, and styles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置颜色、样式表和样式
- en: Creating animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you'll need all the requirements listed in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, and the Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中列出的所有要求，*PyQt入门*，以及[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中的Qt应用程序模板，*使用QMainWindow构建应用程序*。
- en: Additionally, you may require PNG, JPEG, or GIF image files to work with; you
    can use those included in the example code at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能需要PNG、JPEG或GIF图像文件来使用；您可以使用示例代码中包含的这些文件：[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06)。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5OJj6](http://bit.ly/2M5OJj6)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的运行情况：[http://bit.ly/2M5OJj6](http://bit.ly/2M5OJj6)
- en: Using fonts, images, and icons
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字体、图像和图标
- en: We'll begin styling our Qt application by customizing the application's fonts,
    displaying some static images, and including dynamic icons. However, before we
    can do this, we'll need to create a **graphical user interface** (**GUI**) that
    we can work with. We'll create a game lobby dialog, which will be used for logging
    into an imaginary multiplayer game called **Fight Fighter**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过自定义应用程序的字体、显示一些静态图像和包含动态图标来开始样式化我们的Qt应用程序。但在此之前，我们需要创建一个**图形用户界面**（**GUI**），以便我们可以使用。我们将创建一个游戏大厅对话框，该对话框将用于登录到一个名为**Fight
    Fighter**的虚构多人游戏。
- en: 'To do this, open a fresh copy of your application template and add the following
    GUI code to `MainWindow.__init__()`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，打开应用程序模板的新副本，并将以下GUI代码添加到`MainWindow.__init__()`中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is fairly standard Qt GUI code that you should be familiar with by now;
    we''re saving a few lines of code by putting our inputs in a `dict` object and
    adding them to the layout in a loop, but otherwise, it''s relatively straightforward.
    Depending on your OS and theme settings, the dialog box probably looks something
    like the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当标准的Qt GUI代码，您现在应该对此很熟悉；我们通过将输入放入`dict`对象中并在循环中将它们添加到布局中，节省了一些代码行，但除此之外，它相对直接。根据您的操作系统和主题设置，对话框框可能看起来像以下截图：
- en: '![](assets/ce8de21f-49a5-46c4-aab8-3f45ba3b8c26.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce8de21f-49a5-46c4-aab8-3f45ba3b8c26.png)'
- en: As you can see, it's a nice form but it's a bit bland. So, let's explore whether
    we can improve the style.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这是一个不错的表单，但有点单调。因此，让我们探讨一下是否可以改进样式。
- en: Setting a font
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置字体
- en: The first thing we'll tackle is the font. Every `QWidget` class has a `font`
    property, which we can either set in the constructor or by using the `setFont()`
    accessor. The value of `font` must be a `QtGui.QFont` object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要解决的第一件事是字体。每个`QWidget`类都有一个`font`属性，我们可以在构造函数中设置，也可以使用`setFont()`访问器来设置。`font`的值必须是一个`QtGui.QFont`对象。
- en: 'Here is how you can create and use a `QFont` object:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以创建和使用`QFont`对象的方法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A `QFont` object contains all the attributes that describe the way text will
    be drawn to the screen. The constructor can take any of the following arguments:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFont`对象包含描述文本将如何绘制到屏幕上的所有属性。构造函数可以接受以下任何参数：'
- en: A string indicating the font family
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示字体系列的字符串
- en: A float or integer indicating the point size
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个浮点数或整数，表示点大小
- en: A `QtGui.QFont.FontWeight` constant indicating the weight
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`QtGui.QFont.FontWeight`常量，指示权重
- en: A Boolean indicating whether the font should be italic
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，指示字体是否应该是斜体
- en: 'The remaining aspects of the font, such as the `stretch` property, can be configured
    using keyword arguments or accessor methods. We can also create a `QFont` object
    with no arguments and configure it programmatically, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 字体的其余方面，如`stretch`属性，可以使用关键字参数或访问器方法进行配置。我们还可以创建一个没有参数的`QFont`对象，并按照以下方式进行程序化配置：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting a font on a widget affects not only the widget but also all its child
    widgets. Therefore, we could configure the font for the entire form by setting
    it on `cx_form` rather than setting it on individual widgets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件上设置字体不仅会影响该小部件，还会影响所有子小部件。因此，我们可以通过在`cx_form`上设置字体而不是在单个小部件上设置字体来为整个表单配置字体。
- en: Dealing with missing fonts
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理缺失的字体
- en: Now, if all platforms and **operating systems** (**OSes**) shipped with an infinite
    array of identically named fonts, this would be all you'd need to know about `QFont`.
    Unfortunately, that isn't the case. Most systems ship with only a handful of fonts
    built-in and only a few of these are universal across platforms or even different
    versions of a platform. Therefore, Qt has a fallback mechanism for dealing with
    missing fonts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果所有平台和**操作系统**（**OSes**）都提供了无限数量的同名字体，那么您需要了解的就是`QFont`。不幸的是，情况并非如此。大多数系统只提供了少数内置字体，并且这些字体中只有少数是跨平台的，甚至是平台的不同版本通用的。因此，Qt有一个处理缺失字体的回退机制。
- en: 'For example, suppose that we ask Qt to use a nonexistent font family, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Qt will not throw an error at this call or even register a warning. Instead,
    after not finding the font family requested, it will fall back to its `defaultFamily`
    property, which utilizes the default font set in the OS or desktop environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QFont` object won''t actually tell us that this has happened; if you query
    it for information, it will only tell you what was configured:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To discover what font settings are actually being used, we need to pass our
    `QFont` object to a `QFontInfo` object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run the script, you''ll see that, more than likely, your default screen
    font is actually being used here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While this ensures that users won't be left without any text in the window,
    it would be nice if we could give Qt a better idea of what sort of font it should
    use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by setting the font''s `styleHint` and `styleStrategy` properties,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`styleHint` suggests a general category for Qt to fall back on, which, in this
    case, is the `Fantasy` category. Other options here include `SansSerif`, `Serif`,
    `TypeWriter`, `Decorative`, `Monospace`, and `Cursive`. What these options correspond
    to is dependent on the OS and desktop environment configuration.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The `styleStrategy` property informs Qt of more technical preferences related
    to the capabilities of the chosen font, such as anti-aliasing, OpenGL compatibility,
    and whether the size will be matched exactly or rounded to the nearest non-scaled
    size. The complete list of strategy options can be found at [https://doc.qt.io/qt-5/qfont.html#StyleStrategy-enum](https://doc.qt.io/qt-5/qfont.html#StyleStrategy-enum).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting these properties, check the font again to see whether anything
    has changed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Depending on your system''s configuration, you should see different results
    from before:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On this system, `Fantasy` has been interpreted to mean `Impact`, and the `PreferQuality`
    strategy flag has forced the initially odd 15.233 point size to be a nice round
    `15`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, depending on the fonts available on your system, your application
    should look as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0ac336f7-5ade-4387-a6c5-48a27c8fd1b1.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Fonts can also be bundled with the application; see the *Using Qt resource files*
    section in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Adding images
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt offers a number of classes related to the use of images in an application,
    but, for simply displaying a picture in your GUI, the most appropriate is `QPixmap`.
    `QPixmap` is a display-optimized image class, which can load many common image
    formats including PNG, BMP, GIF, and JPEG.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To create one, we simply need to pass `QPixmap` a path to an image file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once loaded, a `QPixmap` object can be displayed in a `QLabel` or `QButton`
    object, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that labels can only display a string or a pixmap, but not both.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Being optimized for display, the `QPixmap` objects offer only minimal editing
    functionality; however, we can do simple transformations such as scaling:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we've used the pixmap's `scaledToWidth()` method to restrict
    the logo's width to `400` pixels using a smooth transformation algorithm.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The reason why `QPixmap` objects are so limited is that they are actually stored
    in the display server's memory. The `QImage` class is similar but stores data
    in application memory, so that it can be edited more extensively. We'll explore
    this class more in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), Creating
    *2D Graphics with QPainter*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`QPixmap` also offers the handy capability to generate simple colored rectangles,
    as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By specifying a size in the constructor and using the `fill()` method, we can
    create a simple, colored rectangle pixmap. This is useful for displaying color
    swatches or to use as a quick-and-dirty image stand-in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Using icons
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now consider an icon on a toolbar or in a program menu. When the menu item is
    disabled, you expect the icon to be grayed out in some way. Likewise, if a user
    hovers over the button or item using a mouse cursor, you might expect it to be
    highlighted. To encapsulate this type of state-dependent image display, Qt provides
    the `QIcon` class. A `QIcon` object contains a collection of pixmaps that are
    each mapped to a widget state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can create a `QIcon` object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After creating the icon object, we use its `addPixmap()` method to assign a
    `QPixmap` object to a widget state. These states include `Normal`, `Active`, `Disabled`,
    and `Selected`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The `connect_icon` icon will now be a red square when disabled, or a green
    square when enabled. Let''s add it to our submit button and add some logic to
    toggle the button''s status:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you run the script at this point, you'll see that the red square appears
    in the submit button until the `Server` field contains data, at which point it
    automatically switches to green. Notice that we don't have to tell the icon object
    itself to switch states; once assigned to the widget, it tracks any changes in
    the widget's state.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Icons can be used with the `QPushButton`, `QToolButton`, and `QAction` objects;
    the `QComboBox`, `QListView`, `QTableView`, and `QTreeView` items; and most other
    places where you might reasonably expect to have an icon.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Using Qt resource files
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A significant problem with using image files in a program is making sure the
    program can find them at runtime. Paths passed into a `QPixmap` constructor or
    a `QIcon` constructor are interpreted as absolute (that is, if they begin with
    a drive letter or path separator), or as relative to the current working directory
    (which you cannot control). For example, try running your script from somewhere
    other than the code directory, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You'll find that your images are all missing! `QPixmap` does not complain when
    it cannot find a file, it just doesn't show anything. Without an absolute path
    to the images, you'll only be able to find them if the script is run from the
    exact directory to which your paths are relative.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, specifying absolute paths means that your program will only work
    from one location on the filesystem, which is a major problem if you plan to distribute
    it to multiple platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'PyQt offers us a solution to this problem in the form of a **PyQt Resource
    file**, which we can create using the **PyQt resource compiler** tool. The basic
    procedure is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Write an XML-format **Qt Resource Collection** file (`.qrc`) containing the
    paths of all the files that we want to include
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `pyrcc5` tool to serialize and compress these files into data contained
    in a Python module
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the resulting Python module into our application script
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can reference our resources using a special syntax
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s step through this process—suppose that we have some team badges in the
    form of PNG files that we want to include in our program. Our first step is to
    create the `resources.qrc` file, which looks like the following code block:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've placed this file in the same directory as the image files listed in the
    script. Note that we've added a `prefix` value of `teams`. Prefixes allow you
    to organize resources into categories. Additionally, notice that the last file
    has an alias specified. In our program, we can use this alias rather than the
    actual name of the file to access this resource.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the command line, we''ll run `pyrcc5`, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The syntax here is `pyrcc5 -o outputFile.py inputFile.qrc`. This command should
    generate a Python file containing your resource data. If you take a moment to
    open the file and examine it, you'll find it's mostly just a large `bytes` object
    assigned to the `qt_resource_data` variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our main script, we just need to import this file in the same way as
    any other Python file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The file doesn't have to be called `resources.py`; in fact, any name will suffice.
    You just need to import it, and the code in the file will make sure that the resources
    are available to Qt.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文件不一定要叫做`resources.py`；实际上，任何名称都可以。你只需要导入它，文件中的代码将确保资源对Qt可用。
- en: 'Now that the resource file is imported, we can specify pixmap paths using the
    resource syntax:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在资源文件已导入，我们可以使用资源语法指定像素图路径：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Essentially, the syntax is `:/prefix/file_name_or_alias.extension`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，语法是`:/prefix/file_name_or_alias.extension`。
- en: Because our data is stored in a Python file, we can place it inside a Python
    library and it will use Python's standard import resolution rules to locate the
    file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的数据存储在一个Python文件中，我们可以将它放在一个Python库中，它将使用Python的标准导入解析规则来定位文件。
- en: Qt resource files and fonts
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt资源文件和字体
- en: Resource files aren't limited to images; in fact, they can be used to include
    just about any kind of binary, including font files. For example, suppose that
    we want to include our favorite font in the program to ensure that it looks right
    on all platforms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件不仅限于图像；实际上，它们可以用于包含几乎任何类型的二进制文件，包括字体文件。例如，假设我们想要在程序中包含我们喜欢的字体，以确保它在所有平台上看起来正确。
- en: 'Just as with images, we start by including the font file in the `.qrc` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与图像一样，我们首先在`.qrc`文件中包含字体文件：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we've added a prefix of `fonts` and included a reference to the `LiberationSans-Regular.ttf`
    file. After running `pyrcc5` against this file, the font is bundled into our `resources.py`
    file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个前缀`fonts`并包含了对`LiberationSans-Regular.ttf`文件的引用。运行`pyrcc5`对这个文件进行处理后，字体被捆绑到我们的`resources.py`文件中。
- en: 'To use this font in the code, we start by adding it to the font database, as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中使用这个字体，我们首先要将它添加到字体数据库中，如下所示：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`QFontDatabase.addApplicationFont()` inserts the passed font file into the
    application''s font database and returns an ID number. We can then use that ID
    number to determine the font''s family string; this can be passed to `QFont`,
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFontDatabase.addApplicationFont()`将传递的字体文件插入应用程序的字体数据库并返回一个ID号。然后我们可以使用该ID号来确定字体的系列字符串；这可以传递给`QFont`，如下所示：'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Make sure to check the license on your font before distributing it with your
    application! Remember that not all fonts are free to redistribute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在分发应用程序之前，请确保检查字体的许可证！请记住，并非所有字体都可以自由分发。
- en: 'Our form is certainly looking more game-like now; run the application and it
    should look similar the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单现在看起来更像游戏了；运行应用程序，它应该看起来类似于以下截图：
- en: '![](assets/93a4b1be-2c07-49b2-9a87-7d2b740a59fc.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/93a4b1be-2c07-49b2-9a87-7d2b740a59fc.png)'
- en: Configuring colors, style sheets, and styles
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置颜色、样式表和样式
- en: 'Fonts and icons have improved the look of our form, but now it''s time to ditch
    those institutional gray tones and replace them with some color. In this section,
    we''re going to look at three different approaches that Qt offers for customizing
    application colors: manipulating the **palette**, using **style sheets**, and
    overriding the **application style**.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 字体和图标改善了我们表单的外观，但现在是时候摆脱那些机构灰色调，用一些颜色来替换它们。在本节中，我们将看一下Qt为自定义应用程序颜色提供的三种不同方法：操纵**调色板**、使用**样式表**和覆盖**应用程序样式**。
- en: Customizing colors with palettes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调色板自定义颜色
- en: A palette, represented by the `QPalette` class, is a collection of colors and
    brushes that are mapped to color roles and color groups.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由`QPalette`类表示的调色板是一组映射到颜色角色和颜色组的颜色和画笔的集合。
- en: 'Let''s unpack that statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解开这个声明：
- en: Here, **color** is a literal color value, represented by a `QColor` object
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，**color**是一个文字颜色值，由`QColor`对象表示
- en: A **brush** combines a particular color with a style, such as a pattern, gradient,
    or texture, and is represented by a `QBrush` class
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画笔**将特定颜色与样式（如图案、渐变或纹理）结合在一起，由`QBrush`类表示'
- en: A **color role** represents the way a widget uses the color, such as in the
    foreground, in the background, or in the border
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色角色**表示小部件使用颜色的方式，例如前景、背景或边框'
- en: The **color group** refers to the interaction state of the widget; it can be
    `Normal`, `Active`, `Disabled`, or `Inactive`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色组**指的是小部件的交互状态；它可以是`Normal`、`Active`、`Disabled`或`Inactive`'
- en: When a widget is painted on the screen, Qt's painting system consults the palette
    to determine the color and brush used to render each piece of the widget. To customize
    this, we can create our own palette and assign it to a widget.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当小部件在屏幕上绘制时，Qt的绘图系统会查阅调色板，以确定用于渲染小部件的每个部分的颜色和画笔。要自定义这一点，我们可以创建自己的调色板并将其分配给一个小部件。
- en: 'To begin, we need to get a `QPalette` object, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取一个`QPalette`对象，如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While we could just create a `QPalette` object directly, the Qt documentation
    recommends that we call `palette()` on our running `QApplication` instance to
    retrieve a copy of the palette for the currently configured style.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以直接创建一个`QPalette`对象，但Qt文档建议我们在运行的`QApplication`实例上调用`palette()`来检索当前配置样式的调色板的副本。
- en: You can always retrieve a copy of your `QApplication` object by calling `QApplication.instance()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`QApplication.instance()`来随时检索`QApplication`对象的副本。
- en: 'Now that we have the palette, let''s start overriding some of the rules:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了调色板，让我们开始覆盖一些规则：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`QtGui.QPalette.Button` and `QtGui.QPalette.ButtonText` are color role constants
    and, as you might guess, they represent the background and foreground colors,
    respectively, of all the Qt button classes. We''re overriding them with new colors.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtGui.QPalette.Button`和`QtGui.QPalette.ButtonText`是颜色角色常量，正如你可能猜到的那样，它们分别代表所有Qt按钮类的背景和前景颜色。我们正在用新颜色覆盖它们。'
- en: 'To override the color for a particular button state, we need to pass in a color
    group constant as the first argument:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖特定按钮状态的颜色，我们需要将颜色组常量作为第一个参数传递：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, we're changing the colors used when a button is in the `Disabled`
    state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在更改按钮处于`Disabled`状态时使用的颜色。
- en: 'To apply this new palette, we have to assign it to a widget, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个新的调色板，我们必须将它分配给一个小部件，如下所示：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`setPalette()` assigns the provided palette to the widget and all the child
    widgets as well. So, rather than assigning this to individual widgets, we could
    create a single palette and assign it to our `QMainWindow` class to apply it to
    all objects.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Working with QBrush objects
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want something fancier than a solid color, then we can use a `QBrush`
    object. Brushes are capable of filling colors in patterns, gradients, or textures
    (that is, image-based patterns).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a brush that paints a white stipple fill:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Dense2Pattern` is one of 15 patterns available. (You can refer to [https://doc.qt.io/qt-5/qt.html#BrushStyle-enum](https://doc.qt.io/qt-5/qt.html#BrushStyle-enum)
    for the full list.) Most of these are varying degrees of stippling, cross-hatching,
    or alternating line patterns.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns have their uses, but gradient-based brushes are perhaps more interesting
    for modern styling. However, creating one is a little more involved, as shown
    in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To use a gradient in a brush, we first have to create a gradient object. Here,
    we've created a `QLinearGradient` object, which implements a basic linear gradient.
    The arguments are the starting and ending coordinates for the gradient, which
    we've specified as the top-left (0, 0), and the bottom-right (width, height) of
    the main window.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Qt also offers the `QRadialGradient` and `QConicalGradient` classes for additional
    gradient options.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: After creating the object, we then specify color stops using `setColorAt()`.
    The first argument is a float value between 0 and 1 that specifies the percentage
    between the start and finish, and the second argument is the `QColor` object that
    the gradient should be at that point.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: After creating the gradient, we pass it to the `QBrush` constructor to create
    a brush that paints with our gradient.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now apply our brushes to a palette using the `setBrush()` method, as
    follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Just as with `QPalette.setColor()`, we can assign our brush with or without
    specifying a specific color group. In this case, our gradient brush will be used
    to paint the main window regardless of its state, but our dotted brush will only
    be used when the widget is active (that is, the currently active window).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the appearance with Qt Style Sheets (QSS)
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For developers who have worked with web technologies, styling an application
    using palette, brush, and color objects may seem verbose and unintuitive. Fortunately,
    Qt offers you an alternative known as QSS, which is very similar to the **Cascading
    Style Sheets** (**CSS**) used in web development. It is an easy way to apply some
    simple changes to our widgets.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use QSS as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, a style sheet is just a string containing style directives, which we can
    assign to a widget's `styleSheet` property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax, which should be familiar to anyone who has worked with CSS, is
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you run the program at this point, you''ll find, to your dismay, that (depending
    on your system theme) it may look something like the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5aa10114-bea6-4980-b9a0-6d011e653a36.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Here, the interface has mostly gone black apart from the text and images. Our
    buttons and checkbox, in particular, are indistinguishable from the background.
    So, why did this happen?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Well, when you add a QSS style to a widget class, the style change carries down
    to all its subclasses. Since we styled `QWidget`, all the other `QWidget` derived
    classes (such as `QCheckbox` and `QPushButton`) inherited this style.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this by overriding the styles for those subclasses, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Just as with CSS, applying a style to a more specific class overrides the more
    general case. For example, our `QPushButton` background color overrides the `QWidget`
    background color.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of colons with `QCheckBox`—the double colon in QSS allows us to
    reference a subelement of a widget. In this case, this is the indicator portion
    of the `QCheckBox` class (as opposed to its label portion). We can also use a
    single colon to reference a widget state, as, in this case, we're setting a different
    style depending on whether or not the checkbox is checked or unchecked.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to restrict a change to a particular class only and not any of
    its subclasses, simply add a period (`.`) to the name, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This preceding example also demonstrates how to use images in QSS. Just like
    in CSS, we can provide a file path that is wrapped in the `url()` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: QSS also accepts resource paths if you've serialized your images with `pyrcc5`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: If you want to apply a style to a particular widget rather than a whole class
    of widgets, there are two ways to do so.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is to rely on the `objectName` property, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our style sheet, an object name must be preceded by a
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '`#` symbol to identify it as an object name rather than a class.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The other way to set styles on individual widgets is to call t
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'he widget''s `setStyleSheet()` method with some style sheet directives, as
    follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we want to apply a style directly to the widget we're calling, we don't need
    to specify class names or object names; we can simply pass in the properties and
    values.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Having made all these changes, our application now looks a lot more like a
    game GUI:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec30b7cf-f46b-4f79-955c-9af210c2281f.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: The downside of QSS
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, QSS is a very powerful styling method and is accessible for
    any developer who has worked with web development; however, it does have some
    disadvantages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: QSS is an abstraction over the palette and style objects and must be translated
    to the actual system. This makes them slower for large applications, and it also
    means that there is no default style sheet that you can retrieve and edit – you're
    starting from scratch each time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: As we've already seen, QSS can have unpredictable results when applied to high-level
    widgets, since it inherits through the class hierarchy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Finally, bear in mind that QSS is a modest subset of CSS 2.0 with a few additions
    or changes—it is not CSS. Therefore, transitions, animations, flexbox containers,
    relative units, and other modern CSS goodies are completely absent. So, while
    web developers may find its basic syntax familiar, the limited set of options
    may be frustrating and its different behaviors confusing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the appearance with QStyle
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Palettes and style sheets can take us a long way towards customizing the look
    of a Qt application, and for most cases, that's all you'll ever need. To really
    dig into the heart of a Qt application's appearance, we need to understand the
    style system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Every running instance of a Qt application has a single style, which is in charge
    of telling the graphics system how to draw each widget or GUI component. Styles
    are dynamic and pluggable, so that different OS platforms have different styles,
    and users can install their own Qt styles to use in Qt applications. This is how
    Qt applications are able to have a native look on different OSes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started
    with PyQt,* we learned that `QApplication` should be passed a copy of `sys.argv`
    when created, so that it can process some Qt-specific arguments. One such argument
    is `-style`, which allows the user to set a custom style for their Qt application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s run the calendar application from [Chapter 3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml),
    *Handling Events with Signals and Slots,* with the `Windows` style:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now try it using the `Fusion` style, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice the difference in appearance, especially in the input controls.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Capitalization counts with styles; **windows** is not a valid style, whereas
    **Windows** is!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The styles that are available on common OS platforms are shown in the following
    table:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '| OS | Styles |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| OS | 样式 |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Windows 10 | `windowsvista`, `Windows`, and `Fusion` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Windows 10 | `windowsvista`，`Windows`和`Fusion` |'
- en: '| macOS | `macintosh`, `Windows`, and `Fusion` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| macOS | `macintosh`，`Windows`和`Fusion` |'
- en: '| Ubuntu 18.04 | `Windows` and `Fusion` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu 18.04 | `Windows`和`Fusion` |'
- en: On many Linux distributions, additional Qt styles are available from the package
    repositories. A list of currently installed styles can be obtained by calling
    `QtWidgets.QStyleFactory.keys()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多Linux发行版中，可以从软件包存储库中获取其他Qt样式。可以通过调用`QtWidgets.QStyleFactory.keys()`来获取当前安装的样式列表。
- en: 'Styles can also be set inside the application itself. In order to retrieve
    a style class, we need to use the `QStyleFactory` class, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 样式也可以在应用程序内部设置。为了检索样式类，我们需要使用`QStyleFactory`类，如下所示：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`QStyleFactory.create()` will attempt to find an installed style with the given
    name and return a `QCommonStyle` object; if the style requested is not found,
    then it will return `None`. The style object can then be used to set the `style`
    property of our `QApplication` object. (A value of `None` will just cause it to
    use the default.)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`QStyleFactory.create()`将尝试查找具有给定名称的已安装样式，并返回一个`QCommonStyle`对象；如果未找到请求的样式，则它将返回`None`。然后可以使用样式对象来设置我们的`QApplication`对象的`style`属性。（`None`的值将导致其使用默认值。）'
- en: If you plan to set a style inside the application, it's best to do it as early
    as possible before any widgets are drawn to avoid visual glitches.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划在应用程序中设置样式，最好在绘制任何小部件之前尽早进行，以避免视觉故障。
- en: Customizing Qt styles
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Qt样式
- en: Building a Qt style is an involved process that requires a deep understanding
    of Qt's widgets and painting system, and few developers will ever need to create
    one. We might, however, want to override some aspects of the running style to
    accomplish some things that aren't possible through manipulation of the palette
    or style sheets. We can do this by subclassing `QtWidgets.QProxyStyle`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Qt样式是一个复杂的过程，需要深入了解Qt的小部件和绘图系统，很少有开发人员需要创建一个。但是，我们可能希望覆盖运行样式的某些方面，以完成一些无法通过调色板或样式表的操作来实现的事情。我们可以通过对`QtWidgets.QProxyStyle`进行子类化来实现这一点。
- en: A proxy style is an overlay that we can use to override methods of the actual
    style that's running. In this way, it doesn't matter what actual style the user
    chooses, our proxy style's methods (where implemented) will be used instead.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 代理样式是我们可以使用来覆盖实际运行样式的方法的覆盖层。这样，用户选择的实际样式是什么并不重要，我们的代理样式的方法（在实现时）将被使用。
- en: 'For example, let''s create a proxy style that forces all the screen text to
    be in uppercase, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个代理样式，强制所有屏幕文本都是大写的，如下所示：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`drawItemText()` is the method called on the style whenever text must be drawn
    to the screen. It receives a number of arguments, but the one we''re most concerned
    with is the `text` argument that is to be drawn. We''re simply going to intercept
    this text and make it uppercase before passing all the arguments back to `super().drawTextItem()`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawItemText()`是在必须将文本绘制到屏幕时在样式上调用的方法。它接收许多参数，但我们最关心的是要绘制的`text`参数。我们只是要拦截此文本，并在将所有参数传回`super().drawTextItem()`之前将其转换为大写。'
- en: 'This proxy style can then be applied to our `QApplication` object in the same
    way as any other style:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将此代理样式应用于我们的`QApplication`对象，方式与任何其他样式相同：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you run the program at this point, you'll see that all the text is now uppercase.
    Mission accomplished!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行程序，您会看到所有文本现在都是大写。任务完成！
- en: Drawing widgets
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制小部件
- en: Now let's try something a bit more ambitious. Let's change all our `QLineEdit`
    entry boxes to a green rounded rectangle outline. So, how do we go about doing
    this in a proxy style?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些更有野心的事情。让我们将所有的`QLineEdit`输入框更改为绿色的圆角矩形轮廓。那么，我们如何在代理样式中做到这一点呢？
- en: 'The first step is to figure out what element of the widget we''re trying to
    modify. These can be found as enum constants of the `QStyle` class, and they''re
    divided into three main classes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是弄清楚我们要修改的小部件的元素是什么。这些可以在`QStyle`类的枚举常量中找到，它们分为三个主要类别：
- en: '`PrimitiveElement`, which includes fundamental, non-interactive GUI elements
    such as frames or backgrounds'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimitiveElement`，其中包括基本的非交互式GUI元素，如框架或背景'
- en: '`ControlElement`, which includes interactive elements such as buttons or tabs'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlElement`，其中包括按钮或选项卡等交互元素'
- en: '`ComplexControl`, which includes complex interactive elements such as combo
    boxes and sliders'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComplexControl`，其中包括复杂的交互元素，如组合框和滑块'
- en: Each of these classes of items is drawn by a different method of `QStyle`; in
    this case, it turns out that we want to modify the `PE_FrameLineEdit` element,
    which is a primitive element (as indicated by the `PE_` prefix). This type of
    element is drawn by `QStyle.drawPrimitive()`, so we'll need to override that method
    in our proxy style.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别中的每个项目都由`QStyle`的不同方法绘制；在这种情况下，我们想要修改的是`PE_FrameLineEdit`元素，这是一个原始元素（由`PE_`前缀表示）。这种类型的元素由`QStyle.drawPrimitive()`绘制，因此我们需要在代理样式中覆盖该方法。
- en: 'Add this method to `StyleOverrides`, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法添加到`StyleOverrides`中，如下所示：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To control the drawing of an element, we need to issue commands to its `painter`
    object, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制元素的绘制，我们需要向其`painter`对象发出命令，如下所示：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Painter objects and the drawing will be fully covered in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml),
    *Creating 2D Graphics with QPainter,* but, for now, understand that the preceding
    code draws a green rounded rectangle if the `element` argument matches `QStyle.PE_FrameLineEdit`.
    Otherwise, it passes the arguments to the superclass's `drawPrimitive()` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图对象和绘图将在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中完全介绍，*使用QPainter创建2D图形*，但是，现在要理解的是，如果`element`参数匹配`QStyle.PE_FrameLineEdit`，则前面的代码将绘制一个绿色的圆角矩形。否则，它将将参数传递给超类的`drawPrimitive()`方法。
- en: Notice that we do not call the superclass method after drawing our rectangle.
    If we did, then the superclass would draw its style-defined widget element on
    top of our green rectangle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在绘制矩形后，我们不调用超类方法。如果我们这样做了，那么超类将在我们的绿色矩形上方绘制其样式定义的小部件元素。
- en: As you can see in this example, while working with `QProxyStyle` is considerably
    more esoteric than using palettes or style sheets, it does give us almost limitless
    control over how our widgets appear.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个例子中看到的，使用`QProxyStyle`比使用调色板或样式表要复杂得多，但它确实让我们几乎无限地控制我们的小部件的外观。
- en: It doesn't matter whether you use QSS or styles and palettes to restyle an application;
    however, it is highly advised that you stick to one or the other. Otherwise, your
    style modifications can fight with one another and give unpredictable results
    across platforms and desktop settings.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用QSS还是样式和调色板来重新设计应用程序都没有关系；然而，强烈建议你坚持使用其中一种。否则，你的样式修改可能会相互冲突，并在不同平台和桌面设置上产生不可预测的结果。
- en: Creating animations
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画
- en: Nothing quite adds a sophisticated edge to a GUI like the tasteful use of animations.
    Dynamic GUI elements that fade smoothly between changes in color, size, or position
    can add a modern touch to any interface.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比动画的巧妙使用更能为GUI增添精致的边缘。在颜色、大小或位置的变化之间平滑地淡入淡出的动态GUI元素可以为任何界面增添现代感。
- en: Qt's animation framework allows us to create simple animations on our widgets
    using the `QPropertyAnimation` class. In this section, we'll explore how to use
    this class to spice up our game lobby with some animations.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的动画框架允许我们使用`QPropertyAnimation`类在我们的小部件上创建简单的动画。在本节中，我们将探讨如何使用这个类来为我们的游戏大厅增添一些动画效果。
- en: Because Qt style sheets override another widget- and palette-based styling,
    you will need to comment out all the style sheet code for these animations to
    work correctly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Qt样式表会覆盖另一个基于小部件和调色板的样式，所以你需要注释掉所有这些动画的样式表代码才能正常工作。
- en: Basic property animations
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本属性动画
- en: A `QPropertyAnimation` object is used to animate a single Qt property of a widget.
    The class automatically creates an interpolated series of steps between two numeric
    property values and applies the changes over time.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPropertyAnimation`对象用于动画小部件的单个Qt属性。该类会自动在两个数值属性值之间创建插值步骤序列，并在一段时间内应用这些变化。'
- en: 'For example, let''s animate our logo so that it scrolls out from left to right.
    You can begin by adding a property animation object, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们动画我们的标志，让它从左向右滚动。你可以通过添加一个属性动画对象来开始，如下所示：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`QPropertyAnimation` requires two arguments: a widget (or another type of `QObject`
    class) to be animated, and a `bytes` object indicating the property to be animated
    (note that this is a `bytes` object and not a string).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPropertyAnimation`需要两个参数：一个要被动画化的小部件（或其他类型的`QObject`类），以及一个指示要被动画化的属性的`bytes`对象（请注意，这是一个`bytes`对象，而不是一个字符串）。'
- en: 'Next, we need to configure our animation object as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置我们的动画对象如下：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: At the very least, we need to set a `startValue` value and an `endValue` value
    for the property. Naturally, these values must be of the data type required by
    the property. We can also set `duration` in milliseconds (the default is 250).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，我们需要为属性设置一个`startValue`值和一个`endValue`值。当然，这些值必须是属性所需的数据类型。我们还可以设置毫秒为单位的`duration`（默认值为250）。
- en: 'Once configured, we just need to tell the animation to start, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好后，我们只需要告诉动画开始，如下所示：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There are a few requirements that limit what `QPropertyAnimation` objects can
    do:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些要求限制了`QPropertyAnimation`对象的功能：
- en: The object to be animated must be a `QObject` subclass. This includes all widgets
    but excludes some Qt classes such as `QPalette`.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要动画的对象必须是`QObject`的子类。这包括所有小部件，但不包括一些Qt类，如`QPalette`。
- en: The property to be animated must be a Qt property (not just a Python member
    variable).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要动画的属性必须是Qt属性（不仅仅是Python成员变量）。
- en: The property must have read-and-write accessor methods that require only a single
    value. For example, `QWidget.size` can be animated but not `QWidget.width`, because
    there is no `setWidth()` method.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性必须具有读写访问器方法，只需要一个值。例如，`QWidget.size`可以被动画化，但`QWidget.width`不能，因为没有`setWidth()`方法。
- en: 'The property value must be one of the following types: `int`, `float`, `QLine`,
    `QLineF`, `QPoint`, `QPointF`, `QSize`, `QSizeF`, `QRect`, `QRectF`, or `QColor`.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性值必顺为以下类型之一：`int`、`float`、`QLine`、`QLineF`、`QPoint`、`QPointF`、`QSize`、`QSizeF`、`QRect`、`QRectF`或`QColor`。
- en: Unfortunately, for most widgets, these limitations exclude a number of aspects
    that we might want to animate—in particular, colors. Fortunately, we can work
    around this.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于大多数小部件，这些限制排除了我们可能想要动画的许多方面，特别是颜色。幸运的是，我们可以解决这个问题。
- en: Animating colors
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画颜色
- en: As you learned earlier in this chapter, widget colors are not properties of
    the widget – rather they are properties of the palette. The palette cannot be
    animated, because `QPalette` is not a subclass of `QObject`, and because `setColor()`
    requires more than just a single value.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章前面学到的，小部件颜色不是小部件的属性，而是调色板的属性。调色板不能被动画化，因为`QPalette`不是`QObject`的子类，而且`setColor()`需要的不仅仅是一个单一的值。
- en: Colors are something that we'd like to animate, though; to make that happen,
    we need to subclass our widget and make its color settings into Qt properties.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是我们想要动画的东西，为了实现这一点，我们需要对小部件进行子类化，并将其颜色设置为Qt属性。
- en: 'Let''s do that with a button; start a new class at the top of the script, as
    follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个按钮来做到这一点；在脚本的顶部开始一个新的类，如下所示：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have a `QPushButton` subclass with accessor methods for the palette's
    `ButtonText` color. However, note that these are Python methods; in order to animate
    this property, we need `color` to be an actual Qt property. To correct this, we'll
    use the `QtCore.pyqtProperty()` function to wrap our accessor methods and create
    a property on the underlying Qt object.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The property name we use will be the name of the Qt property. The first argument
    passed is the data type required by the property, and the next two arguments are
    the getter and setter methods.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '`pyqtProperty()` can also be used as a decorator, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that, in this approach, both methods must be named identically using
    the property name we intend to create.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our properties are in place, we need to replace our regular `QPushButton`
    objects with `ColorButton` objects:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With these changes made, we can animate the color values, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This works like a charm. We''ve also added a couple of additional configuration
    settings here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`setLoopCount()` will set how many times the animation restarts. A value of
    `-1` will make it loop forever.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setEasingCurve()` changes the curve along which the values are interpolated.
    We''ve chosen `InOutQuad`, which slows the rate of the start and finish of the
    animation.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when you run the script, note that the color fades from white to gray
    and then immediately loops back to white. If we want an animation to move from
    one value to another and then smoothly back again, we can use the `setKeyValue()`
    method to put a value in the middle of the animation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this case, our start and end values are the same, and we've added a value
    at 0.5 (50% of the way through the animation) set to a second color. This animation
    will fade from black to dark red and back again. You can add as many key values
    as you wish and make quite complex animations.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Using animation groups
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we add more and more animations to a GUI, we may find it necessary to group
    them together so that we can control the animations as a group. This can be done
    using the animation group classes, `QParallelAnimationGroup` and `QSequentialAnimationGroup`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Both of these classes allow us to add multiple animations to the group and start,
    stop, pause, and resume the animations as a group.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s group our button animations as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`QParallelAnimationGroup` plays all animations in parallel whenever its `start()`
    method is called. In contrast, `QSequentialAnimationGroup` will playback its animations
    one at a time in the order added, as shown in the following code block:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By adding animation groups to other animation groups as we've done here, we
    can choreograph complex arrangements of animations into one object that can be
    started, stopped, or paused altogether.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Comment out all the other animation `start()` calls and launch the script. Note
    that the button animations start only after the heading animation has finished.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We will explore more uses of `QPropertyAnimation` in *Chapter 12*, *2D Graphics
    with QPainter*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to customize the look and feel of a PyQt application.
    We also learned how to manipulate screen fonts and add images. Additionally, we
    learned how to package image and font resources in a way that is resilient to
    path changes. We also explored how to alter the color and appearance of the application
    using palettes and style sheets, and how to override style methods to implement
    nearly limitless style changes. Finally, we explored widget animation using Qt's
    animation framework and learned how to add custom Qt properties to our classes
    so that we can animate them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to explore the world of multimedia applications
    using the `QtMultimedia` library. You'll learn how to work with cameras to take
    pictures and videos, how to display video content, and how to record and playback
    audio.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: You are preparing to distribute your text editor application, and want to ensure
    that the user is given a monospaced font by default, no matter what platform they
    use. What two ways can you use to accomplish this?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As closely as possible, try to mimic the following text using `QFont`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/07c03999-3b51-4ee3-8a01-aaaf1e4cf5c3.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: Can you explain the difference between `QImage`, `QPixmap`, and `QIcon`?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have defined the following `.qrc` file for your application, run `pyrcc5`,
    and imported the resource library in your script. How would you load this image
    into `QPixmap`?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Using `QPalette`, how would you tile the background of a `QWidget` object with
    the `tile.png` image?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are trying to make a delete button pink using QSS, but it's not working.
    What is wrong with your code?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Which style sheet string will turn the background colors of your `QLineEdit`
    widget black?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Build a simple app with a combo box that allows you to change the Qt style to
    any style installed on your system. Include some other widgets so that you can
    see how they look in the different styles.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You feel very happy about learning how to style PyQt apps and want to create
    a `QProxyStyle` class that will force all pixmaps in a GUI to be `smile.gif`.
    How would you do this? Hint: You will need to research some other drawing methods
    of `QStyle` than the ones discussed in this chapter.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following animation doesn''t work; figure out why it doesn''t work:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Further reading
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: A more detailed description of how fonts are resolved can be found in the `QFont`
    documentation at [https://doc.qt.io/qt-5/qfont.html#details](https://doc.qt.io/qt-5/qfont.html#details)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Qt styling example in C++ ([https://doc.qt.io/qt-5/qtwidgets-widgets-styles-example.html](https://doc.qt.io/qt-5/qtwidgets-widgets-styles-example.html))
    demonstrates how to create a comprehensive Qt Proxy Style
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overview of the Qt's animation framework at [https://doc.qt.io/qt-5/animation-overview.html](https://doc.qt.io/qt-5/animation-overview.html)
    offers additional details on how to use property animations and what their limitations
    are
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
