- en: Styling Qt Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is easy to appreciate the clean, native look that Qt effortlessly provides
    by default. But for less business-like applications, plain gray widgets and bog-standard
    fonts don't always set the right tone. Even the drabbest utility or data entry
    application occasionally benefits from the addition of icons or the judicious
    tweaking of fonts to enhance usability. Fortunately, Qt's flexibility allows us
    to take the look and feel of our application into our own hands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using fonts, images, and icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring colors, style sheets, and styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll need all the requirements listed in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, and the Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you may require PNG, JPEG, or GIF image files to work with; you
    can use those included in the example code at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action:Â [http://bit.ly/2M5OJj6](http://bit.ly/2M5OJj6)
  prefs: []
  type: TYPE_NORMAL
- en: Using fonts, images, and icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin styling our Qt application by customizing the application's fonts,
    displaying some static images, and including dynamic icons. However, before we
    can do this, we'll need to create a **graphical user interface** (**GUI**) that
    we can work with. We'll create a game lobby dialog, which will be used for logging
    into an imaginary multiplayer game called **Fight Fighter**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open a fresh copy of your application template and add the following
    GUI code to `MainWindow.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fairly standard Qt GUI code that you should be familiar with by now;
    we''re saving a few lines of code by putting our inputs in a `dict` object and
    adding them to the layout in a loop, but otherwise, it''s relatively straightforward.
    Depending on your OS and theme settings, the dialog box probably looks something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce8de21f-49a5-46c4-aab8-3f45ba3b8c26.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it's a nice form but it's a bit bland. So, let's explore whether
    we can improve the style.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a font
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we'll tackle is the font. Every `QWidget` class has a `font`
    property, which we can either set in the constructor or by using the `setFont()`
    accessor. The value of `font` must be a `QtGui.QFont` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can create and use a `QFont` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A `QFont` object contains all the attributes that describe the way text will
    be drawn to the screen. The constructor can take any of the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A string indicating the font family
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A float or integer indicating the point size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `QtGui.QFont.FontWeight` constant indicating the weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean indicating whether the font should be italic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The remaining aspects of the font, such as the `stretch` property, can be configured
    using keyword arguments or accessor methods. We can also create a `QFont` object
    with no arguments and configure it programmatically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setting a font on a widget affects not only the widget but also all its child
    widgets. Therefore, we could configure the font for the entire form by setting
    it on `cx_form` rather than setting it on individual widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with missing fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, if all platforms and **operating systems** (**OSes**) shipped with an infinite
    array of identically named fonts, this would be all you'd need to know about `QFont`.
    Unfortunately, that isn't the case. Most systems ship with only a handful of fonts
    built-in and only a few of these are universal across platforms or even different
    versions of a platform. Therefore, Qt has a fallback mechanism for dealing with
    missing fonts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that we ask Qt to use a nonexistent font family, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Qt will not throw an error at this call or even register a warning. Instead,
    after not finding the font family requested, it will fall back to its `defaultFamily`
    property, which utilizes the default font set in the OS or desktop environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QFont` object won''t actually tell us that this has happened; if you query
    it for information, it will only tell you what was configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To discover what font settings are actually being used, we need to pass our
    `QFont` object to a `QFontInfo` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the script, you''ll see that, more than likely, your default screen
    font is actually being used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While this ensures that users won't be left without any text in the window,
    it would be nice if we could give Qt a better idea of what sort of font it should
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by setting the font''s `styleHint` and `styleStrategy` properties,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`styleHint` suggests a general category for Qt to fall back on, which, in this
    case, is the `Fantasy` category. Other options here include `SansSerif`, `Serif`,
    `TypeWriter`, `Decorative`, `Monospace`, and `Cursive`. What these options correspond
    to is dependent on the OS and desktop environment configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: The `styleStrategy` property informs Qt of more technical preferences related
    to the capabilities of the chosen font, such as anti-aliasing, OpenGL compatibility,
    and whether the size will be matched exactly or rounded to the nearest non-scaled
    size. The complete list of strategy options can be found at [https://doc.qt.io/qt-5/qfont.html#StyleStrategy-enum](https://doc.qt.io/qt-5/qfont.html#StyleStrategy-enum).
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting these properties, check the font again to see whether anything
    has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your system''s configuration, you should see different results
    from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: On this system, `Fantasy` has been interpreted to mean `Impact`, and the `PreferQuality`
    strategy flag has forced the initially odd 15.233 point size to be a nice round
    `15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, depending on the fonts available on your system, your application
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0ac336f7-5ade-4387-a6c5-48a27c8fd1b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Fonts can also be bundled with the application; see the *Using Qt resource files*
    section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt offers a number of classes related to the use of images in an application,
    but, for simply displaying a picture in your GUI, the most appropriate is `QPixmap`.
    `QPixmap` is a display-optimized image class, which can load many common image
    formats including PNG, BMP, GIF, and JPEG.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create one, we simply need to pass `QPixmap` a path to an image file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once loaded, a `QPixmap` object can be displayed in a `QLabel` or `QButton`
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that labels can only display a string or a pixmap, but not both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being optimized for display, the `QPixmap` objects offer only minimal editing
    functionality; however, we can do simple transformations such as scaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've used the pixmap's `scaledToWidth()` method to restrict
    the logo's width to `400` pixels using a smooth transformation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why `QPixmap` objects are so limited is that they are actually stored
    in the display server's memory. The `QImage` class is similar but stores data
    in application memory, so that it can be edited more extensively. We'll explore
    this class more in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), Creating
    *2D Graphics with QPainter*.
  prefs: []
  type: TYPE_NORMAL
- en: '`QPixmap` also offers the handy capability to generate simple colored rectangles,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By specifying a size in the constructor and using the `fill()` method, we can
    create a simple, colored rectangle pixmap. This is useful for displaying color
    swatches or to use as a quick-and-dirty image stand-in.
  prefs: []
  type: TYPE_NORMAL
- en: Using icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now consider an icon on a toolbar or in a program menu. When the menu item is
    disabled, you expect the icon to be grayed out in some way. Likewise, if a user
    hovers over the button or item using a mouse cursor, you might expect it to be
    highlighted. To encapsulate this type of state-dependent image display, Qt provides
    the `QIcon` class. A `QIcon` object contains a collection of pixmaps that are
    each mapped to a widget state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can create a `QIcon` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After creating the icon object, we use its `addPixmap()` method to assign a
    `QPixmap` object to a widget state. These states include `Normal`, `Active`, `Disabled`,
    and `Selected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `connect_icon` icon will now be a red square when disabled, or a green
    square when enabled. Let''s add it to our submit button and add some logic to
    toggle the button''s status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you run the script at this point, you'll see that the red square appears
    in the submit button until the `Server` field contains data, at which point it
    automatically switches to green. Notice that we don't have to tell the icon object
    itself to switch states; once assigned to the widget, it tracks any changes in
    the widget's state.
  prefs: []
  type: TYPE_NORMAL
- en: Icons can be used with the `QPushButton`, `QToolButton`, and `QAction` objects;
    the `QComboBox`, `QListView`, `QTableView`, and `QTreeView` items; and most other
    places where you might reasonably expect to have an icon.
  prefs: []
  type: TYPE_NORMAL
- en: Using Qt resource files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A significant problem with using image files in a program is making sure the
    program can find them at runtime. Paths passed into a `QPixmap` constructor or
    a `QIcon` constructor are interpreted as absolute (that is, if they begin with
    a drive letter or path separator), or as relative to the current working directory
    (which you cannot control). For example, try running your script from somewhere
    other than the code directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You'll find that your images are all missing! `QPixmap` does not complain when
    it cannot find a file, it just doesn't show anything. Without an absolute path
    to the images, you'll only be able to find them if the script is run from the
    exact directory to which your paths are relative.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, specifying absolute paths means that your program will only work
    from one location on the filesystem, which is a major problem if you plan to distribute
    it to multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyQt offers us a solution to this problem in the form of a **PyQt Resource
    file**, which we can create using the **PyQt resource compiler** tool. The basic
    procedure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Write an XML-format **Qt Resource Collection** file (`.qrc`) containing the
    paths of all the files that we want to include
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `pyrcc5` tool to serialize and compress these files into data contained
    in a Python module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the resulting Python module into our application script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can reference our resources using a special syntax
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s step through this processâsuppose that we have some team badges in the
    form of PNG files that we want to include in our program. Our first step is to
    create the `resources.qrc` file, which looks like the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We've placed this file in the same directory as the image files listed in the
    script. Note that we've added a `prefix` value of `teams`. Prefixes allow you
    to organize resources into categories. Additionally, notice that the last file
    has an alias specified. In our program, we can use this alias rather than the
    actual name of the file to access this resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the command line, we''ll run `pyrcc5`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The syntax here is `pyrcc5 -o outputFile.py inputFile.qrc`. This command should
    generate a Python file containing your resource data. If you take a moment to
    open the file and examine it, you'll find it's mostly just a large `bytes` object
    assigned to the `qt_resource_data` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our main script, we just need to import this file in the same way as
    any other Python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The file doesn't have to be called `resources.py`;Â in fact, any name will suffice.
    You just need to import it, and the code in the file will make sure that the resources
    are available to Qt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the resource file is imported, we can specify pixmap paths using the
    resource syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, the syntax is `:/prefix/file_name_or_alias.extension`.
  prefs: []
  type: TYPE_NORMAL
- en: Because our data is stored in a Python file, we can place it inside a Python
    library and it will use Python's standard import resolution rules to locate the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Qt resource files and fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource files aren't limited to images; in fact, they can be used to include
    just about any kind of binary, including font files. For example, suppose that
    we want to include our favorite font in the program to ensure that it looks right
    on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with images, we start by including the font file in the `.qrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added a prefix of `fonts` and included a reference to the `LiberationSans-Regular.ttf`
    file. After running `pyrcc5` against this file, the font is bundled into our `resources.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this font in the code, we start by adding it to the font database, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`QFontDatabase.addApplicationFont()` inserts the passed font file into the
    application''s font database and returns an ID number. We can then use that ID
    number to determine the font''s family string; this can be passed to `QFont`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to check the license on your font before distributing it with your
    application! Remember that not all fonts are free to redistribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our form is certainly looking more game-like now; run the application and it
    should look similar the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/93a4b1be-2c07-49b2-9a87-7d2b740a59fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring colors, style sheets, and styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fonts and icons have improved the look of our form, but now it''s time to ditch
    those institutional gray tones and replace them with some color. In this section,
    we''re going to look at three different approaches that Qt offers for customizing
    application colors: manipulating the **palette**, using **style sheets**, and
    overriding the **application style**.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing colors with palettes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A palette, represented by the `QPalette` class, is a collection of colors and
    brushes that are mapped to color roles and color groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s unpack that statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, **color** is a literal color value, represented by a `QColor` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **brush** combines a particular color with a style, such as a pattern, gradient,
    or texture, and is represented by a `QBrush` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **color role** represents the way a widget uses the color, such as in the
    foreground, in the background, or in the border
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **color group** refers to the interaction state of the widget; it can be
    `Normal`, `Active`, `Disabled`, or `Inactive`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a widget is painted on the screen, Qt's painting system consults the palette
    to determine the color and brush used to render each piece of the widget. To customize
    this, we can create our own palette and assign it to a widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we need to get a `QPalette` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While we could just create a `QPalette` object directly, the Qt documentation
    recommends that we call `palette()` on our running `QApplication` instance to
    retrieve a copy of the palette for the currently configured style.
  prefs: []
  type: TYPE_NORMAL
- en: You can always retrieve a copy of your `QApplication` object by calling `QApplication.instance()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the palette, let''s start overriding some of the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`QtGui.QPalette.Button` and `QtGui.QPalette.ButtonText` are color role constants
    and, as you might guess, they represent the background and foreground colors,
    respectively, of all the Qt button classes. We''re overriding them with new colors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To override the color for a particular button state, we need to pass in a color
    group constant as the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're changing the colors used when a button is in the `Disabled`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this new palette, we have to assign it to a widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`setPalette()` assigns the provided palette to the widget and all the child
    widgets as well. So, rather than assigning this to individual widgets, we could
    create a single palette and assign it to our `QMainWindow` class to apply it to
    all objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with QBrush objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want something fancier than a solid color, then we can use a `QBrush`
    object. Brushes are capable of filling colors in patterns, gradients, or textures
    (that is, image-based patterns).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a brush that paints a white stipple fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Dense2Pattern` is one of 15 patterns available. (You can refer to [https://doc.qt.io/qt-5/qt.html#BrushStyle-enum](https://doc.qt.io/qt-5/qt.html#BrushStyle-enum)
    for the full list.) Most of these are varying degrees of stippling, cross-hatching,
    or alternating line patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns have their uses, but gradient-based brushes are perhaps more interesting
    for modern styling. However, creating one is a little more involved, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To use a gradient in a brush, we first have to create a gradient object. Here,
    we've created a `QLinearGradient` object, which implements a basic linear gradient.
    The arguments are the starting and ending coordinates for the gradient, which
    we've specified as the top-left (0, 0), and the bottom-right (width, height) of
    the main window.
  prefs: []
  type: TYPE_NORMAL
- en: Qt also offers the `QRadialGradient` and `QConicalGradient` classes for additional
    gradient options.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the object, we then specify color stops using `setColorAt()`.
    The first argument is a float value between 0 and 1 that specifies the percentage
    between the start and finish, and the second argument is the `QColor` object that
    the gradient should be at that point.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the gradient, we pass it to the `QBrush` constructor to create
    a brush that paints with our gradient.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now apply our brushes to a palette using the `setBrush()` method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Just as with `QPalette.setColor()`, we can assign our brush with or without
    specifying a specific color group. In this case, our gradient brush will be used
    to paint the main window regardless of its state, but our dotted brush will only
    be used when the widget is active (that is, the currently active window).
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the appearance with Qt Style Sheets (QSS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For developers who have worked with web technologies, styling an application
    using palette, brush, and color objects may seem verbose and unintuitive. Fortunately,
    Qt offers you an alternative known as QSS, which is very similar to the **Cascading
    Style Sheets** (**CSS**) used in web development. It is an easy way to apply some
    simple changes to our widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use QSS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, a style sheet is just a string containing style directives, which we can
    assign to a widget's `styleSheet` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax, which should be familiar to anyone who has worked with CSS, is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the program at this point, you''ll find, to your dismay, that (depending
    on your system theme) it may look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5aa10114-bea6-4980-b9a0-6d011e653a36.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the interface has mostly gone black apart from the text and images. Our
    buttons and checkbox, in particular, are indistinguishable from the background.
    So, why did this happen?
  prefs: []
  type: TYPE_NORMAL
- en: Well, when you add a QSS style to a widget class, the style change carries down
    to all its subclasses. Since we styled `QWidget`, all the other `QWidget` derived
    classes (such as `QCheckbox` and `QPushButton`) inherited this style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this by overriding the styles for those subclasses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Just as with CSS, applying a style to a more specific class overrides the more
    general case. For example, our `QPushButton` background color overrides the `QWidget`
    background color.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of colons with `QCheckBox`âthe double colon in QSS allows us to
    reference a subelement of a widget. In this case, this is the indicator portion
    of the `QCheckBox` class (as opposed to its label portion). We can also use a
    single colon to reference a widget state, as, in this case, we're setting a different
    style depending on whether or not the checkbox is checked or unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to restrict a change to a particular class only and not any of
    its subclasses, simply add a period (`.`) to the name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This preceding example also demonstrates how to use images in QSS. Just like
    in CSS, we can provide a file path that is wrapped in the `url()` function.
  prefs: []
  type: TYPE_NORMAL
- en: QSS also accepts resource paths if you've serialized your images with `pyrcc5`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to apply a style to a particular widget rather than a whole class
    of widgets, there are two ways to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is to rely on the `objectName` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In our style sheet, an object name must be preceded by a
  prefs: []
  type: TYPE_NORMAL
- en: '`#` symbol to identify it as an object name rather than a class.'
  prefs: []
  type: TYPE_NORMAL
- en: The other way to set styles on individual widgets is to call t
  prefs: []
  type: TYPE_NORMAL
- en: 'he widget''s `setStyleSheet()` method with some style sheet directives, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If we want to apply a style directly to the widget we're calling, we don't need
    to specify class names or object names; we can simply pass in the properties and
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having made all these changes, our application now looks a lot more like a
    game GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec30b7cf-f46b-4f79-955c-9af210c2281f.png)'
  prefs: []
  type: TYPE_IMG
- en: The downside of QSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, QSS is a very powerful styling method and is accessible for
    any developer who has worked with web development; however, it does have some
    disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: QSS is an abstraction over the palette and style objects and must be translated
    to the actual system. This makes them slower for large applications, and it also
    means that there is no default style sheet that you can retrieve and edit â you're
    starting from scratch each time.
  prefs: []
  type: TYPE_NORMAL
- en: As we've already seen, QSS can have unpredictable results when applied to high-level
    widgets, since it inherits through the class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, bear in mind that QSS is a modest subset of CSS 2.0 with a few additions
    or changesâit is not CSS. Therefore, transitions, animations, flexbox containers,
    relative units, and other modern CSS goodies are completely absent. So, while
    web developers may find its basic syntax familiar, the limited set of options
    may be frustrating and its different behaviors confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the appearance with QStyle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Palettes and style sheets can take us a long way towards customizing the look
    of a Qt application, and for most cases, that's all you'll ever need. To really
    dig into the heart of a Qt application's appearance, we need to understand the
    style system.
  prefs: []
  type: TYPE_NORMAL
- en: Every running instance of a Qt application has a single style, which is in charge
    of telling the graphics system how to draw each widget or GUI component. Styles
    are dynamic and pluggable, so that different OS platforms have different styles,
    and users can install their own Qt styles to use in Qt applications. This is how
    Qt applications are able to have a native look on different OSes.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started
    with PyQt,* we learned that `QApplication` should be passed a copy of `sys.argv`
    when created, so that it can process some Qt-specific arguments. One such argument
    is `-style`, which allows the user to set a custom style for their Qt application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s run the calendar application from [Chapter 3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml),
    *Handling Events with Signals and Slots,* with the `Windows` style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try it using the `Fusion` style, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice the difference in appearance, especially in the input controls.
  prefs: []
  type: TYPE_NORMAL
- en: Capitalization counts with styles; **windows** is not a valid style, whereas
    **Windows** is!
  prefs: []
  type: TYPE_NORMAL
- en: 'The styles that are available on common OS platforms are shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| OS | Styles |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Windows 10 | `windowsvista`, `Windows`, and `Fusion` |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | `macintosh`, `Windows`, and `Fusion` |'
  prefs: []
  type: TYPE_TB
- en: '| Ubuntu 18.04 | `Windows` and `Fusion` |'
  prefs: []
  type: TYPE_TB
- en: On many Linux distributions, additional Qt styles are available from the package
    repositories. A list of currently installed styles can be obtained by calling
    `QtWidgets.QStyleFactory.keys()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Styles can also be set inside the application itself. In order to retrieve
    a style class, we need to use the `QStyleFactory` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`QStyleFactory.create()` will attempt to find an installed style with the given
    name and return a `QCommonStyle` object; if the style requested is not found,
    then it will return `None`. The style object can then be used to set the `style`
    property of our `QApplication` object. (A value of `None` will just cause it to
    use the default.)'
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to set a style inside the application, it's best to do it as early
    as possible before any widgets are drawn to avoid visual glitches.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Qt styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Qt style is an involved process that requires a deep understanding
    of Qt's widgets and painting system, and few developers will ever need to create
    one. We might, however, want to override some aspects of the running style to
    accomplish some things that aren't possible through manipulation of the palette
    or style sheets. We can do this by subclassing `QtWidgets.QProxyStyle`.
  prefs: []
  type: TYPE_NORMAL
- en: A proxy style is an overlay that we can use to override methods of the actual
    style that's running. In this way, it doesn't matter what actual style the user
    chooses, our proxy style's methods (where implemented) will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a proxy style that forces all the screen text to
    be in uppercase, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`drawItemText()` is the method called on the style whenever text must be drawn
    to the screen. It receives a number of arguments, but the one we''re most concerned
    with is the `text` argument that is to be drawn. We''re simply going to intercept
    this text and make it uppercase before passing all the arguments back to `super().drawTextItem()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This proxy style can then be applied to our `QApplication` object in the same
    way as any other style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program at this point, you'll see that all the text is now uppercase.
    Mission accomplished!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's try something a bit more ambitious. Let's change all our `QLineEdit`
    entry boxes to a green rounded rectangle outline. So, how do we go about doing
    this in a proxy style?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to figure out what element of the widget we''re trying to
    modify. These can be found as enum constants of the `QStyle` class, and they''re
    divided into three main classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PrimitiveElement`, which includes fundamental, non-interactive GUI elements
    such as frames or backgrounds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ControlElement`, which includes interactive elements such as buttons or tabs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComplexControl`, which includes complex interactive elements such as combo
    boxes and sliders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these classes of items is drawn by a different method of `QStyle`; in
    this case, it turns out that we want to modify the `PE_FrameLineEdit` element,
    which is a primitive element (as indicated by the `PE_` prefix). This type of
    element is drawn by `QStyle.drawPrimitive()`, so we'll need to override that method
    in our proxy style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this method to `StyleOverrides`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To control the drawing of an element, we need to issue commands to its `painter`
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Painter objects and the drawing will be fully covered in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml),
    *Creating 2D Graphics with QPainter,* but, for now, understand that the preceding
    code draws a green rounded rectangle if the `element` argument matches `QStyle.PE_FrameLineEdit`.
    Otherwise, it passes the arguments to the superclass's `drawPrimitive()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we do not call the superclass method after drawing our rectangle.
    If we did, then the superclass would draw its style-defined widget element on
    top of our green rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this example, while working with `QProxyStyle` is considerably
    more esoteric than using palettes or style sheets, it does give us almost limitless
    control over how our widgets appear.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter whether you use QSS or styles and palettes to restyle an application;
    however, it is highly advised that you stick to one or the other. Otherwise, your
    style modifications can fight with one another and give unpredictable results
    across platforms and desktop settings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing quite adds a sophisticated edge to a GUI like the tasteful use of animations.
    Dynamic GUI elements that fade smoothly between changes in color, size, or position
    can add a modern touch to any interface.
  prefs: []
  type: TYPE_NORMAL
- en: Qt's animation framework allows us to create simple animations on our widgets
    using the `QPropertyAnimation` class. In this section, we'll explore how to use
    this class to spice up our game lobby with some animations.
  prefs: []
  type: TYPE_NORMAL
- en: Because Qt style sheets override another widget- and palette-based styling,
    you will need to comment out all the style sheet code for these animations to
    work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Basic property animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `QPropertyAnimation` object is used to animate a single Qt property of a widget.
    The class automatically creates an interpolated series of steps between two numeric
    property values and applies the changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s animate our logo so that it scrolls out from left to right.
    You can begin by adding a property animation object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`QPropertyAnimation` requires two arguments: a widget (or another type of `QObject`
    class) to be animated, and aÂ `bytes` object indicating the property to be animated
    (note that this is a `bytes` object and not a string).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to configure our animation object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: At the very least, we need to set a `startValue` value and an `endValue` value
    for the property. Naturally, these values must be of the data type required by
    the property. We can also set `duration` in milliseconds (the default is 250).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once configured, we just need to tell the animation to start, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few requirements that limit what `QPropertyAnimation` objects can
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: The object to be animated must be a `QObject` subclass. This includes all widgets
    but excludes some Qt classes such as `QPalette`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property to be animated must be a Qt property (not just a Python member
    variable).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property must have read-and-write accessor methods that require only a single
    value. For example, `QWidget.size` can be animated but not `QWidget.width`, because
    there is no `setWidth()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The property value must be one of the following types: `int`, `float`, `QLine`,
    `QLineF`, `QPoint`, `QPointF`, `QSize`, `QSizeF`, `QRect`, `QRectF`, or `QColor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, for most widgets, these limitations exclude a number of aspects
    that we might want to animateâin particular, colors. Fortunately, we can work
    around this.
  prefs: []
  type: TYPE_NORMAL
- en: Animating colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned earlier in this chapter, widget colors are not properties of
    the widget â rather they are properties of the palette. The palette cannot be
    animated, because `QPalette` is not a subclass of `QObject`, and because `setColor()`
    requires more than just a single value.
  prefs: []
  type: TYPE_NORMAL
- en: Colors are something that we'd like to animate, though; to make that happen,
    we need to subclass our widget and make its color settings into Qt properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do that with a button; start a new class at the top of the script, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a `QPushButton` subclass with accessor methods for the palette's
    `ButtonText` color. However, note that these are Python methods; in order to animate
    this property, we need `color` to be an actual Qt property. To correct this, we'll
    use the `QtCore.pyqtProperty()` function to wrap our accessor methods and create
    a property on the underlying Qt object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The property name we use will be the name of the Qt property. The first argument
    passed is the data type required by the property, and the next two arguments are
    the getter and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`pyqtProperty()` can also be used as a decorator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, in this approach, both methods must be named identically using
    the property name we intend to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our properties are in place, we need to replace our regular `QPushButton`
    objects with `ColorButton` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes made, we can animate the color values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This works like a charm. We''ve also added a couple of additional configuration
    settings here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setLoopCount()` will set how many times the animation restarts. A value of
    `-1` will make it loop forever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setEasingCurve()` changes the curve along which the values are interpolated.
    We''ve chosen `InOutQuad`, which slows the rate of the start and finish of the
    animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when you run the script, note that the color fades from white to gray
    and then immediately loops back to white. If we want an animation to move from
    one value to another and then smoothly back again, we can use the `setKeyValue()`
    method to put a value in the middle of the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this case, our start and end values are the same, and we've added a value
    at 0.5 (50% of the way through the animation) set to a second color. This animation
    will fade from black to dark red and back again. You can add as many key values
    as you wish and make quite complex animations.
  prefs: []
  type: TYPE_NORMAL
- en: Using animation groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we add more and more animations to a GUI, we may find it necessary to group
    them together so that we can control the animations as a group. This can be done
    using the animation group classes, `QParallelAnimationGroup` and `QSequentialAnimationGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these classes allow us to add multiple animations to the group and start,
    stop, pause, and resume the animations as a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s group our button animations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`QParallelAnimationGroup` plays all animations in parallel whenever its `start()`
    method is called. In contrast, `QSequentialAnimationGroup` will playback its animations
    one at a time in the order added, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: By adding animation groups to other animation groups as we've done here, we
    can choreograph complex arrangements of animations into one object that can be
    started, stopped, or paused altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Comment out all the other animation `start()` calls and launch the script. Note
    that the button animations start only after the heading animation has finished.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore more uses of `QPropertyAnimation` in *Chapter 12*, *2D Graphics
    with QPainter*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to customize the look and feel of a PyQt application.
    We also learned how to manipulate screen fonts and add images. Additionally, we
    learned how to package image and font resources in a way that is resilient to
    path changes. We also explored how to alter the color and appearance of the application
    using palettes and style sheets, and how to override style methods to implement
    nearly limitless style changes. Finally, we explored widget animation using Qt's
    animation framework and learned how to add custom Qt properties to our classes
    so that we can animate them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to explore the world of multimedia applications
    using the `QtMultimedia` library. You'll learn how to work with cameras to take
    pictures and videos, how to display video content, and how to record and playback
    audio.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You are preparing to distribute your text editor application, and want to ensure
    that the user is given a monospaced font by default, no matter what platform they
    use. What two ways can you use to accomplish this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As closely as possible, try to mimic the following text using `QFont`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/07c03999-3b51-4ee3-8a01-aaaf1e4cf5c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Can you explain the difference between `QImage`, `QPixmap`, and `QIcon`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have defined the following `.qrc` file for your application, run `pyrcc5`,
    and imported the resource library in your script. How would you load this image
    into `QPixmap`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Using `QPalette`, how would you tile the background of a `QWidget` object with
    the `tile.png` image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are trying to make a delete button pink using QSS, but it's not working.
    What is wrong with your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Which style sheet string will turn the background colors of your `QLineEdit`
    widget black?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Build a simple app with a combo box that allows you to change the Qt style to
    any style installed on your system. Include some other widgets so that you can
    see how they look in the different styles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You feel very happy about learning how to style PyQt apps and want to create
    a `QProxyStyle` class that will force all pixmaps in a GUI to be `smile.gif`.
    How would you do this? Hint: You will need to research some other drawing methods
    of `QStyle` than the ones discussed in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following animation doesn''t work; figure out why it doesn''t work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A more detailed description of how fonts are resolved can be found in the `QFont`
    documentation at [https://doc.qt.io/qt-5/qfont.html#details](https://doc.qt.io/qt-5/qfont.html#details)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Qt styling example in C++ ([https://doc.qt.io/qt-5/qtwidgets-widgets-styles-example.html](https://doc.qt.io/qt-5/qtwidgets-widgets-styles-example.html))
    demonstrates how to create a comprehensive Qt Proxy Style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overview of the Qt's animation framework at [https://doc.qt.io/qt-5/animation-overview.html](https://doc.qt.io/qt-5/animation-overview.html)
    offers additional details on how to use property animations and what their limitations
    are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
