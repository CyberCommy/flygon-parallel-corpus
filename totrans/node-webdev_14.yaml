- en: Deploying Node.js Microservices with Docker
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker部署Node.js微服务
- en: Now that we've experienced the traditional Linux way to deploy an application,
    let's turn to Docker, which is a popular new way to manage application deployment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经体验了传统的Linux部署应用程序的方式，让我们转向Docker，这是一种流行的新的应用程序部署方式。
- en: Docker ([http://docker.com](http://docker.com)) is a cool new tool in the software
    industry. It is described as *an open platform for distributed applications for
    developers and sysadmins*. It is designed around Linux containerization technology
    and focuses on describing the configuration of software on any variant of Linux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Docker（http://docker.com）是软件行业中一个很酷的新工具。它被描述为*面向开发人员和系统管理员的分布式应用程序的开放平台*。它是围绕Linux容器化技术设计的，并专注于描述在任何Linux变体上的软件配置。
- en: A Docker container is a running instantiation of a Docker image. A Docker image
    is a bundle containing a specific Linux OS, system configuration, and application
    configuration. Docker images are described using a **Dockerfile**, which is a
    fairly simple-to-write script describing how to build a Docker image. The Dockerfile
    starts by specifying a *base image* from which to build, meaning we derive Docker
    images from other images. The rest of the Dockerfile describes what files to add
    to the image, which commands to run in order to build or configure the image,
    which network ports to expose, which directories to mount in the image, and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器是Docker镜像的运行实例。Docker镜像是一个包含特定Linux操作系统、系统配置和应用程序配置的捆绑包。Docker镜像使用Dockerfile来描述，这是一个相当简单的编写脚本，描述如何构建Docker镜像。Dockerfile首先通过指定一个基础镜像来开始构建，这意味着我们从其他镜像派生Docker镜像。Dockerfile的其余部分描述了要添加到镜像中的文件，要运行的命令以构建或配置镜像，要公开的网络端口，要在镜像中挂载的目录等等。
- en: Docker images are stored on a Docker Registry server, with each image stored
    in its own repository. The largest registry is Docker Hub, but there are also
    third-party registries available, including registry servers that you can install
    on your own hardware. Docker images can be uploaded to a repository, and, from
    the repository, deployed to any Docker server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像存储在Docker注册服务器上，每个镜像存储在自己的存储库中。最大的注册表是Docker Hub，但也有第三方注册表可用，包括您可以安装在自己硬件上的注册服务器。Docker镜像可以上传到存储库，并且可以从存储库部署到任何Docker服务器。
- en: We instantiate a Docker image to launch a Docker container. Typically, launching
    a container is very fast, and often, containers are instantiated for a short time
    and then discarded when no longer needed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化一个Docker镜像来启动一个Docker容器。通常，启动容器非常快速，而且通常情况下，容器会在短时间内实例化，然后在不再需要时被丢弃。
- en: A running container feels like a virtual server running on a virtual machine.
    However, Docker containerization is very different from a virtual machine system
    such as VirtualBox or Multipass. A container is not a virtualization of a complete
    computer. Instead, it is an extremely lightweight shell creating the appearance
    of an installed OS. For example, the processes running inside the container are
    actually running on the host OS with certain Linux technologies (cgroups, kernel
    namespaces, and so on) creating the illusion of running a specific Linux variant.
    Your host OS could be Ubuntu and the container OS could be Fedora or OpenSUSE,
    or even Windows; Docker makes it all work.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的容器感觉像是在虚拟机上运行的虚拟服务器。然而，Docker容器化与诸如VirtualBox或Multipass之类的虚拟机系统非常不同。容器不是完整计算机的虚拟化。相反，它是一个极其轻量级的外壳，创建了已安装操作系统的外观。例如，容器内运行的进程实际上是在主机操作系统上运行的，使用某些Linux技术（cgroups、内核命名空间等）创建了运行特定Linux变体的幻觉。您的主机操作系统可以是Ubuntu，容器操作系统可以是Fedora或OpenSUSE，甚至是Windows；Docker使所有这些都能运行。
- en: While Docker is primarily targeted at x86 flavors of Linux, it is available
    on several ARM-based OSes, as well as other processors. You can even run Docker
    on single-board computers, such as Raspberry Pi, for hardware-oriented **Internet
    of Things** (**IoT**) projects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker主要针对x86版本的Linux，但它也适用于几种基于ARM的操作系统，以及其他处理器。甚至可以在单板计算机上运行Docker，比如树莓派，用于面向硬件的物联网（IoT）项目。
- en: 'The Docker ecosystem contains many tools, and their number is increasing rapidly.
    For our purposes, we''ll focus on the following two tools:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker生态系统包含许多工具，它们的数量正在迅速增加。对于我们的目的，我们将专注于以下两个工具：
- en: '**Docker Engine**: This is the core execution system that orchestrates everything.
    It runs on a Linux host system, exposing a network-based API that client applications
    use to make Docker requests, such as building, deploying, and running containers.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker引擎**：这是协调一切的核心执行系统。它在Linux主机系统上运行，公开一个基于网络的API，客户端应用程序使用它来进行Docker请求，比如构建、部署和运行容器。'
- en: '**Docker Compose**: This helps you define, in a single file, a multi-container
    application with all of its dependencies defined.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Compose**：这有助于您在一个文件中定义一个多容器应用程序及其所有定义的依赖关系。'
- en: There are other tools closely associated with Docker, such as Kubernetes, but
    it all starts with building a container to house your application. By learning
    about Docker, we learn how to containerize an application, a skill we can use
    with both Docker and Kubernetes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他与Docker密切相关的工具，比如Kubernetes，但一切都始于构建一个容器来容纳您的应用程序。通过学习Docker，我们学会了如何将应用程序容器化，这是我们可以在Docker和Kubernetes中使用的技能。
- en: Learning how to use Docker is a gateway to learning about other popular systems,
    such as Kubernetes or AWS ECS. These are two popular orchestration systems for
    managing container deployments at a large scale on cloud-hosting infrastructure.
    Typically, the containers are Docker containers, but they are deployed and managed
    by other systems, whether that is Kubernetes, ECS, or Mesos. That makes learning
    how to use Docker an excellent starting point for learning these other systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用Docker是学习其他流行系统的入门，比如Kubernetes或AWS ECS。这两个是用于在云托管基础设施上大规模管理容器部署的流行编排系统。通常，容器是Docker容器，但它们是由其他系统部署和管理的，无论是Kubernetes、ECS还是Mesos。这使得学习如何使用Docker成为学习这些其他系统的绝佳起点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing Docker on our laptop
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的笔记本电脑上安装Docker
- en: Developing our own Docker containers and using third-party containers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发我们自己的Docker容器并使用第三方容器
- en: Setting up the user authentication service and its database in Docker
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中设置用户认证服务及其数据库
- en: Setting up the Notes service and its database in Docker
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中设置Notes服务及其数据库
- en: Deploying MySQL instances in Docker infrastructure, and data persistence for
    applications such as databases in Docker
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中部署MySQL实例，并为Docker中的应用程序提供数据持久性，例如数据库
- en: Using Docker Compose to describe the Docker deployment of a full application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose描述完整应用程序的Docker部署
- en: Scaling container instances in Docker infrastructure and using Redis to mitigate
    scaling issues
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker基础设施中扩展容器实例并使用Redis来缓解扩展问题
- en: The first task is to duplicate the source code from the previous chapter. It's
    suggested that you create a new directory, `chap11`, as a sibling of the `chap10` directory
    and copy everything from `chap10` to `chap11`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是复制上一章的源代码。建议您创建一个新目录`chap11`，作为`chap10`目录的兄弟目录，并将`chap10`中的所有内容复制到`chap11`中。
- en: By the end of this chapter, you will have a solid grounding of using Docker,
    creating Docker containers, and using Docker Compose to manage the services required
    by the Notes application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对使用Docker、创建Docker容器以及使用Docker Compose管理Notes应用程序所需的服务有扎实的基础。
- en: With the help of Docker, we will design, on our laptop, the system shown in
    the diagram in [Chapter 10](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml), *Deploying
    Node.js Applications to Linux Servers*. That chapter, this one, and [Chapter 12](8551a26c-6834-4df6-b392-60a15c20f6ff.xhtml), *Deploying
    a Docker Swarm to AWS EC2 with Terraform*, form an arc covering three styles of
    Node.js deployment to servers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 借助Docker，我们将在笔记本电脑上设计[第10章](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml)中显示的系统，*将Node.js应用程序部署到Linux服务器*。这一章，以及[第12章](8551a26c-6834-4df6-b392-60a15c20f6ff.xhtml)，*使用Terraform在AWS
    EC2上部署Docker Swarm*，形成了一个覆盖Node.js三种部署风格的弧线。
- en: Setting up Docker on your laptop or computer
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的笔记本电脑或计算机上设置Docker
- en: 'The best place to learn how to install Docker on your laptop is the Docker documentation.
    What we''re looking for is the Docker **Community Edition** (**CE**), which is
    all we need:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何在笔记本电脑上安装Docker的最佳地方是Docker文档。我们要找的是Docker **Community Edition**（CE），这就是我们所需要的：
- en: macOS installation: [https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS安装：[https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
- en: Windows installation: [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows安装：[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
- en: Ubuntu installation: [https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu安装：[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
- en: Instructions are also available for several other distributions. Some useful
    post-install Linux instructions are available at [https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几种发行版的安装说明。一些有用的Linux后安装说明可在[https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/)找到。
- en: Docker runs natively on Linux, and the installation is simply the Docker daemon
    and command-line tools. To run Docker on macOS or Windows, you need to install
    the Docker for Windows or Docker for Mac applications. These applications manage
    a virtual Linux environment in a lightweight virtual machine, within which is
    a Docker Engine instance running on Linux. In the olden days (a few years ago),
    we had to handcraft that setup. Thanks must be given to the Docker team, who have made
    this as easy as installing an application, and all the complexity is hidden away.
    The result is very lightweight, and Docker containers can be left running in the
    background with little impact.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在Linux上本地运行，安装只是Docker守护程序和命令行工具。要在macOS或Windows上运行Docker，您需要安装Docker
    for Windows或Docker for Mac应用程序。这些应用程序在轻量级虚拟机中管理一个虚拟Linux环境，在其中运行着一个在Linux上运行的Docker
    Engine实例。在过去（几年前），我们不得不手工设置这个环境。必须感谢Docker团队，他们使得这一切像安装应用程序一样简单，所有复杂性都被隐藏起来。结果非常轻量级，Docker容器可以在后台运行而几乎不会产生影响。
- en: Let's now learn how to install Docker on a Windows or macOS machine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习如何在Windows或macOS机器上安装Docker。
- en: Installing and starting Docker with Docker for Windows or macOS
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker for Windows或macOS安装和启动Docker
- en: The Docker team has made installing Docker on Windows or macOS very easy. You
    simply download an installer and, as with most other applications, you run the
    installer. It takes care of installation and provides you with an application
    icon that is used to launch Docker. On Linux, the installation is a little more
    involved, so it is best to read and follow the official instructions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Docker团队使得在Windows或macOS上安装Docker变得非常简单。您只需下载安装程序，并像大多数其他应用程序一样运行安装程序。它会负责安装并为您提供一个应用程序图标，用于启动Docker。在Linux上，安装稍微复杂一些，因此最好阅读并遵循官方说明。
- en: Starting Docker for Windows or macOS is very simple, once you've followed the
    installation instructions. You simply find and double-click on the application
    icon. There are settings available so that Docker automatically launches every
    time you start your laptop.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows或macOS上启动Docker非常简单，一旦您遵循了安装说明。您只需找到并双击应用程序图标。有可用的设置，使得Docker在每次启动笔记本电脑时自动启动。
- en: On both Docker for Windows and Docker for Mac, the CPU must support **virtualization**.
    Bundled inside Docker for Windows and Docker for Mac is an ultra-lightweight hypervisor,
    which, in turn, requires virtualization support from the CPU.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker for Windows和Docker for Mac上，CPU必须支持**虚拟化**。Docker for Windows和Docker
    for Mac中内置了一个超轻量级的hypervisor，而这又需要CPU的虚拟化支持。
- en: For Windows, this may require a BIOS configuration. Refer to [https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization-must-be-enabled](https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization-must-be-enabled) for
    more information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: For macOS, this requires hardware from 2010 or later, with Intel's hardware
    support for **Memory Management Unit** (**MMU**) virtualization, including **Extended
    Page Tables** (**EPTs**) and unrestricted mode. You can check for this support
    by running `sysctl kern.hv_support`. It also requires macOS 10.11 or later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Having installed the software, let's try it out and familiarize ourselves with
    Docker.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Familiarizing ourselves with Docker
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the setup accomplished, we can use the local Docker instance to create
    Docker containers, run a few commands, and, in general, learn how to use it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'As in so many software journeys, this one starts with *Hello World*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]js\1'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The `Unable to find image` phrase means that Docker has not downloaded the named
    image yet. Therefore, it downloaded not only the Ubuntu image but also the images
    it depends on. Any Docker image can be built in layers, meaning we always define
    an image in terms of a base image. In this instance, we see that the Ubuntu image
    required four layers in total.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Images are identified by an SHA-256 hash, and there is both a long-form identifier
    and a short-form identifier. We can see both the long and short identifiers in
    this output.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The `docker run` command downloads an image, configures it for execution, and
    executes the image. The `-it` flag means to run the image interactively in the
    terminal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In the `docker run` command line, the part after the image name to execute is
    passed into the container as command options to execute. In this case, the command
    option says to run `bash`, which is the default command shell. Indeed, we were
    given a command prompt and can run Linux commands.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'You can query your computer to see that while the `hello-world` container has
    executed and finished, it still exists:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc4a87f1-2ca6-44b6-aa62-a8b206cf9a98.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: The `docker ps` command lists the running Docker containers. As we see here,
    the `hello-world` container is no longer running, but the Ubuntu container is.
    With the `-a` switch, `docker ps` also shows those containers that exist but are
    not currently running.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The last column is the container name. Since we didn't specify a container name
    when launching the container, Docker created a semi-random name for us.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re done using a container, you can clean up with the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]js\1'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to specify the hex ID. However, it is, of course, more user
    friendly to have a name for the container than a hex ID. When creating a container, it's
    easy to specify any container name you like.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: We've installed Docker on our laptop or computer and tried a couple of simple
    commands to familiarize ourselves with Docker. Let's now get down to some work.
    We'll start by setting up the user authentication service in Docker containers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the user authentication service in Docker
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all that theory spinning around in our heads, it's time to do something
    practical. Let's start by setting up the user authentication service. We'll call
    this AuthNet, and it comprises a MySQL instance to store the user database, the
    authentication server, and a private subnet to connect them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: It is best for each container to focus on providing one service. Having one
    service per container is a useful architectural decision because we can focus
    on optimizing each container for a specific purpose. Another rationale has to
    do with scaling, in that each service has different requirements to satisfy the
    traffic it serves. In our case, we might need a single MySQL instance, and 10
    user authentication instances, depending on the traffic load.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: There is a large library of predefined Docker images available on Docker Hub
    ([https://hub.docker.com](https://hub.docker.com)). It is best to reuse one of
    those images as a starting point to build our desired service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The Docker environment lets us not only define and instantiate Docker containers
    but also the networking connections between containers. That's what we meant by a
    *private subnet* earlier. With Docker, we not only manage containers, but we can
    also configure subnets, data storage services, and more.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we'll carefully dockerize the user authentication
    service infrastructure. We'll learn how to set up a MySQL container for Docker
    and launch a Node.js service in Docker.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by learning how to launch a MySQL container in Docker.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Launching a MySQL container in Docker
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among the publicly available Docker images, there are over 11,000 available
    for MySQL. Fortunately, the image provided by the MySQL team, `mysql/mysql-server`,
    is easy to use and configure, so let's use that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: A Docker image name can be specified, along with a *tag* that is usually the
    software version number. In this case, we'll use `mysql/mysql-server:8.0`, where `mysql/mysql-server` is
    the image repository URL, `mysql-server` is the image name, and `8.0` is the tag.
    The MySQL 8.x release train is the current version as of the time of writing.
    As with many projects, the MySQL project tags the Docker images with the version
    number.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the image, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]js\1'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: There are two images currently available—the `mysql-server` image we just downloaded
    and the `hello-world` image we ran earlier.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove unwanted images with the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]js\1'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The `docker run` command takes an image name, along with various arguments,
    and launches it as a running container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: We started this service in the foreground, and there is a tremendous amount
    of output as MySQL initializes its container. Because of the `--name` option,
    the container name is `mysql`. Using an environment variable, we tell the container
    to initialize the `root` password.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have a running server, let''s use the MySQL CLI to make sure it''s
    actually running. In another window, we can run the MySQL client inside the container,
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]js\1'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: This closes out and cleans up the container we created. To reiterate the point
    made earlier, the database in that container went away. If that database contained
    critical information, you just lost it, with no chance of recovering the data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, let's discuss how this impacts the design of our services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The ephemeral nature of Docker containers
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker containers are designed to be easy to create and easy to destroy. In
    the course of kicking the tires, we've already created and destroyed three containers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In the olden days (a few years ago), setting up a database required the provisioning
    of specially configured hardware, hiring a database admin with special skills,
    and carefully optimizing everything for the expected workload. In the space of
    a few paragraphs, we just instantiated and destroyed three database instances.
    What a brave new world this is!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In terms of databases and Docker containers, the database is relatively eternal,
    and the Docker container is ephemeral. Databases are expected to last for years,
    or perhaps even decades. In computer years, that's practically immortal. By contrast,
    a Docker container that is used and then immediately thrown away is merely a brief
    flicker of time compared to the expected lifetime of a database.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Those containers can be created and destroyed quickly, and this gives us a lot
    of flexibility. For example, orchestration systems, such as Kubernetes or AWS
    ECS, can automatically increase or decrease the number of containers to match
    traffic volume, restart containers that crash, and more.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: But where does the data in a database container live? With the commands we ran
    in the previous section, the database data directory lives inside the container.
    When the container was destroyed, the data directory was destroyed, and any data
    in our database was vaporized. Obviously, this is not compatible with the life
    cycle requirements of the data we store in a database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是数据库容器中的数据存放在哪里？在前一节中运行的命令中，数据库数据目录位于容器内部。当容器被销毁时，数据目录也被销毁，我们数据库中的任何数据都被永久删除。显然，这与我们在数据库中存储的数据的生命周期要求不兼容。
- en: Fortunately, Docker allows us to attach a variety of mass storage services to
    a Docker container. The container itself might be ephemeral, but we can attach
    eternal data to the ephemeral container. It's just a matter of configuring the
    database container so that the data directory is on the correct storage system.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker允许我们将各种大容量存储服务附加到Docker容器。容器本身可能是短暂的，但我们可以将永久数据附加到短暂的容器。只需配置数据库容器，使数据目录位于正确的存储系统上。
- en: Enough theory, let's now do something. Specifically, let's create the infrastructure
    for the authentication service.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的理论，现在让我们做点什么。具体来说，让我们为身份验证服务创建基础架构。
- en: Defining the Docker architecture for the authentication service
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义身份验证服务的Docker架构
- en: Docker supports the creation of virtual bridge networks between containers.
    Remember that a Docker container has many of the features of an installed Linux
    OS. Each container can have its own IP address and exposed ports. Docker supports
    the creation of what amounts to a virtual Ethernet segment, called a **bridge
    network**. These networks live solely within the host computer and, by default,
    are not reachable by anything outside the host computer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持在容器之间创建虚拟桥接网络。请记住，Docker容器具有已安装的Linux操作系统的许多功能。每个容器都可以有自己的IP地址和公开的端口。Docker支持创建类似虚拟以太网段的东西，称为**桥接网络**。这些网络仅存在于主机计算机中，并且默认情况下，外部计算机无法访问它们。
- en: A Docker bridge network, therefore, has strictly limited access. Any Docker containers
    attached to a bridge network can communicate with other containers attached to
    that network and, by default, that network does not allow external traffic. The
    containers find each other by hostname, and Docker includes an embedded DNS server
    to set up the hostnames required. That DNS server is configured to not require
    dots in domain names, meaning the DNS/hostname of each container is simply the
    container name. We'll find later that the hostname of the container is actually `container-name.network-name`,
    and that the DNS configuration lets you skip using the `network-name` portion
    of the hostname. This policy of using hostnames to identify containers is Docker's
    implementation of service discovery.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker桥接网络的访问受到严格限制。连接到桥接网络的任何Docker容器都可以与连接到该网络的其他容器进行通信，并且默认情况下，该网络不允许外部流量。容器通过主机名找到彼此，并且Docker包含一个嵌入式DNS服务器来设置所需的主机名。该DNS服务器配置为不需要域名中的点，这意味着每个容器的DNS/主机名只是容器名称。我们将在后面发现，容器的主机名实际上是`container-name.network-name`，并且DNS配置允许您跳过使用`network-name`部分的主机名。使用主机名来标识容器的策略是Docker对服务发现的实现。
- en: Create a directory named `authnet` as a sibling to the `users` and `notes` directories.
    We'll be working on `authnet` in that directory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`users`和`notes`目录的同级目录中创建名为`authnet`的目录。我们将在该目录中处理`authnet`。
- en: 'In that directory, create a file—`package.json`—which we''ll use solely to
    record commands for managing AuthNet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录中创建一个名为`package.json`的文件，我们将仅使用它来记录管理AuthNet的命令：
- en: '[PRE5]js\1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: This creates a Docker bridge network. The long coded string is the identifier
    for this network. The `docker network ls` command lists the existing networks
    in the current Docker system. In addition to the short hex ID, the network has
    the name we specified.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个Docker桥接网络。长编码字符串是此网络的标识符。`docker network ls`命令列出当前Docker系统中的现有网络。除了短十六进制ID外，网络还具有我们指定的名称。
- en: 'Look at details regarding the network with this command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令查看有关网络的详细信息：
- en: '[PRE6]js\1'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: This command lets us remove a network from the Docker system. However, since
    we need this network, rerun the command to recreate it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令允许我们从Docker系统中删除网络。但是，由于我们需要此网络，重新运行命令以重新创建它。
- en: We have explored setting up a bridge network, and so our next step is to populate
    it with a database server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了设置桥接网络，因此我们的下一步是用数据库服务器填充它。
- en: Creating the MySQL container for the authentication service
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为身份验证服务创建MySQL容器
- en: Now that we have a network, we can start connecting containers to that network.
    In addition to attaching the MySQL container to a private network, we'll be able
    to control the username and password used with the database, and we'll also give
    it external storage. That will correct the issues we named earlier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个网络，我们可以开始将容器连接到该网络。除了将MySQL容器连接到私有网络外，我们还将能够控制与数据库一起使用的用户名和密码，并且还将为其提供外部存储。这将纠正我们之前提到的问题。
- en: 'To create the container, we can run the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建容器，可以运行以下命令：
- en: '[PRE7]js\1'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: In other words, Docker lets you mount not only a directory but also a single
    file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Docker不仅允许您挂载目录，还允许您挂载单个文件。
- en: 'The command line follows this pattern:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行遵循以下模式：
- en: '[PRE8]js\1'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: This will ensure that you are starting with a fresh database each time, as well
    as ensuring that the container initialization runs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您每次都从新数据库开始，并确保容器初始化运行。
- en: This also suggests an administrative pattern to follow. Any time you wish to
    update to a later MySQL release, simply stop the container, leaving the data directory
    in place. Then, delete the container and re-execute the `docker run` command with
    a new `mysql/mysql-server` tag. That will cause Docker to recreate the container
    using a different image, but using the same data directory. Using this technique,
    you can update the MySQL version by pulling down a newer image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这也暗示了一个行政模式要遵循。每当您希望更新到较新的MySQL版本时，只需停止容器，保留数据目录。然后，删除容器，并使用新的`mysql/mysql-server`标签重新执行`docker
    run`命令。这将导致Docker使用不同的镜像重新创建容器，但使用相同的数据目录。使用这种技术，您可以通过拉取更新的镜像来更新MySQL版本。
- en: 'Once you have the MySQL container running, type this command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦MySQL容器运行，输入以下命令：
- en: '![](img/f8b581a3-5b69-4a4c-9725-32697e2a774b.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8b581a3-5b69-4a4c-9725-32697e2a774b.png)'
- en: This will show the current container status. If we use `docker ps -a`, we see
    that the `PORTS` column says `0.0.0.0:3306->3306/tcp, 33060/tcp`. That says that
    the container is listening to access from anywhere (`0.0.0.0`) to port `3306`,
    and this traffic will connect to port `3306` inside the container. Additionally,
    there is a port `33060` that is available, but it is not exposed outside the container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示当前容器状态。如果我们使用`docker ps -a`，我们会看到`PORTS`列显示`0.0.0.0:3306->3306/tcp, 33060/tcp`。这表示容器正在监听从任何地方（`0.0.0.0`）到端口`3306`的访问，这个流量将连接到容器内部的端口`3306`。此外，还有一个端口`33060`可用，但它没有暴露到容器外部。
- en: Even though it is configured to listen to the whole world, the container is
    attached to `authnet`, which limits where connections can come from. Limiting
    the scope of processes that can attach to the database is a good thing. However,
    since we used the `-p` option, the database port is exposed to the host, and it's
    not as secure as we want. We'll fix this later.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它配置为监听整个世界，但容器附加到`authnet`，限制了连接的来源。限制可以连接到数据库的进程的范围是一件好事。但是，由于我们使用了`-p`选项，数据库端口暴露给了主机，这并不像我们想要的那样安全。我们稍后会修复这个问题。
- en: Security in the database container
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库容器中的安全性
- en: A question to ask is whether setting the `root` password like this is a good
    idea. The `root` user has broad access to the entire MySQL server, where other
    users, such as `userauth`, have limited access to the given database. Since one
    of our goals is security, we must consider whether this has created a secure or
    insecure database container.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个要问的问题是是否像这样设置`root`密码是一个好主意。`root`用户对整个MySQL服务器有广泛的访问权限，而其他用户，如`userauth`，对给定数据库的访问权限有限。由于我们的目标之一是安全性，我们必须考虑这是否创建了一个安全或不安全的数据库容器。
- en: 'We can log in as the `root` user with the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令以`root`用户身份登录：
- en: '[PRE9]js\1'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: A connection to a MySQL server includes a user ID, a password, and the source
    of the connection. This connection might come from inside the same computer, or
    it might come over a TCP/IP socket from another computer. To approve the connection,
    the server looks in the `mysql.user` table for a row matching the `user`, `host` (source
    of connection), and `password` fields. The username and password are matched as
    a simple string comparison, but the host value is a more complex comparison. Local
    connections to the MySQL server are matched against rows where the host value
    is `localhost`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到MySQL服务器包括用户ID、密码和连接的来源。这个连接可能来自同一台计算机内部，也可能来自另一台计算机的TCP/IP套接字。为了批准连接，服务器会在`mysql.user`表中查找与`user`、`host`（连接来源）和`password`字段匹配的行。用户名和密码是作为简单的字符串比较进行匹配的，但主机值是一个更复杂的比较。与MySQL服务器的本地连接将与主机值为`localhost`的行匹配。
- en: For remote connections, MySQL compares the IP address and domain name of the
    connection against entries in the `host` column. The `host` column can contain
    IP addresses, hostnames, or wildcard patterns. The wildcard character for SQL
    is `%`. A single `%` character matches against any connection source, while a
    pattern of `172.%` matches any IP address where the first IPv4 octet is `172`,
    or `172.20.%.%` matches any IP address in the `172.20.x.x` range.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于远程连接，MySQL会将连接的IP地址和域名与`host`列中的条目进行比较。`host`列可以包含IP地址、主机名或通配符模式。SQL的通配符字符是`%`。单个`%`字符匹配任何连接源，而`172.%`的模式匹配第一个IPv4八位是`172`的任何IP地址，或者`172.20.%.%`匹配`172.20.x.x`范围内的任何IP地址。
- en: Therefore, since the only row for `userauth` specifies a host value of `%`,
    we can use `userauth` from anywhere. By contrast, the `root` user can only be
    used with a `localhost` connection.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于`userauth`的唯一行指定了`%`的主机值，我们可以从任何地方使用`userauth`。相比之下，`root`用户只能在`localhost`连接中使用。
- en: 'The next task is to examine the access rights for the `userauth` and `root` user
    IDs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是检查`userauth`和`root`用户ID的访问权限：
- en: '[PRE10]js\1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: We've demonstrated four modes of accessing the database, showing that indeed,
    the `userauth` ID can be accessed either from the same container or from a remote
    container, while the `root` ID can only be used from the local container.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了访问数据库的四种模式，表明`userauth` ID确实可以从同一容器或远程容器访问，而`root` ID只能从本地容器使用。
- en: Using `docker run --it --rm ... container-name ..` starts a container, runs
    the command associated with the container, and then exits the container and automatically
    deletes it when it's done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker run --it --rm ... container-name ..`启动一个容器，运行与容器相关的命令，然后在完成后退出容器并自动删除它。
- en: Therefore, with those last two commands, we created a separate `mysql/mysql-server:8.0` container,
    connected to `authnet`, to run the `mysql` CLI program. The `mysql` arguments
    are to connect using the given username (`root` or `userauth`) to the MySQL server
    on the host named `db-userauth`. This demonstrates connecting to the database
    from a separate connector and shows that we can connect remotely with the `userauth` user,
    but not with the `root` user.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这两个命令，我们创建了一个单独的`mysql/mysql-server:8.0`容器，连接到`authnet`，以运行`mysql`CLI程序。`mysql`参数是使用给定的用户名（`root`或`userauth`）连接到名为`db-userauth`的主机上的MySQL服务器。这演示了从一个独立的连接器连接到数据库，并显示我们可以使用`userauth`用户远程连接，但不能使用`root`用户。
- en: 'Then, the final access experiment involves leaving off the `--network` option:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最终的访问实验涉及省略`--network`选项：
- en: '[PRE11]js\1'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: In other words, the `authnet` network has the `172.20.0.0/16` network number,
    and the `db-userauth` container was assigned the `172.20.0.2` IP address. This
    level of detail is rarely important, but it is useful on the first occasion to
    carefully examine the setup so that we understand what we're dealing with.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`authnet`网络具有`172.20.0.0/16`网络号，而`db-userauth`容器被分配了`172.20.0.2`IP地址。这种细节很少重要，但在第一次仔细检查设置时是有用的，这样我们就能理解我们正在处理的内容。
- en: There is a gaping security issue that violates our design. Namely, the database
    port is visible to the host, and therefore, anyone with access to the host can
    access the database. This happened because we used `-p 3306:3306` in a misguided
    belief that this was required so that `svc-userauth`, which we'll build in the
    next section, can access the database. We'll fix this later by removing that option.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个严重的安全问题，违反了我们的设计。即，数据库端口对主机是可见的，因此，任何可以访问主机的人都可以访问数据库。这是因为我们在错误的认为下使用了`-p
    3306:3306`，以为这是必需的，这样`svc-userauth`才能在下一节中访问数据库。我们将通过删除该选项来解决这个问题。
- en: Now that we have the database instance set up for the authentication service,
    let's see how to Dockerize it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为认证服务设置了数据库实例，让我们看看如何将其Docker化。
- en: Dockerizing the authentication service
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker化认证服务
- en: The word *Dockerize* means to create a Docker image for a piece of software.
    The Docker image can then be shared with others or be deployed to a server. In
    our case, the goal is to create a Docker image for the user authentication service.
    It must be attached to `authnet` so that it can access the database server we
    just configured in the `db-userauth` container.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerize*一词意味着为软件创建一个Docker镜像。然后可以与他人共享Docker镜像，或部署到服务器上。在我们的情况下，目标是为用户认证服务创建一个Docker镜像。它必须连接到`authnet`，以便可以访问我们刚刚在`db-userauth`容器中配置的数据库服务器。'
- en: We'll name this new container `svc-userauth` to indicate that this is the user
    authentication REST service, while the `db-userauth` container is the database.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名这个新容器为`svc-userauth`，以表示这是用户认证REST服务，而`db-userauth`容器是数据库。
- en: Docker images are defined using Dockerfiles, which are files to describe the
    installation of an application on a server. They document the setup of the Linux
    OS, installed software, and configuration required in the Docker image. This is
    literally a file named `Dockerfile`, containing Dockerfile commands. Dockerfile commands
    are used to describe how the image is constructed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是使用Dockerfile定义的，Dockerfile是描述在服务器上安装应用程序的文件。它们记录了Linux操作系统的设置，安装的软件以及Docker镜像中所需的配置。这实际上是一个名为`Dockerfile`的文件，其中包含Dockerfile命令。Dockerfile命令用于描述镜像的构建方式。
- en: Refer to [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/) for
    the documentation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)获取文档。
- en: Creating the authentication service Dockerfile
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建认证服务Dockerfile
- en: 'In the `users` directory, create a file named `Dockerfile` containing the following
    content:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`users`目录中，创建一个名为`Dockerfile`的文件，其中包含以下内容：
- en: '[PRE12]js\1'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: The difference is that instead of `localhost` as the database host, we use `db-userauth`.
    Earlier, we explored the `db-userauth` container and determined that this was
    the hostname of the container. By using `db-userauth` in this file, the authentication
    service will use the database in the container.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，我们使用`db-userauth`而不是`localhost`作为数据库主机。之前，我们探索了`db-userauth`容器，并确定这是容器的主机名。通过在这个文件中使用`db-userauth`，认证服务将使用容器中的数据库。
- en: The `EXPOSE` command informs Docker that the container listens on the named
    TCP port. This does not expose the port beyond the container. The `-p` flag is
    what exposes a given port outside the container.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`命令通知Docker容器监听指定的TCP端口。这不会将端口暴露到容器之外。`-p`标志是将给定端口暴露到容器之外的方式。'
- en: Finally, the `CMD` command documents the process to launch when the container
    is executed. The `RUN` commands are executed while building the container, while `CMD` says
    what's executed when the container starts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`CMD`命令记录了在执行容器时启动的过程。`RUN`命令在构建容器时执行，而`CMD`表示容器启动时执行的内容。
- en: We could have installed `PM2` in the container, and then used a `PM2` command
    to launch the service. However, Docker is able to fulfill the same function because
    it automatically supports restarting a container if the service process dies.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在容器中安装`PM2`，然后使用`PM2`命令来启动服务。然而，Docker能够实现相同的功能，因为它自动支持在服务进程死掉时重新启动容器。
- en: Building and running the authentication service Docker container
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和运行认证服务Docker容器
- en: Now that we've defined the image in a Dockerfile, let's build it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Dockerfile中定义了镜像，让我们来构建它。
- en: 'In `users/package.json`, add the following line to the `scripts` section:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`users/package.json`中，将以下行添加到`scripts`部分：
- en: '[PRE13]js\1'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: The `docker build` command builds an image from a Dockerfile. Notice that the
    build executes one step at a time, and that the steps correspond exactly to the
    commands in the Dockerfile.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build`命令从Dockerfile构建一个镜像。请注意，构建一步一步进行，每个步骤都与Dockerfile中的命令完全对应。'
- en: Each step is stored in a cache so that it doesn't have to be rerun. On subsequent
    builds, the only steps executed are the step that changed and all subsequent steps.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都存储在缓存中，因此不必重新运行。在后续构建中，执行的唯一步骤是更改的步骤和所有后续步骤。
- en: 'In `authnet/package.json`, we require quite a few scripts to manage the user
    authentication service:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在“authnet/package.json”中，我们需要相当多的脚本来管理用户认证服务：
- en: '[PRE14]js\1'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: This option requires absolute pathnames and specifying the path this way works
    on Windows.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项需要绝对路径名，并且以这种方式指定路径在Windows上有效。
- en: Another thing to notice is the absence of the `-p 3306:3306` option. It was
    determined that this was not necessary for two reasons. First, the option exposed
    the database in `db-userauth` to the host, when our security model required otherwise,
    and so removing the option got us the desired security. Second, `svc-userauth` was
    still able to access the `db-userauth` database after this option was removed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是“-p 3306:3306”选项的缺失。有两个原因确定这是不必要的。首先，该选项将数据库暴露给主机，“db-userauth”的安全模型要求不这样，因此删除该选项可以获得所需的安全性。其次，“svc-userauth”在删除此选项后仍然能够访问“db-userauth”数据库。
- en: 'With these commands, we can now type the following to build and then run the
    containers:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些命令，我们现在可以输入以下内容来构建，然后运行容器：
- en: '[PRE15]js\1'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: This stops and starts both containers making up the user authentication service.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止并启动构成用户认证服务的两个容器。
- en: We have created the infrastructure to host the user authentication service,
    plus a collection of scripts to manage the service. Our next step is to explore
    what we've created and learn a few things about the infrastructure Docker creates
    for us.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了托管用户认证服务的基础设施，以及一系列脚本来管理该服务。我们的下一步是探索我们创建的内容，并了解Docker为我们创建的基础设施的一些情况。
- en: Exploring AuthNet
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索AuthNet
- en: 'Remember that AuthNet is the connection medium for the authentication service.
    To understand whether this network provides the security gains we''re looking
    for, let''s explore what we just created:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，AuthNet是认证服务的连接介质。为了了解这个网络是否提供了我们正在寻找的安全性增益，让我们探索一下我们刚刚创建的内容：
- en: '[PRE16]js\1'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: 'The `/userauth` directory is inside the container and contains the files placed
    in the container using the `COPY` command, plus the installed files in `node_modules`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “/userauth”目录位于容器内，包含使用“COPY”命令放置在容器中的文件，以及“node_modules”中安装的文件：
- en: '[PRE17]js\1'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: 'The process listing is interesting to study. Process `PID 1` is the `node ./user-server.mjs` command
    in the Dockerfile. The format we used for the `CMD` line ensured that the `node`
    process ended up as process 1\. This is important so that process signals are
    handled correctly, allowing Docker to manage the service process correctly. The
    tail end of the following blog post has a good discussion of the issue:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 进程列表是值得研究的。进程“PID 1”是Dockerfile中的“node ./user-server.mjs”命令。我们在“CMD”行中使用的格式确保“node”进程最终成为进程1。这很重要，以便正确处理进程信号，从而允许Docker正确管理服务进程。以下博客文章的末尾有关于这个问题的很好讨论：
- en: '[https://www.docker.com/blog/keep-nodejs-rockin-in-docker/](https://www.docker.com/blog/keep-nodejs-rockin-in-docker/)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.docker.com/blog/keep-nodejs-rockin-in-docker/](https://www.docker.com/blog/keep-nodejs-rockin-in-docker/)'
- en: 'A `ping` command proves that the two containers are available as hostnames
    matching the container names:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: “ping”命令证明两个容器作为与容器名称匹配的主机名可用：
- en: '[PRE18]js\1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: As with `authnet`, this is just the starting point as we have several more scripts
    to add.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与“authnet”一样，这只是起点，因为我们还有几个脚本要添加。
- en: 'Let''s go ahead and create the `frontnet` bridge network:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建“frontnet”桥接网络：
- en: '[PRE19]js\1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: This is largely the same as for `db-userauth`, with the word `notes` substituted
    for `userauth`. Remember that on Windows the -`-mount` option requires a Windows-style
    absolute pathname.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这与“db-userauth”几乎相同，只是将“notes”替换为“userauth”。请记住，在Windows上，“-mount”选项需要Windows风格的绝对路径名。
- en: 'Let''s now run the script:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们运行脚本： '
- en: '[PRE20]js\1'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: Since `db-notes` is on a different network segment, we've achieved separation.
    But we can notice something interesting. The `ping` command tells us that the
    full domain name for `db-userauth` is `db-userauth.authnet`. Therefore, it stands
    to reason that `db-notes` is also known as `db-notes.frontnet`. But either way,
    we cannot reach containers on `frontnet` from a container on `authnet`, and so
    we have achieved the desired separation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“db-notes”位于不同的网络段，我们已经实现了隔离。但我们可以注意到一些有趣的事情。“ping”命令告诉我们，“db-userauth”的完整域名是“db-userauth.authnet”。因此，可以推断“db-notes”也被称为“db-notes.frontnet”。但无论如何，我们无法从“authnet”上的容器访问“frontnet”上的容器，因此我们已经实现了所需的隔离。
- en: We're able to move more quickly to construct FrontNet because it's so much like
    AuthNet. We just have to do what we did before and tweak the names.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够更快地移动以构建FrontNet，因为它非常类似于AuthNet。我们只需要做以前做过的事情，并微调名称。
- en: In this section, we created a database container. In the next section, we will
    create the Dockerfile for the Notes application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个数据库容器。在下一节中，我们将为Notes应用程序创建Dockerfile。
- en: Dockerizing the Notes application
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker化Notes应用程序
- en: Our next step is, of course, to Dockerize the Notes application. This starts
    by creating a Dockerfile, and then adding another Sequelize configuration file,
    before finishing up by adding more scripts to the `frontnet/package.json` file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步当然是将Notes应用程序Docker化。这始于创建一个Dockerfile，然后添加另一个Sequelize配置文件，最后通过向“frontnet/package.json”文件添加更多脚本来完成。
- en: 'In the `notes` directory, create a file named `Dockerfile` containing the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在“notes”目录中，创建一个名为“Dockerfile”的文件，其中包含以下内容：
- en: '[PRE21]js\1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: However, the multiple `COPY` commands let us control exactly what's copied.
    It's most important to avoid copying the `node_modules` directory into the container.
    Not only is the `node_modules` file on the host large, which would bloat the container
    if copied, but it is set up for the host OS and not the container OS. The `node_modules` directory must
    be built inside the container, with the installation happening on the container's
    OS. That constraint led to the choice to explicitly copy specific files to the
    destination.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a new `SEQUELIZE_CONNECT` file. Create `models/sequelize-docker-mysql.yaml` containing
    the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]js\1'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: As with the authentication server, this lets us build the container image for
    the Notes application service.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in `frontnet/package.json`, add these scripts:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]js\1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: This creates the container image and then launches the container.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the exposed port `3000` is mapped with `-p 80:3000` onto the normal
    HTTP port. Since we're getting ready for deployment on a real service, we can
    stop using port `3000`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can connect our browser to `http://localhost` and start using
    the Notes application. However, we''ll quickly run into a problem:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11e5e001-7757-4392-9277-62ce82f78a64.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: The user experience team is going to scream about this ugly error message, so
    put it on your backlog to generate a prettier error screen. For example, a flock
    of birds pulling a whale out of the ocean is popular.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'This error means that Notes cannot access anything at the host named `svc-userauth`.
    That host does exist because the container is running, but it''s not on `frontnet`,
    and is not reachable from the `notes` container. Instead, it is on `authnet`,
    which is currently not reachable by `svc-notes`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]js\1'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In the architecture diagram presented in [Chapter 10](176ce11c-dd6f-4ebf-ba14-529be6db28da.xhtml), *Deploying
    Node.js Applications to Linux Servers,* we showed a connection between the `svc-notes` and `svc-userauth` containers.
    This connection is required so that Notes can authenticate its users. But that
    connection does not yet exist.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker requires you to take a second step to attach the container to a second
    network:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]js\1'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The first time around, we connected `svc-notes` to `authnet`, then we disconnected
    it from `authnet`, and then connected `svc-userauth` to `frontnet`. That means
    we tried both combinations and, as expected, in both cases, `svc-notes` and `svc-userauth` were
    able to communicate.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: This is a question for security experts since the consideration is the attack
    vectors available to any intruders. Suppose Notes has a security hole allowing
    an invader to gain access. How do we limit what is reachable via that hole?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary observation is that by connecting `svc-notes` to `authnet`, `svc-notes` not
    only has access to `svc-userauth` but also to `db-userauth`. To see this, run
    these commands:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]js\1'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Primarily, this adds a command, `connect-userauth`, to connect `svc-userauth` to `frontnet`.
    That helps us remember our decision on how to join the containers. We also took
    the opportunity to do a little reorganization.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We've learned a lot in this section about Docker—using Docker images, creating
    Docker containers from images, and configuring a group of Docker containers with
    some security constraints in mind. We came out of this section having implemented
    our initial architecture idea. We have two private networks with the containers
    connected to their appropriate network. The only exposed TCP port is the Notes
    application, visible on port `80`. The other containers connect with one another
    using TCP/IP connections that are not available from outside the containers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding to the next section, you may want to shut down the services
    we''ve launched. Simply execute the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]js\1'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: That's the description of the entire Notes deployment. It's at a fairly high
    level of abstraction, roughly equivalent to the options in the command-line tools
    we've used so far. It's fairly succinct and self-explanatory, and, as we'll see,
    the `docker-compose` command makes these files a convenient way to manage Docker
    services.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The `version` line says that this is a version 3 Compose file. The version number
    is inspected by the `docker-compose` command so that it can correctly interpret
    its content. The full documentation is worth reading at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: There are three major sections used here: `services`, `volumes`, and `networks`.
    The `services` section describes the containers being used, the `networks` section
    describes the networks, and the `volumes` section describes the volumes. The content
    of each section matches the containers we created earlier. The configuration we've
    already dealt with is all here, just rearranged.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: There are the two database containers—`db-userauth` and `db-notes`—and the two
    service containers—`svc-userauth` and `svc-notes`. The service containers are
    built from a Dockerfile located in the directory named in the `build` attribute.
    The database containers are instantiated from images downloaded from Docker Hub.
    Both correspond directly to what we did previously, using the `docker run` command
    to create the database containers and using `docker build` to generate the images
    for the services.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The `container_name` attribute is equivalent to the `--name` attribute and specifies
    a user-friendly name for the container. We must specify the container name in
    order to specify the container hostname to effect a Docker-style service discovery.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The `networks` attribute lists the networks to which this container must be
    connected and is exactly equivalent to the `--net` argument. Even though the `docker` command
    doesn't support multiple `--net` options, we can list multiple networks in the
    Compose file. In this case, the networks are bridge networks. As we did earlier,
    the networks themselves must be created separately and, in a Compose file, this
    is done in the `networks` section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The `ports` attribute declares the ports that are to be published and the mapping
    to container ports. In the `ports` declaration, we have two port numbers, the
    first being the published port number and the second being the port number inside
    the container. This is exactly equivalent to the `-p` option used earlier.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The `depends_on` attribute lets us control the start up order. A container that
    depends on another will wait to start until the depended-on container is running.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The `volumes` attribute describes mappings of a container directory to a `host` directory.
    In this case, we've defined two volume names—`db-userauth-data` and `db-notes-data`—and
    then used them for the volume mapping. However, when we deploy to Docker Swarm
    on AWS EC2, we'll need to change how this is implemented.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we haven't defined a host directory for the volumes. Docker will
    assign a directory for us, which we can learn about by using the `docker volume
    inspect` command.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The `restart` attribute controls what happens if or when the container dies.
    When a container starts, it runs the program named in the `CMD` instruction, and
    when that program exits, the container exits. But what if that program is meant
    to run *forever*; shouldn't Docker know that it should restart the process? We
    could use a background process supervisor, such as Supervisord or PM2\. However,
    the Docker `restart` option takes care of it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The `restart` attribute can take one of the following four values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '`no`: Do not restart.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on-failure:count`: Restart up to *N* times.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always`: Always restart.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unless-stopped`: Start the container unless it was explicitly stopped.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we've learned how to build a Docker Compose file by creating
    one that describes the Notes application stack. With that in hand, let's see how
    to use this tool to launch the containers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the Notes application with Docker Compose
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Docker Compose CLI tool, we can manage any sets of Docker containers
    that can be described in a `docker-compose.yml` file. We can build the containers,
    bring them up and down, view the logs, and more. On Windows, we're able to run
    the commands in this section unchanged.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to create a clean slate by running these commands:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]js\1'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: This builds the images listed in `docker-compose.yml`. Note that the image names
    we end up with all start with `compose-local`, which is the name of the directory
    containing the file. Because this is the equivalent of running `docker build` in
    each of the directories, it only builds the images.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Having built the containers, we can start them all at once using either `docker-compose
    up` or `docker-compose start`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]js\1'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, `docker-compose up` will first build the containers. In addition,
    it keeps the containers all in the foreground so that we can see the logging.
    It combines the log output for all the containers together in one output, with
    the container name shown at the beginning of each line. For a multi-container
    system such as Notes, this is very helpful.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the status using this command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]js\1'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: This means that the REST service port for `svc-userauth` was published. Indeed,
    in the status output, we see that the port is published. That violates our security
    design, but it does let us run the tests with `users/cli.mjs` from our laptop.
    That is, we can add users to the database as we've done so many times before.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: This security violation is acceptable so long as it stays on our laptop. The `compose-local` directory
    is named specifically to be used with Docker Compose on our laptop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can run commands inside the `svc-userauth` container just
    as before:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]js\1'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: From there, we can try pinging each of the containers to see which containers
    can be reached. That will serve as a simplistic security audit to ensure that
    what we've created fits the security model we desired.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: While doing this, we find that `svc-userauth` can ping every container, including `db-notes`.
    This violates the security plan and has to be changed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this is easy to fix. Simply by changing the configuration, we
    can add a new network named `svcnet` to `docker-compose.yml`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]js\1'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown here, this stops the whole set of containers. Occasionally, it will
    instead exit the user to the shell, and the containers will still be running.
    In that case, the user will have to use an alternative method to shut down the
    containers:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]js\1'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: This is the service definition for the `svc-notes-2` container we just described.
    Because we set the `PORT` variable, the container will listen on port `3020`,
    which is what is advertised in the `ports` attribute.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: As before, when we quickly reconfigured the network configuration, notice that
    a simple edit to the Docker Compose file was all that was required to change things
    around.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, relaunch the Notes stack, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]js\1'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: This sets up a Redis server in a container named `redis`. This means that other
    services wanting to use Redis will access it at the host named `redis`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: For any `svc-notes` services you've defined (`svc-notes` and `svc-notes-2`),
    we must now tell the Notes application where to find the Redis server. We can
    do this by using an environment variable.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'In `compose-local/docker-compose.yml`, add the following environment variable
    declaration to any such services:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]js\1'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: This installs the required packages. The `redis` package is a client for using
    Redis from Node.js and the `connect-redis` package is the Express session store
    for Redis.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to change the initialization in `app.mjs` to use the `connect-redis` package
    in order to store session data:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]js\1'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Because source file changes were made, the containers need to be rebuilt. These
    options ensure that this happens.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: We'll now be able to connect to both the Notes service on `http://localhost:3000` (`svc-notes`)
    and the service on `http://localhost:3020` (`svc-notes-2`), and it will handle
    the login session on both services.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Another issue should be noted, however, and this is the fact that real-time
    notifications are not sent between the two servers. To see this, set up four browser
    windows, two for each of the servers. Navigate all of them to the same note. Then,
    add and delete some comments. Only the browser windows connected to the same server
    will dynamically show changes to the comments. Browser windows connected to the
    other server will not.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: This is the second horizontal scaling issue. Fortunately, its solution also
    involves the use of Redis.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Distributing Socket.IO messages using Redis
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While testing what happens when we have multiple `svc-notes` containers, we
    found that login/logout was not reliable. We fixed this by installing a Redis-based
    session store to keep session data in a place that is accessible by multiple containers.
    But we also noticed another issue: the fact that the Socket.IO-based messaging
    did not reliably cause updates in all browser windows.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the updates we want to happen in the browser are triggered by
    updates to the `SQNotes` or `SQMessages` tables. The events emitted by updating either table
    are emitted by the server making the update. An update happening in one service
    container (say, `svc-notes-2`) will emit an event from that container, but not
    from the other one (say, `svc-notes`). There is no mechanism for the other containers
    to know that they should emit such events.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The Socket.IO documentation talks about this situation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[https://socket.io/docs/using-multiple-nodes/](https://socket.io/docs/using-multiple-nodes/)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.IO team provides the `socket.io-redis` package as the solution to
    this problem. It ensures that events emitted through Socket.IO by any server will
    be passed along to other servers so that they can also emit those events.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already have the Redis server installed, we simply need to install
    the package and configure it as per the instructions. Again, we will not need
    to learn anything about Redis:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]js\1'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The only change is to add the lines in bold. The `socket.io-redis` package is
    what the Socket.IO team calls an adapter. Adapters are added to Socket.IO by using
    the `io.adapter` call.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: We only connect this adapter if a Redis endpoint has been specified. As before,
    this is so that Notes can be run without Redis as needed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Nothing else is required. If you relaunch the Notes application stack, you will
    now receive updates in every browser window connected to every instance of the
    Notes service.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we thought ahead about deployment to a cloud-hosting service.
    Knowing that we might want to implement multiple Notes containers, we tested this
    scenario on our laptop and found a couple of issues. They were easily fixed by
    installing a Redis server and adding a couple of packages.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: We're getting ready to finish this chapter, and there's one task to take care
    of before we do. The `svc-notes-2` container was useful for ad hoc testing, but
    it is not the correct way to deploy multiple Notes instances. Therefore, in `compose-local/docker-compose.yml`,
    comment out the `svc-notes-2` definition.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: This gave us some valuable exposure to a new tool that's widely used—Redis.
    Our application now also appears to be ready for deployment. We'll take care of
    that in the next chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a huge step toward the vision of deploying Notes on
    a cloud-hosting platform. Docker containers are widely used on cloud-hosting systems
    for application deployment. Even if we don't end up using the Docker Compose file
    once, we can still carry out the deployment and we have worked out how to Dockerize
    every aspect of the Notes stack.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned not only about creating Docker images for Node.js
    applications, but also about launching a whole system of services comprising a
    web application. We have learned that a web application is not just about the
    application code but also the databases, the frameworks we use, and even other
    services, such as Redis.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: For that purpose, we learned both how to create our own Docker containers as
    well as how to use third-party containers. We learned how to launch containers
    using `docker run` and Docker Compose. We learned how to build custom Docker containers
    using a Dockerfile, and how to customize third-party containers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: For connecting containers, we learned about the Docker bridge network. This
    is useful on a single-host Docker installation and is a private communication
    channel where containers can find each other. As a private channel, the bridge
    network is relatively safe from outside intrusion, giving us a way to securely
    tie services together. We had the opportunity to try different network architectures
    inside Docker and to explore the security implications of each. We learned that
    Docker offers an excellent way to securely deploy persistent services on a host
    system.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead to the task of deploying Notes on a cloud hosting service, we
    did some ad hoc testing with multiple instances of the Notes service. This highlighted
    a few issues that will crop up with multiple instances, and we remedied those
    issues by adding Redis to the application stack.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: This gave us a well-rounded view of how Node.js services are prepared for deployment
    to cloud-hosting providers. Remember that our goal is to deploy the Notes application
    as Docker containers on AWS EC2 as an example of cloud deployment. In this chapter,
    we explored different aspects of Dockerizing a Node.js application stack, giving
    us a solid grounding in deploying services with Docker. We're now ready to take
    this application to a server on the public internet.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about two very important technologies. The
    first is **Docker Swarm**, which is a Docker orchestrator that comes bundled with
    Docker. We'll learn how to deploy our Docker stack as services in a Swarm that
    we'll build on the AWS EC2 infrastructure. The second technology we'll learn about
    is Terraform, which is an open source tool for describing service configuration
    on cloud-hosting systems. We'll use it to describe the AWS EC2 configuration for
    the Notes application stack.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
