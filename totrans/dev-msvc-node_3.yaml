- en: Chapter 3. From the Monolith to Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In my professional life, I have worked in quite a few different companies,
    mainly in financial services, and all of the companies that I have worked for
    follow the same pattern as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A company is set up by a couple of people with good domain knowledge: insurance,
    payments, credit cards, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The company grows, demanding new business requirements that need to be satisfied
    quickly (regulation, big customers demanding silly things, and so on), which are
    built in a hurry with little to no planning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The company experiences another phase of growing, where the business transactions
    are clearly defined and poorly modelled by a hard-to-maintain monolithic software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The company increases the headcount that drives into growing pains and loss
    of efficiency due to restrictions imposed on how the software was built in the
    first instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter is not only about how to avoid the previous flow (uncontrolled
    organic growth), but it is also about how to model a new system using microservices.
    This chapter is the soul of this book, as I will try to synthetize my experience
    in a few pages, setting up the principles to be followed in [Chapter 4](ch04.html
    "Chapter 4. Writing Your First Microservice in Node.js"), *Writing Your First
    Microservice in Node.js*, where we will be building a full system based on microservices
    using the lessons learned in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: First, there was the monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A huge percentage (my estimate is around 90%) of the modern enterprise software
    is built following a monolithic approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Large software components that run in a single container and have a well-defined
    development life cycle, which goes completely against the agile principles, deliver
    early and deliver often ([https://en.wikipedia.org/wiki/Release_early,_release_often](https://en.wikipedia.org/wiki/Release_early,_release_often)),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deliver early**: The sooner you fail, the easier it is to recover. If you
    are working for two years on a software component and then it is released, there
    is a huge risk of deviation from the original requirements, which are usually
    wrong and change every few days.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deliver often**: Delivering often, the stakeholders are aware of the progress
    and can see the changes reflected quickly in the software. Errors can be fixed
    in a few days and improvements are identified easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Companies build big software components instead of smaller ones that work together
    as it is the natural thing to do, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer has a new requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: He builds a new method on an existing class on the service layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method is exposed on the API via HTTP, SOAP, or any other protocol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, multiply it by the number of developers in your company, and you will obtain
    something called **organic growth**. Organic growth is a type of *uncontrolled
    and unplanned* growth on software systems under business pressure without an adequate
    long-term planning, and it is bad.
  prefs: []
  type: TYPE_NORMAL
- en: How to tackle organic growth?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing required to tackle organic growth is to make sure that the business
    and IT are aligned in the company. Usually, in big companies, IT is not seen as
    a core part of the business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Organizations outsource their IT systems, keeping the price in mind, but not
    the quality so that the partners building these software components are focused
    on one thing: *deliver on time* and according to the specifications even if they
    are incorrect.'
  prefs: []
  type: TYPE_NORMAL
- en: This produces a less-than-ideal ecosystem to respond to the business needs with
    a working solution for an existing problem. IT is lead by people who barely understand
    how the systems are built, and usually overlook the complexity of software development.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is a changing tendency as IT systems become the driver of
    99% of the businesses around the world, but we need to get smarter about how we
    build them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first measure to tackle organic growth is aligning IT and business stakeholders
    to work together: educating the nontechnical stakeholders is the key to success.'
  prefs: []
  type: TYPE_NORMAL
- en: If we go back to the few big releases schema. Can we do it better?
  prefs: []
  type: TYPE_NORMAL
- en: Of course we can. Divide the work into manageable software artifacts that model
    a single, well-defined business activity and give it an entity.
  prefs: []
  type: TYPE_NORMAL
- en: It does not need to be a microservice at this stage, but keeping the logic inside
    of a separated, well-defined, easily testable, and decoupled module will give
    us a huge advantage for future changes in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to tackle organic growth?](img/B04889_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this insurance system, you can see that someone was in a hurry. SMS and e-mail
    sender, although both are communication channels, they have a very different nature
    and you probably want them to act in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The calling services are grouped into the following two high-level entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Business**: The new customers that receive an e-mail when they sign up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Renewals**: The existing customers that receive an SMS when the insurance
    policy is ready to be renewed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point, the system needed to send SMSs and e-mails and someone created
    the communication service entity that handles all the third-party communications.
  prefs: []
  type: TYPE_NORMAL
- en: It looks like a good idea in the beginning. SMS or e-mail, at the end of the
    day, is only a channel, the communication mechanism will be 90% same and we can
    reuse plenty of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we suddenly want to integrate a third-party service that handles
    all the physical post?
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we want to add a newsletter that goes out to the customers once
    a week with information that we consider interesting for our customers?
  prefs: []
  type: TYPE_NORMAL
- en: The service will grow out of control and it will become more difficult to test,
    release, and ensure that the changes in the SMS code won't affect sending the
    e-mail in any form.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is organic growth and, in this case, it is related to a law called **Conway''s
    Law**, which states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Any organization that designs a system (defined more broadly here than just
    information systems) will inevitably produce a design whose structure is a copy
    of the organization''s communication structure.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this case, we are falling into a trap. We are trying to model the communication
    on a single software component that is probably too big and complex to react quickly
    to new business needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to tackle organic growth?](img/B04889_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have encapsulated every communication channel on its own service (which,
    later on, will be deployed as a microservice) and we will do the same for future
    communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first step to beat organic growth: create fine-grained services
    with well-defined boundaries and a single responsibility—*do something small,
    but do it well*.'
  prefs: []
  type: TYPE_NORMAL
- en: How abstract is too abstract?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our brain can't handle complicated mechanisms. The abstraction capacity is one
    of the most recent human intelligence acquisitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example from the previous section, I''ve given something for good, which
    will upset half of the programmers in the world: *eradicating the abstraction
    of our system*.'
  prefs: []
  type: TYPE_NORMAL
- en: The abstraction capacity is something that we learn along the years and, unlike
    intelligence, it can be trained. Not everyone can reach the same level of abstraction,
    and if we mix the specific and complex domain knowledge required by some industries
    with a high-level of abstraction, we have the perfect recipe for a disaster.
  prefs: []
  type: TYPE_NORMAL
- en: When building software, one of the golden rules that I always tried to follow
    (and try is the correct word, as I always find huge opposition to it) is to avoid
    premature abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'How many times did you find yourself in a corner with a simple set of requirements:
    *build a program to solve X*. However, your team goes off and anticipates all
    the possible variations of *X*, without even knowing if they are plausible. Then,
    once the software is in production, one of the stakeholders comes with a variation
    of *X* that you could have never imagined (as the requirements were not even correct)
    and now, getting this variation to work will cost you a few days and a massive
    refactor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to avoid this problem is simple: *avoid abstraction without at least
    three use cases*.'
  prefs: []
  type: TYPE_NORMAL
- en: Do not factor in the possibility of sending the data through different types
    of channels as it might not happen and you are compromising the current feature
    with unnecessary abstractions. Once you have at least one other communication
    channel, it is time to start thinking about how these two software components
    can be designed better, and when the third use case shows up, refactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that when building microservices, they should be small enough to be
    rewritten on a single sprint (around two weeks), so the benefits of having a working
    prototype in such a short period of time is worth the risk of having to rewrite
    it once the requirements are more concrete: something to show to the stakeholders
    is the quickest way to nail down the requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Seneca** is great in this regard as, through pattern matching, we can extend
    the API of a given microservice without affecting the existing calling code: our
    service is open for extension, but closed for modification (the SOLID principles)
    as we are adding functionality without affecting the existing one. We will see
    more complete examples of this behavior in [Chapter 4](ch04.html "Chapter 4. Writing
    Your First Microservice in Node.js"), *Writing Your First Microservice in Node.js*.'
  prefs: []
  type: TYPE_NORMAL
- en: Then the microservices appeared
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are here to stay. Nowadays, the companies give more importance
    to the quality of the software. As stated in the previous section, deliver early
    and deliver often are the key to succeed in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are helping us to satisfy business needs as quickly as possible
    through modularity and specialization. Small pieces of software that can easily
    be versioned and upgraded within a few days and they are easy to test as they
    have a clear and small purpose (specialization) and are written in such a way
    that they are isolated from the rest of the system (modularization).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is not common to find the situation as described previously.
    Usually, big software systems are not built in a way that modularization or specialization
    are easy to identify. The general rule is to build a big software component that
    does everything and the modularization is poor, so we need to start from the very
    basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing some code, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this module can be easily called **communications service**
    and it will be fairly easy to guess what it is doing. It manages the e-mail, SMS,
    and post communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is probably too much. This service is deemed to grow out of control, as
    people will keep adding methods related to communications. This is the key problem
    of monolithic software: the bounded context spans across different areas, affecting
    the quality of our software from both functional and maintenance point of view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are a software developer, a red flag will be raised straightaway: the
    cohesion of this module is quite poor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it could have worked for a while, we are now changing our mindset.
    We are building small, scalable, and autonomous components that can be isolated.
    The cohesion in this case is bad as the module is doing too many different things:
    e-mail, SMS, and post.'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we add another communication channel such as Twitter and Facebook
    notifications?
  prefs: []
  type: TYPE_NORMAL
- en: 'The service grows out of control. Instead of having small functional software
    components, you end up with a gigantic module that will be difficult to refactor,
    test, and modify. Let''s take a look at the following SOLID design principles,
    explained in [Chapter 2](ch02.html "Chapter 2. Microservices in Node.js – Seneca
    and PM2 Alternatives"), *Microservices in Node.js – Seneca and PM2 Alternatives*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-responsibility principle**: The module does too many things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open for extension, closed for modification**: The module will need to be
    modified to add new functionalities and probably change the common code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution**: We will skip this one again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface segregation**: We don''t have any interface specified in the module,
    just the implementation of an arbitrary set of functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection:** There is no dependency injection. The module needs
    to be built by the calling code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things get more complicated if we don't have tests.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, let's split it into various small modules using Seneca.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the e-mail module (`email.js`) will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The SMS module (`sms.js`) will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the post module (`post.js`) will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the new structure of modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Then the microservices appeared](img/B04889_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have three modules. Each one of these modules does one specific thing
    without interfering with each other; we have created high-cohesion modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the preceding code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As simple as that, we have created a server with the IP `10.0.0.7` bound that
    listens on the `1932` port for incoming requests. As you can see, we haven't referenced
    any file, we just referenced the module by name; Seneca will do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run it and verify that Seneca has loaded the plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will output something similar to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Then the microservices appeared](img/B04889_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you remember from [Chapter 2](ch02.html "Chapter 2. Microservices in Node.js
    – Seneca and PM2 Alternatives"), *Microservices in Node.js – Seneca and PM2 Alternatives*,
    Seneca loads a few plugins by default: `basic`, `transport`, `web`, and `mem-store`,
    which allow Seneca to work out of the box without being hassled with the configuration.
    Obviously, as we will see in [Chapter 4](ch04.html "Chapter 4. Writing Your First
    Microservice in Node.js"), *Writing Your First Microservice in Node.js*, that
    the configuration is necessary as, for example, `mem-store` will only store data
    in the memory without persisting it between executions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the standard plugins, we can see that Seneca has loaded three extra
    plugins: `email`, `sms`, and `post`, which are the plugins that we have created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the services written in Seneca are quite easy to understand
    once you know how the framework works. In this case, I have written the code in
    the form of a plugin so that it can be used by different instances of Seneca on
    different machines, as Seneca has a transparent transport mechanism that allows
    us to quickly redeploy and scale parts of our monolithic app as microservices,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The new version can be easily tested, as changes on the e-mail functionality
    will only affect sending the e-mail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to scale. As we will see in the next chapter, replicating a service
    is as easy as configuring a new server and pointing our Seneca client to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also easy to maintain, as the software is easier to understand and modify.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With microservices, we solve the biggest problems in modern enterprise, but
    that does not mean that they are problem free. Microservices often lead to different
    types of problems that are not easy to foresee.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and most concerning one is the operational overhead that could chew
    up the benefits obtained from using microservices. When you are designing a system,
    you should always have one question in mind: how to automate this? Automation
    is the key to tackling this problem.'
  prefs: []
  type: TYPE_NORMAL
- en: The second disadvantage with microservices is nonuniformity on the applications.
    A team might consider something a good practice that could be banned in another
    team (especially around exception handling), which adds an extra layer of isolation
    between teams that probably does not do well for the communication of your engineers
    within the team.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, but not less important, microservices introduce a bigger communication
    complexity that could lead to security problems. Instead of having to control
    a single application and its communication with the outer world, we are now facing
    a number of servers that communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the monolith
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider that the marketing department of your company has decided to run an
    aggressive e-mail campaign that is going to require peaks of capacity that could
    harm the normal day-to-day process of sending e-mail. Under stress, the e-mails
    will be delayed and that could cause us problems.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we have built our system as explained in the previous section. Small
    Seneca modules in the form of a high-cohesion and low-coupled plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the solution to achieve it is simple: deploy the e-mail service (`email.js`)
    on more than one machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create a Seneca client pointing to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, the `senecaEmail` variable will contact the remote service when
    calling `act` and we would have achieved our goal: *scale up our first microservice*.'
  prefs: []
  type: TYPE_NORMAL
- en: Problems splitting the monolith – it is all about the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data storage could be problematic. If your application has grown out of control
    for a number of years, the database would have done the same, and by now, the
    organic growth will make it hard to deal with significant changes in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices should look after their own data. Keeping the data local to the
    service is one of the keys to ensure that the system remains flexible as it evolves,
    but it might not be always possible. As an example, financial services suffer
    especially from one of the main weak points of microservices-oriented architectures:
    *the lack of transactionality*. When a software component deals with money, it
    needs to ensure that the data remains consistent and not eventually consistent
    after every single operation. If a customer deposits money in a financial company,
    the software that holds the account balance needs to be consistent with the money
    held in the bank, otherwise, the reconciliation of the accounts will fail. Not
    only that, if your company is a regulated entity, it could cause serious problems
    for the continuity of the business.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general rule of thumb, when working with microservices and financial systems,
    is to keep a not-so-microservice that deals with all the money and creates microservices
    for the auxiliary modules of the system such as e-mailing, SMS, user registration,
    and so on, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Problems splitting the monolith – it is all about the data](img/B04889_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding picture, the fact that payments will be a big
    microservice instead of smaller services, it only has implications in the operational
    side, there is nothing preventing us from modularizing the application as seen
    before. The fact that withdrawing money from an ATM has to be an atomic operation
    (either succeed or fail without intermediate status) should not dictate how we
    organize the code in our application, allowing us to modularize the services,
    but spanning the transaction scope across all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Organizational alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a company where the software is built based on microservices, every single
    stakeholder needs to be involved in decision making.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are a huge paradigm shift. Usually, large organizations tend to
    build software in a very old fashioned manner. Big releases every few months that
    require days to complete the **quality assurance** (**QA**) phase and few hours
    to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a company chooses to implement a microservices-oriented architecture,
    the methodology changes completely: small teams work on small features that are
    built, tested, and deployed on their own. The teams do one thing (one microservice,
    or more realistic, a few of them) and they do it well (they master the domain
    and technical knowledge required to build the software).'
  prefs: []
  type: TYPE_NORMAL
- en: These are what usually called cross-functional teams. A unit of work of few
    people that have the required knowledge to build high-quality software components.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to flag that the team has to master the domain knowledge
    needed to understand the business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where the majority of the companies where I have worked in my professional
    life fail (in my opinion). Developers are considered brick stackers that magically
    understand the business flows without being exposed to them before. If one developer
    delivers *X* amount of work in one week, ten developers will deliver *10X*. This
    is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: People in cross-functional teams that build the microservices have to master
    (not only know) the domain-specific knowledge in order to be efficient and factor
    the Conway's Law and its implications into the system for changing how the business
    processes work.
  prefs: []
  type: TYPE_NORMAL
- en: 'When talking about organizational alignment in microservices, autonomy is the
    key. The teams need to be autonomous in order to be agile while building the microservices,
    which implies keeping the technical authority within the team, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Languages used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns used to solve problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools chosen to build, test, debug, and deploy the software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an important part, as this is where we need to define how the company
    builds software and where the engineering problems may be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can look into the coding standards, as shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we want to keep the same coding standards across the teams?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we want each team to have their own coding standards?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, I am always in favor of the 80% rule: *80% of perfection is more
    than enough for 100% of the use cases*. It means that loosening up the coding
    standards (it can be applied to other areas) and allowing some level of imperfection/personalization,
    helps to reduce the friction between teams and also allows the engineers to quickly
    catch up with the very few important rules to follow such as logging strategies
    or exception handling.'
  prefs: []
  type: TYPE_NORMAL
- en: If your coding standards are too complicated, there will be friction when a
    team tries to push a code into a microservice out of their usual scope (remember,
    teams own the services, but every team can contribute to them).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the principles of building monolithic applications
    oriented to be split as microservices, depending on the business needs. As you
    have learned, the **Atomicity**, **Consistency**, **Isolation**, **Durability**
    (**ACID**) design principles are concepts that we need to have in mind in order
    to build high quality software.
  prefs: []
  type: TYPE_NORMAL
- en: You have also learned that we cannot assume that we are going to be able to
    design a system from scratch, so we need to be smart about how we build the new
    parts of the system and how we refactor the existing ones so that we achieve the
    level of flexibility required to satisfy the business needs and be resilient.
  prefs: []
  type: TYPE_NORMAL
- en: We also have given a small introduction about monolithic designed databases
    and how they are the biggest pain points when splitting a monolithic software
    into microservices, as it is usually required to shut down the system for a few
    hours in order to split the data into local databases. This subject could well
    be an entire book as new trends with NoSQL databases are changing the game of
    data storage.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed how to align the teams of engineers in our company in
    order to be efficient while keeping the flexibility and resilience needed to be
    able to be agile, as well as how the Conway's Law impacts the conversion of monolithic
    systems into microservices-oriented architectures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will apply all the principles discussed in the first
    three chapters, as well as a big dose of common sense to build a full working
    system based on microservices.
  prefs: []
  type: TYPE_NORMAL
