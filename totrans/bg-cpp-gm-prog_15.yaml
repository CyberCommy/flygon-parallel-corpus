- en: Chapter 15. Sound Spatialization and HUD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be adding all the sound effects and the HUD. We have
    done this in both of the previous projects, but we will do things a bit differently
    this time. We will explore the concept of sound **spatialization** and how SFML
    makes this otherwise complicated concept nice and easy; in addition, we will build
    a HUD class to encapsulate the code that draws information to the screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will complete these tasks in the following order:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What is spatialization?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How SFML handles spatialization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `SoundManager` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying emitters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `SoundManager` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `HUD` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `HUD` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Spatialization?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spatialization is the act of making something relative to the space it is a
    part of, or within. In our daily lives, everything in the natural world, by default,
    is spatialized. If a motorbike whizzes past from left to right we will hear the
    sound grow from faint to loud from one side and as it passes by, it will become
    more prominent in the other ear, before fading into the distance once more. If
    we woke up one morning and the world was no longer spatialized, it would be exceptionally
    weird.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: If we can make our video games a little bit more like the real world, our players
    can become more immersed. Our zombie game would have been a lot more fun if the
    player could have heard them faintly in the distance and their inhuman wailing
    grew louder as they drew closer, from one direction or another.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: It is probably obvious that the mathematics of spatialization will be complex.
    How do we calculate how loud a given sound will be in a specific speaker, based
    on the direction the sound is coming from, and the distance from the player (the
    hearer of the sound) to the object that is making the sound (the emitter)?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, SFML does all the complicated stuff for us. All we need to do is
    get familiar with a few technical terms and then we can start using SFML to spatialize
    our sound effects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Emitters, attenuation, and listeners
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to be aware of a few pieces of information in order to give SFML
    what it needs to do its work. We will need to be aware of where the sound is coming
    from in our game world. This source of the sound is called an **emitter**. In
    a game, the emitter could be a Zombie, a vehicle, or in the case of our current
    project, a fire tile. We already keep track of the position of objects in our
    game, so giving SFML the emitter location will be quite straightforward.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The next factor we need to be aware of is **attenuation**. Attenuation is the
    rate at which a wave deteriorates. You could simplify that statement and make
    it specific to sound by saying that attenuation is how quickly the sound reduces
    in volume. That isn't technically exact, but it is a good enough description for
    the purposes of this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The final factor we need to consider is the **listener**. When SFML spatializes
    the sound, where is it spatializing it relative to? In most games, the logical
    thing to do is use the player character. In our game, we will use Thomas.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How SFML handles spatialization
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SFML has a number of functions that allow us to handle emitters, attenuation,
    and listeners. Let's take a look at them hypothetically, and then we will write
    some code to add spatialized sound to our project for real.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set up a sound effect ready to be played, as we have done so often,
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can set the position of the emitter using the `setPosition` function, as
    shown in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As suggested in the comments of the previous code, how exactly you obtain the
    coordinates of the emitter will probably be dependent upon the type of game. As
    shown in the previous code, this would be quite simple in the Zombie Arena project.
    We will have a few challenges to overcome when we set the position in this project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the attenuation level using the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The actual attenuation level can be a little ambiguous. The effect that you
    want the player to get might be different from the accurate scientific formula
    used to reduce the volume over distance based on attenuation. Getting the right
    attenuation level is usually achieved by experimenting. Generally speaking, the
    higher the level of attenuation, the quicker the sound level reduces to silence.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you might want to set a zone around the emitter where the volume is not
    attenuated at all. You might do this if the feature isn''t appropriate beyond
    a certain range, or you have a large number of sound sources and don''t want to
    overdo the feature. To do so, we can use the `setMinimumDistance` function, as
    shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the previous line of code, attenuation would not begin to be calculated
    until the listener is `150` pixels/units away from the emitter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other useful functions from the SFML library include the `setLoop` function.
    This function will tell SFML to keep playing the sound over and over when true
    is passed in as a parameter, as demonstrated by the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The sound will continue to play until we ended it with the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From time to time, we will want to know the status of a sound (playing or stopped).
    We can achieve this with the `getStatus` function, as demonstrated in the following
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is just one more aspect of using sound spatialization with SFML that
    we need to cover. Where is the listener? We can set the position of the listener
    with the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code will make all sounds play relative to that location. This
    is just what we need for the distant roar of a fire tile or incoming zombie, but
    for regular sound effects such as jumping, this is a problem. We could start handling
    an emitter for the location of the player, but SFML makes things simple for us.
    Whenever we want to play a *normal* sound, we simply call `setRelativeToListener`,
    as shown in the following code, and then play the sound in the exact same way
    we have done so far. Here is how we might play a *normal*, un-spatialized jump
    sound effect:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All we need to do is call `Listener::setPosition` again before we play any spatialized
    sounds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: We now have a wide repertoire of SFML sound functions and we are ready to make
    some spatialized noise for real.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Building the SoundManager class
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might recall that in the previous project, all the sound code took up quite
    a few lines of code. Now consider that with spatialization, it's going to get
    longer still. To keep our code manageable, we will code a class to manage the
    playing of all our sound effects. In addition, to help us with spatialization,
    we will add a function to the Engine class as well, but we will discuss that when
    we come to it, later in the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Coding SoundManager.h
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started by coding and examining the header file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `SoundManager.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `SoundManager` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and examine the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is nothing tricky in the code we just added. There are five `SoundBuffer`
    objects and eight `Sound` objects. Three of the `Sound` objects will play the
    same `SoundBuffer`. This explains the reason for the different number of `Sound`/`SoundBuffer`
    objects. We do this so that we can have multiple roaring sound effects playing,
    with different spatialized parameters, simultaneously.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Notice there is the `m_NextSound` variable that will help us keep track of which
    of these potentially simultaneous sounds we should use next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: There is a constructor, `SoundManager`, where we will set up all our sound effects,
    and there are five functions that will play the sound effects. Four of these functions
    simply play *normal* sound effects and their code will be really simple.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: One of the functions, `playFire`, will handle the spatialized sound effects
    and will be a bit more in-depth. Notice the parameters of the `playFire` function.
    It receives a `Vector2f`, which is the location of the emitter, and a second `Vector2f`,
    which is the location of the listener.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Coding the SoundManager.cpp file
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can code the function definitions. The constructor and the `playFire`
    functions have a fair amount of code, so we will look at them individually. The
    other functions are short and sweet so we will handle them all at once.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `SoundManager.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `SoundManager` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Coding the constructor
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following code for the include directives and the constructor to `SoundManager.cpp`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code, we loaded five sound files into the five `SoundBuffer`
    objects. Next, we associated the eight `Sound` objects with one of the `SoundBuffer`
    objects. Notice that `m_Fire1Sound`, `m_Fire2Sound`, and `m_Fire3Sound` are all
    going to be playing from the same `SoundBuffer`, `m_FireBuffer`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the attenuation and minimum distance for the three fire sounds.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The values of `150` and `15`, respectively, were arrived at through experimentation.
    Once the game is running, I encourage you to experiment with these values by changing
    them around and seeing (or rather hearing) the difference.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the constructor, we used the `setLoop` function on each of the
    fire-related `Sound` objects. Now when we call `play`, they will play continuously.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Coding the playFire function
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the `playFire` function shown in the following code, and then we can discuss
    it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing we do is call `Listener::setPosition` and set the location of
    the listener based on the `Vector2f` that is passed in as a parameter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code enters a `switch` block based on the value of `m_NextSound`.
    Each of the `case` statements does the exact same thing, but to either `m_Fire1Sound`,
    `m_Fire2Sound`, or `m_Fire3Sound`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: In each of the `case` blocks, we set the position of the emitter using the passed-in
    parameter with the `setPosition` function. The next part of the code in each `case`
    block checks whether the sound is currently stopped, and if it is, plays the sound.
    We will see quite soon how we arrive at the positions for the emitter and listener
    that are passed into this function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the `playFire` function increments `m_NextSound` and ensures
    that it can only be equal to 1, 2, or 3, as required by the `switch` block.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Coding the rest of the SoundManager functions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add these four simple functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `playFallInFire`, `playFallInWater`, and `playReachGoal` functions do just
    two things. First, they each call `setRelativeToListener`, so the sound effect
    is not spatialized, making the sound effect *normal*, not directional, and then
    they call `play` on the appropriate `Sound` object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the `SoundManager` class. Now we can use it in the `Engine` class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Adding SoundManager to the game engine
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Engine.h` file and add an instance of the new `SoundManager` class,
    as shown in the following highlighted code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, we could use `m_SM` to call the various `play...` functions.
    Unfortunately, there is still a bit more work to be done in order to manage the
    locations of the emitters (fire tiles).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Populating the sound emitters
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Engine.h` file and add a new prototype for a `populateEmitters` function
    and a new STL `vector` of `Vector2f` objects:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `populateEmitters` function takes as a parameter a `vector` of `Vector2f`
    objects, as well as a pointer to `int` (a two-dimensional array). The `vector`
    will hold the location of each emitter in a level and the array is our two-dimensional
    array, which holds the layout of a level.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Coding the populateEmitters function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The job of the `populateEmitters` function is to scan through all the elements
    of `arrayLevel` and decide where to put the emitters. It will store its results
    in `m_FireEmitters`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File** (`.cpp`) and then in the **Name** field, type `PopulateEmitters.cpp`.
    Finally, click the **Add** button. Now we can code the new function, `populateEmitters`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code in its entirety; be sure to study the code as you do, and then
    we can discuss it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Some of the code might appear complex at first glance. Understanding the technique
    we use to choose where an emitter will make it simpler. In our levels, there are,
    regularly, large blocks of fire tiles. In one of the levels I designed there are
    more than 30 fire tiles together. The code makes sure that there is only one emitter
    within a given rectangle. This rectangle is stored in `previousEmitter` and is
    300 pixels by 300 pixels (`TILE_SIZE * 6`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The code sets up a nested `for` loop that loops through `arrayLevel` looking
    for fire tiles. When it finds one, it makes sure that it does not intersect with
    `previousEmitter`. Only then does it use the `pushBack` function to add another
    emitter to `vSoundEmitters`. After doing so, it also updates `previousEmitter`
    to avoid getting large clusters of sound emitters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Let's make some noise.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up the `LoadLevel.cpp` file and add the call to the new `populateEmitters`
    function, as highlighted in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first sound to add is the jump sound. You might remember that the keyboard
    handling code is in the pure virtual functions within both the `Bob` and `Thomas`
    classes, and that the `handleInput` function returns `true` when a jump has been
    successfully initiated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Input.cpp` file and add the highlighted lines of code to play
    a jump sound when either Thomas or Bob successfully begins a jump:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open up the `Update.cpp` file and add the highlighted line of code to play
    a success sound when both Thomas and Bob have simultaneously reached the goal
    for the current level:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also within the `Update.cpp` file, we will add code to loop through the `m_FireEmitters`
    vector and decide when we need to call the `playFire` function of the `SoundManager`
    class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Look closely at the small amount of context around the new highlighted code.
    It is essential to add this code in exactly the right place:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code is a bit like collision detection for sound. Whenever Thomas
    stays within a 500-by-500 pixel rectangle surrounding a fire emitter, the `playFire`
    function is called, passing in the coordinates of the emitter and of Thomas. The
    `playFire` function does the rest of the work and sets off a spatialized, looping
    sound effect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `DetectCollisions.cpp` file, find the appropriate place, and add
    the highlighted code as shown in the following. The two highlighted lines of code
    trigger the playing of a sound effect when either character falls into a water
    or fire tile:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Playing the game will allow you to hear all the sounds, including cool spatialization,
    when near a fire tile.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The HUD class
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HUD is super-simple and not really anything different compared to the other
    two projects in the book. What we will do that is different is wrap all the code
    up in a new HUD class. If we declare all the Font, Text, and other variables as
    members of this new class, we can then initialize them in the constructor and
    provide getter functions to all their values. This will keep the `Engine` class
    clear from loads of declarations and initializations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Coding HUD.h
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will code the `HUD.h` file with all the member variables and function
    declarations. Right-click **Header Files** in the **Solution Explorer** and select
    **Add** | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File** (`.h`) and then in the **Name** field, type `HUD.h`. Finally,
    click the **Add** button. We are now ready to code the header file for the `HUD`
    class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `HUD.h`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous code, we added one `Font` instance and three `Text` instances.
    The `Text` objects will be used to show a message prompting the user to start,
    the time remaining, and the current level number.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The public functions are more interesting. First, there is the constructor,
    where most of the code will go. The constructor will initialize the `Font` and
    `Text` objects, as well as position them on the screen relative to the current
    screen resolution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The three getter functions, `getMessage`, `getLevel`, and `getTime` will return
    a `Text` object to the calling code in order to be able to draw them to the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The `setLevel` and `setTime` functions will be used to update the text shown
    in `m_LevelText` and `m_TimeText`, `respectively`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Now we can code all the definitions for the functions we have just outlined.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Coding the HUD.cpp file
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `HUD.cpp`. Finally,
    click the **Add** button. We are now ready to code the `.cpp` file for the `HUD`
    class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the include directives and the following code, and then we will discuss
    it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we store the horizontal and vertical resolution in a `Vector2u` called
    `resolution`. Next, we load the font from the `fonts` directory that we added
    back in [Chapter 12](ch12.html "Chapter 12. Abstraction and Code Management –
    Making Better Use of OOP"), A*bstraction and Code Management - Making Better Use
    of OOP*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The next four lines of code set the font, the color, the size, and the text
    of `m_StartText`. The block of code after this captures the size of the rectangle
    that wraps `m_StartText` and performs a calculation to work out how to position
    it centrally on the screen. If you want a more thorough explanation of this part
    of the code, refer back to [Chapter 3](ch03.html "Chapter 3. C++ Strings, SFML
    Time, Player Input, and HUD"): *C++ Strings, SFML Time - Player Input and HUD*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The final two blocks of code in the constructor set the font, text size, color,
    position, and actual text for `m_TimeText` and `m_LevelText`. We will see in a
    moment, however, that these two `Text` objects will be updatable through two setter
    functions, whenever it is required.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following getter and setter functions immediately after the code we
    have just added:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first three functions in the previous code simply return the appropriate
    `Text` object, `m_StartText`, `m_LevelText`, and `m_TimeText`. We will use these
    functions shortly, when drawing the HUD on the screen. The final two functions,
    `setLevel` and `setTime`, use the `setString` functions to update the appropriate
    `Text` object with the value that will be passed in from the `update` function
    of the `Engine` class every 500 frames.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: With all that done, we can put the HUD class to work in our game engine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Using the HUD class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open `Engine.h`, add an include for our new class, declare an instance of the
    new `HUD` class, and also declare and initialize two new member variables that
    will keep track of how often we update the HUD. As we have learned in the two
    previous projects, we don't need to do this for every frame.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code to `Engine.h`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to add some code to the `update` function of the `Engine` class.
    Open `Update.cpp` and add the highlighted code to update the HUD once every 500
    frames:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous code, `m_FramesSinceLastUpdate` is incremented each frame. When
    `m_FramesSinceLastUpdate` exceeds `m_TargetFramesPerHUDUpdate`, execution enters
    the `if` block. Inside the `if` block, we use `stringstream` objects to update
    our `Text`, as we have done in both previous projects. As you probably expected,
    however, in this project we are using the `HUD` class, so we call the `setTime`
    and `setLevel` functions, passing in the current values that the `Text` objects
    need to be set to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`m_FramesSinceLastUpdate`每帧递增。当`m_FramesSinceLastUpdate`超过`m_TargetFramesPerHUDUpdate`时，执行进入`if`块。在`if`块内，我们使用`stringstream`对象来更新我们的`Text`，就像我们在之前的两个项目中所做的那样。然而，正如你可能期望的那样，在这个项目中我们使用了`HUD`类，所以我们调用`setTime`和`setLevel`函数，传入`Text`对象需要设置的当前值。
- en: The final step in the `if` block is to set `m_FramesSinceLastUpdate` back to
    zero so it can start counting toward the next update.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`块中的最后一步是将`m_FramesSinceLastUpdate`设置回零，这样它就可以开始计算下一个更新。'
- en: 'Finally, open the `Draw.cpp` file and add the highlighted code to draw the
    HUD, each frame:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开`Draw.cpp`文件，并添加高亮代码以在每一帧绘制HUD：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous code draws the HUD by using the getter functions from the HUD class.
    Notice that the call to draw the message to that prompts the player to start is
    only used when the game is not currently playing `(!m_Playing)`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码通过使用HUD类的getter函数来绘制HUD。请注意，只有在游戏当前没有进行时才会调用绘制提示玩家开始的消息`(!m_Playing)`。
- en: Run the game and play a few levels to see the time tick down and the levels
    tick up. When you get back to level one again, notice that you have 10% less time
    than before.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并玩几个关卡，看时间倒计时和关卡增加。当你再次回到第一关时，注意你的时间比之前少了10%。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our Thomas Was Late game is not only fully playable, with directional sound
    effects and a simple but informative HUD, but we also have the capability to add
    new levels with ease. At this point, we could call it done.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏《Thomas Was Late》不仅可以完全玩得了，还有方向性的音效和简单但信息丰富的HUD，而且我们还可以轻松添加新的关卡。在这一点上，我们可以说它已经完成了。
- en: It would be nice to add a bit more sparkle. In the following chapter, we will
    look into two gaming concepts. Firstly we will look at particle systems, which
    are how we can handle things such as explosions or other special effects. To achieve
    this, we will need to learn a bit more C++, look at a way we might radically rethink
    how we structure our game code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些闪光效果会很好。在接下来的章节中，我们将探讨两个游戏概念。首先，我们将研究粒子系统，这是我们如何处理爆炸或其他特殊效果的方法。为了实现这一点，我们需要学习更多的C++知识，看看我们如何彻底重新思考我们的游戏代码结构。
- en: After that, we will add the final flourish to the game when we learn about OpenGL
    and the programmable graphics pipeline. We will then be in a position to dip our
    toes into the **GLSL** language, which allows us to write code that executes directly
    on the GPU, to create some special effects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们学习OpenGL和可编程图形管线时，我们将为游戏添加最后的点睛之笔。然后，我们将有机会涉足**GLSL**语言，这使我们能够编写直接在GPU上执行的代码，以创建一些特殊效果。
