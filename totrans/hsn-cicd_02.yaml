- en: Basics of Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will help introduce the concept of **continuous integration** (**CI**)
    and will help set up the foundation of the CI/CD concepts that we will explore
    in the later chapters. It is important to understand what a CI build is intended
    for as these concepts transcend any given CI/CD tool that you may use. CI is important
    because it helps keep a codebase healthy and helps developers keep a software
    system running independently of any particular developer machine. A CI build enforces
    independence of software components and local environment configuration. The CI
    build should be decoupled from any one developer configuration and should be able
    to be repeatable and isolated in terms of state. Each build that is run should
    in essence be independent, as this guarantees that a software system is working
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is CI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mitigating risks by utilizing CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software builds at source code check-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small builds and large build breakdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI build practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter only assumes a cursory understanding of version control systems
    but the reader should at least understand what configuration files are, and have
    a basic understanding of programming. We will briefly look at an example makefile
    and there will be some code snippets in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at several code examples in this chapter, including an API Workshop
    ([https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop)) where
    we will explain a Makefile and a Demo Application ([https://github.com/jbelmont/advanced-tech-in-wilmington-react-app](https://github.com/jbelmont/advanced-tech-in-wilmington-react-app))
    that uses React/Node.js/Express.js/RethinkDB, and we will also showcase a `gulp.js`
    script file.
  prefs: []
  type: TYPE_NORMAL
- en: What is CI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI is essentially a software engineering task where source code is both merged
    and tested on a mainline trunk. A CI task can do any multitude of tasks, including
    testing software components and deploying software components. The act of CI is
    essentially prescriptive and is an act that can be performed by any developer,
    system administrator, or operations personnel. Continuous integration is continuous
    because a developer can be continuously integrating software components while
    developing software.
  prefs: []
  type: TYPE_NORMAL
- en: What is a software build anyway?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software build is more than just a compilation step. A software build can
    consist of a compilation step, a testing phase, a code inspection phase, and a
    deployment phase. A software build can act as a kind of verification step that
    checks that your software is working as a cohesive unit. Statically compiled languages,
    such as Golang and C++, often have build tools that generate a binary. For example,
    a Golang build command, such as `go build`, will both generate a statically compiled
    binary and run linting on the codebase. Other languages, such as JavaScript, can
    use a tool such as `gulp.js`/`grunt.js` to do what are considered build steps,
    such as **minification**—converting multiple JavaScript source files into one
    file—and **uglification**, which strips the comments and any whitespace of a source
    file, as well as linting and running test runners.
  prefs: []
  type: TYPE_NORMAL
- en: CI process steps in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A developer can commit code to a **version control** **projects** (**VCP**)
    system, such as GitHub and GitLab. The CI server can either poll the repository
    for changes or the CI server can be configured to trigger a software build via
    a WebHook. We will look at this later with Jenkins, Travis, and Circle CI. The
    CI server will then get the latest software revision from the VCP system and can
    then execute a build script that integrates the software system. The CI server
    should generate feedback that emails build results upon a build failure to specified
    project members. The CI server will continuously poll for changes or will respond
    from a configured WebHook.
  prefs: []
  type: TYPE_NORMAL
- en: The value of CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI is valuable for many reasons. First and foremost, a CI build is valuable
    because it can reduce risks, and the health of your software becomes measurable.
    CI helps reduce developer assumptions. A CI environment should not rely on environment
    variables, nor rely on certain configuration files that are set on any one person's
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: The CI build should be built cleanly and independently from each developer's
    local machine and a CI build should be decoupled from any local environment. If
    a developer says that a build works on his/her machine but other developers cannot
    run the same exact code, then you know that a build may not be functioning properly.
    A CI build can help with such issues because the CI build is decoupled from any
    given developer's setup and environment variables and behaves independently of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: A CI build should reduce repetitive manual processes and the CI build process
    should run the same way on every build. A CI build process might consist of a
    compilation step, a test phase, and a report-generation phase. The CI build process
    should run every time a developer pushes a commit to a version control system
    such as Git, subversion, and mercurial. The CI build should free up developers
    to work on higher value work and should reduce possible mistakes that are done
    by repetitive manual processes.
  prefs: []
  type: TYPE_NORMAL
- en: A good CI build should help generate deployable software anytime and anywhere.
    A CI build should enable project visibility and should establish confidence in
    your software with the development team. Developers can rest assured that a CI
    build will catch issues with code changes more so than when a build is run locally.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating risks by utilizing CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI can help mitigate risks that are prevalent in software builds, such as *it
    works in my machine* syndrome. CI also helps unify integration points of failure,
    such as database logic as well as a host of other types of issues.
  prefs: []
  type: TYPE_NORMAL
- en: But it works on my machine!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common thread among developers is where a software build works on one developer's
    machine but does not work on another developer's machine. Each developer's machine
    should mirror—as closely as possible—software integration. Everything that is
    needed to do a software build needs to be committed to a version control system.
    Developers should not have custom build scripts that exist only on their local
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: Database synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any database artifacts that are needed to complete a software build should be
    stored in version control. If you have a relational database, then any database
    creation scripts, data manipulation scripts, SQL stored procedures, and database
    triggers should be stored in version control.
  prefs: []
  type: TYPE_NORMAL
- en: If, for example, you have a NoSQL database system, such as MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/)),
    and are utilizing a RESTful API, then be sure to document API endpoints in a document.
    Remember that developers might need database-specific code to actually run a software
    build.
  prefs: []
  type: TYPE_NORMAL
- en: A missing deployment automation phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software deployments should be automated using a deployment tool. Deployment
    tools that you use can vary depending on different software architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of deployment tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Octopus Deploy ([https://octopus.com/](https://octopus.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Elastic Beanstalk ([https://aws.amazon.com/elasticbeanstalk/](https://aws.amazon.com/elasticbeanstalk/)[)](https://aws.amazon.com/elasticbeanstalk/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heroku ([https://www.heroku.com/](https://www.heroku.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google App Engine ([https://cloud.google.com/appengine/](https://cloud.google.com/appengine/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dokku ([http://dokku.viewdocs.io/dokku/](http://dokku.viewdocs.io/dokku/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deployment tool is valuable because they tend to be cross-platform and can
    be used in many different software architectures. If, for example, a developer
    writes a Bash script, then there is an underlying assumption that other developers
    are working on a Unix-like system, and a developer working in a Windows environment
    may not be able to run the script depending on the Windows version they are using.
    Windows 10 is now offering a bash subsystem where Windows developers can run Unix
    commands and scripts while operating a Windows OS.
  prefs: []
  type: TYPE_NORMAL
- en: Late discovery of defects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CI build can help prevent the late discovery of software defects. A CI build
    should have a good enough test suite that covers a large percentage of the codebase.
    One possible metric for a healthy codebase is having 70% or more code coverage
    in a code base. We will talk later about code coverage, but any software tests
    should be in checked into source code and tests should be run on a CI build. Any
    software tests that you have should be run continuously on a CI system.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage not known
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, a high percentage of code coverage indicates a well-tested codebase,
    but does not necessarily guarantee a codebase has no software bugs—just that the
    test suite has good test coverage throughout. Try to use a code coverage tool
    in order to see how much of your tests are actually covering your source code.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some popular code coverage tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Istanbul** ([h](https://istanbul.js.org/)[ttps://istanbul.js.org/](https://istanbul.js.org/)): Yet
    another JavaScript code coverage tool that computes statement, line, function,
    and branch coverage with module loader hooks to transparently add coverage when
    running tests. Supports all JS coverage use cases including unit tests, server-side
    functional tests, and browser tests. Built for scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goveralls** ([https://github.com/mattn/goveralls](https://github.com/mattn/goveralls)):
    Go integration for the [https://coveralls.io/](https://coveralls.io/) continuous
    code coverage tracking system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dotCover** ([https://www.jetbrains.com/dotcover/](https://www.jetbrains.com/dotcover/)):
    JetBrains dotCover is a .NET unit test runner and code coverage tool that integrates
    with Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you know to what extent your code is covered with unit tests. dotCover
    calculates and reports statement-level code coverage in applications targeting .NET
    Framework, Silverlight, and .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of project visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A CI system should be configured to send alerts in a multitude of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push notification alerts via smartphone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some software development offices also use some other creative ways to send
    issue notifications on a software build, such as some kind of ambient light change
    or maybe even an intercom system. The main point is that developers need to be
    notified that the CI build is broken so that they can quickly fix the build. The
    CI build should not stay broken as this can disrupt other developers work.
  prefs: []
  type: TYPE_NORMAL
- en: Software builds at source code check-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software builds should be triggered upon each source code check-in in a version
    control system. This is an important step in the deployment pipeline, as we will
    see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What is a software build again?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software build can consist of just compiling software components. A build
    can consist of compiling and running automated tests, but, in general, the more
    processes you add to the build, the slower the feedback loop becomes on a build.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Favor using a scripting tool that is designed specifically for building software
    over personal scripts. Custom Shell scripts or batch scripts tend not to be cross-platform
    and can hide environment configuration. A scripting tool is the most effective
    process for developing a consistent, repeatable build solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of scripting tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Make ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven ([https://maven.apache.org/](https://maven.apache.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leiningen ([https://leiningen.org/](https://leiningen.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack ([https://docs.haskellstack.org/en/stable/README/](https://docs.haskellstack.org/en/stable/README/)[)](https://docs.haskellstack.org/en/stable/README/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing single command builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strive to make single command builds to ease the process of building software,
    because the easier you make running the build process, the more you will speed
    up adoption and developer involvement. If doing a software build is a complicated
    process, then you will end up having only a few developers actually doing a build,
    which is not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Building your software in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create your build using a scripting tool, such as Ant ([https://ant.apache.org/](https://ant.apache.org/)),
    Make ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/)),
    Maven ([https://maven.apache.org/](https://maven.apache.org/)), or Rake ([https://ruby.github.io/rake/](https://ruby.github.io/rake/))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start with a simple process in the CI build
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add each process to integrate your software within the build script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run your script from the command line or an IDE
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example makefile that runs a Golang API Service from my open source
    [https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example build script using `gulp.js` that generates a CSS build
    from `sass` source files and runs a linter. The first block sh initialization
    of variables and getting of configuration objects ready for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This second block of code is where we set up gulp tasks: copying React.js files,
    doing uglification of JavaScript files, creating a build JavaScript file, and
    creating CSS files from Sass files.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this final block of code, we run some watcher tasks that will watch any
    changes in the JavaScript files and Sass files, do linting, and create a nodemon
    process that will restart the Node server on any file changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Separating build scripts from your IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to avoid coupling your build scripts to any particular **Integrated Development
    Environment** (**IDE**). A build script shouldn't be dependent on any IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Each developer may be using a different IDE/editor and may have different configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CI server must execute an automated build without any human intervention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software assets should be centralized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software assets should be available on a centralized version
    control repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Components, such as source files or library files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party components, such as DLLs and JAR files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data files that are needed to initialize an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build scripts and build environment settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation scripts that are needed for some components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must decide what should go into version control.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a consistent directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must choose a consistent directory structure for your software assets, as
    it can help you perform scripted retrievals from a CI server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample folder structure that I have done for a skeleton React/Redux
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ca` (certificate authority)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config` (configuration files)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db` (database-related stuff)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docs` (documentation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models` (data files)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test` (all my test files)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`integration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e2e`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helpers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`components`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constants`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reducers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scss`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utils` (utility files)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is another directory structure that I have followed, which is package
    oriented and recommended by **Bill Kennedy from the Golang Community** ([https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html](https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`kit`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages that provide foundational support for the different application projects
    that exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging, configuration, or web functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages that provide support for a specific program that is being built for
    startup, shutdown, and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages that provide support for the different programs the project owns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD, services, or business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal/platform/`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages that provide internal foundational support for the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database, authentication, or marshaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main point is that you should follow a standard naming convention for your
    codebase that all developers follow. This will help the developer team work as
    they will be familiar with particular things laid out in the code. Not everyone
    will agree with a particular directory layout, but having a standard is the most
    important part. Anyone working on a newer service, for example, should be able
    to set up the project structure based on a codified naming convention for folders,
    where source files go, and where test files are placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca6c3c46-7b87-4941-97c9-a6a4bf33fb88.png)'
  prefs: []
  type: TYPE_IMG
- en: Here is a sample directory structure that I am using for an API Workshop ([https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop))
    that I created in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Software builds should fail fast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This can be achieved by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating software components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running true unit tests—unit tests that don't rely on a database but run in
    isolation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensuring that unit tests are able to run quickly. If a unit test takes an order
    of minutes, then this could be an indication of a problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running other automated processes (rebuild database, inspect, and deploy).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is up to each company what other steps are necessary for their builds.
  prefs: []
  type: TYPE_NORMAL
- en: Building for any environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration files and environment variables should be set for different environments,
    such as dev/prod/test. Logging verbosity should be able to be set as per the environment. Developers
    might need increased logging for debugging. Application server configuration information
    can be set in a build file as well as database connection information and framework
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example text file that can be used. One thing to note is that such
    files should not be committed to source control as they may contain client secrets
    and API secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Configuration text files such as these can help other developers connect to
    third-party services and will help organize where client secret information is
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: Small build and large build breakdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A small build is usually a build that can be run quickly by the CI server and
    will usually consist of a compilation step as well as running all the unit tests.
    A small build can be optimized by running staged builds, which will be discussed
    in the *CI build practices* section.
  prefs: []
  type: TYPE_NORMAL
- en: A large build is a build that essentially runs all of the build tasks in one
    large build. The disadvantage of doing a large build is that they discourage developers
    from running them. If a software build takes a long time to run, then many developers
    will avoid running the build at all. Smaller builds that run quickly encourage
    developers to continuously check-in their changes on a version control system
    and will help keep a codebase healthy.
  prefs: []
  type: TYPE_NORMAL
- en: CI build practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI build practices are like stepping stones; they build up on top of each other.
    As we will see in the next chapter, each step in the CI build process is important
    and provides assurance that your codebase is in a healthy condition.
  prefs: []
  type: TYPE_NORMAL
- en: Private build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers should run private builds prior to committing code to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample developer session using Git:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the code you will alter from the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go into the version controlled folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git checkout -b new_branch`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make changes to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `myFile.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the latest system changes from the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git pull`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a build that executes of all your unit tests and possibly integration tests
    in your local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit your code changes to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI build should automatically trigger a build and run any tests in the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI build should also do other tasks, such as reporting and calling other
    services if need be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usage of CI server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CI server should either be polling for changes in version control repository
    systems, such as GitHub, at a specified time interval, or be configured via WebHook
    to trigger a software build. A CI build should perform certain actions on a scheduled
    basis—hourly or daily, if needs be. You should identify a *quiet period* during
    which no integration builds are performed for the project. A CI server should
    support different build scripting tools, such as Rake, Make, NPM, or Ant. A CI
    server should send emails to concerned parties, as well as display a history of
    previous builds.
  prefs: []
  type: TYPE_NORMAL
- en: A CI server should display a dashboard that is web accessible so that all concerned
    parties can review integration build information when necessary. Jenkins, Travis,
    and Circle CI all have dashboards that are web accessible. A CI server should
    support multiple version control systems for your different projects, such as
    svn, Git, and mercurial.
  prefs: []
  type: TYPE_NORMAL
- en: Manual integration builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running an integration build manually is an approach to reducing integration
    build errors if there is a long-running feature that will be difficult to run
    on a CI server—but use such techniques sparingly. For example, you could designate
    a machine that is not being used to do a manual integration task; although, with
    the cloud, it is now easier than ever to just spin up a server instance on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Running fast builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strive to run software builds as quickly as possible by increasing computing
    resources. Offload slower running tests, such as system-level tests, onto a secondary
    build or a nightly build. Offload code inspection to a third-party service. For
    example, for code coverage analysis, you can use the following third-party services:'
  prefs: []
  type: TYPE_NORMAL
- en: Codecov ([https://codecov.io/#features](https://codecov.io/#features))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coveralls ([https://coveralls.io/features](https://coveralls.io/features)[)](https://coveralls.io/features)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code climate [(](https://coveralls.io/features)[https://codeclimate.com/quality/](https://codeclimate.com/quality/)[)](https://coveralls.io/features)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Codacy ([https://www.codacy.com/product](https://www.codacy.com/product)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run staged builds to promote fast builds as well. The first build can compile
    and run all the unit tests. The second build can run all the integration tests
    and system-level tests. You can have as many stages as necessary to have fast
    builds. Arguably, the first build should be the fastest, as this will be the primary
    build that developers use when checking in code to a codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a foundation on CI concepts and introduced techniques
    for employing a successful CI server in a developer team. We looked at scripting
    tools and build tools. We discussed what a software build is, good practices to
    follow when creating a build script, and also some testing concepts, such as code
    coverage. The next chapter is on **continuous delivery** (**CD**), which is a
    natural extension to CI, and we will go into detail about the deployment pipeline,
    configuration management, deployment scripting, and the deployment ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a software build?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by a staged build?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you name some scripting tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you follow a naming convention and folder structure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the value of CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A great book to read that goes into more about CI is *Learning Continuous Integration
    with Jenkins – Second Edition: A beginner''s guide to implementing Continuous
    Integration and Continuous Delivery using Jenkins 2* ([https://www.amazon.com/dp/1788479351/](https://www.amazon.com/dp/1788479351/)),
    by Packt Publishing.'
  prefs: []
  type: TYPE_NORMAL
