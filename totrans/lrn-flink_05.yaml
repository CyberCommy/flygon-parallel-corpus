- en: Chapter 5. Complex Event Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about the Table API provided by Apache Flink
    and how we can use it to process relational data structures. This chapter onwards,
    we will start learning more about the libraries provided by Apache Flink and how
    we can use them for specific use cases. To start with, let's try to understand
    a library called **Complex Event Processing** (**CEP**). CEP is a very interesting
    but complex topic that has its value in various industries. Wherever there is
    a stream of events expected, naturally people want to perform complex event processing
    in all such use cases. Let's try to understand what CEP is all about.
  prefs: []
  type: TYPE_NORMAL
- en: What is complex event processing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CEP analyzes streams of disparate events occurring with high frequency and
    low latency. These days, streaming events can be found in various industries,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: In the oil and gas domain, sensor data comes from various drilling tools or
    from upstream oil pipeline equipment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the security domain, activity data, malware information, and usage pattern
    data come from various end points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the wearable domain, data comes from various wrist bands with information
    about your heart beat rate, your activity, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the banking domain, data comes from credit card usage, banking activities,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is very important to analyze variation patterns to get notified in real
    time about any change in the regular assembly. CEP can understand patterns across
    the streams of events, sub-events, and their sequences. CEP helps to identify
    meaningful patterns and complex relationships among unrelated events, and sends
    notifications in real and near real time to prevent damage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is complex event processing?](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows how the CEP flow works. Even though the flow looks
    simple, CEP has various abilities such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to produce results as soon as the input event stream is available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to provide computations such as aggregation over time and timeout
    between two events of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to provide real-time/near real-time alerts and notifications on
    detection of complex event patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to connect and correlate heterogeneous sources and analyze patterns
    in them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to achieve high-throughput, low-latency processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are various solutions available on the market. With big data technology
    advancements, we have multiple options like Apache Spark, Apache Samza, Apache
    Beam, among others, but none of them have a dedicated library to fit all solutions.
    Now let us try to understand what we can achieve with Flink's CEP library.
  prefs: []
  type: TYPE_NORMAL
- en: Flink CEP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apache Flink provides the Flink CEP library, which provides APIs to perform
    complex event processing. The library consists of the following core components:'
  prefs: []
  type: TYPE_NORMAL
- en: Event stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alert generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Flink CEP](img/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flink CEP works on Flink's streaming API called DataStream. A programmer needs
    to define the pattern to be detected from the stream of events and then Flink's
    CEP engine detects the pattern and takes the appropriate action, such as generating
    alerts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get started, we need to add the following Maven dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Event streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very important component of CEP is its input event stream. In earlier chapters,
    we have seen details of the DataStream API. Now let's use that knowledge to implement
    CEP. The very first thing we need to do is define a Java POJO for the event. Let's
    assume we need to monitor a temperature sensor event stream.
  prefs: []
  type: TYPE_NORMAL
- en: First we define an abstract class and then extend this class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While defining the event POJOs we need to make sure that we implement the `hashCode()`
    and `equals()` methods, because while comparing the events, compile will make
    use of them.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippets demonstrate this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we write an abstract class as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a POJO for the actual temperature event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define the event source as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Pattern API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pattern API allows you to define complex event patterns very easily. Each
    pattern consists of multiple states. To go from one state to another state, generally
    we need to define the conditions. The conditions could be continuity or filtered
    out events.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pattern API](img/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's try to understand each pattern operation in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Begin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initial state can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also specify the filter condition for the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Subtype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also filter out events based on their sub-types, using the `subtype()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern API also allows us define multiple conditions together. We can use `OR`
    and `AND` operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Continuity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, we do not always need to filter out events. There can always
    be some pattern where we need continuity instead of filters.
  prefs: []
  type: TYPE_NORMAL
- en: Continuity can be of two types - strict continuity and non-strict continuity.
  prefs: []
  type: TYPE_NORMAL
- en: Strict continuity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strict continuity needs two events to succeed directly which means there should
    be no other event in between. This pattern can be defined by `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Non-strict continuity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Non-strict continuity can be stated as other events are allowed to be in between
    the specific two events. This pattern can be defined by `followedBy()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Within
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern API also allows us to do pattern matching based on time intervals. We
    can define a time-based temporal constraint as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Detecting patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To detect patterns against a stream of events, we need to run the stream though
    the pattern. The `CEP.pattern()` returns `PatternStream`.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows how we can detect a pattern. First the pattern
    is defined to check if the temperature value is greater than `26.0` degrees in
    `10` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Selecting from patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the pattern stream is available, we need to select the pattern from it
    and then take appropriate actions based on it. We can use the `select` or `flatSelect`
    method to select data from the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Select
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The select method needs `PatternSelectionFunction` implementation. It has a
    select method which would be called for each event sequence. The `select` method
    receives a map of string/event pairs of matched events. The string is defined
    by the name of the state. The `select` method returns exactly one result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To collect the results, we need to define the output POJO. In our case, let''s
    say we need to generate alerts as output. Then we need to define POJO as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next we define the select functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: flatSelect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `flatSelect` method is similar to the `select` method. The only difference
    between the two is that `flatSelect` can return an arbitrary number of results.
    The `flatSelect` method has an additional `Collector` parameter which is used
    for output element.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how we can use the `flatSelect` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Handling timed-out partial patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we may miss out certain events if we have constrained the patterns
    with a time boundary. It is possible that events may be discarded because they
    exceed the length. In order to take actions on the timed out events, the `select`
    and `flatSelect` methods allow a timeout handler. This handler is called for each
    timeout event pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the select method contains two parameters: `PatternSelectFunction`
    and `PatternTimeoutFunction`. The return type for a timed out function can be
    different from the select pattern function. The timed out event and select event
    are wrapped in the class `Either.Right` and `Either.Left`.'
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippets shows how we do things in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, the select API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flatSelect` API is called with the `Collector` as it can emit an arbitrary
    number of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Use case - complex event processing on a temperature sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier sections, we learnt about various features provided by the Flink
    CEP engine. Now it's time to understand how we can use it in real-world solutions.
    For that, let's assume we work for a mechanical company which produces some products.
    In the product factory, there is a need to constantly monitor certain machines.
    The factory has already set up the sensors which keep on sending the temperature
    of the machines at a given time.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will be setting up a system that constantly monitors the temperature
    value and generates an alert if the temperature exceeds a certain value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case - complex event processing on a temperature sensor](img/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we will be using Kafka to collect events from sensors. In order to write
    a Java application, we first need to create a Maven project and add the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next we need to do following things for using Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to define a custom Kafka deserializer. This will read bytes from
    a Kafka topic and convert it into `TemperatureEvent`. The following is the code
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '`EventDeserializationSchema.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we create topics in Kafka called `temperature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we move to Java code which would listen to these events in Flink streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will define the pattern to check if the temperature is greater than
    `26.0` degrees Celsius within `10` seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next match this pattern with the stream of events and select the event. We
    will also add up the alert messages into results stream as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to know what the alerts were generated, we will print the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And we execute the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now we are all set to execute the application. As and when we get messages in
    Kafka topics, the CEP will keep on executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual execution will looks like the following. Here is how we can provide
    sample input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the sample output will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can also configure a mail client and use some external web hook to send e-mail
    or messenger notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code for the application can be found on GitHub: [https://github.com/deshpandetanmay/mastering-flink](https://github.com/deshpandetanmay/mastering-flink).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learnt about CEP. We discussed the challenges involved and
    how we can use the Flink CEP library to solve CEP problems. We also learnt about
    Pattern API and the various operators we can use to define the pattern. In the
    final section, we tried to connect the dots and see one complete use case. With
    some changes, this setup can be used as it is present in various other domains
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to use Flink's built-in Machine Learning
    library to solve complex problems.
  prefs: []
  type: TYPE_NORMAL
