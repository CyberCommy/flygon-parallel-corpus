- en: '13: Volumes and persistent data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to look at how Docker manages data. We’ll look at persistent and non-persistent
    data. However, the main focus of the chapter will be on persistent data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll split the chapter into the usual three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The TLDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes and persistent data - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two main categories of data. Persistent and non-persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent is the stuff you need to *keep*. Things like; customer records, financials,
    bookings, audit logs, and even some types of application *log* data. Non-persistent
    is the stuff you don’t need to keep.
  prefs: []
  type: TYPE_NORMAL
- en: Both are important, and Docker has options for both.
  prefs: []
  type: TYPE_NORMAL
- en: Every Docker container gets its own non-persistent storage. It’s automatically
    created, alongside the container, and it’s tied to the lifecycle of the container.
    That means deleting the container will delete this storage and any data on it.
  prefs: []
  type: TYPE_NORMAL
- en: If you want your container’s data to stick around (persist), you need to put
    it on a *volume*. Volumes are decoupled from containers, meaning you create and
    manage them separately, and they’re not tied to the lifecycle of any container.
    Net result, you can delete a container with a volume, and the volume will not
    be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the TLDR. Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes and persistent data - The Deep Dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Containers are excellent for microservices design patters. And we often associate
    microservices with words like *ephemeral* and *stateless*. So…. microservices
    are all about stateless and ephemeral workloads, and containers are great microservices.
    Therefore, we often jump to the conclusion that containers must be just for ephemeral
    stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Bu that’s wrong. Just wrong, wrong, wrong!
  prefs: []
  type: TYPE_NORMAL
- en: Containers and non-persistent data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s true that containers are great at stateless and non-persistent stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Every container automatically gets a bunch of local storage. By default, this
    is where all of the container’s files and filesystem go. You’ll hear this referred
    to by names like; *local storage*, *graphdriver storage*, and *snapshotter storage*.
    Either way, it’s an integral part of the container, and is tied to the container’s
    lifecycle — it gets created when the container gets created, and it gets deleted
    when the container gets deleted. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux systems, it exists somewhere under `/var/lib/docker/<storage-driver>/`
    as part of the container. On Windows it goes under `C:\ProgramData\Docker\windowsfilter\`.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re running Docker in production on Linux, you’ll want to make sure you
    match the right storage driver (graphdriver) with the version of Linux on your
    Docker host. Use the following list as a *guide:*
  prefs: []
  type: TYPE_NORMAL
- en: '**Red Hat Enterprise Linux:** Use the `overlay2` driver with modern versions
    of RHEL running Docker 17.06 or higher. Use the `devicemapper` driver with older
    versions. This applies to Oracle Linux and other Red Hat related upstream and
    downstream distros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ubuntu:** Use the `overlay2` or `aufs` drivers. If you’re using a Linux 4.x
    kernel or higher you should go with `overlay2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SUSE Linux Enterprise Server:** Use the `btrfs` storage driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows** Windows only has one driver and it is configured by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above list should only be used as a guide. As things progress, the `overlay2`
    driver is increasing in popularity and may become the recommended storage driver
    on more platforms. If you are using Docker Enterprise Edition (EE), and have a
    support contract, you should consult the latest compatibility support matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get back on track.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all storage within a container uses this *local storage*. So every
    directory in a container uses this storage by default.
  prefs: []
  type: TYPE_NORMAL
- en: If your containers don’t create persistent data, *local storage* will be fine
    and you’re good to go. But if your containers **do** need to persist data, you
    need to read the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and persistent data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The recommended way to persist data in containers is with *volumes*.
  prefs: []
  type: TYPE_NORMAL
- en: At a high-level, you create a volume, then you create a container, and you mount
    the volume into it. The volume gets mounted to a directory in the container’s
    filesystem, and anything written to that directory is written to the volume. If
    you then delete the container, the volume and its data will still exist.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 shows a Docker volume mounted into a container at `/code`. Any data
    written to the `/code` directory will be stored on the volume and will exist after
    the container is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 High-level view of volumes and containers](images/figure13-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 High-level view of volumes and containers
  prefs: []
  type: TYPE_NORMAL
- en: In Figure 13.1, the `/code` directory is a Docker volume. All other directories
    use the containers ephemeral local storage. The arrow from the volume to the `/code`
    directory is a dashed line to represent the decoupled relationship between volumes
    and containers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing Docker volumes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Volumes are first-class citizens in Docker. Among other things, this means they
    are their own object in the API, and they have their own `docker volume` sub-command.
  prefs: []
  type: TYPE_NORMAL
- en: Use the following command to create a new volume called `myvol`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`By default, Docker creates new volumes with the built-in `local` driver. As
    the name suggests, local volumes are only available to containers on the node
    they’re created on. Use the `-d` flag to specify a different driver.'
  prefs: []
  type: TYPE_NORMAL
- en: Third-party drivers are available as plugins. These can provide advanced storage
    features, and integrate external storage systems with Docker. Figure 13.2 shows
    an external storage system (e.g. SAN or NAS) being used to provide the backend
    storage for the volume. The driver integrates the external storage system, with
    its advanced features, into the Docker environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 Plugging external storage into Docker](images/figure13-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 Plugging external storage into Docker
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, there are over 25 volume plugins. These cover block
    storage, file storage, object storage, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block storage** tends to be high performance and good for small-block random
    access workloads. Examples of block storage systems with Docker volume plugins
    include HPE 3PAR, Amazon EBS, and the OpenStack Block Storage service (cinder).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File storage** includes systems that use the NFS and SMB protocols, and is
    also good for high performance workloads. Examples of file storage systems that
    have Docker volume plugins include NetApp FAS, Azure Files storage, and Amazon
    EFS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object storage** is good for long term storage of large data blobs that do
    not change frequently. It is often content addressable, and is usually low performance.
    Examples with Docker volume drivers include; Amazon S3, Ceph, and Minio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that the volume is created, you can see it with the `docker volume ls` command,
    and inspect it with the `docker volume inspect` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Some interesting points from the output of the `inspect` command. The `driver`
    and `scope` are both `local`. This means the volume was created with the default
    `local` driver, and is only available to containers on this Docker host. The `mountpoint`
    property tells us where on the host the volume is surfaced. In this example the
    volume is surfaced on the Docker host at `/var/lib/docker/volumes/myvol/_data`.
    On a Windows Docker host it will report as `Mountpoint": "C:\\ProgramData\\Docker\\volumes\\myvol\\_data`.'
  prefs: []
  type: TYPE_NORMAL
- en: All volumes created with the `local` driver get their own directory under `/var/lib/docker/volumes`
    on Linux, and `C:\ProgramData\Docker\volumes` on Windows. This means you can see
    them in your Docker host’s filesystem, and even read and write data to them from
    your Docker host. We saw an example of this in the chapter on Docker Compose —
    where we copied a file into a volume’s directory on the Docker host, and the file
    immediately appeared in the volume inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use the `myvol` volume with Docker services and containers. For
    example, you can mount it into a new container using `docker container run` with
    the `--mount` flag. We’ll see some examples in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to delete a Docker volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker volume prune`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume rm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume prune` will delete **all volumes** that are not mounted into
    a container or service replica, so **use with caution!** `docker volume rm` lets
    you specify exactly which volumes you want to delete. Neither command will delete
    a volume that is in use by a container or service replica.'
  prefs: []
  type: TYPE_NORMAL
- en: As the `myvol` volume is not in use, delete it with the `prune` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Congratulations, you’ve created, inspected, and deleted a Docker volume. And
    you did it all without interacting with a container. This demonstrates the independent
    nature of volumes.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you know all of the commands to create, list, inspect, and delete
    Docker volumes. However, it’s also possible to deploy volumes via Dockerfiles
    using the `VOLUME` instruction. The format is `VOLUME <container-mount-point`.
    However, it’s not possible to specify the host directory portion in a Dockerfile.
    This is because *host* directories are, by nature, *host*-dependent, meaning they
    can change between hosts and potentially break builds. If specifying via a Dockerfile,
    you have to specify host directories at deploy-time.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating volumes with containers and services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we know the basic volume-related Docker commands, let’s see how we
    use them with containers and services.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be working from a system with no volumes, and everything we demonstrate
    applies to both Linux and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Use the following command to create a new standalone container and mount a volume
    called `bizvol`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`**Windows example:**'
  prefs: []
  type: TYPE_NORMAL
- en: Use PowerShell for all Windows examples, and note the use of backticks (`) to
    split commands across multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`The command should run successfully, even though there is no volume on the
    system called `bizvol`. This raises an interesting point:'
  prefs: []
  type: TYPE_NORMAL
- en: If you specify an existing volume, Docker will use the existing volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you specify a volume that does not exist, Docker will create it for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, `bizvol` did not exist, so Docker created it and mounted it into
    the new container. This means you’ll be able to see it with `docker volume ls`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Although containers and volumes have separate lifecycle’s, you cannot delete
    a volume that is in use by a container. Try it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`The volume is currently empty. Let’s `exec` onto the container and write some
    data to it. The example cited is Linux, if you’re following along on Windows,
    you should replace `sh` with `pwsh.exe` at the end of the `docker container exec`
    command. All other commands will work on Linux and Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Type `exit` to return to the shell of your Docker host, and then delete the
    container with the following command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Even though the container is deleted, the volume still exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Because the volume still exists, you can look at its mount point on the host
    to check if the data you wrote is still there.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the following commands from the terminal of your Docker host. The first
    one will show that the file still exists, the second will show the contents of
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to use the `C:\ProgramData\Docker\volumes\bizvol\_data` directory if
    you’re following along on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Great, the volume and data still exists.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s even possible to mount the `bizvol` volume into a new service or container.
    The following command creates a new Docker service, called hellcat, and mounts
    bizvol into the service replica at `/vol`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`We didn’t specify the `--replicas` flag, so only a single service replica
    will be deployed. Find which node in the Swarm it’s running on.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`In this example, the replica is running on `node1`. Log on to `node1` and
    get the ID of the service replica container.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice that the container name is combination of `service-name`, `replica-number`,
    and `replica-ID` separated by periods.'
  prefs: []
  type: TYPE_NORMAL
- en: Exec onto the container and check that the data is present in `/vol`. We’ll
    use the service replica’s container ID in the `exec` example. If you’re following
    along on Windows, remember to replace `sh` with `pwsh.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`I guess it’s time to jump over to Amazon and write that book review :-D'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent, the volume has preserved the original data and made it available
    to a new container.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing storage across cluster nodes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Integrating Docker with external storage systems makes it easy to share the
    external storage between cluster nodes. For example, a single storage LUN or NFS
    share can be presented to multiple Docker hosts, and therefore made available
    to containers and service replicas no-matter which host they’re running on. Figure
    13.3 shows a single external shared volume being shared presented to two Docker
    nodes. These Docker nodes then make the shared volume available to a couple of
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3](images/figure13-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3
  prefs: []
  type: TYPE_NORMAL
- en: Building a setup like this requires knowledge of the external storage system,
    as well as how your applications read and write data to the shared storage.
  prefs: []
  type: TYPE_NORMAL
- en: A major concern with a configuration like this is **data corruption**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the following example based on Figure 13.3: Container A on node1 updates
    some data in the shared volume. But instead of writing the update directly to
    the volume, it holds it in its local buffer for faster recall. At this point,
    Container A thinks the data has been updated. However, before container A on node
    1 flushes its buffers and commits the data to the volume, container B on node
    2 updates the same data with a different value and commits it straight to the
    volume. At this point, both containers *think* they’ve updated the data in the
    volume, but in reality only container B has. At a later date, container A on node
    1 flushes its buffers, overwriting the previous changes container B on node 2
    made. But container B and node 2 may not be made aware of this. This is how corruption
    happens.'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, you need to write your applications in a way to avoid this.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes and persistent data - The Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`docker volume create` is the command we use to create new volumes. By default,
    volumes are created with the native `local` driver, but you can use the `-d` flag
    to specify a different driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume ls` will list all volumes on the local Docker host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume inspect` shows detailed volume information. Use this command
    to find out where a volume exists in the Docker host’s filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume prune` will delete **all** volumes that are not in use by a
    container or service replica. **Use with caution!**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume rm` deletes specific volumes that are not in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two main types of data: persistent and non-persistent data. Persistent
    data is data that you need to keep, non-persistent is data that you don’t need
    to keep. By default, all containers get non-persistent storage that lives and
    dies with the container — we call this *local storage* and it’s ideal for non-persistent
    data. However, if your containers create data that you need to keep, you should
    store the data in a Docker volume.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes are first-class citizens in the Docker API, and are managed independently
    of containers with their own `docker volume` sub-command. This means that deleting
    a container will not delete the volumes it was using.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes are the recommended way to work with persistent data in a Docker environment.[PRE15]
  prefs: []
  type: TYPE_NORMAL
