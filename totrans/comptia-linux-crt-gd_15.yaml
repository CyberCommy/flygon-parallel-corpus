- en: Fundamentals of Internet Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, the focus was on maintaining the system's time and logging.
    Particularly, we touched on ways in which we could manipulate the system. Next,
    we worked with logging and explored the common log files. Finally, we worked with
    remote. We then generated test logs over on our Fedora system and verified that
    we received the logs over on our Ubuntu `rsyslog` server.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the focus is all about **Internet Protocol** (**IP**). We start
    off with IPv4, looking at the address structure and the various IPv4 addresses
    commonly used in today's environment. We then move on to subnetting an IPv4 address,
    determining the network and host portion of an IPv4 address. This is then followed
    up with IPv6\. We look at the structure of an IPv6 address and some well-known
    IPv6 addresses. Then we focus on ways by which we can reduce the lengthy IPv6
    address. Finally, our focus is on the protocols. We will cover some well-known
    protocols and their respective port numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 addressing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 addressing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well-known protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv4 addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IP version 4 is the fourth version of IP. It plays a vital role in the internet
    as we know it. By far, IPv4 is the most commonly used protocol for addressing
    various devices within a network and out on the internet. Another interesting
    fact about IP is that it's not connection-oriented as is the case for TCP; instead,
    IP is connectionless.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv4 address is made of 32 bits or 4-bytes in length. We calculate the addresses
    in base 2; this gives us 2^32, which equals 4,294,967,296 addresses. It may seem
    as though there are plenty of IPv4 addresses; however, the reality differs. In
    fact, there is currently an IPv4 shortage. An IPv4 address is represented in dotted
    decimal format. An example of an IPv4 address is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that an IPv4 address is indeed represented in a dotted decimal
    format. The dots `.` act as separators between the address. The numbers can be
    anywhere between 0 and 255, including the 0 and 255\. Each portion of an IPv4
    address is known as an octet; thus, the four numbers make up four octets. There
    are various types of IPv4 addresses available in today''s environment; particularly
    within a** local area network** (**LAN**), you may see one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10.0.0.0/8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`172.16.0.0/12`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.16.0.0/16`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The addresses may look familiar. These three addresses can be further explained
    by the RFC 1918; this specifies certain addresses that are to be used within a
    private network, such as a LAN.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have five classes of address space; the first four classes are commonly
    used in various types of environment. These are classes of addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class A |  0-127 |'
  prefs: []
  type: TYPE_TB
- en: '| Class B |  128-191 |'
  prefs: []
  type: TYPE_TB
- en: '| Class C  | 192-223 |'
  prefs: []
  type: TYPE_TB
- en: '| Class D | 224-239 |'
  prefs: []
  type: TYPE_TB
- en: '| Class E |  240-255 |'
  prefs: []
  type: TYPE_TB
- en: 'Here, the number range represents the place holder in the first octet. We can
    break down an IPv4 address in order to gain a better understanding. We will use
    the first octet as reference. First, we will build a table. Every octet of an
    IPv4 address represents 1 byte; 1 byte = 8 bits. We can then use this information
    to form our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit positions |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 18 | 4 | 2 | 1 |  = 255 |'
  prefs: []
  type: TYPE_TB
- en: 'Awesome! Based on this, the reason we counted from 7 to 0 is because we always
    start at 0 when calculating a value for an octet inside an IPv4 address and move
    from right to left when adding. Now, the way we got the value was by multiputting
    2^x, where x = the last character to the right. So it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8-bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 1 means that the bit is turned on |'
  prefs: []
  type: TYPE_TB
- en: '| 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ |  = base 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 128 |  6 | 32 |  16 |   8  | 4    |  2  |  1  |  = Result of base 2 for each
    bit position |'
  prefs: []
  type: TYPE_TB
- en: Using all of the values inside the 8 bits, we get *128+64+32+16+8+4+2+1 = 255*.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this, we now see how the table is built using base 2 for calculation.
    Hence, at any given time, only values between 0-255, including the 0 and 255,
    are legal values.
  prefs: []
  type: TYPE_NORMAL
- en: Class A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Class A address space, 0-127, looks at the only leading bit position (position
    7 because we count from 0 to 7) in the first octet; this is known as the most
    significant bit position. The 127 address space is reserved; this is known as
    the loopback address space. Hence, we are only using the values 0-126\. Moreover,
    the 0 is actually reserved for network use (more on this later when we cover subnetting).
    For now, the way we calculate the first values for a Class A address is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 0-127 |'
  prefs: []
  type: TYPE_TB
- en: 'Based on this, we have all eight bits turned off in the first octet. This,
    therefore, gives us the Class A address space which is between 0-126 in first
    octet, 0 being reserved and 127 being the loopback space. Hence, the real usable
    IPv4 addresses in the first octet are 1-126\. This is then followed by the three
    remaining octets being all zeros. So the Class A address space would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Class A `0-126.0.0.0/8`, where the leading bit is 0 in the 8th bit position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class A reserved address space `127.0.0.0/8`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class A **Automatic Private IP Addressin**g (**APIPA**) `169.0.0.0/8` reserved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on this, we are given a maximum of up to 126 networks that we can define.
    The remaining three octets of the Class A address `0.0.0` makes up the host portion;
    each octet is made up of eight bits. A host is any device that can be assigned
    an IPv4 address(s). The maximum number of hosts allowed in a Class A address is
    16,777,214 hosts per network defined. The host portion is the result of 2^3 octets
    (eight bits per octet x 3 =24 bits) – 2 = 1677216-2 = 16,777,214 hosts per Class
    A network.
  prefs: []
  type: TYPE_NORMAL
- en: Class B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Class B address spaces, 128-191, look at the leading bits position 7 and
    6 (remember that we start counting from 0, moving from left to right). The first
    most significant bit, position 7, is turned on in binary. This is set to 1 and
    the second most significant bit, position 6, is set to 0\. This can be seen using
    the table that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128 |'
  prefs: []
  type: TYPE_TB
- en: 'Based on this, the most significant bit is turned on and the second most significant
    bit is turned off. This gives us the address space of 128-191, where the 128 is
    reserved for network use and the 191 is reserved as the broadcast address. We
    will discuss broadcast addresses later in this chapter when we cover subnetting.
    In a Class B address space, the first 16 bits are reserved for network use; however,
    two bits are reserved. This would then give us 2^14 = 16,384 networks per Class
    B address. This can be illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128 |'
  prefs: []
  type: TYPE_TB
- en: We have to skip the first two bits, positions 7 and 6; this then gives us 2^14
    = 163864 networks
  prefs: []
  type: TYPE_NORMAL
- en: Based on this, we see the maximum amount of the networks available but we don't
    see the maximum amount of hosts. Well, the way we calculate the hosts for a Class
    B address is to use the last two octets for the hosts; we would do 2^2 octets
    (eight bits per octets x 2 = 16 bits)—two bits for network and broadcast = 65,536
    -2 = 65,534 hosts per Class B network.
  prefs: []
  type: TYPE_NORMAL
- en: Class C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Class C address space, 192-223, takes the first three most significant
    bits in to consideration; namely, positions 7,6, and 5\. The first two most significant
    bits are turned on; they are set to 1 in binary. The third bit, position 5 in
    binary, is turned off; this is set to 0\. The first 24 bits are reserved for network
    use in a Class C address space. We can then construct our table using this information.
    This is how the table would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128+64=>192 |'
  prefs: []
  type: TYPE_TB
- en: 'Based on this, we can then see that the Class C address space starts at 192
    and ends at 223\. The 192 is reserved for the network and the 223 is reserved
    as the broadcast. We can then calculate the number of networks by using 2^21 =
    2,097,152 networks. This can be represented in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  = first 3 bits total 192 |'
  prefs: []
  type: TYPE_TB
- en: 24 bits are reserved for Class C, 24 bits—three most significant bits = 21 then
    2^21 bits = 2,097,152 networks.
  prefs: []
  type: TYPE_NORMAL
- en: The last octet `.0` (eight bits) is reserved for the host addresses. This then
    means 2^1 octet (8 bits) – 2 bits for network and broadcast = 256 - 2 = 254 hosts
    per Class C address.
  prefs: []
  type: TYPE_NORMAL
- en: Class D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Class D, 224-239, address space is reserved for multicast use. The first
    three most significant bits are turned on; they are set to 1\. The fourth most
    significant bit is set to 0\. The Class D address space is not used for IP addressing,
    as is the case in the previous classes of address. Instead, the Class D address
    space is used to assign an IP address to a multicast group. The hosts then are
    part of a group that in turn shares a group address. The following table illustrates
    the bits that are used for the Class D address space:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  = total 224 |'
  prefs: []
  type: TYPE_TB
- en: Based on this, the Class D address space starts at `224.0.0.0` and ends at `239.255.255.255`.
  prefs: []
  type: TYPE_NORMAL
- en: Class E
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Class E, 240-255, address space is reserved for future use. As such, it
    is not implemented as is the previous address space. The first four most significant
    bits are turned on; they are set to 1\. The only address that is used in a Class
    E is the `255.255.255.255`; this is what is known as the all broadcast address.
    The following table illustrates the bits that are used for the Class E address
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  = total 240 |'
  prefs: []
  type: TYPE_TB
- en: Based on this, the Class E address space starts at `240.0.0.0` and ends at `255.255.255.255`,
    where `255.255.255.255` is reserved for the all broadcast address.
  prefs: []
  type: TYPE_NORMAL
- en: Subnet masks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve just covered the various classes of IPv4 address spaces, but there are
    times when using those classes of address space might not be appropriate. The
    fact of the matter is that Class A, B, and C are classful address spaces if we
    use the default subnet mask for those classes of IPs. For instance, a Class A
    uses a subnet mask of `255.0.0.0`. But wait, what is a subnet mask? To begin with,
    a subnet mask identifies the network portion and the host portion of a given IP
    address. This includes both IPv4 and IPv6\. A subnet mask enables us to easily
    find out the network address for a given IP address. A subnet mask is often written
    in dotted decimal format. However, it is possible to represent a subnet mask in
    a slash notation; namely, the CIDR notation. Classless Inter Domain Routing, or
    CIDR for short, represents a subnet mask by appending the number of network bits
    in a slash format to an IP address. For a Class A address, a subnet mask will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, the value `255.0.0.0` means that all of the bits in the first
    octets are turned on; they are set to 1\. We can present this using the table
    that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  =bits turned on |'
  prefs: []
  type: TYPE_TB
- en: 128+64+32+16+8+4+2+1 = 255 bits
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this, the value of 255 is derived from the sum of all eight bits being
    turned on. Adding to this, the subnet mask can also be represented in binary format.
    Using the Class A address, the subnet mask could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class A subnet mask in decimal**: `255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class A subnet mask in binary**: `11111111.00000000.00000000.00000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Awesome! Now, we can see that a subnet mask can be represented in either decimal
    format using values between 0-255 or in binary format using values of either 0
    or 1\. Furthermore, it is possible to represent a subnet mask in CIDR notation.
    We would represent a Class A address in CIDR format using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class A subnet mask in decimal**: `255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class A subnet mask in binary**: `11111111.00000000.00000000.00000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class A subnet mask in CIDR**: `/8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on this, the `/8` means that eight bits are turned on for the network
    portion of an address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a Class B address, we would represent a Class B address in the following
    format using the dotted decimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, the value `255.255.0.0` means that all of the bits in the first
    and second octets are turned on; they are set to 1\. We can present this using
    the table that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First octet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = bits turned on |'
  prefs: []
  type: TYPE_TB
- en: 128+64+32+16+8+4+2+1 = 255 bits
  prefs: []
  type: TYPE_NORMAL
- en: 'Second octet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = bits turned on |'
  prefs: []
  type: TYPE_TB
- en: 128+64+32+16+8+4+2+1 = 255 bits
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this, the value of `255.255.0.0` is derived from the sum of all 16
    bits being turned on. Adding to this, the subnet mask can also be represented
    in binary format. Using the Class B address, the subnet mask could be written
    as the follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class B subnet mask in decimal**: `255.255.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class B subnet mask in binary**: `11111111.11111111.00000000.00000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Awesome! Now, we can see that a subnet mask can be represented in either decimal
    format using values between 0-255 or in binary format using values of either 0
    or 1\. Furthermore, it is possible to represent a subnet mask in CIDR notation.
    We would represent a Class B address in CIDR format using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class B subnet mask in decimal**: `255.255.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class B subnet mask in binary**: `11111111.11111111.00000000.00000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '** Class B subnet mask in CIDR**: `/16`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on this, the `/16` means that 16 bits are turned on for the network portion
    of an address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a Class C address, we would represent a Class C address in the following
    format using the dotted decimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, the value `255.255.255.0` means that all of the bits in the
    first and second octets are turned on; they are set to 1\. We can present this
    using the table that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First octet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  =bits turned on |'
  prefs: []
  type: TYPE_TB
- en: 128+64+32+16+8+4+2+1 = 255 bits
  prefs: []
  type: TYPE_NORMAL
- en: 'Second octet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  =bits turned on |'
  prefs: []
  type: TYPE_TB
- en: 128+64+32+16+8+4+2+1 = 255 bits
  prefs: []
  type: TYPE_NORMAL
- en: 'Third octet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  =bits turned on |'
  prefs: []
  type: TYPE_TB
- en: 128+64+32+16+8+4+2+1 = 255 bits
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this, the value of `255.255.255.0` is derived from the sum of all
    24 bits being turned on. Adding to this, the subnet mask can also be represented
    in binary format. Using the Class C address, the subnet mask could be written
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class C subnet mask in decimal**: `255.255.255.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class C subnet mask in binary**: `11111111.11111111.11111111.00000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Awesome! Now, we can see that a subnet mask can be represented in either decimal
    format using values between 0-255 or in binary format using values of either 0
    or 1\. Furthermore, it is possible to represent a subnet mask in CIDR notation.
    We would represent a Class C address in CIDR format using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class C subnet mask in decimal**: `255.255.255.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class C subnet mask in binary**: `11111111.11111111.11111111.00000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '** Class C subnet mask in CIDR**: `/24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on this, the `/24` means that 24 bits are turned on for the network portion
    of an address.
  prefs: []
  type: TYPE_NORMAL
- en: Subnetting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve just seen with the Classes A, B, and C, their subnet masks are `/8`,
    `16`, and `24`, respectively, using CIDR notation. In most environments today,
    these default subnet masks are known as classful, meaning if we use these subnet
    masks as they are, we would not be able to perform any sort of traffic engineering.
    This becomes an issue when we want to control the broadcast domain. We should
    try to minimize the broadcast to a given room, office, or department. This ensures
    that in the event of any type of network broadcast, the entire network does not
    start to experience latency. We can leverage subnetting in order to overcome the
    limitation of classful networks. For instance, let''s pick a Class C IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, we can have up to 254 hosts per network address. We might be
    in a situation where we only have eight systems that require IP connectivity.
    This would mean that we are losing those remaining IP addresses because we''ve
    used a default Class C subnet. The requirement in this scenario is to have eight
    IP addresses and not to waste the remaining IPs. We can achieve this requirement
    by subnetting. Subnetting is made possible by borrowing bits from the host portion.
    Let''s write out the subnet mask for the given IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Subnet mask in decimal**: `255.255.255.0 `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subnet mask in binary**: `11111111.11111111.11111111.00000000 `'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on this, the first 24 bits are turned on. We can subnet this address
    in order to gain more control over our IP address space. We want eight IPs. The
    way we borrow bits is by taking bits from the host bits. We can use our table
    for assistance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =4 bits borrowed |'
  prefs: []
  type: TYPE_TB
- en: 2^4bits = 16 network networks can be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2^4 -2 =14 hosts per network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on this, we''ve borrowed four bits from the host portion of the network;
    this enables us to create four smaller subnets/networks. Each network created
    would then have 14 hosts per network. This allows us to save on the amount of
    IPs being lost as opposed to using a standard Class C `/24` network. So, we''ve
    borrowed four bits for the network portion. How would we represent this in decimal
    and CIDR notation? Well, the way we represent the newly created subnet is by a
    process of adding the network bits. This can by illustrated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =4 bits  |'
  prefs: []
  type: TYPE_TB
- en: 128+64+32+16 = 240
  prefs: []
  type: TYPE_NORMAL
- en: Old subnet in decimal = `255.255.255.0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old subnet in CIDR = `/24`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New subnet in decimal = `255.255.255.240`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New subnet in CIDR = `/28`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network address = `192.168.0.0/28`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on this, we can see the new subnet mask in both decimal and CIDR notation.
    The next step would be to identify the usable subnets/networks using this new
    subnet mask. We can calculate the usable subnets by using the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =4 bits |'
  prefs: []
  type: TYPE_TB
- en: 'The networks are incremented by the bit position''s base 2 value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First network**: `192.168.0.0/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second network**: `192.168.0.16/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third network**: `192.168.0.32/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fourth network**: `192.168.0.48/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Till s****ixteen network**: `192.168.0.240/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on this, we can see that the fourth octet is where the increments are
    taking place. In particular, for a `/28`, the subnets are increments by 16; this
    is due to the fact that the fourth bit position is `16` when the calculated 2^4
    bit position = 16\. The last step would be to identify the usable IPs that can
    be assigned to hosts within the network. We will use the following as a breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First subnet/network**: `192.168.0.0/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First usable IP address**: `192.168.0.1/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last usable IP address**: `192.168.0.14/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast IP addres**s: `192.168.0.15/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second subnet/network**: `192.168.0.16/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on this, we see that two IPs are not usable. They are what we''ve been
    taking into consideration when we were calculating the hosts IPs. Similarly, we
    can get the usable IPs for the second subnet `192.168.0.16/28`, by using the following
    breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Second subnet/network**: `192.168.0.16/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First usable IP address**: `192.168.0.17/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last usable IP address**: `192.168.0.30/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast IP address**: `192.168.0.31/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third subnet/network**: `192.168.0.32/28`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Awesome! Based on this, we can see a pattern; we always end up with 14 usable
    IP addresses. Also, we can subnet a Class B address and make use of host bits
    to better manage our network. Let''s use the following Class B address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, we have over 65,000 host IPs per network; this is not ideal
    in most environments. For instance, we want to subnet this IP in order to have
    500 host IPs. This can be achieved by borrowing some host bits from the hosts
    portion of the address. We can use the following breakdown to assist us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The way we calculate the host is by moving from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fourth octet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 8 bits total 255 |'
  prefs: []
  type: TYPE_TB
- en: 2^8 = 255-2 = 254 hosts per network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third octet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |  = 9 bit turned on |'
  prefs: []
  type: TYPE_TB
- en: 2^9 = 512 -2 = 510 hosts per network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome! Based on this, it will take nine bits in order to achieve the requirements.
    This then would mean that we will have to borrow eight bits from the third octets
    to meet the requirements. We can break this down by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |  =7 bit turned on |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on these calculations, the new network would be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, we have the total subnet and hosts per subnets. Now, we need
    to calculate the usable IP addresses per subnet. This can be done using the following
    breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First subnet/network**: `172.16.0.0/23`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First usable IP**: `172.16.0.1/23`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last usable IP**: `172.16.2.254/23`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast IP**: `172.16.2.255`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second subnet/network**: `172.16.2.0/23`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on this, we can see the usable IP addresses; `172.16.2.255` is a valid
    IP using a `/23` subnet. Also, `172.16.1.0/23` is also a valid IP address. In
    some operating systems, such as Windows, if you try to assign either of these
    two IPs, you may encounter an error. However, in Linux, everything is fair game.
    We increment the subnets by 2 because that is where the last network bit position
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even subnet a Class A address. For instance, let''s say we want to create
    100 subnets out of a single class A address. We will use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can do this using the table we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second octet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |  =7 bit turned on |'
  prefs: []
  type: TYPE_TB
- en: 'Awesome! Based on this, we can quickly derive that we would need to borrow
    seven bits from the second octet in order to create 100 subnets. In fact, we will
    have 128 subnets. This is because we''re calculating 2^7 bits in the second octet.
    We can then write out our subnets in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! It''s that easy to subnet a Class A. Now we need to calculate the
    total hosts per subnet. We can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, we can see that we garner quite a number of hosts per subnet
    using a `/15`. We can use the following in order to derive the usable IPs per
    subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First subnet/network**: `10.0.0.0/15`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First usable IP**: `10.0.0.1/15`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last usable IP**: `10.2.255.254/15`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast IP**: `10.2.255.255`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second subnet/network**: `10.2.0.0/15`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excellent! The easiest way to calculate either of the subnets is to always multiple
    the network bits by 2\. For calculating the total hosts, always multiply the hosts
    bits by 2 and then minus 2 for the network and broadcast address.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internet Protocol version 6** (**IPv6**), was developed by the **Internet
    Engineering Task Force** (**IETF**). The IPv6 address was meant to address the
    shortage of IPv4 addresses. IPv4 has been completely exhausted, and companies
    are now willing to trade their IPv4 block of addresses for huge sums of mony.
    An IPv6 address is 128 bits or 16 bytes in length. This gives us 2^128 of IPv6
    addresses. An IPv6 address is represented in hexadecimal format. There are three
    types of IPv6 address.'
  prefs: []
  type: TYPE_NORMAL
- en: Unicast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unicast address specifies an identifier for a single interface on a device
    similar to an IPv4 address. Using IPv6, it's likely that all IPv6 traffic will
    be mostly unicast based.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of an IPv6 multicast address is similar to that of an IPv4 address.
    Packets are sent to an IPv6 multicast address and receivers that are part of a
    multicast group would receive the multicast packet.
  prefs: []
  type: TYPE_NORMAL
- en: Anycast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This address type was introduced in IPv6\. The concept of anycast works by multiple
    devices being assigned the same anycast IPv6 address. When a sender sends a packet
    to an anycast IPv6 address, the anycast packet is routed via a routing protocol
    to the nearest host from the sender.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an IPv6 address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Based on this, we can see that an IPv6 address is made up of eight sets of 16-bit
    or 2-byte values separated by colons. This is how we derive 128 bits or 16 bytes
    in length. It may seem lengthy to write an IPv6 address, but we can use a few
    methods to make an IPv6 address a bit smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Removing leading zeros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can remove the leading zeros from an IPv6 address, thus making it more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! Based on this, we made the IPv6 address much more presentable. But
    wait, we can also make it even smaller by using the technique described next.
  prefs: []
  type: TYPE_NORMAL
- en: Removing consecutive zeros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can remove zeros that are contiguous in an IPv6 address and replace the
    zeros with a double colon. This can only be done once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! As we can see, the IPv6 address is now much more readable. Also, when
    entering an IPv6 address in a browser, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, we would enclose an IPv6 address in square brackets. There are
    some special type of unicast IPv6 addresses that are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global unicast addresses**: These addresses begin with `2000::/3`, as specified
    in RFC 4291\. They are publicly routable addresses that are similar to public
    IPv4 addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link-local addresses**: These addresses begin with `fe80::/10`; they are
    only valid on the local physical link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Site-local addresses**: These addresses begin with `fec::/10`; they are valid
    only within a single site. They have been discouraged by the RFC body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique-local addresses**: These addresses begin with `fc00::/7`; they are
    meant to be routed within a set of cooperating sites. There were meant to replace
    the site-local addresses. An interesting feature of the unique-local addresses
    is that the fact that they reduce the risk of address conflict.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some special IPv6 addresses similar to IPv4\. Here are some reserved
    IPv6 addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `2000::/3    ` |  Global Unicast |'
  prefs: []
  type: TYPE_TB
- en: '| `::/128      ` |  Unspecified address |'
  prefs: []
  type: TYPE_TB
- en: '| `::/0        ` |  Default route |'
  prefs: []
  type: TYPE_TB
- en: '| `::1/128     ` | Loopback address |'
  prefs: []
  type: TYPE_TB
- en: '| `FF00::/8     ` |  Multicast addresses |'
  prefs: []
  type: TYPE_TB
- en: 'Awesome! In terms of identifying the subnet, we would have to dissect an IPv6
    address. We can break it down using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| Global routing prefix   |          Subnet       |     Host ID |'
  prefs: []
  type: TYPE_TB
- en: '|  `2001:db8:0000: `              |        ` 0000:`            |       `0000:ff0:42:8329`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 48 bits or 3bytes           |          16 bits or 2bytes      |        64
    bits   or 8 bytes |'
  prefs: []
  type: TYPE_TB
- en: Based on this, the global routing prefix consists of 48 bits. The subnet is
    made of the next 16 bits. The host identifier is made up of the last 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Well-known protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of well-known protocols that we use in our environment that
    we need to be aware of. For starters, when we browse the internet, we are in fact
    use the HTTP protocol in order to view a web page. Additionally, when we are copying
    a file from a server and providing authentication; in the backend, we are using
    some type of FTP protocol. Likewise, when we type out a URL, we are in fact using
    DNS for name resolution. As we can see, we are using a number of protocols in
    our environments. Some well-known protocols and their respective port numbers
    are described next.
  prefs: []
  type: TYPE_NORMAL
- en: TCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Transmission Control Protocol** (**TCP**) is a connection-oriented protocol
    that offers a number of services, including error checking and sequencing, to
    name a few. It operates at layer 4 of the OSI model, the transport layer.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Hyper Text Transfer Protocol** (**HTTP**) serves up web pages on demand;
    it's the protocol for data communication via URLs on the internet. It uses port
    `80` for communication. Moreover, it rides on top of TCP.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Hyper Text Transfer Protocol Secure** (**HTTPS**) offers secure communications
    for URLs on the internet. It uses port `443` for communication. Moreover, its
    communication uses **Transport Layer Security** (**TLS**). It rides on top of
    TCP.
  prefs: []
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **File Transfer Protocol** (**FTP**), is used for transferring files between
    a client and a server. This could be locally within a LAN or via the internet.
    With FTP support authentication, however, all transmissions are sent in clear
    text; there is no security built in. FTP uses TCP port `20` for data traffic and
    port `21` for command traffic.
  prefs: []
  type: TYPE_NORMAL
- en: UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **User Datagram Protocol** (**UDP**) is a connectionless protocol that offers
    speed but does not do any sort of error checking. It operates at layer 4 of the
    OSI model, the transport layer.
  prefs: []
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Domain Name System** (**DNS**) provides the means for translating IP addresses
    into user-friendly names that users can relate to. It usually uses UDP port `53`
    but also uses TCP port `53` whenever a request or response is larger than a single
    packet.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Trvial File Transfer Protocol** (**TFTP**) is used for transferring date
    at a fast rate. No authentication methods are supported; also, there is no error
    checking. TFTP uses UDP port `69`.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Internet Control Message Protocol** (**ICMP**) is another protocol used
    in the networking environment. It is usually used for troubleshooting by sending
    messages between various networking devices on a LAN or via the internet. There
    is also ICMPv6, which is used for IPv6\. ICMP uses IP protocol `1`, whereas ICMPv6
    uses IP protocol `58`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took took quite an in-depth look into the world of IPv4,
    and IPv6\. In addition to this, we covered subnet masks and ways to identify a
    subnet mask. Next, we covered subnetting. We worked through a few examples and
    illustrated the techniques to derive the required number of hosts and also the
    required number of subnets. Finally, we worked with well-known protocols. We covered
    some of the most widely-used protocols and their port numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to network configuration and troubleshooting.
    We will work on the Linux boxes, assigning IPv4 addresses and also IPv6 addresses,
    looking at various ways of troubleshooting network connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which address is a Class A address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `192.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: B. `172.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: C. `10.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: D.None of the above
  prefs: []
  type: TYPE_NORMAL
- en: Which address is a Class C address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `128.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: B. `100.0.0.2`
  prefs: []
  type: TYPE_NORMAL
- en: C. `192.168.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: D. None of the above
  prefs: []
  type: TYPE_NORMAL
- en: Which address is known as an IPv4 loopback address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `127.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: B. `169.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: C. `172.16.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: D. `192.1.1.1`
  prefs: []
  type: TYPE_NORMAL
- en: Which address is an APIPA address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `169.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: B. `172.16.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: C. `10.1.1.1`
  prefs: []
  type: TYPE_NORMAL
- en: D. `192.168.1.1`
  prefs: []
  type: TYPE_NORMAL
- en: Which address is a class B address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `128.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: B. `10.11.1.1`
  prefs: []
  type: TYPE_NORMAL
- en: C. `127.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: D. 223.0.0.1
  prefs: []
  type: TYPE_NORMAL
- en: What does a IPv6 multicast address start with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `fc0e::/8`
  prefs: []
  type: TYPE_NORMAL
- en: B. `fce::/7`
  prefs: []
  type: TYPE_NORMAL
- en: C. `ff00::/8`
  prefs: []
  type: TYPE_NORMAL
- en: D. `fd0:/9`
  prefs: []
  type: TYPE_NORMAL
- en: Which address is an IPv6 default route?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `::1/0`
  prefs: []
  type: TYPE_NORMAL
- en: B. `::/0`
  prefs: []
  type: TYPE_NORMAL
- en: C. `01A:00000000:00000000:00000000:00000000::9`
  prefs: []
  type: TYPE_NORMAL
- en: D. ::1/128
  prefs: []
  type: TYPE_NORMAL
- en: Which address is an IPv6 loopback address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `::0/1`
  prefs: []
  type: TYPE_NORMAL
- en: B. `::0/0`
  prefs: []
  type: TYPE_NORMAL
- en: C. `::1/128`
  prefs: []
  type: TYPE_NORMAL
- en: D. `::128/128`
  prefs: []
  type: TYPE_NORMAL
- en: What does a link-local address starts with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.`ff00::/8` B.`fc00::/10` C.`fcd00::128` D.`fe80::/10`
  prefs: []
  type: TYPE_NORMAL
- en: Which port does HTTP uses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A.TCP `10` B.UDP `80` C.TCP `80` D.UDP `69`
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This site gives useful information about the IP: [https://tools.ietf.org](https://tools.ietf.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This site gives useful information about subnetting: [https://www.quora.com](https://www.quora.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This site gives useful information about IPv6: [https://www.ipv6.com](https://www.ipv6.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
