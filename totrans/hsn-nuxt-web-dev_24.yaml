- en: Creating a Nuxt App with a CMS and GraphQL
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CMS和GraphQL创建Nuxt应用
- en: In the previous chapters, you have been creating APIs from scratch so that they
    work with Nuxt apps. Building a personalized API can be rewarding and fulfilling,
    but it may not suit every situation. Building an API from the bottom-up is time-consuming.
    In this chapter, we are going to explore third-party systems that can provide
    us with the API services we need without having us build them from scratch. Ideally,
    we want to use a system that can help us manage our content – a **content management
    system** (**CMS**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，您一直在从头开始创建API，以便它们与Nuxt应用一起工作。构建个性化的API可能是有益的和令人满足的，但它可能并不适合每种情况。从底层构建API是耗时的。在本章中，我们将探索可以为我们提供所需API服务的第三方系统，而无需从头开始构建它们。理想情况下，我们希望使用一个可以帮助我们管理内容的系统
    - **内容管理系统**（**CMS**）。
- en: WordPress and Drupal are popular CMSes. They are packed with APIs that are worth
    looking into. In this book, we will be using **WordPress**. Besides CMSes such
    WordPress, we will also look into **headless CMSes**. A headless CMS is just like
    WordPress but is a pure API service without the frontend presentation, which can
    be done in Nuxt, just as we have been doing throughout this book. **Keystone**
    will be the headless CMS that we will explore in this book. However, the WordPress
    API and the Keystone API are two different kinds of API. Specifically, the former
    is a **REST API**, while the latter is a **GraphQL API**. But what are they? In
    short, a REST API is an API that uses HTTP requests to `GET`, `PUT`, `POST`, and
    `DELETE` data. The APIs you created in the previous chapters are REST APIs. GraphQL
    is an API that implements the GraphQL specification (technical standard).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress和Drupal是流行的CMS。它们都包含值得研究的API。在本书中，我们将使用**WordPress**。除了WordPress这样的CMS，我们还将研究**无头CMS**。无头CMS就像WordPress一样，但是是一个纯粹的API服务，没有前端呈现，这可以在Nuxt中完成，就像我们在整本书中一直在做的那样。**Keystone**将是我们在本书中探索的无头CMS。然而，WordPress
    API和Keystone API是两种不同类型的API。具体来说，前者是**REST API**，而后者是**GraphQL API**。但它们是什么？简而言之，REST
    API是使用HTTP请求来`GET`、`PUT`、`POST`和`DELETE`数据的API。您在前几章中创建的API都是REST API。GraphQL是实现GraphQL规范（技术标准）的API。
- en: GraphQL APIs are an alternative to REST APIs. To demonstrate how we can deliver
    the same result using these two different kinds of API, we will use the sample
    Nuxt app website we provided in [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),
    *Adding Views, Routes. and Transitions*. This can be found in `/chapter-4/nuxt-universal/sample-website/`
    in this book's GitHub repository. We will refactor the existing pages (home, about,
    projects, content, and the project subpages), which consist of text and images
    (featured images, fullscreen images, and individual project images). We will also
    refactor the navigation by getting data from the APIs instead of hardcoding them,
    just like we did for the other Nuxt apps in the previous chapters. With a CMS,
    we can get navigation data dynamically through the API, regardless of whether
    it is a REST or a GraphQL API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API是REST API的一种替代方案。为了演示如何使用这两种不同类型的API来实现相同的结果，我们将使用我们在[第4章](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml)中提供的示例Nuxt应用网站，*添加视图、路由和过渡*。这可以在本书的GitHub存储库中的`/chapter-4/nuxt-universal/sample-website/`中找到。我们将重构现有页面（主页、关于、项目、内容和项目子页面），这些页面包括文本和图片（特色图片、全屏图片和单独的项目图片）。我们还将通过从API获取数据而不是硬编码来重构导航，就像我们在前几章中为其他Nuxt应用所做的那样。通过CMS，我们可以通过API动态获取导航数据，无论是REST还是GraphQL
    API。
- en: Furthermore, we are going to generate static Nuxt pages (you learned about these
    in [Chapter 14](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml), *Using Linters, Formatters,
    and Deployment Commands*, and [Chapter 15](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml), *Creating
    an SPA with Nuxt*) with these CMSes. So, by the end of this chapter, you will
    have a full and final view of what you have learned throughout this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用这些CMS生成静态Nuxt页面（您在[第14章](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml)中了解了这些内容，*使用Linter、格式化程序和部署命令*，以及[第15章](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml)中，*使用Nuxt创建SPA*）。因此，到本章结束时，您将对本书中学到的内容有一个完整而最终的了解。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating headless REST APIs in WordPress
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WordPress中创建无头REST API
- en: Introducing Keystone
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Keystone
- en: Introducing GraphQL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍GraphQL
- en: Integrating Keystone, GraphQL, and Nuxt
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Keystone、GraphQL和Nuxt
- en: Let's get started by looking into the WordPress REST API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始研究WordPress REST API。
- en: Creating headless REST APIs in WordPress
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WordPress中创建无头REST API
- en: 'WordPress (WordPress.org) is an open source PHP CMS for general-purpose website
    development. It is not "headless" by default; it is stacked with a template system.
    This means the view and the data are intertwined. However, since 2015 (WordPress
    4.4), the REST API infrastructure has been integrated into WordPress core for
    developers, and now all the default endpoints can be accessed if you append `/wp-json/`
    to your website-based URL. You can also extend the WordPress REST API and add
    your own custom endpoints. So, we can easily use WordPress as a "headless" REST
    API by ignoring the view. You will find out how to achieve this in the upcoming
    sections. To speed up the development process, we will install the following WordPress
    plugins:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress（WordPress.org）是一个用于通用网站开发的开源PHP CMS。它默认情况下不是“无头”的；它堆叠了一个模板系统。这意味着视图和数据是交织在一起的。然而，自2015年以来（WordPress
    4.4），REST API基础设施已经集成到WordPress核心中供开发人员使用，现在如果您在基于网站的URL后附加`/wp-json/`，则可以访问所有默认端点。您还可以扩展WordPress
    REST API并添加自己的自定义端点。因此，我们可以通过忽略视图轻松地将WordPress用作“无头”REST API。您将在接下来的章节中了解如何实现这一点。为了加快开发过程，我们将安装以下WordPress插件：
- en: '**Advanced Custom Fields (ACF)** for creating custom meta boxes. For more information
    about this plugin, please visit [https://www.advancedcustomfields.com/](https://www.advancedcustomfields.com/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级自定义字段（ACF）**用于创建自定义元框。有关此插件的更多信息，请访问[https://www.advancedcustomfields.com/](https://www.advancedcustomfields.com/)'
- en: '**The ACF Repeater Field** for creating a repeatable set of subfields. It is
    an ACF premium add-on ([https://www.advancedcustomfields.com/add-ons/](https://www.advancedcustomfields.com/add-ons/)).
    You can purchase it from [https://www.advancedcustomfields.com/add-ons/repeater-field/](https://www.advancedcustomfields.com/add-ons/repeater-field/).
    Alternatively, you can get it by default from ACF PRO at [https://www.advancedcustomfields.com/pro/](https://www.advancedcustomfields.com/pro/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACF Repeater Field**用于创建可重复的子字段集。这是一个ACF高级附加组件（[https://www.advancedcustomfields.com/add-ons/](https://www.advancedcustomfields.com/add-ons/)）。您可以从[https://www.advancedcustomfields.com/add-ons/repeater-field/](https://www.advancedcustomfields.com/add-ons/repeater-field/)购买它。或者，您可以从ACF
    PRO的[https://www.advancedcustomfields.com/pro/](https://www.advancedcustomfields.com/pro/)默认获取它。'
- en: '**Rewrite Rules Inspector** for inspecting and flushing your rewrite rules
    in WordPress. For more information about this plugin, please visit [https://wordpress.org/plugins/rewrite-rules-inspector/](https://wordpress.org/plugins/rewrite-rules-inspector/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重写规则检查器**用于检查和刷新WordPress中的重写规则。有关此插件的更多信息，请访问[https://wordpress.org/plugins/rewrite-rules-inspector/](https://wordpress.org/plugins/rewrite-rules-inspector/)'
- en: You can create your own plugins and meta boxes if you prefer not to use any
    of these. Please check out how to create custom meta boxes at [https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/](https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/).
    Also, check out how to develop custom plugins at [https://developer.wordpress.org/plugins/intro/](https://developer.wordpress.org/plugins/intro/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用任何这些，您可以创建自己的插件和元框。请查看如何在[https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/](https://developer.wordpress.org/plugins/metadata/custom-meta-boxes/)创建自定义元框。还可以查看如何在[https://developer.wordpress.org/plugins/intro/](https://developer.wordpress.org/plugins/intro/)开发自定义插件。
- en: For more information about the WordPress REST API, please visit [https://developer.wordpress.org/rest-api/](https://developer.wordpress.org/rest-api/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WordPress REST API的更多信息，请访问[https://developer.wordpress.org/rest-api/](https://developer.wordpress.org/rest-api/)。
- en: To develop and extend the WordPress REST API with these plugins or with yours,
    first, you will need to download WordPress and install the program on your machine.
    We'll learn how to do this in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些插件或您自己的插件开发和扩展WordPress REST API，首先需要下载WordPress并在您的计算机上安装该程序。我们将在下一节中学习如何做到这一点。
- en: Installing WordPress and creating our first pages
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装WordPress并创建我们的第一个页面
- en: 'There are a few ways we can install and serve WordPress:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式安装和提供WordPress：
- en: By unpacking the downloaded WordPress `.zip` file and installing it from a directory
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过解压下载的WordPress `.zip`文件并从目录中安装它
- en: By using the WordPress CLI ([https://make.wordpress.org/cli/handbook/](https://make.wordpress.org/cli/handbook/)
    or [https://wp-cli.org/](https://wp-cli.org/))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WordPress CLI（[https://make.wordpress.org/cli/handbook/](https://make.wordpress.org/cli/handbook/)或[https://wp-cli.org/](https://wp-cli.org/)）
- en: By setting up a port using Apache (which can be a bit of pain)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Apache设置端口（可能有点麻烦）
- en: By using the built-in PHP server
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用内置的PHP服务器
- en: 'We will use the built-in PHP server in this book as it is the simplest way
    to get WordPress started and will make it easier to move it around in the future
    if we need to, as long as it is served on the same port; for example, `localhost:4000`.
    So, let''s find out how to do this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用内置的PHP服务器，因为这是启动WordPress的最简单方式，并且如果需要的话，将来移动它会更容易，只要它在同一个端口上提供服务；例如，`localhost:4000`。因此，让我们找出如何做到这一点：
- en: Create a directory (make it writable as well) and download and unzip WordPress
    in there. You can download WordPress from [https://wordpress.org/](https://wordpress.org/).
    You should see some `.php` files with `/wp-admin/`, `/wp-content/`, and `/wp-includes/` directories
    in your unzipped WordPress directory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录（也使其可写），并在其中下载并解压WordPress。您可以从[https://wordpress.org/](https://wordpress.org/)下载WordPress。您应该在解压后的WordPress目录中看到一些带有`/wp-admin/`，`/wp-content/`和`/wp-includes/`目录的`.php`文件。
- en: Create a MySQL database (for example, `nuxt-wordpress`) through the PHP Adminer.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过PHP Adminer创建一个MySQL数据库（例如，`nuxt-wordpress`）。
- en: 'Navigate to the directory and serve WordPress with built-in PHP, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到目录并使用内置的PHP提供WordPress，如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Point your browser to `localhost:4000` and install WordPress with the required
    MySQL credentials (database name, username, and password) and your WordPress user
    account information (username, password, and email address).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器指向`localhost:4000`，并使用所需的MySQL凭据（数据库名称，用户名和密码）以及您的WordPress用户帐户信息（用户名，密码和电子邮件地址）安装WordPress。
- en: Log into the WordPress admin UI with your user credentials at `localhost:4000/wp-admin/`
    and create some main pages (home, about, projects, contact) under the `Pages`
    label.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的用户凭据登录到`localhost:4000/wp-admin/`的WordPress管理UI，并在“页面”标签下创建一些主要页面（主页，关于，项目，联系）。
- en: Navigate to **Menus** from under **Appearance** and create the site navigation
    by adding `menu-main` to the **Menu Name** input field.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**外观**下的**菜单**导航到**菜单**，通过将`menu-main`添加到**菜单名称**输入字段来创建站点导航。
- en: 'Select all the pages (contact, about, projects, home) that appear under Add
    menu items and click Add to Menu to add them to `menu-main` as navigation items.
    You can drag and sort the items so that they are read in this order: home, about,
    projects, contact. Then, click the Save Menu button.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有出现在“添加菜单项”下的页面（联系人、关于、项目、主页），然后点击“添加到菜单”将它们添加到`menu-main`作为导航项。您可以拖动和排序这些项目，使它们按照这个顺序排列：主页、关于、项目、联系人。然后，点击“保存菜单”按钮。
- en: (Optional) Change the WordPress permalinks from the Plain option to the Custom
    Structure (with a value of `/%postname%/`, for example) in **Permalinks**, under
    **Settings**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）将WordPress永久链接从普通选项更改为自定义结构（例如`/%postname%/`）在**永久链接**下的**设置**中。
- en: Download the plugins we mentioned previously and unpack them into a `/plugins/` directory.
    This can be found inside the `/wp-content/` directory. Then, activate them through
    the admin UI.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载我们之前提到的插件并解压缩它们到`/plugins/`目录。这可以在`/wp-content/`目录中找到。然后通过管理界面激活它们。
- en: If you inspect the `wp_options` table in the `nuxt-wordpress` database, you
    should see that port `4000` is recorded successfully in the `siteurl` and `home`
    fields. So, from now on, you can move your WordPress project directory wherever
    you like, as long as you run it with the built-in PHP server at this port.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查“nuxt-wordpress”数据库中的“wp_options”表，您应该看到端口“4000”已成功记录在“siteurl”和“home”字段中。因此，从现在开始，只要在此端口上使用内置的PHP服务器运行，您可以将WordPress项目目录移动到任何您喜欢的地方。
- en: Although we have the data of our main pages and navigation in WordPress, we
    still need the data of the subpages of the `Projects` page. We can add them to
    the `Page` label and then just attach them to the `Projects` page. But these pages
    will share an identical content type (which is called post type in WordPress)
    – the `page` post type. It is better to organize them in a separate post type
    so that they can be managed more easily. We'll find out how to create custom post
    types in WordPress in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在WordPress中有主页面和导航的数据，但我们仍然需要“项目”页面的子页面数据。我们可以将它们添加到“页面”标签，然后将它们附加到“项目”页面。但是这些页面将共享相同的内容类型（在WordPress中称为文章类型）-“页面”文章类型。最好将它们组织在一个单独的文章类型中，以便更容易管理。我们将在下一节中了解如何在WordPress中创建自定义文章类型。
- en: For more details about the WordPress installation process, please visit [https://wordpress.org/support/article/how-to-install-wordpress/](https://wordpress.org/support/article/how-to-install-wordpress/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WordPress安装过程的更多详细信息，请访问[https://wordpress.org/support/article/how-to-install-wordpress/](https://wordpress.org/support/article/how-to-install-wordpress/)。
- en: Creating custom post types in WordPress
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在WordPress中创建自定义文章类型
- en: 'We can create custom post types in WordPress from the `functions.php` file
    in any WordPress theme. However, since we are not going to use the WordPress template
    system to deliver the view for our content, we can just extend a **child theme**
    from the default theme that is provided by WordPress. Then, we can just activate
    the child theme in **Themes**, under **Appearance**. We''ll use the "Twenty Nineteen"
    theme to extend our child theme and then create the custom post types from there.
    Let''s get started:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从任何WordPress主题的“functions.php”文件中创建自定义文章类型。但是，由于我们不打算使用WordPress模板系统来提供我们内容的视图，我们可以从WordPress提供的默认主题中扩展一个**子主题**。然后，在**外观**下的**主题**中激活子主题。我们将使用“Twenty
    Nineteen”主题来扩展我们的子主题，然后从那里创建自定义文章类型。让我们开始吧：
- en: 'Create a directory called `twentynineteen-child` in the `/themes/` directory
    and create a `style.css` file that contains the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/themes/`目录中创建一个名为`twentynineteen-child`的目录，并创建一个包含以下内容的`style.css`文件：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Theme Name`, `Template`, and `Text Domain` are the minimum required header
    comments for extending a theme, followed by importing its parent''s `style.css`
    file. These header comments must be put at the top of the file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Theme Name`、`Template`和`Text Domain`是扩展主题的最低要求的头部注释，然后导入其父级的`style.css`文件。这些头部注释必须放在文件顶部。'
- en: If you want to include more header comments in this child theme, please visit
    [https://developer.wordpress.org/themes/advanced-topics/child-themes/](https://developer.wordpress.org/themes/advanced-topics/child-themes/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在这个子主题中包含更多的头部注释，请访问[https://developer.wordpress.org/themes/advanced-topics/child-themes/](https://developer.wordpress.org/themes/advanced-topics/child-themes/)。
- en: 'Create a `functions.php` file in the `/twentynineteen-child/` directory and
    create the custom post type using this format and WordPress'' `register_post_type`
    function, as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/twentynineteen-child/`目录中创建一个`functions.php`文件，并使用以下格式和WordPress的`register_post_type`函数创建自定义文章类型，方法如下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, to add our custom post type, just use `project` as the type name and provide
    some arguments:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要添加我们的自定义文章类型，只需将`project`作为类型名称，并提供一些参数：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can add labels and what content fields we want to support to the custom
    post type UI, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向自定义文章类型UI添加标签和我们想要支持的内容字段，方法如下：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more information about the `register_post_type` function, please visit [https://developer.wordpress.org/reference/functions/register_post_type/](https://developer.wordpress.org/reference/functions/register_post_type/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`register_post_type`函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/register_post_type/](https://developer.wordpress.org/reference/functions/register_post_type/)。
- en: For more information about the custom post type UI, please visit [https://wordpress.org/plugins/custom-post-type-ui/](https://wordpress.org/plugins/custom-post-type-ui/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有关自定义文章类型UI的更多信息，请访问[https://wordpress.org/plugins/custom-post-type-ui/](https://wordpress.org/plugins/custom-post-type-ui/)。
- en: '(Optional) We can also add support for `category` and `tag` for this custom
    post type, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）我们还可以为这种自定义文章类型添加对`category`和`tag`的支持，方法如下：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, these are global category and tag instances, which means they are
    shared with other post types such as the `Page` and `Post` post types. So, if
    you want to specify specific categories for the `Project` post type only, use
    the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些是全局的类别和标签实例，这意味着它们与其他文章类型（如`Page`和`Post`文章类型）共享。因此，如果您想为`Project`文章类型指定特定的类别，只需使用以下代码：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For more information about registering taxonomies, please visit [https://developer.wordpress.org/reference/functions/register_taxonomy/](https://developer.wordpress.org/reference/functions/register_taxonomy/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有关注册分类法的更多信息，请访问[https://developer.wordpress.org/reference/functions/register_taxonomy/](https://developer.wordpress.org/reference/functions/register_taxonomy/)。
- en: '(Optional) It may be a good idea to disable Gutenberg completely for all post
    types if you find it difficult to use:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）如果您发现难以使用，可能会完全禁用Gutenberg对所有文章类型：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Activate the child theme in the WordPress admin UI and start adding `project`
    type pages to the Projects label.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在WordPress管理界面中激活子主题，并开始向“项目”标签添加`project`类型页面。
- en: You will notice that the content fields (`title`, `editor`, `thumbnail`, `page-attributes`)
    that you can use to add content to the project pages are very limited. We need
    more specific content fields, such as content fields for adding multiple project
    images and a fullscreen image. This is the same issue we had with the `home` page
    because we need another content field so that we can add multiple slide images
    as well. To add more of these content fields, we will need custom meta boxes.
    You can use the ACF plugin or create your own custom meta boxes and include them
    in the `functions.php` file or create them as a plugin. Alternatively, you can
    use another different meta box plugin such as Meta Box ([https://metabox.io/](https://metabox.io/)).
    It is entirely up to you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，您可以使用的内容字段（`title`、`editor`、`thumbnail`、`page-attributes`）非常有限，用于向项目页面添加内容。我们需要更多特定的内容字段，例如用于添加多个项目图片和全屏图片的内容字段。这与我们在`home`页面上遇到的问题相同，因为我们需要另一个内容字段，以便我们也可以添加多个幻灯片图片。要添加更多这些内容字段，我们将需要自定义元框。您可以使用ACF插件或创建自己的自定义元框并将其包含在`functions.php`文件中，或者将其创建为插件。或者，您可以使用另一个不同的元框插件，如Meta
    Box ([https://metabox.io/](https://metabox.io/))。这完全取决于您。
- en: Once you have created the custom content fields and added the required content
    to each project page, you can extend the WordPress REST API for project pages,
    main pages, and navigation. We'll learn how to do this in the next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了自定义内容字段并向每个项目页面添加了所需的内容，您可以扩展WordPress REST API以用于项目页面、主页面和导航。我们将在下一节中学习如何做到这一点。
- en: Extending the WordPress REST API
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展WordPress REST API
- en: The WordPress REST API can be accessed with `/wp-json/` and is the entry route
    that's appended to your site-based URLs. For example, you can see all the other
    available routes by pointing your browser to `localhost:4000/wp-json/`. You will
    see what endpoints are available in every route, as these can be either GET or
    POST endpoints. For example, the `/wp-json/wp/v2/pages` route has a GET endpoint
    for listing pages and a POST endpoint for creating a page. You can find out more
    about these default routes and endpoints at [https://developer.wordpress.org/rest-api/reference/](https://developer.wordpress.org/rest-api/reference/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress REST API可以通过`/wp-json/`访问，并且是附加到基于站点的URL的入口路由。例如，您可以通过将浏览器指向`localhost:4000/wp-json/`来查看所有其他可用的路由。您将看到每个路由中可用的端点，因为这些可以是GET或POST端点。例如，`/wp-json/wp/v2/pages`路由具有用于列出页面的GET端点和用于创建页面的POST端点。您可以在[https://developer.wordpress.org/rest-api/reference/](https://developer.wordpress.org/rest-api/reference/)找到有关这些默认路由和端点的更多信息。
- en: 'However, if you have custom post types and custom content fields, then you
    will need custom routes and endpoints. We can create custom versions of these
    by registering them with the `register_rest_route` function in the `functions.php`
    file, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您有自定义的文章类型和自定义内容字段，那么您将需要自定义路由和端点。我们可以通过在`functions.php`文件中使用`register_rest_route`函数注册它们来创建这些的自定义版本，如下所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s learn how to extend the WordPress REST API:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何扩展WordPress REST API：
- en: 'Create a global namespace and endpoints for fetching the navigation and a single
    page:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于获取导航和单个页面的全局命名空间和端点：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we pass the global namespace to each block of `add_action` by using
    the PHP `use` keyword in the anonymous functions. For more information about the
    PHP `use` keyword and anonymous functions, please visit [https://www.php.net/manual/en/functions.anonymous.php](https://www.php.net/manual/en/functions.anonymous.php).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过在匿名函数中使用PHP的`use`关键字将全局命名空间传递给每个`add_action`块。有关PHP的`use`关键字和匿名函数的更多信息，请访问[https://www.php.net/manual/en/functions.anonymous.php](https://www.php.net/manual/en/functions.anonymous.php)。
- en: For more information about the `register_rest_route` function from WordPress,
    please visit [https://developer.wordpress.org/reference/functions/register_rest_route/](https://developer.wordpress.org/reference/functions/register_rest_route/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关WordPress的`register_rest_route`函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/register_rest_route/](https://developer.wordpress.org/reference/functions/register_rest_route/)。
- en: 'Create endpoints for fetching a single project page and listing project pages:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为获取单个项目页面和列出项目页面创建端点：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `fetch_menu` function for fetching the `menu-main` navigation items:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetch_menu`函数来获取`menu-main`导航项：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use the `wp_get_nav_menu_items` function from WordPress to help us fetch
    the navigation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用WordPress的`wp_get_nav_menu_items`函数来帮助我们获取导航。
- en: For more information about the `wp_get_nav_menu_items` function, please visit
    [https://developer.wordpress.org/reference/functions/wp_get_nav_menu_items/](https://developer.wordpress.org/reference/functions/wp_get_nav_menu_items/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`wp_get_nav_menu_items`函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/wp_get_nav_menu_items/](https://developer.wordpress.org/reference/functions/wp_get_nav_menu_items/)。
- en: 'Create a `fetch_page` function for fetching a page by slug (or path):'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetch_page`函数来按slug（或路径）获取页面：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we use the `get_page_by_path` function from WordPress to fetch the page.
    For more information about this function, please visit [https://developer.wordpress.org/reference/functions/get_page_by_path/](https://developer.wordpress.org/reference/functions/get_page_by_path/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用WordPress的`get_page_by_path`函数来获取页面。有关此函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/get_page_by_path/](https://developer.wordpress.org/reference/functions/get_page_by_path/)。
- en: We also use the `get_field` function from the ACF plugin to fetch the list of
    slide images that are attached to the page and then push them to the `$post` object
    as `slides`. For more information about this function, please visit [https://www.advancedcustomfields.com/resources/get_field/](https://www.advancedcustomfields.com/resources/get_field/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用ACF插件的`get_field`函数来获取附加到页面的幻灯片图片列表，然后将它们作为`slides`推送到`$post`对象中。有关此函数的更多信息，请访问[https://www.advancedcustomfields.com/resources/get_field/](https://www.advancedcustomfields.com/resources/get_field/)。
- en: 'Create a `fetch_project` function in order to fetch a single project page:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetch_project`函数来获取单个项目页面：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, we use the WordPress `get_page_by_path` function for fetching a page
    for us and the ACF `get_field` function for fetching images (the fullscreen image
    and project images) attached to the project page and then push them to the `$post`
    object as `fullscreen` and `images`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用WordPress的`get_page_by_path`函数来为我们获取页面，并使用ACF的`get_field`函数来获取附加到项目页面的图片（全屏图片和项目图片），然后将它们作为`fullscreen`和`images`推送到`$post`对象中。
- en: 'Create a `fetch_projects` function for fetching a list of project pages, 6
    items per page:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fetch_projects`函数来获取项目页面列表，每页6个项目：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we used the `get_posts` function from WordPress with the required arguments
    to fetch the list. For more information about this function, please visit [https://developer.wordpress.org/reference/functions/get_posts/](https://developer.wordpress.org/reference/functions/get_posts/).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用WordPress的`get_posts`函数以所需的参数来获取列表。有关此函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/get_posts/](https://developer.wordpress.org/reference/functions/get_posts/)。
- en: Then, we loop each project page and push their featured images into the `get_the_post_thumbnail_url`
    function from WordPress. For more information about this function, please visit
    [https://developer.wordpress.org/reference/functions/get_the_post_thumbnail_url/](https://developer.wordpress.org/reference/functions/get_the_post_thumbnail_url/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们循环每个项目页面，并将它们的特色图片推送到WordPress的`get_the_post_thumbnail_url`函数中。有关此函数的更多信息，请访问[https://developer.wordpress.org/reference/functions/get_the_post_thumbnail_url/](https://developer.wordpress.org/reference/functions/get_the_post_thumbnail_url/)。
- en: 'We also need to compute the data (the previous page number and next page number)
    in order to make pagination for project pages, so instead of just returning `$posts`,
    return it as `items` in the following array with the pagination data:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要计算数据（上一页编号和下一页编号），以便为项目页面进行分页，因此，不仅返回`$posts`，还要将其作为以下数组中的`items`返回，并包含分页数据：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we used the `wp_count_posts` function to count the total published project
    pages. For more information about this function, please visit [https://developer.wordpress.org/reference/functions/wp_count_posts/](https://developer.wordpress.org/reference/functions/wp_count_posts/).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`wp_count_posts`函数来计算总发布的项目页面数。有关此功能的更多信息，请访问[https://developer.wordpress.org/reference/functions/wp_count_posts/](https://developer.wordpress.org/reference/functions/wp_count_posts/)。
- en: Log into the WordPress admin UI, go to Rewrite Rules under **Tools**, and click
    the Flush Rules button to refresh the WordPress rewrite rules.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录WordPress管理界面，转到**工具**下的重写规则，并单击刷新规则按钮以刷新WordPress重写规则。
- en: 'Go to your browser and test the custom API routes that you have just created:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到浏览器，测试您刚刚创建的自定义API路由：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should see a bunch of JSON raw data printed on your browser screen. The
    JSON raw data can be difficult to read, but you can use **JSONLint**, a JSON validator,
    for pretty-printing your data at [https://jsonlint.com/](https://jsonlint.com/).
    Alternatively, you can just use **Firefox**, which has the option to pretty-print
    your data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在浏览器屏幕上看到一堆JSON原始数据。JSON原始数据可能很难阅读，但您可以使用**JSONLint**，一个JSON验证器，对您的数据进行漂亮的打印，网址是[https://jsonlint.com/](https://jsonlint.com/)。或者，您也可以使用**Firefox**，它有漂亮打印数据的选项。
- en: You can find the entire code for this in `/chapter-18/cross-domain/backend/wordpress/`,
    in this book's GitHub repository. You can find a sample database (`nuxt-wordpress.sql`)
    in it too. The default **username** and **password** in this sample database for
    logging into the WordPress admin UI is **admin**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中的`/chapter-18/cross-domain/backend/wordpress/`中找到此代码的全部内容。您也可以在其中找到一个示例数据库（`nuxt-wordpress.sql`）。用于登录WordPress管理界面的此示例数据库的默认**用户名**和**密码**是**admin**。
- en: Well done! You have successfully extended the WordPress REST API so that it
    supports custom post types. We don't need to develop any new theme in WordPress
    to view our content because this will be handled by Nuxt. We can keep WordPress'
    existing themes for previewing the content. This means we are only using WordPress
    to host our site content remotely, including all the media files (images, videos,
    and so on). Furthermore, we can generate static pages using Nuxt (just like we
    did in the previous chapters) and stream all the media files from WordPress to
    our Nuxt project so that we can host them locally. We'll learn how to do this
    in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已成功扩展了WordPress REST API，以便支持自定义文章类型。我们不需要在WordPress中开发任何新主题来查看我们的内容，因为这将由Nuxt处理。我们可以保留WordPress的现有主题来预览内容。这意味着我们只是使用WordPress远程托管我们网站的内容，包括所有媒体文件（图片、视频等）。此外，我们可以使用Nuxt生成静态页面（就像我们在前几章中所做的那样），并从WordPress流式传输所有媒体文件到我们的Nuxt项目，以便我们可以在本地托管它们。我们将在下一节学习如何做到这一点。
- en: Integrating with Nuxt and streaming images from WordPress
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Nuxt集成和从WordPress流式传输图像
- en: 'Integrating Nuxt with the WordPress REST API is similar to when you integrated
    with the cross-domain APIs you learned about and created in the previous chapters.
    However, in this section, we will improve the plugin that we use to load images
    by requiring them from the `/assets/` directory. But since our images are uploaded
    to the WordPress CMS and are kept in the `/uploads/` directory in our WordPress
    project, we need to refactor our asset loader plugin so that it requires the images
    from the `/assets/` directory when they are found in there; otherwise, we just
    load them remotely from WordPress. Let''s get started:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Set `remote URL` for the Axios instance in the Nuxt config file, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create an Axios instance and inject it into the Nuxt context directly as `$axios`.
    Also, add this Axios instance to the `app` option into the context using the `inject`
    function:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Refactor the asset loader plugin, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we split the image URL string into an array, get the image's filename
    (for example, `my-image.jpg`) from the last item in the array, and store it in
    the `last` variable. We then require the image locally using the filename (`last`).
    If an error is thrown, that means the image does not exist in the `/assets/` directory,
    so we just return the image's URL (`src`) as it is.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: However, we will stream the image from the remote URL to the `/assets/` directory
    using a `streamResource` function when our app is running on the server-side and
    the `streamRemoteResource` option is `true`. You will find out how to create this
    option (just like the `remoteURL` option) in the upcoming step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `stream-resource.js` file with the `streamResource` function in the
    `/assets/` directory, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this function, we use plain Axios to request the data of the remote resource
    by specifying `stream` as the response type. We then use the `createWriteStream`
    function from the Node.js built-in File System (fs) package with the necessary
    filepath to create the image in the `/assets/` directory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `fs` package and its `createWriteStream` function,
    please visit [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)
    and [https://nodejs.org/api/fs.htmlfs_fs_createwritestream_path_options](https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the Node.js stream's `pipe` event in the response
    data and the Node.js stream itself, please visit [https://nodejs.org/api/stream.htmlstream_event_pipe](https://nodejs.org/api/stream.html#stream_event_pipe)
    and [https://nodejs.org/api/stream.htmlstream_stream](https://nodejs.org/api/stream.html#stream_stream).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Register both plugins in the Nuxt config file:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Refactor the home page''s `index.vue` in the `/pages/` directory in order to
    use these two plugins, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we used `$axios` from our plugin to request the WordPress API. After receiving
    the data, we populated it in the `<template>` block. The `$loadAssetImage` function
    is used to run logic on how to load and process the image for us.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the pages in the `/pages/` directory should be refactored and follow
    the same pattern we followed for the home page. They are `/about.vue`, `/contact.vue`,
    `/projects/index.vue`, `/projects/_slug.vue`,  and `/projects/pages/_number.vue`.
    Also, you need to do this for the component in the `/components/` directory; that
    is, `/projects/project-items.vue`. You can find the repository path to these completed
    files in the GitHub repositories provided at the end of this section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another script command with a custom environment variable, `NUXT_ENV_GEN`,
    and put `stream` as its value in the `package.json` file in our Nuxt project:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In Nuxt, if you create an environment variable prefixed with `NUXT_ENV_` in
    the `package.json` file, it will be injected into the Node.js process environment
    automatically. After doing this, you can access it throughout the app via the
    `process.env` object – including other custom properties you might set in the
    `env` property in the Nuxt config file
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `env` property in Nuxt, please visit [https://nuxtjs.org/api/configuration-env/](https://nuxtjs.org/api/configuration-env/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `streamRemoteResource` option for the asset loader plugin (which
    we refactored in *step 3*) in the `env` property in the Nuxt config file, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This `streamRemoteResource` option will be set to `true` when we get the `stream`
    value from the `NUXT_ENV_GEN` environment variable; otherwise, it is always set
    to `false`. So, when this option is set to `true`, the asset loader plugin will
    start streaming the remote resources to the `/assets/` directory for us.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '(Optional) If the Nuxt crawler fails to detect the dynamic routes for some
    unknown reasons, then generate these routes manually in the `generate` option
    in the Nuxt config file, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this optional step, we used Axios to fetch all the child pages that belong
    to the `projects` post type, and used the JavaScript `map` method to loop these
    pages in order to generate their routes. And then, we took the length of the child
    pages to work out how many maximum pages in number (`totalMaxPages`) by dividing
    the child pages by six (making six items per page). After that, we converted the `totalMaxPages` number
    into an array by using the JavaScript `Array` object, and then used the Javascript `fill`, `map`,
    and `push` methods to loop the array in order to generate the dynamic routes for
    pagination. Lastly, we concatenated the routes from the child pages and pagination
    with the JavaScript spread operator, and then return them as a single array for
    Nuxt to generate the dynamic routes for us.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the JavaScript `map`, `fill`, and `push` methods,
    please visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map), [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill),
    and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push),
    respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `stream` command first, followed by the `generate` command on your
    terminal, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use the `stream` command to stream the remote resources to the `/assets/`
    directory by generating the first batch of static pages, then the `generate` command
    to regenerate the static pages. At this point, webpack will process the images
    in the `/assets/` directory and export them to the `/dist/` folder with the static
    pages. So, after running these two commands, you should see that the remote resources
    are streamed and processed in `/assets/` and `/dist/`. You can navigate to these
    two directories and inspect the downloaded resources.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Nuxt app of this section in `/chapter-18/cross-domain/frontend/nuxt-universal/nuxt-wordpress/axios-vanilla/`
    in this book's GitHub repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have successfully integrated Nuxt with the WordPress REST API
    and streamed remote resources for static pages. WordPress may not be everyone's
    choice since it does not comply with **PHP Standards Recommendations** (**PSRs**)
    ([https://www.php-fig.org/](https://www.php-fig.org/)) and has its own way of
    getting things done. But it was released in 2003 before PSR and many modern PHP
    frameworks. It has been able to support countless businesses and individuals ever
    since. Of course, it has evolved and offers one of the most user-friendly admin
    UIs for editors and developers alike.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: If this hasn't convinced you to use WordPress as an API, there are other options.
    In the next section, we are going to look at an alternative to REST APIs – GraphQL
    APIs – and an alternative to WordPress in Node.js – Keystone. Keystone uses GraphQL
    to deliver its API. Before diving into GraphQL, we'll take a look at Keystone
    and learn how to develop customized CMS.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Keystone
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keystone is a scalable headless CMS for building GraphQL APIs in Node.js. It
    is open source and equipped with a very decent admin UI where you can manage your
    content. Just like WordPress, you can create custom content types in Keystone
    called **lists** and then query your contents through the GraphQL API. You create
    lists from source, just like you create REST APIs. You add what you need for your
    API so that it is highly scalable and extensible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: To use Keystone, first, you need to prepare a database for storing your content.
    Keystone supports MongoDB and PostgreSQL. You need to install and configure one
    of them and then find out the connection string for Keystone. You learned about MongoDB
    in [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml), *Adding a Server-Side
    Database*, so using it again as the database for Keystone should not be an issue
    for you. But what about PostgreSQL? Let's find out.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: For more information about Keystone, please visit [https://www.keystonejs.com/](https://www.keystonejs.com/).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Installing and securing PostgreSQL (Ubuntu)
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PostgreSQL, also known as Postgres, is an object-relational database system,
    often compared with MySQL, which is a (purely) relational database management
    system (RDBMS). Both are open source and use tables but have their differences.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: For example, Postgres is largely SQL compliant while MySQL is partially compliant,
    and MySQL performs faster in terms of read speed while PostgreSQL is faster at
    injecting complex queries. For more information about Postgres, please visit [https://www.postgresql.org/](https://www.postgresql.org/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Postgres on many different operating systems, including Linux,
    macOS, and Windows. Depending on your operating system, you can follow the official
    guide at [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    to install it on your machine. We will show you how to install and secure it on
    Linux, specifically Ubuntu, in the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your local package index and install Postgres from Ubuntu''s default
    repositories using Ubuntu''s `apt` packaging system:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Verify Postgres by checking its version:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you get the following output, this means you have installed it successfully:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The number **12** in the path indicates you have Postgres version 12 on your
    machine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the Postgres shell from your terminal:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should get an output similar to the following on your terminal:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'List the default users using the Postgres `\du` command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should get two default users, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will add a new administrative user (or role) to the list using an interactive
    prompt on our terminal. However, we need to exit the Postgres shell first:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Type in the following command with the `--interactive` flag:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following two questions regarding the name of the new role
    and whether the role should have superuser permissions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we called the new user `user1`. It has superuser permissions, just like
    the default users do.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Log into the Postgres shell with `sudo -u postgres psql` to verify the new user
    with the `\du` command. You should see that it has been added to the list.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a password to the new user with the following SQL query:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you get the following output, then you have successfully added a password
    for this user:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Exit the Postgres shell. Now, you can use PHP''s Adminer ([https://www.adminer.org/](https://www.adminer.org/))
    to log into Postgres with this user and, from there, add a new database that will
    be required when you install Keystone later. Then, you can use the following format
    for the Postgres connection string for the database you have just created:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that a password is always required for any user to log into the database
    from Adminer for security reasons. So, it is a good practice to add security to
    your database, especially for production, regardless of whether it is a MySQL,
    Postgres, or MongoDB database. What about MongoDB? You learned to install and
    use it in previous chapters, but it hasn't been secured yet. We'll find out how
    to do this in the next section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Installing and securing MongoDB (Ubuntu)
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, you should know how to install MongoDB. So, in this section, we will
    focus on securing databases in MongoDB. To secure MongoDB, we will start by adding
    an administrative user to MongoDB, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to the Mongo shell from your terminal:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Select the `admin` database and add a new user with a username and password
    (for example, root and password) to this database, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Exit the shell and open the MongoDB configuration file from your terminal:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Look for the `security` section, remove the hash, and add the `authorization`
    setting, as shown here:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Save and exit the file and restart MongoDB:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Verify the configuration by checking the status of MongoDB:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you see an `"active"` status, that means you have configured it correctly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as `"root"` with the password and the `--authenticationDatabase` option.
    Also, supply the name of the database where the user is stored, which is `"admin"`
    in this case:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new database (for example, `test`) and attach a new user to it:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Exit and test the database by logging in as `user1`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Test whether you can access this `test` database but not other databases:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you receive no output, that means you are only authorized to access this
    database after authentication. You can use the following format to supply the
    MongoDB connection string for Keystone or any other apps (for example, Express,
    Koa, and so on):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, it is good practice to add security to the database, especially for production,
    but it is easier and faster to develop apps with MongoDB without authentication
    enabled. You can always disable it for local development and just enable it in
    the production server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Now, both database systems (Postgres and MongoDB) are ready and you can choose
    either of them to build your Keystone app. So, let's get to it!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Installing and creating Keystone apps
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to start a Keystone project – from scratch or by using the
    Keystone scaffolding tool known as `keystone-app`. If you are going to do it from
    scratch, you need to install any Keystone-related packages manually. These include
    the minimum required Keystone''s packages and the additional Keystone packages
    that you need to build your app. Let''s take a look at this manual installation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project directory and install the minimum required packages – the
    Keystone package itself, the Keystone GraphQL package (which is considered as
    an app in Keystone), and a database adapter:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Install the additional Keystone packages that you need, such as the Keystone
    Admin UI package (which is considered an app in Keystone) and the Keystone field
    package for registering lists:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create an empty `index.js` file in your root directory and import the packages
    you have just installed:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a new instance of Keystone and pass the new instance of the database
    adapter to it, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Check out the following guide to learn how to configure the Mongoose adapter: [https://www.keystonejs.com/keystonejs/adapter-mongoose/](https://www.keystonejs.com/keystonejs/adapter-mongoose/).
    We will cover this again when we install Keystone with the scaffolding tool.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple list – a `Page` list, for example – and define the fields that
    you will need in order to store the data for every single item in this list:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It is a convention to capitalize the name of the list for GraphQL. We will cover
    this soon.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Export the `keystone` instance and the apps so that they can be executed:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a `package.json` file (if you haven''t done so already) and add the
    following `keystone` command to the scripts, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Start the app by running the `dev` script on your terminal:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should see the following output on your terminal. This means you have started
    the app successfully:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Well done! You have your first and simplest Keystone app up and running. In
    this app, you have a GraphQL API at `localhost:3000/admin/api`, a GraphQL Playground
    at `localhost:3000/admin/graphiql`, and a Keystone Admin UI at `localhost:3000/admin`.
    But how do we use the GraphQL API and GraphQL Playground? Rest assured, we will
    get to that in the upcoming section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not difficult at all to start a new Keystone app, is it? You just need
    to install what Keystone requires and what you need. However, the easiest way
    to kick off a Keystone app is by using the scaffolding tool. The benefit of using
    the scaffolding tool is that it comes with some optional samples of Keystone apps
    during the installation process and they can be very useful as guides and templates.
    These optional samples are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**Starter**:This example demonstrates basic user authentication using Keystone.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Todo**:This example demonstrates a simple app for adding items to a `Todo`
    list, along with some frontend integration (HTML, CSS, and JavaScript).'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blank**:This example provides a basic starting point, along with the Keystone
    Admin UI, GraphQL API, and GraphQL Playground. These are just like the ones in
    the manual installation but without the Keystone `field` package.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nuxt**:This example demonstrates a simple integration with Nuxt.js.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will go for the **blank** option because it provides us with the basic packages
    we need so that we can build our lists on top of them. Let''s take a look:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a fresh Keystone app with any name on your terminal:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Answer the questions that Keystone asks about, as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After the installation is complete, move into your project directory:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you are using secured Postgres, then just provide the connection string,
    along with the username, password, and database for Keystone:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that you just have to remove `<username>:<password>@` from the string
    if you don''t have authentication enabled. Then, run the following command to
    install the database tables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: For more information about the Knex database adapter, please visit [https://www.keystonejs.com/quick-start/adapters](https://www.keystonejs.com/quick-start/adapters)
    or visit knex.js at [http://knexjs.org/](http://knexjs.org/). It is a query builder
    for PostgreSQL, MySQL, and SQLite3.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using secured MongoDB, then just provide the connection string,
    along with the username, password, and database for Keystone:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that you just have to remove `<username>:<password>@` from the string if
    you don't have authentication enabled.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the Mongoose database adapter, please visit [https://www.keystonejs.com/keystonejs/adapter-mongoose/](https://www.keystonejs.com/keystonejs/adapter-mongoose/)
    or visit Mongoose at [https://mongoosejs.com/](https://mongoosejs.com/). MongoDB
    is a **schemaless** database system by nature, so this adapter is used as a schema
    solution to model the data in our app.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the server default port from `3000` to `4000` to serve the Keystone
    app. You can do this by simply adding `PORT=4000` to the `dev` script, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The reason we changed the port for Keystone to `4000` is because we are reserving
    port `3000` for Nuxt apps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `nodemon` in our project. This will allow us to monitor changes in
    our Keystone app so that it can reload the server for us:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After installing this package, add the `nodemon --exec` command to the `dev`
    script, as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: For more information about nodemon, please visit [https://nodemon.io/](https://nodemon.io/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server for our Keystone app with the following command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You should see the following output on your terminal. This means you have installed
    the Keystone app successfully:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is the same as performing the manual installation but on a different port.
    In this app, you have a GraphQL API at `localhost:4000/admin/api`, a GraphQL Playground
    at `localhost:4000/admin/graphiql`, and a Keystone Admin UI at `localhost:4000/admin`.
    Before we can do anything with the GraphQL API and GraphQL Playground, we must
    add lists to our Keystone app and start injecting data from the Keystone Admin
    UI. We'll start adding lists and fields to the app in the next section.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: You can find the apps we created from both of these installation techniques
    in `/chapter-18/keystone/` in this book's GitHub repository.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Creating lists and fields
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Keystone, lists are schemas. A schema is a data model that has types that
    describe our data. It is the same in Keystone: a list schema is composed of fields
    that have types to describe the data they accept, just like we had in the manual
    installation, in which we have a `Page` list composed of a single `name` field
    with a `Text` type.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: There are many different field types in Keystone, such as `File`, `Float`, `Checkbox`,
    `Content`, `DateTime`, `Slug`, and `Relationships`. You can find out about the
    rest of the Keystone field types that you need in their documentation at [https://www.keystonejs.com/](https://www.keystonejs.com/).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: To add fields and their types to the list, you just have to install the Keystone
    packages that hold those field types in your project directory. For example, the
    `@keystonejs/fields` package holds the `Checkbox`, `Text`, `Float`, and `DateTime`
    field types, among others. You can find out about the rest of the field types
    at [https://www.keystonejs.com/keystonejs/fields/fields](https://www.keystonejs.com/keystonejs/fields/#fields).
    After you have the required field type packages installed, you can just import
    them and unpack the field types you need by using the JavaScript destructuring
    assignment for list creation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'However, lists can grow over time, which means they can become messy and difficult
    to keep up with. So, it is a good idea to create lists in **separate** files in
    a `/list/` directory for better maintainability, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, you just have to import it into the `index.js` file. So, let''s find
    out what schema/lists and other Keystone packages we need to build our Keystone
    app. The lists that we are going to create are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: A `Page` schema/list for storing main pages such as `home`, `about`, `contact`,
    and `projects`
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Project` schema/list for storing project pages
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `Image` schema/list for storing images for main and project pages
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Slide Image` schema/list for storing images for main pages only
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Nav Link` schema/list for storing the site links
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Keystone packages that we are going to use to create these lists are as
    follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**Static file app**: This package is used to serve static files such as images,
    CSS, and JavaScript so that they can be accessed publicly by the client. For more
    information, please visit [https://www.keystonejs.com/keystonejs/app-static/](https://www.keystonejs.com/keystonejs/app-static/).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File adapters**:This package is used to support the `File` field type, which
    is used to upload files to a local or remote cloud-based location. For more information,
    please visit [https://www.keystonejs.com/keystonejs/file-adapters/](https://www.keystonejs.com/keystonejs/file-adapters/).'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WYSIWYG**:This package is used to render a WYSIWYG editor in the Keystone
    Admin UI using TinyMCE. For more information about this package, please visit
    [https://www.keystonejs.com/keystonejs/fields-wysiwyg-tinymce/](https://www.keystonejs.com/keystonejs/fields-wysiwyg-tinymce/).
    For the information about TinyMCE, please visit [https://www.tiny.cloud/](https://www.tiny.cloud/).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s install and use them to create our lists:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Keystone packages that we mentioned previously via npm:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Import `@keystonejs/app-static` into `index.js` and define the path and the
    folder name where you want to keep the static files:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a `File.js` file in the `/lists/` directory. Then, define the fields
    for the `Image` list using the `File`, `Text`, and `Slug` field types from `@keystonejs/fields`
    and `LocalFileAdapter` from `@keystonejs/file-adapters`. This will allow you to
    upload files to the local location; that is, `/public/files/`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding code, we defined a list of fields (`title`, `alt`, `caption`,
    `name`, and `file`) so that we can store the meta-information about every uploaded
    file. It is good practice to have the `name` field in every list schema so that
    we can store a unique name in this field that we can use as the label in Keystone
    Admin UI. We can use it to identify each injected list item easily. To generate
    a unique name for this field, we can use the `Slug` type, which, by default, generates
    the unique name from the `title` field.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the field types that we used in the preceding code,
    please visit the following links:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.keystonejs.com/keystonejs/fields/src/types/file/](https://www.keystonejs.com/keystonejs/fields/src/types/file/) for
    the `File` type'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.keystonejs.com/keystonejs/fields/src/types/text/](https://www.keystonejs.com/keystonejs/fields/src/types/text/) for
    the `Text` type'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.keystonejs.com/keystonejs/fields/src/types/slug/](https://www.keystonejs.com/keystonejs/fields/src/types/slug/) for
    the `Slug` type'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about `LocalFileAdapter`, please visit [https://www.keystonejs.com/keystonejs/file-adapters/localfileadapter](https://www.keystonejs.com/keystonejs/file-adapters/#localfileadapter).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Our app files can be uploaded to Cloudinary using `CloudinaryFileAdapter`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how to set up an account so that you can host files
    on Cloudinary, please visit [https://cloudinary.com/](https://cloudinary.com/).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `SlideImage.js` file in the `/lists/` directory and define the fields
    that are identical to the ones in the `File.js` file with an additional field
    type, `Relationship`, so that you can link the slide image to the project page:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: For more information about the `Relationship` field, please visit [https://www.keystonejs.com/keystonejs/fields/src/types/relationship/](https://www.keystonejs.com/keystonejs/fields/src/types/relationship/).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Page.js` file in the `/lists/` directory and define the fields for
    the `Page` list using the `Text`, `Relationship`, `Slug`, and `Wysiwyg` field
    types from `@keystonejs/fields` and `@keystonejs/fields-wysiwyg-tinymce`, as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding code, we defined a list of fields (`title`, `excerpt`, `content`,
    `name`, `featuredImage,` and `slideImages`) so that we can store the data of every
    main page that we will inject into this content type. Note that we link `featuredImage`
    to the `Image` list and link `slideImages` to the `SlideImage` list. We want to
    allow multiple images to be placed in the `slideImages` field, so we set the `many` option
    to `true`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: For more information about these one-to-many and many-to-many relationships,
    please visit [https://www.keystonejs.com/guides/new-schema-cheatsheet](https://www.keystonejs.com/guides/new-schema-cheatsheet).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Project.js` file in the `/lists/` directory and define the fields
    that are identical to the ones in the `File.js` file for the `Project` list with
    two additional fields (`fullscreenImage` and `projectImages`):'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create a `NavLink.js` file in the `/lists/` directory and define the fields
    (`title`, `order`, `name`, `link`, `subLinks`) for the `NavLink` list using the
    `Text`, `Relationship`, `Slug`, and `Integer` field types from `@keystonejs/fields`,
    as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, we use the `order` field to sort the link items by their numeric positions
    in the GraphQL query. You will learn about this soon. The `subLinks` field is
    an example that demonstrates how you can make simple sublinks in Keystone. So,
    we can add multiple sublinks to the main links by attaching the project pages
    to this field, which is linked to the `Project` list using the `Relationship`
    field type.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `Integer` field type, please visit [https://www.keystonejs.com/keystonejs/fields/src/types/integer/](https://www.keystonejs.com/keystonejs/fields/src/types/integer/).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the files from the `/lists/` directory and start creating the list schema
    from them, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Start the app by running the `dev` script on your terminal:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You should see a list of URLs on your terminal identical to the ones shown in
    the previous section. This means you have started the app successfully on `localhost:4000`.
    So, now, you can point your browser to `localhost:4000/admin` and start injecting
    content and uploading files from the Keystone Admin UI. Once you have the content
    and data ready, you can query them using the GraphQL API and GraphQL Playground.
    But before you can do that, you should learn what a GraphQL is and how to create
    and use it independently from Keystone. So, let's find out!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this app in `/chapter-18/cross-domain/backend/keystone/`
    in this book's GitHub repository.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Introducing GraphQL
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraphQL is an open source query language, server-side runtime (execution engine),
    and specification (technical standard). But what does it mean? What is it? GraphQL
    is a query language, which is what the "QL" part of GraphQL stands for. To be
    specific, it is a client query language. But again, what does it mean? The following
    example will address any doubts you have about GraphQL queries:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'GraphQL queries like the previous one are used in HTTP clients such as Nuxt
    or Vue to send the query to the server in exchange for a JSON response, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can see, you get the specific data for the fields (`age` and `population`)
    that you requested and nothing more. This is what makes GraphQL distinctive and
    gives the client the power to request exactly what they want. It's cool and exciting,
    isn't it? But what is it in the server that returns the GraphQL response? A GraphQL
    API server (server-side runtime).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL queries are sent by the client to a GraphQL API server over an HTTP
    endpoint via the `POST` method to the server as a string. The server extracts
    and processes the query string. Then, just like any typical API server, the GraphQL
    API will fetch the data from a database or other services/APIs and return it to
    the client in a JSON response.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'So, can we use a server such as Express as a GraphQL API server? Yes and no.
    All qualified GraphQL servers must implement two core components, as specified
    in the GraphQL specification, that validate and process and then return the data:
    a schema and resolvers.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'A GraphQL schema is a collection of type definitions that consist of objects
    that the client can request and the fields that the objects have. On the other
    hand, GraphQL resolvers are functions that are attached to the fields that return
    values when the client makes a query or mutation. For example, the following is
    the type definition for finding a planet:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, you can see that GraphQL uses a strongly typed schema – each field must
    be defined with a type that can be a scalar type (which is a single value that
    can be an integer, Boolean, or string) or an object type. The `Planet` and `Query` types
    are object types, while `String` and `Int` are scalar types. Each of the fields
    in the object types must be resolved with a function, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding example was written in JavaScript, but a GraphQL server can be
    written in any programming language as long as you follow and implement what is
    outlined in the GraphQL specification at [https://spec.graphql.org/](https://spec.graphql.org/).
    The following are some examples of GraphQL implementations in different languages:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL.js (JavaScript) at [https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js)
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: graphql-php (PHP) at [https://github.com/webonyx/graphql-php](https://github.com/webonyx/graphql-php)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphene (Python) at [https://github.com/graphql-python/graphene](https://github.com/graphql-python/graphene)
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL Ruby (Ruby) at [https://github.com/rmosolgo/graphql-ruby](https://github.com/rmosolgo/graphql-ruby)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are free to create a new implementation as long as you comply with the GraphQL
    specification, but we're only going to use GraphQL.js in this book. Now, you probably
    have some deeper questions – what exactly is the query type? We know that it is
    an `object` type, but why do we need it? Do we need to have it in the schema?
    The short answer is yes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at this in more detail in the next section and find out why it is
    required regardless. We will also find out how to use Express as a GraphQL API
    server. So, keep reading.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the GraphQL schema and resolvers
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example schema and resolvers for finding a planet that we discussed in the
    previous section presume that we use the GraphQL schema language, which helps
    us create the GraphQL schema required by the GraphQL server. We can easily create
    a GraphQL.js `GraphQLSchema` instance from the GraphQL schema language using the
    `makeExecutableSchema` function from a Node.js package called GraphQL Tools.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more information about this package at [https://www.graphql-tools.com/](https://www.graphql-tools.com/)
    or [https://github.com/ardatan/graphql-tools](https://github.com/ardatan/graphql-tools).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL schema language is a "shortcut" – a shorthand notation for constructing
    your GraphQL schema and its type system. Before making use of this shorthand notation,
    we should take a look at how a GraphQL schema is built from the low-level objects
    and functions such as `GraphQLObjectType`, `GraphQLString`, `GraphQLList`, and
    so on from GraphQL.js, which implements the GraphQL specification. Let''s install
    these packages and create a simple GraphQL API server with Express:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Express, GraphQL.js, and GraphQL HTTP Server Middleware via npm:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: GraphQL HTTP Server Middleware is a piece of middleware that allows us to create
    a GraphQL HTTP server with any HTTP web framework that implements the way Connect
    supports a middleware, such as Express, Restify, and Connect itself.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about these packages, please visit the following links:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/graphql/express-graphql](https://github.com/graphql/express-graphql) for
    GraphQL HTTP Server Middleware'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/senchalabs/connect](https://github.com/senchalabs/connect) for
    Connect'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://expressjs.com/](https://expressjs.com/) for Express'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://restify.com/](http://restify.com/) for Restify'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create an `index.js` file in the project''s root and import `express`, `express-graphql`
    and `graphql`, using the `require` method:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create a dummy data with a list of planets:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Define the `Planet` object type and the fields that the client can query:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that it is a convention to capitalize the object type in the `name` field
    for the GraphQL schema's creation.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Define various types and how you want to resolve the value for each field:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Notice that every resolver function accepts the following four arguments:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`root`: The object or value that''s resolved from the parent object type (the
    Query in *step 6*).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args`: Arguments that the field can receive if they are set. See *step 8*.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context`: A mutable JavaScript object that holds the top-level data that is
    shared across all the resolvers. It is the Node.js HTTP request object (`IncomingMessage`)
    by default in our case when using Express. We can modify this context object and
    add general data that we want to be shared, such as authentication and database
    connections. See *step 10*.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`: A JavaScript object that holds information about the current field
    such as its field name, return type, parent type (`Planet`, in this case), and
    the general schema details.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can omit them if they aren't needed for resolving the value for the current
    field.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Query` object type and the fields that the client can query:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Define the type and resolve how you want to return the value for the `hello`
    field:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Define the type and resolve how you want to return the value for the `planet`
    field:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Notice that we passed the `Planet` object type that we created and stored in
    the `planetType` variable to the `planet` field in the `Query` object type so
    that a relationship between them can be established.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Construct a GraphQL schema instance with the required `query` field and the
    **`Query`** object type that you have just defined with the fields, types, arguments,
    and resolvers in it, as follows:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that the `query` key must be provided as the GraphQL query root type so
    that our query can be chained down to the fields in the `Planet` object type.
    We can say that the `Planet` object type is a subtype or a child of the `Query`
    object type (the root type) and that their relationship must be established in
    the parent object (`Query`) using the `type` field in the `planet` field.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the GraphQL HTTP Server Middleware as a piece of middleware with the GraphQL
    schema instance to establish the GraphQL server on an endpoint permitted by Express
    called `/graphiql`, as follows:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: It is recommended to set the `graphiql` option to `true` so that we can use
    the GraphQL IDE when the GraphQL endpoint is loaded on the browser.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'At this top level, you can also modify the context of your GraphQL API by using
    the `context` option inside the `graphqlHTTP` middleware, as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: By doing this, you can access this top-level data from any resolver. This can
    be very useful. Cool, isn't it?
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after all the data has been loaded, start the server with the `node
    index.js` command on your terminal with the following line in the `index.js` file:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Point your browser to `localhost:4000/graphiql`. You should see the GraphQL
    IDE, a UI where you can test your GraphQL API. So, type the following query into
    the input area on the left-hand side:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You should see that the preceding GraphQL query has been exchanged with a JSON
    object on the right-hand side when you hit the play button:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Well done – you have managed to create a basic GraphQL API server with Express
    using the low-level approach! We hope this has given you a full picture of how
    a GraphQL API server can be created with the GraphQL schema and resolvers. We
    also hope that you can see the relationship between these two core components
    in GraphQL and that we have answered yours questions; that is, what exactly is
    the `Query` type? Why do we need it? Do we need to have it in the schema? The
    answer is yes, the query (object) type is a root object type (usually called a
    root `Query` type) that must be provided when creating the GraphQL schema.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'But you may still have some questions and complaints, particularly regarding
    the resolvers – surely you find it tedious and dumb to define the resolvers in
    *step 5* for the fields in the `Planet` object type because they do nothing except
    return the values that are resolved from the query object. Is there any way to
    avoid this painful repetition? The answer is yes: you don''t specify them for
    every field in your schema, and this lies in the **default resolver**. But how
    do we do this? We''ll find out in the next section.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: You can find this and other examples in `/chapter-18/graphql-api/graphql-express/`
    in this book's GitHub repository.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraphQL default resolvers
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When no resolver has been specified for a field, by default, this field will
    take on the value of the property in the object that''s been resolved by the parent –
    that is, if that object has a property name that matches the field name. So, the
    fields in the `Planet` object type can be refactored as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The values of these fields will fall back to the properties in the object that''s
    been resolved by the parent (the query type) under the hood, as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'So, put the other way around, when a resolver is specified explicitly for a
    field, this resolver will always be used, even if the parent''s resolver returns
    any value for that field. For example, let''s specify a value explicitly for the
    `id` field in the `Planet` object type, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We already know that the default ID values for Earth and Mars are 3 and 4 and
    that they are resolved by the `Query` object type (the parent), as shown in *step
    8* in the previous section. But these resolved values will never be used because
    they are overridden by the value in the ID''s resolver. So, let''s query Earth
    or Mars, as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In this case, you will always get `2` in the JSON response:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This is very clever, isn't it? It saves us from painful repetition – that is,
    if you have tons of fields in an object type. However, so far, we have been following
    the most painful way to construct our schema by working with GraphQL.js. This
    is because we wanted to see and understand how a GraphQL schema is created from
    the low-level types. We probably wouldn't want to take this long and winding road
    in real life, especially in a large project. Instead, we should prefer using the
    GraphQL schema language to build the schema and resolvers for us. In the next
    section, we will show you how to create a GraphQL API server easily with the GraphQL
    schema language and **Apollo Server** as an alternative to GraphQL HTTP Server
    Middleware. So, read on!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GraphQL API with Apollo Server
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apollo Server is an open source and GraphQL spec-compliant server developed
    by the Apollo platform for building GraphQL APIs. We can use it standalone or
    with other Node.js web frameworks such as Express, Koa, Hapi, and so on. We will
    use Apollo Server as it is in this book, but if you want to use it with other
    frameworks, please visit [https://github.com/apollographql/apollo-serverinstallation-integrations](https://github.com/apollographql/apollo-server#installation-integrations).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'In this GraphQL API, we will create a server that queries a collection of books
    by title and author. Let''s get started:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Apollo Server and GraphQL.js via npm as the project dependencies:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Create an `index.js` file in the project root directory and import the `ApolloServer`
    and `gql` functions from the `apollo-server` package:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `gql` function is used to parse GraphQL operations and the schema language
    by wrapping them with template literal tags (or tagged template literals). For
    more information about template literals and tagged templates, please visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following static data, which holds the lists of authors and posts:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Define the `Author`, `Post`, and `Query` object types, along with the fields
    that the client can query:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note that we can shorthand the `Author`, `Post`, and `Query` object types as
    the `Author` type, the `Post` type,  and the `Query` type. It is just clearer
    than using "object type" to describe them because that is what they are. Remember
    that apart from being an object type by nature, the `Query` type is also the root
    type in GraphQL schema creation.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we establish the relationship of `Author` with `Post` and `Post`
    with `Query` – the type for the `author` field is the `Author` type. The `Author`
    type has simple scalar types for its fields (`id`, `name`), while the `Post` type
    has simple scalar types (`id`, `title`) and the `Author` type (`author`) for its
    field. The `Query` type has the `Post` type for its only field, which is `posts`,
    but it is a list of posts, so we must use the type modifier to wrap the `Post`
    type with open and closed square brackets to indicate that this `posts` field
    will resolve with an array of `Post` objects.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the type modifier, please visit [https://graphql.org/learn/schema/lists-and-non-null](https://graphql.org/learn/schema/#lists-and-non-null).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Define resolvers to specify how you want to resolve the value for the `posts`
    field in the `Query` type and the `author` field in the `Post` type:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Notice how the GraphQL schema language has helped us **decouple** the resolvers
    from the object types and that they are simply defined in a single JavaScript
    object. The resolvers in the JavaScript object are "magically" connected with
    the object types, as long as the property names for our resolvers map the field
    names in the type definitions. Hence, this JavaScript object is called a resolver
    map. Before defining resolvers, we must also define the **top-level** property
    names (`Query`, `Post`) in the resolver map so that they match the object types
    (`Author`, `Post`, `Query`) in the type definitions. But we don't need to define
    any specific resolvers for the `Author` type in this resolver map because the
    values for the fields (`id`, `name`) in `Author` are resolved by the default resolvers
    automatically.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Another point to note is that the values for the fields (`id`, `title`) in
    the `Post` type are also resolved by the default ones. If you don''t like using
    property names to define resolvers, you can use resolver functions instead, as
    long as the function names correspond with the field names in the type definitions.
    For example, the resolvers for the `author` field can be rewritten as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Construct a GraphQL schema instance from `ApolloServer` with the type definitions
    and resolvers. Then, start the server, as follows:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Launch your GraphQL API with the `node` command on your terminal:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Point your browser to `localhost:4000`. You should see the GraphQL Playground
    loaded on your screen. From there, you can test your GraphQL API. So, type the
    following query into the input area on the left-hand side:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'You should see that the preceding GraphQL query has been exchanged with a JSON
    object on the right-hand side when you hit the play button:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This is beautiful and wonderful, isn't it? That's how easily we can build a
    GraphQL API with the GraphQL schema language and Apollo Server. It is worth knowing
    the long and painful way of how a GraphQL schema and resolvers are created before
    adopting the shorthand method. Once you have this basic concrete knowledge, you
    should be able to query the data you have stored with Keystone with ease. We have
    only covered a few of GraphQL's types in this book, including the scalar type,
    the object type, the query type, and the type modifier. There are a few other
    types you should check out, such as the mutation type, the enumeration type, the
    union and input types, and interface. Please check them out at [https://graphql.org/learn/schema/](https://graphql.org/learn/schema/).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about GraphQL, please visit [https://graphql.org/learn/](https://graphql.org/learn/).
    For more information about Apollo Server, visit [https://www.apollographql.com/docs/apollo-server/](https://www.apollographql.com/docs/apollo-server/).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code that was used in this section, along with other example
    GraphQL type definitions, in `/chapter-18/graphql-api/graphql-apollo/` in this
    book's GitHub repository.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to use the Keystone GraphQL API.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Using the Keystone GraphQL API
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GraphQL Playground for the Keystone GraphQL API is located at `localhost:4000/admin/graphiql`.
    Here, we can test the list we created through the Keystone admin UI at `localhost:4000/admin`.
    Keystone will generate four top-level GraphQL queries automatically for **every**
    list that''s created. For example, we will get the following queries for the `page`
    list we created in the previous section:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '`allPages`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This query can be used to fetch all the items from the `Page` list. We can
    also search, limit, and filter the result, as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '`_allPagesMeta`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This query can be used to fetch all meta-information about items in the `Page`
    list, such as the total count of all matched items, which can be useful for pagination.
    We can also search, limit, and filter the result, as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '`Page`'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This query can be used to fetch a single item from the `Page` list. We can **only** use
    a `where` parameter with an `id` key to fetch the page, as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '`_PagesMeta`'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This query can be used to fetch the meta-information about the `Page` list
    itself, such as its name, access, schema, and fields, as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'As you can see, these four queries, along with the filter, limit, and sorting
    parameters, provide us with enough power to fetch the specific data that we need
    and nothing more. What''s more is that, in GraphQL, we can fetch **multiple**
    resources with a **single** request, as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This is amazing and fun, isn't it? In a REST API, you may have to send multiple
    requests to multiple API endpoints for multiple resources. GraphQL offers us an
    alternative to solve this infamous issue of REST APIs that has bothered both frontend
    and backend developers. Note that these four top-level queries also apply to other
    lists we have created, including `Project`, `Image`, and `NavLink`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: For more information about these four top-level queries and the filter, limit,
    and sorting parameters, as well as the GraphQL mutations and execution steps,
    which are not covered in this book, please visit [https://www.keystonejs.com/guides/intro-to-graphql/](https://www.keystonejs.com/guides/intro-to-graphql/).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn about how to query a GraphQL server in general, please
    visit [https://graphql.org/learn/queries/](https://graphql.org/learn/queries/).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have basic knowledge of GraphQL and are aware of Keystone's top-levels
    GraphQL queries, it's time to learn how to use them in the Nuxt app.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Keystone, GraphQL, and Nuxt
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keystone's GraphQL API endpoint is located at `localhost:4000/admin/api`. As
    opposed to a REST API, which usually has multiple endpoints, GraphQL API usually
    has **one single endpoint** for all queries. So, we will use this endpoint to
    send our GraphQL queries from the Nuxt app. It is good practice to always test
    our queries on the GraphQL Playground first to confirm that we get the result
    we need and then use those tested queries in our frontend apps. Besides, we should
    always use the `query` keyword in our queries in the frontend app to fetch data
    from the GraphQL API.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we will refactor the Nuxt app that we built for the WordPress
    API. We will be looking at the `/pages/index.vue`, `/pages/projects/index.vue`,
    `/pages/projects/_slug.vue`, and `/store/index.js` files. We will still be using
    Axios to help us send the GraphQL query. Let''s take a look at how to get the
    GraphQL query and Axios working together:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable that will store the GraphQL query in order to fetch the title
    of the home page and the slide images that we attached to it:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We only need the slug from the project page that the image will link to, so
    the `name` field is the only field we will query. And we only need the relative
    public URL of the image, so the `publicUrl` field is the only field we want from
    the image file object. Also, we use the `allPages` query instead of `Page` because
    it is easier to get the page by its slug, which is *home* in this case.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Send the query to the GraphQL API endpoint using the `post` method from Axios:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Notice that we only need the first item from the array in the data that's returned
    from the GraphQL API, so we use `0` to locate this first item.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Note that we should also refactor `/pages/about.vue`, `/pages/contact.vue`,
    `/pages/projects/index.vue`, and `/pages/projects/pages/_number.vue` following
    the same pattern of how we refactored this home page. You can find the path to
    this book's GitHub repository, which contains the complete code, at the end of
    this section.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable that will store the query and allow you to fetch multiple
    resources from the endpoint, as follows:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: As you can see, we are fetching the total count of project pages through `_allProjectsMeta` and
    the list of project pages through `allProjects` with the `orderBy`, `skip`, and `first` filters.
    The data for the `skip` and `first` filters will be passed in as variables; that
    is, `skip` and `postsPerPage`, respectively.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute the data for the `skip` variable from the route parameters, set `6`
    to the `postsPerPage` variable, and then send the query to the GraphQL API endpoint
    using the `post` method from Axios:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: As you can see, we compute the `pageNumber` data from the route parameters,
    which we can only access via `this.$route.params` in the `fetch` method. The `skip`
    data is computed from `pageNumber` and `postsPerPage` before we pass it to the
    GraphQL query and fetch our data. Here, we will get `1` for `pageNumber` and `0`
    for `skip` on the `/projects` or `/projects/pages/1` route, `2` for `pageNumber`
    and `6` for `skip` on the `/projects/pages/2` route, and so on. Also, we must
    make sure that any intentional negative data in the route (for example, `/projects/pages/-100`)
    will be made positive by using the JavaScript `Math.abs` function.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the JavaScript `Math.abs` function, please visit
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the pagination (the next page and the previous page) from the `count`
    field that''s returned from the server, and then return the data as usual for
    the `<template>` block, as follows:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create a variable that will store the query for fetching a single project page
    by the slug from the endpoint, as follows:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Here, we are fetching the project page through `allProjects` with the `search`
    filter. The data for the `search` filter will be passed in from the `params.slug`
    parameter. The fields we will query in `fullscreenImage` and `fullscreenImage`
    are the same as the ones in `featuredImage`; you can find them in *step 3*.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Send the query to the GraphQL API endpoint using the `post` method from Axios:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Notice that you can also destructure nested objects or arrays and assign a variable
    to the value. In the preceding code, we have assigned `result` as the variable
    in order to store the value of the `data` property that's returned by GraphQL.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable that will store the query for fetching the list of `NavLinks`
    from the endpoint with the `orderBy` filter, as follows:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Send the query to the GraphQL API endpoint using the `post` method from Axios
    and then commit the data to the store state:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '(Optional) Just like the *step 9* in the *Integrating with Nuxt and streaming
    images from WordPress* section, if the Nuxt crawler fails to detect the dynamic
    routes for some unknown reasons, then generate these routes manually in the generate
    option in the Nuxt config file, as follows:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In this optional step, you can see that we use the same JavaScript built-in
    object and methods – `Array`, `map`, `fill` and `push`, just as in the *Integrating
    with Nuxt and streaming images from WordPress* section, to work out the dynamic
    routes for the child pages and pagination for us, and then return them as a single
    array for Nuxt to generate their dynamic routes.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following script commands for either development or production:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Remember that if you want to generate static pages and host the images in the
    same location, we have the ability to stream the remote images to the `/assets/`
    directory so that webpack can process these images for us. So, if you want to
    do that, then just as we've done previously, run `npm run stream` first to stream
    the remote images to your local disc and then run `npm run generate` to regenerate
    the static pages with the images before hosting them somewhere.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this exercise in `/chapter-18/cross-domain/frontend/nuxt-universal/nuxt-keystone` in
    this book's GitHub repository.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Apart from using Axios, you can also use Nuxt Apollo module to send GraphQL
    queries to the server. For more information about this module and its usage, please
    visit [https://github.com/nuxt-community/apollo-module](https://github.com/nuxt-community/apollo-module).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have successfully integrated Nuxt with the Keystone GraphQL API
    and streamed remote resources for static pages – just like did with the WordPress
    REST API. We hope that Keystone and GraphQL, in particular, have shown you another
    exciting API option. You can even take the GraphQL knowledge you have learned
    in this chapter further and develop your GraphQL API for Nuxt apps. You can also
    take Nuxt to the next level with many other technologies, just like some of those
    we have walked you through in this book. This book has been quite a journey. We
    hope it has benefitted you regarding web development and that you can take what
    you have learned from this book as far as you can. Now, let's summarize what you
    have learned in this chapter.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you managed to create custom post types and routes to extend
    the WordPress REST API, integrated with Nuxt, and streamed the remote resources
    from WordPress to generate static pages. You also managed to customize a CMS from
    Keystone by creating lists and fields. You then learned how to create a GraphQL
    API at a low level with GraphQL.js and at a high level with the GraphQL schema
    language and Apollo Server. Now that you've grasped the foundations of GraphQL,
    you can query the Keystone GraphQL API from the Nuxt app using GraphQL queries
    and Axios. And last, not least, you can stream remote resources from the Keystone
    project to the Nuxt project to generate static pages. Well done!
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: This has been a very long journey. You've gone from learning about the directory
    structure of Nuxt to adding pages, routes, transitions, components, Vuex stores,
    plugins, and modules, and then to creating user logins and API authentication,
    writing end-to-end tests, and creating Nuxt SPAs (static pages). You've also integrated
    Nuxt with other technologies, tools, and frameworks, including MongoDB, RethinkDB,
    MySQL, PostgreSQL, and GraphQL; Koa, Express, Keystone, and Socket.IO; PHP and
    PSRs; Zurb Foundation and Less CSS; and Prettier, ESLint, and StandardJS.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: We hope that this has been an inspiring journey and that you will adopt Nuxt
    in your projects wherever it fits and take it further to benefit yourself as well
    as the community. Keep coding, be inspiring, and stay inspired. We wish you all
    the best.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Note that a final app example of this book can be found on the author's website.
    It's a solelystatic-generated web app made entirely with Nuxt's `static` target
    and GraphQL! Please have a look and explore it at [https://lauthiamkok.net/](https://lauthiamkok.net/).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
