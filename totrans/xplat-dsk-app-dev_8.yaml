- en: 'Creating RSS Aggregator with Electron, TypeScript, React, and Redux: Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we embraced TypeScript and came up with a static prototype.
    Now, we are about unleash the try power of the language. We are going to write
    application services and cover them with interfaces. We will describe actions
    and Reducers. On the way, we will examine the creation of Promise-based asynchronous
    actions and optimistic updates with the `redux-promise` and `redux-actions` modules.
    We will connect the store to the application and bring the intended functionality
    to the components. We will also create a simple router and bind it to the store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service to fetch RSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a nutshell, our application is about reading RSS feeds. So, it would be
    the right thing to start with the service, which fetches the feed by a given URL
    and parses it into a structure that we could attach to the applications state.
    I suggest retrieving the feed XML with the `request` ([https://www.npmjs.com/package/request](https://www.npmjs.com/package/request))
    module and parsing it using the `feedme` module ([https://www.npmjs.com/package/feedme](https://www.npmjs.com/package/feedme)).
    Let''s do it first in plain JavaScript. So, we need to install both the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to have a function `rss` that uses `request` to fetch feed contents
    though HTTP(s). This function will accept two arguments: feed URL and a callback
    function written in a thunk-like manner of Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define the feed data container as a plain object (`feed`). We obtain
    a Writable Stream ([https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html))
    from the not yet written `createFeedParserStream` function and pipe it into the
    Readable Stream produced by `request` for the specified feed URL. Now, let''s
    add the missing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get the stream as the `FeedMe` instance and subscribe for its parsing
    events. On receiving the feed title, we assign it to `feed.title`. On receiving
    every item's details, we push them into the `feed.items` array. This function
    returns the derived parse stream and modifies the `feed` object by the reference
    passed in with the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can consume the `rss` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite the fact that, by default, the Node.js core modules still imply long
    nesting of asynchronous functions, we are quite aware of the undesirable impact
    known as *Callback Hell.* So, we will convert the service into a Promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it leads to a notably improved development experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Being a Promise, it''s also available via the `async`/`await` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can jump back to TypeScript and describe the types that we
    have in the code. Firstly, we expect the declared `feed` structure to implement
    the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Interfaces/Rss.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But wait! The module `feedme` doesn''t have a declaration file. It looks like
    we have to provide it with an interface too. In the previous chapter, I showed
    a way to introduce a global library into the TypeScript scope by using triple-slash
    directives and ambient declarations. That''s not the only possible solution. We
    can declare the interface in a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Services/IFeedMe.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the service, we import the `IFeedMe` interface and assign the `feedme` export
    to a constant of type `IFeedMe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After rewriting our service in TypeScript, its source will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/app/ts/Services/rss.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What is changed? We regarded the export `feedme` module with an interface (`FeedMe:
    IFeedMe`). We defined the contract for the `createFeedParserStream` function.
    It accepts the `IFeed` type as input and returns `NodeJS.WritableStream`. We did
    the same for the service function `rss`. It expects a string and returns a Promise,
    which resolves in the `IFeed` type.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service to manage feed menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, now we can fetch RSS feeds. But the plan was to have a manageable menu
    of feeds. I think, we can represent the menu in an array of items, where each
    item can be described with the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Interfaces/index.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the service itself, let''s also start with the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Services/IMenu.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To some degree, it''s like Test-Driven development. We describe the contents
    of the class without implementation to get the whole picture. Then, we populate
    the members one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Services/Menu.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What is going on here? Firstly, we import the `sha1` module ([https://www.npmjs.com/package/sha1](https://www.npmjs.com/package/sha1))
    that we are going to use to calculate SHA1 hash ([https://en.wikipedia.org/wiki/SHA-1](https://en.wikipedia.org/wiki/SHA-1))
    of a feed URL. That's an external module, which resolves to a non-module entity
    and, therefore, cannot be imported using the ES6 syntax. That's why, we go with
    the `require` function. But we still want TypeScript to consider the module declaration
    file (`@types/sha1`), so we declare its container as `import sha1`. We also import,
    in the module scope, the service interface (`IMenu`) and menu item type (`IMenuItem`).
    Our constructor accepts namespace as a string. By prefixing the parameter with
    an accessibility modifier, we declare the `ns` property and assign the parameter's
    value to it. The instance of `Menu` will keep the actual menu state in the property
    `items`. Private method `save` stores the value of the `items` property to `localStorage`.
    All the three `add`, `remove`, and `clear` methods modify the `this.items` array
    and synchronize with `localStorage` by using the save method. Finally, the method
    load updates `this.item` with the array stored in `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Actions and Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we have our core services and can start designing the Redux store. We can
    describe the intended state mutations in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action creator** | **Action Type** | **State Impact** |'
  prefs: []
  type: TYPE_TB
- en: '| `toggleOpenAddFeed` | `TOGGLE_ADD_FEED` | `state.isOpenAddFeed` |'
  prefs: []
  type: TYPE_TB
- en: '| `addFeed` | `ADD_FEED` | `state.isOpenAddFeed``state.feedError` `state.items`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setFeedError` | `SET_FEED_ERROR` | `state.feedError` |'
  prefs: []
  type: TYPE_TB
- en: '| `removeFeed` | `REMOVE_FEED` | `state.feedError` |'
  prefs: []
  type: TYPE_TB
- en: '| `fetchFeed` | `FETCH_FEED` | `state.items` `state.feedError` |'
  prefs: []
  type: TYPE_TB
- en: '| `fetchMenu` | `FETCH_MENU` | `state.menu` `state.items``state.activeFeedUrl`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setActiveFeed` | `SET_ACTIVE_FEED` | `state.activeFeedUrl` |'
  prefs: []
  type: TYPE_TB
- en: First of all, we need to populate our feed menu. For that, we are going to have
    a modal window with a form to add a feed. The action creator function `toggleOpenAddFeed`
    will be used to toggle the visibility of the modal window.
  prefs: []
  type: TYPE_NORMAL
- en: When the form in the modal window is submitted, the component will call the
    `addFeed` function. The function fetches the feed by the supplied URL, obtains
    its title, and appends the menu with a new item. As it involves user input and
    network operations, we have to cover the failure scenario. So, we introduce the
    `setFeedError` function that sets a message in the application state. When we
    update the menu, the corresponding service synchronizes the change with `localStorage`.
    That means we need an action to read the menu. The function `fetchMenu` will take
    care of it. Besides, it will utilize the `rss` service to fetch the items of all
    the feeds in the menu in an aggregative list. What's more, we are going to provide
    the option to navigate through the menu. When a user clicks on an item, the component
    calls `setActiveFeed` to mark the item as active and the function `fetchFeed`
    to update the `Feed` component with the items of the selected feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working on action creator functions, we declare the types and use them
    as references from the Reducers. That means we need a module with a bunch of constants
    representing action types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Constants/index.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are here, let''s also define a few configuration constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first (`MENU_STORAGE_NS`) specifies the namespace that we are going to use
    in `localStorage` for the menu. The second (`FEED_ITEM_PER_PAGE`) determines how
    many items we display per page. That applies for both a selected feed and aggregative
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](5fc3eae1-8e13-4273-a9a3-c79d5384db4c.xhtml), *Creating a Screen
    Capturer with NW.js, React, and Redux: Planning, Design, and Development*, we
    used the third-party module `redux-act` to abstract the creation of actions and
    Reducers. It was really handy, but it doesn''t fit if you need asynchronous actions.
    So, this time, we are going to use the `redux-actions` module ([https://github.com/acdlite/redux-actions](https://github.com/acdlite/redux-actions))
    instead. Let''s check what that is on a JavaScript example. First, we create a
    synchronous action by calling the `createAction` function of `redux-actions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, it looks pretty much similar to the syntax of `redux-act`. We can run
    the newly created function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get an action object with a mandatory `type` property and a multipurpose
    `payload` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make a Reducer by using the `handleActions` function of `redux-actions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The function `handleActions` expects a plain object that maps handlers to actions
    using the action type as a reference. Every handler callback takes in the latest
    state object and the dispatched action--the same as the canonical Reducer ([http://redux.js.org/docs/basics/Reducers.html](http://redux.js.org/docs/basics/Reducers.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about asynchronous actions? For example, we are going use the `rss`
    services for fetching feeds. The service returns a Promise. Thanks to `redux-actions`,
    we can create an action as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Isn''t it beautiful? We just pass, for the handler, an asynchronous function.
    The action will be dispatched as soon as the Promise of the handler resolves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Hold on! But what if the Promise gets rejected? The module `redux-actions`
    relies on optimistic updates. In the case of failure, incoming action acquires
    an extra property `error` when we can find an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now after considering how we are going to implement action creators and Reducers,
    we can cover the store assets with interfaces. First, we declare the interface
    for the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Interfaces/index.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The property `isOpenAddFeed` is a `boolean` determining if the modal window
    with the form for adding a new feed is visible. The property `menu` contains the
    list of menu items and is used in the `Menu` component to build the menu. The
    property `items` consists of RSS items and is used to build the list in the `Feed`
    component. The property `feedError` stores the last error message and `activeFeedUrl`
    keeps the last requested feed URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we describe the actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The module `redux-actions` exports though the declaration file `Action` type.
    So, we state that the functions `toggleOpenAddFeed`, `setActiveFeed`, and `setFeedError`
    return plain objects that confront the `Action` type constraints. In other words,
    in addition to the `type` property, those may have `payload` and `error`. `Action`
    is a generic type, so we clarify what type is expected in payload, for example,
    `Action<boolean>` means `{ type: string, payload: boolean }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous actions `fetchMenu`, `addFeed`, `removeFeed`, and `fetchFeed`
    return Promises. Again, we specify explicitly what type is expected when a Promise
    resolves. Speaking of which, the function `fetchMenu` refers to the missing `IMenuRssPayload`
    type. Let''s add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Interfaces/index.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The function resolves with an object containing both menu items and RSS items
    of the aggregative list.
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems like we are ready to implement the store. So, we will start with actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Actions/actions.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import `createAction`, the earlier defined constants and interfaces,
    and both the services such as `rss` and `Menu` constructor. We create an instance
    of the menu in the namespace imported from the configuration constants. Next,
    we add synchronous actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the pattern we examined earlier in the JavaScript example for `createAction`.
    The only difference is that `createAction` is a generic type in the TypeScript
    scope, so we have to specify what type the action creator will pass in the `payload`
    property and what it expects with the first parameter. All of these functions
    take in a single argument. If we needed more, we would express it as `createAction<Payload,
    Arg1, Arg2>` or even `createAction<Payload, Arg1, Arg2, Arg3, Arg4>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we extend `feedActions` with asynchronous actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The function `fetchFeed` simply delegates the Promise of the `rss` service.
    The function `addFeed` first checks whether a given URL already exists in the
    menu. If `true`, it throws an exception. Then, the function obtains the feed from
    the `rss` service and adds the item into the menu. Finally, `fetchMenu` performs
    a number of tasks. It reloads the menu from `localStorage`. That is exactly what
    one may expect of the action. But I want the function to generate the aggregative
    list as well. So, it collects the Promises of the `rss` service for every feed
    available in the menu. It applies `Promise.all` to resolve the collected set of
    Promises. The method results in the list of feeds. We need to combine all the
    items in a flat array, sort it by publication date, and limit it to the number
    we set in the `FEED_ITEM_PER_PAGE` constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we start on the Reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Reducers/app.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we imported the `handleActions` function and the `Action` interface, and
    from `redux-actions`, our interfaces and constants. We also defined the default
    state for the Reducer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the Reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`handleActions` is generic type, so we can specify the constraints for the
    `state` object it operates with. In the supplied object, we describe how every
    dispatched action shall modify the state. Thus, `toggleOpenAddFeed` (`TOGGLE_ADD_FEED`)
    toggles the `isOpenAddFeed` property. The function `addFeed` (`ADD_FEED`), in
    case of success, populates the `menu` property from the action payload and, besides,
    resets `feedError` and `isOpenAddFeed`. If the Promise was rejected, it sets `feedError`
    with an error message. The function `setFeedError` (`SET_FEED_ERROR`) simply sets
    `feedError` from the action payload. The function `removeFeed` (`REMOVE_FEED`)
    updates the menu, so here, it populates the `menu` state property with the updated
    list. The function `fetchFeed` (`FETCH_FEED`) updates the `items` property with
    just the fetched feed items. The function `fetchMenu` (`FETCH_MENU`) reloads the
    menu and generates the aggregative list, so it updates both `menu` and (RSS) `items`.
    Finally, the function `setActiveFeed` (`SET_ACTIVE_FEED`) simply saves the selected
    item URL in the state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a large scalable application, we use multiple Reducers combined together
    with the `combineReducers` function of `redux`. For this little application, only
    the Reducer will be sufficient. Yet, I suggest, we follow the practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Reducers/index.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes our state tree. So, the top level state object can be described
    now with the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Interfaces/index.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have action creators and we have Reducers and, now, we are about to make
    them available across the application. As you can remember from [Chapter 5](5fc3eae1-8e13-4273-a9a3-c79d5384db4c.xhtml),
    *Creating a Screen Capturer with NW.js, React, and Redux: Planning, Design, and
    Development*, the module `redux` provides the function `createStore`, which takes
    in combined reducers to produce the store. The module `react-redux` exports the
    provider higher-order component that accepts the store with the props and makes
    it available through `connect` across the inner component tree. The function `createStore`
    accepts middleware that is combined with the compose function of `redux`. As we
    already discussed in this application, we need asynchronous actions. Here, we
    can use the `redux-thunk` (https://www.npmjs.com/package/redux-thunk) middleware
    that allows us to write action creators, which return functions instead of plain
    objects. These functions take in references to the `dispatch` and `getState` functions
    as parameters. So, we can dispatch deferred actions. For example, we need to read
    the RSS feed by URL, so we reflect it on the application state with the following
    action creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Before making asynchronous HTTP request for the feed contents, we dispatch `fetchFeedRequest`
    and, when the request is resolved, `fetchFeedSuccess` or `fetchFeedFailure` if
    it was rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is all nice, but is too verbose. Just to get the data retrieved through
    HTTP, we write four (!) action creators. Instead we can follow an optimistic updates
    approach and go with a single action creator. That involves an additional middleware
    `redux-promise` ([https://www.npmjs.com/package/redux-promise](https://www.npmjs.com/package/redux-promise)),
    which plays nicely with `redux-actions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when combining all together, we come up with the following update for
    the entry script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/index.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the container component, we need to add two functions that inform `connect`
    of how we want to map state and action creators to the component props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Containers/App.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have mapped the state to the props simply one to one. As we have the
    store expressed as `{ state: applicationStateTree }`, we receive, in the props,
    an extra property `state` pointing at the actual state tree. As for the action
    creators, we destructure the namespace and attach every available function as
    a new property to the props. So the props of the container components can now
    be described with the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Interfaces/index.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We shall refer to the props with this type in the `React.Component` generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the container component''s properties downward by destructuring `store={this.props}`.
    Thus, every child component receives an object of the `TStore` type with the property
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Personally, I find the container to be a good place for bootstrap logic. In
    particular, I would like the load menu from `localStorage` in the start of the
    application. Actually, it can be done straight after the container component is
    mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, we call the `fetchMenu` action creator, which is now available in the props.
    This dispatches the action, the Reducer modifies the state and any component,
    and all the components reflect the state change.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming store from the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you were attentive enough, you didn''t miss that, in container''s JSX, we
    introduced a new component `ErrorAlert`. Since we have an error state (`state.feedError`),
    we need to visualize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Components/ErrorAlert.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `Dialog` and related components of the React MDL library, we describe
    a modal window, which shows up when `state.feedError` is not empty. The window
    has a button `Close`, which has a handler `onClose` subscribed for the click event.
    The handler calls the `setFeedError` action to reset `state.feedError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b95092e9-0414-4490-ad39-c35ffc9d14d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now modify the `Menu` components to display and manage the RSS menu
    from the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Components/Menu.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we take `state.menu` from the property `store` and map it to build the
    list of menu items. We represent items as links with `item.title` as contents
    and `item.id` (sha1 of URL) in `href`. We use the static method `makeClassName`
    to build the item `className`. It will be `"mdl-navigation__link"` normally and
    `"mdl-navigation__link mdl-navigation__link--current"` when the item is an active
    one. We also subscribe to the handlers for click events on the `Add`, `Remove`,
    and `Refresh` (`Autorenew` icon) buttons. The first one calls the `toggleOpenAddFeed`
    action with `true` to display the modal window for adding a feed. The second uses
    the `removeFeed` action with `activeFeedUrl` from the state. It also calls the
    `fetchMenu` action to refresh the aggregative list. The last one simply calls
    the `fetchMenu` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to create a component representing the modal window with the form
    to add a feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Components/AddFeedDialog.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `ErrorAlert`, we use `Dialog` and the related components of React
    MDL to render the modal window. The window has a form and an input represented
    with the `Textfield` component of React MDL. We make both elements available in
    the instance scope by using the `ref` attribute. We subscribe the `onSubmit` method
    for the form `submit` event. In the handler, we take the value from the input
    field by the reference (`Textfield` is referenced as `this.urlEl`; thus, internal
    input can be accessed as `this.urlEl.inputRef` according to React MDL API) and
    pass it to the private method `save`. The `save` method calls `addFeed` and `fetchMenu`
    to update the aggregative list. The window also includes the `Close` button, which
    invokes the `toggleOpenAddFeed` action with false on a click event.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s left just to update the `Feed` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Components/Feed.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we map `state.items` to render RSS items, while we use the `stripHtml`
    static method to sanitize item description. Every item is provided with the `Open`
    button that has a subscriber `onOpenLink`. This method makes visible, the `.feed-contents`
    column and changes the `src` attribute of `WebView`. This causes `WebView` to
    load the feed item URL. Why do we use `WebView` and not iFrame? Because `WebView`
    is the intended container for guest contents in both Electron and NW.js ([https://electron.atom.io/docs/api/webview-tag/](https://electron.atom.io/docs/api/webview-tag/)).
    `WebView` runs in a separate process and it doesn't have the same permission as
    your page. So, it's supposed to prevent third-party pages, and scripts that are
    affecting and harmful to your application.
  prefs: []
  type: TYPE_NORMAL
- en: We could not reference `WebView` directly because JSX doesn't have such an element
    and we had to inject it. So, we use the `componentDidMount` life-cycle method
    to reach it via DOM. What is more, we subscribe to the `new-window` event, which
    happens when the page loaded within `WebView` tries to open a new window/tab.
    We prevent that from happening, but open the requested page in the external browser
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chin-chin! It''s a working application now. So, we can build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51ef4b5f-8cb8-4b25-aa3c-51703139710e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we hit "open" link on any of RSS items the content panel slides in and it
    loads the corresponding contents into the WebView:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f936b23c-30b2-44dd-8a4f-bb1fe1474060.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating router service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything is fine, except we cannot really select a feed from the menu. We
    have the state property `activeFeedUrl`, which is already considered by the `Menu`
    component, but we have never used the `setActiveFeed` action so far to set this
    state. Nonetheless, in the `Menu` component, we provided all the items with hash
    links. To serve browser location navigation, we need a router. There are many
    implementations available as installable modules. Yet, in this simple example,
    we will create our own:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/Services/Router.ts`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: On the construction, the service takes in the store instance and assigns it
    to the private property `store`. With the `register` method, we subscribe to the
    document `hashchange` event, which triggers every time the `location.hash` changes.
    It happens, for example, when we request from the address bar something like `#some-id`.
    In the handler function, we extract SHA1 from `location.hash` (everything what
    follows `#` symbol) and use the `getFeedUrlById` method to find the associated
    feed URL (we provide items with IDs in the `add` method of the `Menu` service).
    As we have the URL, we dispatch the `setActiveFeed` action to set the `activeFeedUrl`
    state property. In addition, we dispatch `fetchFeed` to fetch the selected feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now enable the service in entry script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/ts/index.tsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by implementing the `rss` service. We used the `request`
    module to fetch feed contents. We obtained a Writable Stream from the `feedme`
    module and configured it to parse the input into our feed container object. We
    piped the `feedme` parser into the Readable Stream produced by `request`. The
    module `feedme` was missing the declaration file, so we provided it with an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created the `Menu` service, which can be used to manage and persist
    the menu of feeds. We considered actions and state structure required by the application.
    We applied the `redux-actions` module for creating actions and the Reducer. On
    the way, we examined the optimistic updates approach. While creating the store,
    we practiced two store enhancers `redux-thunk` and `redux-promise` that help to
    deal with asynchronous actions. We connected our existing components to the store
    and modified them accordingly. Besides this, we have written two new components,
    both utilizing the `Dialog` component of React MDL library. The first one displays
    an application error if it occurs. The second shows and handles the feed adding
    form. Among other things, we made the `Feed` component to load the feed item URL
    on demand. So, you learned to use the `WebView` tag for the guest contents. What
    is more, we subscribed to the new-window event to force any request for opening
    a new window from the WebView to open in an external browser. Finally, we created
    a simple router to serve navigation in the feed menu.
  prefs: []
  type: TYPE_NORMAL
