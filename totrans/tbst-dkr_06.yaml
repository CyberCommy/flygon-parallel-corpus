- en: Chapter 6. Making Containers Work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore various options of creating Docker containers
    with added modes, such as privileged mode and super privileged mode containers.
    We will also be exploring various troubleshooting issues for these modes.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a deep dive into various deployment management tools, such as **Chef**,
    **Puppet**, and **Ansible**, which provide integration with Docker in order to
    ease the pain of deploying thousands of containers for a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Privileged containers and super privileged containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting issues of working with different sets of options available for
    creating containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making Docker containers work with Puppet, Ansible, and Chef
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Puppet to create Docker containers and deploy applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Docker containers with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker and Ansible together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chef for Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Automating the Docker container''s deployment with the help of the preceding
    management tools has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: They provide you with the flexibility to reproduce the Docker-based
    application, as well as the environment required for the Docker application on
    the cloud instance or bare metal of your choice. This helps in managing and testing,
    as well as providing dev environment spin up as and when required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auditability**: These tools also provide auditability, as they provide isolation
    and help track any potential vulnerabilities and who deployed what type of container
    in which environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ubiquity**: They help you manage the full environment around containers,
    that is, manage container as well as non-container environments such as storage,
    database, and networking models around the container application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privileged containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, containers run in unprivileged mode, that is, we cannot run Docker
    daemon inside a Docker container. However, the privileged Docker container is
    given access to all the devices. Docker privileged mode allows access to all the
    devices on the host and sets system configuration in **App Armor** and **SELinux**
    to allow containers the same access as the process running on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Privileged containers](graphics/image_06_001-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Privileged container highlighted in red
  prefs: []
  type: TYPE_NORMAL
- en: 'The privileged containers can be started with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, after starting the container in privileged mode, we can list
    all the devices connected to the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker allows you to use the non-default profile by supporting the addition,
    as well as the removal of, capabilities. It is better to remove the capabilities
    that are not specifically required for the container process as this will make
    it secure.
  prefs: []
  type: TYPE_NORMAL
- en: If you are facing security threats on your host system running containers, it
    is usually advised to check if any of the containers are running with privileged
    mode, which might be affecting the security of the host system by running a security-threat
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following example, when we run the container without privileged
    mode, we are unable to change the kernel parameters, but when we run the container
    in privileged mode using the `--privileged` flag it is able to change the kernel
    parameters easily, which can cause a security vulnerability on the host system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, while auditing, you should ensure that all the containers running on the
    host system do not have privileged mode set to `true` unless required for some
    specific application running in the Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Super-privileged container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concept is introduced in one of the Project Atomic blogs, by Redhat. It
    provides the capability to use a special/privileged container as an agent to control
    the underlying host. If we ship only the application code, we risk turning the
    container into a black box. There are many benefits to the host of packaging up
    an agent as a Docker container with the right access. We can bind in devices via
    `-v /dev:/dev`, which will help to mount devices inside the container without
    needing super-privileged access.
  prefs: []
  type: TYPE_NORMAL
- en: Using `nsenter` trick, allows you to run commands in another namespace, that
    is, if Docker has its own private mount namespace, with `nsenter` and the right
    mode we can reach out to the host and mount things in its namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run in privileged mode to mount the whole host system on some path (`/media/host`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use `nsenter` inside the container; `--mount` tells `nsenter` to
    look into `/media/host` and then select the mount namespace for proc number 1\.
    Then, run the regular mount command linking the device to the mount point. As
    seen previously, this functionality allows us to mount host sockets and devices
    such as a file, and thus all can be bind mounted into a container for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Super-privileged container](graphics/image_06_002-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: nsenter running as a super-privileged container monitoring the host
  prefs: []
  type: TYPE_NORMAL
- en: Basically, super-privileged containers thus not only provide security separation,
    resource, and process isolation, but also a mechanism for shipping containers.
    Allowing software to be shipped as a container image also allows us to manage
    the host operating system and manage other container processes as explained previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider an example where, currently, we are loading the required kernel
    modules as RPM packages needed by the application that are not included in the
    host OS, and running them when the application starts. This module can be shipped
    with the help of super-privileged containers, and the benefit will be that this
    custom kernel module can work very well with the current kernel in comparison
    to shipping kernel modules as part of a privileged container. In this approach,
    it is not required to run the application as a privileged container; they can
    run separately and kernel modules can be loaded as part of a different image as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting - Docker containers at scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working in a production environment means continuous deployments. When the
    infrastructure is decentralized and cloud-based, we are frequently managing the
    deployment of identical services across identical systems. Automating the entire
    process of configuration and management of this system will be a boon. Deployment
    management tools are designed for this purpose. They provide recipes, playbooks,
    and templates to simplify orchestration and automation, to provide a standard and
    consistent deployment. In the following sections, we will be exploring three common
    configuration-automation tools: Chef, Puppet, and Ansible, and the ease they provide
    for deploying Docker containers at scale.'
  prefs: []
  type: TYPE_NORMAL
- en: Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Puppet is an automated engine that performs automated administrative tasks such
    as updating configurations, adding users, and installing packages based on user
    specifications. Puppet is a well known open source configuration management tool,
    which runs on various systems, such as Microsoft Windows, Unix, and Linux. The
    user describes the configuration using either Puppet's declarative language or
    a domain-specific language (Ruby). Puppet is model-driven and requires limited
    programming knowledge to use. Puppet provides a module for managing Docker containers.
    Puppet and Docker integration can help to achieve complex use cases with ease.
    Puppet manages files, packages, and services, while Docker encapsulates binaries
    and configuration inside a container, for deployment as an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the potential use cases of Puppet is that it can be used to provision
    the Docker containers required for a Jenkins build, and this can be done at scale
    as per the need of developers, that is, when the build gets triggered. After the
    build process is complete, binaries can be delivered to the respective owners
    and containers can be destroyed after each build. Puppet plays a very important
    role in this use case as the code has to be written once using the Puppet template,
    and it can be triggered as and when required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Puppet](graphics/image_06_003-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Integration of Puppet and Jenkins to deploy build docker containers
  prefs: []
  type: TYPE_NORMAL
- en: 'The Puppet module for managing Docker can be installed as per the `garethr-docker`
    GitHub project. The module just requires a single class to be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It sets up a Docker hosted repository and installs Docker packages and any
    required kernel extensions. The Docker daemon will bind to `unix socket /var/run/docker.sock`;
    this configuration can be changed as per the requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the default configuration the Docker can be
    changed as per the configurations provided by this module.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker image can be pulled with the help of the configurations syntax elaborated
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative to the `ubuntu:trusty docker` command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Even the configuration allows the link to Dockerfile in order to build the
    image. A rebuild of the image can also be triggered by subscribing to external
    events such as changes in the Dockerfile. We subscribe to changes in the folder
    `vkohli/Dockerfile`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the image has been created, containers can be launched with a number
    of optional parameters. We get a similar functionality with the basic `docker
    run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown here, we are also able to pass some more parameters, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pull_on_start`: Before the image is started it will be freshly pulled each
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before_stop`: The command mentioned will get executed before stopping the
    container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra_parameters`: Additional array parameters required to pass to the `docker
    run` command, such as `--restart=always`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after`: This option allows expressing containers that are required to be started
    first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other parameters which can be set are `ports`, `expose`, `env_files`, and `volumes`.
    A single value or an array of values can be passed.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The latest Docker versions have official support for networks: the module now
    exposes a type, Docker network, which can be used to manage them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As the preceding code shows, a new overlay network, `sample-net`, can be created,
    and the Docker daemon can be configured to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Docker compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compose is a tool for running multiple Docker container applications. Using
    the compose file, we can configure an application's services and start them as
    well. The `docker_compose` module type is provided, which allows Puppet to run
    the compose application with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'A compose file can be added as well, such as scaling rules of running four
    containers, as shown in the following code snippet. We can also provide additional
    parameters required for networking and other configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Puppet program is not installed on your machine it can be done in the
    following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After the Puppet module installation, the `garethr-docker` module can be installed
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be creating one sample hello world app, which will be deployed using
    Puppet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the file, we apply (run) it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can attach it to the container and see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we have shown earlier, containers can be deployed across multiple hosts and
    the entire cluster can be created with help of single Puppet configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are not able to list the Docker image even after the Puppet `apply` command
    has run successfully, check the syntax and whether the correct image name is put
    up in the sample file.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is a workflow orchestration tool that provides configuration management,
    provisioning, and application deployment with the help of one easy-to-use platform.
    Some of the powerful features of Ansible are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provisioning**: The apps are developed and deployed in different environments.
    It can be on bare metal servers, VMs, or Docker containers, locally or on the
    cloud. Ansible can help to streamline the provisioning steps with the help of
    Ansible tower and playbooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration Management**: Keeping a common configuration file is one of
    the primary use cases of Ansible, and helps manage and deploy in the required
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Deployment**: Ansible helps to manage the complete lifecycle
    of an application, from deployment to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Delivery**: Managing a continuous delivery pipeline requires resources
    from various teams. It cannot be achieved with the help of simple platform, hence,
    Ansible playbooks play a vital role in deploying and managing the applications
    throughout their lifecycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and Compliance**: Security can be an integral part from the deployment
    stage, by integrating various security policies as part of the automated process,
    rather than as an afterthought process or merging it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestration**: As explained previously, Ansible can define the way to manage
    multiple configurations, interact with them, and manage the individual pieces
    of the deployment script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating Docker with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible also provides a way to automate Docker containers; it enables us to
    channelise and operationalise the Docker container build and automate a process
    that is mostly handled manually as of now. Ansible offers the following module
    for orchestrating Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker_service**: The existing Docker compose files can be used to orchestrate
    containers on a single Docker daemon or swarm with the help of the Docker service
    part of Ansible. The Docker compose file has the same syntax as the Ansible playbook,
    as both of them are **Yaml** files and the syntax is almost the same. Ansible
    is also written in Python, and the Docker module uses the exact docker-py API
    client that docker compose uses internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a simple Docker compose file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ansible playbook for the preceding Docker compose file looks similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**docker_container**: This manages the lifecycle of the Docker container by
    providing the ability to start, stop, create, and destroy a Docker container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**docker_image**: This provides help to manage images of the Docker container
    with commands such as build, push, tag, and remove a Docker image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**docker_login**: This authenticates with the Docker hub or any Docker registry
    and provides pushing as well as pulling Docker images from the registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible Container is a tool used to orchestrate and build Docker images using
    Ansible playbooks only. Ansible Container can be installed in the following way
    by creating `virtualenv` using pip installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have issues installing Ansible Container as shown above, the installation
    can be done by downloading the source code from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ansible Container has the following commands to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ansible_container init**: This command creates a directory for Ansible files
    to get started:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**ansible-container build**: This creates images from the Ansible playbooks
    in the Ansible directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ansible-container run**: This launches the containers defined in the `container.yml`
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ansible-container push**: This pushes the project''s image to the private
    or public repository, as per the user''s choice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ansible-container shipit**: This will export the necessary playbooks and
    roles to deploy containers to a supported cloud provider'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in the example at GitHub, the Django service can be defined in the
    `container.yml` file in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Chef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chef has some important components, such as cookbook and recipes. A cookbook
    defines a scenario and contains everything; the first of them is recipes which
    is a fundamental configuration element within an organisation and it is written
    in Ruby language. It is mostly collection of resource-defined using patterns.
    Cookbooks also contain attribute values, file distribution, and templates. Chef
    allows the Docker container to be managed in a versionable, testable, and repeatable
    way. It provides you with the power to build an efficient workflow for container-based
    development and to manage the release pipeline. Chef delivery allows you to automate
    and use the scalable workflow to test, develop, and release the Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker cookbook is available on GitHub ([https://github.com/chef-cookbooks/docker](https://github.com/chef-cookbooks/docker))
    and provides custom resources to be used in the recipes. It provides various options,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker_service`: These are the composite resources used for `docker_installation`
    and `docker_service` manager'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_image`: This deals with pulling Docker images from a repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_container`: This handles all the Docker container operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_registry`: This handles all the Docker registry operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker_volume`: This manages all the volume related operations for Docker
    containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a sample Chef Docker recipe, which can be used for reference
    to deploy the containers using Chef recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we initially did a deep dive into privileged containers, which
    can get access to all the host devices as well as super-privileged containers,
    it shows the capability of the containers to manage to run a background service
    which can be used to run services in Docker containers to manage the underlying
    host. Then, we looked into Puppet, a key orchestration tool, and how it handles
    container management with help of the `garethr-docker` GitHub project. We also
    looked into Ansible and Chef, which provide similar capabilities to Puppet to
    manage Docker containers at scale. In the next chapter, we will be exploring the
    Docker networking stack.
  prefs: []
  type: TYPE_NORMAL
