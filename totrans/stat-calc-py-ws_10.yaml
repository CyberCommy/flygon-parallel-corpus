- en: 10\. Foundational Calculus with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn to calculate the derivatives of functions at
    a given value of x. You'll also learn to calculate the integrals of functions
    between given values and use derivation to solve optimization problems, such as
    maximizing profit or minimizing cost. By the end of this chapter, you will be
    able to use calculus to solve a range of mathematical problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculus has been called the science of change, since its tools were developed
    to deal with constantly changing values such as the position and velocity of planets
    and projectiles. Previously, there was no way to express this kind of change in
    a variable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The first important topic in calculus is the **derivative**. This is the rate
    of change of a function at a given point. Straight lines follow a simple pattern
    known as the slope. This is the change in the *y* value (the *rise*) over a given
    range of *x* values (the *run*):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Slope of a line'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: Slope of a line'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10.1*, the *y* value in the line increases by 2 units for every 1-unit
    increase in the *x* value, so we divide 2 by 1 to get a slope of 2.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the slope of a curve isn''t constant over the whole curve like it
    is in a line. So, as you can see in *Figure 10.2*, the rate of change of this
    function at point **A** is different from the rate of change at point **B**:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Finding the slope of a curve'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.2: Finding the slope of a curve'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: However, if we zoom in closely enough on point **A**, we see the curve is pretty
    closely approximated by a straight line.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Zooming in on the curve'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.3: Zooming in on the curve'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how derivatives work: we make the change in *x*, the *run*, small enough
    that the slope over that small part of the curve will closely approximate the
    rate of change of the curve at that point. Let''s see what it looks like in Python.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Derivative Function
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all the fear whipped up about derivatives in calculus courses, the function
    for calculating a derivative numerically is surprisingly easy.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Jupyter notebook, we''ll define a function, *f(x)*, to be the parabola
    *y = x*2:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can write a function to calculate the derivative at any point *(x, f(x))*
    using the classic formula:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Formula for calculating derivatives'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.4: Formula for calculating derivatives'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The numerator is the *rise* and the denominator is the *run*. *Δ x* means the
    *change in x*, and we''re going to make that a really small decimal by dividing
    1 by a million:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The triple-quotes ( `"""` ) shown in the code snippet below are used to denote
    the start and end points of a multi-line code comment. Comments are added into
    code to help explain specific bits of logic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can calculate the derivative of the function at any *x* value and we''ll
    get a very accurate approximation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run the preceding code, you''ll get the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These values are only a little off from their actual values (-5.999999 instead
    of -6). We can round up the printout to the nearest tenth and we''ll see the values
    more clearly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will be:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ve calculated the derivative of the function *y = x*2 at a number of points
    and we can see the pattern: the derivative is always twice the *x* value. This
    is the slope of the line that approximates the curve at that point. The awesome
    power of this method will become clear in this exercise.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.01: Finding the Derivatives of Other Functions'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use our derivative function to calculate the derivative of any function
    we can express. There''s no need to go through tedious algebraic manipulations
    when we can simply use the *tiny run* method of calculating the slope. Here, our
    function will find the derivative of some complicated-looking functions. We reused
    *f*, but you can call other functions as well. In this exercise, you will find
    the derivatives of each function at the given *x* values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Function definitions at given x values'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5: Function definitions at given x values'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to import the square root function from the `math` module:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are the preceding functions in the equations, translated into Python code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the derivative function if you haven''t already:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then print out the derivatives by calling each function and the desired *x*
    value:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You''ve just learned a very important skill: finding the derivative of a function
    (any function) at a specific *x* value. This is the reason calculus students do
    lots of hard algebra: to get the derivative as a function, and then they can plug
    in an *x* value. However, with Python, we just directly calculated the numerical
    derivative of a function without doing any algebra.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2AnlJOC](https://packt.live/2AnlJOC).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3gi4I7S](https://packt.live/3gi4I7S).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Equation of the Tangent Line
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common question in calculus is to find the equation of the line tangent to
    the curve at a given point. Remember our points **A** and **B**? The tangent lines
    are the lines that closely approximate the curve at those points, as you can see
    in *Figure 10.6*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Two tangent lines to a curve'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.6: Two tangent lines to a curve'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the information in *Figure 10.6*. The equation is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: Equation of f(x)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.7: Equation of f(x)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The *x* value at point **A** in *Figure 10.6* is -0.48 and the *x* value at
    **B** is 0.67\. The great thing about using Python to do this is it won't matter
    if the given values are whole numbers, negatives, or decimals, the computer will
    easily process the number-crunching.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the equation of a line, all we need is a slope and a point. If you
    remember your algebra, you can use this formula:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: Equation of a line'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.8: Equation of a line'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re given the function and the point (*x*0*, y*0), so from that, we can
    find the slope *m* from the derivative of the function at the given *x* value.
    The equation of the tangent line will be in the form *y = mx + b*, and the only
    thing we don''t know is *b*, the *y* intercept of the line. But if we rearrange
    the preceding equation, we can see it on the right side of the equation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Equation of line at the point'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_09.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.9: Equation of line at the point'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to find the slope *m* using the derivative function we already have,
    then plug it into *y*0 *- m x*0. To do this, perform the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define our `f(x)` function:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we''ll write a function to return the *y* intercept of a line given the
    slope and a point. Call it `point_slope`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we''ll write a function that takes the function `f` and an `x` value
    and finds the derivative of `f` at `x`, puts that into the `point_slope` function,
    and prints out the equation of the line in *y = mx + b* form. Call it `tangent_line`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We find the slope of the tangent line by taking the derivative of `f` at `x`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we use the `point_slope` function to find the *y* intercept:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, to get the equations of the lines tangent to `f` at *x = -0.48* and *x
    = 0.67*, use the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this section, we learned how to find out the equations of tangent lines at
    specific values of `x`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Integrals
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major topic of calculus is differential calculus, which means taking derivatives,
    as we've been doing so far in this chapter. The other major topic is integral
    calculus, which involves adding up areas or volumes using many small *slices*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: When calculating integrals by hand, we're taught to reverse the algebra we would
    do to find a derivative. But that algebra gets messy and, in some cases, impossible.
    The *hard* version we learned in school was Riemann sums, which required us to
    cut the area under a curve into rectangular *slices* and add them up to get the
    area. But you could never work with more than 10 slices in a realistic amount
    of time, certainly not on a test.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: However, using Python, we can work with as many slices as we want, and it saves
    us the drudgery of jumping through a lot of hoops to get an algebraic equation.
    The point of finding the algebraic equation is to obtain accurate number values,
    and if using a program will get us the most accurate numbers, then we should definitely
    take that route.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.10* shows a function and the area under it. Most commonly the area
    is bounded by the function itself, a lower *x* value **a**, an upper *x* value
    **b**, and the *x* axis.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: The area S under a curve defined by the function f(x) from
    a to b'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.10: The area S under a curve defined by the function f(x) from a
    to b'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re going to do is to slice the area **S** into rectangles of equal
    width, and since we know the height (*f(x)*), it''ll be easy to add them all up
    using Python. *Figure 10.11* shows what the situation looks like for *f(x) = x*2:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: The area S sliced into 10 rectangles of equal width'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.11: The area S sliced into 10 rectangles of equal width'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define the function and choose the number of rectangles (so that
    the value of both will be easy to change). In this instance, we will use 20 rectangles,
    which will give us a higher degree of accuracy than the 10 rectangles shown in
    *Figure 10.11*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we define our integral function. First, divide the range `(b – a)` into
    equal widths by dividing by `num`, the number of rectangles:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we''ll loop over the range, adding the area of the rectangles as we go.
    We do this with a one-line list comprehension. For every `n`, we multiply the
    base of the rectangle (`width`) by the height (*f(x)*) to get the area of each
    rectangle. Finally, we return the sum of all the areas:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is how the function call looks:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output shows how, with more rectangles, we get closer and closer to the
    actual value of the area:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It seems to be growing slowly. What if we jump ahead to 100 rectangles? That
    would create the situation shown in *Figure 10.12*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: Smaller rectangles making a better approximation of the area'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_12.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.12: Smaller rectangles making a better approximation of the area'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we change the `print` statement to give us the area of the 100
    rectangles:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output will be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'How about 1,000 rectangles, an integral that would be extremely difficult and
    time-consuming to calculate by hand? Using Python, we''ll just change `100` to
    `1000` and get a much more accurate approximation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And summing up 100,000 rectangles gets us 0.3333283333\. It seems like it's
    getting close to 0.333, or 1/3\. But adding more zeroes doesn't cost us anything,
    so feel free to increase the number of rectangles as much as required to get a
    more accurate result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Using Trapezoids
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can get better approximations sooner using trapezoids rather than rectangles.
    That way, we won''t miss as much area, as you can see in *Figure 10.13*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: Using trapezoids for better approximations to the curve'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_13.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.13: Using trapezoids for better approximations to the curve'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the formula for the trapezoidal rule:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: Formula for area of trapezoids'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_14.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.14: Formula for area of trapezoids'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The heights of the segments at the endpoints *x = a* and *x = b* are counted
    once, while all the other heights are counted twice. That's because there are
    two *heights* in the formula for the area of a trapezoid. Can you guess how to
    adapt your integral function to be trapezoidal?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we''ll run the `trap_integral` function using `5` trapezoids:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output will be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, by using only 5 trapezoids, we have reduced the error to 3%. (Remember,
    we know the true value of the area for this function is 0.333...) Using 10 trapezoids,
    we get 0.335, which has an error of 0.6%.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.02: Finding the Area Under a Curve'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll find the area under the following functions in the
    given intervals:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15: Formula for intervals'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_15.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.15: Formula for intervals'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the area. Having written the `trap_integral`
    function to use trapezoids to approximate the area under a curve, it''s easy:
    just define the function (you may have to import a `trig` function and `pi`) and
    declare the endpoints. Have it use 100 trapezoids, because that''ll be very accurate
    and quickl:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `math` functions you''ll need and define `f`, `g`, and `h`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then call the `trap_integral` function on each function between the specified
    *x* values:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By now, you can probably see the power in this numerical method. If you can
    express a function in Python, you can get a very accurate approximation of its
    integral using the function for adding up all the rectangles under the curve,
    or even more accurately, the function for adding up all the trapezoids under the
    curve.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dTUVTG](https://packt.live/3dTUVTG).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Zsfxxi](https://packt.live/2Zsfxxi).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Using Integrals to Solve Applied Problems
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a curve is rotated about the *x* or *y* axis or a line parallel to one of
    the axes, to form a 3D object, we can calculate the volume of this solid by using
    the tools of integration. For example, let''s say the parabola *y = x*2 is rotated
    around its axis of symmetry to form a paraboloid, as in *Figure 10.16*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16: A parabola rotated about the z axis'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_16.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.16: A parabola rotated about the z axis'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: We can find the volume by adding up all the *slices* of the paraboloid as you
    go up the solid. Just as before, when we were using rectangles in two dimensions,
    now we're using cylinders in three dimensions. In *Figure 10.16*, the slices are
    going up the figure and not to the right, so we can flip it in our heads and redefine
    the curve *y = x*2 as *y = sqrt(x)*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the radius of each cylinder is the *y* value, and let''s say we''re going
    from *x = 0* to *x = 1*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17: Flipping the paraboloid on its side'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.17: Flipping the paraboloid on its side'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The endpoints are still *0* and *1*, but the radius of the curve is the *y*
    value, which is *sqrt(x)*. So the volume of each circular slice is the volume
    of a cylinder (*pi * radius*2 ** height*), in this case *pi * r*2 ** thickness*,
    or *pi * sqrt(x)*2 ** width*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import `sqrt` and `pi` from the `math` module and define `f(x)`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we''ll define a function that will take the function of the paraboloid
    and the beginning and ending values of `x`. It starts off by defining the running
    volume and the number of slices we''re going to use:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then we calculate the thickness of the slices by dividing the range of *x*
    values by the number of slices:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we calculate the volume of each cylindrical slice, which is *pi * r*2 **
    width*. We add that to the running volume, and when the loop is done we return
    the final volume:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s add up all the volumes between `0` and `1`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output will be as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This value is an approximation of the volume of the bounded paraboloid. Again,
    the more slices we split the function up into, the more accurate the approximation
    to the real volume.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.03: Finding the Volume of a Solid of Revolution'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s another solid-of-revolution problem: find the volume of the solid formed
    when the following functions are rotated around the *x* axis on the given intervals.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, the green curve is *f(x) = 4 – 4x*2 and the red curve
    is *g(x) = 1-x*2. Find the volume of the solid formed when the area between the
    functions is rotated about the *x* axis.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18: A two-dimensional look at the two functions'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_18.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.18: A two-dimensional look at the two functions'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting shape of the solid would be as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19: The resulting shape is like a ring'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_19.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.19: The resulting shape is like a ring'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'This is like a problem of finding the area of a ring, as shown in the preceding
    figure. The formula is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20: Formula for area of a ring'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_20.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.20: Formula for area of a ring'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to find the volume of the solid using Python, perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `f` and `g` as usual, and a third function (`h`) to be the difference
    of the squares of `f` and `g`, from the ring area formula:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now the volume of the solid will be the sum of a given number (`num`) of cylinders
    made between the functions. We do the same thing as in our integration function.
    The radius of the cylinder is the same as the height of our rectangle when we
    were integrating:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The volume of a cylinder is *pi*r*2**h*, and we''ll add that to the running
    total volume:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here''s where we call `vol_solid` on the `h` function for *x* between `-1`
    and `1`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output will be as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Hence, the volume of the resulting solid is 50.3 cubic units. So, we have used
    our function to find the volumes of solids, and we have adapted it to find the
    volume of the solid between two curves.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2NR9Svg](https://packt.live/2NR9Svg).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3eWJaxs](https://packt.live/3eWJaxs).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Using Derivatives to Solve Optimization Problems
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In many applied problems, we''re looking for an optimal point, where the error
    is lowest, for example, or the profit is highest. The traditional way is to model
    the situation using a function, find the derivative of the function, and solve
    for the input that makes the derivative zero. This is because the derivative is
    zero at local minima and maxima, as shown in the following figure:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21: A cubic function and the points we want to find'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_21.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.21: A cubic function and the points we want to find'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The function we're given in the figure is *f(x) = x*3 *- 2.8x*2 *+ 1.2x + 0.85*.
    We're interested in finding the local maximum, point **A**, and the local minimum,
    point **B**. We would have to differentiate the function and solve the resulting
    equation by hand. But using a computer, we can simply start at a value of *x*
    on the left of the grid and take small steps, checking *f(x)* until we get a change
    in direction. To do that, we can use our derivative function to check when the
    derivative changes sign.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define `f(x)`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then we''ll define a function called `find_max_mins` to start at a minimum
    *x* value and take tiny steps, checking if the derivative equals zero or if it
    changes sign, from positive to negative or vice versa. The most mathematical way
    to do that is to check whether the previous derivative times the new one is negative:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we call the function so it''ll print out all the values at which the
    derivative changes sign:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are the local maximum and local minimum of `f` in *Figure 10.21*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.04: Find the Quickest Route'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use this procedure of finding maxima and minima to find the minimum
    value of a complicated function. In traditional calculus classes, students have
    to take the derivative algebraically, set it to zero, and then solve the resulting
    equation. We can model the situation in Python and use our derivative and the
    `find_max_min` functions to easily find the minimum value. Here''s the situation:
    a lighthouse is located 6 kilometers offshore, and a cabin on the straight shoreline
    is 9 kilometers from the point on the shore nearest the lighthouse. If you row
    at a rate of 3 km/hr and walk at a rate of 5 km/hr, where should you land your
    boat in order to get from the lighthouse to the cabin as quickly as possible?'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22: Distance of the lighthouse from the cabin'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_22.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.22: Distance of the lighthouse from the cabin'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re aiming to minimize the time it takes to make this trip, so let''s make
    a formula for time. Remember, time is distance divided by rate:![Figure 10.23:
    Formula for calculating time'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_23.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.23: Formula for calculating time'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'And there''s the function we need to minimize. The optimal *x* is going to
    be between 0 and 9 kilometers, so we''ll set those as our start and end values
    when we call our `find_max_mins` function:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output will be as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'That''s very close to 4.5 kilometers along the beach. This is a very useful
    calculation: we found the shortest distance between two points when other constraints
    have been put in place.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/31DwYxu](https://packt.live/31DwYxu).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38wNRM5](https://packt.live/38wNRM5).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.05: The Box Problem'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a classic problem given to all calculus students in which a manufacturer
    has a rectangular piece of material that they want to make into a box by cutting
    identical squares out of the corners, like in the following figure:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24: Cutting squares out of the corners of a rectangle'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_24.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.24: Cutting squares out of the corners of a rectangle'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the piece of material is 10 inches by 12 inches. Here''s the
    problem: find the size of the square to cut out in order to maximize the volume
    of the resulting box:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for the volume of the box will be length multiplied by width multiplied
    by height. In terms of *x*, the length of the square cut from the corners, the
    length of the box is *12 – 2x*, since two corners are cut out of the 12-inch sides.
    Similarly, the width of the box will be *10 – 2x*. The height, once the "flaps"
    are bent upwards, will be *x*. So, the volume is:![Figure 10.25: Formula to calculate
    the volume'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_25.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.25: Formula to calculate the volume'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you define this function in Python:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'By now, you know how to put this into your `find_max_mins` function. We only
    want to plug in values between 0 and 5 because more than 5 inches would mean we''d
    be left with no side (the width is 10 inches):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output will be as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The maximum volume is achieved by cutting squares with side length 1.81 inches.
    Here''s a plot of the volume:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.26: Plot of maximum value achieved'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_26.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.26: Plot of maximum value achieved'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the maximum volume is achieved when a square of 1.81 inches
    is cut from each side, since this is where the maximum point of the plot lies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gc11AC](https://packt.live/3gc11AC).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2NNSNmb](https://packt.live/2NNSNmb).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.06: The Optimal Can'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cylindrical can hold 355 cm3 of soda. What dimensions (radius and height)
    will minimize the cost of metal to construct the can? You can neglect the top
    of the can:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The surface area of a cylinder is the area of the bottom (a circle, so πr2)
    plus the area of its side, which is a rectangle of base *2πr* and a height of
    *h*. The volume of a cylinder is πr2h, so we put it all together:![Figure 10.27:
    Formula to calculate the volume of a cylinder'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_27.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.27: Formula to calculate the volume of a cylinder'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The volume is already set to 355\. From there, we can get an expression for
    *h* in terms of *r* and we''ll have the surface area all in terms of one variable:![Figure
    10.28: Substituting the values in the formula'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_28.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.28: Substituting the values in the formula'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s express it in Python and put it in our `find_max_mins` function:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you run the code, the output will be as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So the solution is for the radius to be around 4.8 cm and the height to be
    355/(π(4.8)2) = 4.9 cm. That means the can is about twice as wide as it is tall.
    Here''s a plot of the `surf_area` function for cans between 2 and 6 cm. You can
    see the point that minimizes the material, between 4.5 and 5 cm. We calculated
    it to be exactly 4.9 cm:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.29: Finding the minimum material needed to make a can'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_29.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.29: Finding the minimum material needed to make a can'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zu2bAK](https://packt.live/2Zu2bAK).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38lUNeE](https://packt.live/38lUNeE).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.07: Calculating the Distance between Two Moving Ships'
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At noon, ship A is 20 km north of ship B. If ship A sails south at 6 km/hr
    and ship B sails east at 8 km/hr, find the time at which the distance between
    the two ships is smallest. The following figure shows the situation:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.30: Ships A and B moving south and east'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_30.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.30: Ships A and B moving south and east'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the time:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance is velocity multiplied by time, so the distance between the two
    ships can be modeled by this equation:![Figure 10.31: Formula for calculating
    distance'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_31.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.31: Formula for calculating distance'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s express that using Python and put it into our `find_max_mins` function:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We assume the time will be between `0` and `4` hours:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output will be as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The time is therefore 1.2 hours, illustrated by the minimum point on the following
    plot. Two tenths of an hour is 12 minutes, meaning the ships will be closest at
    1:12 pm. Here''s a plot of the distance versus time:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.32: Plot of distance versus time'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_32.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.32: Plot of distance versus time'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/38k2kuF](https://packt.live/38k2kuF).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/31FK3GG](https://packt.live/31FK3GG).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.01: Maximum Circle-to-Cone Volume'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a classic optimization problem, which results in some extremely complicated
    equations to differentiate and solve if you''re doing it by hand. However, doing
    it with the help of Python will make the calculus part much easier. You start
    with a circle and cut out a sector of θ degrees. Then you attach points **A**
    and **B** in the following figure to make a cone:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.33: Circle to cone volume'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_33.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.33: Circle to cone volume'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The problem, like in the box problem, is to find the angle to cut out which
    maximizes the volume of the cone. It will require you to visualize cutting out
    the angle, attach the points to make a cone, and calculate the volume of the resulting
    cone.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps for completion:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Find the arc length of `AB`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find *h*, the height of the resulting cone.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find *r*, the radius of the base of the cone.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find an expression for the volume of the cone as a function of theta (*θ*),
    the angle cut out.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出圆锥的体积表达式作为角度切出的函数(*θ*)。
- en: Note
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 694.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第694页找到。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The tools of calculus allowed mathematicians and scientists to deal with constantly
    changing values, and those tools changed the way science is done. All of a sudden,
    we could use infinitely small steps to approximate the slope of a curve at a point,
    or infinitely small rectangles to approximate the area under a curve. These tools
    were developed hundreds of years before our modern world of computers and free
    programming software, but there's no reason to limit ourselves to the tools available
    to Newton, Leibniz, and the Bernoullis.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分的工具使数学家和科学家能够处理不断变化的值，这些工具改变了科学研究的方式。突然之间，我们可以使用无限小的步骤来近似曲线在某一点的斜率，或者使用无限小的矩形来近似曲线下的面积。这些工具是在我们现代计算机和免费编程软件的世界出现数百年之前发展起来的，但是没有理由限制自己只使用牛顿、莱布尼兹和伯努利可用的工具。
- en: In this chapter, we learned to take derivatives of functions by simply dividing
    the *rise* of the function from one point to another by the infinitesimal *run*
    between those points. We simply told Python to divide 1 by a million to give us
    that small number. Without a computer, plugging those decimals into a function
    would be a daunting task, but Python plugs a decimal into a function as easily
    as a whole number.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学会了通过简单地将函数从一个点到另一个点的*上升*除以这些点之间的无限小*运行*来对函数进行求导。我们只需告诉Python将1除以一百万，就可以得到这个小数。没有计算机的话，将这些小数插入函数将是一项艰巨的任务，但是Python可以像处理整数一样轻松地将小数插入函数。
- en: We used the derivative idea to find the highest or lowest output of a function,
    where the derivative equals zero. This enabled us to find the optimal value of
    a function that would yield the shortest distance, or the greatest volume, for
    example.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用导数的概念来找到函数的最高或最低输出，其中导数等于零。这使我们能够找到函数的最优值，例如产生最短距离或最大体积。
- en: The second most important topic in calculus is integration, and that allowed
    us to build up a complicated area or volume slice by slice using rectangles, trapezoids,
    or cylinders. Using Python, we could easily combine hundreds or thousands of slices
    to accurately approximate an area or volume.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分中第二重要的主题是积分，这使我们能够使用矩形、梯形或圆柱体逐层构建复杂的面积或体积。使用Python，我们可以轻松地组合数百或数千个切片，准确地近似一个面积或体积。
- en: We've only scratched the surface of the power that calculus and Python give
    us to work with changing values, infinitely small values, and infinitely large
    ones, too.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了微积分和Python赋予我们处理变化值、无限小值以及无限大值的能力的表面。
- en: In the next chapter, we'll expand on these basic tools to find the lengths of
    curves, the areas of surfaces, and, most usefully for machine learning, the minimum
    point on a surface.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展这些基本工具，以找到曲线的长度、表面的面积，以及对机器学习最有用的，表面上的最小点。
- en: WFT54
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: WFT54
- en: GLS48
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: GLS48
