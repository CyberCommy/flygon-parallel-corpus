- en: Chapter 2. Basic Thread Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging independent attributes in synchronized classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditions in synchronized code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing a block of code with a Lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing data access with read/write locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying Lock fairness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple conditions in a Lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common situations in concurrent programming occurs when more
    than one execution thread shares a resource. In a concurrent application, it is
    normal that multiple threads read or write the same data or have access to the
    same file or database connection. These shared resources can provoke error situations
    or data inconsistency and we have to implement mechanisms to avoid these errors.
  prefs: []
  type: TYPE_NORMAL
- en: The solution for these problems comes with the concept of **critical section**
    . A critical section is a block of code that accesses a shared resource and can't
    be executed by more than one thread at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: To help programmers to implement critical sections, Java (and almost all programming
    languages) offers **synchronization** mechanisms. When a thread wants access to
    a critical section, it uses one of those synchronization mechanisms to find out
    if there is any other thread executing the critical section. If not, the thread
    enters the critical section. Otherwise, the thread is suspended by the synchronization
    mechanism until the thread that is executing the critical section ends it. When
    more than one thread is waiting for a thread to finish the execution of a critical
    section, the JVM chooses one of them, and the rest wait for their turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter presents a number of recipes that teaches how to use the two basic
    synchronization mechanisms offered by the Java language:'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `synchronized`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Lock` interface and its implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use one of the most basic methods for synchronization
    in Java, that is, the use of the `synchronized` keyword to control the concurrent
    access to a method. Only one execution thread will access one of the methods of
    an object declared with the `synchronized` keyword. If another thread tries to
    access any method declared with the `synchronized` keyword of the same object,
    it will be suspended until the first thread finishes the execution of the method.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, every method declared with the `synchronized` keyword is a critical
    section and Java only allows the execution of one of the critical sections of
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods have a different behavior. Only one execution thread will access
    one of the static methods declared with the `synchronized` keyword, but another
    thread can access other non-static methods of an object of that class. You have
    to be very careful with this point, because two threads can access two different
    `synchronized` methods if one is static and the other one is not. If both methods
    change the same data, you can have data inconsistency errors.
  prefs: []
  type: TYPE_NORMAL
- en: To learn this concept, we will implement an example with two threads accessing
    a common object. We will have a bank account and two threads; one that transfers
    money to the account and another one that withdraws money from the account. Without
    synchronization methods, we could have incorrect results. Synchronization mechanisms
    ensures that the final balance of the account will be correct.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `Account` that will model our bank account. It has only
    one `double` attribute, named `balance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `setBalance()` and `getBalance()` methods to write and read the
    value of the attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method called `addAmount()` that increments the value of the balance
    in a certain amount that is passed to the method. Only one thread should change
    the value of the balance, so use the `synchronized` keyword to convert this method
    into a critical section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method called `subtractAmount()`that decrements the value of the
    balance in a certain amount that is passed to the method. Only one thread should
    change the value of the balance, so use the `synchronized` keyword to convert
    this method into a critical section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class that simulates an ATM. It will use the `subtractAmount()`
    method to decrement the balance of an account. This class must implement the `Runnable`
    interface to be executed as a thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Add an `Account` object to this class. Implement the constructor of the class
    that initializes that `Account` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. It makes `100` calls to the `subtractAmount()`
    method of an account to reduce the balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class that simulates a company and uses the `addAmount()` method
    of the `Account` class to increment the balance of the account. This class must
    implement the `Runnable` interface to be executed as a thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Add an `Account` object to this class. Implement the constructor of the class
    that initializes that account object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method . It makes `100` calls to the `addAmount()` method
    of an account to increment the balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the application by creating a class named `Main`
    that contains the `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Create an `Account` object and initialize its balance to `1000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Company` object and `Thread` to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Bank` object and `Thread` to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Write the initial balance to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the two threads using the `join()` method and print
    in the console the final balance of the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have developed an application that increments and decrements
    the balance of a class that simulates a bank account. The program makes `100`
    calls to the `addAmount()` method that increments the balance by `1000` in each
    call and `100` calls to the `subtractAmount()` method that decrements the balance
    by `1000` in each call. You should expect the final and initial balances to be
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: You have tried to force an error situation using a variable named `tmp` to store
    the value of the account's balance, so you read the account's balance, you increment
    the value of the temporal variable, and then you establish the value of the account's
    balance again. Additionally, you have introduced a little delay using the `sleep()`
    method of the `Thread` class to put the thread that is executing the method to
    sleep for 10 milliseconds, so if another thread executes that method, it can modify
    the account's balance provoking an error. It's the `synchronized` keyword mechanism
    that avoids those errors.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the problems of concurrent access to shared data, delete
    the `synchronized` keyword of the `addAmount()` and `subtractAmount()` methods
    and run the program. Without the `synchronized` keyword, while a thread is sleeping
    after reading the value of the account's balance, another method will read the
    account's balance, so both the methods will modify the same balance and one of
    the operations won't be reflected in the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, you can obtain inconsistent results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you run the program often, you will obtain different results. The order of
    execution of the threads is not guaranteed by the JVM. So every time you execute
    them, the threads will read and modify the account's balance in a different order,
    so the final result will be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `synchronize` keyword as you learned before and run the program
    again. As you can see in the following screenshot, now you obtain the expected
    result. If you run the program often, you will obtain the same result. Refer to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the `synchronized` keyword, we guarantee correct access to shared data
    in concurrent applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the introduction of this recipe, only a thread can access
    the methods of an object that use the `synchronized` keyword in their declaration.
    If a thread (A) is executing a `synchronized` method and another thread (B) wants
    to execute other `synchronized` methods of the same object, it will be blocked
    until the thread (A) ends. But if threadB has access to different objects of the
    same class, none of them will be blocked.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `synchronized` keyword penalizes the performance of the application, so
    you must only use it on methods that modify shared data in a concurrent environment.
    If you have multiple threads calling a `synchronized` method, only one will execute
    them at a time while the others will be waiting. If the operation doesn't use
    the `synchronized` keyword, all the threads can execute the operation at the same
    time, reducing the total execution time. If you know that a method will not be
    called by more than one thread, don't use the `synchronized` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: You can use recursive calls with `synchronized` methods. As the thread has access
    to the `synchronized` methods of an object, you can call other `synchronized`
    methods of that object, including the method that is executing. It won't have
    to get access to the `synchronized` methods again.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `synchronized` keyword to protect the access to a block of code
    instead of an entire method. We should use the `synchronized` keyword in this
    way to protect the access to the shared data, leaving the rest of operations out
    of this block, obtaining a better performance of the application. The objective
    is to have the critical section (the block of code that can be accessed only by
    one thread at a time) be as short as possible. We have used the `synchronized`
    keyword to protect the access to the instruction that updates the number of persons
    in the building, leaving out the long operations of this block that don't use
    the shared data. When you use the `synchronized` keyword in this way, you must
    pass an object reference as a parameter. Only one thread can access the `synchronized`
    code (blocks or methods) of that object. Normally, we will use the `this` keyword
    to reference the object that is executing the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Arranging independent attributes in synchronized classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the `synchronized` keyword to protect a block of code, you must
    pass an object reference as a parameter. Normally, you will use the `this` keyword
    to reference the object that executes the method, but you can use other object
    references. Normally, these objects will be created exclusively with this purpose.
    For example, if you have two independent attributes in a class shared by multiple
    threads, you must synchronize the access to each variable, but there is no problem
    if there is one thread accessing one of the attributes and another thread accessing
    the other at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to resolve this situation's programming with
    an example that simulates a cinema with two screens and two ticket offices. When
    a ticket office sells tickets, they are for one of the two cinemas, but not for
    both, so the numbers of free seats in each cinema are independent attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `Cinema` and add to it two `long` attributes named `vacanciesCinema1`
    and `vacanciesCinema2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Add to the `Cinema` class two additional `Object` attributes named `controlCinema1`
    and `controlCinema2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the `Cinema` class that initializes all the attributes
    of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `sellTickets1()` method that is called when some tickets for the
    first cinema are sold. It uses the `controlCinema1` object to control the access
    to the `synchronized` block of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `sellTickets2()` method that is called when some tickets for the
    second cinema are sold. It uses the `controlCinema2` object to control the access
    to the `synchronized` block of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `returnTickets1()` method that is called when some tickets for
    the first cinema are returned. It uses the `controlCinema1` object to control
    the access to the `synchronized` block of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `returnTickets2()` method that is called when some tickets for
    the second cinema are returned. It uses the `controlCinema2` object to control
    the access to the `synchronized` block of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Implement another two methods that return the number of vacancies in each cinema.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Implement the class `TicketOffice1` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `Cinema` object and implement the constructor of the class that initializes
    that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method that simulates some operations over the two cinemas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Implement the class `TicketOffice2` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `Cinema` object and implement the constructor of the class that initializes
    that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method that simulates some operations over the two cinemas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class called `Main` and
    add to it the `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Declare and create a `Cinema` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Create a `TicketOffice1` object and `Thread` to execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Create a `TicketOffice2` object and `Thread` to execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Start both threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the completion of the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Write to the console the vacancies of the two cinemas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use the `synchronized` keyword to protect a block of code, you use
    an object as a parameter. JVM guarantees that only one thread can have access
    to all the blocks of code protected with that object (note that we always talk
    about objects, not about classes).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we have an object that controls access to the `vacanciesCinema1`
    attribute, so only one thread can modify this attribute each time, and another
    object controls access to the `vacanciesCinema2` attribute, so only one thread
    can modify this attribute each time. But there may be two threads running simultaneously,
    one modifying the `vacancesCinema1` attribute and the other one modifying the
    `vacanciesCinema2` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this example, you can see how the final result is always the expected
    number of vacancies for each cinema. In the following screenshot, you can see
    the results of an execution of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other important uses of the `synchronize` keyword. See the *See also*
    section for other recipes that explain the use of this keyword.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using conditions in synchronized code* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditions in synchronized code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A classic problem in concurrent programming is the **producer-consumer** problem.
    We have a data buffer, one or more producers of data that save it in the buffer
    and one or more consumers of data that take it from the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: As the buffer is a shared data structure, we have to control the access to it
    using a synchronization mechanism such as the `synchronized` keyword, but we have
    more limitations. A producer can't save data in the buffer if it's full and the
    consumer can't take data from the buffer if it's empty.
  prefs: []
  type: TYPE_NORMAL
- en: For these types of situations, Java provides the `wait()`, `notify()` , and
    `notifyAll()` methods implemented in the `Object` class. A thread can call the
    `wait()` method inside a `synchronized` block of code. If it calls the `wait()`
    method outside a `synchronized` block of code, the JVM throws an `IllegalMonitorStateException`
    exception. When the thread calls the `wait()` method, the JVM puts the thread
    to sleep and releases the object that controls the `synchronized` block of code
    that it's executing and allows the other threads to execute other blocks of `synchronized`
    code protected by that object. To wake up the thread, you must call the `notify()`
    or `notifyAll()` method inside a block of code protected by the same object.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement the producer-consumer problem
    using the `synchronized` keyword and the `wait()`, `notify()`, and `notifyAll()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `EventStorage`. It has two attributes: an `int` attribute
    called `maxSize` and a `LinkedList<Date>` attribute called `storage`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the attributes of the
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `synchronized` method `set()` to store an event in the storage.
    First, check if the storage is full or not. If it's full, it calls the `wait()`
    method until the storage has empty space. At the end of the method, we call the
    `notifyAll()` method to wake up all the threads that are sleeping in the `wait()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `synchronized` method `get()` to get an event for the storage.
    First, check if the storage has events or not. If it has no events, it calls the
    `wait()` method until the storage has some events. At the end of the method, we
    call the `notifyAll()` method to wake up all the threads that are sleeping in
    the `wait()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Producer` and specify that it implements the `Runnable`
    interface. It will implement the producer of the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Declare an `EventStore` object and implement the constructor of the class that
    initializes that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method that calls `100` times the `set()` method of the
    `EventStorage` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Consumer` and specify that it implements the `Runnable`
    interface. It will implement the consumer for the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Declare an `EventStorage` object and implement the constructor of the class
    that initializes that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. It calls `100` times the `get()` method of the
    `EventStorage` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Create the main class of the example by implementing a class named `Main` and
    add to it the `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Create an `EventStorage` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Producer` object and `Thread` to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Consumer` object and `Thread` to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Start both threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to this example is the `set()` and `get()` methods of the `EventStorage`
    class. First of all, the `set()` method checks if there is free space in the storage
    attribute. If it's full, it calls the `wait()` method to wait for free space.
    When the other thread calls the `notifyAll()` method, the thread wakes up and
    checks the condition again. The `notifyAll()` method doesn't guarantee that the
    thread will wake up. This process is repeated until there is free space in the
    storage and it can generate a new event and store it.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of the `get()` method is similar. First, it checks if there are
    events on the storage. If the `EventStorage` class is empty, it calls the `wait()`
    method to wait for events. Where the other thread calls the `notifyAll()` method,
    the thread wakes up and checks the condition again until there are some events
    in the storage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to keep checking the conditions and calling the `wait()` method in
    a `while` loop. You can't continue until the condition is `true.`
  prefs: []
  type: TYPE_NORMAL
- en: If you run this example, you will see how producer and consumer are setting
    and getting the events, but the storage never has more than 10 events.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other important uses of the `synchronized` keyword. See the *See also*
    section for other recipes that explain the use of this keyword.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Arranging independent attributes in synchronized classes* recipe in [Chapter
    2](ch02.html "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing a block of code with a Lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java provides another mechanism for the synchronization of blocks of code.
    It''s a more powerful and flexible mechanism than the `synchronized` keyword.
    It''s based on the `Lock` interface and classes that implement it (as `ReentrantLock`).
    This mechanism presents some advantages, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows the structuring of synchronized blocks in a more flexible way. With
    the `synchronized` keyword, you have to get and free the control over a synchronized
    block of code in a structured way. The `Lock` interfaces allow you to get more
    complex structures to implement your critical section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Lock` interfaces provide additional functionalities over the `synchronized`
    keyword. One of the new functionalities is implemented by the `tryLock()` method.
    This method tries to get the control of the lock and if it can't, because it's
    used by other thread, it returns the lock. With the `synchronized` keyword, when
    a thread (A) tries to execute a synchronized block of code, if there is another
    thread (B) executing it, the thread (A) is suspended until the thread (B) finishes
    the execution of the synchronized block. With locks, you can execute the `tryLock()`
    method. This method returns a `Boolean` value indicating if there is another thread
    running the code protected by this lock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Lock` interfaces allow a separation of read and write operations having
    multiple readers and only one modifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Lock` interfaces offer better performance than the `synchronized` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use locks to synchronize a block of code
    and create a critical section using the `Lock` interface and the `ReentrantLock`
    class that implements it, implementing a program that simulates a print queue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `PrintQueue` that will implement the print queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `Lock` object and initialize it with a new object of the `ReentrantLock`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `printJob()` method. It will receive `Object` as a parameter and
    it will not return any value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `printJob()` method, get the control of the `Lock` object calling
    the `lock()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, include the following code to simulate the printing of a document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Finally, free the control of the `Lock` object with the `unlock()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Job` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Declare an object of the `PrintQueue` class and implement the constructor of
    the class that initializes that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. It uses the `PrintQueue` object to send a job
    to print.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Create the main class of the application by implementing a class named `Main`
    and add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Create a shared `PrintQueue` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Create 10 `Job` objects and 10 threads to run them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Start the 10 threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a part of the output of one execution,
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key to the example is in the `printJob()` method of the `PrintQueue` class.
    When we want to implement a critical section using locks and guarantee that only
    one execution thread runs a block of code, we have to create a `ReentrantLock`
    object. At the beginning of the critical section, we have to get the control of
    the lock using the `lock()` method. When a thread (A) calls this method, if no
    other thread has the control of the lock, the method gives the thread (A) the
    control of the lock and returns immediately to permit the execution of the critical
    section to this thread. Otherwise, if there is another thread (B) executing the
    critical section controlled by this lock, the `lock()` method puts the thread
    (A) to sleep until the thread (B) finishes the execution of the critical section.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the critical section, we have to use the `unlock()` method to
    free the control of the lock and allow the other threads to run this critical
    section. If you don't call the `unlock()` method at the end of the critical section,
    the other threads that are waiting for that block will be waiting forever, causing
    a deadlock situation. If you use try-catch blocks in your critical section, don't
    forget to put the sentence containing the `unlock()` method inside the `finally`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Lock` interface (and the `ReentrantLock` class) includes another method
    to get the control of the lock. It's the `tryLock()` method. The biggest difference
    with the `lock()` method is that this method, if the thread that uses it can't
    get the control of the `Lock` interface, returns immediately and doesn't put the
    thread to sleep. This method returns a `boolean` value, `true` if the thread gets
    the control of the lock, and `false` if not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take into consideration that it is the responsibility of the programmer to take
    into account the result of this method and act accordingly. If the method returns
    the `false` value, it's expected that your program doesn't execute the critical
    section. If it does, you probably will have wrong results in your application.
  prefs: []
  type: TYPE_NORMAL
- en: The `ReentrantLock` class also allows the use of recursive calls. When a thread
    has the control of a lock and makes a recursive call, it continues with the control
    of the lock, so the calling to the `lock()` method will return immediately and
    the thread will continue with the execution of the recursive call. Moreover, we
    can also call other methods.
  prefs: []
  type: TYPE_NORMAL
- en: More Info
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to be very careful with the use of `Locks` to avoid **deadlocks** .
    This situation occurs when two or more threads are blocked waiting for locks that
    never will be unlocked. For example, a thread (A) locks a Lock (X) and a thread
    (B) locks a Lock (Y). If now, the thread (A) tries to lock the Lock (Y) and the
    thread (B) simultaneously tries to lock the Lock (X), both threads will be blocked
    indefinitely, because they are waiting for locks that will never be liberated.
    Note that the problem occurs, because both threads try to get the locks in the
    opposite order. The Appendix , *Concurrent programming design*, explains some
    good tips to design concurrent applications adequately and avoid these deadlocks
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Synchronizing a method* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using multiple conditions in a Lock* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Lock* interface recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing data access with read/write locks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most significant improvements offered by locks is the `ReadWriteLock`
    interface and the `ReentrantReadWriteLock` class, the unique one that implements
    it. This class has two locks, one for read operations and one for write operations.
    There can be more than one thread using read operations simultaneously, but only
    one thread can be using write operations. When a thread is doing a write operation,
    there can't be any thread doing read operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a `ReadWriteLock` interface implementing
    a program that uses it to control the access to an object that stores the prices
    of two products.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the *Synchronizing a block of code with a Lock* recipe for a
    better understanding of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `PricesInfo` that stores information about the prices of
    two products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Declare two `double` attributes named `price1` and `price2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `ReadWriteLock` object called `lock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the three attributes.
    For the `lock` attribute, we create a new `ReentrantReadWriteLock` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getPrice1()` method that returns the value of the `price1` attribute.
    It uses the read lock to control the access to the value of this attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getPrice2()` method that returns the value of the `price2` attribute.
    It uses the read lock to control the access to the value of this attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `setPrices()` method that establishes the values of the two attributes.
    It uses the write lock to control access to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Reader` and specify that it implements the `Runnable`
    interface. This class implements a reader of the values of the `PricesInfo` class
    attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `PricesInfo` object and implement the constructor of the class that
    initializes that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method for this class. It reads 10 times the value of
    the two prices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Writer` and specify that it implements the `Runnable`
    interface. This class implements a modifier of the values of the `PricesInfo`
    class attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `PricesInfo` object and implement the constructor of the class that
    initializes that object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. It modifies three times the value of the two prices
    that are sleeping for two seconds between modifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Create a `PricesInfo` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Create five `Reader` objects and five `Threads` to execute them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Writer` object and `Thread` to execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Start the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a part of the output of one execution
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we mentioned previously, the `ReentrantReadWriteLock` class has two locks,
    one for read operations and one for write operations. The lock used in read operations
    is obtained with the `readLock()` method declared in the `ReadWriteLock` interface.
    This lock is an object that implements the `Lock` interface, so we can use the
    `lock()`, `unlock()`, and `tryLock()` methods. The lock used in write operations
    is obtained with the `writeLock()` method declared in the `ReadWriteLock` interface.
    This lock is an object that implements the `Lock` interface, so we can use the
    `lock()`, `unlock()`, and `tryLock()` methods. It is the responsibility of the
    programmer to ensure the correct use of these locks, using them with the same
    purposes for which they were designed.When you get the read lock of a `Lock` interface,
    you can't modify the value of the variable. Otherwise, you probably will have
    inconsistency data errors.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a Lock* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Lock interface* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying Lock fairness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The constructor of the `ReentrantLock` and `ReentrantReadWriteLock` classes
    admits a `boolean` parameter named `fair` that allows you to control the behavior
    of both classes. The `false` value is the default value and it's called the **non-fair
    mode** . In this mode, when there are some threads waiting for a lock (`ReentrantLock`
    or `ReentrantReadWriteLock`) and the lock has to select one of them to get the
    access to the critical section, it selects one without any criteria. The `true`
    value is called the **fair mode**. In this mode, when there are some threads waiting
    for a lock (`ReentrantLock` or `ReentrantReadWriteLock`) and the lock has to select
    one to get access to a critical section, it selects the thread that has been waiting
    for the most time. Take into account that the behavior explained previously is
    only used with the `lock()` and `unlock()` methods. As the `tryLock()` method
    doesn't put the thread to sleep if the `Lock` interface is used, the fair attribute
    doesn't affect its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will modify the example implemented in the *Synchronizing
    a block of code with a Lock* recipe to use this attribute and see the difference
    between the fair and non-fair modes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to modify the example implemented in the *Synchronizing a block
    of code with a Lock* recipe, so read that recipe to implement this example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the example explained in the *Synchronizing a block of code with a
    Lock* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `PrintQueue` class, modify the construction of the `Lock` object. The
    new instruction is given as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Modify the `printJob()` method. Separate the simulation of printing in two blocks
    of code, freeing the lock between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify in the `Main` class the block of code that starts the threads. The new
    block of code is given as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following screenshot you can see a part of the output of one execution
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All threads are created with a difference of 0.1 seconds. The first thread that
    requests the control of the lock is **Thread 0**, then **Thread 1**, and so on.
    While **Thread 0** is running the first block of code protected by the lock, we
    have nine threads waiting to execute that block of code. When **Thread 0** releases
    the lock, immediately, it requests the lock again, so we have 10 threads trying
    to get the lock. As the fair mode is enabled, the `Lock` interface will choose
    **Thread 1**, so it's the thread that has been waiting for more time for the lock.
    Then, it chooses **Thread 2**, then, **Thread 3**, and so on. Until all the threads
    have passed the first block protected by the lock, none of them will execute the
    second block protected by the lock.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the threads have executed the first block of code protected by the
    lock, it's the turn of **Thread 0** again. Then, it's the turn of **Thread 1**,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the difference with the non-fair mode, change the parameter passed to
    the lock constructor and put the `false` value. In the following screenshot, you
    can see the result of one execution of the modified example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the threads are executed in the order that have been created but
    each thread executes the two protected blocks of code. However, this behavior
    is not guaranteed because, as explained earlier, the lock could choose any thread
    to give it access to the protected code. The JVM does not guarantee, in this case,
    the order of execution of the threads.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read/write locks also have the fair parameter in their constructor. The behaviour
    of this parameter in this kind of lock is the same as we explained in the introduction
    of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a Lock* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Synchronizing data access with read/write locks* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing a custom Lock class* recipe in [Chapter 7](ch07.html "Chapter 7. Customizing
    Concurrency Classes"), *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple conditions in a Lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lock may be associated with one or more conditions. These conditions are declared
    in the `Condition` interface. The purpose of these conditions is to allow threads
    to have control of a lock and check whether a condition is `true` or not and,
    if it's `false`, be suspended until another thread wakes them up. The `Condition`
    interface provides the mechanisms to suspend a thread and to wake up a suspended
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: A classic problem in concurrent programming is the **producer-consumer** problem.
    We have a data buffer, one or more **producers** of data that save it in the buffer,
    and one or more **consumers** of data that take it from the buffer as explained
    earlier in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement the producer-consumer problem
    using locks and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the *Synchronizing a block of code with a Lock* recipe for a
    better understanding of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s implement a class that will simulate a text file. Create a class
    named `FileMock` with two attributes: a `String` array named `content` and `int`
    named `index`. They will store the content of the file and the line of the simulated
    file that will be retrieved.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the content of the file
    with random characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Implement the method `hasMoreLines()` that returns `true` if the file has more
    lines to process or `false` if we have achieved the end of the simulated file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Implement the method `getLine()`that returns the line determined by the index
    attribute and increases its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement a class named `Buffer` that will implement the buffer shared
    by producers and consumers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has six attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `LinkedList<String>` attribute named `buffer` that will store the shared data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `int` type named `maxSize` that stores the length of the buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ReentrantLock` object called `lock` that controls the access to the blocks
    of code that modify the buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two `Condition` attributes named `lines` and `space`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `boolean` type called `pendingLines` that will indicate if there are lines
    in the buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class. It initializes all the attributes described
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `insert()` method. It receives `String` as a parameter and tries
    to store it in the buffer. First, it gets the control of the lock. When it has
    it, it then checks if there is empty space in the buffer. If the buffer is full,
    it calls the `await()` method in the `space` condition to wait for free space.
    The thread will be woken up when another thread calls the`signal()` or `signalAll()`
    method in the space `Condition`. When that happens, the thread stores the line
    in the buffer and calls the `signallAll()` method over the `lines` condition.
    As we'll see in a moment, this condition will wake up all the threads that were
    waiting for lines in the buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `get()` method. It returns the first string stored in the buffer.
    First, it gets the control of the lock. When it has it, it checks if there are
    lines in the buffer. If the buffer is empty, it calls the `await()` method in
    the `lines` condition to wait for lines in the buffer. This thread will be woken
    up when another thread calls the `signal()` or `signalAll()` method in the lines
    condition. When it happens, the method gets the first line in the buffer, calls
    the `signalAll()` method over the space condition and returns `String`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `setPendingLines()` method that establishes the value of the attribute
    `pendingLines`. It will be called by the producer when it has no more lines to
    produce.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `hasPendingLines()` method. It returns `true` if there are more
    lines to be processed, or `false` otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: It's now the turn of the producer. Implement a class named `Producer` and specify
    that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two attributes: one object of the `FileMock` class and another object
    of the `Buffer` class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes both attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method that reads all the lines created in the `FileMock`
    object and uses the `insert()` method to store them in the buffer. Once it finishes,
    use the `setPendingLines()` method to alert the buffer that it's not going to
    generate more lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Next is the consumer's turn. Implement a class named `Consumer` and specify
    that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `Buffer` object and implement the constructor of the class that initializes
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. While the buffer has pending lines, it tries to
    get one and process it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Implement the auxiliary method `processLine()`. It only sleeps for 10 milliseconds
    to simulate some kind of processing with the line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Create a `FileMock` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Buffer` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Producer` object and `Thread` to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Create three `Consumer` objects and three threads to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Start the producer and the three consumers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the `Condition` objects are associated with a lock and are created using
    the `newCondition()` method declared in the `Lock` interface. Before we can do
    any operation with a condition, you have to have the control of the lock associated
    with the condition, so the operations with conditions must be in a block of code
    that begins with a call to a `lock()` method of a `Lock` object and ends with
    an `unlock()` method of the same `Lock` object.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread calls the `await()` method of a condition, it automatically frees
    the control of the lock, so that another thread can get it and begin the execution
    of the same, or another critical section protected by that lock.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a thread calls the `signal()` or `signallAll()` methods of a condition,
    one or all of the threads that were waiting for that condition are woken up, but
    this doesn't guarantee that the condition that made them sleep is now `true`,
    so you must put the `await()` calls inside a `while` loop. You can't leave that
    loop until the condition is `true`. While the condition is `false`, you must call
    `await()` again.
  prefs: []
  type: TYPE_NORMAL
- en: You must be careful with the use of `await()` and `signal()`. If you call the
    `await()` method in a condition and never call the `signal()` method in this condition,
    the thread will be sleeping forever.
  prefs: []
  type: TYPE_NORMAL
- en: A thread can be interrupted while it is sleeping, after a call to the `await()`
    method, so you have to process the `InterruptedException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Condition` interface has other versions of the `await()` method, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`await(long time, TimeUnit unit)`: The thread will be sleeping until:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's interrupted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another thread calls the `singal()` or `signalAll()` methods in the condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified time passes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitUninterruptibly()`: The thread will be sleeping until another thread
    calls the `signal()` or `signalAll()` methods, which can''t be interrupted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitUntil(Date date)`: The thread will be sleeping until:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's interrupted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another thread calls the `singal()` or `signalAll()` methods in the condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specified date arrives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use conditions with the `ReadLock` and `WriteLock` locks of a read/write
    lock.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a Lock* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Synchronizing data access with read/write locks* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
