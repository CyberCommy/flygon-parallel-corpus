- en: Designing Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents the core design concepts of various algorithms. It discusses
    the strengths and weaknesses of various techniques for designing algorithms. By
    understanding these concepts, you will learn how to design efficient algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts by discussing the different choices available to you when
    designing algorithms. Then, it discusses the importance of characterizing the
    particular problem that we are trying to solve. Next, it uses the famous **Traveling
    Salesman Problem** (**TSP**) as a use case and applies the different design techniques
    that we will be presenting. Then, it introduces linear programming and discusses
    its applications. Finally, it presents how linear programming can be used to solve
    a real-world problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand the basic concepts
    of designing an efficient algorithm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The following concepts are discussed in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The various approaches to designing an algorithm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the trade-offs involved in choosing the correct design for an
    algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices of formulating a real-world problem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving a real-world optimization problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first look at the basic concepts of designing an algorithm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the basic concepts of designing an algorithm
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An algorithm, according to the American Heritage Dictionary, is defined as
    follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '"A finite set of unambiguous instructions that given some set of initial conditions
    can be performed in a prescribed sequence to achieve a certain goal and that has
    a recognizable set of end conditions."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Designing an algorithm is about coming up with this "*finite set of unambiguous
    instructions*" in the most efficient way to "*achieve a certain goal*." For a
    complex real-world problem, designing an algorithm is a tedious task. To come
    up with a good design, we first need to fully understand the problem we are trying
    to solve. We start by figuring out *what* needs to be done (that is, understanding
    the requirements) before looking into *how* it will be done (that is, designing
    the algorithm). Understanding the problem includes addressing both the functional
    and non-functional requirements of the problem. Let''s look at what these are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Functional requirements formally specify the input and output interfaces of
    the problem that we want to solve and the functions associated with them. Functional
    requirements help us understand data processing, data manipulation, and the calculations
    that need to be implemented to generate the result.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-functional requirements set the expectations about the performance and security
    aspects of the algorithm.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that designing an algorithm is about addressing both the functional and
    non-functional requirements in the best possible way under the given set of circumstances
    and keeping in mind the set of resources available to run the designed algorithm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'To come up with a good response that can meet the functional and non-functional
    requirements, our design should respect the following three concerns, as discussed
    in Chapter 1, *Overview of Algorithms*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Concern 1: Will the designed algorithm produce the result we expect?'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concern 2: Is this the optimal way to get these results?'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concern 3: How is the algorithm going to perform on larger datasets?'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, let's look at these concerns one by one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Concern 1 – Will the designed algorithm produce the result we expect?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An algorithm is a mathematical solution to a real-world problem. To be useful,
    it should produce accurate results. How to verify the correctness of an algorithm
    should not be an afterthought; instead, it should be baked into the design of
    the algorithm. Before strategizing how to verify an algorithm, we need to think
    about the following two aspects:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the truth**: To verify the algorithm, we need some known correct
    results for a given set of inputs. These known correct results are called the
    **truths**, in the context of the problem we are trying to solve. The **truth**
    is important as it is used as a reference when we iteratively work on evolving
    our algorithm toward a better solution.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义真相**：为了验证算法，我们需要一些已知的给定输入的正确结果。在我们试图解决的问题的上下文中，这些已知的正确结果被称为**真相**。真相很重要，因为在我们迭代地努力将算法演变为更好的解决方案时，它被用作参考。'
- en: '**Choosing metrics**: We also need to think about how are we going to quantify
    the deviation from the defined truth. Choosing the correct metrics will help us
    to accurately quantify the quality of our algorithm.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择度量标准**：我们还需要考虑如何量化与定义真相的偏差。选择正确的度量标准将帮助我们准确量化算法的质量。'
- en: For example, for machine learning algorithms, we can use existing labeled data
    as the truth. We can choose one or more metrics, such as accuracy, recall, or
    precision, to quantify deviation from the truth. It is important to note that,
    in some use cases, the correct output is not a single value. Instead, the correct
    output is defined as the range for a given set of inputs. As we work on the design
    and development of our algorithm, the objective will be to iteratively improve
    the algorithm until it is within the range specified in the requirements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于机器学习算法，我们可以使用现有的标记数据作为真相。我们可以选择一个或多个度量标准，如准确度、召回率或精确度，来量化与真相的偏差。需要注意的是，在某些用例中，正确的输出不是一个单一的值。相反，正确的输出被定义为给定一组输入的范围。在设计和开发算法时，目标是迭代改进算法，直到它在需求中指定的范围内。
- en: Concern 2 – Is this the optimal way to get these results?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点2 - 这是获得这些结果的最佳方式吗？
- en: 'The second concern is about finding the answer to the following question:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关注点是找到以下问题的答案：
- en: <q>Is this the optimal solution and can we verify that no other solution exists
    for this problem that is better than our solution?</q>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <q>这是最佳解决方案吗？我们能验证不存在比我们的解决方案更好的解决方案吗？</q>
- en: 'At first glance, this question looks quite simple to answer. However, for a
    certain class of algorithms, researchers have unsuccessfully spent decades verifying
    whether a particular solution generated by an algorithm is also the best and that
    no other solution exists that can give better results. So, it becomes important
    that we first understand the problem, its requirements, and the resources available
    to run the algorithm. We need to acknowledge the following statement:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个问题看起来很简单。然而，对于某类算法，研究人员已经花费了数十年的时间，试图验证算法生成的特定解决方案是否也是最佳解决方案，以及是否存在其他解决方案可以给出更好的结果。因此，首先了解问题、其需求和可用于运行算法的资源是很重要的。我们需要承认以下声明：
- en: <q>Should we aim to find the optimal solution for this problem? Finding and
    verifying the optimal solution is so time-consuming and complex that a workable
    solution based on heuristics is our best bet.</q>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <q>我们应该努力寻找这个问题的最佳解决方案吗？找到并验证最佳解决方案是如此耗时和复杂，以至于基于启发式的可行解决方案是我们最好的选择。</q>
- en: So, understanding the problem and its complexities is important and helps us
    estimate the resource requirements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解问题及其复杂性是重要的，有助于我们估计资源需求。
- en: 'Before we start looking deeper into this, first, let''s define a couple of
    terms here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究之前，首先让我们定义这里的一些术语：
- en: '**Polynomial algorithm:** If an algorithm has a time complexity of *O(n**^k*
    *)*, we call it a polynomial algorithm, where *k* is a constant.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式算法：如果一个算法的时间复杂度为*O(n**^k* *)*，我们称之为多项式算法，其中*k*是一个常数。
- en: '**Certificate:** A proposed candidate solution produced at the end of an iteration
    is called a **certificate**. As we progress iteratively in solving a particular
    problem, we typically generate a series of certificates. If the solution is moving
    toward convergence, each generated certificate will be better than the previous
    one. At some point, when our certificate meets the requirements, we will choose
    that certificate as the final solution.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书**：在迭代结束时产生的候选解决方案被称为**证书**。当我们迭代解决特定问题时，我们通常会生成一系列证书。如果解决方案朝着收敛前进，每个生成的证书都会比前一个更好。在某个时刻，当我们的证书满足要求时，我们将选择该证书作为最终解决方案。'
- en: 'In Chapter 1, *Overview of Algorithms*, we introduced Big O notation, which
    can be used to analyze the time complexity of an algorithm. In the context of
    analyzing time complexity, we are looking at the following different time intervals:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章《算法概述》中，我们介绍了大O符号，它可以用来分析算法的时间复杂度。在分析时间复杂度的上下文中，我们关注以下不同的时间间隔：
- en: The time it takes for an algorithm to produce a proposed solution, called a
    certificate (*t[r]*)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法产生提议解决方案（证书）所需的时间，称为证书(*t[r]*)
- en: The time it takes to verify the proposed solution (certificate), *t[s]*
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证提议解决方案（证书）所需的时间，*t[s]*
- en: Characterizing the complexity of the problem
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表征问题的复杂性
- en: 'Over the years, the research community has divided problems into various categories
    according to their complexity. Before we attempt to design the solution to a problem,
    it makes sense to first try to characterize it. Generally, there are three types
    of problems:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，研究界根据问题的复杂性将问题分为各种类别。在尝试设计解决方案之前，首先尝试对问题进行表征是有意义的。一般来说，问题有三种类型：
- en: 'Type 1: Problems for which we can guarantee that a polynomial algorithm exists
    that can be used to solve them'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型1：我们可以保证存在一个多项式算法来解决这些问题
- en: 'Type 2: Problems for which we can prove that they cannot be solved by a polynomial
    algorithm'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型2：我们可以证明它们不能通过多项式算法解决的问题
- en: 'Type 3: Problems for which we are unable to find a polynomial algorithm to
    solve them, but we are also unable to prove that a polynomial solution for those
    problems is impossible to find'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型3：我们无法找到多项式算法来解决这些问题，但也无法证明这些问题不存在多项式解决方案
- en: 'Let''s look at the various classes of problems:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-Deterministic Polynomial** (**NP**): For a problem to be an NP problem,
    it has to meet the following condition:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is guaranteed that there is a polynomial algorithm that can be used to verify
    that the candidate solution (certificate) is optimal.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polynominal** (**P**): These are types of problems that can be thought of
    as a subset of NP. In addition to meeting the condition of an NP problem, P problems
    need to meet another condition:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is guaranteed that there is at least one polynomial algorithm that can be
    used to solve them.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between **P** and **NP** problems is shown in the following
    diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/efff141e-c598-4dfc-9b52-650de9d52230.png)If a problem is NP, is
    it P as well? This is one of the greatest problems in computer science that remains
    unresolved. Millennium Prize Problems, selected by the Clay Mathematics Institute,
    has announced a 1 million dollar prize for the solution to this problem as it
    will have a major impact on fields such as AI, cryptography, and theoretical computer
    sciences:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99b84b3d-f132-4aad-b80d-084d61c79810.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Let''s continue the list of various classes of problems:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**NP-complete**: The NP-complete category contains the hardest problems of
    all NP problems. An NP-complete problem meets the following two conditions:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no known polynomial algorithms to generate a certificate.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are known polynomial algorithms to verify that the proposed certificate
    is optimal.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NP-hard**: The NP-hard category contains problems that are at least as hard
    as any problem in the NP category, but that do not themselves need to be in the
    NP category.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s try to draw a diagram to illustrate these different classes of
    problems:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7f1eae28-466f-4476-b8bf-d8e6389b0f62.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Note that it is still to be proven by the research community whether P = NP.
    Although this has not yet been proven, it is extremely likely that P ≠ NP. In
    that case, no polynomial solution exists for NP-complete problems. Note that the
    preceding diagram is based on this assumption.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Concern 3 – How is the algorithm going to perform on larger datasets?
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An algorithm processes data in a defined way to produce a result. Generally,
    as the size of the data increases, it takes more and more time to process the
    data and calculate the required results. The term *big data* is sometimes used
    to roughly identify datasets that are expected to be challenging for the infrastructure
    and algorithms to work with due to their volume, variety, and velocity. A well-designed
    algorithm should be scalable, which means that it should be designed in a way
    that means, wherever possible, it should be able to run efficiently, making use
    of the available resources and generating the correct results in a reasonable
    timeframe. The design of the algorithm becomes even more important when dealing
    with big data. To quantify the scalability of an algorithm, we need to keep the
    following two aspects in mind:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**The increase in resource requirements as the input data is increased**: Estimating
    a requirement such as this is called space complexity analysis.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The increase in the time taken to run as the input data is increased**: Estimating
    this is called time complexity analysis.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we are living in an era that is defined by data explosion. The term
    *big data* has become mainstream as it captures the size and complexity of the
    data that is typically required to be processed by modern algorithms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: While in the development-and-testing phase, many algorithms use only a small
    sample of data. When designing an algorithm, it is important to look into the
    scalability aspect of the algorithms. In particular, it is important to carefully
    analyze (that is, test or predict) the effect of an algorithm's performance as
    datasets increase in size.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Understanding algorithmic strategies
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-designed algorithm tries to optimize the use of the available resources
    most efficiently by dividing the problem into smaller subproblems wherever possible.
    There are different algorithmic strategies for designing algorithms. An algorithmic
    strategy deals with the following three aspects of an algorithm list containing
    aspects of the missing algorithm.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'We will present the following three strategies in this section:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The divide-and-conquer strategy
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dynamic programming strategy
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The greedy algorithm strategy
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the divide-and-conquer strategy
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strategies is to find a way to divide a larger problem into smaller
    problems that can be solved independently of each other. The subsolutions produced
    by these subproblems are then combined to generate the overall solution of the
    problem. This is called the **divide-and-conquer** strategy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, if we are designing a solution for a problem (*P*) with *n*
    inputs that needs to process dataset *d*, we split the problem into *k* subproblems,
    *P[1]* to *P[k]*. Each of the subproblems will process a partition of the dataset,
    *d*. Typically, we will have *P**[1]* to *P**[k]* processing *d[1]* to *d[k]*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a practical example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Practical example – divide-and-conquer applied to Apache Spark
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Spark is an open source framework that is used to solve complex distributed
    problems. It implements a divide-and-conquer strategy to solve problems. To process
    a problem, it divides the problem into various subproblems and processes them
    independently of each other. We will demonstrate this by using a simple example
    of counting words from a list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have the following list of words:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`wordsList = [python, java, ottawa, news, java, ottawa]`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: We want to calculate the frequency of each word in this list. For that, we will
    apply the divide-and-conquer strategy to solve this problem in an efficient way.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of divide-and-conquer is shown in the following diagram:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0803c96a-de47-4fda-aa52-9f6ad7e7d81a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows the following phases into which a problem is divided:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Splitting**: The input data is divided into partitions that can be processed
    independently of each other. This is called splitting. We have three *splits*
    in the preceding figure.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mapping**: Any operation that can run independently on a split is called
    a map. In the preceding diagram, the map operation coverts each of the words in
    the partition to key-value pairs. Corresponding to the three splits, there are
    three mappers that are run in parallel.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shuffling**: Shuffling is the process of bringing similar keys together.
    Once the similar keys are brought together, aggregation functions can be run on
    their values. Note that *shuffling* is a performance-intensive operation as similar
    keys need to be brought together that can be originally distributed across the
    network.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reducing**: Running an aggregation function on the values of similar keys
    is called reducing. In the preceding diagram, we have to count the number of words.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see how we can write the code to implement this. To demonstrate the
    divide-and-conquer strategy, we need a distributed computing framework. We will
    run Python running on Apache Spark for this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in order to use Apache Spark, we will create a runtime context of Apache
    Spark:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s create a sample list containing some words. We will convert this
    list into Spark''s native distributed data structure, called a **Resilient Distributed
    Dataset** (**RDD**):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s use a `map` function to convert the words into a key-value pair:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b3cc81ba-f3bf-4ed1-8032-c0ff42b7bd35.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use the `reduce` function to aggregate and get the final result:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a2340460-95d3-45ef-818e-095913d82680.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: This shows how we can use the divide-and-conquer strategy to count the number
    of words.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Modern cloud computing infrastructures, such as Microsoft Azure, Amazon Web
    Services, and Google Cloud, achieve scalability by implementing a divide-and-conquer
    strategy either directly or indirectly behind the scenes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现代云计算基础设施，如Microsoft Azure、Amazon Web Services和Google Cloud，通过直接或间接地实现分而治之策略来实现可扩展性。
- en: Understanding the dynamic programming strategy
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动态规划策略
- en: Dynamic programming was a strategy proposed in the 1950s by Richard Bellman
    to optimize certain classes of algorithms. It is based on an intelligent caching
    mechanism that tries to reuse heavy computations. This intelligent caching mechanism
    is called **memorization**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划是理查德·贝尔曼在1950年代提出的一种优化某些类别算法的策略。它基于一种智能缓存机制，试图重复使用繁重的计算。这种智能缓存机制称为**记忆化**。
- en: Dynamic programming gives good performance benefits when the problem we are
    trying to solve can be divided into subproblems. The subproblems partly involve
    a calculation that is repeated in those subproblems. The idea is to perform that
    calculation once (which is the time-consuming step) and then reuse it on the other
    subproblems. This is achieved using memorization, which is especially useful in
    solving recursive problems that may evaluate the same inputs multiple times.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图解决的问题可以分解为子问题时，动态规划可以带来良好的性能优势。这些子问题部分涉及在这些子问题中重复的计算。其思想是执行该计算一次（这是耗时的步骤），然后在其他子问题中重复使用它。这是通过记忆化实现的，特别适用于解决可能多次评估相同输入的递归问题。
- en: Understanding greedy algorithms
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解贪婪算法
- en: 'Before we dive deep into this section, let''s first define two terms:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究本节内容之前，让我们先定义两个术语：
- en: '**Algorithmic overheads**: Whenever we try to find the optimal solution to
    a certain problem, it takes some time. As the problems that we are trying to optimize
    become more and more complex, the time it takes to find the optimal solution also
    increases. We represent algorithmic overheads with *Ω[i]*.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法开销**：每当我们尝试找到某个问题的最优解时，都需要一些时间。随着我们试图优化的问题变得越来越复杂，找到最优解所需的时间也会增加。我们用*Ω[i]*表示算法开销。'
- en: '**Delta from optimal**: For a given optimization problem, there exists an optimal
    solution. Typically, we iteratively optimize the solution using our chosen algorithm.
    For a given problem, there always exists a perfect solution, called the **optimal
    solution**, to the current problem. As discussed, based on the classification
    of the problem we are trying to solve, it''s possible for the optimal solution
    to be unknown or that it would take an unreasonable amount of time to calculate
    and verify it. Assuming that the optimal solution is known, the difference from
    optimal for the current solution in the *i**^(th)* iteration is called **delta
    from optimal** and is represented by *Δ**[i]*.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与最优解的差异**：对于给定的优化问题，存在一个最优解。通常，我们使用我们选择的算法迭代优化解决方案。对于给定的问题，总是存在一个完美的解决方案，称为**最优解**。正如讨论的那样，根据我们试图解决的问题的分类，最优解可能是未知的，或者计算和验证它可能需要不合理的时间。假设最优解已知，则在第*i*次迭代中，当前解决方案与最优解的差异称为**与最优解的差异**，用*Δ[i]*表示。'
- en: 'For complex problems, we have two possible strategies:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂问题，我们有两种可能的策略：
- en: '**Strategy 1:** Spend more time finding a solution nearest to optimal so that
    *Δ*[*i*] is as small as possible.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略1：**花费更多时间找到最接近最优解的解决方案，使*Δ*[*i*]尽可能小。'
- en: '**Strategy 2:** Minimize the algorithmic overhead, *Ω*[*i*] . Use the quick-and-dirty
    approach and just use a workable solution.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略2：**最小化算法开销*Ω*[*i*]。使用快速且简单的方法，只使用可行的解决方案。'
- en: Greedy algorithms are based on strategy 2, where we do not make an effort to
    find a global optimal and choose to minimize the algorithm overheads instead.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪算法是基于策略2的，我们不会努力寻找全局最优解，而是选择最小化算法开销。
- en: Using a greedy algorithm is a quick and simple strategy of finding the global
    optimal value for multistage problems. It is based on selecting the local optimal
    values without making an effort to verify whether local optimal values are globally
    optimal as well. Generally, unless we are lucky, a greedy algorithm will not result
    in a value that can be considered globally optimal. However, finding a global
    optimal value is a time-consuming task. Hence, the greedy algorithm is fast compared
    to the divide-and-conquer and dynamic programming algorithms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用贪婪算法是一种快速简单的策略，用于找到多阶段问题的全局最优值。它基于选择局部最优值，而不努力验证局部最优值是否也是全局最优值。一般来说，除非我们很幸运，贪婪算法不会得到可以被认为是全局最优的值。然而，找到全局最优值是一项耗时的任务。因此，与分而治之和动态规划算法相比，贪婪算法更快。
- en: 'Generally, a greedy algorithm is defined as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，贪婪算法定义如下：
- en: Let's assume that we have a dataset, *D*. In this dataset, choose an element,
    *k*.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个数据集*D*。在这个数据集中，选择一个元素*k*。
- en: Let's assume the candidate solution or certificate is *S*. Consider including
    *k* in the solution, *S*. If it can be included, then the solution is *Union(S,
    e)*.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设候选解或证书是*S*。考虑将*k*包含在解决方案*S*中。如果可以包含，那么解决方案就是*Union(S, e)*。
- en: Repeat the process until *S* is filled up or *D* is exhausted.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这个过程，直到*S*填满或*D*用尽。
- en: Practical application – solving the TSP
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用-解决TSP
- en: Let's first look at the problem statement for the TSP, which is a well-known
    problem that was coined as a challenge in the 1930s. The TSP is an NP-hard problem.
    To start with, we can randomly generate a tour that meets the condition of visiting
    all of the cities without caring about the optimal solution. Then, we can work
    to improve the solution with each iteration. Each tour generated in an iteration
    is called a candidate solution (also called a certificate). Proving that a certificate
    is optimal requires an exponentially increasing amount of time. Instead, different
    heuristics-based solutions are used that generate tours that are near to optimal
    but are not optimal.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下TSP的问题陈述，这是一个在上世纪30年代被提出的众所周知的问题。TSP是一个NP难问题。首先，我们可以随机生成一个满足访问所有城市条件的旅行路线，而不考虑最优解。然后，我们可以努力改进每次迭代的解决方案。迭代中生成的每个旅行路线称为候选解（也称为证书）。证明证书是最优的需要指数级增加的时间。相反，使用基于不同启发式的解决方案，这些解决方案生成的旅行路线接近于最优但并非最优。
- en: 'A traveling salesman needs to visit a given list of cities to get their job
    done:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商需要访问给定的城市列表才能完成他们的工作：
- en: '| INPUT | A list of *n* cities (denoted as *V*) and the distances between each
    pair of cities, *d ij (1 ≤ i, j ≤ n)* |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 一个包含*n*个城市（表示为*V*）和每对城市之间距离的列表，*d ij (1 ≤ i, j ≤ n)* |'
- en: '| OUTPUT | The shortest tour that visits each city exactly once and returns
    to the initial city |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 输出 | 访问每个城市一次并返回到初始城市的最短旅行路线 |'
- en: 'Note the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The distances between the cities on the list are known,
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中的城市之间的距离是已知的，
- en: Each city in the given list needs to be visited *exactly* once.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定列表中的每个城市都需要被访问*一次*。
- en: Can we generate the travel plan for the salesman? What will be the optimal solution
    that can minimize the total distance traveled by the traveling salesman?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能为销售员生成旅行计划吗？什么是可以最小化旅行商所走总距离的最优解？
- en: 'The following are the distances between five Canadian cities that we can use
    for the TSP:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是五个加拿大城市之间的距离，我们可以用于TSP：
- en: '|  | **Ottawa** | **Montreal** | **Kingston** | **Toronto** | **Sudbury** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  | **Ottawa** | **Montreal** | **Kingston** | **Toronto** | **Sudbury** |'
- en: '| **Ottawa** | - | 199 | 196 | 450 | 484 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **Ottawa** | - | 199 | 196 | 450 | 484 |'
- en: '| **Montreal** | 199 | - | 287 | 542 | 680 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **Montreal** | 199 | - | 287 | 542 | 680 |'
- en: '| **Kingston** | 196 | 287 | - | 263 | 634 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **Kingston** | 196 | 287 | - | 263 | 634 |'
- en: '| **Toronto** | 450 | 542 | 263 | - | 400 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **Toronto** | 450 | 542 | 263 | - | 400 |'
- en: '| **Sudbury** | 484 | 680 | 634 | 400 | - |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **Sudbury** | 484 | 680 | 634 | 400 | - |'
- en: Note that the objective is to get a tour that starts and ends in the initial
    city. For example, a typical tour can be Ottawa–Sudbury–Montreal–Kingston–Toronto–Ottawa
    with a cost of *484 + 680 + 287 + 263 + 450 = 2,164*. Is this the tour in which
    the salesman has to travel the minimum distance? What will be the optimal solution
    that can minimize the total distance traveled by the traveling salesman? I will
    leave this up to you to think about and calculate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目标是获得一个从初始城市出发并返回到初始城市的旅行路线。例如，一个典型的旅行路线可以是Ottawa–Sudbury–Montreal–Kingston–Toronto–Ottawa，成本为*484
    + 680 + 287 + 263 + 450 = 2,164*。这是销售员需要旅行的最短距离吗？什么是可以最小化旅行商所走总距离的最优解？我将留给你去思考和计算。
- en: Using a brute-force strategy
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蛮力策略
- en: 'The first solution that comes to mind to solve the TSP is using brute force
    to come up with the shortest path in which the salesperson visits every city exactly
    once and returns to the initial city. So, the brute-force strategy works as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 解决TSP的第一个解决方案是使用蛮力策略找到销售员访问每个城市一次并返回到初始城市的最短路径。因此，蛮力策略的工作方式如下：
- en: Evaluate all possible tours.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估所有可能的旅行路线。
- en: Choose the one for which we get the shortest distance.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个我们可以得到最短距离的方案。
- en: The problem is that for *n* number of cities there are *(n-1)!* possible tours.
    It means that five cities will produce *4! = 24* tours and we will select the
    one that corresponds to the lowest distance. It is obvious that this method will
    only work since we do not have too many cities. As the number of cities increases,
    the brute-force strategy becomes unstable due to a large number of permutations
    generated by using this approach.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于对于*n*个城市，存在*(n-1)!*种可能的旅行路线。这意味着五个城市将产生*4! = 24*种旅行路线，我们将选择对应最短距离的那个。很明显，这种方法只适用于我们没有太多城市的情况。随着城市数量的增加，蛮力策略由于生成的排列数量庞大而变得不稳定。
- en: Let's see how we can implement the brute-force strategy in Python.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Python中实现蛮力策略。
- en: First, note that a tour, {1,2,3}, represents a tour of the city from city 1
    to city 2 and city 3\. The total distance in a tour is the total distance covered
    in a tour. We will assume that the distance between the cities is the shortest
    distance between them (which is the Euclidean distance).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到一个旅行路线{1,2,3}表示从城市1到城市2和城市3的旅行路线。旅行路线中的总距离是旅行路线中覆盖的总距离。我们将假设城市之间的距离是它们之间的最短距离（即欧几里得距离）。
- en: 'Let''s first define three utility functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义三个实用函数：
- en: '`distance_points`: Calculates the absolute distance between two points'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distance_points`：计算两点之间的绝对距离'
- en: '`distance_tour`: Calculates the total distance the salesperson has to cover
    in a given tour'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distance_tour`：计算销售员在给定旅行中需要覆盖的总距离'
- en: '`generate_cities`: Randomly generates a set of *n* cities located in a rectangle
    of width `500` and height `300`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_cities`：随机生成一个位于宽度为`500`，高度为`300`的矩形内的*n*个城市的集合'
- en: 'Let''s look at the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE2]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we implemented `alltours` from the `permutations` function
    of the `itertools` package. We have also represented the distance with a complex
    number. This means the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们从`itertools`包的`permutations`函数实现了`alltours`。我们还用复数表示了距离。这意味着：
- en: Calculating the distance between two cities, *a* and *b*, is as simple as `distance
    (a,b)`,
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个城市*a*和*b*之间的距离就是简单的`distance (a,b)`，
- en: We can create *n* number of cities just by calling `generate_cities(n)`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过调用`generate_cities(n)`来创建*n*个城市。
- en: 'Now let''s define a function, `brute_force`, that generates all the possible
    tours of the cities. Once it has generated all possible tours, it will choose
    the one with the shortest distance:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个名为`brute_force`的函数，它生成所有可能的城市旅游路线。一旦生成了所有可能的路线，它将选择最短距离的路线：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let''s define the utility functions that can help us plot the cites. We
    will define the following functions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一些实用函数，可以帮助我们绘制城市。我们将定义以下函数：
- en: '`visualize_tour`: Plots all the cities and links in a particular tour. It also
    highlights the city from where the tour started.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visualize_tour`：绘制特定旅游路线中的所有城市和链接。它还会突出显示旅游路线的起始城市。'
- en: '`visualize_segment`: Used by `visualize_tour` to plot cites and links in a
    segment.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visualize_segment`：由`visualize_tour`使用，用于绘制路段中的城市和链接。'
- en: 'Look at the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s implement a function, `tsp()`, that does the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个名为`tsp()`的函数，它可以执行以下操作：
- en: Generates the tour based on the algorithm and number of cities requested
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据算法和请求的城市数量生成旅游路线
- en: Calculates the time it took for the algorithm to run
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算算法运行所花费的时间
- en: Generates a plot
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个图
- en: 'Once `tsp()` is defined, we can use it to create a tour:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了`tsp()`，我们就可以使用它来创建一条旅游路线：
- en: '![](assets/772acb6f-707d-4628-9e83-78a5b830cb2e.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/772acb6f-707d-4628-9e83-78a5b830cb2e.png)'
- en: Note that we have used it to generate the tour for 10 cities. As *n* *= 10*,
    it will generate *(10-1)! =* *362,880* possible permutations. If *n* increases,
    the number of permutations sharply increases and the brute-force method cannot
    be used.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经用它来为10个城市生成旅游路线。当*n*=10时，它将生成*(10-1)! = 362,880*个可能的排列。如果*n*增加，排列的数量会急剧增加，而暴力方法无法使用。
- en: Using a greedy algorithm
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用贪婪算法
- en: If we use a greedy algorithm to solve the TSP, then, at each step, we can choose
    a city that seems reasonable, instead of finding a city to visit that will result
    in the best overall path. So, whenever we need to select a city, we just select
    the nearest city without bothering to verify that this choice will result in the
    globally optimal path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用贪婪算法来解决TSP问题，那么在每一步，我们可以选择一个看起来合理的城市，而不是找到一个可以得到最佳整体路径的城市。因此，每当我们需要选择一个城市时，我们只需选择最近的城市，而不必验证这个选择是否会得到全局最优路径。
- en: 'The approach of the greedy algorithm is simple:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪算法的方法很简单：
- en: Start from any city.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何城市开始。
- en: At each step, keep building the tour by moving to the next city where the nearest
    neighborhood has not been visited before.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一步中，通过移动到尚未访问过的最近邻居的城市来构建旅游路线。
- en: Repeat *step 2.*
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*。
- en: 'Let''s define a function named `greedy_algorithm` that can implement this logic:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`greedy_algorithm`的函数，可以实现这个逻辑：
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s use `greedy_algorithm` to create a tour for 2,000 cities:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`greedy_algorithm`为2,000个城市创建一条旅游路线：
- en: '![](assets/dd42feb1-1b10-4448-97c9-115cd8e3528b.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dd42feb1-1b10-4448-97c9-115cd8e3528b.png)'
- en: Note that it took only 0.514 seconds to generate the tour for 2,000 cities.
    If we had used the brute-force method, it would have generated *(2000-1)!* permutations,
    which is almost infinity.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生成2,000个城市的旅游路线只花了0.514秒。如果我们使用了暴力方法，它将生成*(2000-1)!*个排列，几乎是无穷大。
- en: Note that the greedy algorithm is based on heuristics and there is no proof
    that the solution will be optimal.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，贪婪算法是基于启发式的，没有证据表明解决方案将是最优的。
- en: Now, let's look at the design of the PageRank algorithm.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看PageRank算法的设计。
- en: Presenting the PageRank algorithm
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍PageRank算法
- en: As a practical example, let's look at the PageRank algorithm, which was initially
    used by Google to rank the search results of a user query. It generates a number
    that quantifies the importance of search results in the context of the query the
    user has executed. This was designed by two Ph.D. students, Larry Page and Sergey
    Brin, at Stanford in the late 1990s, who also went on to start Google.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际的例子，让我们来看看PageRank算法，最初被谷歌用来对用户查询的搜索结果进行排名。它生成一个数字，量化了搜索结果在用户执行的查询上下文中的重要性。这是由斯坦福大学的两位博士生拉里·佩奇和谢尔盖·布林在20世纪90年代末设计的，他们后来创办了谷歌。
- en: The PageRank algorithm was named after Larry Page, who created it with Sergey
    Brin while studying at Stanford University.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法是以拉里·佩奇的名字命名的，他在斯坦福大学与谢尔盖·布林一起创建了它。
- en: Let's first formally define the problem for which PageRank was initially designed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先正式定义PageRank最初设计的问题。
- en: Problem definition
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题定义
- en: Whenever a user enters a query on a search engine on the web, it typically results
    in a large number of results. To make the results useful for the end user, it
    is important to rank the web pages using some criteria. The results that are displayed
    use this ranking to summarize the results for the user and are dependent on the
    criteria defined by the underlying algorithm being used.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户在网络上的搜索引擎上输入查询时，通常会得到大量的结果。为了使结果对最终用户有用，重要的是使用某些标准对网页进行排名。显示的结果使用这个排名来总结用户的结果，并且依赖于底层算法定义的标准。
- en: Implementing the PageRank algorithm
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现PageRank算法
- en: 'The most important part of the PageRank algorithm is to come up with the best
    way to calculate the importance of each page that is returned by the query results.
    To calculate a number from `0` to `1` that can quantify the importance of a particular
    page, the algorithm incorporates information from the following two components:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法最重要的部分是找到计算每个页面重要性的最佳方法。为了计算一个从`0`到`1`的数字，可以量化特定页面的重要性，该算法结合了以下两个组件的信息：
- en: '**Information that was specific to the query entered by the user**: This component
    estimates, in the context of the query entered by the user, how relevant the content
    of the web page is. The content of the page is directly dependent on the author
    of the page.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入的查询特定信息**：这个组件估计了用户输入的查询的上下文中，网页内容的相关性。页面的内容直接取决于页面的作者。'
- en: '**Information that was not relevant to the query entered by the user**: This
    component tries to quantify the importance of each web page in the context of
    its links, views, and neighborhood. This component is difficult to calculate as
    web pages are heterogeneous and coming up with criteria that can be applied across
    the web is difficult to develop.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与用户输入的查询无关的信息**：这个组件试图量化每个网页在其链接、浏览和邻域的重要性。这个组件很难计算，因为网页是异质的，而且很难制定可以应用于整个网络的标准。'
- en: 'In order to implement the PageRank algorithm in Python, first, let''s import
    the necessary libraries:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中实现PageRank算法，首先让我们导入必要的库：
- en: '[PRE6]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the purpose of demonstration, let''s assume that we are analyzing only
    five webpages in the network. Let''s call this set of pages `myPages` and together
    they are in a network named `myWeb`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示的目的，让我们假设我们只分析网络中的五个网页。让我们称这组页面为“myPages”，它们一起在一个名为“myWeb”的网络中：
- en: '[PRE7]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s connect them randomly to simulate an actual network:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们随机连接它们以模拟实际网络：
- en: '[PRE8]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s plot this graph:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制这个图：
- en: '[PRE9]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It creates the visual representation of our network, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了我们网络的可视表示，如下所示：
- en: '![](assets/5bff14a4-3a17-4186-bb25-c9a898075152.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5bff14a4-3a17-4186-bb25-c9a898075152.png)'
- en: In the PageRank algorithm, the patterns of a web page are contained in a matrix
    called the transition matrix. There are algorithms that constantly update the
    transition matrix to capture the constantly changing state of the web. The size
    of the transition matrix is *n x n*, where *n* is the number of nodes. The numbers
    in the matrix are the probability that a visitor will next go to that link due
    to the outbound link.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在PageRank算法中，网页的模式包含在一个称为转换矩阵的矩阵中。有一些算法不断更新转换矩阵，以捕捉不断变化的网络状态。转换矩阵的大小是*n x n*，其中*n*是节点的数量。矩阵中的数字是访问者由于出站链接而下一个转到该链接的概率。
- en: 'In our case, the preceding graph shows the static web that we have. Let''s
    define a function that can be used to create the transition matrix:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，上面的图显示了我们拥有的静态网络。让我们定义一个函数，用于创建转换矩阵：
- en: '![](assets/40bb15c0-107d-4743-92c8-6933a8fdd79b.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/40bb15c0-107d-4743-92c8-6933a8fdd79b.png)'
- en: Note that this function will return *G*, which represents the transition matrix
    for our graph.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个函数将返回*G*，它代表我们图的转换矩阵。
- en: 'Let''s generate the transition matrix for our graph:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的图生成转换矩阵：
- en: '![](assets/94bc5bfb-e6af-4856-821e-1cb2c73c0642.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/94bc5bfb-e6af-4856-821e-1cb2c73c0642.png)'
- en: Note that the transition matrix is *5 x 5* for our graph. Each column corresponds
    to each node in the graph. For example, column 2 is about the second node. There
    is a 0.5 probability that the visitor will navigate from node 2 to node 1 or node
    3. Note that the diagonal of the transition matrix is `0` as in our graph, there
    is no outbound link from a node to itself. In an actual network, it may be possible.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们图的转换矩阵是*5 x 5*。每一列对应图中的每个节点。例如，第2列是关于第二个节点的。访问者从节点2导航到节点1或节点3的概率为0.5。请注意，转换矩阵的对角线是`0`，因为在我们的图中，节点没有到自身的出站链接。在实际网络中，这可能是可能的。
- en: Note that the transition matrix is a sparse matrix. As the number of nodes increases,
    most of its values will be `0`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，转换矩阵是一个稀疏矩阵。随着节点数量的增加，大多数值将为`0`。
- en: Understanding linear programming
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线性规划
- en: The basic algorithm behind linear programming was developed by George Dantzig
    at the University of California at Berkeley in the early 1940s. Dantzig used this
    concept to experiment with logistical supply-and-capacity planning for troops
    while working for the US Air Force. At the end of the Second World War, Dantzig
    started working for the Pentagon and matured his algorithm into a technique that
    he named linear programming. It was used for military combat planning.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划背后的基本算法是由乔治·丹齐格在1940年代初在加州大学伯克利分校开发的。丹齐格在为美国空军工作时，利用这个概念进行了物流供应和容量规划的实验。二战结束后，丹齐格开始为五角大楼工作，并将他的算法成熟为一种他称之为线性规划的技术。它被用于军事作战规划。
- en: 'Today, it is used to solve important real-world problems that relate to minimizing
    or maximizing a variable based on certain constraints. Some examples of these
    problems are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，它被用来解决与根据某些约束最小化或最大化变量相关的重要现实问题。这些问题的一些例子如下：
- en: Minimizing the time to repair a car at a mechanic shop based on the resources
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据资源最小化修理汽车的时间
- en: Allocating available distributed resources in a distributed computing environment
    to minimize response times
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分布式计算环境中分配可用的分布式资源以最小化响应时间
- en: Maximizing the profit of a company based on the optimal assignment of resources
    within the company
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据公司内资源的最佳分配来最大化公司的利润
- en: Formulating a linear programming problem
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制定线性规划问题
- en: 'The conditions to use linear programming are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性规划的条件如下：
- en: We should be able to formulate the problem through a set of equations.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够通过一组方程来阐明问题。
- en: The variables used in the equation must be linear.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程中使用的变量必须是线性的。
- en: Defining the objective function
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义目标函数
- en: Note that the objective of each of the preceding three examples is about minimizing
    or maximizing a variable. This objective is mathematically formulated as a linear
    function of other variables and is called the objective function. The aim of a
    linear programming problem is to minimize or maximize the objective function while
    remaining within the specified constraints.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面三个例子的目标都是关于最小化或最大化一个变量。这个目标在数学上被公式化为其他变量的线性函数，并被称为目标函数。线性规划问题的目标是在保持指定约束条件的情况下最小化或最大化目标函数。
- en: Specifying constraints
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定约束条件
- en: When trying to minimize or maximize something, there are certain constraints
    in real-world problems that need to be respected. For example, when trying to
    minimize the time it takes to repair a car, we also need to consider that there
    is a limited number of mechanics available. Specifying each constraint through
    a linear equation is an important part of formulating a linear programming problem.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Practical application – capacity planning with linear programming
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a practical use case where linear programming can be used to
    solve a real-world problem. Let''s assume that we want to maximize the profits
    of a state-of-the-art factory that manufactures two different types of robots:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced model (A)**: This provides full functionality. Manufacturing each
    unit of the advanced model results in a profit of $4,200.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic model (B)**: This only provides basic functionality. Manufacturing
    each unit of the basic model results in a profit of $2,800.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three different types of people needed to manufacture a robot. The
    exact number of days needed to manufacture a robot of each type are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type of Robot** | **Technician** | **AI Specialist** | **Engineer** |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| Robot A: advanced model | 3 days | 4 days | 4 days |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| Robot B: basic model | 2 days | 3 days | 3 days |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: The factory runs on 30-day cycles. A single AI specialist is available for 30
    days in a cycle. Each of the two engineers will take 8 days off in 30 days. So,
    an engineer is available only for 22 days in a cycle. There is a single technician
    available for 20 days in a 30-day cycle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the number of people we have in the factory:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Technician** | **AI Specialist** | **Engineer** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| Number of people | 1 | 1 | 2 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| Total number of days in a cycle | 1 x 20 = 20 days | 1 x 30 = 30 days | 2
    x 22 = 44 days |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: 'This can be modeled as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Maximum profit = 4200A + 2800B
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is subject to the following:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A ≥ 0: The number of advanced robots produced can be `0` or more.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'B ≥ 0: The number of basic robots produced can be `0` or more.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3A + 2B ≤ 20: These are the constraints of the technician''s availability.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4A+3B ≤ 30: These are the constraints of the AI specialist''s availability.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4A+ 3B ≤ 44: These are the constraints of the engineers'' availability.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we import the Python package named `pulp`, which is used to implement
    ;linear programming:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we call the `LpProblem` function in this package to instantiate the problem
    class. We name the instance `Profit maximising problem`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we define two linear variables, `A` and `B`. Variable `A` represents
    the number of advanced robots that are produced and variable `B` represents the
    number of basic robots that are produced:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We define the objective function and constraints as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use the `solve` function to generate a solution:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we print the values of `A` and `B` and the value of the objective function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ef602d5-4191-4349-91f0-962727d49841.png)Linear programming is extensively
    used in the manufacturing industry to find the optimal number of products that
    should be used to optimize the use of available resources.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: And here we come to the end of this chapter! Let's summarize what we have learned.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at various approaches to designing an algorithm.
    We looked at the trade-offs involved in choosing the correct design of an algorithm.
    We looked at the best practices of formulating a real-world problem. We also looked
    at how to solve a real-world optimization problem. The lessons learned from this
    chapter can be used to implement well-designed algorithms.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on graph-based algorithms. We will start
    by looking at different ways of representing graphs. Then, we will study the techniques
    to establish a neighborhood around various data points to conduct a particular
    investigation. Finally, we will study the optimal ways to search for information
    from graphs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
