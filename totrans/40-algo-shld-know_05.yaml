- en: Designing Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents the core design concepts of various algorithms. It discusses
    the strengths and weaknesses of various techniques for designing algorithms. By
    understanding these concepts, you will learn how to design efficient algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts by discussing the different choices available to you when
    designing algorithms. Then, it discusses the importance of characterizing the
    particular problem that we are trying to solve. Next, it uses the famous **Traveling
    Salesman Problem** (**TSP**) as a use case and applies the different design techniques
    that we will be presenting. Then, it introduces linear programming and discusses
    its applications. Finally, it presents how linear programming can be used to solve
    a real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand the basic concepts
    of designing an efficient algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following concepts are discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The various approaches to designing an algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the trade-offs involved in choosing the correct design for an
    algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices of formulating a real-world problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving a real-world optimization problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first look at the basic concepts of designing an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the basic concepts of designing an algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An algorithm, according to the American Heritage Dictionary, is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A finite set of unambiguous instructions that given some set of initial conditions
    can be performed in a prescribed sequence to achieve a certain goal and that has
    a recognizable set of end conditions."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Designing an algorithm is about coming up with this "*finite set of unambiguous
    instructions*" in the most efficient way to "*achieve a certain goal*." For a
    complex real-world problem, designing an algorithm is a tedious task. To come
    up with a good design, we first need to fully understand the problem we are trying
    to solve. We start by figuring out *what* needs to be done (that is, understanding
    the requirements) before looking into *how* it will be done (that is, designing
    the algorithm). Understanding the problem includes addressing both the functional
    and non-functional requirements of the problem. Let''s look at what these are:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional requirements formally specify the input and output interfaces of
    the problem that we want to solve and the functions associated with them. Functional
    requirements help us understand data processing, data manipulation, and the calculations
    that need to be implemented to generate the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-functional requirements set the expectations about the performance and security
    aspects of the algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that designing an algorithm is about addressing both the functional and
    non-functional requirements in the best possible way under the given set of circumstances
    and keeping in mind the set of resources available to run the designed algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'To come up with a good response that can meet the functional and non-functional
    requirements, our design should respect the following three concerns, as discussed
    in Chapter 1, *Overview of Algorithms*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Concern 1: Will the designed algorithm produce the result we expect?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concern 2: Is this the optimal way to get these results?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concern 3: How is the algorithm going to perform on larger datasets?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, let's look at these concerns one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Concern 1 – Will the designed algorithm produce the result we expect?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An algorithm is a mathematical solution to a real-world problem. To be useful,
    it should produce accurate results. How to verify the correctness of an algorithm
    should not be an afterthought; instead, it should be baked into the design of
    the algorithm. Before strategizing how to verify an algorithm, we need to think
    about the following two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the truth**: To verify the algorithm, we need some known correct
    results for a given set of inputs. These known correct results are called the
    **truths**, in the context of the problem we are trying to solve. The **truth**
    is important as it is used as a reference when we iteratively work on evolving
    our algorithm toward a better solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choosing metrics**: We also need to think about how are we going to quantify
    the deviation from the defined truth. Choosing the correct metrics will help us
    to accurately quantify the quality of our algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, for machine learning algorithms, we can use existing labeled data
    as the truth. We can choose one or more metrics, such as accuracy, recall, or
    precision, to quantify deviation from the truth. It is important to note that,
    in some use cases, the correct output is not a single value. Instead, the correct
    output is defined as the range for a given set of inputs. As we work on the design
    and development of our algorithm, the objective will be to iteratively improve
    the algorithm until it is within the range specified in the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Concern 2 – Is this the optimal way to get these results?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second concern is about finding the answer to the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>Is this the optimal solution and can we verify that no other solution exists
    for this problem that is better than our solution?</q>
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, this question looks quite simple to answer. However, for a
    certain class of algorithms, researchers have unsuccessfully spent decades verifying
    whether a particular solution generated by an algorithm is also the best and that
    no other solution exists that can give better results. So, it becomes important
    that we first understand the problem, its requirements, and the resources available
    to run the algorithm. We need to acknowledge the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>Should we aim to find the optimal solution for this problem? Finding and
    verifying the optimal solution is so time-consuming and complex that a workable
    solution based on heuristics is our best bet.</q>
  prefs: []
  type: TYPE_NORMAL
- en: So, understanding the problem and its complexities is important and helps us
    estimate the resource requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start looking deeper into this, first, let''s define a couple of
    terms here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Polynomial algorithm:** If an algorithm has a time complexity of *O(n**^k*
    *)*, we call it a polynomial algorithm, where *k* is a constant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate:** A proposed candidate solution produced at the end of an iteration
    is called a **certificate**. As we progress iteratively in solving a particular
    problem, we typically generate a series of certificates. If the solution is moving
    toward convergence, each generated certificate will be better than the previous
    one. At some point, when our certificate meets the requirements, we will choose
    that certificate as the final solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Chapter 1, *Overview of Algorithms*, we introduced Big O notation, which
    can be used to analyze the time complexity of an algorithm. In the context of
    analyzing time complexity, we are looking at the following different time intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: The time it takes for an algorithm to produce a proposed solution, called a
    certificate (*t[r]*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time it takes to verify the proposed solution (certificate), *t[s]*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characterizing the complexity of the problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the years, the research community has divided problems into various categories
    according to their complexity. Before we attempt to design the solution to a problem,
    it makes sense to first try to characterize it. Generally, there are three types
    of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type 1: Problems for which we can guarantee that a polynomial algorithm exists
    that can be used to solve them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type 2: Problems for which we can prove that they cannot be solved by a polynomial
    algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type 3: Problems for which we are unable to find a polynomial algorithm to
    solve them, but we are also unable to prove that a polynomial solution for those
    problems is impossible to find'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the various classes of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-Deterministic Polynomial** (**NP**): For a problem to be an NP problem,
    it has to meet the following condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is guaranteed that there is a polynomial algorithm that can be used to verify
    that the candidate solution (certificate) is optimal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polynominal** (**P**): These are types of problems that can be thought of
    as a subset of NP. In addition to meeting the condition of an NP problem, P problems
    need to meet another condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is guaranteed that there is at least one polynomial algorithm that can be
    used to solve them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between **P** and **NP** problems is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/efff141e-c598-4dfc-9b52-650de9d52230.png)If a problem is NP, is
    it P as well? This is one of the greatest problems in computer science that remains
    unresolved. Millennium Prize Problems, selected by the Clay Mathematics Institute,
    has announced a 1 million dollar prize for the solution to this problem as it
    will have a major impact on fields such as AI, cryptography, and theoretical computer
    sciences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99b84b3d-f132-4aad-b80d-084d61c79810.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s continue the list of various classes of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NP-complete**: The NP-complete category contains the hardest problems of
    all NP problems. An NP-complete problem meets the following two conditions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no known polynomial algorithms to generate a certificate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are known polynomial algorithms to verify that the proposed certificate
    is optimal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NP-hard**: The NP-hard category contains problems that are at least as hard
    as any problem in the NP category, but that do not themselves need to be in the
    NP category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s try to draw a diagram to illustrate these different classes of
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7f1eae28-466f-4476-b8bf-d8e6389b0f62.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that it is still to be proven by the research community whether P = NP.
    Although this has not yet been proven, it is extremely likely that P ≠ NP. In
    that case, no polynomial solution exists for NP-complete problems. Note that the
    preceding diagram is based on this assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Concern 3 – How is the algorithm going to perform on larger datasets?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An algorithm processes data in a defined way to produce a result. Generally,
    as the size of the data increases, it takes more and more time to process the
    data and calculate the required results. The term *big data* is sometimes used
    to roughly identify datasets that are expected to be challenging for the infrastructure
    and algorithms to work with due to their volume, variety, and velocity. A well-designed
    algorithm should be scalable, which means that it should be designed in a way
    that means, wherever possible, it should be able to run efficiently, making use
    of the available resources and generating the correct results in a reasonable
    timeframe. The design of the algorithm becomes even more important when dealing
    with big data. To quantify the scalability of an algorithm, we need to keep the
    following two aspects in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The increase in resource requirements as the input data is increased**: Estimating
    a requirement such as this is called space complexity analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The increase in the time taken to run as the input data is increased**: Estimating
    this is called time complexity analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we are living in an era that is defined by data explosion. The term
    *big data* has become mainstream as it captures the size and complexity of the
    data that is typically required to be processed by modern algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: While in the development-and-testing phase, many algorithms use only a small
    sample of data. When designing an algorithm, it is important to look into the
    scalability aspect of the algorithms. In particular, it is important to carefully
    analyze (that is, test or predict) the effect of an algorithm's performance as
    datasets increase in size.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding algorithmic strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-designed algorithm tries to optimize the use of the available resources
    most efficiently by dividing the problem into smaller subproblems wherever possible.
    There are different algorithmic strategies for designing algorithms. An algorithmic
    strategy deals with the following three aspects of an algorithm list containing
    aspects of the missing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will present the following three strategies in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: The divide-and-conquer strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dynamic programming strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The greedy algorithm strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the divide-and-conquer strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strategies is to find a way to divide a larger problem into smaller
    problems that can be solved independently of each other. The subsolutions produced
    by these subproblems are then combined to generate the overall solution of the
    problem. This is called the **divide-and-conquer** strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, if we are designing a solution for a problem (*P*) with *n*
    inputs that needs to process dataset *d*, we split the problem into *k* subproblems,
    *P[1]* to *P[k]*. Each of the subproblems will process a partition of the dataset,
    *d*. Typically, we will have *P**[1]* to *P**[k]* processing *d[1]* to *d[k]*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a practical example.
  prefs: []
  type: TYPE_NORMAL
- en: Practical example – divide-and-conquer applied to Apache Spark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Spark is an open source framework that is used to solve complex distributed
    problems. It implements a divide-and-conquer strategy to solve problems. To process
    a problem, it divides the problem into various subproblems and processes them
    independently of each other. We will demonstrate this by using a simple example
    of counting words from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have the following list of words:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wordsList = [python, java, ottawa, news, java, ottawa]`'
  prefs: []
  type: TYPE_NORMAL
- en: We want to calculate the frequency of each word in this list. For that, we will
    apply the divide-and-conquer strategy to solve this problem in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of divide-and-conquer is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0803c96a-de47-4fda-aa52-9f6ad7e7d81a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows the following phases into which a problem is divided:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Splitting**: The input data is divided into partitions that can be processed
    independently of each other. This is called splitting. We have three *splits*
    in the preceding figure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mapping**: Any operation that can run independently on a split is called
    a map. In the preceding diagram, the map operation coverts each of the words in
    the partition to key-value pairs. Corresponding to the three splits, there are
    three mappers that are run in parallel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shuffling**: Shuffling is the process of bringing similar keys together.
    Once the similar keys are brought together, aggregation functions can be run on
    their values. Note that *shuffling* is a performance-intensive operation as similar
    keys need to be brought together that can be originally distributed across the
    network.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reducing**: Running an aggregation function on the values of similar keys
    is called reducing. In the preceding diagram, we have to count the number of words.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see how we can write the code to implement this. To demonstrate the
    divide-and-conquer strategy, we need a distributed computing framework. We will
    run Python running on Apache Spark for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in order to use Apache Spark, we will create a runtime context of Apache
    Spark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a sample list containing some words. We will convert this
    list into Spark''s native distributed data structure, called a **Resilient Distributed
    Dataset** (**RDD**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use a `map` function to convert the words into a key-value pair:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b3cc81ba-f3bf-4ed1-8032-c0ff42b7bd35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use the `reduce` function to aggregate and get the final result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a2340460-95d3-45ef-818e-095913d82680.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows how we can use the divide-and-conquer strategy to count the number
    of words.
  prefs: []
  type: TYPE_NORMAL
- en: Modern cloud computing infrastructures, such as Microsoft Azure, Amazon Web
    Services, and Google Cloud, achieve scalability by implementing a divide-and-conquer
    strategy either directly or indirectly behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the dynamic programming strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic programming was a strategy proposed in the 1950s by Richard Bellman
    to optimize certain classes of algorithms. It is based on an intelligent caching
    mechanism that tries to reuse heavy computations. This intelligent caching mechanism
    is called **memorization**.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic programming gives good performance benefits when the problem we are
    trying to solve can be divided into subproblems. The subproblems partly involve
    a calculation that is repeated in those subproblems. The idea is to perform that
    calculation once (which is the time-consuming step) and then reuse it on the other
    subproblems. This is achieved using memorization, which is especially useful in
    solving recursive problems that may evaluate the same inputs multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding greedy algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive deep into this section, let''s first define two terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithmic overheads**: Whenever we try to find the optimal solution to
    a certain problem, it takes some time. As the problems that we are trying to optimize
    become more and more complex, the time it takes to find the optimal solution also
    increases. We represent algorithmic overheads with *Ω[i]*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delta from optimal**: For a given optimization problem, there exists an optimal
    solution. Typically, we iteratively optimize the solution using our chosen algorithm.
    For a given problem, there always exists a perfect solution, called the **optimal
    solution**, to the current problem. As discussed, based on the classification
    of the problem we are trying to solve, it''s possible for the optimal solution
    to be unknown or that it would take an unreasonable amount of time to calculate
    and verify it. Assuming that the optimal solution is known, the difference from
    optimal for the current solution in the *i**^(th)* iteration is called **delta
    from optimal** and is represented by *Δ**[i]*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For complex problems, we have two possible strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy 1:** Spend more time finding a solution nearest to optimal so that
    *Δ*[*i*] is as small as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy 2:** Minimize the algorithmic overhead, *Ω*[*i*] . Use the quick-and-dirty
    approach and just use a workable solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greedy algorithms are based on strategy 2, where we do not make an effort to
    find a global optimal and choose to minimize the algorithm overheads instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using a greedy algorithm is a quick and simple strategy of finding the global
    optimal value for multistage problems. It is based on selecting the local optimal
    values without making an effort to verify whether local optimal values are globally
    optimal as well. Generally, unless we are lucky, a greedy algorithm will not result
    in a value that can be considered globally optimal. However, finding a global
    optimal value is a time-consuming task. Hence, the greedy algorithm is fast compared
    to the divide-and-conquer and dynamic programming algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, a greedy algorithm is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we have a dataset, *D*. In this dataset, choose an element,
    *k*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's assume the candidate solution or certificate is *S*. Consider including
    *k* in the solution, *S*. If it can be included, then the solution is *Union(S,
    e)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process until *S* is filled up or *D* is exhausted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practical application – solving the TSP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first look at the problem statement for the TSP, which is a well-known
    problem that was coined as a challenge in the 1930s. The TSP is an NP-hard problem.
    To start with, we can randomly generate a tour that meets the condition of visiting
    all of the cities without caring about the optimal solution. Then, we can work
    to improve the solution with each iteration. Each tour generated in an iteration
    is called a candidate solution (also called a certificate). Proving that a certificate
    is optimal requires an exponentially increasing amount of time. Instead, different
    heuristics-based solutions are used that generate tours that are near to optimal
    but are not optimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'A traveling salesman needs to visit a given list of cities to get their job
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '| INPUT | A list of *n* cities (denoted as *V*) and the distances between each
    pair of cities, *d ij (1 ≤ i, j ≤ n)* |'
  prefs: []
  type: TYPE_TB
- en: '| OUTPUT | The shortest tour that visits each city exactly once and returns
    to the initial city |'
  prefs: []
  type: TYPE_TB
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The distances between the cities on the list are known,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each city in the given list needs to be visited *exactly* once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we generate the travel plan for the salesman? What will be the optimal solution
    that can minimize the total distance traveled by the traveling salesman?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the distances between five Canadian cities that we can use
    for the TSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Ottawa** | **Montreal** | **Kingston** | **Toronto** | **Sudbury** |'
  prefs: []
  type: TYPE_TB
- en: '| **Ottawa** | - | 199 | 196 | 450 | 484 |'
  prefs: []
  type: TYPE_TB
- en: '| **Montreal** | 199 | - | 287 | 542 | 680 |'
  prefs: []
  type: TYPE_TB
- en: '| **Kingston** | 196 | 287 | - | 263 | 634 |'
  prefs: []
  type: TYPE_TB
- en: '| **Toronto** | 450 | 542 | 263 | - | 400 |'
  prefs: []
  type: TYPE_TB
- en: '| **Sudbury** | 484 | 680 | 634 | 400 | - |'
  prefs: []
  type: TYPE_TB
- en: Note that the objective is to get a tour that starts and ends in the initial
    city. For example, a typical tour can be Ottawa–Sudbury–Montreal–Kingston–Toronto–Ottawa
    with a cost of *484 + 680 + 287 + 263 + 450 = 2,164*. Is this the tour in which
    the salesman has to travel the minimum distance? What will be the optimal solution
    that can minimize the total distance traveled by the traveling salesman? I will
    leave this up to you to think about and calculate.
  prefs: []
  type: TYPE_NORMAL
- en: Using a brute-force strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first solution that comes to mind to solve the TSP is using brute force
    to come up with the shortest path in which the salesperson visits every city exactly
    once and returns to the initial city. So, the brute-force strategy works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate all possible tours.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the one for which we get the shortest distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The problem is that for *n* number of cities there are *(n-1)!* possible tours.
    It means that five cities will produce *4! = 24* tours and we will select the
    one that corresponds to the lowest distance. It is obvious that this method will
    only work since we do not have too many cities. As the number of cities increases,
    the brute-force strategy becomes unstable due to a large number of permutations
    generated by using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can implement the brute-force strategy in Python.
  prefs: []
  type: TYPE_NORMAL
- en: First, note that a tour, {1,2,3}, represents a tour of the city from city 1
    to city 2 and city 3\. The total distance in a tour is the total distance covered
    in a tour. We will assume that the distance between the cities is the shortest
    distance between them (which is the Euclidean distance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first define three utility functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`distance_points`: Calculates the absolute distance between two points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distance_tour`: Calculates the total distance the salesperson has to cover
    in a given tour'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generate_cities`: Randomly generates a set of *n* cities located in a rectangle
    of width `500` and height `300`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we implemented `alltours` from the `permutations` function
    of the `itertools` package. We have also represented the distance with a complex
    number. This means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the distance between two cities, *a* and *b*, is as simple as `distance
    (a,b)`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create *n* number of cities just by calling `generate_cities(n)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s define a function, `brute_force`, that generates all the possible
    tours of the cities. Once it has generated all possible tours, it will choose
    the one with the shortest distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define the utility functions that can help us plot the cites. We
    will define the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`visualize_tour`: Plots all the cities and links in a particular tour. It also
    highlights the city from where the tour started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visualize_segment`: Used by `visualize_tour` to plot cites and links in a
    segment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement a function, `tsp()`, that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generates the tour based on the algorithm and number of cities requested
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculates the time it took for the algorithm to run
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates a plot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once `tsp()` is defined, we can use it to create a tour:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/772acb6f-707d-4628-9e83-78a5b830cb2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we have used it to generate the tour for 10 cities. As *n* *= 10*,
    it will generate *(10-1)! =* *362,880* possible permutations. If *n* increases,
    the number of permutations sharply increases and the brute-force method cannot
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using a greedy algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we use a greedy algorithm to solve the TSP, then, at each step, we can choose
    a city that seems reasonable, instead of finding a city to visit that will result
    in the best overall path. So, whenever we need to select a city, we just select
    the nearest city without bothering to verify that this choice will result in the
    globally optimal path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach of the greedy algorithm is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from any city.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At each step, keep building the tour by moving to the next city where the nearest
    neighborhood has not been visited before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 2.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s define a function named `greedy_algorithm` that can implement this logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use `greedy_algorithm` to create a tour for 2,000 cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd42feb1-1b10-4448-97c9-115cd8e3528b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that it took only 0.514 seconds to generate the tour for 2,000 cities.
    If we had used the brute-force method, it would have generated *(2000-1)!* permutations,
    which is almost infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the greedy algorithm is based on heuristics and there is no proof
    that the solution will be optimal.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the design of the PageRank algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the PageRank algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a practical example, let's look at the PageRank algorithm, which was initially
    used by Google to rank the search results of a user query. It generates a number
    that quantifies the importance of search results in the context of the query the
    user has executed. This was designed by two Ph.D. students, Larry Page and Sergey
    Brin, at Stanford in the late 1990s, who also went on to start Google.
  prefs: []
  type: TYPE_NORMAL
- en: The PageRank algorithm was named after Larry Page, who created it with Sergey
    Brin while studying at Stanford University.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first formally define the problem for which PageRank was initially designed.
  prefs: []
  type: TYPE_NORMAL
- en: Problem definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a user enters a query on a search engine on the web, it typically results
    in a large number of results. To make the results useful for the end user, it
    is important to rank the web pages using some criteria. The results that are displayed
    use this ranking to summarize the results for the user and are dependent on the
    criteria defined by the underlying algorithm being used.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the PageRank algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important part of the PageRank algorithm is to come up with the best
    way to calculate the importance of each page that is returned by the query results.
    To calculate a number from `0` to `1` that can quantify the importance of a particular
    page, the algorithm incorporates information from the following two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Information that was specific to the query entered by the user**: This component
    estimates, in the context of the query entered by the user, how relevant the content
    of the web page is. The content of the page is directly dependent on the author
    of the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information that was not relevant to the query entered by the user**: This
    component tries to quantify the importance of each web page in the context of
    its links, views, and neighborhood. This component is difficult to calculate as
    web pages are heterogeneous and coming up with criteria that can be applied across
    the web is difficult to develop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to implement the PageRank algorithm in Python, first, let''s import
    the necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purpose of demonstration, let''s assume that we are analyzing only
    five webpages in the network. Let''s call this set of pages `myPages` and together
    they are in a network named `myWeb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s connect them randomly to simulate an actual network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s plot this graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It creates the visual representation of our network, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5bff14a4-3a17-4186-bb25-c9a898075152.png)'
  prefs: []
  type: TYPE_IMG
- en: In the PageRank algorithm, the patterns of a web page are contained in a matrix
    called the transition matrix. There are algorithms that constantly update the
    transition matrix to capture the constantly changing state of the web. The size
    of the transition matrix is *n x n*, where *n* is the number of nodes. The numbers
    in the matrix are the probability that a visitor will next go to that link due
    to the outbound link.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the preceding graph shows the static web that we have. Let''s
    define a function that can be used to create the transition matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/40bb15c0-107d-4743-92c8-6933a8fdd79b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that this function will return *G*, which represents the transition matrix
    for our graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate the transition matrix for our graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/94bc5bfb-e6af-4856-821e-1cb2c73c0642.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the transition matrix is *5 x 5* for our graph. Each column corresponds
    to each node in the graph. For example, column 2 is about the second node. There
    is a 0.5 probability that the visitor will navigate from node 2 to node 1 or node
    3. Note that the diagonal of the transition matrix is `0` as in our graph, there
    is no outbound link from a node to itself. In an actual network, it may be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the transition matrix is a sparse matrix. As the number of nodes increases,
    most of its values will be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding linear programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic algorithm behind linear programming was developed by George Dantzig
    at the University of California at Berkeley in the early 1940s. Dantzig used this
    concept to experiment with logistical supply-and-capacity planning for troops
    while working for the US Air Force. At the end of the Second World War, Dantzig
    started working for the Pentagon and matured his algorithm into a technique that
    he named linear programming. It was used for military combat planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, it is used to solve important real-world problems that relate to minimizing
    or maximizing a variable based on certain constraints. Some examples of these
    problems are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the time to repair a car at a mechanic shop based on the resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating available distributed resources in a distributed computing environment
    to minimize response times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximizing the profit of a company based on the optimal assignment of resources
    within the company
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formulating a linear programming problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The conditions to use linear programming are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We should be able to formulate the problem through a set of equations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variables used in the equation must be linear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the objective function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that the objective of each of the preceding three examples is about minimizing
    or maximizing a variable. This objective is mathematically formulated as a linear
    function of other variables and is called the objective function. The aim of a
    linear programming problem is to minimize or maximize the objective function while
    remaining within the specified constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When trying to minimize or maximize something, there are certain constraints
    in real-world problems that need to be respected. For example, when trying to
    minimize the time it takes to repair a car, we also need to consider that there
    is a limited number of mechanics available. Specifying each constraint through
    a linear equation is an important part of formulating a linear programming problem.
  prefs: []
  type: TYPE_NORMAL
- en: Practical application – capacity planning with linear programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a practical use case where linear programming can be used to
    solve a real-world problem. Let''s assume that we want to maximize the profits
    of a state-of-the-art factory that manufactures two different types of robots:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced model (A)**: This provides full functionality. Manufacturing each
    unit of the advanced model results in a profit of $4,200.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic model (B)**: This only provides basic functionality. Manufacturing
    each unit of the basic model results in a profit of $2,800.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three different types of people needed to manufacture a robot. The
    exact number of days needed to manufacture a robot of each type are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type of Robot** | **Technician** | **AI Specialist** | **Engineer** |'
  prefs: []
  type: TYPE_TB
- en: '| Robot A: advanced model | 3 days | 4 days | 4 days |'
  prefs: []
  type: TYPE_TB
- en: '| Robot B: basic model | 2 days | 3 days | 3 days |'
  prefs: []
  type: TYPE_TB
- en: The factory runs on 30-day cycles. A single AI specialist is available for 30
    days in a cycle. Each of the two engineers will take 8 days off in 30 days. So,
    an engineer is available only for 22 days in a cycle. There is a single technician
    available for 20 days in a 30-day cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the number of people we have in the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Technician** | **AI Specialist** | **Engineer** |'
  prefs: []
  type: TYPE_TB
- en: '| Number of people | 1 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Total number of days in a cycle | 1 x 20 = 20 days | 1 x 30 = 30 days | 2
    x 22 = 44 days |'
  prefs: []
  type: TYPE_TB
- en: 'This can be modeled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum profit = 4200A + 2800B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is subject to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A ≥ 0: The number of advanced robots produced can be `0` or more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'B ≥ 0: The number of basic robots produced can be `0` or more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3A + 2B ≤ 20: These are the constraints of the technician''s availability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4A+3B ≤ 30: These are the constraints of the AI specialist''s availability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4A+ 3B ≤ 44: These are the constraints of the engineers'' availability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we import the Python package named `pulp`, which is used to implement
    ;linear programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call the `LpProblem` function in this package to instantiate the problem
    class. We name the instance `Profit maximising problem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define two linear variables, `A` and `B`. Variable `A` represents
    the number of advanced robots that are produced and variable `B` represents the
    number of basic robots that are produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the objective function and constraints as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `solve` function to generate a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we print the values of `A` and `B` and the value of the objective function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ef602d5-4191-4349-91f0-962727d49841.png)Linear programming is extensively
    used in the manufacturing industry to find the optimal number of products that
    should be used to optimize the use of available resources.'
  prefs: []
  type: TYPE_NORMAL
- en: And here we come to the end of this chapter! Let's summarize what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at various approaches to designing an algorithm.
    We looked at the trade-offs involved in choosing the correct design of an algorithm.
    We looked at the best practices of formulating a real-world problem. We also looked
    at how to solve a real-world optimization problem. The lessons learned from this
    chapter can be used to implement well-designed algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on graph-based algorithms. We will start
    by looking at different ways of representing graphs. Then, we will study the techniques
    to establish a neighborhood around various data points to conduct a particular
    investigation. Finally, we will study the optimal ways to search for information
    from graphs.
  prefs: []
  type: TYPE_NORMAL
