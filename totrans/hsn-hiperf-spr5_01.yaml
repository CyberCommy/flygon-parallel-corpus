- en: Exploring Spring Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Spring Framework** provides extensive support for managing large enterprise
    Java applications and also addresses the complexities of enterprise application
    development. Spring provides a complete set of API and configuration models for
    modern enterprise applications so that programmers just need to focus on the business
    logic of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced as a lightweight framework, the Spring Framework was aimed at providing
    a way of making the development of Java enterprise applications easy and simple.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you gain a better understanding of the core features
    of the Spring Framework. We will start with an introduction to the Spring Framework. This
    chapter will also give you a clear understanding of every major module of the
    Spring Framework. After having a quick look at the important modules in the Spring
    Framework, we will dive into the world of Spring projects. We will also have a
    clear understanding of the Spring **Inversion of Control** (**IoC**) container.
    At the end, we will have a look at the new features and enhancements introduced
    in Spring 5.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Spring Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Spring modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring IoC container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features in Spring Framework 5.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Framework is one of the most popular open source Java application
    frameworks and IoC containers. Spring was originally developed by Rod Johnson
    and Jurgen Holler. The first milestone version of Spring Framework was released
    in March 2004\. Though it has been a decade and a half, the Spring Framework remains
    the framework of choice to build any Java application.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework provides comprehensive infrastructure support for developing
    enterprise Java applications. So, developers don't need to worry about the infrastructure
    of the application; they can focus on the business logic of the application, rather
    than handling the configuration of the application.
  prefs: []
  type: TYPE_NORMAL
- en: All infrastructure, configuration, and meta configuration files, either Java-based
    or XML-based, are handled by the Spring Framework. So, this framework gives you
    more flexibility in building an application with a **Plain Old Java Object** (**POJO**) programming
    model rather than a non-invasive programming model.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring IoC container forms the core of the entire framework by putting together
    any application's various components. Spring **Model-View-Controller** (**MVC**)
    components can be used to build a very flexible web tier. The IoC container simplifies
    the development of the business layer with POJOs.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with EJB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early days, it was very difficult for programmers to manage enterprise
    applications, because the enterprise Java technologies like **Enterprise JavaBeans**
    (**EJB**) were much heavier to provide the enterprise solutions to programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When EJB technology was first announced, it was offering a distributed component
    model that would allow the developers to focus only on the business side of the
    system while ignoring the middleware requirements, such as wiring of components,
    transaction management, persistence operations, security, resource pooling, threading,
    distribution, remoting, and so on; however, it was a very cumbersome process for
    developing, unit testing, and deploying EJB applications. Some of the following
    complexities were faced while using EJB:'
  prefs: []
  type: TYPE_NORMAL
- en: Forcing implementation of unnecessary interfaces and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making unit testing difficult, especially outside the EJB container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inconveniences in managing deployment descriptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tedious exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At that time, Spring was introduced as an alternative technology especially
    made for EJB, because Spring provided a very simple, leaner, and lighter programming
    model compared with other existing Java technologies. Spring makes it possible
    to overcome the preceding complexities, and also to avoid the use of some other
    heavier enterprise technologies by using many available design patterns. The Spring
    Framework focused on the POJO programming model rather than a non-invasive programming
    model. This model provided the simplicity to the Spring Framework. It also empowered
    ideas such as the **dependency injection** (**DI**) pattern and **Aspect-Oriented
    Programming** (**AOP**), using the proxy pattern and decorator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying implementation using POJO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important advantage of the POJO programming model is that coding application
    classes is very fast and simple. This is because classes don't need to depend
    on any particular API, implement any special interface, or extend from a particular
    framework class. You do not have to create any special callback methods until
    you really need them.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The important benefits of the Spring Framework are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No need to reinvent the wheel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduction in implementing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inversion of control and API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency in transaction management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to date with time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each in detail.
  prefs: []
  type: TYPE_NORMAL
- en: No need to reinvent the wheel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No need to reinvent the wheel is one of the most important benefits that developers
    can leverage from the Spring Framework. It facilitates the practical use of the
    well-known technologies, ORM frameworks, logging frameworks, JEE, JDK timers,
    Quartz, and so on. So, developers don't have to learn any new technologies or
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: It facilitates good programming practices, such as programming using interfaces
    instead of classes. Spring enables developers to develop enterprise applications
    using POJO and **Plain Old Java Interface** (**POJI**) model programming.
  prefs: []
  type: TYPE_NORMAL
- en: Ease of unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to test the applications developed using Spring, it is quite easy.
    The main reason behind this is that the environment-dependent code is available
    in this framework. Earlier versions of EJBs were very difficult to unit test.
    It was difficult to even run EJBs outside the container (as of version 2.1). The
    only way to test them was to deploy them in a container.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework introduced the DI concept. We will discuss DI in complete
    detail in [Chapter 2](cd47e5f4-5c77-413c-935f-ae3bfa508c9a.xhtml), *Spring Best
    Practices and Bean Wiring Configurations*. The DI enables unit testing. This is
    done by replacing the dependencies with their mocks. The entire application need
    not be deployed to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing has multiple benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Improving the productivity of programmers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting defects at earlier stages, thereby saving the cost of fixing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing future defects by automating unit tests in applications that are
    running in **continuous integration** (**CI**) builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduction in implementing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All application classes are simple POJO classes; Spring is not invasive. It
    does not require you to extend framework classes or implement framework interfaces
    for most use cases. Spring applications do not require a Jakarta EE application
    server, but they can be deployed on one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the Spring Framework, typical J2EE applications contained a lot of plumbing
    code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Code for getting a database connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code for handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction management code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging code and a lot more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following simple example of executing a query using `PreparedStatement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, there are four lines of business logic and more than
    10 lines of plumbing code. The same logic can be applied in a couple of lines
    using the Spring Framework, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using Spring, you can use a Java method as a request handler method or remote
    method, like a `service()` method of a servlet API, but without dealing with the
    servlet API of the servlet container. It supports both XML-based and annotation-based
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Spring enables you to use a local Java method as a message handler method, without
    using a **Java Message Service** (**JMS**) API in the application. Spring serves
    as a container for your application objects. Your objects do not have to worry
    about finding and establishing connections with each other. Spring also enables
    you to use the local Java method as a management operation, without using a **Java
    Management Extensions** (**JMX**) API in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of control and API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring also helps developers to get rid of the necessity of writing a separate
    compilation unit, or a separate class loader to handle exceptions. Spring converts
    technology-dependent exceptions, particularly thrown by **Java Database Connectivity** (**JDBC**),
    Hibernate or **Java Data Objects** (**JDO**), into unchecked and consistent exceptions.
    Spring does this magic using inversion of control and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it uses IoC for DI, which means aspects can be configured normally. If
    we want to add our own behavior, we need to extend the classes of the framework
    or plug in our own classes. The following is a list of advantages for this kind
    of architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling the execution of a task from its implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making it easier to switch between different implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater modularity of a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater ease in testing a program by isolating a component or mocking it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies and allowing components to communicate through contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency in transaction management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring also provides support for transaction management with consistency. It
    provides an easy and flexible way to configure local transactions for small applications
    as well as global transactions for large applications using the **Java Transaction
    API** (**JTA**). So we do not need to use any third-party transactional API to
    execute a database transaction; Spring will take care of it with the transaction
    management feature.
  prefs: []
  type: TYPE_NORMAL
- en: Modular architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides a modular architecture that helps developers to identify the
    packages or classes which are to be used and which are to be ignored. Hence, in
    this way, we can keep only those things which we really need. So that makes it
    easy to identify and utilize the usable packages or classes even if there are
    many packages or classes.
  prefs: []
  type: TYPE_NORMAL
- en: Spring is a powerful framework that addresses many common problems in Jakarta
    EE. It includes support for managing business objects and exposing their services
    to presentation tier components.
  prefs: []
  type: TYPE_NORMAL
- en: Spring instantiates the beans and injects the dependencies of your objects into
    the application it serves as a life cycle manager of the beans.
  prefs: []
  type: TYPE_NORMAL
- en: Up to date with time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the first version of the Spring Framework was built, its main focus was
    to make applications testable. There were also new challenges in the later versions,
    but the Spring Framework managed to evolve and stay ahead and on track with the
    architectural flexibility and modules that are offered. Some examples are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework introduced a number of abstractions ahead of Jakarta EE
    to keep the application decoupled from the specific implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring Framework also provided transparent caching support in Spring 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta EE was introduced with JSR-107 for JCache in 2014, so it was provided
    in Spring 4.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another major evolution that Spring was involved with was to provide different
    Spring projects. The Spring Framework is just one of the many projects among Spring
    projects. The following example illustrates how the Spring Framework managed to
    remain up to date in terms of Spring projects:'
  prefs: []
  type: TYPE_NORMAL
- en: As architecture evolved toward cloud and microservices, Spring came up with
    new cloud-oriented Spring projects. The Spring Cloud project simplifies development
    and deployment of microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To build Java batch applications, a new approach was introduced as the Spring
    Batch project by the Spring Framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will dive deep into the different Spring Framework modules.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Spring modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides a modular architecture that is one of the most important reasons
    for the popularity of the Spring Framework. Its layered architecture enables integration
    of other frameworks easily and without hassle. These modules provide everything
    that a developer may need to use in enterprise application development. The Spring
    Framework is organized into 20 different modules that are built on the top of
    its Core Container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates different Spring modules organized in a layered
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1a68982-99fd-4f80-9c50-910d04a97854.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spring Framework modules
  prefs: []
  type: TYPE_NORMAL
- en: We will start with discussing the Core Container before moving on to other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Core Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Spring Core Container** provides the core features of the Spring Framework,
    namely as Core, Beans, Context, and Expression Language, the details of which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Artifact** | **Module Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-core` | This module facilitates all the utilities used by other modules
    and it also provides a way for managing the different bean life cycle operations.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-beans` | This module is mainly used to decouple code dependencies
    from your actual business logic and eliminates the use of singleton classes using
    DI and IoC features.  |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-context` | This module provides features like internationalization,
    and resource loading, and also underpins Java EE features like EJB, JMS, and remoting. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-expression` | This module provides support for accessing properties
    of beans at runtime and also allows us to manipulate them. |'
  prefs: []
  type: TYPE_TB
- en: Crosscutting concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Crosscutting concerns are applicable to all the layers of an application, including
    logging and security, among others. Important Spring modules related to crosscutting
    concerns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Artifact** | **Module Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-aop` | This module is mainly used to perform the tasks which are
    common amongst different parts of a system like transaction management, logging,
    and security. To enable this we can implement method-interceptors and pointcuts.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-aspects` | This module is used to integrate any custom object type.
    It is possible using AspectJ, and the main use of this module is to integrate
    the objects which are not in the control of the container. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-instrument` | This module is used to measure the application''s performance
    and also helps to perform error diagnosis using trace information. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-test` | This module is used to integrate testing support in a Spring
    application. |'
  prefs: []
  type: TYPE_TB
- en: Data Access/Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Data Access**/**Integration** layer in applications interacts with the
    database and/or the external interfaces. It consists of JDBC, ORM, OXM, JMS, and
    Transaction modules. These modules are `spring-jdbc`, `spring-orm`, `spring-oxm`,
    `spring-jms`, and `spring-tx`.
  prefs: []
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Web** layer contains the Web, Web-MVC, Web-Socket, and other Web-Portlet
    modules. The respective module names are `spring-web`, `spring-webmvc`, `spring-websocket`,
    `spring-webmvc-portlet`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go through different kinds of Spring projects.
  prefs: []
  type: TYPE_NORMAL
- en: Spring projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Framework provides different kinds of projects for different infrastructure
    needs, and also helps to explore solutions to other problems in the enterprise
    application: deployment, cloud, big data, and security, among others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important Spring projects are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Batch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring HATEOAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Boot** provides support to create standalone, production-grade, Spring-based
    applications that you can just run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot also provides some of the following features out of the box, by
    taking an opinionated view of how applications have to be developed:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides support for developing standalone Spring applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embeds Tomcat, Jetty, or Undertow directly, with no need to deploy WAR files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow us to externalize configuration to work in different environments with
    the same application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifies Maven configuration by providing opinionated starter POMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminates the need for code generation and the requirement for XML configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides support for production features like metrics, health checks, and application
    monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at Spring Boot in depth in [Chapter 12](ffdd6481-357a-4a6c-9a62-b5cc8315b967.xhtml),
    *Spring Boot Microservice Performance Tuning*.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of the **Spring Data** project is to provide an easy and consistent
    Spring-based model to access data and other special features, to manipulate SQL-and
    NoSQL-based data stores. It also tries to provide an easy way to use data access
    technologies, map-reduce frameworks, relational and non-relational databases,
    and cloud-based data services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides support for integration with custom repository code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides repository and object-mapping abstractions by deriving dynamic queries
    using repository method names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced integration support with Spring MVC controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced support for transparent auditing features such as created by, created
    date, last changed by, and last changed date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimental integration support for cross-store persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Data provides integration support for the following data sources:'
  prefs: []
  type: TYPE_NORMAL
- en: JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LDAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gemfire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Cassandra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Solr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Batch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Batch** facilitates essential processing for large volumes of records,
    including logging/tracing, transaction management, job processing statistics,
    job restart, skip, and resource management, by providing reusable functions. It
    also provides more advanced technical services and features that will enable extremely
    high-volume and high-performance batch jobs using optimization and partitioning
    techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Important features of Spring Batch are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to process data in chunks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to start, stop and restart jobs, including the ability to restart,
    in the case of failed jobs, from the point where they failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to retry steps or to skip steps on failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web-based administration interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not an overstatement to say *the world is moving to the cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud** provides tools for developers to build common patterns in
    distributed systems. Spring Cloud enables developers to quickly build services
    and applications that implement common patterns to work in any distributed environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common patterns implemented in Spring Cloud are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registration and discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breakers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligent routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are the essential parts of enterprise applications,
    both web applications and web services. **Spring** **Security** is a powerful
    and highly customizable authentication and access control framework. Spring Security
    focuses on providing declarative authentication and authorization to Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important features in Spring Security are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive support for both authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good support for integration with servlet APIs and Spring MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module support for integration with **Security Assertion Markup Language** (**SAML**)
    and **Lightweight Directory Access Protocol** (**LDAP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing support for common security attacks such as **Cross-Site Forgery Request**
    (**CSRF**), session fixation, clickjacking, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss how to secure web applications with Spring Security in [Chapter
    4](3ad9ec7c-1a8c-4a0f-886f-28528322ac49.xhtml), *Spring MVC Optimization*.
  prefs: []
  type: TYPE_NORMAL
- en: Spring HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Themain purpose of **Hypermedia As The Engine Of Application State** (**HATEOAS**)
    is to decouple the server (the service provider) from the client (the service
    consumer). The server provides the client with information on other possible actions
    that can be performed on the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Spring HATEOAS provides a HATEOAS implementation, especially for the **REpresentational
    State Transfer** (**REST**) services implemented with Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring HATEOAS has the following important features:'
  prefs: []
  type: TYPE_NORMAL
- en: A simplified definition of links pointing to service methods, making the links
    less fragile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for JSON and JAXB (XML-based) integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for hypermedia formats such as **Hypertext Application Language** (**HAL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will understand the mechanism of Spring's IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Spring's IoC container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring's **IoC container** is built as the core module of the Spring architecture.
    IoC is also known as DI. It is a design pattern which eliminates the dependency
    of the code to provide ease in managing and testing the application. In DI, the
    objects themselves characterize their dependencies with the other objects they
    work, just through constructor arguments, arguments to a factory method, or properties
    that are set on the object instance after it is created or returned from a factory
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The container is then responsible to inject those dependencies when it creates
    the bean. This process is basically the inverse (so it is known as IoC) of the
    bean itself controlling the instantiation or location of its dependencies, by
    using the direct construction of classes, or a mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main base packages of the Spring Framework''s IoC container:
    `org.springframework.beans`, and `org.springframework.context`. The `BeanFactory`
    interface provides some of the advanced-level configuration mechanisms to manage
    any type of object. `ApplicationContext` includes all the functionalities of `BeanFactory`,
    and acts as a subinterface of it. In fact, `ApplicationContext` is also recommended
    over `BeanFactory`, and provides more supporting infrastructure that enables:
    easier integration with Spring''s AOP features and transaction; message resource
    handling in terms of internationalization and event publication; and application
    layer-specific contexts such as `WebApplicationContext` for use in web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: The interface `org.springframework.context.ApplicationContext` is represented
    as the Spring IoC container, and it is in complete control of a bean's life cycle
    and responsible for instantiating, configuring, and assembling the beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container gets all the instructions to instantiate, configure, and assemble,
    by scanning bean configuration metadata. The configuration metadata can be represented
    using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: XML-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn these methods in more detail in [Chapter 2](cd47e5f4-5c77-413c-935f-ae3bfa508c9a.xhtml),
    *Spring Best Practices and Bean Wiring Configurations*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents a simple representation of the **Spring Container**
    process towards creating a fully configured application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e59e8c91-5ae5-4977-a721-ced135b86944.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Spring IoC container
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the basic structure of XML-based configuration
    metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `id` attribute is a string that you use to identify the individual `bean`
    definition. The `class` attribute defines the type of `bean`, and uses the fully
    qualified `class` name. The value of the `id` attribute refers to collaborating
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: What are Spring beans?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can consider a **Spring bean** as a simple Java object, instantiated, configured,
    and managed by a Spring IoC container. It is called a bean instead of an object
    or component because it is a replacement for complex and heavy enterprise JavaBeans
    with respect to the origin of the framework. We will learn more about Spring bean
    instantiation methods in [Chapter 2](cd47e5f4-5c77-413c-935f-ae3bfa508c9a.xhtml),
    *Spring Best Practices and Bean Wiring Configurations*.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating a Spring container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For creating bean instances, we first need to instantiate a Spring IoC container
    by reading the configuration metadata. After initialization of an IoC container,
    we can get the bean instances using the bean name or ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides two types of IoC container implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BeanFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BeanFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BeanFactory` container acts as the simplest container providing basic support
    for DI, and it is defined by the `org.springframework.beans.factory.BeanFactory`
    interface. `BeanFactory` is responsible to source, configure, and assemble the
    dependencies between objects. `BeanFactory` mainly acts as an object pool, where
    object creation and destruction is managed through configuration. The most popular
    and useful implementation of `BeanFactory` is the `org.springframework.context.support.ClassPathXmlApplicationContext`.
    The `ClassPathXmlApplicationContext` uses XML configuration metadata to create
    a fully configured application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample defines a simple `HelloWorld` application using `ClassPathXmlApplicationContext`.
    The content of `Beans.xml` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding XML code represents the content of `bean` XML configuration. It
    has a single `bean` configured, which has a single property with the `name` message.
    It has a default `value` set for the property.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the following Java class represents `bean` configured in the preceding
    XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at `HelloWorld.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the end, we need to use `ClassPathXmlApplicationContext` to create the `HelloWorld`
    bean and invoke a method in the created Spring bean.
  prefs: []
  type: TYPE_NORMAL
- en: '`Main.java` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ApplicationContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ApplicationContext` container provides support to access application components
    using `BeanFactory` methods. This includes all functionality of `BeanFactory`.
    In addition, `ApplicationContext` can also perform more enterprise functionalities,
    like transaction, AOP, resolving text messages from properties files, and pushing
    application events to interested listeners. It also has the ability to publish
    events to the registered listeners.
  prefs: []
  type: TYPE_NORMAL
- en: The mostly-used implementations of `ApplicationContext` are `FileSystemXmlApplicationContext`,
    `ClassPathXmlApplicationContext`, and `AnnotationConfigApplicationContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring also provides us with a web-aware implementation of the `ApplicationContext`
    interface, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XmlWebApplicationContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnnotationConfigWebApplicationContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use either one of these implementations to load beans into a `BeanFactory`;
    it depends upon our application configuration file locations. For example, if
    we want to load our configuration file `Beans.xml` from the filesystem in a specific
    location, we can use a `FileSystemXmlApplicationContext` class that looks for
    the configuration file `Beans.xml` in a specific location within the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to load our configuration file `Beans.xml` from the classpath of
    our application, we can use `ClassPathXmlApplicationContext` class provided by
    Spring. This class looks for the configuration file `Beans.xml` anywhere in the
    classpath, including JAR files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a Java configuration instead of an XML configuration, you
    can use `AnnotationConfigApplicationContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After loading the configuration files and getting an `ApplicationContext`,
    we can fetch beans from the Spring container by calling the `getBean()` method
    of the `ApplicationContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will learn about the Spring bean life cycle, and
    how a Spring container reacts to the Spring bean to create and manage it.
  prefs: []
  type: TYPE_NORMAL
- en: Spring bean life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The factory method design pattern is used by the Spring `ApplicationContext`
    to create Spring beans in the container in the correct order, as per the given
    configuration. So, the Spring container is responsible for managing the life cycle
    of the bean, from creation to destruction. In a normal Java application, a `new`
    keyword of Java is used to instantiate the bean, and it's ready to use. Once the
    bean is no longer in use, it's eligible for garbage collection. But in a Spring
    container, the life cycle of the bean is more elaborate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the life cycle of a typical Spring bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f0cc18b-e6fe-4d9c-8522-881ca5674560.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spring bean life cycle
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see the new features of the Spring Framework 5.0.
  prefs: []
  type: TYPE_NORMAL
- en: New features in the Spring Framework 5.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Spring Framework 5.0** is the first major upgrade in the Spring Framework,
    almost four years after the Spring Framework 4.0\. In this time frame, one of
    the major developments has been the evolution of the Spring Boot project. We will
    discuss the new features in Spring Boot 2.0 in the next section. One of the biggest
    features of the Spring Framework 5.0 is **reactive programming**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Core reactive programming features and support for reactive endpoints are available
    out of the box with the Spring Framework 5.0\. The list of important changes includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Baseline upgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core features upgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Web MVC upgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring's new functional web framework, **WebFlux**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularity support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin language support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved testing support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropped or deprecated features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss these changes in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Baseline upgrades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The entire Spring Framework 5.0 has a JDK 8 and Jakarta EE 7 baseline. Basically,
    it means that to work on the Spring Framework 5.0, Java 8 is the minimum requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important baseline Jakarta EE 7 specifications for the Spring Framework
    5.0 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The code base of the Spring Framework 5.0 is based on Java 8 source code level
    now. So, the code readability is improved using inferred generics, lambdas, and
    so on. It also has the stability in the code for conditional support for Java
    8 features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring Framework requires at least Jakarta EE 7 API level to run any of
    the Spring Framework 5.0 applications. It requires Servlet 3.1, Bean Validation
    1.1, JPA 2.1, and JMS 2.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The development and deployment process is fully compatible with JDK 9 as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatible with classpath and module path, with stable automatic module names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring Framework's build and test suite also pass on JDK 9, and by default,
    it can be run on JDK 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reactive programming model stands out among the most exciting feature of
    Spring 5.0\. The Spring 5.0 Framework is based on a reactive foundation and is
    completely asynchronous and non-blocking. The new event-loop execution model can
    scale vertically using few threads.
  prefs: []
  type: TYPE_NORMAL
- en: The framework procures reactive streams to provide a system for conveying **backpressure**
    in a pipeline of reactive components. Backpressure is an idea that guarantees
    consumers do not get overpowered with data originating from different producers.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Java 8 does not have built-in support for reactive programming, there
    are a number of frameworks that provide support for reactive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive Streams**: Language-neutral attempt to define reactive APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactor**: Java implementation of Reactive Streams provided by the Spring
    Pivotal team'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring WebFlux**: Enables the development of web applications based on reactive
    programming; provides a programming model similar to Spring MVC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core features upgrades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a part of the new features introduced in Java 8, the core of the Spring
    Framework 5.0 has been revised to provide some of the following key features:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 reflection enhancements include a provision of accessing method parameters
    in the Spring Framework 5.0 efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provision of selective declaration support of Java 8 default methods in Spring
    Core interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports `@Nullable` and `@NotNull` annotations to explicitly mark nullable
    arguments and return values. This eliminates the cause of `NullPointerExceptions`
    at runtime and enables us to deal with null values at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the logging side, the Spring Framework 5.0 provides out-of-the-box support
    with the Commons Logging Bridge module, named `spring-jcl` instead of the standard
    Commons Logging. Also, this new version will be able to detect Log4j 2.x, the
    **Simple Logging Facade for Java** (**SLF4J**), **JUL** (short for `java.util.logging`),
    without any extra amendments.
  prefs: []
  type: TYPE_NORMAL
- en: It also supports `Resource` abstraction by providing the `isFile` indicator
    for the `getFile` method.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Web MVC upgrades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring 5.0 fully supports the Servlet 3.1 signature in Spring-provided `Filter`
    implementations. It also provides support for the Servlet 4.0 `PushBuilder` argument
    in Spring MVC controller methods.
  prefs: []
  type: TYPE_NORMAL
- en: Spring 5.0 also provides unified support for common media types through the `MediaTypeFactory`
    delegate, including the use of the Java Activation Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The new `ParsingPathMatcher` will act as an alternative to `AntPathMatcher`,
    with more efficient parsing and extended syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Spring 5.0 will also be providing support for `ResponseStatusException` as a
    programmatic alternative to `@ResponseStatus`.
  prefs: []
  type: TYPE_NORMAL
- en: Spring's new functional web framework – WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another exciting feature to support reactive HTTP and WebSocket clients, the
    Spring Framework 5.0 provides the `spring-webflux` module. The Spring Framework
    5.0 also provides support for REST, HTML, and WebSocket-style interactions for
    reactive web applications running on servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `spring-webflux`, there are two major programming models on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for `@Controller` annotation including other Spring MVC annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provision for functional style routing and handling with Java 8 Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring `spring-webflux` also provides support for creating `WebClient`, which
    is reactive and non-blocking, as an alternative to `RestTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modular framework is trending on the Java platform. From Java 9, the Java
    platform became modular, and that helps to remove the flaws in encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain problems resulted to have modularity support, as explained
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Java platform size: Since the last couple of decades, there was no need to add
    modularity support in Java. But there are many new lightweight platforms available
    on the market, like the **Internet of Things** (**IoT**), and Node.js. So, it
    was an urgent need to reduce the size of JDK version, because initial versions
    of JDK were less than 10 MB in size, whereas recent versions need more than 200
    MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassLoader` difficulty: When the Java `ClassLoader` searches for the classes,
    it will pick the class definition that is around itself, and immediately load
    the first class available. So, if there is the same class available in different
    JARs, then it is not possible for `ClassLoader` to specify the JAR from which
    the class is to be loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make Java applications modular, **Open System Gateway initiative (OSGi)**
    is one of the initiatives to bring modularity into the Java platform. In OSGi,
    each module is denoted as a **bundle**. Each bundle has its own life cycle, with
    different states as installed, started, and stopped.
  prefs: []
  type: TYPE_NORMAL
- en: The **Jigsaw** project is a primary motivation under the **Java Community Process**
    (**JCP**), to bring modularity into Java. Its main purpose is to define and implement
    a modular structure for JDK and to define a module system for Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin language support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Framework 5.0 introduces a statically typed JVM language support
    the **Kotlin ****language** ([https://kotlinlang.org/](https://kotlinlang.org/)), which
    enables code that is short, readable, and expressive. Kotlin is basically an object-oriented
    language that runs on top of the JVM, and also supports functional programming
    style.
  prefs: []
  type: TYPE_NORMAL
- en: With Kotlin support, we can dive into functional Spring programming, especially
    for functional web endpoints and bean registration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Spring Framework 5.0, we can write clean and readable Kotlin code for web-functional
    APIs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the Spring 5.0 version, Kotlin's null-safety support is also provided with
    the indicating annotations using `@NonNull`, `@Nullable`, `@NonNullApi`, and `@NonNullFields`
    from the `org.springframework.lang` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some newly added Kotlin extensions that basically add function extensions
    to the existing Spring APIs. For example, the extension `fun <T : Any> BeanFactory.getBean():
    T` from the package `org.springframework.beans.factory` adds the support in `org.springframework.beans.factory.BeanFactory` for
    searching a bean by just specifying the bean type as Kotlin''s reified type parameter
    without class argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'One more extension can be found in `org.springframework.ui`, which provides
    operator overloading support to add an array-like getter and setter to the `model`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Improved testing support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the testing front, the Spring Framework 5.0 likewise accompanies JUnit Jupiter
    ([https://junit.org/junit5/docs/current/user-guide/](https://junit.org/junit5/docs/current/user-guide/)).
    It helps in writing tests and extensions in JUnit 5\. It also gives a test engine
    to run Jupiter-constructed tests with respect to Spring and also provides a programming
    and extension model.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework 5.0 additionally underpins parallel test execution in the
    Spring `TestContext` Framework. For Spring WebFlux, `spring-test` likewise incorporates
    bolster for `WebTestClient` to integrate testing support for the reactive programming model.
  prefs: []
  type: TYPE_NORMAL
- en: There is no compelling reason to run a server for testing scenarios. By utilizing
    a new `WebTestClient`, which is like `MockMvc`, `WebTestClient` can bind specifically
    to the WebFlux server infrastructure using a mock request and response.
  prefs: []
  type: TYPE_NORMAL
- en: Dropped or deprecated features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring 5.0, there are some of the packages that have been either removed
    or deprecated at the API level. The `mock.staticmock` package of the `spring-aspects` module
    is no longer available. The `BeanFactoryLocator` is also not available along with
    the `bean.factory.access` package. The `NativeJdbcExtractor` is also no longer
    available along with the `jdbc.support.nativejdbc` package. The packages `web.view.tiles2`, `orm.hibernate3`, and `orm.hibernate4` are
    also replaced with Tiles 3 and Hibernate 5.
  prefs: []
  type: TYPE_NORMAL
- en: Many other bundles like JasperReports, Portlet, Velocity, JDO, Guava, XMLBeans
    are no longer supported in Spring 5\. If you are utilizing any of the preceding
    bundles, it is advised to remain on the Spring Framework 4.3.x.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained a clear understanding of the core features of the
    Spring Framework. We also covered different kinds of Spring modules. After that,
    we went through different types of Spring projects in the Spring Framework. We
    also understood the mechanisms of a Spring IoC container. At the end of the chapter,
    we looked at the new features and enhancements introduced in Spring 5.0.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will understand the concept of DI in detail. We will
    also cover the different types of configurations using DI, including performance
    assessment. And finally, we will go through the pitfalls of DI.
  prefs: []
  type: TYPE_NORMAL
