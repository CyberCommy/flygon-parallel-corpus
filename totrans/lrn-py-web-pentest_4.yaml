- en: Resources Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](part0042.html#181NK0-5a228e2885234f4ba832bb786a6d0c80), *Web
    Crawling with Scrapy – Mapping the Application*, we saw how to write our own crawler
    using Python and the Scrapy library. In this chapter, we are going to learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What is resource discovery?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our first BruteForcer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding more information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking screenshots of the findings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is resource discovery?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to learn what resource discovery is and why it
    is important when testing web applications. Also, we're going to introduce FUZZDB,
    which is going to be used in the next section as our dictionary database.
  prefs: []
  type: TYPE_NORMAL
- en: You will remember that, in [Chapter 1](part0019.html#I3QM0-5a228e2885234f4ba832bb786a6d0c80),
    *Introduction to Web Application Penetration Testing*, we learned about the penetration
    testing process. The second phase in the process was mapping. In the mapping phase,
    we need to build a map or catalog of the application pages and functionalities.
    In earlier sections, we learned how to perform application mapping using a crawler.
    We also learned that crawlers have some limitations. For example, links generated
    by JS are not identified by crawlers. This can be overcome by using HTTP proxies
    or by using a headless browser such as PhantomJS. If we do that, we should be
    able to identify all the resources that are linked somewhere in the web application,
    but my personal experience has shown me that we can find many resources that are
    not linked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to discover these, we need to perform resource discovery via dictionaries
    of known words. These kinds of tools are known as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary attacks**: Here, we use a list of known words in order to identify
    resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brute forcing**: This is using brute force in order to identify resources
    when using a list of permutations or combinations of strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuzzing**: This is not really correct but is often used to refer to resource
    discovery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can we find using these techniques?
  prefs: []
  type: TYPE_NORMAL
- en: '**Files**: Such as backup files, test files, notes, scripts, documentations,
    and examples'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directories**: Such as admin interfaces, backups, internal areas, and upload
    directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: Whenever there are verb names in options or parameters, we can
    use a dictionary of similar words to identify other functionalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Servlets**: Are similar to actions but with a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: We can enumerate ranges or combinations of potential valid
    strings used in parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to be successful when doing resource recovery, you need to have good
    quality lists. There are many dictionary databases where you can find a variety
    of word lists appropriate for different environments or scenarios. FUZZDB ([https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb))
    is one of the most popular and complete databases available on the internet. We
    are going to use it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: For resource discovery, we are going to focus on the predictable resource locations
    dictionary. I recommend that you take a look at it in our virtual machine, under
    the code samples for this section, and get familiar with the different dictionaries
    or string lists that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Building our first BruteForcer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to build a script that will help us to discover
    resources using a dictionary. We're going to create a basic BruteForcer. We'll
    start by defining the objective of the tool and then go over the code for the
    basic structure of the BruteForcer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll run it against our test web application using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to our editor and open the project folder for section 4 by selecting
    File | Add Project Folder... | Desktop | Examples | Section-4 | OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, open the file for `forzabruta.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this script, we have the basic structure for our BruteForcer. We have our
    typical `import`, and then we have the `banner` function, which will print the
    name of the script. The `usage` function opens to provide help on how to use the
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s jump to the `start` function, which is invoked when we run our
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Print the `banner` and then check the parameters used to invoke our program.
    Then, pass the parameters and assign the URL dictionary and number of threads.
    Open the dictionary and read all the lines, and finally, call the `launcher_thread`
    with the `words`, `threads`, and `url`.
  prefs: []
  type: TYPE_NORMAL
- en: As we want our application to perform several tasks at once, we can use threads.
    Otherwise, our BruteForcer will be sequential, and for big dictionaries, it will
    be slow. By using threads, we can speed up this attack. We can reuse this script's
    skeleton whenever we want to implement threading in other tools, as threading
    is usually tricky to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `launcher_thread` function will basically manage the threads and will instantiate
    the class request performer for each thread with one word from the dictionary
    and the target URL, and then it will start the thread. This will be done for each
    word that is loaded in the dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The thread instantiates the class `request_performer`. This class has the `init`
    method which is used to set up the object after it is created, which is basically
    the constructor. In this case, we basically create the attributes `self.word`
    and `self.urly`, which will replace the `FUZZ` tag with a dictionary word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we have the method `run`, which will perform the request and print the
    requested URL and the status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, update the thread counter. When the words from the dictionary are consumed,
    the program will be completed.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding steps show the basic structure for a BruteForcer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example with our vulnerable test application:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Terminal and type `python forzabruta.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have the first option that is the target URL with the word `FUZZ`, which
    is the token that will be replaced by every word in the dictionary. It is the
    position that we want to test, which in this case is dictionaries and files in
    the root directory in the test application. Then, we have the option `-t 5`, which
    is the number of threads we want to use, and finally `-f comment.text`, which
    is the dictionary file created for this exercise. It is pretty simple, but remember
    that in a real test you need to use FUZZDB dictionaries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we run this, we should see the results shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have one result per word in the dictionary. We have some valid `200` status
    codes, and a `401`, which means authentication is needed, and many `404` not found
    codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see some examples in the browser. We are particularly interested in
    the `/Admin` directory. When we request `/Admin`, an authentication form pops
    up needing User Name and Password; we''ll come back to this later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see if `robots.txt` has anything interesting. There are three entries
    in the `robots.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One is `/admin` and the other is the `/includes/` directory. We knew about admin
    already, but `/backoffice` looks interesting. `robot.txt` often produces some
    interesting findings for our testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Wow, congratulations. You wrote a basic HTTP BruteForcer. The coined script
    is pretty basic and the results are not that great, but we're going to improve
    them in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Analysing the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will improve the BruteForcer we created in the previous
    section in order to facilitate an analysis of the results. We're going to see
    how we can improve the results, then we'll add the improvements to our code, and
    finally test the code without testing the web app.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we created a basic BruteForcer, but we saw that the
    results were a little basic and that, when we have a lot of them, it isn't easy
    to identify the interesting findings. So, we can add colors depending on the status
    code. A good start would be to print in green all the results that have a status
    code greater or equal to 200 and lower than 300; in red, the results with a status
    code greater or equal to 400 and lower than 500; and finally, in blue, the results
    with a status code greater or equal to 300 and lower than 400\. This will help
    us to quickly identify the results. Our interest will be mainly in the green and
    blue results.
  prefs: []
  type: TYPE_NORMAL
- en: We can also enrich our results with more information about the responses, such
    as the number of characters, the number of words, and the number of lines. This
    will help us to tell apart pages that return the same content for multiple resources,
    as we'll be able to identify them by looking at the characters, words, or lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll add the option to filter or hide results based on the status
    code. This will be useful to remove any unfound responses that are usually 404;
    although, often, developers customize their apps or servers to return 200, 301,
    or 302:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to our editor, and open the file `forzabruta-2.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some more imports such as `termcolor`, which will allow us to print colors
    in the Terminal, and `re` for regular expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In `request_performer`, we obtain all the information from the response, for
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lines`: Counts the number of new lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chars`: Calculates the number of characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`words`: Calculates the number of words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code`: Calculates the `status_code`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll add them all to the result output. This chain of conditions will
    allow us to filter on non-interesting responses with the code equal to a specific
    hide code, and to visualize other kinds of requests with three different colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use `green` for status codes greater than or equal to `200`
    and less than `300`, `red` for codes greater than or equal to `400` and less than
    `500`, and `blue`, when the result is greater than or equal to `300` and less
    than `400`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add a new parameter to our program. We add `c` in the `getopt`
    parameters, and then we assign the value of `-c` to the variable `hidecode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We pass `hidecode` to the `launcher_thread`, and then to `request_performer`.
    In `request_performer`, we add a condition before printing. In order to filter
    out the codes we are not interested in, this is usually 404.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's go back to the Terminal and run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the command to `forzabruta-2.py` and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the results are much easier to read as the different codes can
    be identified quickly. Let''s try it again adding the parameter `-c` and hide
    response `404` to the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is much better.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will help us to quickly identify where the interesting stuff is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: But it seems that `test1.txt` and `test2.txt` are the same files, right? They
    have the same number of `lines`, `chars`, and `words`, as highlighted in the preceding
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open them in the browser by typing `www.scruffybank.com/test1.txt`.
    You can see `test1.txt` only has `aaa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s open `test2.txt` by typing `www.scruffybank.com/test2.txt`. The
    content is `bbb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: They are not the same, but with our current tool, we weren't able to tell these
    files apart. Let's see how we can solve this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll continue adding features to our BruteForcer in order
    to improve detection and to facilitate filtering.
  prefs: []
  type: TYPE_NORMAL
- en: First, we're going to add the code that will detect whether there was a redirection,
    then we're going to add the time it took for the request response transaction
    and the MD5 hash of the response. Finally, we're going to test the improved script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the `requests` library returns a `200` status code for resources
    that follow the redirection as it is returning the status code from the last resource
    in the redirection chain. If we want to know whether there was a redirection,
    we need to check the history of requests:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the Atom editor and open the file `forzaBruta-3.py`. We need
    to add this code in order to improve the redirection detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After line 48, we get the request response. This code will check whether there
    was a redirection and it will update the code with the first redirection code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For the request time, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the time before the request and the time after the request, and then subtract
    the start time from the elapsed time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to do this, we''re going to use the `time` library. We''ll add the
    `import` library at the beginning, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the following line before the request in order to capture the
    time at that moment and we do the same after the request is performed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we subtract the start time from the elapsed time, and we get the time
    it took for the response to arrive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Entering the hash of the response content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember in the previous example that the files `test1.txt` and `test2.txt` had
    similar results? That was because the number of `lines`, `chars`, and `words`
    were the same. But there will be times when you need to know whether there is
    an actual difference in the content, and in order to do this, we can calculate
    the MD5 hash of the content to get the resources' unique fingerprints.
  prefs: []
  type: TYPE_NORMAL
- en: We need to import MD5 and add `forzabruta-3.py` code. That hash will be unique,
    and it will be useful for filtering resources with similar `chars`, `words`, `lines`,
    and `code`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Terminal and run `forzabruta-3.py` with the same parameters
    as before. Now, this is looking way better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The results are very rich now. Check out the difference in the `MD5` hash of
    `test1.txt` and `test2.txt`. Cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: We now have a value with which to tell them apart. Also, we can see the redirection
    in blue instead of a `200` result. What if we just want to look for `.php` files?
    We just need to add `.php` after the `FUZZ` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we change to `commons` as it is a bigger dictionary for this scenario. Let''s
    run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that we have many new results to investigate. Great stuff. Well
    done! You now have a functional web application—BruteForcer.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to make the BruteForcer take a screenshot of the resource, then
    return a 200 status code? Let's look at that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Taking screenshots of the findings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short section, we're going to learn how to automatically take a screenshot
    from our BruteForcer. We're going to see why taking pictures can be useful, and
    which libraries we need to add this capability to our script. Finally, we're going
    to run a new BruteForcer and take some pictures.
  prefs: []
  type: TYPE_NORMAL
- en: What do we want to achieve in this section? Basically, we want to take a screenshot
    of every resource that returns a 200 code. This will help us to speed up the analysis
    of big apps, or test multiple apps in a shorter period of time.
  prefs: []
  type: TYPE_NORMAL
- en: For this, I chose the selenium web driver for Python ([http://docs.seleniumhq.org](http://docs.seleniumhq.org))
    and PhantomJS ([http://phantomjs.org/](http://phantomjs.org/)). Selenium WebDriver
    is a tool used to automate web browsers pragmatically, mainly for software testing
    purposes. Selenium WebDriver will drive PhantomJS, which is a headless browser,
    and has access to PhantomJS capabilities in Python, in this case, the screenshot
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can also access the DOM, which will be very useful for testing DOM injections.
    I have installed Selenium and PhantomJS in the virtual machine to facilitate training.
    Let''s see how to add this to our BruteForcer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to our editor and open `forzabruta-4.py`. We''re going to add the following
    selenium libraries in the `import` area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the capabilities where we specify, we want to use PhantomJS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we instantiate the WebDriver with the capabilities, and wait `2` seconds
    just to make sure the page is loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the size of the screenshot, then we load the page, and finally, we
    save the screenshot to `word.png`, with the name of the results found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Short and easy, right? Let's run it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Terminal and run `forzabruta-4.py` with the same parameters
    as before. We will see that there are some delays, but they were caused by us
    waiting a couple of seconds to make sure the page loaded. Now, if we look in the
    directory where we ran the script, we should see a few `.png` images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s open `index.php.png` by selecting the Examples folder on the desktop
    and by clicking on Section-4 | index.php.png. This is a screenshot of the content
    of `index.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the index.php
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can open `robots.text.png`, and finally, `test1.txt.png`. We can now
    see the content of the files. This is very interesting considering we are using
    two tools in order to automate the screenshots: Selenium, which lets us drive
    PhantomJS, which in turn lets us take a screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Now you have the knowledge to expand the BruteForcer and add
    anything that you may need in the future. Some suggestions for further development
    are filtering by `lines`, `words`, `chars`, and `MD5`, adding recursion when detecting
    a directory, and generating an HTML report of the results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we learned how to write a BruteForcer tool that will help us
    to discover and enumerate resources such as files, directories, and parameters.
    We saw how to add filtering capabilities, and we saw how this can be extended
    in order to add more information and capabilities to help us filter responses
    and identify interesting ones. Finally, we saw how we can take screenshots automatically
    using Selenium and PhantomJS.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](part0057.html#1MBG20-5a228e2885234f4ba832bb786a6d0c80), *Password
    Testing*, we're going to learn about password quality testing, also known as password
    cracking.
  prefs: []
  type: TYPE_NORMAL
