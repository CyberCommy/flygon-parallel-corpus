- en: Chapter 3. Building Queries with Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how we can configure Spring Data JPA and implemented a simple
    CRUD application. Now it is time that we learn some skills that will help us to
    implement real-life applications. In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: How we can use query methods for creating queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can create dynamic queries by using the JPA Criteria API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can use Querydsl for creating dynamic queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can sort and paginate query results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the course of this chapter, we will extend our contact manager application
    by adding a search function to it. The requirements of the search function are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The search function must return all contacts whose first name or last name start
    with the given search term
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search must be case insensitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search results must be sorted in ascending order by using the last name
    and first name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search function must be able to paginate search results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also learn to sort and paginate the contact list shown on the home page
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Building queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three options we can use to build queries with Spring Data JPA: query
    methods, JPA Criteria API, and Querydsl. During this section, we will learn how
    to use them and start the implementation of our search function. We will also
    take a look at the pros and cons of each option and receive concrete recommendations
    concerning the selection of the correct query creation technique.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can move forward, we have to add a `search()` method, which is used
    as a starting point of our search function, to the `ContactService` interface.
    The signature of the `search()` method looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Query methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to create queries with Spring Data JPA is to use query methods.
    **Query methods** are methods that are declared in the repository interface. There
    are three techniques we can use to create query methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query generation from method name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Named Queries**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Query` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query generation from method name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Query generation from method name is a query generation strategy where the
    executed query is parsed from the name of a query method. The naming convention,
    which is used to create the names of query methods, has three important components:
    **method prefixes**, **property expressions**, and **keywords**. Next we will
    learn the basic usage of these components and implement our search function. We
    will also take a look at the pros and cons of this approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Method prefixes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The name of each method must start with a special prefix. This ensures that
    the method is identified as a query method. The supported prefixes are `findBy`
    , `find`, `readBy` , `read` , `getBy` , and `get` . All prefixes are synonyms
    and they have no effect on the parsed query.
  prefs: []
  type: TYPE_NORMAL
- en: Property expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Property expressions are used to refer either to a direct property or to a
    nested property of a managed entity. We will use the `Contact` entity to demonstrate
    the usage of property expressions in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property expression | Referred property |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LastName` | The `lastName` property of the `Contact` class. |'
  prefs: []
  type: TYPE_TB
- en: '| `AddressStreetAddress` | The `streetAddress` property of the `Address` class.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s find out how the property resolution algorithm works by using the `AddressStreetAddress`
    property expression as an example. This algorithm has three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: At first it will check if the entity class has a property with the name matching
    the property expression when the first letter of the property expression is transformed
    to lowercase. If a match is found, that property is used. If a property named
    `addressStreetAddress` is not found from the `Contact` class the algorithm moves
    to the next phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The property expression is split at camel case parts starting from right to
    left to a head and a tail. After this is done, the algorithm tries to find a matching
    property from the entity. If a match it found, the algorithm tries to find the
    referred property by following the parts of the property expression from head
    to tail. In this phase, our property expression is split into two parts: `AddressStreet`
    and `Address`. Since the `Contact` entity does not have a matching property, the
    algorithm continues to the third phase.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The split point is moved to the left and the algorithm tries to find a matching
    property from the entity. The property expression is split into two parts: `Address`
    and `StreetAddress`. A matching property `address` is found from the `Contact`
    class. Also, since the `Address` class has a property named `streetAddress`, a
    match is found.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Contact` class would have a property called `addressStreetAddress`,
    the property selection algorithm would select it instead of the `streetAddress`
    property of the `Address` class. We can solve this problem by using the underscore
    character in the property expression to manually specify traversal points. In
    this case, we should use a property expression `Address_StreetAddress`.
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Keywords are used to specify constraints against the values of properties referred
    by property expressions. There are two rules that are used to combine property
    expressions together with keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a **constraint** by adding a keyword after a property expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can combine constraints by adding either the **And** or **Or** keyword between
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reference manual of Spring Data JPA ([http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/](http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/))
    describes how property expressions and keywords can be used for creating query
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Sample | JPQL Snippet |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `And` | `findByLastNameAndFirstName` | `where x.lastname = ?1 and x.firstname
    = ?2` |'
  prefs: []
  type: TYPE_TB
- en: '| `Or` | `findByLastNameOrFirstName` | `where x.lastname = ?1 or x.firstname
    = ?2` |'
  prefs: []
  type: TYPE_TB
- en: '| `Between` | `findByStartDateBetween` | `where x.startDate between 1? and
    ?2` |'
  prefs: []
  type: TYPE_TB
- en: '| `LessThan` | `findByAgeLessThan` | `where x.age < ?1` |'
  prefs: []
  type: TYPE_TB
- en: '| `GreaterThan` | `findByAgeGreaterThan` | `where x.age > ?1` |'
  prefs: []
  type: TYPE_TB
- en: '| `After` | `findByStartDateAfter` | `where x.startDate > ?1` |'
  prefs: []
  type: TYPE_TB
- en: '| `Before` | `findByStartDateBefore` | `where x.startDate < ?1` |'
  prefs: []
  type: TYPE_TB
- en: '| `IsNull` | `findByAgeIsNull` | `where x.age is null` |'
  prefs: []
  type: TYPE_TB
- en: '| `IsNotNull`, `NotNull` | `findByAge`(`Is`)`NotNull` | `where x.age is not
    null` |'
  prefs: []
  type: TYPE_TB
- en: '| `Like` | `findByFirstNameLike` | `where x.firstname like ?1` |'
  prefs: []
  type: TYPE_TB
- en: '| `NotLike` | `findByFirstNameNotLike` | `where x.firstname not like ?1` |'
  prefs: []
  type: TYPE_TB
- en: '| `StartingWith` | `findByFirstNameStartingWith` | `where x.firstname like
    ?1` (parameter bound with appended `%`) |'
  prefs: []
  type: TYPE_TB
- en: '| `EndingWith` | `findByFirstNameEndingWith` | `where x.firstname like ?1`
    (parameter bound with prepended `%`) |'
  prefs: []
  type: TYPE_TB
- en: '| `Containing` | `findByFirstNameContaining` | `where x.firstname like ?1`
    (parameter bound wrapped in `%`) |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderBy` | `findByAgeOrderByLastNameDesc` | `where x.age = ?1 order by x.lastname
    desc` |'
  prefs: []
  type: TYPE_TB
- en: '| `Not` | `findByLastNameNot` | `where x.lastname <> ?1` |'
  prefs: []
  type: TYPE_TB
- en: '| `In` | `findByAgeIn` (Collection<Age> ages) | `where x.age in ?1` |'
  prefs: []
  type: TYPE_TB
- en: '| `NotIn` | `findByAgeNotIn` (Collection<Age> ages) | `where x.age not in ?1`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `True` | `findByActiveTrue` | `where x.active = true` |'
  prefs: []
  type: TYPE_TB
- en: '| `False` | `findByActiveFalse` | `where x.active = false` |'
  prefs: []
  type: TYPE_TB
- en: Implementing the search function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is time to use the skills we have learned and add the search function to
    our contact manager application. We can implement the search function by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We add a query method to the `ContactRepository` interface by following the
    described naming convention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement a service method that uses the query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we have to create the query method. The signature of our query method
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have to add the `search()` method to the `RepositoryContactService`
    class. This method simply delegates the method call to the repository and gives
    the used search term as a parameter. The source code of the implemented method
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pros and cons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have now learned how we can create queries by using the query generation
    from the method name strategy. The pros and cons of this strategy are described
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: It is a fast way to create simple queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a consistent naming strategy for method names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The features of the method name parser decide what kind of queries we can create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method names of complicated query methods are long and ugly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries are verified at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No support for dynamic queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: One good example about the limitations of the method name parser is the lack
    of the `Lower` keyword. This means that we cannot implement a case insensitive
    search by using this strategy. Next we will learn alternative strategies for creating
    queries that do not suffer from this restriction.
  prefs: []
  type: TYPE_NORMAL
- en: Named queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A second way to create query methods with Spring Data JPA is to use named queries.
    If we want to create a query method with a named query, we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a named query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a query method that executes the named query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service method that uses the created query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are described with more details in following section. We will also
    discuss the pros and cons of named queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a named query
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Spring Data JPA supports named queries that are created by using either JPQL
    or SQL. The selection of the used query language determines how the created named
    query is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a JPA named query by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `@NamedQueries` annotation to an entity class. This annotation takes
    an array of `@NamedQuery` annotations as its value, and it must be used if we
    specify more than one named query
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use the `@NamedQuery` annotation for creating the named query. This annotation
    has two properties that are relevant to us: the `name` property stores the name
    of the named query, and the `query` property contains the executed JPQL query.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The declaration of our named query, which uses JPQL, is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use XML for declaring named queries. In this case, we must use the
    `named-query` element and declare the query in an entity mapping XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a named native query by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `@NamedNativeQueries` annotation to an entity class. This annotation
    accepts an array of `@NamedNativeQuery` annotations as its value, and it must
    be used if we specify more than one native named query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create the native named query by using the `@NamedNativeQuery` annotation.
    The name of the created native named query is stored in the `name` property. The
    value of the `query` property is the executed SQL query. The `resultClass` property
    contains an entity class that is returned by the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the named native query does not return an entity or a list of entities, we
    can map the query result to a correct return type by using the `@SqlResultSetM`
    `apping` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of our named native query looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use XML for creating named native queries. In this case, we must
    use the `named-native-query` element and declare the SQL query in an entity mapping
    XML file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the query method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our next step is to add the query method to the contact repository. We will
    have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the correct name for the query method. Spring Data JPA resolves method
    names back to named queries by pretending the simple name of the managed entity
    and a dot to the method name. The name of our named query is `Contact.findContacts`.
    Thus, we have to add a method called `findContacts` to the `ContactRepository`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `@Param` annotation to identify the method parameter as a value of the
    named parameter that is used in our queries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The signature of the added query method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating the service method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next we have to add the `search()` method to the `RepositoryContactService`
    class. Our implementation consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We build the used like pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We fetch the search results by calling the created query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `search()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Pros and cons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are now capable of creating query methods by using named queries. The pros
    and cons of this approach are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Supports both JPQL and SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes it easier to migrate existing applications using named queries to Spring
    Data JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of native queries is not restricted to entities or to the list
    of entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Query validation is done at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No support for dynamic queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query logic litters the code of our entity classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '@Query annotation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@Query` annotation is used to specify the query that is executed when
    a query method is called. We can implement both JPQL and SQL queries with the
    `@Query` annotation by:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new method of a repository and annotating it with the `@Query` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the service method, which uses the query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the method name of the method annotated with the `@Query` annotation conflicts
    with the name of a named query, the annotated query will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will get concrete instructions that will guide us through the described
    steps and find out the pros and cons of this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the query method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First we must add the query method to the `ContactRepository` class. As we already
    know, we can create the actual query by using either JPQL or SQL. The selection
    of the used query language has some effects on the creation of the query methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a query method that uses JPQL by:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new method to the `ContactRepository` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `@Param` annotation to identify the parameter of the method as the
    value of the named parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotating the method with the `@Query` annotation and setting the executed
    JPQL query as its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The declaration of our query method, which fulfills the requirements of the
    search function, is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create a query method that uses SQL, we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new method to the `ContactRepository` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the method parameter as a value of the named parameter used in the
    SQL query by using the `@Param` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the created method with the `@Query` annotation and set the SQL query
    as its value. Set the value of the `nativeQuery` property to true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A native query created with the `@Query` annotation can return only entities
    or list of entities. If we need a different return type, we must use a named query
    and map the query result by using the `@SqlResultSetMapping` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of our query method, which implements the requirements of the
    search function, looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spring Data JPA does not provide dynamic sorting or pagination support for native
    queries created with `@Query` annotation because there is no reliable way to manipulate
    SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the service method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our next step is to add an implementation of the `search()` method to the `RepositoryContactService`
    class. We can do this by:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the used like pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetching the search results by calling the created query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the implemented `search()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Pros and cons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have now learned how we can use the `@Query` annotation for creating query
    methods. This approach naturally has both pros and cons that are described in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Supports both JPQL and SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No naming convention for method names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Native queries can return only entities or a list of entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No support for dynamic queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query validation is done at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: JPA Criteria API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JPA Criteria API provides us with a way to create dynamic and type-safe
    queries in an object-oriented manner. We can create **criteria queries** by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We add JPA Criteria API support to a repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create the executed criteria query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a service method that executes the created query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps, and the pros and cons of using the JPA criteria API, are described
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the JPA Criteria API support to a repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add JPA Criteria API support to a repository by extending the `JpaSpecificationExecutor<T>`
    interface. When we extend this interface, we must give the type of the managed
    entity as a type parameter. The source code of the `ContactRepository` interface
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Extending the `JpaSpecificationExecutor<T>` interface gives us access to the
    following methods that can be used to execute criteria queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `long count(Specification<Contact> s)` | Returns the number of entities matching
    with the given search criteria. |'
  prefs: []
  type: TYPE_TB
- en: '| `List<Contact> findAll(Specification<Contact> s)` | Returns all entities
    matching with the given search criteria. |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact findOne(Specification<Contact> s)` | Returns a single contact matching
    with the given search criteria. |'
  prefs: []
  type: TYPE_TB
- en: Creating the criteria query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have learned, Spring Data JPA uses the `Specification<T>` interface for
    specifying the criteria query. This interface declares the `Predicate toPredicate(Root<T>
    root, CriteriaQuery<?> query, CriteriaBuilder cb)` method that we can use to create
    the executed criteria query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create criteria queries for the `Contact` entity, we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a static metamodel class for the `Contact` entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a way to build `Specification<Contact>` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a static metamodel class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Static metamodel classes provide static access to the metadata that describes
    the attributes of entities, and they are used to create type-safe queries with
    JPA Criteria API. Static metamodel classes are typically generated automatically
    but in here we will create one manually for the sake of an example. We can create
    a static metamodel class by following these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A static metamodel class should be placed in the same package than the corresponding
    entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a static metamodel class is created by appending an underscore character
    to the simple name of the corresponding entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we are using only the `firstName` and `lastName` properties of the `Contact`
    entity when building our criteria query, we can ignore the other attributes. The
    source code of the `Contact_` class looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating specifications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can create specifications in a clean manner by creating a specification
    builder class and use static method to build the actual specifications. The logic
    used to build the needed like pattern is also moved to this class. Our implementation
    of the specification builder class is explained in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a `getLikePattern()` method that is used to create the like pattern
    from the search term.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a static `firstOrLastNameStartsWith()` method that returns a new `Specification<Contact>`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We build the criteria query in the `toPredicate()` method of the `Specification<Contact>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our specification builder class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating the service method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our implementation of the `search()` method of the `RepositoryContactService`
    class contains the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We obtain the `Specification<Contact>` object by using our specification builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the search results by calling the `findAll()` method of the repository
    and passing the `Specification<Contact>` object as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our implementation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Pros and cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have now learned how we can implement dynamic queries by using the JPA Criteria
    API. Before we can use these skills in real-world applications, we should be aware
    of the pros and cons of this approach. These are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Supports dynamic queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax verification is done during compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes it easier to migrate applications using the JPA Criteria API to Spring
    Data JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Complex queries are hard to implement and understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Querydsl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Querydsl** is a framework that enables the construction of type-safe dynamic
    queries through an API that resembles SQL (to learn more on Querydsl, visit [http://www.querydsl.com/](http://www.querydsl.com/)).
    If we want to create queries by using Querydsl, we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure Querydsl Maven Integration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate Querydsl query type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Querydsl support to a repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the executed query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the created query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will explain these steps in more detail in the following section and we will
    also take a look of the pros and cons of Querydsl.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Querydsl-Maven integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The configuration of the Querydsl-Maven integration consist of two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We configure the needed dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We configure the APT Maven plugin that is used for code generation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Querydsl Maven dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because we are using Querydsl with JPA, we have to declare the following dependencies
    in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Querydsl core that provides the core functions of Querydsl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querydsl APT, which provides support for APT based code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querydsl JPA, that adds support for JPA annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are using the Querydsl version 2.8.0\. Thus, we have to add the following
    dependency declarations to the dependencies section of the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the code generation Maven plugin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our next step is to configure the Maven plugin of the Annotation Processing
    Tool of Java 6, which is used to generate the Querydsl query types. We can configure
    this plugin by:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the plugin to execute its `process` goal in Maven's `generate-sources`
    lifecycle phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specifying the target directory in which the query types are generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the code generator to look for JPA annotations from entity classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The configuration of the Maven APT plugin is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Generating Querydsl query types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If our configuration is working properly, Querydsl query types should be generated
    automatically when we build our project with Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Maven APT plugin has a known issue that prevents its usage directly from
    Eclipse. Eclipse users must create the Querydsl query types manually by running
    the command `mvn generate-sources` at command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The query types are found from the `target/generated-sources` directory. The
    following rules will apply for the generated query types:'
  prefs: []
  type: TYPE_NORMAL
- en: Each query type is generated in the same package as the corresponding entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a query type class is built by appending the simple name of the
    entity class to a letter "`Q`". For example, since the name of our entity class
    is `Contac`t, the name of the corresponding Querydsl query type is `QContact`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can use the query types in our code, we must add the `target/generated-sources`
    directory as a source directory of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Querydsl support to a repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add Querydsl support to a repository by extending the `QueryDslPredicateExecutor<T>`
    interface. When we extend this interface we must give the type of the managed
    entity as a type parameter. The source code of the `ContactRepository` interface
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have extended the `QueryDslPredicateExecutor<T>` interface, we have
    access to the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `long count(Predicate p)` | Returns the number of entities matching with
    the given search criteria. |'
  prefs: []
  type: TYPE_TB
- en: '| `Iterable<Contact> findAll(Predicate p)` | Returns all entities matching
    with the given search criteria. |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact findOne(Predicate p)` | Returns a single entity matching with the
    given search criteria. |'
  prefs: []
  type: TYPE_TB
- en: Creating the executed query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each query must implement the `Predicate` interface that is provided by Querydsl.
    Luckily, we don''t have to implement this interface manually. Instead, we can
    use the query types for creating the actual query objects. A clean way to do this
    is to create a special predicate builder class and use a static method for creating
    the actual predicates. Let''s call this class `ContactPredicates`. Our implementation
    of the static method that creates predicates fulfilling the requirements of the
    search function is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We implement a static `firstOrLastNameStartsWith()` method that returns an implementation
    of the `Predicate` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a reference to the `QContact` query type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We build our query by using the `QContact` query type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our predicate builder class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Executing the created query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have implemented the `search()` method of the `RepositoryContactService`
    class by:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the used predicate by calling the static `firstOrLastNAmeStartsWith()`
    method of the `ContactPredicates` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting results by calling our repository method and passing the predicate as
    a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `CollectionUtils` class found from the `Commons Collections` library
    to add every contact to the returned list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our implementation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Pros and cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are now capable of creating queries by using Spring Data JPA and Querydsl.
    The pros and cons of Querydsl are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Supports dynamic queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean and understandable API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax verification is done during compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Requires code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse integration is not working properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: What technique should we use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the course of this section, we have been discussing different ways to create
    queries with Spring Data JPA. We are also aware of the pros and cons of each described
    technique. This information is refined to concrete guidelines that are given in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: We should use query methods for creating static queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the query generation from method name strategy if the created query
    is simple and the method name parser supports the required keywords. Otherwise,
    we should use the `@Query` annotation because of its flexibility and because it
    does not force us to use long and ugly method names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named queries are useful if we cannot create our query method by using the query
    generation from the method strategy or the `@Query` annotation. This approach
    can also be useful if we are migrating an existing application to Spring Data
    JPA. However, we should use them sparingly when we are creating new applications
    because they tend to litter our entities with query logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native queries are useful if we cannot create the query by using the other described
    techniques or if we need to tune up the performance of an individual query. However,
    we must understand that using native queries creates a dependency between our
    application and the used database schema. Also, if we use provider specific SQL
    extensions, our application is tied to the used database provider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should use the JPA Criteria API for creating dynamic queries if we are migrating
    an existing application that uses criteria queries to Spring Data JPA. The JPA
    Criteria API is also a valid option if we cannot live with the problems of the
    Querydsl-Eclipse integration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querydsl is a great choice for creating dynamic queries. It provides a clean
    and readable API, which is a huge benefit over the JPA Criteria API. Querydsl
    should be our first choice for creating dynamic queries from a scratch. The clumsy
    Eclipse integration is naturally a downside for Eclipse users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting query results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the course of this section, we will learn different techniques that can be
    used to sort query results with Spring Data JPA. We will also learn the guidelines
    that we can use to select a proper sorting method for each situation.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting with method name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we are building our queries by using the query generation from the method
    name strategy, we can sort query results by the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a query method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifying an existing service method to use the new query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the query method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we are building our queries by using the query generation from the method
    name strategy, we can use the `OrderBy` keyword to sort the query results when
    we:'
  prefs: []
  type: TYPE_NORMAL
- en: Append the `OrderBy` keyword to the method name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the property expression that corresponds to the property of the entity,
    which is used to sort the query results, to the method name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append a keyword describing the sorting order to the method name. If the query
    results are sorted in ascending order, the keyword `Asc` should be used. `Desc`
    keyword is used when the query results are sorted in descending order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 2 and step 3 if more than one property is used to sort the query
    results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can fulfill the new requirement of the search function by appending the
    string `OrderByLastNameAscFirstNameAsc` to the name of our query method. The signature
    of our query method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the service method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have to modify the `search()` method of the `RepositoryContactService` class
    to delegate the method call forward to the new query method. The source code of
    this method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Sorting with query strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, we have to add the sorting logic to the actual query string.
    If we are using named queries or native queries with the `@Query` annotation,
    we must provide the sorting logic in the actual query. It is also possible to
    add sorting logic to the actual query when we are using `@Query` annotation with
    JPQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: JPQL queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we want to sort the query results of a JPQL query, we must use the `ORDER
    BY` keyword of JPQL. The JPQL query that fulfills the new requirement of the search
    function is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: SQL queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we want to sort the query results of native SQL queries, we must use the
    `ORDER BY` keyword of SQL. The SQL query fulfilling the new requirement of the
    search function is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sorting with the Sort class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we are using the methods of the `JpaRepository<T,ID>` interface, query methods,
    or the JPA Criteria API, we can use the `Sort` class for sorting query results.
    If we decide to use this approach, we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `Sort` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the created instance as a parameter to the used repository method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We cannot use the `Sort` class to sort the query results of named queries or
    native queries declared with `@Query` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all the techniques that are described later need to get an instance of
    the `Sort` class, we will have to add a way to create these objects to the `RepositoryContactService`
    class. We will do this by creating a private `sortByLastNameAndFirstNameAsc()`
    method. The source code of this method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: JpaRepository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used the `findAll()` method of the `JpaRepository<T,ID>` interface to get
    a list of all the entities stored to the database. However, when we extended the
    `JpaRepository<T,ID>` interface, we also got access to the `List<Contact> findAll(Sort
    sort`) method which we can use to sort a list of entities that are stored to a
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we are going to sort the list of all the entities in ascending
    order by using last name and first name. We can do this by:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a new `Sort` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the sorted list of entities by calling the `findAll()` method of our
    repository and passing the created `Sort` object as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `findAll()` method of the `RepositoryContactService`
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Query generation from the method name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use this approach for sorting the query results of queries that
    are created by using the query generation from the method name strategy. If we
    want to use this technique, we have to modify the signature of our query method
    to take a `Sort` object as a parameter. The signature of our query method, which
    implements the new sorting requirement of the search function, is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to change the implementation of the `search()` method of the
    `RepositoryContactService` class. The new implementation is explained in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We get a reference to a `Sort` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call our new repository method and provide the needed parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our implementation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '@Query annotation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We don''t have to add the sorting logic to the actual query if we are using
    the `@Query` annotation for building queries with JPQL. We can also modify the
    signature of our query method to take a `Sort` object as a parameter. The declaration
    of our query method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to modify the `search()` method to the `RepositoryContactService`
    class. Our implementation of this method is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create the used like pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a reference to a `Sort` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call our repository method and provide the needed parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `search()` method looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: JPA Criteria API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to create queries by using JPA Criteria API, we had to modify the `ContactRepository`
    interface to extend the `JpaSpecificationExecutor<T>` interface. This gives us
    access to the `List<Contact> findAll(Specification spec, Sort sort)` method that
    returns a sorted list of entities matching the given search conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation of the `search()` method of the `RepositoryContactService`
    class is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We get the used search criteria by using our specification builder class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the used `Sort` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will call the `findAll()` method of the `ContactRepository` and provide the
    necessary parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our `search()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sorting with Querydsl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extending the `QuerydslPredicateExecutor<T>` interface in our contact repository
    gave us access to the `Iterable<Contact> findAll(Predicate predicate, OrderSpecifier<?>...
    orders)` method that returns a sorted list of all entities that match with the
    given search criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create a service method that creates an array of `OrderSpecifier`
    objects. The source code of the `sortByLastNameAndFirstNameAsc()` method is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to modify the implementation of the `search()` method of the
    `RepositoryContactService` class to fulfill the given requirements. Our implementation
    of the `search()` method is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We get the used search criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the used `OrderSpecifier` array by calling the `sortByLastNameAndFirstNameAsc()`
    method that we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `findAll()` method of the `ContactRepository` and provide the needed
    parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `CollectionUtils` class found from the `Commons Collections` library
    to add all contacts to the returned list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `search()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What technique should we use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best approach is to keep the query generation and sorting logic in the
    same place, if possible. In this way, we can check the implementation of our query
    by looking at one place, and one place only. This general guideline can be refined
    to the following concrete instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: If we are using the query generation from the method name, we should use this
    approach for sorting the query results. If the method name becomes too long or
    ugly, we can always use the `Sort` class for sorting our query results but this
    should not be our first choice. Instead, we should consider building our query
    by using the `@Query` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are using JPQL or SQL, we should add the sorting logic in our query string.
    This way we can check our query logic and sorting logic from the same place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are using named queries or native queries with the `@Query` annotation,
    we must add the sorting logic into our query string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are building our queries by using the JPA Criteria API, we must use
    the `Sort` class because that is only the method provided by the `JpaSpecificationExecutor<T>`
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are using Querydsl for building our queries, we must use the `OrderSpecifier`
    class to sort our query results because that is required by the `QueryDslPredicateExecutor<T>`
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paginating query results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Paginating query results is a very common requirement for practically every
    application that presents some kind of data. The key component of the pagination
    support of Spring Data JPA is the `Pageable` interface that declares the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int getPageNumber()` | Returns the number of the requested page. The page
    numbers are zero indexed. Thus, the number of the first page is zero. |'
  prefs: []
  type: TYPE_TB
- en: '| `int getPageSize()` | Returns the number of elements shown on a single page.
    The page size must always be larger than zero. |'
  prefs: []
  type: TYPE_TB
- en: '| `int getOffset()` | Returns the selected offset according to the given page
    number and page size. |'
  prefs: []
  type: TYPE_TB
- en: '| `Sort getSort()` | Returns the sorting parameters used to sort the query
    results. |'
  prefs: []
  type: TYPE_TB
- en: 'We can use this interface to paginate the query results with Spring Data JPA
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new `PageRequest` object. We can use the `PageRequest` class because
    it implements the `Pageable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passing the created object to a repository method as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we are using query methods for creating our queries, we have got two options
    for the return type of the query method:'
  prefs: []
  type: TYPE_NORMAL
- en: If we need to access the metadata of the requested page, we can make our query
    method return `Page<T>` where `T` is the type of the managed entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are interested in only getting the contacts of the requested page, we
    should make our query method return `List<T>`, where `T` is the type of the managed
    entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to add pagination to our contact manager application, we have to make
    changes to the service layer of our application and implement the pagination.
    Both of these tasks are described in more detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the service layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the Spring Data JPA repositories are just interfaces, we have to create
    the `PageRequest` objects on the service layer. This means that we have to figure
    out a way to pass the pagination parameters to the service layer and use these
    parameters to create the `PageRequest` object. We can achieve this goal by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class that stores the pagination parameters and the search term.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We change the method signatures of the service interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement a way to create `PageRequest` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a class for pagination parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we have to create a class that is used to store both the pagination parameters
    and the used search term. Spring Data provides a custom argument resolver called
    `PageableArgumentResolver` that will automatically build the `PageRequest` object
    by parsing the request parameters. More information about this approach is available
    at [http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/#web-pagination](http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/#web-pagination).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not use this approach since we don''t want to introduce a dependency
    between our web layer and Spring Data. Instead we will use a simple DTO that has
    only a few fields, and getters and setters. The source code of the `SearchDTO`
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Changing the service interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to change the `ContactService` interface of our example application
    in order to provide pagination support for both the contact list and the search
    result list. The required changes are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to replace the `findAll()` method with `findAllForPage()` method that
    takes the page number and the page size as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to modify the signature of the `search()` method to take `SearchDTO`
    as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signatures of changed methods are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Creating PageRequest objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can move forward to the actual implementations we have to add a new
    method to the `RepositoryContactService` class. This method is used to create
    `PageRequest` objects that are passed as a parameter to our repository. The implementation
    of the `buildPageSpecification()` method is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `sortByLastNameAndFirstNameAsc()` method to get a reference to the
    used `Sort` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the page number, page size, and the Sort object to create a new `PageRequest`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the relevant methods is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Implementing pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to paginate the results of our queries, we have to pass the created
    `PageRequest` object to a correct repository method. This method depends on the
    approach, which we are using to build our queries. Each of these approaches is
    described in this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: JpaRepository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the `ContactRepository` extends the `JpaRepository<T,ID>` interface,
    we got access to the `Page<Contact> findAll(Pageable page)` method that we can
    use to paginate the list of all entities. The implementation of the `findAllForPage()`
    method of the `RepositoryContactService` class is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We get the used `PageRequest` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a reference to `Page<Contact>` by calling the repository method and passing
    the `PageRequest` object as parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return a list of contacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our `findAllForPage()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Query generation from the method name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we are building our queries by using the query generation from the method
    name strategy, we can paginate query results by:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding pagination support to the query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the query method from a service method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding pagination support to the query method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adding pagination support to our query method is rather simple. All we have
    to do is make the following changes to the signature of the query method:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Pageable` interface as a parameter of the query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the return type of the query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we are not interested in the page metadata, the signature of our query
    method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the service class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The modifications needed by the `search()` method of the `RepositoryContactService`
    are rather simple. We get a reference to a `PageRequest` object and pass it as
    a parameter to our query method. The source code of the modified method is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Named queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to paginate the query results of named queries, we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add pagination support to the query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the query method from a service method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding pagination support to the query method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can add pagination support to a query method that is backed up by a named
    query by adding the `Pageable` interface as a parameter of the query method. At
    this point we do not need the page metadata for anything. Thus, the signature
    of our query method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the service class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our implementation of the `search()` method of the `RepositoryContactService`
    class is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We get the used like pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the required `PageRequest` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the list of contacts by calling the modified query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our modified `search()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '@Query annotation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can paginate the query results of JPQL queries built with the `@Query` annotation
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the pagination support to a query method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the query method from a service method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding pagination support to a query method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can add pagination support to a query method that is annotated with the
    `@Query` annotation by making the following changes to its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `Pageable` interface as a parameter of the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We determine the return type of the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point we are not interested in the metadata of the returned page. Thus,
    the declaration of the query method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the service method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The implementation of the `search()` method of the `RepositoryContactService`
    class is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We get the used like pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a reference to the used `PageRequest` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the list of contacts by calling the query method and passing the like
    pattern and the created `PageRequest` object as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the `search()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: JPA Criteria API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to build queries with the JPA Criteria API, the `ContactRepository`
    interface must extend the `JpaSpecificationExecutor<T>` interface. This gives
    us access to the `Page<Contact> findAll(Specification spec, Pageable page)` method
    that can be used to paginate the query results of criteria queries. The only thing
    that is left for us to do is to modify the `search()` method of the `RepositoryContactService`
    class. Our implementation is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We get the used specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the used `PageRequest` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the `Page` implementation by calling the repository method and passing
    the specification and the `PageRequest` object as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the requested list of contacts by calling the `getContent()` method
    of the `Page` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our search method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Querydsl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the `ContactRepository` interface extends the `QueryDslPredicateExecutor<T>`
    interface, we got access to the `Page<Contact> findAll(Predicate predicate, Pageable
    page)` method that we can use to paginate query results. In order to add pagination
    support to our search function, we have to make some changes to the existing `search()`
    method of the `RepositoryContactService` class. The new implementation of this
    method is described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We get a reference to the used `Predicate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the used `PageRequest` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get a `Page` reference by calling the repository method and passing the `Predicate`
    and `PageRequest` object as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the requested contacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of our new `search()` method looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned that:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use query generation from method name, named queries, or the `@Query`
    annotation for the purpose of creating query methods with Spring Data JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create dynamic queries by using either JPA Criteria API or Querydsl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are three different methods we can use to sort query results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are paginating the query results of a query method, the return type of
    the method can be either `List` or `Page`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each query creation method has its strengths and weaknesses that we must consider
    when we are selecting the correct solution for the current problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes we need to add custom functions to our repositories. This issue is
    addressed in the next chapter.
  prefs: []
  type: TYPE_NORMAL
