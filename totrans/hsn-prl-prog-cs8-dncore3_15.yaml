- en: Writing Unit Test Cases for Parallel and Asynchronous Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce how to write unit test cases for parallel
    and asynchronous code. Writing unit test cases is an important aspect of writing
    robust code that is easy to maintain when you're working with large teams.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: With the new CI/CD platforms, it's easier to make running unit test cases a
    part of the build process. This helps in finding issues at a very early stage.
    It also makes sense to write integration tests so that we can evaluate whether
    different components are working correctly together. Although you will find more
    features in Visual Studio's Community and Professional editions, only Visual Studio
    Enterprise edition has support for analyzing code coverage for unit test cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problems with writing unit test cases for async code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit test cases for parallel and async code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking the setup for async code using Moq
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using testing tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic understanding of unit testing and C# is required for learning how to
    write unit test cases using frameworks supported by Visual Studio. The source
    code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter11).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with .NET Core
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET Core supports three frameworks for writing unit tests, that is, MSTest,
    NUnit, and xUnit, as shown in the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5237ca31-885c-432b-9361-5d3ae572ecec.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Initially, the preferred framework for writing test cases was NUnit. Then,
    MSTest was added to Visual Studio, before xUnit was introduced into .NET Core.
    xUnit is a very lean version in comparison to NUnit and helps users write clean
    tests and take advantage of new features. Some of the benefits of xUnit are as
    follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: It is lightweight.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses new features.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has improved test isolation.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The xUnit creator is also from Microsoft and is a tool that's used within Microsoft.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Setup` and `TearDown` attributes have been replaced with a constructor
    and `System.IDisposable`, thereby forcing the developer to write clean code.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A unit test case is just a simple function that returns `void`, which is used
    to test the function logic and verify the output against a predefined set of inputs.
    To make the function recognizable as a test case, it must be decorated with the
    `[Fact]` attribute, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run this test case, we need to right-click on the function in the code and
    click Run Test(s) or Debug Test(s):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/481b8095-a846-48c1-95e7-9ec15d692b72.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'The output of the test case''s execution can be seen in the Test Explorer window:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c2e553e-e26e-4527-9f74-14522d4b2cb1.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: While this is fairly straightforward, writing unit test cases for parallel and
    asynchronous code is challenging. We'll discuss this in more detail in the next
    section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problems with writing unit test cases for async code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Async methods return a `Task` that needs to be awaited to get results. If it
    is not awaited, the method will return immediately, without waiting for the async
    task to finish. Consider the following method, which we''re using to write a unit
    test case with xUnit:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The method returns a constant value of 5 after a delay of 1 second. Since the
    method used `Task`, we made use of the `async` and `await` keywords to get the
    expected results. The following is a very simple test case we can use to test
    this method using MSTest:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the method should fail as the expected return value is 3 whereas
    the method is returning 5\. When we run this test, however, it passes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83e88031-cd3f-4584-be32-5e41af5e4369.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: What happened here is that, since the method is marked as async, it returned
    immediately when it encountered the `await` keyword. When a task is returned,
    it's deemed to run at a future point in time, but since the test case returned
    without any failures, it was marked as a pass by the test framework. This is a
    major cause of concern as this means the tests will pass, even if the task throws
    an exception.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding test case can be written slightly differently to make it run
    with MSTest:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same unit test case can be written in xUnit as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we run the preceding xUnit test case, it runs successfully. However, the
    problem with this code is that it''s a blocking test case, which can have a significant
    impact on the performance of our test suite. A better unit test case would be
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Initially, async unit test cases were not supported by every unit testing framework,
    as we saw in the case of MSTest. However, they are supported by xUnit and NUnit.
    The preceding test case once again returns as a success.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding unit test case can be written using NUnit as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are some differences here compared to the preceding code. The `[Fact]`
    attribute is replaced by `[Test]`, while `Assert.Equal` is replaced by `Assert.AreEqual`.
    The main difference, however, which you will see when you try running the preceding
    test case in Visual Studio, is that it will fail with the following error: `"Message:
    Async test method must have non-void return type"`. So, for NUnit, the method
    needs to be changed, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only difference here is that `void` is replaced with `Task`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen the problems that we may face when we use various
    frameworks that are provided for unit testing. Now, let's take a look at how to
    write better unit test cases.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit test cases for parallel and async code
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we learned how to write unit test cases for async
    code. In this section, we will discuss writing unit test cases for exception scenarios.
    Consider the following method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding method returns the result of the division of two numbers asynchronously.
    If the divisor is 0, then the `DivideByZero` exception is thrown by the method.
    We need two types of test cases to cover both scenarios:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Checking for a successful result
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for an exception result when the divisor is 0
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for a successful result
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test case will look as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the expected result is `5`. When we run the test, it will show
    up as successful in the Test Explorer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Checking for an exception result when the divisor is 0
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can write a test case for a method that throws an exception using the `Assert.ThrowsAsync<>`
    method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we checked the assertion using `Assert.ThrowsAsync<DivideByZeroException>`
    while calling the `GetDivisionAsync` method asynchronously. Since we pass the
    `divisor` as `0`, the method will throw an exception and the assertion will hold
    true.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the setup for async code using Moq
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking objects is a very important aspect of unit testing. As you may be aware,
    unit testing is about testing one module at a time; any external dependency is
    assumed to be working fine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many mocking frameworks available for .NET, including the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: NSubstitute (not supported in .NET core)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rhino Mocks (not supported in .NET core)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moq (supported in .NET core)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NMock3 (not supported in .NET core)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the sake of demonstration, we will be using Moq to mock our serviced components.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a simple service containing asynchronous methods.
    Then, we will try to write unit test cases for the methods that call the service. Let''s
    consider a service interface:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see, the interface has a `GetDataAsync()` method, which fetches data
    in an asynchronous manner. The following snippet shows a controller class that
    makes use of some dependency injection frameworks to gain access to the service
    instance:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding `Controller` class also exposes an asynchronous method called
    `DisplayData()`, which fetches data from a service and writes it to the console.
    When we try to write a unit test case for the preceding method, the first problem
    we will encounter is that we have no way of creating the service instance in the
    absence of any concrete implementation. Even if we do have a concrete implementation,
    we should avoid calling the actual service method as this would be more appropriate
    in an integration test case rather than a unit test case. Mocking comes to our
    rescue here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to write a unit test case for the preceding method using Moq:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: We need to install `Moq` as a NuGet package.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the namespace for it as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a mock object, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Set up a mock object that returns dummy data. This can be achieved using the
    `Task.FromResult` method, as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we need to create a controller object by passing the mocked object we
    just created:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is a simple test case for the `DisplayData()` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code shows how we can set up data for mock objects. Another way
    to set up data for mock objects is via the `TaskCompletionSource` class, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since the number of test cases can really grow in an enterprise project, the
    need to be able to find and execute test cases arises. In the next section, we
    will discuss some common testing tools in Visual Studio that can help us manage
    the test case execution process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Testing tools
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important tools in Visual Studio to run a test or see the results
    of test execution is Test Explorer. We had a brief look at Test Explorer at the
    start of this chapter. One key feature of Test Explorer is its ability to run
    test cases in parallel. If you have a system with multiple cores, you can easily
    take advantage of parallelism to run test cases faster. This can be done by clicking
    on the Run Tests in parallel toolbar button in Test Explorer:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d4af856-f5cb-4377-858c-7b492f84903d.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Depending on your version of Visual Studio, some additional support is provided
    by Microsoft. One useful tool is the option to generate unit test cases automatically
    using **Intellitest.** Intellitest analyzes your source code and automatically
    generates test cases, test data, and test suites. Intellitest isn't supported
    in .NET core yet, though it's available for other versions of the .NET Framework.
    It's likely to have a future upgrade to Visual Studio.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about writing unit test cases for async methods,
    which helps in achieving robust code, supporting large teams, and adapting to
    new CI/CD platforms, which helps in finding issues at a very early stage. We started
    by introducing a few problems that you may come across while writing unit test
    cases for parallel and async code and how you can mitigate them using correct
    coding practices. Then, we moved on and looked at mocking, which is a very important
    aspect of unit testing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We learned that Moq has support for .NET Core and that .NET Core is evolving
    very fast; soon, there will be support for all the major mocking frameworks. All
    the steps for writing test cases were explained as well, including installing
    Moq as a NuGet package and setting up data for mock objects. Finally, we explored
    the features of an important testing tool, Test Explorer, which we can use to
    write cleaner test cases, and how to parallelize unit test cases for faster execution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the concepts and roles of IIS and Kestrel in
    a .NET Core web application development environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these is not a supported unit testing framework in Visual Studio?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JUnit
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NUnit
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: xUnit
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MSTest
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we check the output of a unit test case?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the Task Explorer window
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the Test Explorer window
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which attributes can you apply to a test method when the testing framework is
    xUnit?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fact
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TestMethod
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you verify the success of a test case that throws an exception?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何验证抛出异常的测试用例的成功？
- en: '`Assert.AreEqual(ex, typeof(Exception)`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assert.AreEqual(ex, typeof(Exception)`'
- en: '`Assert.IsException`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assert.IsException`'
- en: '`Assert.ThrowAsync<T>`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Assert.ThrowAsync<T>`'
- en: Which of these mocking frameworks is supported in .NET Core?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些模拟框架中哪些受到.NET Core的支持？
- en: NSubstitute
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NSubstitute
- en: Moq
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Moq
- en: Rhino Mocks
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rhino Mocks
- en: NMock
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NMock
- en: Further reading
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can read about parallel programming and unit testing techniques at the
    following web pages:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网页上了解并行编程和单元测试技术：
- en: '[https://www.packtpub.com/application-development/c-multithreaded-and-parallel-programming](https://www.packtpub.com/application-development/c-multithreaded-and-parallel-programming)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c-multithreaded-and-parallel-programming](https://www.packtpub.com/application-development/c-multithreaded-and-parallel-programming)'
- en: '[https://www.packtpub.com/application-development/net-45-parallel-extensions-cookbook](https://www.packtpub.com/application-development/net-45-parallel-extensions-cookbook)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/net-45-parallel-extensions-cookbook](https://www.packtpub.com/application-development/net-45-parallel-extensions-cookbook)'
