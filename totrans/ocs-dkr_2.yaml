- en: Chapter 2. Docker CLI and Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we set up Docker in our development setup and ran our first
    container. In this chapter, we will explore the Docker command-line interface.
    Later in the chapter, we will see how to create our own Docker images using Dockerfiles
    and how to automate this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker terminologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker workflow—pull-use-modify-commit-push workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker terminologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin our exciting journey into the Docker sphere, let's understand
    the Docker terminologies that will be used in this book a little better. Very
    similar in concept to VM images, a Docker image is a snapshot of a system. The
    difference between a VM image and a Docker image is that a VM image can have running
    services, whereas a Docker image is just a filesystem snapshot, which means that
    while you can configure the image to have your favorite packages, you can run
    only one command in the container. Don't fret though, since the limitation is
    one command, not one process, so there are ways to get a Docker container to do
    almost anything a VM instance can.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has also implemented a Git-like distributed version management system
    for Docker images. Images can be stored in repositories (called a registry), both
    locally and remotely. The functionalities and terminologies borrow heavily from
    Git—snapshots are called commits, you pull an image repository, you push your
    local image to a repository, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Docker container can be correlated to an instance of a VM. It runs sandboxed
    processes that share the same kernel as the host. The term **container** comes
    from the concept of shipping containers. The idea is that you can ship containers
    from your development environment to the deployment environment and the applications
    running in the containers will behave the same way no matter where you run them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the layers of AUFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker container](graphics/4787OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is similar in context to a shipping container, which stays sealed until
    delivery but can be loaded, unloaded, stacked, and transported in between.
  prefs: []
  type: TYPE_NORMAL
- en: The visible filesystem of the processes in the container is based on AUFS (although
    you can configure the container to run with a different filesystem too). AUFS
    is a layered filesystem. These layers are all read-only and the merger of these
    layers is what is visible to the processes. However, if a process makes a change
    in the filesystem, a new layer is created, which represents the difference between
    the original state and the new state. When you create an image out of this container,
    the layers are preserved. Thus, it is possible to build new images out of existing
    images, creating a very convenient hierarchical model of images.
  prefs: []
  type: TYPE_NORMAL
- en: The docker daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker` daemon is the process that manages containers. It is easy to get
    this confused with the Docker client because the same binary is used to run both
    the processes. The `docker` daemon, though, needs the `root` privileges, whereas
    the client doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, since the `docker` daemon runs with root privileges, it also
    introduces an attack vector. Read [https://docs.Docker.com/articles/security/](https://docs.Docker.com/articles/security/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Docker client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docker client is what interacts with the `docker` daemon to start or manage
    containers. Docker uses a RESTful API to communicate between the client and the
    daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REST is an architectural style consisting of a coordinated set of architectural
    constraints applied to components, connectors, and data elements within a distributed
    hypermedia system. In plain words, a RESTful service works over standard HTTP
    methods such as the `GET`, `POST`, `PUT`, and `DELETE` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Dockerfile is a file written in a **Domain** **Specific** **Language** (**DSL**)
    that contains instructions on setting up a Docker image. Think of it as a Makefile
    equivalent of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the public repository of all Docker images published by the Docker community.
    You can pull images from this registry freely, but to push images, you will have
    to register at [http://hub.docker.com](http://hub.docker.com). Docker registry
    and Docker hub are services operated and maintained by Docker Inc., and they provide
    unlimited free repositories. You can also buy private repositories for a fee.
  prefs: []
  type: TYPE_NORMAL
- en: Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's get our hands dirty on the Docker CLI. We will look at the most common
    commands and their use cases. The Docker commands are modeled after Linux and
    Git, so if you have used either of these, you will find yourself at home with
    Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Only the most commonly used options are mentioned here. For the complete reference,
    you can check out the official documentation at [https://docs.docker.com/reference/commandline/cli/](https://docs.docker.com/reference/commandline/cli/).
  prefs: []
  type: TYPE_NORMAL
- en: The daemon command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have installed the `docker` daemon through standard repositories, the
    command to start the `docker` daemon would have been added to the `init` script
    to automatically start as a service on startup. Otherwise, you will have to first
    run the `docker` daemon yourself for the client commands to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, while starting the daemon, you can run it with arguments that control
    the **Domain** **Name** **System** (**DNS**) configurations, storage drivers,
    and execution drivers for the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll need these only if you want to start the daemon yourself. Otherwise,
    you can start the `docker` daemon with `$ sudo service Docker start`. For OSX
    and Windows, you need to run the commands mentioned in [Chapter 1](ch01.html "Chapter 1. Unboxing
    Docker"), *Installing Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes the various flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| This runs Docker as a daemon. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| This runs Docker in debug mode. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the execution driver to be used. The default execution driver is
    native, which uses `libcontainer`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| This forces Docker to use a different storage driver. The default value is
    "", for which Docker uses AUFS. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| This sets the DNS server (or servers) for all Docker containers. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| This sets the DNS search domain (or domains) for all Docker containers. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the socket (or sockets) to bind to. It can be one or more of `tcp://host:port,
    unix:///path/to/socket, fd://* or fd://socketfd`. |'
  prefs: []
  type: TYPE_TB
- en: If multiple `docker` daemons are being simultaneously run, the client honors
    the value set by the `DOCKER_HOST` parameter. You can also make it connect to
    a specific daemon with the `-H` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is the same as the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The version command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `version` command prints out the version information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The info command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `info` command prints the details of the `docker` daemon configuration
    such as the execution driver, the storage driver being used, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The run command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The run command is the command that we will be using most frequently. It is
    used to run Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '| Flags | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| Attach to the `stdin`, `stdout`, or `stderr` files (standard input, output,
    and error files.). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| This runs the container in the background. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| This runs the container in interactive mode (keeps the `stdin` file open).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| This allocates a pseudo `tty` flag (which is required if you want to attach
    to the container''s terminal). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| This publishes a container''s port to the host (`ip:hostport:containerport`).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| This automatically removes the container when exited (it cannot be used with
    the `-d` flag). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| This gives additional privileges to this container. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| This bind mounts a volume (from host => `/host:/container`; from docker =>
    `/container`). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| This mounts volumes from specified containers. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the working directory inside the container. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| This assigns a name to the container. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| This assigns a hostname to the container. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the username or UID the container should run on. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| This sets the environment variables. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| This reads environment variables from a new line-delimited file. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| This sets custom DNS servers. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| This sets custom DNS search domains. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '| This adds link to another container (`name:alias`). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the relative CPU share for this container. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '| These are the CPUs in which to allow execution; starts with 0\. (For example,
    0 to 3). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the memory limit for this container `(<number><b&#124;k&#124;m&#124;g>`).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '| (v1.2+) This specifies a restart policy in case the container crashes. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '| (v1.2+) This grants a capability to a container (refer to [Chapter 4](ch04.html
    "Chapter 4. Automation and Best Practices"), *Security Best Practices*). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '| (v1.2+) This blacklists a capability to a container (refer to [Chapter 4](ch04.html
    "Chapter 4. Automation and Best Practices"), *Security Best Practices*). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '| (v1.2+) This mounts a device on a container. |'
  prefs: []
  type: TYPE_TB
- en: 'While running a container, it is important to keep in mind that the container''s
    lifetime is associated with the lifetime of the command you run when you start
    the container. Now try to run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: What happened here? When we ran the simple command, `ps`, the container ran
    the command and exited. Therefore, we got an error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `attach` command attaches the standard input and output to a running container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important piece of information here is that you don''t need to use
    the whole 64-character ID for all the commands that require the container ID.
    The first couple of characters are sufficient. With the same example as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A more convenient method though would be to name your containers yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` flag is necessary to have any kind of interaction in the container,
    and the `-t` flag is necessary to create a pseudo-terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example also made us aware of the fact that even after we exit
    a container, it is still in a `stopped` state. That is, we will be able to start
    the container again, with its filesystem layer preserved. You can see this by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'While this can be convenient, you may pretty soon have your host''s disk space
    drying up as more and more containers are saved. So, if you are going to run a
    disposable container, you can run it with the `–-rm` flag, which will remove the
    container when the process exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Running a server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, for our next example, we''ll try running a web server. This example is
    chosen because the most common practical use case of Docker containers is the
    shipping of web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we know the problem; we have a server running in a container, but since
    the container''s IP is assigned by Docker dynamically, it makes things difficult.
    However, we can bind the container''s ports to the host''s ports and Docker will
    take care of forwarding the networking traffic. Now let''s try this command again
    with the `-p` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now open your browser and go to `http://localhost:8000`. Voilà!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are an OS X user and you realize that you are not able to access `http://localhost:8000`,
    it is because VirtualBox hasn''t been configured to respond to **Network Address
    Translation** (**NAT**) requests to the boot2Docker VM. Adding the following function
    to your aliases file (`bash_profile` or .`bashrc`) will save a lot of trouble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you should be able to use the `$ natboot2docker mypythonserver
    8000 8000` command to be able to access the Python server. But remember to run
    the `$ removeDockerDockerNat mypythonserver` command when you are done. Otherwise,
    when you run the boot2Docker VM next time, you will be faced with a bug that won''t
    allow you to get the IP address or the `ssh` script into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Your browser now shows the `/root` path of the container. What if you wanted
    to serve your host''s directories? Let''s try mounting a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `mount` command doesn't work. In fact, most kernel capabilities
    that are potentially dangerous are dropped, unless you include the `--privileged`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you should never use this flag unless you know what you are doing.
    Docker provides a much easier way to bind mount host volumes and bind mount host
    volumes with the `-v` and `–volumes` options. Let''s try this example again in
    the directory we are currently in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You have now bound the directory you are running the commands from to the container.
    However, when you access the container, you still get the directory listing of
    the root of the container. To serve the directory that has been bound to the container,
    let''s set it as the working directory of the container (the directory the containerized
    process runs in) using the `-w` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boot2Docker users will not be able to utilize this yet, unless you use guest
    additions and set up shared folders, the guide to which can be found at [https://medium.com/boot2docker-lightweight-linux-for-docker/boot2docker-together-with-virtualbox-guest-additions-da1e3ab2465c](https://medium.com/boot2docker-lightweight-linux-for-docker/boot2docker-together-with-virtualbox-guest-additions-da1e3ab2465c).
    Though this solution works, it is a hack and is not recommended. Meanwhile, the
    Docker community is actively trying to find a solution (check out issue `#64`
    in the boot2Docker GitHub repository and `#4023` in the Docker repository).
  prefs: []
  type: TYPE_NORMAL
- en: Now `http://localhost:8000` will serve the directory you are currently running
    in, but from a Docker container. Take care though, because any changes you make
    are written into the host's filesystem as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since v1.1.1, you can bind mount the root of the host to a container using `$
    docker run -v /:/my_host:ro ubuntu ls /my_host`, but mounting on the `/` path
    of the container is forbidden.
  prefs: []
  type: TYPE_NORMAL
- en: The volume can be optionally suffixed with the `:ro` or `:rw` commands to mount
    the volumes in read-only or read-write mode, respectively. By default, the volumes
    are mounted in the same mode (read-write or read-only) as they are in the host.
  prefs: []
  type: TYPE_NORMAL
- en: This option is mostly used to mount static assets and to write logs.
  prefs: []
  type: TYPE_NORMAL
- en: But what if I want to mount an external device?
  prefs: []
  type: TYPE_NORMAL
- en: Before v1.2, you had to mount the device in the host and bind mount using the
    `-v` flag in a privileged container, but v1.2 has added a `--device` flag that
    you can use to mount a device without needing to use the `--privileged` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to use the webcam in your container, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker v1.2 also added a `--restart` flag to specify a restart policy for containers.
    Currently, there are three restart policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`no`: Do not restart the container if it dies (default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on-failure`: Restart the container if it exits with a non-zero exit code.
    It can also accept an optional maximum restart count (for example, `on-failure:5`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always`: Always restart the container no matter what exit code is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example to restart endlessly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line is used to try five times before giving up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The search command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `search` command allows us to search for Docker images in the public registry.
    Let''s search for all images related to Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The pull command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pull` command is used to pull images or repositories from a registry.
    By default, it pulls them from the public Docker registry, but if you are running
    your own registry, you can pull them from it too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The start command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw when we discussed `docker run` that the container state is preserved
    on exit unless it is explicitly removed. The `docker start` command starts a stopped
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example of the `start` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The options have the same meaning as with the `docker run` command.
  prefs: []
  type: TYPE_NORMAL
- en: The stop command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `stop` command stops a running container by sending the `SIGTERM` signal
    and then the `SIGKILL` signal after a grace period:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SIGTERM` and `SIGKILL` are Unix signals. A signal is a form of interprocess
    communication used in Unix, Unix-like, and other POSIX-compliant operating systems.
    `SIGTERM` signals the process to terminate. The `SIGKILL` signal is used to forcibly
    kill a process.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify the `-t` flag or `--time` flag, which allows you to set
    the wait time.
  prefs: []
  type: TYPE_NORMAL
- en: The restart command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `restart` command restarts a running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you observe the status, you will notice that the container was rebooted.
  prefs: []
  type: TYPE_NORMAL
- en: The rm command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rm` command removes Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We seem to be having a lot of containers left over after our adventures. Let''s
    remove one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also combine two Docker commands. Let''s combine the `docker ps -a -q`
    command, which prints the ID parameters of the containers in the `docker ps -a`,
    and `docker rm` commands, to remove all containers in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This evaluates the `docker ps -a -q` command first, and the output is used by
    the `docker rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: The ps command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ps` command is used to list containers. It is used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '| Flag | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows all containers, including stopped ones. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows only container ID parameters. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '| This prints the sizes of the containers. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows only the latest container (including stopped containers). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows the last *n* containers (including stopped containers). Its default
    value is -1. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows the containers created before the specified ID or name. It includes
    stopped containers. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows the containers created after the specified ID or name. It includes
    stopped containers. |'
  prefs: []
  type: TYPE_TB
- en: The `docker ps` command will show only running containers by default. To see
    all containers, run the `docker ps -a` command. To see only container ID parameters,
    run it with the `-q` flag.
  prefs: []
  type: TYPE_NORMAL
- en: The logs command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `logs` command shows the logs of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You can also provide a `--tail` argument to follow the output as the container
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: The inspect command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `inspect` command allows you to get the details of a container or an image.
    It returns those details as a JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for a container we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Docker inspect provides all of the low-level information about a container or
    image. In the preceding example, find out the IP address of the container and
    the exposed port and make a request to the `IP:port`. You will see that you are
    directly accessing the server running in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, manually looking through the entire JSON array is not optimal. So
    the `inspect` command provides a flag, `-f` (or the `--follow` flag), which allows
    you to specify exactly what you want using `Go` templates. For example, if you
    just want to get the container''s IP address, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `{{.NetworkSettings.IPAddress}}` is a `Go` template that was executed over
    the JSON result. `Go` templates are very powerful, and some of the things that
    you can do with them have been listed at [http://golang.org/pkg/text/template/](http://golang.org/pkg/text/template/).
  prefs: []
  type: TYPE_NORMAL
- en: The top command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `top` command shows the running processes in a container and their statistics,
    mimicking the Unix `top` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s download and run the `ghost` blogging platform and check out what processes
    are running in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Yes! We just set up our very own `ghost` blog, with just one command. This brings
    forth another subtle advantage and shows something that could be a future trend.
    Every tool that exposes its services through a TCP port can now be containerized
    and run in its own sandboxed world. All you need to do is expose its port and
    bind it to your host port. You don't need to worry about installations, dependencies,
    incompatibilities, and so on, and the uninstallation will be clean because all
    you need to do is stop all the containers and remove the image.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ghost is an open source publishing platform that is beautifully designed, easy
    to use, and free for everyone. It is coded in Node.js, a server-side JavaScript
    execution engine.
  prefs: []
  type: TYPE_NORMAL
- en: The attach command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `attach` command attaches to a running container.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start a container with Node.js, running the node interactive shell as
    a daemon, and later attach to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node.js is an event-driven, asynchronous I/O web framework that runs applications
    written in JavaScript on Google's V8 runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container with Node.js is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The kill command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `kill` command kills a container and sends the `SIGTERM` signal to the
    process running in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The cp command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cp` command copies a file or folder from a container's filesystem to the
    host path. Paths are relative to the root of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to have some fun. First, let''s run an Ubuntu container with the
    `/bin/bash` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the container, let''s create a file with a special name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `\007` character is an ASCII `BEL` character that rings the system bell
    when printed on a terminal. You might have already guessed what we''re about to
    do. So let''s open a new terminal and execute the following command to copy this
    newly created file to the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the `docker cp` command to work, both the container path and the host path
    must be complete, so do not use shortcuts such as `.`, `,`, `*`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we created an empty file whose filename is the `BEL` character, in a container.
    Then we copied the file to the current directory in the host container. Just one
    last step is remaining. In the host tab where you executed the `docker cp` command,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You will hear the system bell ring! We could have copied any file or directory
    from the container to the host. But it doesn't hurt to have some fun!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you found this interesting, you might like to read [http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html](http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html).
    This is a great essay that discusses the edge cases in filenames, which can cause
    simple to complicated issues in a program.
  prefs: []
  type: TYPE_NORMAL
- en: The port command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `port` command looks up the public-facing port that is bound to an exposed
    port in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Ghost runs a server at the `2368` port that allows you to write and publish
    a blog post. We bound a host port to the `OD-ghost` container's port `2368` in
    the example for the `top` command.
  prefs: []
  type: TYPE_NORMAL
- en: Running your own project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we are considerably familiar with the basic Docker commands. Let's up
    the ante. For the next couple of commands, I am going to use one of my side projects.
    Feel free to use a project of your own.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by listing out our requirements to determine the arguments we must
    pass to the `docker run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application is going to run on Node.js, so we will choose the well-maintained
    `dockerfile/nodejs` image to start our base container:'
  prefs: []
  type: TYPE_NORMAL
- en: We know that our application is going to bind to port `8000`, so we will expose
    the port to `8000` of the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to give a descriptive name to the container so that we can reference
    it in future commands. In this case, let''s choose the name of the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Once you have started your container, you need to check whether the dependencies
    for your application are already available. In our case, we only need Git (apart
    from Node.js), which is already installed in the `dockerfile/nodejs` image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our container is ready to run our application, all that is remaining
    is for us to fetch the source code and do the necessary setup to run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This downloads the source code for a plugin used in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now all the node modules required to run the application are installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now you can go to `localhost:8000` to use the application.
  prefs: []
  type: TYPE_NORMAL
- en: The diff command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `diff` command shows the difference between the container and the image
    it is based on. In this example, we are running a container with `code.it`. In
    a separate tab, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The commit command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `commit` command creates a new image with the filesystem of the container.
    Just as with Git''s `commit` command, you can set a commit message that describes
    the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '| Flag | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '| This pause the container during commit (availabe from v1.1.1+ onwards). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '| This is a commit message. It can be a description of what the image does.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '| This displays the author details. |'
  prefs: []
  type: TYPE_TB
- en: 'For example, let''s use this command to commit the container we have set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replace the author details and the username portion of the image name in this
    example if you are copying these examples.
  prefs: []
  type: TYPE_NORMAL
- en: The output will be a lengthy image ID. If you look at the command closely, we
    have named the image `shrikrishna/code.it:v1`. This is a convention. The first
    part of an image/repository's name (before the forward slash) is the Docker Hub
    username of the author. The second part is the intended application or image name.
    The third part is a tag (usually a version description) separated from the second
    part by a colon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Docker` `Hub` is a public registry maintained by Docker, Inc. It hosts public
    Docker images and provides services to help you build and manage your Docker environment.
    More details about it can be found at [https://hub.docker.com](https://hub.docker.com).'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of images tagged with different versions is a repository. The image
    you create by running the `docker commit` command will be a local one, which means
    that you will be able to run containers from it but it won't be available publicly.
    To make it public or to push to your private Docker registry, use the `docker
    push` command.
  prefs: []
  type: TYPE_NORMAL
- en: The images command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `images` command lists all the images in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '| Flag | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows all images, including intermediate layers. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '| This provides filter values. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '| This doesn''t truncate output (shows complete ID). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows only the image IDs. |'
  prefs: []
  type: TYPE_TB
- en: 'Now let''s look at a few examples of the usage of the `image` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This lists all top-level images, their repository and tags, and their virtual
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images are nothing but a stack of read-only filesystem layers. A union
    filesystem, such as AUFS, then merges these layers and they appear to be one filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In Docker-speak, a read-only layer is an image. It never changes. When running
    a container, the processes think that the entire filesystem is read-write. But
    the changes go only at the topmost writeable layer, which is created when a container
    is started. The read-only layers of the image remain unchanged. When you commit
    a container, it freezes the top layer (the underlying layers are already frozen)
    and turns it into an image. Now, when a container is started this image, all the
    layers of the image (including the previously writeable layer) are read-only.
    All the changes are now made to a new writeable layer on top of all the underlying
    layers. However, because of how union filesystems (such as AUFS) work, the processes
    believe that the filesystem is read-write.
  prefs: []
  type: TYPE_NORMAL
- en: 'A rough schematic of the layers involved in our `code.it` example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The images command](graphics/4787OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, it might be wise to think just how much effort is to be made
    by the union filesystems to merge all of these layers and provide a consistent
    performance. After some point, things inevitably break. AUFS, for instance, has
    a 42-layer limit. When the number of layers goes beyond this, it just doesn't
    allow the creation of any more layers and the build fails. Read [https://github.com/docker/docker/issues/1171](https://github.com/docker/docker/issues/1171)
    for more information on this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command lists the most recently created images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f` flag can be given arguments of the `key=value` type. It is frequently
    used to get the list of dangling images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This will display untagged images, that is, images that have been committed
    or built without a tag.
  prefs: []
  type: TYPE_NORMAL
- en: The rmi command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rmi` command removes images. Removing an image also removes all the underlying
    images that it depends on and were downloaded when it was pulled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '| Flag | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '| This forcibly removes the image (or images). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '| This command does not delete untagged parents. |'
  prefs: []
  type: TYPE_TB
- en: 'This command removes one of the images from your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The save command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `save` command saves an image or repository in a tarball and this streams
    to the `stdout` file, preserving the parent layers and metadata about the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The `-o` flag allows us to specify a file instead of streaming to the `stdout`
    file. It is used to create a backup that can then be used with the `docker load`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: The load command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `load` command loads an image from a tarball, restoring the filesystem
    layers and the metadata associated with the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` flag allows us to specify a file instead of trying to get a stream
    from the `stdin` file.
  prefs: []
  type: TYPE_NORMAL
- en: The export command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `export` command saves the filesystem of a container as a tarball and streams
    to the `stdout` file. It flattens filesystem layers. In other words, it merges
    all the filesystem layers. All of the metadata of the image history is lost in
    this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Here, `red_panda` is the name of one of my containers.
  prefs: []
  type: TYPE_NORMAL
- en: The import command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `import` command creates an empty filesystem image and imports the contents
    of the tarball to it. You have the option of tagging it the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: URLs must start with `http`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to import from a local directory or archive, you can use
    the - parameter to take the data from the `stdin` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The tag command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can add a `tag` command to an image. It helps identify a specific version
    of an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `python` image name represents `python:latest`, the latest
    version of Python available, which can change from time to time. But whenever
    it is updated, the older versions are tagged with the respective Python versions.
    So the `python:2.7` command will have Python 2.7 installed. Thus, the `tag` command
    can be used to represent versions of the images, or for any other purposes that
    need identification of the different versions of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The `REGISTRYHOST` command is only needed if you are using a private registry
    of your own. The same image can have multiple tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you are tagging an image, follow the `username/repository:tag` convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, running the `docker images` command again will show that the same image
    has been tagged with both the `v1` and `latest` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The login command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `login` command is used to register or log in to a Docker registry server.
    If no server is specified, [https://index.docker.io/v1/](https://index.docker.io/v1/)
    is the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '| Flag | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '| Email |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '| Password |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '| Username |'
  prefs: []
  type: TYPE_TB
- en: If the flags haven't been provided, the server will prompt you to provide the
    details. After the first login, the details will be stored in the `$HOME/.dockercfg`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: The push command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `push` command is used to push an image to the public image registry or
    a private Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The history command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `history` command shows the history of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The events command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once started, the `events` command prints all the events that are handled by
    the `docker` daemon, in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '| Flag | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '| This shows all events created since timestamp (in Unix). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '| This stream events until timestamp. |'
  prefs: []
  type: TYPE_TB
- en: 'For example the `events` command is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in a different tab, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go back to the tab running Docker events and see the output. It will be
    along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: You can use flags such as `--since` and `--until` to get the event logs of specific
    timeframes.
  prefs: []
  type: TYPE_NORMAL
- en: The wait command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `wait` command blocks until a container stops, then prints its exit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The build command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The build command builds an image from the source files at a specified path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '| Flag | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the repository name (and an optional tag) to be applied to the resulting
    image in case of success. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '| This suppresses the output, which by default is verbose. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '| This removes intermediate containers after a successful build. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '| This always removes intermediate containers, even after unsuccessful builds.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '| This command does not use the cache while building the image. |'
  prefs: []
  type: TYPE_TB
- en: This command uses a Dockerfile and a context to build a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: A Dockerfile is like a Makefile. It contains instructions on the various configurations
    and commands that need to be run in order to create an image. We will look at
    writing Dockerfiles in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be a good idea to read the section about Dockerfiles first and then
    come back here to get a better understanding of this command and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The files at the `PATH` or `URL` paths are called **context** of the build.
    The context is used to refer to the files or folders in the Dockerfile, for instance
    in the `ADD` instruction (and that is the reason an instruction such as `ADD ../file.txt`
    won't work. It's not in the context!).
  prefs: []
  type: TYPE_NORMAL
- en: When a GitHub URL or a URL with the `git://` protocol is given, the repository
    is used as the context. The repository and its submodules are recursively cloned
    in your local machine, and then uploaded to the `docker` daemon as the context.
    This allows you to have Dockerfiles in your private Git repositories, which you
    can access from your local user credentials or from the **Virtual** **Private**
    **Network** (**VPN**).
  prefs: []
  type: TYPE_NORMAL
- en: Uploading to Docker daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that Docker engine has both the `docker` daemon and the Docker client.
    The commands that you give as a user are through the Docker client, which then
    talks to the `docker` daemon (either through a TCP or a Unix socket), which does
    the necessary work. The `docker` daemon and Docker host can be in different hosts
    (which is the premise with which boot2Docker works), with the `DOCKER_HOST` environment
    variable set to the location of the remote `docker` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: When you give a context to the `docker build` command, all the files in the
    local directory get tared and are sent to the `docker` daemon. The `PATH` variable
    specifies where to find the files for the context of the build in the `docker`
    daemon. So when you run `docker build .`, all the files in the current folder
    get uploaded, not just the ones listed to be added in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Since this can be a bit of a problem (as some systems such as Git and some IDEs
    such as Eclipse create hidden folders to store metadata), Docker provides a mechanism
    to ignore certain files or folders by creating a file called `.dockerignore` in
    the `PATH` variable with the necessary exclusion patterns. For an example, look
    up [https://github.com/docker/docker/blob/master/.dockerignore](https://github.com/docker/docker/blob/master/.dockerignore).
  prefs: []
  type: TYPE_NORMAL
- en: If a plain URL is given or if the Dockerfile is streamed through the `stdin`
    file, then no context is set. In these cases, the `ADD` instruction works only
    if it refers to a remote URL.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's build the `code.it` example image through a Dockerfile. The instructions
    on how to create this Dockerfile are provided in the *Dockerfile* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you would have created a directory and placed the Dockerfile
    inside it. Now, on your terminal, go to that directory and execute the `docker`
    `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Now, you will be able to look at your newly built image in the output of Docker
    images
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: To see the caching in action, run the same command again
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now experiment with this caching. Change one of the lines in the middle (the
    port number for example), or add a `RUN echo "testing cache"` line somewhere in
    the middle and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of building an image using a repository URL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to create images by committing containers. What if you want
    to update the image with new versions of dependencies or new versions of your
    own application? It soon becomes impractical to do the steps of starting, setting
    up, and committing over and over again. We need a repeatable method to build images.
    In comes Dockerfile, which is nothing more than a text file that contains instructions
    to automate the steps you would otherwise have taken to build an image. `docker
    build` will read these instructions sequentially, committing them along the way,
    and build an image.
  prefs: []
  type: TYPE_NORMAL
- en: The `docker build` command takes this Dockerfile and a context to execute the
    instructions, and builds a Docker image. Context refers to the path or source
    code repository URL given to the `docker build` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Dockerfile contains instructions in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Any line beginning with `#` will be considered as a comment. If a `#` sign is
    present anywhere else, it will be considered a part of arguments. The instruction
    is not case-sensitive, although it is an accepted convention for instructions
    to be uppercase so as to distinguish them from the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the instructions that we can use in a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: The FROM instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `FROM` instruction sets the base image for the subsequent instructions.
    A valid Dockerfile''s first non-comment line will be a `FROM` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The image can be any valid local or public image. If it is not found locally,the
    `Docker build` command will try to pull it from the public registry. The `tag`
    command is optional here. If it is not given, the `latest` command is assumed.
    If the incorrect `tag` command is given, it returns an error.
  prefs: []
  type: TYPE_NORMAL
- en: The MAINTAINER instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MAINTAINER` instruction allows you to set the author for the generated
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The RUN instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RUN` instruction will execute any command in a new layer on top of the
    current image, and commit this image. The image thus committed will be used for
    the next instruction in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RUN` instruction has two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN <command>` form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RUN ["executable", "arg1", "arg2"...]` form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first form, the command is run in a shell, specifically the `/bin/sh
    -c <command>` shell. The second form is useful in instances where the base image
    doesn't have a `/bin/sh` shell. Docker uses a cache for these image builds. So
    in case your image build fails somewhere in the middle, the next run will reuse
    the previously successful partial builds and continue from the point where it
    failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cache will be invalidated in these situations:'
  prefs: []
  type: TYPE_NORMAL
- en: When the `docker build` command is run with the `--no-cache` flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a non-cacheable command such as `apt-get update` is given. All the following
    `RUN` instructions will be run again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the first encountered `ADD` instruction will invalidate the cache for all
    the following instructions from the Dockerfile if the contents of the context
    have changed. This will also invalidate the cache for the `RUN` instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CMD instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CMD` instruction provides the default command for a container to execute.
    It has the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CMD ["executable", "arg1", "arg2"...]` form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CMD ["arg1", "arg2"...]` form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CMD command arg1 arg2 …` form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first form is like an exec and it is the preferred form, where the first
    value is the path to the executable and is followed by the arguments to it.
  prefs: []
  type: TYPE_NORMAL
- en: The second form omits the executable but requires the `ENTRYPOINT` instruction
    to specify the executable.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the shell form of the `CMD` instruction, then the `<command>` command
    will execute in the `/bin/sh -c` shell.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the user provides a command in `docker run`, it overrides the `CMD` command.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the `RUN` and `CMD` instructions is that a `RUN` instruction
    actually runs the command and commits it, whereas the `CMD` instruction is not
    executed during build time. It is a default command to be run when the user starts
    a container, unless the user provides a command to start it with.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s write a `Dockerfile` that brings a `Star` `Wars` output
    to your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this in a folder named `star_wars` and open your terminal at this location.
    Then run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the `starwars` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CMD instruction](graphics/4787OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thus, you can watch **Star Wars** in your terminal!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This *Star Wars* tribute was created by Simon Jansen, Sten Spans, and Mike Edwards.
    When you've had enough, hold *Ctrl* + *]*. You will be given a prompt where you
    can type `close` to exit.
  prefs: []
  type: TYPE_NORMAL
- en: The ENTRYPOINT instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` instruction allows you to turn your Docker image into an executable.
    In other words, when you specify an executable in an `ENTRYPOINT`, containers
    will run as if it was just that executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ENTRYPOINT` instruction has two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ENTRYPOINT ["executable", "arg1", "arg2"...]` form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ENTRYPOINT command arg1 arg2 …` form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This instruction adds an entry command that will not be overridden when arguments
    are passed to the `docker run` command, unlike the behavior of the `CMD` instruction.
    This allows arguments to be passed to the `ENTRYPOINT` instruction. The `docker
    run <image> -arg` command will pass the `-arg` argument to the command specified
    in the `ENTRYPOINT` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters, if specified in the `ENTRYPOINT` instruction, will not be overridden
    by the `docker run` arguments, but parameters specified via the `CMD` instruction
    will be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s write a Dockerfile with `cowsay` as the `ENTRYPOINT`
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cowsay` is a program that generates ASCII pictures of a cow with a message.
    It can also generate pictures using premade images of other animals, such as Tux
    the Penguin, the Linux mascot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this with the name `Dockerfile` in a folder named `cowsay`. Then through
    terminal, go to that directory, and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the image is built, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ENTRYPOINT instruction](graphics/4787OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the screenshot closely, the first run has no arguments and it
    used the argument we configured in the Dockerfile. However, when we gave our own
    arguments in the second run, it overrode the default and passed all the arguments
    (The `-f` flag and the sentence) to the `cowsay` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are the kind who likes to troll others, here''s a tip: apply the instructions
    given at [http://superuser.com/a/175802](http://superuser.com/a/175802) to set
    up a pre-exec script (a function that is called whenever a command is executed)
    that passes every command to this Docker container, and place it in the .`bashrc`
    file. Now cowsay will print every command that it execute in a text balloon, being
    said by an ASCII cow!'
  prefs: []
  type: TYPE_NORMAL
- en: The WORKDIR instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `WORKDIR` instruction sets the working directory for the `RUN`, `CMD`,
    and `ENTRYPOINT` Dockerfile commands that follow it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: This instruction can be used multiple times in the same Dockerfile. If a relative
    path is provided, the `WORKDIR` instruction will be relative to the path of the
    previous `WORKDIR` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The EXPOSE instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `EXPOSE` instruction informs Docker that a certain port is to be exposed
    when a container is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Even after exposing ports, while starting a container, you still need to provide
    port mapping using the `-p` flag to `Docker run`. This instruction is useful when
    linking containers, which we will see in [Chapter 3](ch03.html "Chapter 3. Configuring
    Docker Containers"), *Linking Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: The ENV instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ENV command is used to set environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This sets the `<key>` environment variable to `<value>`. This value will be
    passed to all future `RUN` instructions. This is equivalent to prefixing the command
    with `<key>=<value>`.
  prefs: []
  type: TYPE_NORMAL
- en: The environment variables set using the `ENV` command will persist. This means
    that when a container is run from the resulting image, the environment variable
    will be available to the running process as well. The `docker inspect` command
    shows the values that have been assigned during the creation of the image. However,
    these can be overridden using the `$ docker run –env <key>=<value>` command.
  prefs: []
  type: TYPE_NORMAL
- en: The USER instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The USER instruction sets the username or UID to use when running the image
    and any following the `RUN` directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The VOLUME instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `VOLUME` instruction will create a mount point with the given name and
    mark it as holding externally mounted volumes from the host or from other containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the `VOLUME` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of this instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Both formats are acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: The ADD instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ADD` instruction is used to copy files into the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The `ADD` instruction will copy files from `<src>` into the path at `<dest>`.
  prefs: []
  type: TYPE_NORMAL
- en: The `<src>` path must be the path to a file or directory relative to the source
    directory being built (also called the context of the build) or a remote file
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: The `<dest>` path is the absolute path to which the source will be copied inside
    the destination container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you build by passing a Dockerfile through the `stdin` file (`docker build
    - <` `somefile`), there is no build context, so the Dockerfile can only contain
    a URL-based `ADD` statement. You can also pass a compressed archive through the
    `stdin` file (`docker build - <` `archive.tar.gz`). Docker will look for a Dockerfile
    at the root of the archive and the rest of the archive will get used as the context
    of the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ADD` instruction obeys the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<src>` path must be inside the context of the build. You cannot use `ADD
    ../file as ..` syntax, as it is beyond the context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `<src>` is a URL and the `<dest>` path doesn't end with a trailing slash
    (it's a file), then the file at the URL is copied to the `<dest>` path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `<src>` is a URL and the `<dest>` path ends with a trailing slash (it's a
    directory), then the content at the URL is fetched and a filename is inferred
    from the URL and saved into the `<dest>/filename` path. So, the URL cannot have
    a simple path such as `example.com` in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `<src>` is a directory, the entire directory is copied, along with the filesystem
    metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `<src>` is a local tar archive, then it is extracted into the `<dest>` path.
    The result at `<dest>` is union of:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever existed at the path `<dest>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contents of the extracted tar archive, with conflicts in favor of the path `<src>`,
    on a file-by-file basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `<dest>` path doesn't exist, it is created along with all the missing directories
    along its path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The COPY instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The COPY instruction copies a file into the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The `Copy` instruction is similar to the `ADD` instruction. The difference is
    that the `COPY` instruction does not allow any file out of the context. So, if
    you are streaming Dockerfile via the `stdin` file or a URL (which doesn't point
    to a source code repository), the `COPY` instruction cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: The ONBUILD instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ONBUILD` instruction adds to the image a trigger that will be executed
    when the image is used as a base image for another build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: This is useful when the source application involves generators that need to
    compile before they can be used. Any build instruction apart from the `FROM`,
    `MAINTAINER`, and `ONBUILD` instructions can be registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how this instruction works:'
  prefs: []
  type: TYPE_NORMAL
- en: During a build, if the `ONBUILD` instruction is encountered, it registers a
    trigger and adds it to the metadata of the image. The current build is not otherwise
    affected in any way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of all such triggers is added to the image manifest as a key named `OnBuild`
    at the end of the build (which can be seen through the `Docker inspect` command).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When this image is later used as a base image for a new build, as part of processing
    the `FROM` instruction, the `OnBuild key` triggers are read and executed in the
    order they were registered. If any of them fails, the `FROM` instruction aborts,
    causing the build to fail. Otherwise, the `FROM` instruction completes and the
    build continues as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Triggers are cleared from the final image after being executed. In other words
    they are not inherited by *grand-child builds*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s bring `cowsay` back! Here''s a Dockerfile with the `ONBUILD` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Now save this file in a folder named `OnBuild`, open a terminal in that folder,
    and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to write another Dockerfile that builds on this image. Let''s write
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `apt-get moo` command is an example of Easter eggs typically found in many
    open source tools, added just for the sake of fun!
  prefs: []
  type: TYPE_NORMAL
- en: 'Building this image will now execute the `ONBUILD` instruction we gave earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use our newly gained knowledge to write a Dockerfile for the `code.it`
    application that we previously built by manually satisfying dependencies in a
    container and committing. The Dockerfile would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Create a folder named `code.it` and save this content as a file named `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is good practice to create a separate folder for every Dockerfile even if
    there is no context needed. This allows you to separate concerns between different
    projects. You might notice as you go that many Dockerfile authors club `RUN` instructions
    (for example, check out the Dockerfiles in [dockerfile.github.io](http://dockerfile.github.io)).
    The reason is that AUFS limits the number of possible layers to 42\. For more
    information, check out this issue at [https://github.com/docker/docker/issues/1171](https://github.com/docker/docker/issues/1171).
  prefs: []
  type: TYPE_NORMAL
- en: You can go back to the section on *Docker build* to see how to build an image
    out of this Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Docker workflow - pull-use-modify-commit-push
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, as we are nearing the end of this chapter, we can guess what a typical
    Docker workflow is like:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare a list of requirements to run your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine which public image (or one of your own) can satisfy most of these
    requirements, while also being well-maintained (this is important as you would
    need the image to be updated with newer versions whenever they are available).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, fulfill the remaining requirements either by running a container and executing
    the commands that fulfill the requirements (which can be installing dependencies,
    bind mounting volumes, or fetching your source code), or by writing a Dockerfile
    (which is preferable since you will be able to make the build repeatable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push your new image to the public Docker registry so that the community can
    use it too (or to a private registry or repository if needs be).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automated Builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Automated Builds automate the building and updating of images from GitHub or
    BitBucket, directly on Docker Hub. They work by adding a `commit` hook to your
    selected GitHub or BitBucket repository, triggering a build and an update when
    you push a commit. So you need not manually build and push an image to Docker
    Hub every time you make an update. The following steps will show you how to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: To set up an Automated Build, log in to your Docker Hub account.![Automated
    Builds](graphics/4787OS_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link your GitHub or BitBucket account through the **Link** **Accounts** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Automated** **Build** in the **Add** **Repository** menu.![Automated
    Builds](graphics/4787OS_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the GitHub or BitBucket project that has the Dockerfile you want to build.
    (You will need to authorize Docker Hub to access your repositories.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the branch that contains the source code and the Dockerfile (the default
    is the master branch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the Automated Build a name. This will be the name of the repository as
    well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign an optional Docker tag to the Build. The default is the `lastest` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify where the Dockerfile is located. The default is `/`.![Automated Builds](graphics/4787OS_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once configured, the automated build will trigger a build and you will be able
    to see it in the Docker Hub Registry in a few minutes. It will stay in sync with
    your GitHub and BitBucket repository until you deactivate the Automated Build
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The build status and history can be seen in the Automated Builds page on your
    profile in Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: '![Automated Builds](graphics/4787OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you've created an Automated Build, you can deactivate or delete it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot, however, push to an Automated Build with the Docker `push` command.
    You can only manage it by committing code to your GitHub or BitBucket repository.
  prefs: []
  type: TYPE_NORMAL
- en: You can create multiple Automated Builds per repository and configure them to
    point to specific Dockerfile or Git branches.
  prefs: []
  type: TYPE_NORMAL
- en: Build triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automated Builds can also be triggered via a URL on Docker Hub. This allows
    you to rebuild an Automated Build image on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Webhooks are triggers that are called upon a successful build event. With a
    webhook, you can specify a target URL (such as a service that notifies you) and
    a JSON payload that will be delivered when the image is pushed. Webhooks are useful
    if you have a continuous-integration workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a webhook to your Github repository, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Settings** in your repository.![Webhooks](graphics/4787OS_02_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu bar on the left, go to **Webhooks** **and** **Services**.![Webhooks](graphics/4787OS_02_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add** **Service**.![Webhooks](graphics/4787OS_02_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the text box that opens, enter **Docker** and select the service.![Webhooks](graphics/4787OS_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're all set! Now a build will be triggered in Docker Hub whenever you commit
    to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the **Docker** command-line tool and tried out
    the commands available. Then we figured out how to make builds repeatable using
    Dockerfile. Also, we automated this build process using Docker Hub's Automated
    Build service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will try to gain more control over how our containers
    run by looking at the various commands that help us configure them. We will look
    at restraining the amount of resources (CPU, RAM, and storage) consumable by the
    container.
  prefs: []
  type: TYPE_NORMAL
