- en: Chapter 1. Preparatory Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter, we will start off by looking at Jenkins from several
    different perspectives; how to obtain and run it, some of the ways and the reasons
    people use it, and what it provides to them. In doing so, we will take a look
    at some standard use cases and examine how a Jenkins installation will often evolve
    over a period of time—typically starting off with only the basic installation
    and core features, then progressively becoming more customized and advanced with
    different types of extensions. We will start off with "ready-made" plugins, and
    then progress towards extending these before looking at how to develop your own
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: We will then summarize the high-level aims of this book, and give the details
    of what you should hopefully gain from them.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide an overview of the various tools and the environment setup that
    you will need in order to run the practical examples covered in the subsequent
    chapters, and we will review the best practices of **Continuous Integration**
    (**CI**) by identifying some of the ways that Jenkins can be used to achieve them.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, it is assumed that you already have some working knowledge
    of Jenkins, so we will not spend much time covering the basics, such as installing
    and starting Jenkins, or detailing the usage of standard features and core functions.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like more details on these topics, there are numerous helpful tutorials
    and examples available online; the **Use Jenkins** section of the Jenkins homepage,
    [https://jenkins-ci.org](https://jenkins-ci.org), is often a good starting point
    for help with general setup and usage questions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a Java application, Jenkins can be installed and run in different ways depending
    on your requirements, personal preferences, and the environment that you are running
    it in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest and easiest approach to quickly get Jenkins up and running is
    by setting up Java, downloading the latest Jenkins WAR file from the Jenkins homepage
    ([www.jenkins-ci.org](http://www.jenkins-ci.org)), and then simply starting it
    from the command line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure demonstrates the use of this approach by running just
    two simple commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wget http://mirrors.jenkins-ci.org/war/latest/jenkins.war`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This command downloads the latest version of Jenkins from the main site.
  prefs: []
  type: TYPE_NORMAL
- en: '`wget` is a Linux utility that fetches files from the Web—if you are on a platform
    that does not have `wget`, you can simply save the link (the `jenkins.war` file)
    via your browser to a working directory instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL is obtained by copying the **Latest & Greatest** link from the homepage
    at [https://jenkins-ci.org/](https://jenkins-ci.org/). Note that there is also
    an option to download and use the Long-Term Support release instead of the current,
    latest, and greatest, as explained here: [https://wiki.jenkins-ci.org/display/JENKINS/LTS+Release+Line](https://wiki.jenkins-ci.org/display/JENKINS/LTS+Release+Line).'
  prefs: []
  type: TYPE_NORMAL
- en: This is preferable for more conservative installations, where stability is more
    important than having latest features.
  prefs: []
  type: TYPE_NORMAL
- en: '`java –jar jenkins.war`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This second command tells Java to run the WAR file that we just downloaded
    as an application, which produces the resulting output that you can see in the
    following screenshot—Jenkins unpacking from the WAR file, checking and initializing
    the various subsystems, and starting up a process on port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Jenkins](../images/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Downloading and starting Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple process is usually all that is required to both download the latest
    version of Jenkins and get it up and running. You should now be able to access
    the web interface at `http://localhost:8080` through your browser and begin setting
    up jobs to make Jenkins work for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Jenkins](../images/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Jenkins start page
  prefs: []
  type: TYPE_NORMAL
- en: Extending the basic setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you exit from the command prompt or shell that started the process that
    we looked at previously, the Jenkins instance will stop with the exit, so for
    anything beyond a very quick ad hoc test, some form of initialization or process
    management script is highly recommended. Such a script can also be easily tailored
    to perform a few "nice to have" functions for you, for example, things such as
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting up at system boot time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catering to `stop|start|restart|status` requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting console output to a log file so that you can monitor it for issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running as a background/daemon process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running on a nonstandard port by setting the `--httpPort=` parameter, in cases
    where port `8080` is already used by another application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding to a specific network interface, rather than the default `0.0.0.0` value
    using the `--httpListenAddress=` option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This Ubuntu-based example script from the home page demonstrates many of the
    previously mentioned features of Jenkins that is running under Tomcat. The script
    can be found at [https://wiki.jenkins-ci.org/display/JENKINS/JenkinsLinuxStartupScript](https://wiki.jenkins-ci.org/display/JENKINS/JenkinsLinuxStartupScript)
    and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the [http://jenkins-ci.org/](http://jenkins-ci.org/) home page also
    hosts **Native Installers** for many popular operating systems under the **Native
    packages** column. These pages provide download links and installation instructions
    for each OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to look at running Jenkins in a J2EE container too, which can
    often lead to a more seamless fit with your existing software stack and architecture.
    This may mean that you will inherit additional benefits, such as the container''s
    logging, authentication, authorization, or resilience. Jenkins can be run with
    many popular J2EE compatible containers, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: WebSphere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebLogic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tomcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JBoss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jonas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more `init` script examples and detailed installation instructions
    readily available on the Web, which should cover any combination of operating
    system and container setup. The point of this is that you should be able to set
    up Jenkins to suit your environment and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, we will assume that Jenkins is being run directly
    from the command line on the local host. If you are using a J2EE container to
    host the application or running the application on a remote host, the only difference
    you will notice is that you may need to perform additional admin and deployment
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, most users or organizations will start off on their Jenkins journey
    by setting up a basic, standard Jenkins installation to manage a few simple development
    tasks. The most common use is to build your source code, either periodically or
    whenever it changes in your central repository (Git, Subversion, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Using Jenkins to automate this type of simple and repetitive task often provides
    a lot of useful benefits very quickly and easily. Straight out of the box, so
    to speak, you get a bundle of helpful features, such as task scheduling and job
    triggering, building and testing report pages, sending out email notifications
    and alerts when there are new issues, and providing rapid and live feedback of
    how healthy (or not!) your code base currently is. If you don't already have a
    tool in place to provide these things, then setting up a standard Jenkins instance
    will provide these initial basic features, which on their own may well transform
    your development process.
  prefs: []
  type: TYPE_NORMAL
- en: The next logical step after this is to gradually add a little more intelligence
    and complexity to the setup—does the code compile ok? How many unit tests have
    been passed now, how long does the application take to compile? Oh, and could
    we show on a web page who has changed which parts of the code base? Is our application
    running faster or better than it was previously, and is it stable? Even before
    we begin to add any type of extension or customization, the core Jenkins installation
    provides a plethora of options here—you can choose to build your application on
    any platform that runs Java (which means pretty much anywhere these days), and
    you can also do this in whatever way that suits you and your current setup the
    best, including using the standard and popular build tools such as Ant or Maven,
    and/or re-using your existing Ant or Maven build scripts, or your Linux Shell
    or Windows DOS scripts.
  prefs: []
  type: TYPE_NORMAL
- en: You can also easily set up a cross-platform environment by deploying Jenkins
    Slave Nodes, which will allow you to run different jobs on different hosts. This
    can be useful in the environments that use a combination of operating systems;
    for example, your application runs on Linux, and you want to run your browser-based
    tests using Internet Explorer on a Windows host.
  prefs: []
  type: TYPE_NORMAL
- en: This ability to act as an easily configurable "wrapper" for your existing process,
    combined with the flexible nature of Jenkins, makes it very easy to adapt your
    particular setup to suit your requirements with minimal change or interruption.
    This makes Jenkins far easier to implement than having to change your existing
    build and deployment processes and practices just to accommodate the requirements
    of a new tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this stage, the benefits of setting up a Continuous Integration environment
    often become quite obvious: if we can automatically build our code and package
    our application so easily, wouldn''t it be great if we could go on to deploy it
    too? And then, if we did that, we could automatically test how our new application
    performs on a replica of the target platform!'
  prefs: []
  type: TYPE_NORMAL
- en: On reaching this point, Jenkins will be a pivotal tool in your Continuous Integration
    process, and the more you can extend it to suit your growing and specific requirements,
    the more benefit you will receive from it.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to extending Jenkins, which is what we will be looking at in the
    rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to extend Jenkins is through its fantastic and ever-expanding
    wealth of plugins. It is always recommended and informative to browse through
    them; existing plugins are frequently being improved upon and updated with new
    features, and new plugins are being added to the list all the time. We are going
    to do more than just review a few popular plugins here though—by the end of this
    book, you should have the ability to take your usage of Jenkins to the next level
    to create your own custom plugins and extensions and work with the many features
    and interfaces that Jenkins provides us with for extension and interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be taking a detailed look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The different ways in which we can use the existing features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Jenkins through its various interfaces and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interact with Jenkins from within your IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to build upon the existing functionality to suit your needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing, testing, and building your own custom Jenkins extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the main tools that we will be using to help us extend Jenkins, along
    with some information on setting them up, and the sources for further help and
    information if required:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**): You will need a version of this at the
    same bit level as your Java IDE, that is, both will need to be 32 bit or 64 bit,
    depending on your architecture and preference. You can choose from IBM, Oracle,
    or OpenJDK 6.0 or later. Each vendor supplies installation instructions for all
    major platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java IDE**: We will mainly be using Eclipse, but will cater to NetBeans and
    IntelliJ too, where possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most recent versions of each of these IDEs are available at their respective
    websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://netbeans.org/downloads/](https://netbeans.org/downloads/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mylyn**: This is used to communicate with Jenkins from our IDE. If Mylyn
    is not already included in your IDE, you can download it from the Eclipse site
    here: [http://www.eclipse.org/mylyn/downloads/](http://www.eclipse.org/mylyn/downloads/).
    We will cover this in detail in [Chapter 3](part0024_split_000.html#MSDG1-497efea050ab4b7582c7e2ed4ba920ee
    "Chapter 3. Jenkins and the IDE"), *Jenkins and the IDE*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: We will be using Maven 3 to build the Jenkins source code and our
    own custom plugin. Maven is a Java tool, so it will need to know about the JDK
    of your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins Source**: This will be downloaded by Maven.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: On most Linux platforms, the equivalent of `sudo apt-get install git`
    should suffice. On Mac, there are several options, including the `git-osx` installer
    on Sourceforge. For Microsoft Windows, there is an executable installer available
    at [http://msysgit.github.io/](http://msysgit.github.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go in to more specifics on the installation and usage of each of these
    components as we use them in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we conclude this chapter, here is a list of the key practices of Continuous
    Integration (as defined by Martin Fowler in 2006) with the examples of the ways
    in which Jenkins can be used to help you achieve them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintain a Single Source Repository**: Jenkins can interact with all modern
    source code and version control repositories—some abilities are built-in, others
    can be added as extensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automate the Build**: As described earlier in the use cases, this is one
    of the core aims of Jenkins and often the main driver to start using Jenkins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make Your Build Self-Testing**: This is usually the second step in setting
    up a CI environment with Jenkins—once you automate the building of the code, automating
    the tests as well is a natural progression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Everyone Commits To the Mainline Every Day**: We can''t really force developers
    to do this, unfortunately. However, we can quite easily highlight and report who
    is doing—or not doing—what, which should eventually help them learn to follow
    this best practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Every Commit Should Build the Mainline on an Integration Machine**: Builds
    can be triggered by developer commits, and Jenkins Slave Nodes can be used to
    build and provide accurate replica environments to build upon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fix Broken Builds Immediately**: This is another developer best practice
    that needs to be adopted—when Jenkins shows red, the top focus should be on fixing
    the issue until it shows green. No one should commit new changes while the build
    is broken, and Jenkins can be configured to communicate the current status in
    the most effective way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep the Build Fast**: By offloading and spreading work to distributed Slave
    Nodes and by breaking down builds to identify and focus on the areas that have
    changed, Jenkins can be tuned to provide a rapid response to changes—a good target
    would be to check in a change and obtain a clear indication of the result or impact
    under 10 minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test in a Clone of the Production Environment**: After compiling the new
    change, downstream Jenkins jobs can be created that will prepare the environment
    and take it to the required level—applying database changes, starting up dependent
    processes, and deploying other prerequisites. Using virtual machines or containers
    in conjunction with Jenkins to automatically start up environments in a known-good
    state can be very useful here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make it Easy for Anyone to Get the Latest Executable**: Jenkins can be set
    up to act as a web server hosting the latest version at a known location so that
    everyone (and other processes/consumers) can easily fetch it, or it can also be
    used to send out details and links to interested parties whenever a new version
    has been uploaded to Nexus, Artifactory, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Everyone can see what''s happening**: There are many ways in which Jenkins
    communications can be extended—email alerts, desktop notifications, Information
    Radiators, RSS feeds, Instant Messaging, and many more—from lava lamps and traffic
    lights to the ubiquitous toy rocket launchers!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automate Deployment**: This is usually a logical progression of the `Build
    -> Test -> Deploy` automation sequence, and Jenkins can help in many ways; with
    Slave Nodes running on the deployment host, or jobs set up to connect to the target
    and update it with the most recently built artifact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits that can be realized once you have achieved the preceding best
    practices are often many and significant—your team will release software of higher
    quality and will do this more quickly and for less cost than before. However,
    setting up an automated build, test, and deployment pipeline will never be enough
    in itself; the tests, environment, and culture must be of sufficient quality too,
    and having the developers, managers, and business owners "buy in" to the processes
    and practices often makes all the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this preparatory chapter, we have taken a look at the basics of Jenkins;
    how it is used from both functional and practical points of view. We have run
    through a high-level overview of the toolset that we will be using to extend Jenkins
    in the following chapters and reviewed the best practices for Continuous Integration
    along with the ways in which Jenkins can be used to help your team achieve them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at the ways in which we can extend
    the Jenkins user interface to make it more productive and intelligent, and how
    we can extend the user experience to make life easier and more productive for
    end users, as well as for Jenkins admins, build scripts, and processes.
  prefs: []
  type: TYPE_NORMAL
