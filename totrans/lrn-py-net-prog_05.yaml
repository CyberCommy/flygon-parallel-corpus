- en: Chapter 5. Interacting with Remote Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your computer is connected to the Internet or a **local area network** (**LAN**),
    then it''s time to talk to the other computers on the network. In a typical home,
    office, or campus LAN, you will find that many different types of computers are
    connected to the network. Some computers act as the servers for specific services,
    such as a file server, a print server, a user authentication management server,
    and so on. In this chapter, we will explore how the computers in a network can
    interact with each other and how they can access a few services through the Python
    scripts. The following task list will give you an overview of the topics that
    will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing SSH terminals with `paramiko`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files through SFTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files with the help of FTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the SNMP packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the LDAP packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing the files with the help of SAMBA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter requires quite a few third-party packages, such as `paramiko`,
    `pysnmp`, and so on. You can use your operating system''s package management tool
    for installing them. Here''s a quick how-to on installing the `paramiko` module
    in Ubuntu 14, python3, and the other modules that are required for understanding
    the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Secure shell – access using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH has become a very popular network protocol for performing secure data communication
    between two computers. It provides an excellent cryptographic support, so that
    unrelated third-parties cannot see the content of the data during the transmission
    process. Details of the SSH protocol can be found in these RFC documents: RFC4251-RFC4254,
    available at [http://www.rfc-editor.org/rfc/rfc4251.txt](http://www.rfc-editor.org/rfc/rfc4251.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s `paramiko` library provides a very good support for the SSH-based
    network communication. You can use Python scripts to benefit from the advantages
    of SSH-based remote administration, such as the remote command-line login, command
    execution, and the other secure network services between two networked computers.
    You may also be interested in using the `pysftp` module, which is based on `paramiko`.
    More details regarding this package can be found at PyPI: [https://pypi.python.org/pypi/pysftp/](https://pypi.python.org/pypi/pysftp/).'
  prefs: []
  type: TYPE_NORMAL
- en: The SSH is a client/server protocol. Both of the parties use the SSH key pairs
    to encrypt the communication. Each key pair has one private and one public key.
    The public key can be published to anyone who may be interested in that. The private
    key is always kept private and secure from everyone except the owner of the key.
  prefs: []
  type: TYPE_NORMAL
- en: The SSH public and private keys can be generated and digitally signed by an
    external or an internal certificate authority. But that brings a lot of overhead
    to a small organization. So, alternatively, the keys can be generated randomly
    by utility tools, such as `ssh-keygen`. The public key needs to be available to
    all participating parties. When the SSH client connects to the server for the
    first time, it registers the public key of the server on a special file called
    `~/.ssh/known_hosts` file. So, the subsequent connection to the server ensures
    that the client is talking to the same server as it spoke to before. On the server
    side, if you would like to restrict access to certain clients who have certain
    IP addresses, then the public keys of the permitted hosts can be stored to another
    special file called `ssh_known_hosts` file. Of course, if you re-build the machines,
    such as the server machine, then the old public key of the server won't match
    with that of the one stored in the `~/.ssh/known_hosts` file. So, the SSH client
    will raise an exception and prevent you from connecting to it. You can delete
    the old key from that file and then try to re-connect, as if for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `paramiko` module to create an SSH client and then connect it
    to the SSH server. This module will supply the `SSHClient()` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, the instance of this client class will reject the unknown host keys.
    So, you can set up a policy for accepting the unknown host keys. The built-in
    `AutoAddPolicy()` class will add the host keys as and when they are discovered.
    Now, you need to run the `set_missing_host_key_policy()` method along with the
    following argument on the `ssh_client` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If, you want to restrict connecting only to certain hosts, then you can define
    your own policy and replace it with the `AutoAddPolicy()` class.
  prefs: []
  type: TYPE_NORMAL
- en: You may also be interested in adding the system host keys by using the `load_system_host_keys()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have discussed how to encrypt the connection. However, SSH needs
    your authentication credentials. This means that the client needs to prove to
    the server that a specific user is talking, not someone else. This can be done
    in a few ways. The simplest way is by using the username and the password combination.
    Another popular way is by using the key-based authentication method. This means
    that the user's public key can be copied to the server. There's a specific tool
    for doing that. This comes with the later versions of the SSH. Here's an example
    of how to use `ssh-copy-id`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will copy the SSH public key of the faruq user to a machine, `debian6box.localdomain.loc`:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can simply call the `connect()` method along with the target hostname
    and the SSH login credentials. To run any command on the target host, we need
    to invoke the `exec_command()` method by passing the command as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code listing shows how to do SSH login to a target host and then
    run a simple `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running it, we need to ensure that the SSH server daemon is running
    on the target host (which in this case is the localhost). As shown in the following
    screenshot, we can use the `netstat` command for doing that. This command will
    show all the running services that are listening to a particular port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure shell – access using Python](graphics/6008OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding script will make an SSH connection to the localhost and the run
    the `ls -l /dev/` command. The output of this script will be similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure shell – access using Python](graphics/6008OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting the SSH packets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be very interesting to see the network packet exchange between the
    client and the server. We can use either the native `tcpdump` command or the third-party
    Wireshark tool to capture network packets. With `tcpdump`, you can specify the
    target network interface ( `-i lo`) and the port number (port `22`) options. In
    the following packet capture session, five packet exchanges have been shown during
    an SSH client/server communication session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Although, it''s very quick and easy to run `tcpdump`, the command does not
    interpret it in the same way as the other GUI tools, such as Wireshark, interpret
    it. The preceding session can be captured in Wireshark, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the SSH packets](graphics/6008OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This clearly shows how the first three packets complete the TCP handshake process.
    Then, the subsequent SSH packets negotiate the connection between the client and
    the server. It's interesting to see how the client and the server negotiate the
    encryption protocols. In this example, the client port is `50768` and the server
    port is `22`. The client first initiates the SSH packet exchange and then indicates
    that it would like to talk over the `SSHv2` protocol. Then, the server agrees
    on that and continues the packet exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files through SFTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH can be used effectively for securely transferring files between two computer
    nodes. The protocol used in this case is the **secure file transfer protocol**
    (**SFTP**). The Python `paramiko` module will supply the classes required for
    creating the SFTP session. This session can then perform a regular SSH login.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The SFTP session can be created from the SSH transport. The paramiko's working
    in the SFTP session will support the normal FTP commands such as `get()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the SFTP `get` command requires the source file''s path and
    the target file''s path. In the following example, the script will download a
    `test.txt` file, which is located on the user''s home directory, through SFTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a file has been downloaded with the help of SFTP. Notice, how
    `paramiko` has created the SFTP session by using the `SFTPClient.from_transport(ssh_transport)`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The script can be run as shown in the following screenshot. Here, we will first
    create a temporary file called `/tmp/test.txt`, then complete the SSH login, and
    then download that file by using SFTP. Lastly, we will check the content of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transferring files through SFTP](graphics/6008OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Transferring files with FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike SFTP, FTP uses the plain-text file transfer method. This means any username
    or password transferred through the wire can be detected by an unrelated third-party.
    Even though FTP is a very popular file transfer protocol, people frequently use
    this for transferring a file from their PCs to the remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, `ftplib` is a built-in module used for transferring the files to
    and from the remote machines. You can create an anonymous FTP client connection
    with the `FTP()` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can invoke the normal FTP commands, such as `CWD`. In order to download
    a binary file, you need to create a file-handler such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to retrieve the binary file from the remote host, the syntax shown
    here can be used along with the `RETR` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, an example of a full FTP file download can be
    seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code illustrates how an anonymous FTP can be downloaded from [ftp.kernel.org](http://ftp.kernel.org),
    which is the official website that hosts the Linux kernel. The `FTP()` class takes
    three arguments, such as the initial filesystem path on the remote server, the
    username, and the email address of the `ftp` user. For anonymous downloads, no
    username and password is required. So, the script can be downloaded from the `tftp-hpa-0.11.tar.gz`
    file, which can be found on the `/pub/software/network/tftp` path.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting FTP packets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we capture the FTP session in Wireshark on port `21` of the public network
    interface, then we can see how the communication happens in plain-text. This will
    show you why SFTP should be preferred. In the following figure, we can see that,
    after successfully establishing connection with a client the server sends the
    banner message: `220` Welcome to kernel.org. Following this, the client will anonymously
    send a request for login. In response, the server will ask for a password. The
    client can send the user''s e-mail address for authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting FTP packets](graphics/6008OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To your surprise, you can see that the password has been sent in clear-text.
    In the following screenshot, the contents of the password packet have been displayed.
    It shows the supplied fake e-mail address, `nobody@nourl.com`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting FTP packets](graphics/6008OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fetching Simple Network Management Protocol data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SNMP is a ubiquitous network protocol that is used by the network routers, such
    as switches, servers, and so on, for communicating the device's configuration,
    performance data, and the commands that are meant for the control devices. Although
    SNMP starts with the word *simple*, it's not a simple protocol. Internally, each
    device's information is stored in a sort of a database of information called the
    **management information base** (**MIB**). The SNMP protocol offers varying levels
    of security depending on the protocol version number. In SNMP `v1` and `v2c`,
    the data is protected by a pass phrase known as the community string. In SNMP
    `v3`, a username and a password are required for storing the data. And, the data
    can be encrypted with the help of SSL. In our example, we will use the `v1` and
    `v2c` versions of the SNMP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'SNMP is a client/server-based network protocol. The server daemon provides
    the requested information to the clients. In your machine, if SNMP has been installed
    and configured properly, then you can use the `snmpwalk` utility command to query
    the basic system information by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command will show the MIB number and its values.
    For example, the MIB number `iso.3.6.1.2.1.1.1.0` shows that it''s a string type
    value, such as `Linux debian6box 2.6.32-5-686 #1 SMP Tue May 13 16:33:32 UTC 2014
    i686`.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you can use a third-party library called `pysnmp` for interfacing
    with the `snmp` daemon. You can install the `pysnmp` module by using pip.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This module provides a useful wrapper for the `snmp` commands. Let's learn how
    to create an `snmpwalk` command. To begin, import a command generator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then define the necessary default values for the connection assuming that the
    `snmpd` daemon has been running on port `161` of the local machine and the community
    string has been set to public.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now invoke the `getCmd()` method with the help of the necessary data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `cmdgen` takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CommunityData()`: Set the community string as public.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UdpTransportTarget()`: This is the host target, where the `snmp` agent is
    running. This is specified in a pair of the hostname and the UDP port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MibVariable`: This is a tuple of values that includes the MIB version number
    and the MIB target string (which in this case is `sysDescr`; this refers to the
    description of the system).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of this command consists of a four-value tuple. Out of those, three
    are related to the errors returned by the command generator, and the fourth one
    is related to the actual variables that bind the returned data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how the preceding method can be used for fetching
    the SNMP host description string from a running SNMP daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding example, an output similar to the following will
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting SNMP packets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can inspect the SNMP packet by capturing the packets on port 161 of your
    network interface. If the server is running locally, then listening on the `loopbook`
    interface is sufficient. The `snmp-get` request format and the `snmp-get` response
    packet formats, which are produced by Wireshak, is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting SNMP packets](graphics/6008OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In response to the SNMP get request from the client, an SNMP get response will
    be generated by the server. This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting SNMP packets](graphics/6008OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reading Light-weight Directory Access Protocol data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LDAP has been used for a long time for accessing and managing distributed directory
    information. This is an application level protocol that works over the IP network.
    Directory service is heavily used in organizations for managing the information
    about the users, the computer systems, the networks, the applications, and so
    on. The LDAP protocol contains plenty of technical jargon. It is a client/server-based
    protocol. So, the LDAP client will make a request to a properly configured LDAP
    server. After initializing the LDAP connection, the connection will need to be
    authenticated by using a few parameters. A simple BIND operation will establish
    an LDAP session. In a simple case, you can set up a simple anonymous BIND that
    would not need no password or any other credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you a run a simple LDAP query with the help of `ldapsearch`, then you will
    see results such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding communication can be captured with the help of Wireshark. You
    need to capture the packets on port 389\. As shown in the following screenshot,
    the LDAP client-server communication will be established after a `bindRequest`
    has been successfully sent. It's not secure to communicate anonymously with the
    LDAP server. For the sake of simplicity, in the following example the search has
    been done without binding with any of the credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading Light-weight Directory Access Protocol data](graphics/6008OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Python's third-party `python-ldap` package provides the necessary functionality
    for interacting with an LDAP server. You can install this package with the help
    of `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To begin with, you will have to initialize the LDAP connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the following code will show how a simple BIND operation can be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can perform an ldap search. It requires you to specify the necessary
    parameters, such as base DN, filter, and attributes. Here is an example of the
    syntax that is required for searching for the users on an LDAP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a complete example for finding user information by using the LDAP protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will search the LDAP directory subtree with the `ou=users,dc=localdomain,dc=loc`
    base `DN` and the `[sn]` attributes. The search is limited to the person objects.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting LDAP packets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we analyze the communication between the LDAP client and the server, then
    we can see the format of the LDAP search request and response. The parameters
    that we have used in our code have a direct relationship with the `searchRequest`
    section of an LDAP packet. As shown in the following screenshot produced by Wireshark,
    it contains data, such as `baseObject`, `scope` and `Filter`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting LDAP packets](graphics/6008OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The LDAP search request generates a server response, which has been shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting LDAP packets](graphics/6008OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the LDAP server returns the search response, we can see the format of the
    response. As shown in the preceding screenshot, it contains the result of the
    search and the associated attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of searching a user from an LDAP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In a properly configured LDAP machine, the preceding script will return a result
    that will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sharing files with SAMBA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a LAN environment, you will often need to share the files between different
    types of machines, such as Windows and Linux machines. The protocol used for sharing
    the files and the printers among these machines is either the **Server Message
    Block** (**SMB**) protocol or its enhanced version called the **Common Internet
    File System** (**CIFS**) protocol. CIFS runs over TCP/IP and it is used by the
    SMB clients and servers. In Linux, you will find a package called Samba, which
    implements the `SMB` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running a Linux virtual machine within a Windows box with the help
    of software, such as VirtualBox, then we can test file sharing among the Windows
    and the Linux machines. Let us create a folder at `C:\share` on the Windows machine
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing files with SAMBA](graphics/6008OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, right-click on the folder and then go to the **Sharing** tab. There are
    two buttons: **Share** and **Advanced sharing**. You can click on the latter and
    it will open the advanced sharing dialog box. Now you can adjust the share permissions.
    If this share is active, then you will be able to see this share from your Linux
    virtual machine. If you run the following command on your Linux box, then you
    will see the previously defined file-share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how you can share a folder under Windows 7 as
    discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing files with SAMBA](graphics/6008OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding file share can be accessed from your Python script by using a
    third-party module called `pysmb`. You can use the `pip` command-line tool for
    installing `pysmb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This module provides an `SMBConnection` class, where you can pass the necessary
    parameters for accessing an SMB/CIFS share. For example, the following code will
    help you to access a file-share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding works, then the following assertion will be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list the shared files by using the `listShares()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can use the `tmpfile` module copying a file from your windows share.
    For example, if you create a file in the `C:\Share\test.rtf` path, then the additional
    code shown here will copy that file by using the SMB protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we put the entire code into a single source file, then it will look like
    the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting SAMBA packets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we capture the SMABA packets on port `445`, then we can see how the Windows
    Server communicates with the Linux SAMBA client over the CIFS protocol. In the
    following two screenshots, a detailed communication between the client and the
    server, has been presented. The connection setup has been shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting SAMBA packets](graphics/6008OS_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows how a file copy session is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting SAMBA packets](graphics/6008OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A typical SAMBA packet format has been shown in the following screenshot. The
    important field of this packet is the `NT_STATUS` field. Typically, if the connection
    is successful, then it will show `STATUS_SUCESS`. Otherwise, it will print a different
    code. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting SAMBA packets](graphics/6008OS_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have come across several network protocols and Python libraries,
    which are used for interacting with remote systems. SSH and SFTP are used for
    securely connecting and transferring files to the remote hosts. FTP is still used
    as a simple file transfer mechanism. However, it's not secure due to user credentials
    being transferred over the wire as plain-text. We also examined Python libraries
    for dealing with SNMP, LDAP, and SAMBA packets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, one of the most common networking protocols—that is, DNS
    and IP—will be discussed. We will explore TCP/IP networking using Python scripts.
  prefs: []
  type: TYPE_NORMAL
