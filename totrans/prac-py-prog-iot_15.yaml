- en: Advanced IoT Programming Concepts - Threads, AsyncIO, and Event Loops
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 高级IoT编程概念-线程、异步IO和事件循环
- en: In the previous chapter, we learned how to detect movement with a PIR sensor,
    as well as measure distances and detect movement with ultrasonic sensors and Hall-effect
    sensors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用PIR传感器检测运动，以及如何使用超声波传感器和霍尔效应传感器测量距离和检测运动。
- en: In this chapter, we will discuss alternative ways of *structuring* our Python
    programs when we are working with electronic sensors (input devices) and actuators
    (output devices). We will cover the classic event-loop approach to programming,
    before moving on to more advanced approaches, including the use of threads in
    Python, the publisher/subscriber model, and finally, asynchronous I/O programming
    with Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在处理电子传感器（输入设备）和执行器（输出设备）时，*构建*Python程序的替代方式。我们将首先介绍经典的事件循环编程方法，然后转向更高级的方法，包括在Python中使用线程、发布者/订阅者模型，最后是使用Python进行异步IO编程。
- en: I guarantee you that there are many, many blog posts and tutorials across the
    internet covering these topics; however, what we will cover in this chapter will
    be uniquely focused on practical electronic interfacing. Our approach in this
    chapter will involve creating a simple circuit with a push-button, a potentiometer,
    and two LEDs that we will make flash at different rates, and presenting four different
    coding approaches to make the circuit work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我向您保证，互联网上有很多博客文章和教程涵盖了这些主题；然而，本章将专注于实际的电子接口。本章的方法将涉及创建一个简单的电路，其中包括一个按钮、一个电位计和两个LED，我们将使它们以不同的速率闪烁，并提供四种不同的编码方法来使电路工作。
- en: 'Here is what we will cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的内容：
- en: Building and testing our circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试我们的电路
- en: Exploring an event-loop approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索事件循环的方法
- en: Exploring a threaded approach
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索线程化方法
- en: Exploring a publisher-subscriber alternative
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索发布者-订阅者的替代方案
- en: Exploring an AsyncIO approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索异步IO的方法
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，您需要以下内容：
- en: Raspberry Pi 4 Model B
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: Minimum Python version 3.5
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your Python
    version is 3.5 or higher.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望，只要您的Python版本是3.5或更高，本书中的代码示例应该可以在树莓派3型B或不同版本的Raspbian
    OS上无需修改即可运行。
- en: You will find this chapter's source code in the `chapter12` folder in the GitHub
    repository available at [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的`chapter12`文件夹中找到本章的源代码，该存储库位于[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)。
- en: 'You will need to execute the following commands in a terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在终端中执行以下命令来设置虚拟环境并安装本章所需的Python库：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项已从`requirements.txt`中安装：
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**ADS1X15**: The ADS1x15 ADC library ([https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADS1X15**：ADS1x15 ADC库（[https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15)）'
- en: '**PyPubSub**: In-process messaging and events ([https://pypi.org/project/PyPubSub](https://pypi.org/project/PyPubSub))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyPubSub**：进程内消息和事件（[https://pypi.org/project/PyPubSub](https://pypi.org/project/PyPubSub)）'
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习所需的电子元件如下：
- en: 2 x red LEDs
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 红色LED
- en: 2 x 200 Ω resistors
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 200 Ω 电阻
- en: 1 x push-button switch
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 按钮开关
- en: 1 x ADS1115 module
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x ADS1115模块
- en: 1 x 10k Ω potentiometer
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 10k Ω 电位计
- en: 'To maximize your learning in this chapter, there are some assumptions made
    regarding pre-existing knowledge and experience:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地提高您在本章中的学习效果，对于预先存在的知识和经验做出了一些假设：
- en: From an electronic interfacing perspective, I will assume that you have read the
    preceding 11 chapters of this book and are comfortable working with the PiGPIO
    and ADS1115 Python libraries featured throughout this book.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从电子接口的角度来看，我假设您已经阅读了本书前面的11章，并且对本书中始终出现的PiGPIO和ADS1115 Python库的工作感到满意。
- en: From a programming perspective, I am assuming existing knowledge of **Object-Oriented
    Programming** (**OOP**) techniques and how they are implemented in Python.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从编程的角度来看，我假设您已经掌握了**面向对象编程**（**OOP**）技术以及它们在Python中的实现。
- en: Familiarity with the concepts *event-loop*, *threads,* *publisher-subscriber,* and
    *synchronous versus asynchronous* paradigms will also be advantageous.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉*事件循环*、*线程*、*发布者-订阅者*和*同步与异步*范式的概念也将是有利的。
- en: If any of the preceding topics are unfamiliar, you will find many online tutorials
    available covering these topics in great detail. Please see the *Further reading*
    section at the end of the chapter for suggestions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前述任何主题对您来说是陌生的，您会发现有很多在线教程详细介绍了这些主题。请参阅本章末尾的*进一步阅读*部分以获取建议。
- en: Building and testing our circuit
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试我们的电路
- en: 'I''m going to present the circuit and programs for this chapter in the form
    of a practical exercise. Let''s pretend for a moment that we have been asked to
    design and build a *gizmo* that has the following requirements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以实际练习的形式呈现本章的电路和程序。让我们假设我们被要求设计和构建一个具有以下要求的*小玩意*：
- en: It has two LEDs that blink.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有两个LED灯在闪烁。
- en: A potentiometer is used to adjust the rate that the LED(s) blink.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the program starts, both LEDs will blink at the same rate determined by
    the position of the potentiometer.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blinking rate of 0 seconds means an LED is off, while the maximum blinking
    rate of 5 seconds means an LED is on for 5 seconds, then off for 5 seconds, before
    repeating the cycle.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A push-button is used to select which LED changes its blinking rate when the
    potentiometer is adjusted.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the push-button is pressed and held for 0.5 seconds, all LEDs synchronize
    to the same rate, determined by the potentiometer's position.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, the program code should easily scale to support more LEDs with minimal
    coding effort.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a scenario illustrating the gizmo''s use:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: After applying power (and the program starts), all LEDs start to blink at a
    rate of 2.5 seconds because the potentiometer's dial is at the midpoint (50%)
    of its rotation.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user adjusts the potentiometer to make the *first* LED blink at a rate of
    4 seconds.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the user briefly presses and releases the push-button so that the potentiometer
    will change the *second* LED's blinking rate.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the user adjusts the potentiometer so that the *second* LED blinks at a
    rate of 0.5 seconds.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the user presses and holds the button down for 0.5 seconds to make
    both the *first* and *second* LED blink in unison at a rate of 0.5 seconds (the
    rate set by the potentiometer at *step 4*).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now for the challenge I mentioned – before we get into this chapter's circuit
    and code, I challenge you to stop reading now and try to create a circuit and
    write a program that implements the preceding requirements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: You will find a short video demonstrating these requirements at [https://youtu.be/seKkF61OE8U](https://youtu.be/seKkF61OE8U).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: I anticipate that you will encounter challenges and have questions about the
    best approach to take. There is no one best approach; however, by having your
    own implementation – whether it works or not – you will have something to compare and
    contrast with the four solutions that I will present during this chapter. I'm
    confident that if you have a go yourself first, then you will gain a deeper understanding
    and more insight. Hey, perhaps you'll create an even better solution!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need suggestions to help get you started, here they are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: We first covered LEDs and push-buttons in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first covered potentiometers and analog input using an ADS1115 module in [Chapter
    5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry Pi
    to the Physical World*.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you are ready, we will look at a circuit that fulfills the aforementioned
    requirements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Building the reference circuit
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Figure 12.1* is a circuit that meets the requirements we just listed. It
    has a push-button, a potentiometer in the form of a voltage divider connected
    to an ADS1115 analog-to-digital converter, and two LEDs connected by current limiting
    resistors. Adding additional LEDs will be as simple as wiring more LED and resistors
    pairs between GND and a free GPIO pin:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1ce6b28c-49d3-4bae-bfce-ee96b13a20ab.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Reference circuit schematic
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not already created a similar circuit on your own, we will create
    this circuit now on your breadboard. We will build this circuit in three parts.
    Let''s get started:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e0af2da2-7c85-476e-97eb-25ad65088378.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Reference circuit (part 1 of 3)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to create the first part of our breadboard build
    where we place the components. The step numbers match the numbers in black circles
    in *Figure 12.2*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Place the ADS1115 module into your breadboard.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the potentiometer into your breadboard.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place an LED into your breadboard, taking care to orientate the LED's legs as
    illustrated.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a second LED into your breadboard, taking care to orientate the LED's
    legs as illustrated.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 200Ω resistor (R1) into your breadboard. One end of this resistor shares
    the same row as the anode leg of the LED placed in *step 3*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个200Ω电阻（R1）放入您的面包板中。这个电阻的一端与*步骤3*中放置的LED的阳极腿共用一行。
- en: Place another 200Ω resistor (R2) into your breadboard. One end of this resistor
    shares the same row as the anode leg of the second LED you placed in *step 5*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个200Ω电阻（R2）放入您的面包板中。这个电阻的一端与*步骤5*中放置的第二个LED的阳极腿共用一行。
- en: Place the push-button into your breadboard.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按键放入您的面包板中。
- en: 'Now that we have placed the components into the breadboard, let''s start wiring
    them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将组件放入面包板中，让我们开始将它们连接起来：
- en: '![](assets/332b67b8-0242-43a3-a206-485f0325e118.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/332b67b8-0242-43a3-a206-485f0325e118.png)'
- en: Figure 12.3 – Reference circuit (part 2 of 3)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - 参考电路（2/3部分）
- en: 'Here are the steps to follow to continue with the second part of our breadboard
    build. The step numbers match the numbers in black circles in *Figure 12.3*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是继续进行面包板组装的步骤。步骤编号与*图12.3*中的黑色圆圈中的编号相匹配：
- en: Connect a 3.3-volt pin from your Raspberry Pi to the positive rail of the left-hand
    side power rail.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的3.3伏特引脚连接到左侧电源轨的正电源轨。
- en: Connect the Vdd terminal of the ADS1115 to the positive rail of the left-hand
    side power rail.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115的Vdd端连接到左侧电源轨的正电源轨。
- en: Connect the GND terminal of the ADS1115 to the negative rail of the left-hand
    side power rail.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115的GND端连接到左侧电源轨的负电源轨。
- en: Connect the SCL terminal of the ADS1115 to the SCL pin on your Raspberry Pi.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115的SCL端连接到树莓派的SCL引脚。
- en: Connect the SDA terminal of the ADS1115 to the SDA pin on your Raspberry Pi.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ADS1115的SDA端连接到树莓派的SDA引脚。
- en: Connect a GND pin on your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的GND引脚连接到左侧电源轨的负电源轨。
- en: Connect an outer terminal of the potentiometer to the positive rail of the left-hand
    side power rail.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器的外端连接到左侧电源轨的正电源轨。
- en: Connect another outer terminal of the potentiometer to the negative rail of
    the left-hand side power rail.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器的另一个外端连接到左侧电源轨的负电源轨。
- en: Connect the center terminal of the potentiometer to port A0 of the ADS1115.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电位器的中间端口连接到ADS1115的A0端口。
- en: Can you recall that the potentiometer in this configuration is creating a variable
    voltage divider? If not, you may want to revisit [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*. Furthermore, if you would like a
    detailed refresher on the ADS1115 module, please refer to [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting your Raspberry Pi to the Physical World*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否记得，这种配置中的电位器正在创建一个可变电压分压器？如果没有，您可能需要重新阅读[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)，*软件工程师的电子学101*。此外，如果您想对ADS1115模块进行详细复习，请参阅[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)，*将树莓派连接到物理世界*。
- en: 'Let''s continue with our build:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续组装：
- en: '![](assets/2c48c450-5450-4f1e-b387-70c8aaf5848a.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2c48c450-5450-4f1e-b387-70c8aaf5848a.png)'
- en: Figure 12.4 – Reference circuit (part 3 of 3)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 参考电路（3/3部分）
- en: 'Here are the steps to follow to continue with the final part of our breadboard
    build. The step numbers match the numbers in black circles in *Figure 12.4*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是继续进行面包板组装的最后部分的步骤。步骤编号与*图12.4*中的黑色圆圈中的编号相匹配：
- en: Connect GPIO 26 from your Raspberry Pi to the 200 Ω resistor (R1).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GPIO 26连接到200Ω电阻（R1）。
- en: Connect GPIO 19 from your Raspberry Pi to the second 200 Ω resistor (R2).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GPIO 19连接到第二个200Ω电阻（R2）。
- en: Connect GPIO 21 from your Raspberry Pi to one leg of the push-button.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GPIO 21连接到按键的一腿。
- en: Connect the two cathode legs of the LEDs together.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个LED的阴极腿连接在一起。
- en: Connect the cathode legs of the LEDs to the negative rail of the left-hand side
    power rail.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED的阴极腿连接到左侧电源轨的负电源轨。
- en: Connect the second leg of the push-button to the negative rail of the left-hand
    side power rail.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按键的第二腿连接到左侧电源轨的负电源轨。
- en: Now that we have finished our circuit build, we are ready to run the sample
    code to make the circuit work.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了电路组装，我们准备运行示例代码使电路工作。
- en: Running the examples
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'This chapter comes with four different versions of code that can work with
    the circuit shown previously in *Figure 12.1.* You will find the code in the `chapter12`
    folder organized by version:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了四个不同版本的代码，可以与*图12.1*中先前显示的电路配合使用。您将在`chapter12`文件夹中按版本组织的代码：
- en: '`chapter12/version1_eventloop` is an *event-loop*-based example.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter12/version1_eventloop`是一个基于*事件循环*的示例。'
- en: '`chapter12/version2_thread` is a *thread and callback*-based example.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter12/version2_thread`是一个基于*线程和回调*的示例。'
- en: '`chapter12/version3_pubsub` is a *publisher-subscriber-*based example.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter12/version3_pubsub`是一个基于*发布者-订阅者*的示例。'
- en: '`chapter12/version4_asyncio` is an**Asynchronous IO** *(***AsyncIO***)*-based
    example.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter12/version4_asyncio`是一个**异步IO**（***AsyncIO***)*-based示例。'
- en: All versions are functionally equivalent; however, they differ in their code
    structure and design. We will discuss each version in greater detail after we
    test our circuit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有版本在功能上是等效的；但是它们在代码结构和设计上有所不同。在测试电路后，我们将更详细地讨论每个版本。
- en: 'Here are the steps to follow to run each version (starting with version 1)
    and test the circuit:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行每个版本（从版本1开始）并测试电路的步骤：
- en: Change to the `version1_eventloop` folder.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`version1_eventloop`文件夹。
- en: Briefly look over the `main.py` source file, and any additional Python files
    in the folder, to get a feel for what they contain and how the program is structured.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简要查看`main.py`源文件，以及文件夹中的任何其他Python文件，了解它们包含的内容以及程序的结构。
- en: Run `main.py` in a terminal (remember to switch into the chapter's virtual environment
    first).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行`main.py`（记得先切换到本章的虚拟环境）。
- en: At this point, if you receive errors regarding I2C or ADS11x5, remember that
    there is the i2cdetect tool, which can be used to confirm that an I2C device such
    as the ADS1115 is correctly connected and visible to your Raspberry Pi. Refer
    to [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry
    Pi to the Physical World*, for more information.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Turn the potentiometer dial and observe the *first* LED's blinking rate changes.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the button briefly.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn the potentiometer dial and observe the *second* LED's blinking rate changes.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press and hold the button for 0.5 seconds, and observe that both LEDs now blink
    in unison at the same rate.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is an example of the terminal output you will receive:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Press *Ctrl *+ *C* in your terminal to exit the program.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 1* through *8* for `version2_threads`, `version3_pubsub`, and
    `version4_asyncio`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have just tested and glanced at the source code of four different programs
    (perhaps five, if you challenged yourself to create your own) that all achieve
    exactly the same end result but in different ways.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to understand how these programs are built. Let's begin with the
    *event-loop* version of the program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the event-loop approach
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start our code exploration by discussing an event-loop-based approach
    to building the sample gizmo that we just tested in the previous section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The code for the event-loop-based approach can be found in the `chapter12/version1_eventloop`
    folder. You will find one file named `main.py`. Please take the time now to stop
    and read through the code contained in `main.py` to get a basic understanding
    of how the program is structured and how it works. Alternatively, you could add
    breakpoints or insert `print()` statements into the code and run it again to understand
    how it works.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: How did it go, and what did you notice? If you thought *yuck* or got lost in
    the web of loops, `if` statements, and state variables, then well done! This means
    you have invested the time to consider this approach and how the code is constructed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'What I mean by an event-loop approach is demonstrated in the code by the `while
    True:` loop abbreviated on line 1:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Granted, I could have used functions and even external classes to reduce the
    quantity (and possibly enhance the readability) of the code within the `while`
    loop, however, the overall design paradigm remains the same – the body of the
    program control is sitting in a perpetual loop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Arduino programming, you will be intimately familiar
    with this approach to programming. That's why I titled this section *event-loop*
    due to the similarity of approach and the popularity of the term. Notwithstanding,
    note that the term *event-loop* has a wider context within Python, as we will
    see when we look at the AsyncIO (version 4) of our program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have realized that this event-loop approach to programming has been
    used by many of the examples throughout this book. Three examples are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: When we wanted a timed event such as blinking an LED ([Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling the DHT 11 or DHT 22 temperature/humidity sensor ([Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml),
    *Measuring Temperature, Humidity, and Light Levels*)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling the ADS1115 analog-to-digital converter connected to a **Light-Dependent-Resistor**
    (**LDR**) (also [Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml), *Measuring
    Temperature, Humidity, and Light Levels*)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this context, for a single focused example, event-loops make sense. They
    even make sense purely for convenience when you're hacking about and trying out
    new ideas and learning about a new actuator or sensor. However, as demonstrated
    by our `version1_eventloop/main.py` program, as soon as you add in multiple components
    (such as a potentiometer, two LEDs, and a push-button) and want to make them work
    together for a definite purpose, the code gets complex fast.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于一个单一的专注示例，事件循环是有意义的。甚至在你进行试验和学习新的执行器或传感器时，它们也是纯粹为了方便而有意义的。然而，正如我们的`version1_eventloop/main.py`程序所示，一旦你添加了多个组件（比如电位计、两个LED和一个按钮）并且想要让它们为一个明确的目的一起工作，代码就会迅速变得复杂。
- en: 'For instance, consider the following code on line 3, which is responsible for
    blinking all the LEDs, and remember that this block of code is evaluated once
    per loop iteration and is responsible for blinking every LED:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下第3行的以下代码，它负责让所有LED闪烁，并记住这个代码块在每次循环迭代中被评估一次，负责让每个LED闪烁：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compare this to a vanilla alternative (similar to what we will see in other
    approaches), which at a moment''s glance is significantly easier to understand:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与纯粹的替代方案相比（类似于我们将在其他方法中看到的），一眼看去，它们显然更容易理解：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you also consider the following block of code, starting on line 2, which
    is responsible for detecting button presses, then you find nearly 40 lines of
    code (in the actual `main.py` file) just to detect what the button is doing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再考虑一下从第2行开始的以下代码块，它负责检测按钮按下，那么你会发现在实际的`main.py`文件中有将近40行代码，只是为了检测按钮的操作：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will count multiple variables at play – `button_pressed`, `button_held`,
    `was_pressed`, and `button_hold_timer` – that are all evaluated at every `while`
    loop iteration and are there primarily to detect a *button-hold* event. I'm sure
    you can appreciate that writing and debugging this code like this can be tedious
    and error-prone.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现有多个变量在起作用 - `button_pressed`、`button_held`、`was_pressed`和`button_hold_timer`
    - 它们在每次`while`循环迭代中都被评估，并且主要用于检测*按钮按住*事件。我相信你会理解，像这样编写和调试这样的代码可能会很乏味和容易出错。
- en: We could have used a `PiGPIO` *callback* to handle button presses outside of
    the `while` loop, or even a GPIO Zero `Button` class. Both approaches would help
    reduce the complexity of the button-handling logic. Likewise, maybe we could have
    mixed in a GPIO Zero `LED` class to handle the LED blinking. However, if we did,
    our example would not be a purely event-loop-based example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用`PiGPIO` *回调*来处理`while`循环之外的按钮按下，或者使用GPIO Zero的`Button`类。这两种方法都有助于减少按钮处理逻辑的复杂性。同样，也许我们本可以混合使用GPIO
    Zero的`LED`类来处理LED的闪烁。然而，如果这样做，我们的示例就不会是一个纯粹基于事件循环的示例。
- en: Now, I'm not saying that event-loops are a bad or wrong approach. They have
    their uses, they are needed, and, in essence, we create one every time we use
    a `while` loop or another looping construct – so the base ideal is everywhere,
    but it's just not an ideal approach to building complex programs, because this
    approach makes them harder to understand, maintain, and debug.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我并不是说事件循环是一种不好或错误的方法。它们有它们的用途，是必需的，实际上，每当我们使用`while`循环或其他循环结构时，我们都会创建一个 -
    所以基本理念无处不在，但这并不是构建复杂程序的理想方法，因为这种方法使它们更难理解、维护和调试。
- en: Whenever you find that your program is heading down this event-loop path, stop
    and reflect, because it might be time to consider refactoring your code to employ
    a different – and more maintainable – approach, such as a threaded/callback approach,
    which we will look at next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发现你的程序正在走这条事件循环的道路时，停下来反思一下，因为也许是时候考虑重构你的代码，采用不同的 - 更易维护的 - 方法，比如线程/回调方法，我们将在下面看到。
- en: Exploring a threaded approach
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索线程方法
- en: Now that we have explored an event-loop-based approach to creating our program,
    let's consider an alternative approach built using threads, callbacks, and OOP
    and see how this approach improves code readability and maintainability and promotes
    code reuse.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了一个基于事件循环的方法来创建我们的程序，让我们考虑一种使用线程、回调和面向对象编程的替代方法，并看看这种方法如何改进了代码的可读性和可维护性，并促进了代码的重用。
- en: 'The code for the *threaded*-based approach can be found in the `chapter12/version2_threads`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基于*线程*的方法的代码可以在`chapter12/version2_threads`文件夹中找到。你会找到四个文件 - 主程序`main.py`和三个类定义：`LED.py`、`BUTTON.py`和`POT.py`。
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then,
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请花点时间停下来阅读`main.py`中包含的代码，以基本了解程序的结构和工作原理。然后，继续查看`LED.py`、`BUTTON.py`和`POT.py`。
- en: 'How did it go, and what did you notice? I''d guess that you found this version
    of the program (while reading through `main.py`) much quicker and easier to understand
    and noticed that there is no cumbersome and complex `while` loop, but instead
    a `pause()` call, which is necessary to stop our program from exiting, as summarized on
    line 3:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何进行的，你注意到了什么？我猜想你会发现这个程序的版本（在阅读`main.py`时）更快更容易理解，并且注意到没有繁琐复杂的`while`循环，而是一个`pause()`调用，这是必要的，用于阻止我们的程序退出，如第3行总结的那样：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this program example, we have employed object-oriented techniques and componentized
    our program using three classes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序示例中，我们使用了面向对象的技术，并使用了三个类来组件化我们的程序：
- en: A button class (`BUTTON.py`), which takes care of all the button logic
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮类（`BUTTON.py`），负责所有按钮逻辑
- en: A potentiometer class (`POT.py`), which takes care of all the potentiometer
    and analog-to-digital conversion logic
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个电位计类（`POT.py`），负责所有电位计和模拟数字转换逻辑
- en: A LED class (`LED.py`), which is responsible for making a *single* LED flash
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个LED类（`LED.py`），负责让*单个*LED闪烁
- en: By using an OOP approach, our `main.py` code is greatly simplified. Its role
    is now to create and initialize class instances and house the callback handlers
    and logic that make our program work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用面向对象的方法，我们的`main.py`代码大大简化了。它的作用现在是创建和初始化类实例，并包含使我们的程序工作的回调处理程序和逻辑。
- en: 'Consider the following OOP approach for our push-button:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下我们的按钮的面向对象的方法：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compared to the button-handing code from the event-loop example, this is greatly
    simplified and much more readable – it's pretty explicit where and how this code
    is responding to the button pressed at line 1 and button holds on line 2.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件循环示例中的按钮处理代码相比，这大大简化了并且更易读——很明显这段代码在第1行响应按钮按下，第2行响应按钮保持。
- en: 'Let''s consider the `BUTTON` class, which is defined in the `BUTTON.py` file.
    This class is an enhancing wrapper around a PiGPIO callback function that turns
    the `HIGH`/`LOW` states of the button''s GPIO pin into `PRESSED`, `RELEASED`,
    and `HOLD` events, as summarized in the following code at line 1 in `BUTTON.py`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下`BUTTON`类，它在`BUTTON.py`文件中定义。这个类是一个增强的包装器，可以将按钮的GPIO引脚的`HIGH`/`LOW`状态转换为`PRESSED`、`RELEASED`和`HOLD`事件，如在`BUTTON.py`的第1行中总结的代码所示：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compared to the button-handling code of the event-loop example, we did not introduce
    and interrogate multiple state variables to detect the button-hold event, but
    instead, this logic is reduced to a simple and linear approach at line 2.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件循环示例中的按钮处理代码相比，我们没有引入和审问多个状态变量来检测按钮保持事件，而是将这个逻辑简化为在第2行的简单线性方法。
- en: Next, as we consider the `POT` class (defined in `POT.py`) and `LED` class (defined
    in `LED.py`), we will see threads come into our program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当我们考虑`POT`类（在`POT.py`中定义）和`LED`类（在`LED.py`中定义）时，我们将看到线程进入我们的程序。
- en: Did you know that even in a multi-threaded Python program, only one thread is
    active at a time? While it seems counter-intuitive, it was a design decision known
    as the **Global Interpreter Lock** (**GIL**) made back when the Python language
    was first created. If you want to learn more about the GIL and the many other
    forms of achieving concurrency with Python, you will find resources in the *Further
    reading* section of this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道即使在多线程的Python程序中，也只有一个线程在活动吗？虽然这似乎违反直觉，但这是Python语言最初创建时做出的一个称为**全局解释器锁**（**GIL**）的设计决定。如果您想了解更多关于GIL和使用Python实现并发的其他形式的信息，您可以在本章的*进一步阅读*部分找到相关资源。
- en: 'The following is the thread run method for the `POT` class, which can be found
    in the `POT.py` source file, and illustrates, starting on line 1, the approach
    of intermediately polling the ADS1115 ADC to determine the potentiometer''s position.
    We''ve seen this polling example several times already throughout this book, starting
    back in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your
    Raspberry Pi to the Physical World*, where we first discussed analog-to-digital
    conversion, the ADS1115 module, and potentiometers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`POT`类的线程运行方法，可以在`POT.py`源文件中找到，从第1行开始说明了中间轮询ADS1115 ADC以确定电位器位置的方法。我们已经在本书中多次看到这个轮询示例，最早是在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中，*将您的树莓派连接到物理世界*，我们首次讨论模数转换、ADS1115模块和电位器：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The difference with our code here is that we are monitoring the ADC for voltage
    changes on line 2 (for example, when a user turns the potentiometer), and turning
    them into a callback on line 3, which you will have seen handled in `main.py`
    when you reviewed the source code in that file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的代码不同之处在于我们正在监视ADC上的电压变化（例如，当用户转动电位器时），并将其转换为回调（在第3行），您在审查该文件中的源代码`main.py`时会看到。
- en: 'Let''s now discuss how we are implementing the `version2` LED-related code. As
    you are aware, the basic code pattern for blinking an LED on and off at a defined
    rate involves a `while` loop and a `sleep` statement. This is the approach taken
    in the LED class, as seen in the `run()` method on line 3 in `LED.py`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下我们如何实现`version2` LED相关的代码。正如您所知，闪烁LED的基本代码模式涉及`while`循环和`sleep`语句。这就是LED类中采用的方法，如`LED.py`中第3行的`run()`方法中所示：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I am sure you will agree that this is easier to understand than the approach
    taken by the event-loop approach we discussed in the previous section. It is important
    to remember, however, that the event-loop approach was working with and altering
    the blinking rate of *all* LEDs together in a *single* block of code, and within
    a *single* thread – the program's main thread.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您会同意这比我们在前一节讨论的事件循环方法更容易理解。然而，重要的是要记住，事件循环方法是在*单个*代码块中使用和改变*所有*LED的闪烁速率，并在*单个*线程——程序的主线程中进行的。
- en: Notice the two sleep approaches shown in the preceding code. While the first
    approach using `sleep(self.blink_rate_secs)` is common and tempting, the caveat
    is that it blocks the thread for the full duration of the sleep. As a result,
    the LED will not respond to rate changes immediately and will feel sluggish to
    a user when they turn the potentiometer. The second approach, commended `#Better
    approach`, alleviates this issue and allows the LED to respond to rate changes
    in (near) real time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面代码中显示的两种睡眠方法。虽然使用 `sleep(self.blink_rate_secs)` 的第一种方法很常见且诱人，但需要注意的是它会阻塞线程，使其在整个睡眠期间无法立即响应速率变化，当用户转动电位器时会感觉迟钝。第二种方法，称为
    `#Better approach`，缓解了这个问题，使LED能够（近乎）实时地响应速率变化。
- en: Our `version2` program example using the LED class with its own internal thread
    now means that we have multiple threads – one per LED – all making the LEDs blink
    independently to one another.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`version2`程序示例使用LED类及其自己的内部线程，这意味着我们现在有多个线程——每个LED一个——都独立地使LED独立地闪烁。
- en: Can you think of any potential problems this may introduce? Okay, it might be
    obvious if you have read through the `version2` source files – it's the synchronization
    of all LEDs to blink at the same rate in unison when the button is held for 0.5
    seconds!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到这可能引入的任何潜在问题吗？好吧，如果你已经阅读了`version2`源文件，这可能是显而易见的——当按钮按下0.5秒时，同步所有LED以同样的速率同时闪烁！
- en: By introducing multiple threads, we have introduced multiple timers (that is,
    the `sleep()` statement), so each thread is blinking on its own independent schedule,
    and not from a common reference point in terms of a starting timebase.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入多个线程，我们引入了多个定时器（即`sleep()`语句），因此每个线程都在自己独立的时间表上闪烁，而不是从一个共同的参考点开始闪烁。
- en: This means that if we simply called `led.set_rate(n)` on multiple LEDs, while
    they would all blink on and off at the rate *n*, they would not necessarily blink
    in unison.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们简单地在多个LED上调用`led.set_rate(n)`，虽然它们都会以速率*n*闪烁，但它们不一定会同步闪烁。
- en: A simple solution to this issue is to synchronize the turning off of all LEDs
    before we start them blinking at the same rate. That is, we start them blinking
    from a common state (that is, off), and start them blinking together.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个简单方法是在开始以相同速率闪烁之前同步关闭所有LED。也就是说，我们从一个共同的状态（即关闭）开始让它们一起闪烁。
- en: 'This approach is shown in the following code snippet starting at line 1 in
    `LED.py`. The core of the synchronization is achieved by the `led._thread.join()`
    statements on line 2:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在`LED.py`的第1行开始的以下代码片段中显示。同步的核心是在第2行的`led._thread.join()`语句中实现的：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a good first pass at synchronization, and for practical purposes, it
    works well for our situation. As mentioned, all we are doing is ensuring our LEDs
    start blinking together from an off state at the same time (well, very, very,
    very close to the same time, subject to the time taken for Python to iterate through
    the `for` loops).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同步的一个很好的第一步，对于我们的情况来说，实际上效果很好。正如前面提到的，我们所做的就是确保我们的LED从关闭状态同时开始闪烁（嗯，非常非常接近同时，取决于Python迭代`for`循环所花费的时间）。
- en: Try commenting out `led._thread.join()` and the embodying `for` loop on line
    2 in the preceding code and run the program. Make the LEDs blink at different
    rates, then try to synchronize them by holding down the button. Does it always
    work?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将前面代码中第2行的`led._thread.join()`和包含的`for`循环注释掉，然后运行程序。让LED以不同的速率闪烁，然后尝试通过按住按钮来同步它们。它总是有效吗？
- en: However, it must be noted that we are still dealing with multiple threads and
    independent timers to make our LEDs blink, so the potential for a time drift to
    occur is present. If this ever presented a practical issue, we would then need
    to explore alternative techniques to synchronize the time in each thread, or we
    could create and use a single class to manage multiple LEDs together (basically
    using the approach from the event-loop example, only refactoring it into a class
    and a thread).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但必须指出的是，我们仍然在处理多个线程和独立的定时器来让我们的LED闪烁，因此存在时间漂移的可能性。如果这曾经成为一个实际问题，那么我们将需要探索替代技术来同步每个线程中的时间，或者我们可以创建并使用一个单一的类来管理多个LED（基本上使用事件循环示例中的方法，只是将其重构为一个类和一个线程）。
- en: The takeaway here regarding threads is that when you introduce threads to your
    applications, you can introduce timing issues that *may* be designed around or
    synchronized.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程的要点是，当您将线程引入应用程序时，您可能会引入*可能*可以设计或同步的时间问题。
- en: If your first pass at a prototype or new program involves an event-loop-based
    approach (as I often do), then as you refactor that code out into classes and
    threads, always think about any timing and synchronizing issues that may arise.
    Discovering synchronization-related bugs by accident during testing (or worse,
    when in production) is frustrating as they can be hard to reliably replicate,
    and could result in the need for extensive rework.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的原型或新程序的第一次尝试涉及基于事件循环的方法（就像我经常做的那样），那么当你将代码重构为类和线程时，始终要考虑可能出现的任何时间和同步问题。在测试期间意外发现与同步相关的错误（或更糟糕的是，在生产中）是令人沮丧的，因为它们很难可靠地复制，并且可能导致需要进行大量的重做。
- en: We've just seen how to create our sample gizmo program using OOP techniques,
    threads, and callbacks. We've seen how this approach results in easier to read
    and maintain code, and we also discovered the additional requirement and effort
    needed to synchronize threaded code. Next, we will look at the third variation
    of our program, which is based around a publisher-subscriber model.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用面向对象编程技术、线程和回调创建样本小工具程序。我们已经看到了这种方法导致了更容易阅读和维护的代码，同时也发现了需要同步线程代码的额外要求和工作。接下来，我们将看一下我们的程序的第三种变体，它是基于发布-订阅模型的。
- en: Exploring the publisher-subscriber alternative
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索发布-订阅的替代方法
- en: Now that we have seen an approach to creating our program using threads, callbacks,
    and OOP techniques, let's consider a third approach using a *publisher-subscriber*
    model.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了使用线程、回调和面向对象编程技术创建程序的方法，让我们考虑第三种方法，使用*发布-订阅*模型。
- en: 'The code for the publisher-subscriber approach can be found in the `chapter12/version3_pubsub`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅方法的代码可以在`chapter12/version3_pubsub`文件夹中找到。你会找到四个文件——主程序`main.py`和三个类定义：`LED.py`、`BUTTON.py`和`POT.py`。
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then,
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请花时间停下来阅读`main.py`中包含的代码，以基本了解程序的结构和工作原理。然后，继续查看`LED.py`、`BUTTON.py`和`POT.py`。
- en: What you will have noticed is that the overall program structure (especially
    the class files) is very similar to the `version2` thread/callback example that
    we covered in the previous heading.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，整体程序结构（特别是类文件）与我们在上一个标题中介绍的`version2`线程/回调示例非常相似。
- en: You may also have realized that this approach is very similar in concept to
    the publisher/subscribing method employed by MQTT, which we discussed in detail
    in [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml), *Networking with MQTT,
    Python, and the Mosquitto MQTT Broker*. The main difference is that in our current
    `version3` example, our publisher-subscribing context is confined just to our
    program run-time environment, not a network-distributed set of programs, which
    was the scenario for our MQTT examples.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也意识到，这种方法在概念上与MQTT采用的发布者/订阅者方法非常相似，我们在[第4章](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml)中详细讨论了MQTT、Python和Mosquitto
    MQTT Broker的网络。主要区别在于，在我们当前的“version3”示例中，我们的发布者-订阅者上下文仅限于我们的程序运行时环境，而不是网络分布式程序集，这是我们MQTT示例的情况。
- en: I have implemented the publishing-subscribing layer in `version3` using the
    `PyPubSub` Python library, which is available from [pypi.org](https://pypi.org)
    and is installed using `pip`. We will not discuss this library in any detail,
    as the overall concepts and use of this type of library should already be familiar
    to you, and if not, I have no doubt that you will immediately understand what's
    going on once you review the `version3` source code files (if you have not already
    done so).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用`PyPubSub` Python库在“version3”中实现了发布-订阅层，该库可以从[pypi.org](https://pypi.org)获取，并使用`pip`安装。我们不会详细讨论这个库，因为这种类型的库的整体概念和使用应该已经很熟悉了，如果没有，我相信一旦你审查了“version3”源代码文件（如果你还没有这样做），你会立刻明白发生了什么。
- en: There are alternative PubSub libraries available for Python through PyPi.org.
    The choice to use `PyPubSub` for this example was due to the quality of its documentation
    and the examples provided there. You will find a link to this library in the *Technical
    requirements* section at the start of this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过PyPi.org提供了其他可选的PubSub库。选择在这个例子中使用`PyPubSub`是因为它的文档质量和提供的示例。你会在本章开头的*技术要求*部分找到这个库的链接。
- en: 'Due to the similarity of the `version2` (threaded approach) and `version3`
    (publisher-subscriber approach) examples, we will not discuss each code file in
    detail, other than to point out that the core differences:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“version2”（线程方法）和“version3”（发布者-订阅者方法）示例的相似性，我们不会详细讨论每个代码文件，只是指出核心差异：
- en: 'In `version2` (threaded), this is how our `led`, `button`, and `pot` class
    instances communicate with one another:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“version2”（线程）中，这是我们的`led`、`button`和`pot`类实例之间的通信方式：
- en: We registered callback handlers in `main.py` on the `button` and `pot` class
    instances.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`main.py`上注册了`button`和`pot`类实例的回调处理程序。
- en: '`button` and `pot` send events (for example, a button press or potentiometer
    adjustment) via this callback mechanism.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`button`和`pot`通过这种回调机制发送事件（例如按钮按下或电位器调整）。'
- en: We interacted with the LED class instances directly using the `set_rate()` instance
    method and the `set_rate_all()` class method.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们直接使用`set_rate()`实例方法和`set_rate_all()`类方法与LED类实例进行交互。
- en: 'In `version3 `(publisher-subscriber), here is the intra-class communication
    structure and design:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“version3”（发布者-订阅者）中，这是类内通信结构和设计：
- en: Every class instance is very loosely coupled.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类实例都是非常松散耦合的。
- en: There are no callbacks.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有回调。
- en: We do not interact with any class instances directly after they are created
    and registered with `PyPubSub`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类实例创建并注册到`PyPubSub`之后，我们不再直接与任何类实例进行交互。
- en: All communication between classes and threads occurs using the messaging layer
    provided by `PyPubSub`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类和线程之间的通信都是使用`PyPubSub`提供的消息层进行的。
- en: Now, to be honest, our gizmo program does not benefit from a publisher-subscriber
    approach. My personal preference is to adopt the callback version for a small
    program like this one. However, I have provided the publisher-subscriber alternative
    implementation as a point of reference so that you have this alternative to consider
    for your own needs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，说实话，我们的小玩意程序并不从发布者-订阅者方法中受益。我个人偏好采用回调版本来处理这样一个小程序。然而，我提供了发布者-订阅者的替代实现作为参考，这样你就有这个选择来考虑你自己的需求。
- en: Where a publisher-subscriber approach shines is in more complex programs where
    you have many components (and here I mean software components, not necessarily electronics
    components) that need to share data and can do so in an asynchronous PubSub-style
    nature.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者-订阅者方法在更复杂的程序中表现出色，其中有许多组件（这里指的是软件组件，不一定是电子组件）需要共享数据，并且可以以异步的发布者-订阅者方式进行。
- en: We're presenting the coding and design approaches in this chapter in four very
    discrete and focused examples. In practice, however, it's common to combine these
    approaches (and other design patterns) in a hybrid and mixed fashion when creating
    your programs. Remember, the approach or combination of approaches to use is whatever
    makes the most sense for what you are trying to achieve.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中以四个非常离散和专注的例子来展示编码和设计方法。然而，在实践中，当创建程序时，通常会将这些方法（以及其他设计模式）以混合的方式结合起来。记住，使用的方法或方法组合应该是对你所要实现的目标最有意义的。
- en: As we have just discussed, and you will have seen as you reviewed the `version3`
    code, a publisher-subscriber approach to our gizmo program is a simple variation
    of the thread and callback approach, where instead of using callbacks and interacting
    with class instances directly, we standardize all code communication to a messaging
    layer. Next, we will look at our final approach to coding our gizmo program, this
    time taking the AsyncIO approach.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚讨论过的，你在审查“version3”代码时会看到，我们的小玩意程序的发布者-订阅者方法是线程和回调方法的一个简单变体，我们不再直接使用回调与类实例交互，而是将所有代码通信标准化到一个消息层。接下来，我们将看看我们编写小玩意程序的最终方法，这次采用AsyncIO方法。
- en: Exploring an AsyncIO approach
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索AsyncIO方法
- en: So far in this chapter, we have seen three different programming approaches
    to achieving the same end goal. Our fourth and final approach will be built using
    the AsyncIO libraries offered by Python 3\. As we will see, this approach shares
    similarities and differences with our previous approaches, and also adds an extra
    dimension to our code and how it operates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Speaking from my own experience, this approach can feel complex, cumbersome,
    and confusing the first time you experience asynchronous programming in Python.
    Yes, there is a steep learning curve to asynchronous programming (and we can only
    barely scratch the surface in this section). However, as you learn to master the
    concepts and gain practical experience, you may start to discover that it is an
    elegant and graceful way to create programs!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to asynchronous programming in Python, you will find curated
    tutorial links in the *Further reading* section to deepen your learning. It is
    my intention in this section to give you a simple working AsyncIO program that
    focuses on electronic interfacing, which you can use as a reference as you learn
    more about this style of programming.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the asynchronous-based approach can be found in the `chapter12/version4_asyncio`
    folder. You will find four files – the main program, `main.py`, and three class
    definitions: `LED.py`, `BUTTON.py`, and `POT.py`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Please take the time now to stop and read through the code contained in `main.py` to
    get a basic understanding of how the program is structured and how it works. Then
    proceed to review `LED.py`, `BUTTON.py`, and `POT.py`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: If you are also a JavaScript developer – particularly Node.js – you will already
    know that JavaScript is an asynchronous programming language; however, it looks
    and feels very different from what you are seeing in Python! I can assure you
    that the principles are the same. Here is a key reason why they feel very different
    – JavaScript is *asynchronous by default.* As any experienced Node.js developer
    knows, we often have to go to (often extreme) lengths in code to make parts of
    our code behave synchronously. The opposite is true for Python – it's *synchronous
    by default*, and we need to extend extra programming effort to make parts of our
    code behave asynchronously.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'As you read through the source code files, I want you to think about our `version4`
    AsyncIO program as having elements of both the `version1` event-loop-based program
    and the `version2` threaded/callback program. Here is a summary of the key differences
    and similarities:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The overall program structure is very similar to the `version2` thread/callback
    example.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of `main.py`, we have a few new lines of code that we have not seen
    in this book before – for example, `loop = asyncio.get_event_loop()`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the `version2` program, we have used OOP techniques to factor our components
    into classes, which also have a `run()` method – but notice how there is no thread
    instance in these classes and no code related to starting a thread.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the class definition files, `LED.py`, `BUTTON.py`, and `POT.py`, we have
    the `async` and `await` keywords sprinkled around and in the `run()` function,
    and a delay of 0 seconds in the `while` loop – that is, `asyncio.sleep(0)` – so
    we're not really sleeping at all!
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `BUTTON.py`, we are no longer using the PiGPIO callback to monitor a button
    being pressed, but instead polling the button GPIO in a `while` loop.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python 3 AsyncIO library has evolved significantly over time (and still
    is evolving), with new API conventions, the addition of higher-level functionality.
    and deprecated functions. Due to this evolution, code can get out of date with
    the latest API conventions quickly, and two code examples illustrating the same
    underlying concepts can be using seemingly different APIs. I highly recommend
    you glance through the latest Python AsyncIO library API documentation as it will
    give you hints and examples of newer versus older API practices, which may help
    you better interpret code examples.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: I will explain how this program works by walking you through the high-level
    program flow in a simplified way. When you can grasp the general idea of what
    is happening, you are well on your way to understanding asynchronous programming
    in Python.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: You will also find a file named `chapter12/version4_asyncio/main_py37.py`. This
    is a Python 3.7+ version of our program. It uses an API available since Python
    3.7\. If you look through this file, the differences are clearly commented.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `main.py` file, we see the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An asynchronous program in Python evolves around the event-loop. We see this
    created at line 1 and started at line 5\. We'll come back to the registrations
    occurring in between at lines 2, 3, and 4 momentarily.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The overall principle of this asynchronous event-loop is similar to our version1
    event-loop example; however, the semantics are different. Both versions are single-threaded,
    and both sets of code do *go around in a loop*. In `version1`, this was very explicit
    because our main body of code was contained in an outer `while` loop. In our asynchronous
    `version4`, it's more implicit, and has a core difference – it's non-blocking
    *if programmed correctly*, and as we will see soon, this is the purpose of the
    `await asyncio.sleep()` calls in the class `run()` methods.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, we have registered our class `run()` methods with the loop on
    lines 2, 3, and 4\. After we start the event-loop on line 5, here is what happens
    in simplified terms:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The *first* LED''s `run()` function (shown in the following code) is called:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It enters the `while` loop on line 1 and toggles the LED on or off from line
    2, depending on the blinking rate.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it gets to line 3, `await asyncio.sleep(0)`, and *yields* control. At
    this point, the `run()` method is effectively paused, and another `while` loop
    iteration does not start.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control is passed over the *second* LED's `run()` function, and it runs through
    it's `while` loop once until it reaches `await asyncio.sleep(0)`. It then yields
    control.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, the pot instance''s `run()` method (shown in the following code) gets
    a turn to run:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `run()` method performs one iteration of the `while` loop until it reaches `await
    asyncio.sleep(0)`. It then yields control.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Control is passed to the `button` instance''s `run()` method (partly shown
    in the following code), which has multiple `await asyncio.sleep(0)` statements:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As soon as the button's `run()` method reaches any instance of `await asyncio.sleep(0)`,
    it yields control.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, all our registered `run()` methods have had a chance to run, so the *first*
    LED's `run()` method will take control again and perform one `while` loop iteration
    until it reaches `await asyncio.sleep(0)`. Again, at this point it *yields* control
    and the *second* LED's `run()` method gets another turn to run...and the process
    continues over and over, with each `run()` method getting a turn to run in a round-robin
    fashion.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s tie up a few loose ends where you will likely have questions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: What about the button's `run()` function with its many `await asyncio.sleep(0)`
    statements?
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When control is yielded at any `await asyncio.sleep(0)` statement, the function
    yields at this point. The next time the `run()` button gets control, the code
    will continue from the next statement beneath the `await asyncio.sleep(0)` statement
    that yielded.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Why is the sleep delay 0 seconds?
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awaiting a zero-delay sleep is the simplest way to yield control (and please
    note that it is the `sleep()` function from the `asyncio` library, not the `sleep()`
    function from the `time` library). However, you can `await` any asynchronous method,
    but this is beyond the scope for our simple example.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: I have used zero-second delays for this example for simplicity in explaining
    how the program works, but you can use non-zero delays. All this means is that
    the yielding `run()` function would sleep for this period – the event-loop will
    not give it a turn to run until this period expires.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: What about the `async` and `await` keywords – how do I know where to use them?
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This certainly comes with practice; however, here are the basic design rules:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: If you are registering a function (for example, `run()`) with the event-loop,
    the function must start with the `async` keyword.
  id: totrans-243
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Any `async` function must contain at least one `await` statement.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and learning asynchronous programs takes practice and experimentation.
    One of the initial design challenges you will face is knowing where to put `await`
    statements (and how many), and how long you should yield control for. I encourage
    you to play with the `version4` code base, add in your own debugging `print()` or
    logging statements, and just experiment and tinker until you get a feel for how
    it all fits together. At some point, you'll have that *aha* moment, and at that
    point, you have just opened the door to further explore the many advanced features
    offered by the Python AsyncIO libraries.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how an asynchronous program is structured and behaves
    at runtime, I want to give you something to experiment with and ponder.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous experiment
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's try an experiment. Maybe you've wondered how `version4` (AsyncIO) is a
    bit like our `version1` (event-loop) code, only it's been refactored into classes
    just like the `version2` (threaded) code. So, couldn't we just refactor the code
    in the `version1 while` loop into classes, create and call a function them (for
    example, `run()`) in the `while` loop, and not bother with all the asynchronous
    stuff and its extra library and syntax?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Let's try. You will find a version just like this in the `chapter12/version5_eventloop2`
    folder. Try running this version, and see what happens. You'll find that the first
    LED blinks, the second one is always on, and that the button and potentiometer do
    not work.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Can you work out why?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the simple answer: in `main.py`, once the first LED''s `run()` function
    is called, we''re stuck in its `while` loop forever!'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The call to `sleep()` (from the `time` library) does not yield control; it just
    halts the LED's `run()` method for the duration before the next `while` loop iteration
    occurs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Hence, this is an example of why we say synchronous programs are blocking (no
    yielding of control), and why asynchronous programs are non-blocking (they yield
    control and give other code a chance to run).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have enjoyed our exploration of four alternative ways of structuring
    electronic-interfacing programs – and one way we shouldn't. Let's conclude by
    recapping what we have learned in this chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at four different way of structuring a Python program
    that interface with electronics. We learned about an event-loop approach to programming,
    two variations on a thread-based approach – callbacks and a publisher-subscriber
    model – and finished by looking at how an AsyncIO approach to programming works.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Each of the four examples we covered was very discrete and specific in its approach.
    While we briefly discussed the relative benefits and pitfalls of each approach
    along the way, it's worth remembering that in practice, your projects will likely
    use a mixture of these (and potentially other) approaches, depending on the programming
    and interfacing goals you are trying to achieve.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn our attention toward IoT platforms and present
    a discussion of the various options and alternatives that are available for building
    IoT programs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the book:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: When is a publisher-subscriber model a good design approach?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Python GIL, and what implication does it present for classic threading?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a pure event-loop usually a poor choice for complex applications?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is an event-loop approach a bad idea? Why or why not?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `thread.join()` function call?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have used a thread to poll your new analog component via an analog-to-digital
    converter. However, you find that your code behaves sluggishly to changes in the
    component. What could be the problem?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the superior approach to designing an IoT or electronic interfacing
    application in Python – using an event-loop, a thread/callback, the publisher-subscriber
    model, or an AsyncIO-based approach?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [realpython.com](https://realpython.com) website has a range of excellent
    tutorials covering all things concurrency in Python, including the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: What is the Python GIL? [https://realpython.com/python-gil](https://realpython.com/python-gil)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed Up Your Python Program with Concurrency: [https://realpython.com/python-concurrency](https://realpython.com/python-concurrency)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Intro to Threading in Python: [https://realpython.com/intro-to-python-threading](https://realpython.com/intro-to-python-threading)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Async IO in Python: A Complete Walkthrough: [https://realpython.com/async-io-python](https://realpython.com/async-io-python)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are relevant links from the official Python (3.7) API documentation:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Threading: [https://docs.python.org/3.7/library/threading.html](https://docs.python.org/3.7/library/threading.html)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AsyncIO library: [https://docs.python.org/3.7/library/asyncio.htm](https://docs.python.org/3.7/library/asyncio.htm)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing with AsyncIO: [https://docs.python.org/3.7/library/asyncio-dev.html](https://docs.python.org/3.7/library/asyncio-dev.html)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency in Python: [https://docs.python.org/3.7/library/concurrency.html](https://docs.python.org/3.7/library/concurrency.html)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
