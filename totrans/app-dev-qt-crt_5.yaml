- en: Chapter 5. Performance Optimization with Qt Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't use performance analysis tools every day, but we're glad they're there
    when we need them. Commercial tools like the ones that come with Microsoft Visual
    Studio or standalone tools such as IBM's Rational Rose Purify can set you back
    a pretty pile of change—fortunately, Qt Creator has most of what you need built-in,
    or has support for working with open source tools to help you profile the runtime
    and memory performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how we can perform runtime profiling of QML applications
    using the QML performance analyzer, and learn how to read the report it generates.
    We then turn our attention to memory performance analysis with Valgrind using
    Qt Creator, which is a free option to look for memory leaks and heap corruption
    on the Linux platform.
  prefs: []
  type: TYPE_NORMAL
- en: The QML performance analyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt Quick applications are supposed to be fast, with smooth, fluid user interfaces.
    In many cases, that''s easy to accomplish with QML; the contributors to QML and
    the Qt Quick runtime have put a great deal of effort into creating an environment
    that performs well under a wide variety of circumstances. Sometimes, however,
    try as you might, you may find that you just can''t squeeze the performance that
    you''d like out of your application. Some mistakes are obvious, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Doing a lot of compute-intensive tasks between state changes or actions that
    trigger drawing operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessively complex view hierarchies with thousands of elements on the display
    at once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running on very limited hardware (often in combination with the first two problems)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knuth famously said that "Premature optimization is the root of all evil", and
    he's definitely right. However, there might come a time when you need to measure
    the performance of your application, and Qt Creator includes a special performance
    analyzer for just this purpose. With it, you can see how much time your application
    spends in each QML method, as well as measure critical aspects of your application
    that are at the edge of your control, like how long it takes to create your application's
    view hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: QtSlowButton – a Qt Quick application in need of performance tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s analyze the performance of `QtSlowButton`, a poorly-performing example
    program I put together for you in this chapter. `QtSlowButton` has two QML components:
    a button based on the calculator button from [Chapter 3](ch03.html "Chapter 3. Designing
    Your Application with Qt Designer"), *Designing Your Application with Qt Designer*,
    and a view with buttons you can press. Here''s the implementation of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each button simply runs a `for` loop when you push it; its `delay` property
    controls how many times it cycles through the loop. In addition, each button has
    a label, which the button draws in the center of the clickable area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main user interface consists of three buttons in a `Column region`, labeled
    `fast`, `medium`, and `slow`, with progressively longer delays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can either load the source project that comes with this book for this example,
    or you can create a new Qt Quick project and make a button and main view with
    this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To analyze the application''s performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **QML Profiler** from the **Analyze** menu. The application will start,
    and Qt Creator will switch to the **Analyze** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the application itself, click on each application button a few times. You
    will be expected to wait after you click on each button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quit the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The QML Profiler uses TCP/IP to make a connection between the running application
    and the profiler, by default on port 3768\. You may need to tinker with your host's
    firewall settings to get things to work correctly. On Windows, be sure to permit
    the connection in the **Windows Firewall** dialog that appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Analyze** view after running your application.
    The QML Profiler has three tabs, and shows the first by default:'
  prefs: []
  type: TYPE_NORMAL
- en: The first tab is the timeline, indicating what things happened at what point
    through the application, and how long they took
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second tab lists the events the QML application processed, and how much
    time was spent in each event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third tab lists the JavaScript functions the program encountered while running,
    and how long the application spent in total to run each function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, I''ve clicked on the **Handling Signal** row to
    expand the signals the application handled. You can see it handled one signal,
    `onClicked`, a total of three times, and the amount of time spent in each is shown
    as varying bars on the graph. Clearly, if the application were doing something
    that could be optimized, there''d be an opportunity for performance improvement
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![QtSlowButton – a Qt Quick application in need of performance tuning](img/2319OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Timeline view, showing how much time was spent in my onClicked method
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows a different view of this information, indicating
    that up to the limit of numerical accuracy, the application spent all of its measured
    time in the `onClicked` handler for the button: clearly a performance "hot spot"
    in this case. Interestingly, every incident of my JavaScript is measured here,
    including the `$when` clause that puts the opaque filter in front of the button
    when it''s pressed. Looking at the **JavaScript** view can be very helpful if
    you need to look at where things are happening in your application in a broad
    sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '![QtSlowButton – a Qt Quick application in need of performance tuning](img/2319OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The total time spent running different bits of JavaScript in QtSlowButton
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot is likely the most interesting for performance geeks, because
    it shows the amount of time QML spent for each and every event it handled running
    the application. Again, we see the `onClicked` handler consuming the lion''s share
    of the processor resources, but other things like the creation of the rectangles
    for the view and the variable binding for the state of a push button are shown
    as well. Typically, we''ll use the **JavaScript** view to get the broad picture
    of where the problems in your application are, while you''ll use the **Events**
    view to zero in on specific problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![QtSlowButton – a Qt Quick application in need of performance tuning](img/2319OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Events view of the QML Profiler, showing each and every event in QtSlowButton
  prefs: []
  type: TYPE_NORMAL
- en: Finding memory leaks with Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 3](ch03.html "Chapter 3. Designing Your Application
    with Qt Designer"), *Designing Your Application with Qt Designer*, you should
    really get in the habit of using Qt's parent-child relationship when managing
    memory for classes of `QObject` in your application to avoid memory leaks. In
    my time writing Qt applications, the only time I've had to deal with memory leaks
    was when I didn't do that. In addition, using classes such as `QSharedPointer`
    for pointers that aren't based on `QObject` is a good idea too.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, though, you may introduce a memory leak you can't find on your own.
    In that case, a tool such as Valgrind can be a lifesaver; it tracks every memory
    allocation and free operation in your application, alerting you when your program
    terminates if it hasn't freed all the memory it allocates.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Valgrind is a Linux-only tool. If you're writing pure Qt code,
    this shouldn't be a serious issue for you even if you're developing on Windows
    or Mac OS X, because you can port your application to Linux and run it in Valgrind
    there. To do that, you'll want to use an application such as VMware Fusion, VMware
    Player, Microsoft HyperV, or Parallels to set up a virtual machine running Linux
    (I like to use Ubuntu), install Qt Creator, and get your code running there. (Unfortunately,
    if you have Windows-specific code or libraries in your application, this isn't
    an option.)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you build your application for Windows, a commercial leak detector such as
    Rational Purify may be an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing, you should make sure you have Qt Creator running under a
    Linux distribution, and install Valgrind from [http://bit.ly/14QwiQZ](http://bit.ly/14QwiQZ)
    or use your package manager. For example, on Ubuntu, I can install Valgrind with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you use Valgrind, you actually run your application inside of Valgrind;
    instead of starting your application, you start Valgrind, which starts your application.
  prefs: []
  type: TYPE_NORMAL
- en: QtLeakyButton – a Qt C++ application in need of memory help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `QtLeakyButton` application does one thing: it presents a button that when
    clicked, allocates 512 KB of RAM. The following is the code (you can either run
    the sample that accompanies this book, or create a Qt GUI application with a single
    button and a label and use this code for your `MainWindow` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `MainWindow` class has an integer counter and a `ui` slot for the instantiated
    form. The `MainWindow` constructor instantiates this form, and then connects the
    `clicked` signal of `leakButton` to `MainWnidow::leakPressed`. The `leakPressed`
    method just allocates memory and bumps the counter, updating the counter with
    the number of times you've pressed the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Valgrind, we need to add a new run target to your application. To accomplish
    this, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Projects** on the left, and then on **Run**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Name**, enter `valgrind`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Executable**, add the path to Valgrind (usually `/usr/bin/valgrind`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For arguments, enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For **Working Directory**, enter `$BUILDDIR`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can select the Valgrind run target for your application. We need to do
    this with the debug build because Valgrind needs the debug symbols in our application
    to produce a meaningful report. To use Valgrind, start the application and click
    on the button a few times. The Valgrind process outputs information continually,
    but most of the output comes after we quit the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valgrind produces a lot of output, which can take some time to sort through.
    We''re looking for the leak summary, which indicates the number of bytes definitely
    lost and indirectly lost. The blocks that are definitely lost are memory you''ve
    allocated and not freed; indirectly lost memory is memory leaked because it''s
    referred to by another pointer, and the referring pointer wasn''t freed. The output
    will look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `X` indicates the number of bytes that were leaked, and the address of
    the leaked block is shown on the second line. The record numbers indicate internal
    record numbers used by the application's memory allocator, and probably won't
    help you very much.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should really focus on leaks in our application, because it''s possible
    that Qt may have leaks of its own. Valgrind supports suppression files, which
    indicate what leaks should be ignored; if you can find and download one for the
    versions of Qt you''re building against, you can include a reference to the suppression
    file by modifying the argument line to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finding memory leaks in your application is part art and part science. It's
    a good exercise to go through periodically during application development, to
    ensure that leaks you may introduce are quickly found while you're most familiar
    with the new code you're running.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Creator provides the QML analyzer, which lets you perform runtime analysis
    of your Qt applications. You can see a graph in time of how your application is
    running, as well as dive into detail about how your application spends its time
    drawing, binding to variables, and executing JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Creator also integrates well with Valgrind on Linux, letting you look for
    memory leaks in your application. Using Valgrind on Linux, you can see blocks
    that were allocated but not freed, and more importantly, how big they are and
    where in the code they were allocated, giving you a head start in determining
    why they were not freed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we turn from specific parts of Qt Creator to one of its
    most exciting aspects in general: the ability to use Qt Creator to compile and
    test applications for mobile platforms such as Google Android.'
  prefs: []
  type: TYPE_NORMAL
