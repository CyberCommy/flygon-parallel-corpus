- en: Beginning Your Kotlin Adventure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is great language that makes Android development easier, faster, and
    much more pleasant. In this chapter, we will discuss what Kotlin really is and
    look at many Kotlin examples that will help us build even better Android applications.
    Welcome to the amazing journey of Kotlin, that will change the way you think about
    writing code and solving common programming problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: First steps with Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical Kotlin examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new Kotlin project in Android Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating existing Java project to Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kotlin standard library (stdlib)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Kotlin is a good choice to learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Say hello to Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is a modern, statically typed, Android-compatible language that fixes
    many *Java* problems, such as null pointer exceptions or excessive code verbosity.
    Kotlin is a language inspired by Swift, Scala, Groovy, C#, and many other languages.
    Kotlin was designed by JetBrains professionals, based on analysis of both developers
    experiences, best usage guidelines (most important are *clean code* and *effective
    Java* ), and data about this language's usage. Deep analysis of other programming
    languages has been done. Kotlin tries hard to not repeat the mistakes from other
    languages and take advantage of their most useful features. When working with
    Kotlin, we can really feel that this is a mature and well-designed language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin takes application development to a whole new level by improving code
    quality and safety and boosting developer performance. Official Kotlin support
    for the Android platform was announced by Google in 2017, but the Kotlin language
    has been here for some time. It has a very active community and Kotlin adoption
    on the Android platform is already growing quickly. We can describe Kotlin as
    a safe, expressive, concise, versatile, and tool-friendly language that has great
    interoperability with Java and JavaScript. Let''s discuss these features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safety** : Kotlin offers safety features in terms of nullability and immutability.
    Kotlin is statically typed, so the type of every expression is known at compile
    time. The compiler can verify that whatever property or method that we are trying
    to access or a particular class instance actually exists. This should be familiar
    from Java which is also statically typed, but unlike Java, Kotlin type system
    is much more strict (safe). We have to explicitly tell the compiler whether the
    given variable can store null values. This allows making the program fail at compile
    time instead of throwing a `NullPointerException` at runtime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Image00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Easy debugging** : Bugs can be detected much faster during the development
    phase instead of crashing the application after it is released and thus damaging
    the user experience. Kotlin offers a convenient way to work with immutable data.
    For example, it can distinguish mutable (read-write) and immutable (read-only)
    collections by providing convenient interfaces (under the hood collections are
    still mutable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conciseness** : Most of the Java verbosity was eliminated. We need less code
    to achieve common tasks and thus the amount of boilerplate code is greatly reduced,
    even comparing Kotlin to Java 8\. As a result, the code is also easier to read
    and understand (expressive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability** : Kotlin is designed to seamlessly work side by side with
    Java (cross-language project). The existing ecosystem of Java libraries and frameworks
    works with Kotlin without any performance penalties. Many Java libraries have
    even Kotlin-specific versions that allow more idiomatic usage with Kotlin. Kotlin
    classes can also be directly instantiated and transparently referenced from Java
    code without any special semantics and vice versa. This allows us to incorporate
    Kotlin into existing Android projects and use Kotlin easily together with Java
    (if we want to).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versatility** : We can target many platforms, including mobile applications
    (Android), server-side applications (backend), desktop applications, frontend
    code running in the browser, and even build systems (Gradle).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any programming language is only as good as its tool support. Kotlin has outstanding
    support for modern IDEs such as Android Studio, IntelliJ Idea, and Eclipse. Common
    tasks like code assistance or refactoring are handled properly. The Kotlin team
    works hard to make the Kotlin plugin better with every single release. Most of
    the bugs are quickly fixed and many of the features requested by the community
    are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin bug tracker: [https://youtrack.jetbrains.com/issues/KT](https://youtrack.jetbrains.com/issues/KT)
    Kotlin slack channel: [http://slack.kotlinlang.org/](http://slack.kotlinlang.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: Android application development becomes much more efficient and pleasant with
    Kotlin. Kotlin is compatible with JDK 6, so applications created in Kotlin run
    safely even on old Android devices that precede Android 4.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin aims to bring you the best of both worlds by combining concepts and elements
    from both procedural and functional programming. It follows many guidelines are
    described in the book, *Effective Java* , *2nd Edition* , by Joshua Bloch which
    is considered must read a book for every Java developer.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, Kotlin is open sourced, so we can check out the project and
    be actively involved in any aspect of the Kotlin project such as Kotlin plugins,
    compilers, documentations or Kotlin language itself.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome Kotlin examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin is really easy to learn for Android developers because the syntax is
    similar to Java and Kotlin often feels like natural Java evolution. At the beginning,
    a developer usually writes Kotlin code having in mind habits from Java, but after
    a while, it is very easy to move to more idiomatic Kotlin solutions. Let''s look
    at some cool Kotlin features, and see where Kotlin may provide benefits by solving
    common programming tasks in an easier, more concise, and more flexible way. We
    have tried to keep examples simple and self-explanatory, but they utilize content
    from various parts of this book, so it''s fine if they are not fully understood
    at this point. The goal of this section is to focus on the possibilities and present
    what can be achieved by using Kotlin. This section does not necessarily need to
    fully describe how to achieve it. Let''s start with a variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that Kotlin does not require semicolons. You can still use them, but
    they are optional. We also don''t need to specify a variable type because it''s
    inferred from the context. Each time the compiler can figure out the type from
    the context we don''t have to explicitly specify it. Kotlin is a strongly typed
    language, so each variable has an adequate type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable has an inferred `String` type, so assigning a different value
    (integer) will result in compilation error. Now, let''s see how Kotlin improves
    the way to add multiple strings using *string templates* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We need no more joining strings using the `+` character. In Kotlin, we can
    easily incorporate single variable or even whole expression into string literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java any variable can store null values. In Kotlin *strict null safety*
    forces us to explicitly mark each variable that can store nullable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a question mark to a data type (string versus string?), we say that
    variable can be nullable (can store null references). If we don''t mark variable
    as nullable, we will not be able to assign a nullable reference to it. Kotlin
    also allows to deal with nullable variables in proper ways. We can use *safe call*
    operator to safely call methods on potentially nullable variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The method `doSomething` will be invoked only if `savedInstanceState` has a
    non-null value, otherwise the method call will be ignored. This is Kotlin's safe
    way to avoid null pointer exceptions that are so common in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin also has several new data types. Let''s look at the `Range` data type
    that allows us to define end inclusive ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin introduces the `Pair` data type that, combined with *infix* *notation,*
    allows us to hold a common pair of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can deconstruct it into separate variables using *destructive declarations*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even iterate through a list of pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `forEach` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that Kotlin distinguishes between mutable and immutable collections by
    providing a set of interfaces and helper methods (`List` versus `MutableList`
    , `Set` versus `Set` versus `MutableSet` , `Map` versus `MutableMap` , and so
    on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Immutable collection means that the collection state can't change after initialization
    (we can't add/remove items). Mutable collection (quite obviously) means that the
    state can change.
  prefs: []
  type: TYPE_NORMAL
- en: 'With lambda expressions, we can use the Android framework build in a very concise
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin standard library (stdlib) contains many functions that allow us to perform
    operations on collections in simple and concise way. We can easily perform stream
    processing on lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we don't have to pass parameters to a lambda. We can also define
    our own lambdas that will allow us to write code in completely new way. This lambda
    will allow us to run a particular piece of code only in Android Marshmallow or
    newer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make asynchronous requests easily and display responses on the main
    thread using the `doAsync` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Smart casts allow us to write code without performing redundant casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Kotlin compiler knows that the variable `*x*` is of the type `String` after
    performing a check, so it will automatically cast it to the `String` type*,* allowing
    it to call all methods and access all properties of the `String` class without
    any explicit casts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we have a simple function that returns the value of a single expression.
    In this case, we can use a function with an expression body to shorten the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using *default argument syntax,* we can define the default value for each function
    argument and call it in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The only limitation is that we need to supply all arguments without default
    values. We can also use *named argument* *syntax* to specify function arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This also increases readability when invoking the function with multiple parameters
    in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data classes give a very easy way to define and operate on classes from
    the data model. To define a proper data class, we will use the `data` modifier
    before the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have a really nice, human readable string representation of
    the class instance and we do not need the `new` keyword to instantiate the class.
    We can also easily create a custom copy of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding constructs make working with *immutable* objects very easy and
    convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the best features in Kotlin are *extensions.* They allow us to add new
    behavior (a method or property) to an existing class without changing its implementation.
    Sometimes when you work with a library or framework, you would like to have extra
    method or property for certain class. Extensions are a great way to add those
    missing members. Extensions reduce code verbosity and remove the need to use utility
    functions known from Java (for example, the `StringUtils` class). We can easily
    define extensions for custom classes, third-party libraries, or even Android framework
    classes. First of all, `ImageView` does not have the ability to load images from
    network, so we can add the `loadImage` extension method to load images using the
    `Picasso` library (an image loading library for Android):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add a simple method displaying toasts to the `Activity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are many places where usage of *extensions* will make our code simpler
    and more concise. Using Kotlin, we can fully take advantage of lambdas to simplify
    Kotlin code even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces in Kotlin can have default implementations as long as they don''t
    hold any state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In Android, there are many applications where we want to delay object initialization
    until it is needed (used). To solve this problem, we can use *delegates* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Retrofit (a popular Android networking framework) property initialization will
    be delayed until the value is accessed for the first time. Lazy initialization
    may result in faster Android application startup time since loading is deferred
    to when the variable is accessed. This is a great way to initialize multiple objects
    inside a class, especially when not all of them are always needed (for certain
    class usage scenario, we may need only specific objects) or when not every one
    of them is needed instantly after class creation.
  prefs: []
  type: TYPE_NORMAL
- en: All the presented examples are only a glimpse of what can be accomplished with
    Kotlin. We will learn how to utilize the power of Kotlin throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Kotlin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways of managing and running Kotlin code. We will mainly
    focus on Android Studio and Kotlin Playground.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin Playground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fastest way to try Kotlin code without the need to install any software
    is Kotlin Playground ([https://try.kotlinlang.org](https://try.kotlinlang.org)
    )*.* We can run Kotlin code there using JavaScript or JVM Kotlin implementations
    and easily switch between different Kotlin versions. All the code examples from
    the book that does not require the Android framework dependencies and can be executed
    using **Kotlin Playground** .
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `main` function is the entry point of every Kotlin application. This function
    is called when any application starts, so we must place code from the book examples
    in the body of this method. We can place code directly or just place a call to
    another function containing more Kotlin code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Android Applications have multiple entry points. main function is called implicitly
    by the Android framework, so we can't use it to run Kotlin code on Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All Android Studio's existing tools work with Kotlin code. We can easily use
    debugging, lint checks, have proper code assistance, refactoring and more. Most
    of the things work the same way as for Java, so the biggest noticeable change
    is the Kotlin language syntax. All we need to do is to configure Kotlin in the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Android applications have multiple entry points (different intents can start
    different components in the application) and require Android framework dependencies.
    To run book examples, we need to extend the `Activity` class and place code there.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kotlin for the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from Android Studio 3.0, full tooling support for Kotlin was added.
    Installation of the Kotlin plugin is not required and Kotlin is integrated even
    deeper into the Android development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Kotlin with Android Studio 2.x, we must manually install the Kotlin
    plugin. To install it, we need to go to Android Studio | File | Settings | Plugins
    | Install JetBrains plugin... | Kotlin and press the Install button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To be able to use Kotlin, we need to configure Kotlin in our project. For existing
    Java projects, we need to run the *Configure Kotlin in project* action (the shortcut
    in Windows is *Ctrl* +*Shift* +*A* , and in macOS, it is *command* + *shift* +
    *A* ) or use the corresponding Tools |Kotlin *|* Configure Kotlin in Project menu
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, select Android with Gradle :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we need to select the required modules and the proper Kotlin version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding configuration scenario also applies to all existing Android projects
    that were initially created in Java. Starting from Android Studio 3.0, we can
    also check the Include Kotlin support checkbox while creating a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In both scenarios, the `Configure Kotlin in project` command updates the root
    `build.gradle` file and the `build.gradle` files corresponding to the module(s)
    by adding Kotlin dependencies. It also adds the Kotlin plugin to the Android module.
    During the time of writing this book release version of Android Studio 3 is not
    yet available, but we can review build script from pre-release version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Prior to Android Plugin for Gradle 3.x (delivered with Android Studio 3.0) *compile*
    dependency configuration was used instead of *implementation* .
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the Kotlin version (let us say in the future), we need to change
    the value of the `kotlin_version` variable in the `build.gradle` file (project
    root folder). Changes in Gradle files mean that the project must be synchronized,
    so Gradle can update its configuration and download all the required dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Kotlin in a new Android project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the new Kotlin projects created in Android Studio 3.x, the main activity
    will be already defined in Kotlin, so that we can start writing Kotlin code right
    away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding a new Kotlin file is similar to adding a Java file. Simply right-click
    on a package and select new | Kotlin File/Class :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason why the IDE says Kotlin File/Class and not simply *Kotlin class*
    , analogously to *Java class* is that we can have more members defined inside
    a single file. We will discuss this in more detail in [Chapter 2](text00035.html)
    , *Laying a Foundation* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that Kotlin source files can be located inside the `java` source folder.
    We can create a new source folder for Kotlin, but it is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Running and debugging a project is exactly the same as in Java and does not
    require any additional steps besides configuring Kotlin in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Starting from Android Studio 3.0, various Android templates will also allow
    us to select a language. This is the new Configure Activity wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Java to Kotlin converter (J2K)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Migration of existing Java projects is also quite easy, because we can use Java
    and Kotlin side by side in the same project. There are also ways to convert existing
    Java code into Kotlin code by using the **Java to Kotlin converter** (**J2K**
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is to convert whole Java files into Kotlin files using the c*onvert
    Java File to Kotlin* command (keyboard shortcut in Windows is *Alt* + *Shift*
    + *Ctrl* + *K* and in macOS: *option* + *shift* + *command* + *K* ), and this
    works very well. The second way is to paste Java code into an existing Kotlin
    file and the code will also be converted (a dialog window will appear with a conversion
    proposition). This may be very helpful when learning Kotlin.'
  prefs: []
  type: TYPE_NORMAL
- en: If we don't know how to write a particular piece of code in Kotlin, we can write
    it in Java, then simply copy to the clipboard and then paste it into the Kotlin
    file. Converted code will not be the most idiomatic version of Kotlin, but it
    will work. The IDE will display various intentions to convert the code even more
    and improve its quality. Before conversion, we need to make sure that Java code
    is valid, because conversion tools are very sensitive and the process will fail
    even if a single semicolon is missing. The J2K converter combined with Java interoperability
    allows Kotlin be introduced gradually into the existing project (for example,
    to convert a single class at a time).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative ways to run Kotlin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio offers an alternative way of running Kotlin code without the
    need to run Android application. This is useful when you want to quickly test
    some Kotlin code separately from the long Android compilation and deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to run Kotlin code is to use build Kotlin **Read Eval Print Loop**
    (**REPL** ). REPL is a simple language shell that reads single user input, evaluates
    it, and prints the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'REPL looks like the command-line, but it will provide us with all the required
    code hints and will give us access to various structures defined inside the project
    (classes, interfaces, top-level functions, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The biggest advantage of REPL is its speed. We can test Kotlin code really quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will focus mainly on Android, but keep in mind that Kotlin can be compiled
    to multiple platforms. Kotlin code can be compiled to *Java bytecode* and then
    to *Dalvik bytecode* . Here is simplified version of the Kotlin build process
    for the Android platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A file with a `.java` extension contains Java code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file with a `.kt` extension contains Kotlin code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file with a `.class` extension contains Java bytecode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file with a `.dex` extension contains Dalvik bytecode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file with a `.apk` extension contains the `AndroidManifest` file, resources,
    and `.dex` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For pure Kotlin projects, only the Kotlin compiler will be used, but Kotlin
    also supports cross-language projects, where we can use Kotlin together with Java
    in the same Android project. In such cases, both compilers are used to compile
    the Android application and the result will be merged at the class level.
  prefs: []
  type: TYPE_NORMAL
- en: The Kotlin standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kotlin standard library** (**stdlib** ) is a very small library that is distributed
    together with Kotlin. It is required to run applications written in Kotlin and
    it is added automatically to our application during the build process.'
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin 1.1, `kotlin-runtime` was required to run applications written in
    Kotlin. In fact, in Kotlin 1.1 there were two artifacts (`kotlin-runtime` and
    `kotlin-stdlib` ) that shared a lot of Kotlin packages. To reduce the amount of
    confusion both the artifacts will be merged into single artifact (`kotlin-stdlib`
    ) in in the upcoming 1.2 version of Kotlin. Starting from Kotlin 1.2, `kotlin-stdlib`
    is required to run applications written in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin standard library provides essential elements required for everyday
    work with Kotlin. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Data types like arrays, collections, lists, ranges, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various utilities for working with strings and char sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions for JDK classes making it convenient to work with files, IO, and
    threading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More reasons to use Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin has strong commercial support from JetBrains, a company that delivers
    very popular IDEs for many popular programming languages (Android Studio is based
    on JetBrains IntelliJ IDEA). JetBrains wanted to improve the quality of their
    code and team performance, so they needed the language that will solve all the
    Java issues and provide seamless interoperability with Java. None of the other
    JVM languages meet those requirements, so JetBrains finally decided to create
    their own language and started the Kotlin project. Nowadays, Kotlin is used in
    their flagship products. Some use Kotlin together with Java while others are pure
    Kotlin products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin is quite a mature language. In fact, its development started many years
    before Google announced official Android support (first commit dates back to 2010-11-08):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The initial name of the language was **Jet** . At some point, the JetBrains
    team decided to rename it to Kotlin. The name comes from Kotlin Island, near St.
    Petersburg and its analogy to Java which was also named after the Indonesian island.
  prefs: []
  type: TYPE_NORMAL
- en: After the version 1.0 release in 2016, more and more companies started to support
    the Kotlin project. Gradle added support of Kotlin into building scripts, Square,
    the biggest creator of Android libraries posted that they strongly support Kotlin
    and finally, Google announced it's official Kotlin support for the Android platform.
    This means that every tool that will be released by the Android team will be compatible
    not only with Java but also with Kotlin. Google and JetBrains have begun a partnership
    to create a nonprofit foundation for Kotlin, responsible for future language maintenance
    and development. All of this will greatly increase the number of companies that
    will use Kotlin in their projects.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin is also similar to Apple's Swift programming language. In fact, such
    is the resemblance, that some articles focus on differences, not similarities.
    Learning Kotlin will be very helpful for developers eager to develop applications
    for Android and iOS. There are also plans to port Kotlin to iOS (Kotlin/Native),
    so maybe we don't have to learn Swift after all. Full stack development is also
    possible in Kotlin, so we can develop server-side applications and frontend clients
    sharing the same data model with mobile clients.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've discussed how the Kotlin language fits into Android development and how
    we can incorporate Kotlin into new and existing projects. We have seen useful
    examples where Kotlin simplified the code and made it much safer. There are still
    many interesting things to discover.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Kotlin building blocks and lay a foundation
    to develop Android applications using Kotlin.
  prefs: []
  type: TYPE_NORMAL
