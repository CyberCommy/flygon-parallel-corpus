- en: Chapter 5. Where Do You Store Your Stuff?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm like a squirrel. Once in a while, I leave money in secret stashes around
    the house in case I get mugged or just spend too much in a month. I truly forget
    where all my stashes are, and that is kind of funny and sad (for me).
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine you're storing something equally important or even more important
    than money, for instance, client data or even your company data. Could you allow
    yourself to store it in places that could later be lost or accessible to someone
    who could meddle with your "stash"? We are in the information era; information
    is power!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the web application world, we have two big players for data storage: **relational
    databases** and **NoSQL databases**. The first is the traditional way where your
    data is stored inside tables and columns and where transactions matter, ACID is
    expected and normalization is the key (pun intended)! It uses **SQL** to store
    and retrieve data. In the second way, things get a little wild. Your data may
    be stored in different structures such as documents, graphs, key value mappings,
    and others. Writing and consulting languages are vendor-specific, and you may
    have to give up on ACID too in a tradeoff for speed, lots of speed!'
  prefs: []
  type: TYPE_NORMAL
- en: You have probably guessed it already! This chapter is all about the **M** layer
    of **MVC**, that is, how to store and access your data in a transparent way with
    Flask! We'll look at the examples of how to use query and write to both the database
    types, and when to choose which one to use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ACID is the acronym for atomicity, consistency, isolation, and durability. Refer
    to [http://en.wikipedia.org/wiki/ACID](http://en.wikipedia.org/wiki/ACID) for
    a cozy definition and overview.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLAlchemy is an amazing library for working with relational databases. It was
    made by the Pocoo Team, the same folks that brought you Flask, and is considered
    "The Facto" Python SQL library. It works with SQLite, Postgres, MySQL, Oracle,
    and all SQL databases, which comes with compatible drivers.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite describes itself as a self-contained, serverless, zero-configuration,
    and transactional SQL database engine ([https://sqlite.org/about.html](https://sqlite.org/about.html)).
    One of its main goals is to be a great embeddable database solution for applications
    and small devices, which it is! It is also very easy to use and that makes it
    perfect for our learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Though all the examples will be given and tested with SQLite in mind, they should
    work in the other databases with little to no changes. Database-specific tips
    will be given from time to time whenever appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [http://www.w3schools.com/sql/default.asp](http://www.w3schools.com/sql/default.asp)
    for an extensive SQL reference.
  prefs: []
  type: TYPE_NORMAL
- en: Before our first example, should we review a few relational database concepts?
  prefs: []
  type: TYPE_NORMAL
- en: Concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tables** are low-level abstraction structures where your data is stored.
    It is made up of **columns** and **rows**, where each column represents a part
    of your data and each row represents a full record. Usually, each table represents
    a low-level abstraction of a class model.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rows** are individual records of a given class model. You may need to scatter
    multiple row records across different tables to record a full piece of information.
    A good example is an **MxN relationship**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Columns** represent the stored data itself. Each column has a specific type,
    and accepts only that type as input data. You may think of it as an abstraction
    of a class model attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transactions** are how you group the operations you want to be executed together.
    It is used mainly to achieve atomicity. This way, no operations are done halfway.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary key** is a database concept where part of a record''s data is used
    to identify the given record across the database table. It is usually implemented
    by the database through constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Foreign key** is a database concept where a set of data is used to identify
    a given record across tables. Its main use is to construct relationships between
    rows in different tables. It is usually implemented by the database through constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: One main concern when working with relational databases is data normalization.
    In relational databases, related data is stored across different tables. You may
    have a table to hold a person's data, a table for the person's address, another
    for his/her cars, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Each table is isolated from one another and the related data may be retrievable,
    thanks to the relations established by the foreign keys! The data normalization
    techniques are a set of rules used to allow proper scattering of the data across
    the tables so that the related tables are easily fetched and redundancy is kept
    to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please, refer to [http://en.wikipedia.org/wiki/Database_normalization](http://en.wikipedia.org/wiki/Database_normalization)
    for an overview of database normalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an overview of the normal forms, please refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/First_normal_form](http://en.wikipedia.org/wiki/First_normal_form)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Second_normal_form](http://en.wikipedia.org/wiki/Second_normal_form)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Third_normal_form](http://en.wikipedia.org/wiki/Third_normal_form)'
  prefs: []
  type: TYPE_NORMAL
- en: We may now proceed!
  prefs: []
  type: TYPE_NORMAL
- en: Hands on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by installing the library into our environment and trying out
    a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On to our first example! Let''s create a simple employee database for a company
    (maybe yours?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is pretty simple. We create a SQLAlchemy engine, grab
    a connection from the **connection pool** (engine handles that for you) and then
    we execute the SQL command to create a table, insert a few rows and query to see
    whether everything occurred as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [http://en.wikipedia.org/wiki/Connection_pool](http://en.wikipedia.org/wiki/Connection_pool)
    for the connection pool pattern overview. (This is important, really!)
  prefs: []
  type: TYPE_NORMAL
- en: In our insertion, we provided the value `NULL` to the primary key `id`. Be aware
    that SQLite will not populate the primary key with `NULL`; instead, it will ignore
    the `NULL` value and set the column with a new, unique, across the table integer.
    That's SQLite- specific behavior. **Oracle**, for example, would require you to
    insert a sequence's next value explicitly in order to set a new unique column
    value for the primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Our preceding example uses a feature called **autocommit**. It means each execute
    method call commits to the database immediately. In this way, you could not execute
    multiple statements at once, a common scenario in real world applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute multiple statements at once, we should use **transactions**. We
    could rewrite our previous example with transactions in order to make sure all
    three insertions are either committed together or not at all (grim look...):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Nothing fancy so far. In our example, we create a transaction from the connection,
    execute a few statements and then commit it to finish the transaction. If an error
    occurs between the beginning and end of a transaction, the `except` block will
    be reached and all the statements executed within the transaction will rollback
    or "undone".
  prefs: []
  type: TYPE_NORMAL
- en: We can make our example complete by creating a relation among the tables. Imagine
    our employee has one or more addresses registered with his/her company profile.
    We will create a 1xN relation, where an employee may have one, or more addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our new and updated, awesome example, we record some addresses of our employees,
    making sure to use the correct value for the foreign keys (`id_employee`) and
    then we look out for the addresses of an employee called `'marcos mango'` using
    `LEFT JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to create tables and relations, run statements to consult and
    insert data, and use transactions with SQLAlchemy; we're yet to explore much of
    the library power within SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has a built-in ORM, which allows you to work with database tables
    as if they were native object instances. Imagine reading a column value as if
    it was an instance attribute or consulting a complex table relation through a
    method, that's SQLAlchemy's ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how our example will look using the built-in ORM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example has quite a few concepts to be introduced. First, we create
    our engine, the SQLAlchemy engine used in the first example, then we create our
    base model class. While `Employee` will be mapped into a table called `employee`
    by `create_all`, each defined `Column` attribute will be mapped into a column
    of the given table in the database with the proper constraints. For the `id` field,
    for example, it is defined as a primary key, so it will have the primary key constraint
    created for it. The `id_employee` is a foreign key, which is a reference to the
    primary key of another table, so it will have a foreign key constraint, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: All of our class models should inherit from it. Then we create a `session`.
    A session is how you work with the SQLAlchemy ORM models.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions have an internal ongoing transaction, so it's very simple for it to
    have a *transaction-like* behavior. It also maps your models to the correct engine
    in case you're using more than one; but wait, there's more! It also keeps track
    of all the model instances loaded in/from it. For example, if you add a model
    instance to it and then modify that very instance, the session is smart enough
    to acknowledge the change of one of its objects. It will, thus, mark itself as
    dirty (stuff was changed) until a commit or rollback is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, after finding marcos, we could change "Marcos Mango''s" name
    to something else, such as `"marcos tangerine"`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, comment the whole code after `Base.metadata` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, re-execute the example. Marcos new last name now is "tangerine". Magical!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an amazing, super duper, mega power reference on querying with SQLAlchemy
    ORM, please visit [http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#querying](http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html#querying).
  prefs: []
  type: TYPE_NORMAL
- en: After so much talk about SQLAlchemy, could you please wake up as we'll talk
    about Flask-SQLAlchemy, the extension that integrates the library with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flask-SQLAlchemy is a thin extension that wraps SQLAlchemy around Flask. It
    allows you to configure the SQLAlchemy engine through your configuration file
    and binds a session to each request, giving you a transparent way to handle transactions.
    Let''s see how to do all that. First, let''s make sure we have all the necessary
    packages installed. With the virtual environment loaded, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is pretty complete. It has a form validation, CSRF protection,
    auto-generated form from model, and database integration. Let's focus only on
    what we have not mentioned so far.
  prefs: []
  type: TYPE_NORMAL
- en: The auto form generation is pretty handy. Using `model_form`, you're able to
    introspect the defined model class and generate a form class fit for that model.
    You may also provide arguments to the fields through the `model_form` parameter
    `field_args`, which is pretty useful for adding element classes or extra validators.
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed that `Employee` extends `db.Model` which is your ORM
    model base class. All your models should extend it in order to be known by `db`,
    which encapsulates our engine and holds our request aware session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the index function, we instantiate the form, then check whether it was
    submitted through POST and is valid. Inside the `if` block, we instantiate our
    employee model and use `populate_obj` to put the values of the form inside the
    model instance. We could also do it field by field, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `populate_obj` is just more convenient. After populating the model, we add
    it to the session to keep track of it and commit the session. In case of any exception
    in this block, we have it inside a try/except block with a rollback prepared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we use `Employee.query` to consult which employees are stored in
    our database. Each model class comes with a `query` attribute that allows you
    to fetch and filter results from the database. Each filter call to `query` will
    return a `BaseQuery` instance, which allows you to stack your filters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The possibilities here are many. Why don't you try a few examples on your own
    now?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common security problem related to web applications and databases is
    the **SQL Injection Attack**, where an attacker injects SQL instructions into
    your queries to the database, gaining privileges he/she should not have. The SQLAlchemy's
    engine object "auto-magically" escapes special characters in your consults; so,
    unless you explicitly bypass its quoting mechanism, you should be safe.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a widely used, powerful NoSQL database. It allows you to store your
    data inside documents; a mutable, dictionary-like, object-like structure where
    your data may be stored without you worrying about things such as "is my data
    normalized to the third normal form?" or "do I have to create another table to
    store my relation?", and others.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB documents are actually BSON documents, a superset of JSON with extended
    data type support. If you know how to handle JSON documents, you should have no
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If JSON means nothing to you, just take a look at [http://www.w3schools.com/json/](http://www.w3schools.com/json/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install MongoDB locally in order to try out some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from console, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll enter the MongoDB interactive console. From it, you may execute commands,
    add documents to your database, query, update, or remove. Anything you can achieve
    grammatically, you may also achieve through the console. Now, let''s understand
    the two important MongoDB concepts: databases and collections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside MongoDB, your documents are grouped inside collections, while collections
    are grouped inside databases. So, after connecting to MongoDB, the first thing
    you should do is to choose which database you plan to use. You do not need to
    create the database, connecting to it is enough to create the database. The same
    case is applicable for the collections. You also do not need to define your document
    structure prior to using it, nor are you required to implement complex altering
    commands if you decide your documents structure should change. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we switch to the example database, then we insert a new
    document into the employees collection (we do not need to create it before use)
    and eventually, we search for it using a regular expression. The MongoDB console
    is actually a JavaScript console, so new `Date` is actually the JavaScript class
    `Date` being instantiated. It's very simple.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're not familiar with JavaScript, visit [http://www.w3schools.com/js/default.asp](http://www.w3schools.com/js/default.asp)
    for a nice overview.
  prefs: []
  type: TYPE_NORMAL
- en: We can store inside any JSON-type documents, also a few others. Visit [http://docs.mongodb.org/manual/reference/bson-types/](http://docs.mongodb.org/manual/reference/bson-types/)
    for the full list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding proper usage of MongoDB, just keep a few golden rules in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid keeping data from one collection to another as MongoDB does not *like*
    joins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having document values as lists is OK in MongoDB, even expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper document indexes (not covered in this book) are key to good performance
    in MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writes are much slower than reads and may affect overall performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoEngine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoEngine is a terrific Python library to access and manipulate MongoDB documents
    and uses **PyMongo**, the MongoDB recommended Python library underneath.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As PyMongo does not have a **Document-object Mapper** (**DOM**), we are not
    using it directly. Nonetheless, there will be cases where the MongoEngine API
    will not be enough and you'll need to use PyMongo to achieve your goal.
  prefs: []
  type: TYPE_NORMAL
- en: It has its own consulting API and document to class mapper that allows you to
    work with the documents in a similar way you would work with SQLAlchemy ORM. That's
    a good thing because MongoDB is schema-less. It does not enforce the schema as
    a relational database would do. That way you don't have to declare how your document
    should look like before using it. MongoDB just doesn't care!
  prefs: []
  type: TYPE_NORMAL
- en: In actual daily development, knowing exactly what kind of information you're
    supposed to store in a document is a great anti-madness feature and MongoEngine
    gives it to you out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already have MongoDB on your machine, just install the MongoEngine library
    to start coding with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add "Rosie Rinn" to the database using our new library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Understanding our example: first, we create a MongoDB connection with the `example`
    database, then define our employee document just like we did with SQLAlchemy,
    and eventually, we insert our employee "Rosie" and query to see whether everything
    is OK.'
  prefs: []
  type: TYPE_NORMAL
- en: When declaring our `Employee` class, you may have noticed we had to define each
    field with its proper field type. If MongoDB is schema-less, why is that? MongoEngine
    enforces the type of each model field. If you had `IntField` defined for your
    model and provided it a string value, MongoEngine would raise a validation error
    as that is not a proper field value. Also, we defined a `__unicode__` method for
    `Employee` in order to have it print the employee's name in our loop. The `__repr__`
    will not work here.
  prefs: []
  type: TYPE_NORMAL
- en: As MongoDB does not support transactions (MongoDB is not ACID, remember?), neither
    does MongoEngine, every operation we do is atomic. As we create our "Rosie" and
    call the `save` method, "Rosie" is inserted in the database at once; there is
    no need to commit the changes or anything like that.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we have the database consult where we search for "Rosie". To query
    a chosen collection, you should use the `objects` handler available in every MongoEngine
    document. It exposes a Django-like interface for querying with support to operations
    such as `contains`, `icontains`, `ne`, `lte`, and others. For a full list of query
    operators, visit [https://mongoengine-odm.readthedocs.org/guide/querying.html#query-operators](https://mongoengine-odm.readthedocs.org/guide/querying.html#query-operators).
  prefs: []
  type: TYPE_NORMAL
- en: Flask-MongoEngine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoEngine is pretty easy by itself, but someone thought things could go better,
    and there we have Flask-MongoEngine. It gives you three main features:'
  prefs: []
  type: TYPE_NORMAL
- en: Flask-DebugToolbar Integration (weeee!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django-like querysets (`get_or_404`, `first_or_404`, `paginate`, `paginate_field`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-DebugToolbar is a neat Flask extension inspired by the Django-DebugToolbar
    extension that keeps track of what is happening inside your application behind
    the hood, such as HTTP headers used in a request, CPU time, number of active MongoDB
    connections, and others.
  prefs: []
  type: TYPE_NORMAL
- en: The Django-like queries are a helpful feature as they allow you to avoid some
    boring coding here and there. The `get_or_404(*args, **kwargs)` query method will
    raise a 404 HTTP page if the document being looking for is not found (it uses
    a `get`, internally). In case you're building a blog, you might like to use this
    little fellow while loading a specific post entry. The `first_or_404()` query
    method is similar, but works with the collection. If the collection is empty,
    it raises a 404 HTTP page. The `paginate(page, per_page)` query is actually a
    very helpful query method. It provides you with a pagination interface out of
    the box. It will not work well with huge collections because MongoDB requires
    a different strategy in these cases, but most of the time, it will be all you
    need. The `paginate_field(field_name, doc_id, page, per_page)` is a more specific
    version of paginate as you'll be paginating through a single document field and
    not a collection. It is very useful when you have a document where one of the
    fields is a huge list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at a full example with `flask-mongoengine`. First, let''s
    install the library in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now on to coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our Flask-MongoEngine example is pretty similar to our Flask-SQLAlchemy example.
    Besides differences in the imports, there is the MongoDB configuration, as MongoDB
    requires different parameters; we have the `birthday` field type as MongoEngine
    does not support `DateField`; there is birthday format overwrite as the default
    string format for `datetimefield` is different than what we want; and we have
    the changes in the `index` method.
  prefs: []
  type: TYPE_NORMAL
- en: As we do not have to handle sessions with Flask-MongoEngine, we just remove
    all references to it. We also change how `employee_list` is built.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As MongoDB does not parse the data you send to it in an attempt to figure out
    what the query is about, you do not have SQL injection-like problems with it.
  prefs: []
  type: TYPE_NORMAL
- en: Relational versus NoSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering when to use relational and when to use NoSQL. Well, given
    the techniques and technologies in existence today, I would recommend you work
    with the type you feel better working with. NoSQL brags about being schema-less,
    scalable, fast, and so on, but relational databases are also quite fast for most
    of your needs. A few relational databases, such as Postgres, even support documents.
    What about scaling? Well, most projects do not need to scale as they will never
    be big enough. Others, just scale with their relational database.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no *important* reason to pick one or the other for native schema-less
    support or full ACID support, either of them will be good enough. Even security-wise,
    there are no big differences worth mentioning. MongoDB has its own authorization
    scheme as most relational databases do, and, if properly configured, both are
    just as secure. Usually, the application layer is more troublesome in this matter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was pretty intense! We had an overview of relational and NoSQL
    databases, we learned about MongoDB and MongoEngine, SQLite and SQLAlchemy, and
    how to use extensions to integrate Flask with each. Knowledge is stacking up fast!
    You're now capable of creating more complex web applications with database support,
    custom validation, CSRF protection, and user communication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about REST, its advantages, and how to create
    services to be consumed by your app.
  prefs: []
  type: TYPE_NORMAL
