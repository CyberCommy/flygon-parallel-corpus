- en: Interacting with RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with RESTful APIs is a very common task we need to do when building
    an app, and it always results in us having to write asynchronous code. So, to
    begin with in this chapter, we'll have a detailed look at asynchronous code in
    general.
  prefs: []
  type: TYPE_NORMAL
- en: There are many libraries that we can use to help us interact with REST APIs.
    In this chapter, we'll look at both a native browser function and a popular open
    source library for interacting with REST APIs. We'll discover the additional features
    that the open source library has over the native function. We will also look at
    how we can interact with a REST API in both React class and function-based components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fetch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using axios with class components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using axios with function components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TypeScript playground**: This is a website at [https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/)
    that allows us to play with asynchronous code without installing anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install these from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least at version 5.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeScript**: This can be installed via `npm` with the following command
    in a terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Visual Studio Code**. We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsonplaceholder.typicode.com`: We will use this online service to help us
    learn how to interact with a RESTful API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs.](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/09-RestfulAPIs)
  prefs: []
  type: TYPE_NORMAL
- en: Writing asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript code is executed synchronously by default, where each line of code
    is executed after each other. However, TypeScript code can also be asynchronous,
    which means things can happen independently of our code. Calling a REST API is
    an example of asynchronous code because the API request is handled outside of
    our TypeScript code. So, interacting with a REST API forces us to write asynchronous
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll take the time to understand the approaches we can take
    when writing asynchronous code before using them to interact with RESTful APIs.
    We'll start in the next section by looking at callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A callback is a function we pass as a parameter to an asynchronous function
    to call when the asynchronous function is complete. In the next section, we'll
    go through an example of writing asynchronous code with a callback.
  prefs: []
  type: TYPE_NORMAL
- en: Callback execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through an example of using callbacks in asynchronous code in the
    TypeScript playground. Let''s enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code calls the JavaScript `setTimeout` function, which is asynchronous. It
    takes in a callback as the first parameter and the number of milliseconds the
    execution should wait until the callback is executed as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We use an arrow function as the callback function, where we set the `firstName` variable
    to "Fred" and output this to the console. We also log `firstName` in the console
    immediately after the call to `setTimeout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, which `console.log` statement will get executed first? If we run the code
    and look at the console, we''ll see that the last line is executed first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b9a54558-5be3-47a1-8921-2cd69f4933e2.png)'
  prefs: []
  type: TYPE_IMG
- en: The key point is that after `setTimeout` is called, execution carries on to
    the next line of code. Execution doesn't wait for the callback to be called. This
    can make code that includes callbacks harder to read than synchronous code, particularly
    when we have callbacks nested within callbacks. This is referred to as **callback
    hell** by many developers!
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we handle errors in asynchronous callback code? We'll find out in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling callback errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to explore how we can handle errors when using
    callback code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by entering the following code in the TypeScript playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are again using `setTimeout` to experiment with callbacks. This time, we
    throw an error inside the callback. We are hoping to catch the error outside the
    callback using a `try / catch` around the `setTimeout` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code, we see that we don''t catch the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/08ffe4f4-0b57-4cc6-8d4b-ed7d664004bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We must handle errors within the callback. So, let''s adjust our example to
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This time, the `try / catch` is within the callback. We use a variable, `result`,
    to determine whether the callback was executed successfully, along with any error.
    The `IResult` interface gives us a nice bit of type safety with the result `variable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code, we''ll see that we successfully handle the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec166585-af59-4cc9-b805-2cb395749311.png)'
  prefs: []
  type: TYPE_IMG
- en: So, handling errors along with reading callback-based code is a challenge. Luckily,
    there are alternative approaches that deal with these challenges, which we'll
    go through in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A promise is a JavaScript object that represents the eventual completion (or
    failure) of an asynchronous operation and its resulting value. We'll have a look
    at an example of consuming a promised-based function in the next section, followed
    by creating our own promised-based function after that.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a promised-based function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at some code that exposes a promise-based API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function is the native JavaScript `fetch` function for interacting with
    RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function takes in a URL for the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a `then` method to handle the response and reading of the response body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a `catch` method to handle any errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code execution flows down as we would read it. We also don't have to do
    any additional work in the `then` methods to handle errors. So, this is much nicer
    than working with callback-based asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we'll create our own promised based function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a promised based function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll create a `wait` function to asynchronously wait a number
    of milliseconds that passed in as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enter the following into the TypeScript playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function starts by returning a `Promise` object, which takes in the function
    that needs to be executed asynchronously as its constructor parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `promise` function takes in a `resolve` parameter, which is a function that
    we call when the function has finished executing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The promise function also takes in a `reject` parameter, which is a function
    that we call when the function errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internally, we are using `setTimeout` with a callback to do the actual waiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consume our promised-based `wait` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function simply outputs the result or error to the console after waiting
    500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s give this a try and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43ce9513-e1b1-4b0a-b4c4-b9f14206adf1.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the output in the console indicates that the `then` method is
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call the `wait` function with a parameter greater than 1000, the `catch`
    method should be invoked. Let''s give this a try:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the `catch` method is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c3b5730-c747-4e17-9499-23f7a4c9461f.png)'
  prefs: []
  type: TYPE_IMG
- en: So, promises give us a nice way of writing asynchronous code. However, there's
    another approach that we have used a number of times earlier in this book. We'll
    go through this method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: async and await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`async` and `await` are two JavaScript keywords we can use to make asynchronous
    code read almost identically to synchronous code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of consuming our `wait` function we created in the
    last section by entering the following code into the TypeScript playground, after
    the `wait` function declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have created an arrow function called `someWork` that is marked as asynchronous
    with the `async` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then call `wait` prefixed with the `await` keyword. This halts execution
    of the next line until `wait` has completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `try / catch` will catch any errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the code is very similar to how you would write it in a synchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this example, we get confirmation that the `console.log` statement
    in the `try` branch waited until the `wait` function had completely finished before
    executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0278f6b8-7431-4059-8cec-87efa7941022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change the wait to `1500` milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this, we see that an error is raised and caught:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5af59f14-a6b6-44c0-bbe9-d6701cde368d.png)'
  prefs: []
  type: TYPE_IMG
- en: So, `async` and `await` make our code nice and easy to read. A bonus for using
    these in TypeScript is that the code can be transpiled to work in older browsers.
    So, for example, we can code with `async` and `await` and still support IE.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good understanding of writing asynchronous code, we'll put
    this into practice when we interact with RESTful APIs in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fetch` function is a native JavaScript function that we can use to interact
    with RESTful APIs. In this section, we'll go through some common RESTful API interactions
    using `fetch`, starting with getting data. Throughout this section, we are going
    to interact with the fantastic `JSONPlaceholder` REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data with fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use `fetch` to get some posts from the `JSONPlaceholder` REST
    API, starting with a basic `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: Basic GET request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s open up the TypeScript playground and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some key points:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter in the `fetch` function is the URL for the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch` is a promised-based function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first `then` method handles the response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `then` method handles when the body has been parsed as JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we run the code, we should see an array of posts output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be4bbc0d-04b2-4867-98f1-1ea1c4f9d7e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting response status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Very often, we need to check the status of the request. We can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The response `status` property gives the HTTP status code of the response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response `ok` property is a `boolean` and returns whether the HTTP status
    code is in the 200 range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we run the previous code, we get 200 and true output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an example request where the post doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding code, we get 404 and false output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we would expect with a promised-based function, we handle errors in the
    `catch` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, the `catch` method doesn't catch responses that aren't in the 200 range.
    An example of this was in the previous example, where we got 404 in the response
    status code. So, an HTTP error status code can be handled in the first `then`
    method and not the `catch` method.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the `catch` method for? The answer is to catch network errors.
  prefs: []
  type: TYPE_NORMAL
- en: So, that's how to get data using `fetch`. In the next section, we'll cover posting
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data with fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use `fetch` to create some data with the `JSONPlaceholder` REST
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Basic POST request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating data via a REST API usually involves using the HTTP `POST` method with
    the data we want to create in the request body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up the TypeScript playground and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `fetch` call is largely the same as for getting data. The key difference
    is the second parameter, which is an options object that can contain the method
    and body for the request. Notice also that the body needs to be a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the preceding code, we get a 201 and an object containing the generated
    post ID in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Request HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Very often, we need to include HTTP headers in the request. We can specify
    these in the `options` object in a `headers` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Request headers can be used in this way for any HTTP method and not just an
    HTTP `POST`. For example, we can use this for a `GET` request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, that's how to use `fetch` to post data to a REST API. In the next section,
    we'll look at changing data.
  prefs: []
  type: TYPE_NORMAL
- en: Changing data with fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use `fetch` to change some data via a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Basic PUT request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common way to change data is via a `PUT` request. Let''s open up the TypeScript
    playground and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So, the structure of a `fetch` call to do an HTTP `PUT` is very similar to a
    `POST` request. The only difference is that we specify the `method` property in
    the options object as `PUT`.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the preceding code, we get 200 and the updated `POST` object output
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Basic PATCH request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some REST APIs offer `PATCH` requests, which allow us to submit changes to
    a portion of a resource. Let''s open up the TypeScript playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, we are submitting a change to the title of the post with the `PATCH` HTTP
    method. If we run the preceding code, we get 200 and the updated post object output
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: So, that's how to `PUT` and `PATCH` using `fetch`. In the next section, we'll
    delete some data.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data with fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally, we delete data via a `DELETE` HTTP method on a REST API. Let''s
    enter the following in the TypeScript playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, we are requesting to delete a post with the `DELETE` method.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the preceding code, we get 200 output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've learned how to interact with a RESTful API with the native `fetch`
    function. In the next section, we'll look at doing the same with a popular open
    source library and understanding its benefits over `fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: Using axios with class components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`axios` is a popular open source JavaScript HTTP client. We''re going to build
    a little React app that creates, reads, updates, and deletes posts from the `JSONPlaceholder`
    REST API. Along the way, we''ll discover some of the benefits of `axios` over
    `fetch`. Our first job in the next section is to install `axios`.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we install `axios`, we are going to quickly create our little React
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a folder of our choice, let''s open Visual Studio Code and its Terminal and
    enter the following command to create a new React and TypeScript project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the version of React we use needs to be at least version `16.7.0-alpha.0`.
    We can check this in the `package.json` file. If the version of React in `package.json`
    is older than `16.7.0-alpha.0`, then we can install this version using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After the project is created, let''s add TSLint as a development dependency
    to our project, along with some rules that work well with React and Prettier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add a `tslint.json` file containing some rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open `App.tsx`, there is a linting error. So, let''s resolve this by
    adding `public` as the modifier on the `render` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can install `axios` using NPM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that `axios` has TypeScript types within it, so, we don't need to install
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start our app running before we continue with development:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The app will then start up and run in our browser. In the next section, we'll
    use axios to get posts from JSONPlaceholder.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data with axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to render posts from `JSONPlaceholder` in the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: Basic GET request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start off by getting the posts using a basic GET request with `axios`,
    and then rendering them in an unordered list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `App.tsx` and add an import statement for `axios`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create an interface for the posts that will come from JSONPlaceholder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to store the posts in state, so let''s add an interface for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s then initialize the post-state to an empty array in a constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When getting data from a REST API, we usually do this in the `componentDidMount`
    life cycle method. So, let''s do this with `axios` to get our posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We use the `get` function in `axios` to get data, which is a promised-based
    function like `fetch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a generic function that accepts the response body type as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass the URL we are requesting as the parameter to the `get` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can then handle the response in the `then` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get access to the response body via the `data` property in the response object
    that is typed, as per the generic parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, straight away this is nicer than `fetch` in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We can easily type the response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one step (rather than two) to get the response body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have the posts in the component state, let''s render the posts
    in the `render` method. Let''s also remove the `header` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use the `posts` array's `map` function to display the posts in an unordered
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We reference a `posts` CSS class, so let''s add this to `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the running app, it will now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c8ae59fc-f745-47d3-aca5-ce24e4911e01.png)'
  prefs: []
  type: TYPE_IMG
- en: So, a basic `GET` request with `axios` is nice and easy. We need to use the
    `componentDidMount` life cycle method in a class component to make a REST API
    call that will have data from the response rendered.
  prefs: []
  type: TYPE_NORMAL
- en: How do we handle errors though? We'll cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s adjust the URL in our request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the running app, the posts are no longer being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to handle this situation and give the user some feedback. We can do
    this using a `catch` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So, unlike `fetch`, HTTP status error codes can be handled in the `catch` method.
    The error object argument in `catch` contains a `response` property containing
    information about the response, including the HTTP status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just referenced a piece of state called `error` in the `catch` method. We''ll
    use this in the next step to render the error message. However, we first need
    to add this state to our interface and initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s then render the error if it contains a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `error` CSS class we just referenced to `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the running app now, we'll see Resource not found in red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change the URL to a valid URL so that we can move on to looking
    at how we can include HTTP headers in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, handling HTTP errors with `axios` is different than with `fetch`. We handle
    them in the first `then` method with `fetch`, whereas we handle them in the `catch`
    method with `axios`.
  prefs: []
  type: TYPE_NORMAL
- en: Request HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to include HTTP headers in the request, we need to add a second parameter
    to the `get` function, which can contain various options, including HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an HTTP header for the content type in our request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So, we define the HTTP headers in an object in a property called `headers`.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the running app, it will be exactly the same. The JSONPlaceholder
    REST API doesn't require the content type, but other REST APIs that we interact
    with may do.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at something that is not easily achieved in
    the `fetch` function, which is the ability to specify a timeout on the request.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Timing out requests after a certain amount of time can improve the user experience
    in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a timeout to our request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So, adding a timeout to an `axios` request is super simple. We just add a `timeout`
    property to the options object with an appropriate number of milliseconds. We
    have specified just 1 millisecond, so that we can hopefully see the request timing
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s handle a timeout now in the `catch` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, we check the `code` property in the caught error object in order to determine
    whether a timeout has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the running app, we should get confirmation that a timeout has
    occurred with A timeout has occurred displayed in red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change the timeout to something more sensible so that we can move
    on to looking at how we can allow users to cancel requests in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Canceling requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Allowing the user to cancel a request can improve the user experience in our
    app. We''ll do this with the help of `axios` in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to import the `CancelTokenSource` type from `axios`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a cancel token and a loading flag to our state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s initialize the loading state in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We've defined the cancel token as optional so we don't need to initialize it
    in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll generate the cancel token source and add it to the state, just
    before we make the `GET` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the token in the GET request as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can handle cancellations in the `catch` method as follows. Let''s also set
    the `loading` state to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, we use the `isCancel` function in `axios` to check if the request has been
    canceled.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are in the `componentDidMount` method, let''s set the `loading` state
    to `false` in the `then` method as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` method, let''s add a Cancel button, which will allow the user
    to cancel the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the Cancel button handler that we have just referenced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In order to cancel the request, the cancel method is called on the cancel token
    source.
  prefs: []
  type: TYPE_NORMAL
- en: So, users can now cancel requests by clicking the Cancel button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is going to be hard to test because the REST API we are using is
    really fast! So, in order to see a canceled request, let''s cancel it in the `componentDidMount`
    method immediately after the request is sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the running app, we should see verification that the request was
    cancelled by Request cancelled being displayed in red.
  prefs: []
  type: TYPE_NORMAL
- en: So, `axios` makes it really easy to improve our app's user experience by adding
    the ability to cancel requests.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next section, wherein we look at using `axios` to create
    data, let's remove the line we just added to cancel the request immediately after
    it was made.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data with axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move on to creating data now. We are going to allow the user to enter
    a post title and body and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a new state for the title and body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s initialize this new state as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create an `input` and `textarea` to capture the post title and body
    from the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the change handlers we have just referenced to update the
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a bit of CSS in `index.css` to make this all look reasonable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also start work on the save click handler and `POST` the new post to
    the REST API using `axios`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can handle response using the `then` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: So, we concatenate the new post with the existing post to create a new posts
    array for the state.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the `post` function call is very similar to `get`.  In fact,
    we could add error handling, a timeout, and the ability to cancel the request
    in the same way as we did for `get`.
  prefs: []
  type: TYPE_NORMAL
- en: If we add a new post in the running app and click the Save button, we see it
    added to the bottom of the posts list.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will allow users to update posts.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data with axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move on to updating data now. We are going to allow the user to click
    an Update button in an existing post to change and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create an Update button in each list item in the posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now implement the Update button click handler, which sets the post being
    edited in the component state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In our existing save click handler, we need two branches of code now for the
    existing `POST` request and the `PUT` request we need to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `PUT` request now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: So, we filter out and concatenate the updated post to create a new posts array
    for the state.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the `put` function call is very similar to `get` and `post`. 
    Again, we could add error handling, a timeout, and the ability to cancel the request
    in the same way as we did for `get`.
  prefs: []
  type: TYPE_NORMAL
- en: In the running app, if we click an Update button in a post, change the title
    and body, and click the Save button, we see it removed from where it was and added
    to the bottom of the posts list with the new title and body.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to `PATCH` a post, we can use the `patch` `axios` method. This has
    the same structure as `put` but instead of passing the whole object that is being
    changed, we can just pass the values that need updating.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will allow users to delete posts.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data with axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move on to deleting data now. We are going to allow the user to click
    a Delete button in an existing post to delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a Delete button in each list item in the posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create the Delete button click handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: So, we use the `axios` `delete` method to make an HTTP `DELETE` request, which
    follows the same structure as the other methods.
  prefs: []
  type: TYPE_NORMAL
- en: If we go to the running app, we should see a delete button in each post. If
    we click one of the buttons, we'll see it removed from the list after a short
    delay.
  prefs: []
  type: TYPE_NORMAL
- en: So, that concludes this section on `axios` with class components. We've seen
    that the `axios` functions are a little cleaner than `fetch`, and features such
    as the ability to have typed responses, timeouts, and request cancellation make
    it a popular choice for many developers. In the next section, we'll refactor the
    `App` component we have just implemented to be a function component.
  prefs: []
  type: TYPE_NORMAL
- en: Using axios with function components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll implement REST API calls using `axios` in a function
    component. We''ll refactor the `App` component we built in the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to declare a constant, called `defaultPosts` that is going
    to hold the default posts state we''ll use a little later. We''ll add this after
    the `IPost` interface and set this to an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We'll remove the `IState` interface because the state will be structured as
    individual pieces of state now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll also remove the previous `App` class component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s start the `App` function component under the `defaultPosts` constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create the state for the posts, error, cancel token, loading flag,
    and posts being edited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: So, we use the `useState` function to define and initialize all these pieces
    of state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to make the REST API call to get the posts when the component has first
    been mounted. We can use the `useEffect` function, after the lines where the state
    is defined, to do this passing of an empty array as the second parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call the REST API to get the posts in the arrow function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s handle the response and set the post-state along with setting the loading
    state to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also handle any errors, setting the error state along with the loading
    state to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can move on to the event handlers now.  These are very similar to the class
    component implementation, with `const` replacing the `private` access modifier,
    as well as `this.state` and `this.setState` being replaced by the specific state
    variables and state setter functions. We''ll start with the Cancel button click
    handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can add the change handlers for the title and body inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The Save button click handler is next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do the Update button next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The last handler is for the Delete button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final task is to implement the return statement. Again, this is very similar
    to the class component `render` method, with references to `this` removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Our function component that interacts with a REST API is complete.
    If we try this, it should behave exactly as it did before.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference in terms of REST API interaction is that we use the `useEffect`
    function to make a REST API call to get data that needs to be rendered. We still
    do this when the component has been mounted, like we do in class-based components.
    It's just a different way of tapping into that component life cycle event.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Callback-based asynchronous code can be difficult to read and maintain. Who's
    spent hours trying to track down the root cause of a bug in callback-based asynchronous
    code? Or just spent hours trying to understand what a piece of callback-based asynchronous
    code is trying to do? Thankfully, we now have alternative ways of writing asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Promise-based functions are a great improvement over callback-based asynchronous
    code because the code is a lot more readable and errors can be handled more easily.
    The `async` and `await` keywords arguably make reading asynchronous code even
    easier than promised-based function code because it is very close to what the
    synchronous equivalent would look like.
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have a nice function called `fetch` for interacting with REST
    APIs. This is a promised-based function allowing us to easily make a request and
    nicely manage the response.
  prefs: []
  type: TYPE_NORMAL
- en: '`axios` is a popular alternative to `fetch`. The API is arguably cleaner and
    allows us to better handle HTTP error codes. Timeouts and canceling requests are
    also made very simple using `axios`. `axios` is also TypeScript-friendly, having
    types baked into the library. Having played with both `axios` and `fetch`, which
    is your favorite?'
  prefs: []
  type: TYPE_NORMAL
- en: We can interact with REST APIs in both class- and function-based components.
    When calling a REST API to get data to display in a first component render, we
    need to wait until just after the component has been mounted. In class components,
    we do this using the `componentDidMount` life cycle method. In function components,
    we do this using the `useEffect` function, passing an empty array as the second
    parameter. Having experienced interacting with REST APIs in both types of components,
    which component type are you going to use on your next React and TypeScript project?
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs aren't the only type of API we are likely going to need to interact
    with. GraphQL is a popular alternative API server. We'll learn how we can interact
    with GraphQL servers in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s answer the following questions to help our knowledge of what we have
    just learned stick:'
  prefs: []
  type: TYPE_NORMAL
- en: What will the output be in the console if we ran the following code in a browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that post `9999` doesn't exist, what would be the output in the console
    if we ran the following code in a browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If we did a similar exercise with `axios`, what would be the output in the console
    when running the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: What is the benefit of using the native `fetch` over `axios`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we add a bearer token to the following `axios` request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We are using the following `axios` `PUT` request to update a post title?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The body hasn't changed though—it's just the title we want to update. How can
    we change this to a `PATCH` request to make this REST call more efficient?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have implemented a function component to display a post. It uses the following
    code to get the post from a REST API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with the preceding code?
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links are good resources for further information on the topics
    we have covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: More information about promises can be found at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional information about `async` and `await` is at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about the `fetch` function can be found at [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `axios` GitHub page is at [https://github.com/axios/axios](https://github.com/axios/axios)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
