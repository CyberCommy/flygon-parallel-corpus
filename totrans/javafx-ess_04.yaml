- en: Chapter 4. Developing a JavaFX Application for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no doubt that we are seeing a rise in non-PC clients every day. Almost
    everyone has at least one mobile phone or tablet, maybe from different vendors,
    but certainly with Android or iOS, given that they represent 96 percent of smart
    phone OSs sold in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: Smart phones and tablets are extremely popular nowadays and these figures are
    increasing every year. And that is why developers should consider gaining the
    skills required to develop applications for such a great market.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX 8 already delivers rich client applications for Web and desktop, as we
    have seen in [Chapter 3](ch03.html "Chapter 3. Developing a JavaFX Desktop and
    Web Application"), *Developing a JavaFX Desktop and Web Application*. But, like
    me, if you have written a JavaFX application, you definitely want it to run on
    as many devices as possible to follow the true spirit of *Write Once, Run Anywhere*.
    I would like to take this opportunity to inform you that, yes, we can run JavaFX
    on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the official support from Oracle Corporation for JavaFX, a number of
    people inside the JavaFX community are working to port JavaFX to make it run on
    as many devices and platforms as possible (desktop, mobile, and embedded) and
    different operating systems, with the same codebase.
  prefs: []
  type: TYPE_NORMAL
- en: They have successfully created SDKs that allow us to develop JavaFX applications
    as native applications to run on Android or iOS-based devices in one bundle (*JVM
    plus application*) without any extra software needed to run them as in desktop
    or Web.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you the essential hands-on knowledge about SDKs that
    will allow you to create, package, and deploy native applications for Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some skills that will be gained during this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Android environment tools and software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing and creating the JavaFX 8 mobile project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Android JavaFX 8 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability between JavaFX 8 and Android low-level APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging and deploying applications on mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing the application for final Google Play Store submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why port JavaFX into the mobile environment?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why port JavaFX into the mobile environment? Isn't it **Write Once Run Anywhere**
    (**WORA**)? This is a very good question to ask. Any Java application follows
    the WORA paradigm, but with a very critical abstract piece of software that it
    relies on to run and is called **Java Virtual Machine** (**JVM**).
  prefs: []
  type: TYPE_NORMAL
- en: JVM is the software responsible for translating the compiled byte code (*.class
    file*) for a specific machine and providing platform instructions that it can
    understand and run, so you can run your application. Therefore, you will find
    different versions of JRE or **JDK** for each hardware (Intel, AMD, SPARC, or
    ARM) and platform (Windows, Mac, Linux, or Solaris).
  prefs: []
  type: TYPE_NORMAL
- en: On Desktop, Web, or embedded devices, you have to first install the **Java Runtime
    Environment** (**JRE**) to be able to run your Java application. But, for mobile
    devices, you will notice that you just download your application from the Store,
    install it, and finally run it without any extra software. Also, some closed platforms
    don't allow the JVM to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: For a better end user experience, there should be no difference between running
    JavaFX applications and running other applications targeting Android or iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we should have a self-contained (the application plus JVM) JavaFX
    application that can run on mobile devices. In addition to the ability to interact
    with Android low-level APIs to control device features, it will be treated similarly
    to other applications in the Google Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: We should thank the community for bringing up such porting SDKs and filling
    this gap to allow us to create and run our JavaFX applications on iOS using the
    port from RoboVM ([http://www.robovm.org/](http://www.robovm.org/)) and on Android
    using the port from JavaFXPorts ([http://javafxports.org/](http://javafxports.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Since February 2015, an agreement between the companies behind those projects
    has been in force, and now a single plugin called `jfxmobile-plugin` allows us
    to build applications for three platforms desktop, Android, and iOS from the same
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a new company called **Gluon** offers a free plugin ([http://gluonhq.com/products/tools/ide-plugins/](http://gluonhq.com/products/tools/ide-plugins/))
    for **NetBeans** that creates a project with everything required to build applications
    based on `jfxmobile-plugin`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But bear in mind that all of this is constantly evolving and things may change
    from what is stated here.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both RoboVM for iOS porting and JavaFXPorts for Android porting contain all
    the required libraries to make it easy to package your JavaFX 8 application with
    the required runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: When using RoboVM for iOS to package your JavaFX application (to an `.ipa` package
    file), all your JavaFX applications are transformed into **Objective-C** (currently
    **Swift**) applications.
  prefs: []
  type: TYPE_NORMAL
- en: When packaging your JavaFX application using JavaFXPorts for Android (to the
    `.apk` package file), the applications are transformed into Android packages running
    on top of the **Dalvik** VM.
  prefs: []
  type: TYPE_NORMAL
- en: These SDKs contain a lot of native code that will be ported to iOS and Android
    after injecting them inside your JavaFX application in order to increase application
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using these SDK's, we can package our applications into formats (`.ipa` for
    iOS and `.apk` for Android) that are suitable for submission to Stores.
  prefs: []
  type: TYPE_NORMAL
- en: Who is maintaining it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don't worry—there is free support on a large scale for porting JavaFX to both
    Android and iOS, as well as commercial support.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For free and commercial support, both the RoboVM and JavaFXPorts communities
    use this Google group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://groups.google.com/forum/#!forum/javafxports](https://groups.google.com/forum/#!forum/javafxports)'
  prefs: []
  type: TYPE_NORMAL
- en: Free and commercial support is mainly available from people in the community
    and those who are actively involved in both projects. And they encourage more
    third parties to be involved as well.
  prefs: []
  type: TYPE_NORMAL
- en: For iOS, RoboVM has different plans for developers; you can check them at [http://robovm.com/pricing/](http://robovm.com/pricing/).
  prefs: []
  type: TYPE_NORMAL
- en: While for Android, the company **LodgON** offers support for JavaFX-Android
    integration as part of their support for JavaFX porting ([http://www.lodgon.com/dali/page/JavaFX_Consulting](http://www.lodgon.com/dali/page/JavaFX_Consulting)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have enough information on how the tools and SDKs discussed previously
    will let us get started on developing our JavaFX applications and porting them
    to Android mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: But before moving to the development stage, we should have the tools and software
    installed and configured properly in order to complete the development process,
    based on the provided SDKs, to have a final `.apk` package at hand.
  prefs: []
  type: TYPE_NORMAL
- en: We will deploy this `.apk` package on real devices and finally we will sign
    it for final submission to Google Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started with installing the prerequisite tools and software to
    start developing our application.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing and installing the prerequisite software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to install the following list of tools and software in order to have
    our build process complete without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: Java SE 8 JDK8 u45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already done this before; refer to the *Installing Java SE 8 JDK* section
    in [Chapter 1](ch01.html "Chapter 1. Getting Started with JavaFX 8"), *Getting
    Started with JavaFX 8*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java SE 8 update 40 is the minimum version required in order to develop JavaFX
    applications for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From their website, this is the definition of Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Gradle is an open source build automation system. Gradle can automate the
    building, testing, publishing, deployment, and more of software packages or other
    types of projects, such as generated static websites, generated documentation,
    or indeed anything else.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recently, Android development tools changed their build system to Gradle. The
    RoboVM and JavaFXPorts porting projects mimic the same tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Gradle is a very straightforward task:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://gradle.org](https://gradle.org).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the right-hand side, under the **GET GRADLE!** Section, click on **Downloads
    2.4** (as of this writing) and the download process will start for the `gradle-2.4-all.zip`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the downloaded `.zip` file into a convenient location of your choice and
    unzip it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final step is to set the environment variable into your system as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Windows – Assume Gradle is installed at `c:\tools\gradle_2.4`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On Mac – Assume Gradle is installed at `/usr/local/tools/gradle_2.4`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Android SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android SDK includes the complete set of development and debugging tools
    for the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Android SDK is a very straightforward task:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://developer.android.com/sdk/index.html#Other](http://developer.android.com/sdk/index.html#Other).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under SDK Tools Only, click `on android-sdk_r24.2-{platform}`.`{exe|zip|tgz}`
    (as of this writing) against the name of your favorite platform:![Android SDK](img/B03998_04_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Download` page will open; accept the terms, click on the `Download android-sdk_r24.2-{platform}`.`{exe|zip|tgz}`
    button, and the download process will start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the downloaded `.zip` file into a convenient location and unzip it, or
    double-click the `.exe` on Windows to start the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the command line, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Android SDK Manager will open; click on `Build-tools version 21.1.2` or
    higher and the SDK Platform for API 21 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Install x packages**, accept the license, and click on **Install**.
    You are done.
  prefs: []
  type: TYPE_NORMAL
- en: A good reference for Android SDK Manager is at [http://developer.android.com/sdk/installing/adding-packages.html](http://developer.android.com/sdk/installing/adding-packages.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to set the environment variable in your system as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Windows – Assume the Android SDK is installed at `c:\tools\android_ADT`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On Mac – Assume the Android SDK is installed at `/usr/local/tools/android_ADT`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The best approach for this is to create a Gradle property with the name ANDROID_HOME
    defined under `C:\Users\<user>\.gradle\gradle.properties`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the project for Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully installed the prerequisite software and tools and configured
    the environmental variables, so we are ready to start developing the application
    that will be ported into the Android device.
  prefs: []
  type: TYPE_NORMAL
- en: But before we do so, we need to prepare our project structure and the build
    file as well in order to be ready for building and packaging our application with
    JavaFXPorts libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a complex project with three different platforms would have been
    a hard task, until now. But recently, Gluon (http://gluonhq.com/) has released
    a NetBeans plugin ([http://gluonhq.com/gluon-plugin-for-netbeans/](http://gluonhq.com/gluon-plugin-for-netbeans/))
    that simplifies this task to a great degree.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way is to use the Gluon plugin for NetBeans. This will create everything
    for you a Java project, where you just need to add the JavaFX sources, and a `build.gradle`
    file with all the tasks ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed the plugin, perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Just create a new JavaFX project and select **Basic Gluon Application**, as
    shown here:![Project structure](img/B03998_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select valid names for the project (`DialPad2`), packages (`packt.taman.jfx8.ch4`),
    and the main class (`DialPad2`) and you will find a bunch of folders in your new
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The top project structure following the Gluon plugin will bring a more complex
    structure and should be as seen in the following screenshot:![Project structure](img/B03998_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Gluon plugin project structure
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to add our build script file to complete our mission.
  prefs: []
  type: TYPE_NORMAL
- en: Using Gradle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To build a Gradle project, we need the `build.gradle` script file. The Gluon
    plugin has already added this file for you by default, including all the properties
    to allow our application to run and compile successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default Gradle build file created `build.gradle` file should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only important thing to change is the `jfxmobile-plugin` version to 1.0.0-b8
    (or the most recent one; check [https://bitbucket.org/javafxports/javafxmobile-plugin/overview](https://bitbucket.org/javafxports/javafxmobile-plugin/overview)
    frequently to keep it updated).
  prefs: []
  type: TYPE_NORMAL
- en: The application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that you have reached this section means that we have finished setting
    up the application project structure correctly, and it's now ready for mobile
    device development.
  prefs: []
  type: TYPE_NORMAL
- en: Our application will be a new smart phone dial pad interface to perform calls
    on our device with its default dialer. It will be customized with CSS to control
    its skinning style, which can be modified to get the native look and feel for
    different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The main aim of this application is to provide a new UI concept (to customize
    an application using CSS), and you will learn how to use the CSS id and class
    selectors as well as setting them from inside the code to be applied to different
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshots show the application before and after applying the
    CSS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application](img/B03998_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Developing and styling an application UI with CSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have learned before, I will start prototyping our application; after the
    prototyping, we should have the application UI we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This application UI is written directly inside the `start(Stage)` function of
    the class `DialPad2.java`, as an alternative way to develop UIs rather than using
    static FXML design.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we nested controls from inside the code in case we need to dynamically
    generate UI controls and assign them different settings, `CSS` classes, `ids`
    selectors, and `listeners`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we produced the preceding application
    UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code starts by creating a scene that has `BorderPane` as a root node. After
    the scene is created, the code loads the CSS style sheet file, `Mobile_UI.<platform>.css`,
    to style the current scene''s nodes via the `getStylesheets().add()` method as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After we have created a `TextField` output to show the dial result and set it
    to be disabled so we can't edit it, the numbers are added and displayed just by
    clicking on the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code simply creates a grid using the `GridPane` class and generates
    12 buttons to be placed in each cell. Notice in the for loop that each button
    is set with the style class named `dial-num-btn` via the `getStyleClass().add()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use here an old classic `for` loop for adding the buttons, and not a fancy
    Java 8 stream. Be aware that `Dalvik VM` runs only on Java 7, and only lambdas
    can be used (since, internally, JavaFXPorts uses the Retrolambda project).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the dark blue **Call** button will be added to the last row of the grid
    pane. Because the **Call** button is unique, its id selector is set with `#call-btn`,
    and it will be styled using the id selector, which means the selector named inside
    the CSS file will be prefixed with the `#` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the CSS file used to style the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information about JavaFX 8 CSS properties, visit the following JavaFX
    8 CSS reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding some logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you have seen in the code snippet, each of the 12 buttons has an action
    assigned using a lambda expression that is dynamically created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We get the output `TextField` and concatenate the next number, asterisk, or
    hash symbol by getting the source of the event `e`, which in our case is the clicked
    button, and then its text value, containing the number to dial.
  prefs: []
  type: TYPE_NORMAL
- en: Making your project ready for mobile devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Basically, this new project was generated with the Gluon plugin (`build.gradle`
    updated to **b8**).
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the application ready for mobile devices, we need to adjust
    its height and width to the target device screen and make the UI tree respond
    to that accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very simple yet important step and we can adjust the following line
    of code by setting the scene height and width to the target device screen dimensions
    dynamically. Have a look at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Change this to the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line gets the device screen `bounds`. Then we set the scene height
    and width from this bounds variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line adds your sources to the Sources Packages [Java] and Resources
    [Main]. It then adds a `PlatformFactory` class, which is in charge of finding
    which platform the project is running from. Have a look at the `Platform` interface
    with a method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to call the following method on your source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you provide the native solution for each platform. For instance, for
    Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work on Android, we only need to modify `AndroidManifest.xml`,
    adding the required permission and the activity intent. This custom manifest has
    to be referenced on the `build.gradle` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Interoperability with low-level Android APIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You need `android.jar` in order to use the Android API's, and you need `jfxdvk.jar`
    in order to access the `FXActivity` class, which is the bridge between `JavaFX`
    and the `Dalvik` runtime. We use a static method on the `FXActivity` to retrieve
    the `FXActivity`, which extends the Android `Context`. This `Context` can be used
    to look up Android services.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create our Android `.apk` package file for our application, we
    need to build our application first; it is a very easy task. With the command
    line (or from NetBeans, right-click on the **project** tab and select `Tasks/task`)
    pointing to the current project folder, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Gradle will download all the required libraries and start building our application.
    Once finished, you should see the successful output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Until now, we have built our application successfully. Next we need to generate
    the `.apk` and deploy it to many sources.
  prefs: []
  type: TYPE_NORMAL
- en: Building the final .apk Android package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have two options when it comes to building our `.apk` file. The first is
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the `.apk` file in the directory `build/javafxports/android`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will deploy the generated `.apk` package onto a device that is connected
    to your desktop or laptop device.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the first option (`gradle android`) to make sure that we are able
    to generate the `.apk` file successfully. When done successfully, you should have
    a file named `DialPad2.apk` under the path mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to deploy our application on the connected mobile device using the
    `gradle androidInstall` command, you have to enable **Developer Options** and
    enable some other settings inside it on your device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From your device, tap on **Settings** to open the setting menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the top menu, choose **More**. The options depend on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the **More Options** menu list, you should see **Developer Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the **Developer Options** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **Developer Options** by turning on the slider at the top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **debugging**, enable **USB debugging**, click on the **OK** button in
    the **Allow USB debugging** alert window, and enable **Unknown sources**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You are done—let's go and install our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Optional**: if you don''t see **Developer Options**, don''t worry. It is
    present but hidden. Here is the magic—tap on **About device**, locate **Build
    number**, and tap on it 5 times (7 times on Lollipop). You will see a countdown
    of numbers, and at the end **Developer Options** will be enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on Android-based devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'No as we are ready run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After issuing this command, it will start building and packaging the JavaFX
    8 application. The plugin will connect to your connected device and install the
    application into it. This is the result you should have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open your device and locate your applications icon from the home screen;
    in the bottom-right corner, you should see your `DialPad2` JavaFX application
    installed as seen in the following screenshot, with the default Android icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying on Android-based devices](img/B03998_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JavaFX 8 application installed on the Android device
  prefs: []
  type: TYPE_NORMAL
- en: 'Tap the **DialPad2** application, and you should see your application up-and-running
    on your device and fully functional as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying on Android-based devices](img/B03998_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JavaFX 8 application running on Android device
  prefs: []
  type: TYPE_NORMAL
- en: 'Tap the **Call** button and the Android default dialer will be launched, dialing
    the number you have typed in, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying on Android-based devices](img/B03998_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JavaFX 8 application dialing a number
  prefs: []
  type: TYPE_NORMAL
- en: 'If something doesn''t work as expected, go to the command line and type in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And you will have the output from all the applications on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on the Google Play Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to deploy your application on the Google Play Store, you have to perform
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You have to be enroll yourself with Google Play Developers ([https://play.google.com/apps/publish/](https://play.google.com/apps/publish/)),
    fill a form with the description and several screenshots, and finally submit the
    DialPad2 apk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `AndroidManifest.xml`, you have to disable the debugging option by adding
    `android:debuggable="false"` on the `application` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also add the icon of your app (`android:icon="@icons/ic_launcher`) under
    the `application` tag. Here, `icons-*` are image folders with several resolutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Signing the APK
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `apk` must be signed for release. **Signed** means you need a private key;
    for that, we can use keytool ([http://developer.android.com/tools/publishing/app-signing.html#signing-manually](http://developer.android.com/tools/publishing/app-signing.html#signing-manually)).
  prefs: []
  type: TYPE_NORMAL
- en: 'And **release** means that we need to add the signing configuration to `build.gradle`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on the **DialPad2** project and, from **Tasks**, choose **apk**
    and then **apkRelease**.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! The resulting `DialPad2.`apk is ready for submission to Google
    Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: Testing tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important point before delivering your application is to test it, especially
    on different Android based mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience with the mobile industry, I have found a dozen vendors' test
    mobile and tablets running the Android platform, each of them customizing the
    UI layer of each device with different capabilities and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four golden rules in the mobile testing field from my experience are:'
  prefs: []
  type: TYPE_NORMAL
- en: Test on as many real devices and Android platforms as possible to cover all
    cases that your application will run on and to know how it will behave in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use simulators only for *GUI testing and functionality* and not for *performance
    testing*. All simulators rely on your underlying PC/laptop hardware and memory,
    while on mobile hardware it will be quite different and very challenging to achieve
    the same performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a new simulator called ARC Welder for Chrome. Check it out at [https://developer.chrome.com/apps/getstarted_arc](https://developer.chrome.com/apps/getstarted_arc).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test on real devices for final production and performance testing. This is so
    you are assured that your application will act accordingly on the targeted market
    devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave you a very good understanding of the mobile industry and how
    JavaFX-based applications can be developed and customized using different projects
    such as **RoboVM** for **iOS** and **JavaFXPorts** for **Android** to make it
    possible to run your application on both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how to install the required software and tools for Android development
    and to enable Android SDK along with *JavaFXPorts* libraries to package and install
    our dialer JavaFX-based application on a real Android device and submit it to
    Google Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to customize our application using CSS to have a different look and
    feel for the same application to make sure you have provided a different CSS for
    the Android version.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to enable our device in the debugging mode to successfully
    install the application from `jfxmobile-plugin` via the command line. Finally,
    we covered the four golden rules of testing.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will not differ too much from this one, but will give you a
    very good introduction to, and knowledge of, targeting your JavaFX 8 application
    to run on iOS-based devices. You will also learn how to use its development tools.
  prefs: []
  type: TYPE_NORMAL
