- en: Go Packages, Algorithms, and Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main topics of this chapter will be Go packages, algorithms, and data structures.
    If you combine all of these, you will end up with a complete program because Go
    programs come in packages that contain algorithms that deal with data structures.
    These packages include both the ones that come with Go and the ones that you create
    on your own in order to manipulate your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, in this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Big O notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two sorting algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sort.Slice()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own hash table data structure in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Garbage collection** (**GC**) in Go'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing about algorithms and the way they work will definitely help you when
    you have to manipulate lots of data. Additionally, if you choose to use the wrong
    algorithm for a given job, you might slow down the entire process and make your
    software unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional Unix command-line utilities such as `awk(1)`, `sed(1)`, `vi(1)`,
    `tar(1)`, and `cp(1)` are great examples of how good algorithms can help, and
    these utilities can work with files that are much bigger than the memory of a
    machine. This was extremely important in the early Unix days because the total
    amount of RAM on a Unix machine then was about 64K or even less!
  prefs: []
  type: TYPE_NORMAL
- en: The Big O notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Big O** **notation** is used for describing the complexity of an algorithm,
    which is directly related to its performance. The efficiency of an algorithm is
    judged by its computation complexity, which mainly has to do with the number of
    times the algorithm needs to access its input data to do its job. Usually, you
    would want to know about the worst-case scenario and the average situation.
  prefs: []
  type: TYPE_NORMAL
- en: So, an O(n) algorithm, where n is the size of the input, is considered better
    than an O(n²) algorithm, which is better than an O(n³) algorithm. However, the
    worst algorithms are the ones with an O(n!) running time because this makes them
    almost unusable for inputs with more than 300 elements. Note that the Big O notation
    is more about estimating and not about giving an exact value. Therefore, it is
    largely used as a comparative value and not an absolute value.
  prefs: []
  type: TYPE_NORMAL
- en: Also, most Go lookup operations in built-in types, such as finding the value
    of a map key or accessing an array element, have a constant time, which is represented
    by O(1). This means that built-in types are generally faster than custom types
    and that you should usually prefer them unless you want full control over what
    is going on behind the scenes. Additionally, not all data structures are created
    equal. Generally speaking, array operations are faster than map operations, whereas
    maps are more versatile than arrays!
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common category of algorithm has to deal with sorting data, that is,
    placing it in a given order. The two most famous sorting algorithms are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quicksort**: This is considered one of the fastest sorting algorithms. The
    average time that quicksort takes to sort its data is O (n log n), but this can
    grow up to O(n²) in the worst-case scenario, which mainly has to do with the way
    the data is presented for processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bubble sort**: This algorithm is pretty easy to implement with an O(n²) average
    complexity. If you want to start learning about sorting, start with bubble sort
    before looking into the more difficult to develop algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although every algorithm has its disadvantages, if you do not have lots of data,
    the algorithm is not really important as long as it does the job.
  prefs: []
  type: TYPE_NORMAL
- en: What you should remember is, the way Go implements sorting internally cannot
    be controlled by the developer and it can change in the future; so, if you want
    to have full control over sorting, you should write your own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The sort.Slice() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will illustrate the use of the `sort.Slice()` function that first
    came with Go version 1.8\. The use of the function will be illustrated in `sortSlice.go`,
    which will be presented in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the expected preamble of the program and the definition of
    a new structure type, given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, you have to import the `sort` package to be able to use
    its `Slice()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the definition of a slice, which has four elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, in the first part, you declared a slice of structure that will be
    sorted in two ways in the rest of the program, which contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code contains all the magic: you only have to define the way you want
    to `sort` your `slice` and the rest is done by Go. The `sort.Slice()` function
    takes the anonymous sorting function as one of its arguments; the other argument
    is the name of the `slice` variable you want to `sort`. Note that the sorted slice
    is saved in the `slice` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `sortSlice.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can easily `sort` in ascending or descending order by just
    changing a single character in the Go code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if your Go version does not support `sort.Slice()`, you will get an error
    message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Linked lists in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **linked list** is a structure with a finite set of elements where each element
    uses at least two memory locations: one for storing the data and the other for
    a pointer that links the current element to the next one in the sequence of elements
    that make the linked list. The biggest advantages of linked lists are that they
    are easy to understand and implement, and generic enough to be used in many different
    situations and model many different kinds of data.'
  prefs: []
  type: TYPE_NORMAL
- en: The first element of a linked list is called the **head**, whereas the last
    element of a list is often called the **tail**. The first thing you should do
    when defining a linked list is to keep the head of the list in a separate variable
    because the head is the only thing that you need to access the entire linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you lose the pointer to the first node of a single linked list,
    there is no possible way to find it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the graphical representation of a linked list and
    a doubly linked list. Doubly linked lists are more flexible, but require more
    housekeeping:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/834e20cc-7099-4649-b740-da9fa61fbd3d.png)'
  prefs: []
  type: TYPE_IMG
- en: The graphical representation of a linked list and a doubly linked list
  prefs: []
  type: TYPE_NORMAL
- en: So, in this section, we will present a simple implementation of a linked list
    in Go saved in `linkedList.go`.
  prefs: []
  type: TYPE_NORMAL
- en: When creating your own data structures, the single most important element is
    the definition of the node, which is usually implemented using a structure.
  prefs: []
  type: TYPE_NORMAL
- en: The code of `linkedList.go` will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you define the structure that will hold each element of the list and a
    function that allows you to add a new node to the list. In order to avoid duplicate
    entries, you should check whether a value already exists in the list or not. Note
    that `addNode()` is a recursive function because it calls itself and that this
    approach might be a little slower and require more memory than iterating.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the code is the `traverse()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop implements the iterative approach for visiting all the nodes
    in a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For the first time in this book, you see the use of a global variable that is
    not a constant. Global variables can be accessed and changed from anywhere in
    a program, which makes their use both practical and dangerous for that reason.
    The reason for using a global variable, which is named `root`, to hold the `root`
    of the linked list is to show whether the linked list is empty or not. This happens
    because integer values in Go are initialized as `0`; so `new(Node)` is in fact
    `{0 <nil>}`, which makes it impossible to tell whether the head of the list is
    nil or not without passing an extra variable to each function that manipulates
    the linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `linkedList.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Trees in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **graph** is a finite and nonempty set of vertices and edges. A **directed
    graph** is a graph whose edges have a direction associated with them. A **directed
    acyclic graph** is a directed graph with no cycles in it. A **tree** is a directed
    acyclic graph that satisfies three more principles: firstly, it has a root node:
    the entry point to the tree; secondly, every vertex, except the root, has one
    and only one entry point; and thirdly, there is a path that connects the root
    with each vertex and belongs to the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the root is the first node of the tree. Each node can be connected
    to one or more nodes depending on the tree type. If each node leads to one and
    only one other node, then the tree is a linked list!
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used type of tree is called a binary tree because each node
    can have up to two children. The following figure shows a graphical representation
    of a binary tree''s data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f4a000e-6fe7-4025-81f3-ff52adfbd59f.png)'
  prefs: []
  type: TYPE_IMG
- en: A binary tree
  prefs: []
  type: TYPE_NORMAL
- en: The presented code will only show you how to create a binary tree and how to
    traverse it in order to print all of its elements as proof that Go can be used
    for creating a tree data structure. Therefore, it will not implement the full
    functionality of a binary tree, which also includes deleting a tree node and balancing
    a tree.
  prefs: []
  type: TYPE_NORMAL
- en: The code of `tree.go` will be presented in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the expected preamble as well as the definition of the node,
    as given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part contains functions that allow you to traverse a tree in order
    to print all of its elements, create a tree with randomly generated numbers, and
    insert a node into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second `if` statement of `insert()` checks whether a value already exists
    in the tree, in order to not add it again. The third `if` statement identifies
    whether the new element will be on the left or right-hand side of the current
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the implementation of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `tree.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Please note that as the values of the nodes of the tree are generated randomly,
    the output of the program will be different each time you run it. If you want
    to get the same elements all the time, then use a constant for the seed value
    in the `create()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a hash table in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strictly speaking, a **hash table** is a data structure that stores one or more
    key and value pairs and uses the `hashFunction` of the key to compute an index
    into an array of buckets or slots, from which the correct value can be retrieved.
    Ideally, the `hashFunction` should assign each key to a unique bucket, provided
    that you have the required number of buckets.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good `hashFunction` must be able to produce a uniform distribution of hash
    values because it is inefficient to have unused buckets or big differences in
    the cardinalities of the buckets. Additionally, the `hashFunction` should work
    consistently and output the same hash value for identical keys because otherwise
    it would be impossible to find the information you want! If you think that hash
    tables are not that useful, handy, or clever, you should consider the following:
    when a hash table has *n* keys and *k* buckets, its search speed goes from O (n)
    for a linear search to O (n/k)! Although the improvement might look small, you
    should realize that for a hash array with only 20 slots, the search time would
    be reduced by 20 times! This makes hash tables good for applications such as dictionaries
    or any other analogous application where you have to search lots of data. Although
    using lots of buckets increases the complexity and the memory usage of your program,
    there are times when it is worth it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the graphical representation of a simple hash table
    with 10 buckets. It is not difficult to understand that the `hashFunction` is
    the modulo operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30731fad-6b66-43d1-8e49-25ae564255a1.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple hash table
  prefs: []
  type: TYPE_NORMAL
- en: Although the presented version of a hash table uses numbers because they are
    a little easier to implement and understand, you can use any data type you want
    as long as you can find an appropriate `hashFunction` to process your input. The
    source code of `hash.go` will be presented in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Node struct` definition is taken from the implementation of the linked
    list you saw earlier. The reason for using a map for the `Table` variable instead
    of a slice is that the index of a slice can only be a natural number, whereas
    the key of a map can be anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note here that the `traverse()` function is using the Go code from `linkedList.go`
    in order to traverse the elements of each bucket in the hash table. Additionally,
    note that the `insert` function does not check whether or not a value already
    exists in the hash table in order to save book space, but this is not usually
    the case. Also, for reasons of speed and simplicity, new elements are inserted
    at the beginning of each list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part contains the implementation of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `hash.go` will generate the following output, which proves that the
    hash table is working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you execute `hash.go` multiple times, you will see that the order the lines
    are printed in will vary. This happens because the output of `range hash.Table`
    found in the `traverse()` function cannot be predicted, which happens because
    Go has an unspecified return order for hashes.
  prefs: []
  type: TYPE_NORMAL
- en: About Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages are for grouping related functions and constants so that you can transfer
    them easily and use them in your own Go programs. As a result, apart from the
    main package, packages are not autonomous programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There exist many useful Go packages that come with each Go distribution including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `net` package: This supports portable TCP and UDP connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `http` package: This is a part of the net package and offers HTTP server
    and client implementations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `math` package: This provides mathematical functions and constants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `io` package: This deals with primitive input and output operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `os` package: This gives you a portable interface to the operating system
    functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `time` package: This allows you to work with times and dates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full list of standard Go packages refer to [https://golang.org/pkg/](https://golang.org/pkg/).
    I strongly advise you to look into all the packages that come with Go before you
    start developing your own functions and packages because there is a realistic
    chance that the functionality you are looking for is already available in a standard
    Go package.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably already know how to use the standard Go packages. However, what
    you may not be aware of is the fact that some packages have a structure. So, for
    example, the `net` package has several sub directories, named `http`, `mail`,
    `rpc`, `smtp`, `textproto`, and `url`, which should be imported as `net/http`,
    `net/mail`, `net/rpc`, `net/smtp`, `net/textproto`, and `net/url`, respectively.
    Go groups packages when this makes sense, but these packages could have also been
    isolated packages if they were grouped for distribution instead of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You can find information about a Go standard package with the help of the `godoc`
    utility. So, if you are looking for information about the `net` package, you should
    execute `godoc net`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages make the design, implementation, and maintenance of large software
    systems easier and simpler. Moreover, they allow multiple programmers to work
    on the same project without any overlapping. So, if you find yourselves using
    the same functions all the time, you should seriously consider including them
    in your own Go packages.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of a Go package, which can contain multiple files, can be found
    within a single directory, which is named after the package with the exception
    of the main package, which can have any name.
  prefs: []
  type: TYPE_NORMAL
- en: The Go code of the `aSimplePackage.go` file, which will be developed in this
    section, will be presented in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special here; you just have to define the name of the package
    and include the necessary import statements because a package can depend on other
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, the `aSimplePackage` package offers two functions and one constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you finish writing the code of `aSimplePackage.go`, you should execute
    the following commands in order to be able to use the package in other Go programs
    or packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You should perform all these actions for every Go package you create, apart
    from the first two `mkdir` commands, which should only be executed once.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, each package needs its own directory inside `~/go/src`. After
    executing the aforementioned commands, the `go tool` will automatically generate
    an `ar(1)` archive of the Go package you have just compiled in the `pkg` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although you are now ready to use the `aSimplePackage` package, you cannot see
    the functionality of the package without having an autonomous program.
  prefs: []
  type: TYPE_NORMAL
- en: Private variables and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Private variables and functions are different from public ones in that they
    can be used and called only internally in a package. Controlling `which` functions
    and variables are public or not is also known as encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Go follows a simple rule which states that functions, variables, types, and
    so on that begin with an uppercase letter are public, whereas functions, variables,
    types, and so on that begin with a lowercase letter are private. However, this
    rule does not affect package names.
  prefs: []
  type: TYPE_NORMAL
- en: You should understand now why the `fmt.Printf()` function is named as it is,
    instead of `fmt.printf()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, we will make some changes to the `aSimplePackage.go` module
    and add one private variable and one private function. The name of the new separate
    package will be `anotherPackage.go`. You can see the changes made to it using
    the `diff(1)` command-line utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The init() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Go package can have a function named `init()` that is automatically executed
    at the beginning of the execution. So, let''s add the following `init()` function
    to the code of the `anotherPackage.go` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The current implementation of the `init()` function is naive and does nothing
    special. However, there are times when you want to perform important initializations
    before you start using a package such as opening database and network connections:
    in these relatively rare cases the `init()` function is invaluable.'
  prefs: []
  type: TYPE_NORMAL
- en: Using your own Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will show you how to use the `aSimplePackage` and `anotherPackage`
    packages in your own Go programs by presenting two small Go programs named `usePackage.go`
    and `privateFail.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the `aSimplePackage` package that resides under the `GOPATH`
    directory from another Go program, you will need to write the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, if `aSimplePackage` is not already compiled and located at the
    expected location, the compilation process will fail with an error message similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if `aSimplePackage` is available, `usePackage.go` will be executed
    just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the Go code of the other small program that uses `anotherPackage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to call a private function or use a private variable from `anotherPackage`,
    your Go program `privateFail.go` will fail to run with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I really like showing error messages because most books try to hide them as
    if they were not there. When I was learning Go, it took me about 3 hours of debugging
    until I found that the reason for an error message I could not explain was the
    name of a variable!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you remove the call to the private variable from `privateFail.go`,
    the program will be executed without errors. Additionally, you will see that the
    `init()` function actually gets executed automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using external Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes packages are available on the internet and you would prefer to use
    them by specifying their internet address. One such example is the Go `MySQL`
    driver that can be found at `github.com/go-sql-driver/mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following Go code, which is saved as `useMySQL.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of `_` as the package identifier will make the compiler ignore the
    fact that the package is not being used: the only sensible reason for bypassing
    the compiler is when you have an `init` function in your unused package that you
    want to be executed. The other sensible reason is for illustrating a Go concept!'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to execute `useMySQL.go`, the compilation process will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to compile `useMySQL.go`, you should first perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully downloading the required package, the contents of the `~/go`
    directory verify that the desired Go package has been downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The go clean command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There will be times when you are developing a big Go program that uses lots
    of nonstandard Go packages and you want to start the compilation process from
    the beginning. Go allows you to clean up the files of a package in order to recreate
    it later. The following command cleans up a package without affecting the code
    of the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can also clean up a package that you have downloaded from the
    internet, which also requires the use of its full path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the `go clean` command is also particularly useful when you
    want to transfer your projects to another machine without including unnecessary
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will briefly talk about how Go deals with GC, which tries
    to free unused memory efficiently. The Go code of `garbageCol.go` can be presented
    in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Every time you want to read the latest memory statistics, you should make a
    call to the `runtime.ReadMemStats()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part, which contains the implementation of the `main()` function,
    has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, you try to obtain large amounts of memory in order to trigger the use
    of the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `garbageCol.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the output presents information about properties related to the memory
    used by the `garbageCol.go` program. If you want to get an even more detailed
    output, you can execute `garbageCol.go`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the command will give you information in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `95->95->0 MB` part contains information about the various heap sizes that
    also show how well or how badly the garbage collector is doing. The first value
    is the heap size when the GC starts, whereas the middle value shows the heap size
    when the GC ends. The third value is the size of the live heap.
  prefs: []
  type: TYPE_NORMAL
- en: Your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show how to find out things about your environment
    using the `runtime` package: this can be useful when you have to take certain
    actions depending on the OS and the Go version you are using.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the `runtime` package for finding out about your environment is
    straightforward and is illustrated in `runTime.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as you know what you want to call from the runtime package, you can
    get the information you desire. The last `fmt.Println()` command here displays
    information about **goroutines**: you will learn more about goroutines in [Chapter
    9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,* *Goroutines - Basic Features*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `runTime.go` on a macOS machine generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `runTime.go` on a Linux machine that uses an older Go version gives
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Go gets updated frequently!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I came to the end of writing this chapter, Go was updated a little. So,
    I decided to include this information in this book in order to give a better sense
    of how often Go gets updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visit the documentation of the runtime package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your own structure, make a slice and use the `sort.Slice()` to sort the
    elements of the slice you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the quicksort algorithm in Go and sort some randomly-generated numeric
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a doubly linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation of `tree.go` is far from complete! Try to implement a function
    that checks whether a value can be found in the tree and another function that
    allows you to delete a tree node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, the implementation of the `linkedList.go` file is also incomplete.
    Try to implement a function for deleting a node and another one for inserting
    a node somewhere inside the linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, the hash table implementation of `hash.go` is incomplete as it allows
    duplicate entries. So, implement a function that searches the hash table for a
    key before inserting it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned many things related to algorithms and data structures.
    You also learned how to use existing Go packages and how to develop your own Go
    packages. This chapter also talked about garbage collection in Go and how to find
    information about your environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start talking about systems programming and present
    even more Go code. More precisely, [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml),
    *Files and Directories*, will talk about how to work with files and directories
    in Go, how to painlessly traverse directory structures, and how to process command-line
    arguments using the `flag` package. But more importantly, we will start developing
    Go versions of various Unix command-line utilities.
  prefs: []
  type: TYPE_NORMAL
