- en: Go Packages, Algorithms, and Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main topics of this chapter will be Go packages, algorithms, and data structures.
    If you combine all of these, you will end up with a complete program because Go
    programs come in packages that contain algorithms that deal with data structures.
    These packages include both the ones that come with Go and the ones that you create
    on your own in order to manipulate your data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, in this chapter, you will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The Big O notation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two sorting algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sort.Slice()` function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own hash table data structure in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Garbage collection** (**GC**) in Go'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About algorithms
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing about algorithms and the way they work will definitely help you when
    you have to manipulate lots of data. Additionally, if you choose to use the wrong
    algorithm for a given job, you might slow down the entire process and make your
    software unusable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Traditional Unix command-line utilities such as `awk(1)`, `sed(1)`, `vi(1)`,
    `tar(1)`, and `cp(1)` are great examples of how good algorithms can help, and
    these utilities can work with files that are much bigger than the memory of a
    machine. This was extremely important in the early Unix days because the total
    amount of RAM on a Unix machine then was about 64K or even less!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The Big O notation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Big O** **notation** is used for describing the complexity of an algorithm,
    which is directly related to its performance. The efficiency of an algorithm is
    judged by its computation complexity, which mainly has to do with the number of
    times the algorithm needs to access its input data to do its job. Usually, you
    would want to know about the worst-case scenario and the average situation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: So, an O(n) algorithm, where n is the size of the input, is considered better
    than an O(n²) algorithm, which is better than an O(n³) algorithm. However, the
    worst algorithms are the ones with an O(n!) running time because this makes them
    almost unusable for inputs with more than 300 elements. Note that the Big O notation
    is more about estimating and not about giving an exact value. Therefore, it is
    largely used as a comparative value and not an absolute value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Also, most Go lookup operations in built-in types, such as finding the value
    of a map key or accessing an array element, have a constant time, which is represented
    by O(1). This means that built-in types are generally faster than custom types
    and that you should usually prefer them unless you want full control over what
    is going on behind the scenes. Additionally, not all data structures are created
    equal. Generally speaking, array operations are faster than map operations, whereas
    maps are more versatile than arrays!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common category of algorithm has to deal with sorting data, that is,
    placing it in a given order. The two most famous sorting algorithms are the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Quicksort**: This is considered one of the fastest sorting algorithms. The
    average time that quicksort takes to sort its data is O (n log n), but this can
    grow up to O(n²) in the worst-case scenario, which mainly has to do with the way
    the data is presented for processing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bubble sort**: This algorithm is pretty easy to implement with an O(n²) average
    complexity. If you want to start learning about sorting, start with bubble sort
    before looking into the more difficult to develop algorithms.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although every algorithm has its disadvantages, if you do not have lots of data,
    the algorithm is not really important as long as it does the job.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: What you should remember is, the way Go implements sorting internally cannot
    be controlled by the developer and it can change in the future; so, if you want
    to have full control over sorting, you should write your own implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The sort.Slice() function
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will illustrate the use of the `sort.Slice()` function that first
    came with Go version 1.8\. The use of the function will be illustrated in `sortSlice.go`,
    which will be presented in three parts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the expected preamble of the program and the definition of
    a new structure type, given as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you might expect, you have to import the `sort` package to be able to use
    its `Slice()` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the definition of a slice, which has four elements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Therefore, in the first part, you declared a slice of structure that will be
    sorted in two ways in the rest of the program, which contains the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code contains all the magic: you only have to define the way you want
    to `sort` your `slice` and the rest is done by Go. The `sort.Slice()` function
    takes the anonymous sorting function as one of its arguments; the other argument
    is the name of the `slice` variable you want to `sort`. Note that the sorted slice
    is saved in the `slice` variable.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `sortSlice.go` will generate the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, you can easily `sort` in ascending or descending order by just
    changing a single character in the Go code!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if your Go version does not support `sort.Slice()`, you will get an error
    message similar to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Linked lists in Go
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **linked list** is a structure with a finite set of elements where each element
    uses at least two memory locations: one for storing the data and the other for
    a pointer that links the current element to the next one in the sequence of elements
    that make the linked list. The biggest advantages of linked lists are that they
    are easy to understand and implement, and generic enough to be used in many different
    situations and model many different kinds of data.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The first element of a linked list is called the **head**, whereas the last
    element of a list is often called the **tail**. The first thing you should do
    when defining a linked list is to keep the head of the list in a separate variable
    because the head is the only thing that you need to access the entire linked list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you lose the pointer to the first node of a single linked list,
    there is no possible way to find it again.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the graphical representation of a linked list and
    a doubly linked list. Doubly linked lists are more flexible, but require more
    housekeeping:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/834e20cc-7099-4649-b740-da9fa61fbd3d.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: The graphical representation of a linked list and a doubly linked list
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: So, in this section, we will present a simple implementation of a linked list
    in Go saved in `linkedList.go`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: When creating your own data structures, the single most important element is
    the definition of the node, which is usually implemented using a structure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The code of `linkedList.go` will be presented in four parts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second part contains the following Go code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you define the structure that will hold each element of the list and a
    function that allows you to add a new node to the list. In order to avoid duplicate
    entries, you should check whether a value already exists in the list or not. Note
    that `addNode()` is a recursive function because it calls itself and that this
    approach might be a little slower and require more memory than iterating.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the code is the `traverse()` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `for` loop implements the iterative approach for visiting all the nodes
    in a linked list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the first time in this book, you see the use of a global variable that is
    not a constant. Global variables can be accessed and changed from anywhere in
    a program, which makes their use both practical and dangerous for that reason.
    The reason for using a global variable, which is named `root`, to hold the `root`
    of the linked list is to show whether the linked list is empty or not. This happens
    because integer values in Go are initialized as `0`; so `new(Node)` is in fact
    `{0 <nil>}`, which makes it impossible to tell whether the head of the list is
    nil or not without passing an extra variable to each function that manipulates
    the linked list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中首次看到不是常量的全局变量的使用。全局变量可以从程序的任何地方访问和更改，这使得它们的使用既实用又危险。使用名为`root`的全局变量来保存链表的`root`是为了显示链表是否为空。这是因为在Go中，整数值被初始化为`0`；因此`new(Node)`实际上是`{0
    <nil>}`，这使得在不传递额外变量给每个操作链表的函数的情况下，无法判断列表的头部是否为空。
- en: 'Executing `linkedList.go` will generate the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`linkedList.go`将生成以下输出：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Trees in Go
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的树
- en: 'A **graph** is a finite and nonempty set of vertices and edges. A **directed
    graph** is a graph whose edges have a direction associated with them. A **directed
    acyclic graph** is a directed graph with no cycles in it. A **tree** is a directed
    acyclic graph that satisfies three more principles: firstly, it has a root node:
    the entry point to the tree; secondly, every vertex, except the root, has one
    and only one entry point; and thirdly, there is a path that connects the root
    with each vertex and belongs to the tree.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**图**是一个有限且非空的顶点和边的集合。**有向图**是一个边带有方向的图。**有向无环图**是一个没有循环的有向图。**树**是一个满足三个原则的有向无环图：首先，它有一个根节点：树的入口点；其次，除了根之外，每个顶点只有一个入口点；第三，存在一条连接根和每个顶点的路径，并且属于树。'
- en: As a result, the root is the first node of the tree. Each node can be connected
    to one or more nodes depending on the tree type. If each node leads to one and
    only one other node, then the tree is a linked list!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根是树的第一个节点。每个节点可以连接到一个或多个节点，具体取决于树的类型。如果每个节点只指向一个其他节点，那么树就是一个链表！
- en: 'The most commonly used type of tree is called a binary tree because each node
    can have up to two children. The following figure shows a graphical representation
    of a binary tree''s data structure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的树类型是二叉树，因为每个节点最多可以有两个子节点。下图显示了二叉树数据结构的图形表示：
- en: '![](img/4f4a000e-6fe7-4025-81f3-ff52adfbd59f.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f4a000e-6fe7-4025-81f3-ff52adfbd59f.png)'
- en: A binary tree
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树
- en: The presented code will only show you how to create a binary tree and how to
    traverse it in order to print all of its elements as proof that Go can be used
    for creating a tree data structure. Therefore, it will not implement the full
    functionality of a binary tree, which also includes deleting a tree node and balancing
    a tree.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的代码只会向您展示如何创建二叉树以及如何遍历它以打印出所有元素，以证明Go可以用于创建树数据结构。因此，它不会实现二叉树的完整功能，其中还包括删除树节点和平衡树。
- en: The code of `tree.go` will be presented in three parts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree.go`的代码将分为三部分呈现。'
- en: 'The first part is the expected preamble as well as the definition of the node,
    as given here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是预期的序言以及节点的定义，如下所示：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The second part contains functions that allow you to traverse a tree in order
    to print all of its elements, create a tree with randomly generated numbers, and
    insert a node into it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含允许您遍历树以打印所有元素、使用随机生成的数字创建树以及将节点插入其中的函数：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second `if` statement of `insert()` checks whether a value already exists
    in the tree, in order to not add it again. The third `if` statement identifies
    whether the new element will be on the left or right-hand side of the current
    node.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`的第二个`if`语句检查树中是否已经存在值，以免重复添加。第三个`if`语句标识新元素将位于当前节点的左侧还是右侧。'
- en: 'The last part is the implementation of the `main()` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是`main()`函数的实现：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing `tree.go` will generate the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`tree.go`将生成以下输出：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Please note that as the values of the nodes of the tree are generated randomly,
    the output of the program will be different each time you run it. If you want
    to get the same elements all the time, then use a constant for the seed value
    in the `create()` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于树的节点的值是随机生成的，程序的输出每次运行时都会不同。如果您希望始终获得相同的元素，则在`create()`函数中使用种子值的常量。
- en: Developing a hash table in Go
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中开发哈希表
- en: Strictly speaking, a **hash table** is a data structure that stores one or more
    key and value pairs and uses the `hashFunction` of the key to compute an index
    into an array of buckets or slots, from which the correct value can be retrieved.
    Ideally, the `hashFunction` should assign each key to a unique bucket, provided
    that you have the required number of buckets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，**哈希表**是一种数据结构，它存储一个或多个键值对，并使用键的`hashFunction`计算出数组中的桶或槽的索引，从中可以检索到正确的值。理想情况下，`hashFunction`应该将每个键分配到一个唯一的桶中，前提是您有所需数量的桶。
- en: 'A good `hashFunction` must be able to produce a uniform distribution of hash
    values because it is inefficient to have unused buckets or big differences in
    the cardinalities of the buckets. Additionally, the `hashFunction` should work
    consistently and output the same hash value for identical keys because otherwise
    it would be impossible to find the information you want! If you think that hash
    tables are not that useful, handy, or clever, you should consider the following:
    when a hash table has *n* keys and *k* buckets, its search speed goes from O (n)
    for a linear search to O (n/k)! Although the improvement might look small, you
    should realize that for a hash array with only 20 slots, the search time would
    be reduced by 20 times! This makes hash tables good for applications such as dictionaries
    or any other analogous application where you have to search lots of data. Although
    using lots of buckets increases the complexity and the memory usage of your program,
    there are times when it is worth it.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the graphical representation of a simple hash table
    with 10 buckets. It is not difficult to understand that the `hashFunction` is
    the modulo operator:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30731fad-6b66-43d1-8e49-25ae564255a1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: A simple hash table
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Although the presented version of a hash table uses numbers because they are
    a little easier to implement and understand, you can use any data type you want
    as long as you can find an appropriate `hashFunction` to process your input. The
    source code of `hash.go` will be presented in three parts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Node struct` definition is taken from the implementation of the linked
    list you saw earlier. The reason for using a map for the `Table` variable instead
    of a slice is that the index of a slice can only be a natural number, whereas
    the key of a map can be anything.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the following Go code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note here that the `traverse()` function is using the Go code from `linkedList.go`
    in order to traverse the elements of each bucket in the hash table. Additionally,
    note that the `insert` function does not check whether or not a value already
    exists in the hash table in order to save book space, but this is not usually
    the case. Also, for reasons of speed and simplicity, new elements are inserted
    at the beginning of each list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part contains the implementation of the `main()` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Executing `hash.go` will generate the following output, which proves that the
    hash table is working as expected:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you execute `hash.go` multiple times, you will see that the order the lines
    are printed in will vary. This happens because the output of `range hash.Table`
    found in the `traverse()` function cannot be predicted, which happens because
    Go has an unspecified return order for hashes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: About Go packages
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages are for grouping related functions and constants so that you can transfer
    them easily and use them in your own Go programs. As a result, apart from the
    main package, packages are not autonomous programs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'There exist many useful Go packages that come with each Go distribution including
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The `net` package: This supports portable TCP and UDP connections'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `http` package: This is a part of the net package and offers HTTP server
    and client implementations'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `math` package: This provides mathematical functions and constants'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `io` package: This deals with primitive input and output operations'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `os` package: This gives you a portable interface to the operating system
    functionality'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `time` package: This allows you to work with times and dates'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full list of standard Go packages refer to [https://golang.org/pkg/](https://golang.org/pkg/).
    I strongly advise you to look into all the packages that come with Go before you
    start developing your own functions and packages because there is a realistic
    chance that the functionality you are looking for is already available in a standard
    Go package.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Using standard Go packages
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably already know how to use the standard Go packages. However, what
    you may not be aware of is the fact that some packages have a structure. So, for
    example, the `net` package has several sub directories, named `http`, `mail`,
    `rpc`, `smtp`, `textproto`, and `url`, which should be imported as `net/http`,
    `net/mail`, `net/rpc`, `net/smtp`, `net/textproto`, and `net/url`, respectively.
    Go groups packages when this makes sense, but these packages could have also been
    isolated packages if they were grouped for distribution instead of functionality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: You can find information about a Go standard package with the help of the `godoc`
    utility. So, if you are looking for information about the `net` package, you should
    execute `godoc net`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own packages
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages make the design, implementation, and maintenance of large software
    systems easier and simpler. Moreover, they allow multiple programmers to work
    on the same project without any overlapping. So, if you find yourselves using
    the same functions all the time, you should seriously consider including them
    in your own Go packages.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The source code of a Go package, which can contain multiple files, can be found
    within a single directory, which is named after the package with the exception
    of the main package, which can have any name.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The Go code of the `aSimplePackage.go` file, which will be developed in this
    section, will be presented in two parts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is nothing special here; you just have to define the name of the package
    and include the necessary import statements because a package can depend on other
    packages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the following Go code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, the `aSimplePackage` package offers two functions and one constant.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'After you finish writing the code of `aSimplePackage.go`, you should execute
    the following commands in order to be able to use the package in other Go programs
    or packages:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You should perform all these actions for every Go package you create, apart
    from the first two `mkdir` commands, which should only be executed once.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, each package needs its own directory inside `~/go/src`. After
    executing the aforementioned commands, the `go tool` will automatically generate
    an `ar(1)` archive of the Go package you have just compiled in the `pkg` directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although you are now ready to use the `aSimplePackage` package, you cannot see
    the functionality of the package without having an autonomous program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Private variables and functions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Private variables and functions are different from public ones in that they
    can be used and called only internally in a package. Controlling `which` functions
    and variables are public or not is also known as encapsulation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Go follows a simple rule which states that functions, variables, types, and
    so on that begin with an uppercase letter are public, whereas functions, variables,
    types, and so on that begin with a lowercase letter are private. However, this
    rule does not affect package names.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: You should understand now why the `fmt.Printf()` function is named as it is,
    instead of `fmt.printf()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, we will make some changes to the `aSimplePackage.go` module
    and add one private variable and one private function. The name of the new separate
    package will be `anotherPackage.go`. You can see the changes made to it using
    the `diff(1)` command-line utility:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The init() function
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Go package can have a function named `init()` that is automatically executed
    at the beginning of the execution. So, let''s add the following `init()` function
    to the code of the `anotherPackage.go` package:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The current implementation of the `init()` function is naive and does nothing
    special. However, there are times when you want to perform important initializations
    before you start using a package such as opening database and network connections:
    in these relatively rare cases the `init()` function is invaluable.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Using your own Go packages
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will show you how to use the `aSimplePackage` and `anotherPackage`
    packages in your own Go programs by presenting two small Go programs named `usePackage.go`
    and `privateFail.go`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the `aSimplePackage` package that resides under the `GOPATH`
    directory from another Go program, you will need to write the following Go code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First of all, if `aSimplePackage` is not already compiled and located at the
    expected location, the compilation process will fail with an error message similar
    to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, if `aSimplePackage` is available, `usePackage.go` will be executed
    just fine:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s see the Go code of the other small program that uses `anotherPackage`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you try to call a private function or use a private variable from `anotherPackage`,
    your Go program `privateFail.go` will fail to run with the following error message:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I really like showing error messages because most books try to hide them as
    if they were not there. When I was learning Go, it took me about 3 hours of debugging
    until I found that the reason for an error message I could not explain was the
    name of a variable!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you remove the call to the private variable from `privateFail.go`,
    the program will be executed without errors. Additionally, you will see that the
    `init()` function actually gets executed automatically:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using external Go packages
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes packages are available on the internet and you would prefer to use
    them by specifying their internet address. One such example is the Go `MySQL`
    driver that can be found at `github.com/go-sql-driver/mysql`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following Go code, which is saved as `useMySQL.go`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The use of `_` as the package identifier will make the compiler ignore the
    fact that the package is not being used: the only sensible reason for bypassing
    the compiler is when you have an `init` function in your unused package that you
    want to be executed. The other sensible reason is for illustrating a Go concept!'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to execute `useMySQL.go`, the compilation process will fail:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to compile `useMySQL.go`, you should first perform the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After successfully downloading the required package, the contents of the `~/go`
    directory verify that the desired Go package has been downloaded:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The go clean command
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There will be times when you are developing a big Go program that uses lots
    of nonstandard Go packages and you want to start the compilation process from
    the beginning. Go allows you to clean up the files of a package in order to recreate
    it later. The following command cleans up a package without affecting the code
    of the package:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, you can also clean up a package that you have downloaded from the
    internet, which also requires the use of its full path:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Please note that the `go clean` command is also particularly useful when you
    want to transfer your projects to another machine without including unnecessary
    files.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will briefly talk about how Go deals with GC, which tries
    to free unused memory efficiently. The Go code of `garbageCol.go` can be presented
    in two parts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Every time you want to read the latest memory statistics, you should make a
    call to the `runtime.ReadMemStats()` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part, which contains the implementation of the `main()` function,
    has the following Go code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, you try to obtain large amounts of memory in order to trigger the use
    of the garbage collector.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `garbageCol.go` generates the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, the output presents information about properties related to the memory
    used by the `garbageCol.go` program. If you want to get an even more detailed
    output, you can execute `garbageCol.go`, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This version of the command will give you information in the following format:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `95->95->0 MB` part contains information about the various heap sizes that
    also show how well or how badly the garbage collector is doing. The first value
    is the heap size when the GC starts, whereas the middle value shows the heap size
    when the GC ends. The third value is the size of the live heap.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Your environment
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show how to find out things about your environment
    using the `runtime` package: this can be useful when you have to take certain
    actions depending on the OS and the Go version you are using.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the `runtime` package for finding out about your environment is
    straightforward and is illustrated in `runTime.go`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As long as you know what you want to call from the runtime package, you can
    get the information you desire. The last `fmt.Println()` command here displays
    information about **goroutines**: you will learn more about goroutines in [Chapter
    9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,* *Goroutines - Basic Features*.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `runTime.go` on a macOS machine generates the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Executing `runTime.go` on a Linux machine that uses an older Go version gives
    the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Go gets updated frequently!
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I came to the end of writing this chapter, Go was updated a little. So,
    I decided to include this information in this book in order to give a better sense
    of how often Go gets updated:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Exercises
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visit the documentation of the runtime package.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your own structure, make a slice and use the `sort.Slice()` to sort the
    elements of the slice you created.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the quicksort algorithm in Go and sort some randomly-generated numeric
    data.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a doubly linked list.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation of `tree.go` is far from complete! Try to implement a function
    that checks whether a value can be found in the tree and another function that
    allows you to delete a tree node.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, the implementation of the `linkedList.go` file is also incomplete.
    Try to implement a function for deleting a node and another one for inserting
    a node somewhere inside the linked list.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, the hash table implementation of `hash.go` is incomplete as it allows
    duplicate entries. So, implement a function that searches the hash table for a
    key before inserting it.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned many things related to algorithms and data structures.
    You also learned how to use existing Go packages and how to develop your own Go
    packages. This chapter also talked about garbage collection in Go and how to find
    information about your environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start talking about systems programming and present
    even more Go code. More precisely, [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml),
    *Files and Directories*, will talk about how to work with files and directories
    in Go, how to painlessly traverse directory structures, and how to process command-line
    arguments using the `flag` package. But more importantly, we will start developing
    Go versions of various Unix command-line utilities.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
