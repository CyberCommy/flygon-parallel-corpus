- en: Interacting with Smart Contracts Using Web3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you're going to learn how to connect to a smart contract programmatically.
    Here, you'll use the Python programming language to execute a method in a smart
    contract. To achieve that, you will use the `web3.py` library. In the previous
    chapter, you built a smart contract and deployed it to the Ethereum blockchain.
    You also used Vyper to write a smart contract. To interact with that smart contract,
    you fired up the Truffle console and typed in a number of commands. Those commands
    are sent to the smart contract in the blockchain. Depending on what command you
    type in, this could either read the state of the smart contract or change it. In
    this chapter, you are going to move beyond the Truffle console.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to decentralized applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `web3.py` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with smart contracts using `web3.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to decentralized applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll build a program using Python to execute methods in a smart contract programmatically,
    and we call this program a decentralized application. So, there's a smart contract,
    and there's a decentralized application. A smart contract written with the Vyper
    or Solidity programming languages lives in an Ethereum blockchain. This means
    that if you deploy your smart contract to the Ethereum production blockchain,
    the bytecode of your smart contract is written in every Ethereum node. So, if
    we have 10,000 Ethereum nodes in this world, your smart contract is duplicated
    10,000 times.
  prefs: []
  type: TYPE_NORMAL
- en: However, a decentralized application doesn't live in Ethereum blockchain. It
    lives in your computer, in your neighbor's computer, in a cloud, but it does not
    live on the blockchain, and it does not have to be duplicated all over the world
    in the same way as a smart contract. People build a decentralized application
    using various programming languages. In the case of Ethereum, the most popular
    programming languages for building a decentralized application are Javascript
    in the Node.js environment and Python. In our case, we are going to use Python
    to build a decentralized application. To do this, we need a library. In the case
    of Javascript , we need a `web3.js` library. In our case, which is Python, we
    need a `web3.py` library. All of the library names include the word web3.
  prefs: []
  type: TYPE_NORMAL
- en: 'People like to think of web3 as a third version of the internet: a decentralized
    internet. So, if this is the third version, what are the first and second ones,
    you ask? The first version of the internet is the internet that you use to consume
    content passively (think static websites.) The second version of the internet
    is the social one, where you generate content and co-create experiences (think
    Facebook, Twitter, or Instagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb53afe9-871e-481e-b2ca-e482b52ca024.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see that the Vyper or Solidity bytecode
    lives (duplicated) in many Ethereum nodes (system). But a program using the `web3`
    library can live in a single computer (such as a laptop or smartphone).
  prefs: []
  type: TYPE_NORMAL
- en: Installing web3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without further ado, let''s install the `web3` library. Create a virtual environment
    with Python 3.6 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Activate the virtual environment and install Vyper as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install the `web3.py` library using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, verify whether it works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t encounter any errors, it works. Let''s connect to the Ganache
    blockchain with `web3`. To do this, first fire up Ganache, and then go back to
    your Python Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What we have done here is connecting to Ganache blockchain with the `web3` library.
    We can retrieve the information on the blockchain, such as how many blocks have
    been mined on this particular blockchain. Because we are using Ganache, a development
    blockchain, `w3.eth.blockNumber` returns `0` because we have not created any transaction
    on Ganache.
  prefs: []
  type: TYPE_NORMAL
- en: Geth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Go Ethereum** (**Geth**) is an implementation of the Ethereum protocol written
    in Go. You can use Geth to sync an Ethereum node, or even build a private Ethereum
    blockchain. If you want to be a miner, this is a software that you would use.
    Your Ethereum node is a gateway and a part of Ethereum blockchain. Your program
    with the `web3` library requires the Ethereum node to be able to interact with
    a smart contract that lives inside the blockchain.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Ganache is all fine and dandy. But Ganache is a fake blockchain. There
    are no miners, so it's hard to simulate some situations that we would encounter
    on real Ethereum blockchain. As a result, let's step up our game. We don't need
    to use Ethereum production blockchain now, but we can use something in between
    development and production blockchain—the **Rinkeby network**. If the Ethereum
    production blockchain is akin to a production server, the Rinkeby network is like
    a staging server. In DevOps lingua franca, a staging server is a test server that
    mimics a production server as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, Rinkeby is not a software like Ganache. It lives on the internet. As a
    result, using the Rinkeby network, we can get a feel for what it is like to deal
    with the Ethereum production blockchain. One of the situations you could encounter
    in Etherum blockchain in the Rinkeby network is that it takes time to confirm
    a transaction. In Ganache, it takes a fraction of a second to confirm a transaction.
    In the Rinkeby network, it takes maybe 20-30 seconds, or even a minute, to confirm
    a transaction, so you need to get used to it. Of course, not everything in the
    Ethereum production blockchain can be replicated on the Rinkeby network. Another situation
    that specifically happens in the Ethereum production blockchain is that it includes
    the high traffic that the Ethereum production blockchain sometimes gets. For example,
    a decentralized application named Cryptokitties slowed down the Ethereum network
    because there are many users interacting with the application, as can be seen
    here: [https://techcrunch.com/2017/12/03/people-have-spent-over-1m-buying-virtual-cats-on-the-ethereum-blockchain/](https://techcrunch.com/2017/12/03/people-have-spent-over-1m-buying-virtual-cats-on-the-ethereum-blockchain/).'
  prefs: []
  type: TYPE_NORMAL
- en: There is another Ethereum testing network similar to the Rinkeby network—the
    **Ropsten network**. The difference here is that the Rinkeby network uses **Proof-of-Authority**
    (**PoA**) in confirming transactions, while the Ropsten network uses **Proof-of-Work**
    (**PoW**). Right now, there is no need to worry about this difference, since using
    the Rinkeby network is similar to using the Ropsten network.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to connect to this kind of Ethereum blockchain—by running
    Ethereum node yourself, or by using other people's nodes. Each method comes with
    its own advantages and disadvantages. Running an Ethereum node takes up a lot
    of storage. A node connecting to the Rinkeby network requires around 6 GB of storage.
    As regards the Ethereum production network, it requires a whopping 150 GB of storage.
    Depending on your internet connection, to be fully operational, you need a night
    or a couple of days to make the node fully synchronized with all other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Another method is to use someone else's node. Some people build a web service
    to connect to their Ethereum node, so you can use an API to connect to their Ethereum
    node. One of the most popular services for this is Infura. All you need to do
    here is register on their website to get their API.
  prefs: []
  type: TYPE_NORMAL
- en: To run our own Ethereum node for the Rinkeby network, go to [https://geth.ethereum.org/downloads/](https://geth.ethereum.org/downloads/)
    to download the software for your operating system. For Ubuntu Linux, this is
    in `tar.gz` format, so you have to extract it. Then, put the binary file somewhere
    convenient (something such as `/opt/bin` or `/home/yourusername/Program` or `/user/local/bin`).
  prefs: []
  type: TYPE_NORMAL
- en: 'After doing this, synchronize the node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a different data directory. By default, Geth stores the data in
    the `~/.ethereum` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In my case, this takes a night. Your experience may be different depending on
    how fast your internet connection is.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is fully synced (you know this is the case when the output no longer
    changes that often), then you can run Python inside the `web3-venv` virtual environment
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a different provider to the one we used in the previous example.
    With the Ganache example, we use an HTTP provider. Remember that Ganache uses
    `http://localhost:7545` and you use this information in the Truffle configuration.
    However, in our case, when we connect to the Ethereum node, we use **Inter Process
    Communication provider** (**IPC**). You can also see a parameter of `IPCProvider` ,
    which is a file path. So your Python program communicates with the Ethereum node
    by means of that file. In computer science, that file is called a `pipe`. You
    just search where the `geth.ipc` file lives on your local computer. Remember that `geth.ipc`
    only shows up if you run `geth` software. If you stop it, the `geth.ipc` file will
    disappear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, before you run business as usual, you need to inject something into the
    web3 middleware. This should be done because the block size in the Ethereum production
    blockchain is different to the block size in the Rinkeby blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can test it, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output you got is the information regarding the latest block of blockchain
    in the Rinkeby network. There are a couple of things that you can learn from the
    block of blockchain. You can find all the transactions that have been confirmed
    in this block; the gas used, the gas limit, and so on. In the Rinkeby network,
    the miner is always the zero address (`0x0000000000000000000000000000000000000000`),
    because blockchain in the Rinkeby network uses proof of authority. But in mainnet
    (production network), you can find out who got the reward to confirm the blockchain.
    You can find the information from the latest block in mainnet (the Ethereum production
    network) from [https://etherscan.io/blocks](https://etherscan.io/blocks). Of course,
    you could find the same information from the Ethereum production node if you are
    willing to sync the node.
  prefs: []
  type: TYPE_NORMAL
- en: Geth console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we continue to use the `web3` library, let''s play around with Geth
    software. Geth software can act like the Truffle console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The keyword is `console` in that statement, but in order to make it a more
    pleasant experience, you should add another `--verbosity` flag with a value of `0`.
    This will prevent you from getting bogged down with a lot of output from the `geth`
    software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Geth console, you can do anything that you can do in the Truffle console.
    However, we now want to create an Ethereum account. When you launch Ganache, you
    are equipped with 10 accounts that are ready to be used. However, this is not
    the case in the Rinkeby blockchain. You need to create an account manually in
    Rinkeby:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the command to create a new Ethereum account. You need to supply a password
    to create an account in the Geth console. Don't forget the password for this account,
    as there is no option to recover it. The output of this command is your account's
    public address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private key is encrypted in a file inside the following directory: `/home/yourusername/.geth/rinkeby/keystore`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file name is something like this: `UTC—2018-10-12T09-30-20.687898000Z—28f5b56b035da966afa609f65fd8f7d71ff68327`.
    This is a combination of a timestamp and public key. You can open it, but you
    will not be able to find the private key inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To decrypt it, you can use the `web3` library. Name the script `extract_private_key.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the script, you will see your private key, which can be used
    in another situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Please do not use this account in a production setting any more because the
    private key is already exposed. Use it for development purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: 'This private key is in `bytes` format. If you want to convert it to a hex string,
    you can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the web3.py library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s write a decentralized application with this library. The simplest
    decentralized application script would be sending money from one account to another.
    Name the script `send_money_ganache.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you execute this script, launch Ganache first. After doing so, take
    any public address you like and put it into the `to` field in the transaction
    dictionary. This account will be the receiver. Then find another account, look
    at its private key, and input the value in the `private_key` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2cef175b-2047-433c-b849-69d84d925d92.png)'
  prefs: []
  type: TYPE_IMG
- en: Put one ether in the `value` field. This means you want to send 1 ether to another
    account. This is a simple script to illustrate how sending a transaction works.
    It does not show best practice because you shouldn't put a private key embedded
    in the code like this. You could read a private key from the file with restricted
    permission, for example, or you could request the private key from the standard
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute this script, you would notice that the receiver''s balance would
    increase by 1 ETH, while the sender''s balance would decrease by 1 ETH:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/79c28369-b896-4f17-b5d0-454b93a5a90e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f653adc0-e03c-4fc7-93ba-885e22a7c240.png)'
  prefs: []
  type: TYPE_IMG
- en: Gas and gas price
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you will know, Ethereum blockchain is not free; someone has to maintain it.
    I am not talking about developers who write Ethereum software, but miners who
    run Ethereum nodes to confirm transactions. They are rewarded with money (ETH)
    from Ethereum software itself. On top of that, they are rewarded with the fee
    of the transaction. This fee is the gas and gas price.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need a fee on top of a reward in Ethereum software? This is to prevent
    spam from users. If a transaction is free, a troller could set up two accounts,
    sending the money back and forth between them. In addition, this gives high priority
    to users who want to pay more. If there are two similar transactions, but the
    first transaction is backed with more gas, it would be of higher priority in a
    miner's to-do list. The transaction with less gas will be confirmed in the end;
    it just needs to wait a little bit longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So there is gas and there is a gas price. Gas is the amount of gas you are
    willing to allocate in this transaction. In a previous script, you allocate 20,000
    gas to create a transaction to send the money. For a more complex transaction,
    such as executing a complex method in a smart contract, it could require more
    gas. If you don''t allocate enough gas, your transaction would be rejected and
    you could lose gas as well. But if you put more than enough gas, if your transaction
    is successful, the remaining gas would be returned to you. So, you would think:
    Why not just set gas aside as much as possible? There is a catch. If, somehow,
    your call of a method in a smart contract fails assertion (for example: assert
    1 == 2), you would lose all the gas you use up until the assertion line (but the
    remaining gas will be refunded). So you need to hit the middle ground.'
  prefs: []
  type: TYPE_NORMAL
- en: Gas price is the price of the gas, so gas is not free. It's separated from Ethereum
    itself. You buy gas with the ETH you have. You could check the gas price in historical
    transactions. In the Ethereum production blockchain, you could check the price
    of the gas in [https://www.ethgasstation.info/](https://www.ethgasstation.info/).
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you estimate the gas you need for your transaction? You need to learn
    all the intricacy of the Solidity or Vyper programming languages. If I allocate
    a variable of integer with 256 bits and store it in storage, how much would it
    cost? What about looping? What about constructing a struct? This sounds complicated,
    but luckily, the `web3` library has a method to estimate gas usage. First, create
    a script named `estimate_gas.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You would get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you find an error related to nonce, change nonce to 1 or higher until it
    works. Well talk about nonce in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Nonce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have observed that you get errors related to nonce if you try to execute
    the sending money script more than once. If you haven't, try it. You have to increase
    nonce to make it work again. Nonce is like an indicator of how many transactions
    you have made with an account. For the first transaction (just after creating
    a new account), you put zero value in nonce. Then, for the second transaction,
    you put a value of 1 in nonce. Then, for the third transaction, you put a value
    of 2 in nonce.
  prefs: []
  type: TYPE_NORMAL
- en: 'But keeping track of the nonce value becomes silly, especially if you want
    to use an old account on which you don''t know how high the nonce value is. Fortunately,
    there is a way of obtaining the latest nonce value from Ethereum blockchain. Create
    a script named `get_latest_nonce.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Try to send money again with a higher nonce, and then execute this script. Do
    it again. This will show you the value tallies.
  prefs: []
  type: TYPE_NORMAL
- en: With this new knowledge, you must be careful to create a transaction in Ethereum
    blockchain. In the real world, transactions could take time to be confirmed. Imagine
    you create two different transactions in parallel with the same nonce. If both
    transactions are valid, only one of them will be recorded on Ethereum blockchain.
    The other one will be rejected because of a nonce issue. Which transaction of
    these two will be confirmed? It would be quite random.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you must decide which transaction you want to be confirmed first. Give
    it a lower nonce. For the second transaction, you accord a higher nonce. However,
    if the first transaction fails, the second transaction will be rejected because
    the nonce is too high (the nonce skips one number). This is something you need
    to bear in mind.
  prefs: []
  type: TYPE_NORMAL
- en: So why all of this nonce bureaucracy? It is to prevent the same transaction
    from happening again. Imagine you broadcast a transaction where you send one ETH
    to your neighbor. I could copy this transaction and broadcast it again. Since
    this transaction is validated with your signature, I could drain your account.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a transaction on Rinkeby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have had fun with Ganache, let's try to create a transaction on
    the Rinkeby network. You may notice a problem here—unlike Ganache, where you get
    10 accounts each with a 100 ETH balance, here you get nothing. You have to create
    an account by default. Creating 10 accounts is easy. But what about the balance?
    Each account you created on the Rinkeby network with Geth software comes with
    a balance of 0 ETH. But sending money requires well, money, to pay the transaction
    fee.
  prefs: []
  type: TYPE_NORMAL
- en: In the Ethereum production blockchain, you get ETH from the cryptocurrency exchange
    or from mining. But in the Rinkeby network, you get money by begging. And here's
    how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to [https://faucet.rinkeby.io/](https://faucet.rinkeby.io/), and then, using
    one of the social media platforms, such as Twitter, Google+, or Facebook, you
    create a post containing your public address in the Rinkeby network. Then, post
    your social media post in the form on the Rinkeby faucet website. You have three
    options: 3 ethers in 8 hours, 7.5 ethers in 1 day, or 18.5 ethers in 3 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fb0d293b-a32c-4021-8366-bbc1c44016c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make sure you got the balance, you can check the balance from the Geth software.
    Sync it first. As I said before, this process could take a long time, perhaps
    several hours, or one night in my case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After your local blockchain node is fully synced with the Rinkeby network,
    kill the `geth` process first and launch `geth` again, but with different flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute this command inside the `geth` console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Change this address to your address. You should get some ETH from the faucet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have the ETH already, you can create a transaction in the Rinkeby
    network. Here is the script to send ethers in the Rinkeby network. You can refer
    to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/send_money_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/send_money_rinkeby.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Change the account receiver's address, your private key encrypted file location,
    your password, and the `geth.ipc` file location according to your situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that our private key is encrypted in a file. So we read that file,
    and then unlock it with a password. Remember, you should not embed the password
    in the code directly. Then you can check your destination account''s balance in
    the `geth` console after waiting a couple of minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You send a transaction by signing it with a private key. This is the most versatile
    way to create a transaction in Ethereum. But there is another way, which involves
    using just a password.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a private key like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, instead, you can use a password when signing a transaction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using password can only be done when you control the node because it requires
    an encrypted private key file. I have created a couple of accounts in my Ethereum
    node. I can only use a password when signing a transaction for these accounts
    only. But with a private key, I can use any account.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with smart contracts using web3.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've sent ethers using a Python script with the `web3` library in Ganache
    and the Rinkeby network. Now, let's create a script to interact with a smart contract.
    But before doing that, you need to learn how to launch a smart contract with `geth`
    and a Python script with the `web3` library. Previously, in [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml),
    *Implementing Smart Contracts Using Vyper*, you launched a smart contract using
    Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a smart contract with Geth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next section, we are going to connect to a smart contract with `web3`.
    Here''s how to deploy a smart contract to the Rinkeby blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `geth` console, list all of your accounts with Geth software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these accounts come from the keystore files you created with this command:
    `personal.newAccount("password")`. Say you want to unlock the first account, then
    you can use the `personal.unlockAccount` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, get  `bytecode` and put it in a variable. Remember that you get  `bytecode`
    when you compile the source code with the Vyper compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, check whether your smart contract has been confirmed on the blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If it has been confirmed, then you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Launching a smart contract with web3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also launch a smart contract using a Python script with the `web3`
    library. Name this script `deploy_smart_contract_to_ganache.py`. You can refer
    to the code file on the following GitLab link for the full code, [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_ganache.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script. But make sure you have Ganache running. You should get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you create a smart contract object with this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in order to deploy a smart contract, you just have to use the `constructor`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The final step is quite important, which is to wait for the transaction to be
    confirmed. It's important because you need to get the smart contract's address
    after the transaction has been confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to deploy a smart contract to the Rinkeby network, you need to
    modify this script. Create a new file named `deploy_smart_contract_to_rinkeby.py`. You
    can refer to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/deploy_smart_contract_to_rinkeby.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The difference (other than using `IPCProvider` instead of `HTTPProvider`) when
    deploying a smart contract to the Rinkeby network is that you have to set `gas`,
    `gasPrice`, and `nonce` as well. On top of that, you use the `buildTransaction`
    method, get the `transaction` object, and sign it with a private key. Because
    this script runs in the Rinkeby network, you need to make sure you've allocated
    sufficient gas. It's a common mistake to deploy a smart contract to the Rinkeby
    network with insufficient gas. Then, developers are confused as to why the smart
    contract can't be accessed afterward. When you deploy this smart contract to the
    Rinkeby network, you need to wait a while.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with a smart contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we have developed a simple smart contract using Vyper
    named `hello.vy`. Let''s create a script using `web3` to interact with this smart
    contract. If you have forgotten the content of `hello.vy`, here is the content
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Compile it and deploy it to Ganache or the Rinkeby network. Now, depending on
    whether you want to connect to your smart contract in Ganache or Rinkeby, choose
    one of the following options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first script is for interacting with the smart contract in the Rinkeby
    network. Name the script `play_with_smart_contract_in_rinkeby.py`. You can refer
    to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_rinkeby.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_rinkeby.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The second script is to interact with the smart contract in Ganache. Name the
    script `play_with_smart_contract_in_ganache.py`. You can refer to the code file
    on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_ganache.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_04/play_with_smart_contract_in_ganache.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll discuss the code line by line to understand the concept better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This part of the script is designed to get the `abi` and `bytecode` of the
    smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This script is for the Rinkeby network option. You get the `web3` connection
    object and the private key. Then, you initialize the smart contract object based
    on the `abi` and the address from the deploying smart contract script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This script is for the Ganache option. You get the `web3` connection object
    and set the private key. Then, you initialize the smart contract object based
    on the `abi` and the `address` from the deploying smart contract script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both (Ganache and Rinkeby) scripts, you set the value to `w3.eth.defaultAccount`.
    If you set the address to `w3.eth.defaultAccount`, this means that this address
    is the account that is going to broadcast transactions. It will also execute methods
    in a smart contract. If you remember what you did in Truffle console, you specified
    the account that will execute methods in a smart contract with the `from` parameter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t use the default account, you would need to specify the `from`
    field, too, when you build a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain the value from a public variable or public method that does not change
    the state of the smart contract, you use the contract object’s `functions` method,
    followed by the public variable and public method (both must be executed using
    `()`), followed by executing the `call` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember what to do with nonce, it is necessary to get the updated one.
    For a transaction that is going to change the state of the smart contract, instead
    of `call`, you use `buildTransaction`, which supplies parameters that you recognize
    already: `gas`, `gasPrice`, and `nonce`. If you don''t use `w3.eth.defaultAccount`,
    then you need to add another parameter here: `from`. If you want to send some
    ethers to the smart contract (for example, the `donate` method in Donation Smart
    Contract), you add another parameter as well: `value`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you notice, the `gas` and `gasPrice` parameters in the script for the Rinkeby
    network are much higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ganache, you can get away with 70,000 gas and a gas price set to `1 gwei`.
    In the Rinkeby network, however, you must be careful. To be safe, I bumped up
    the gas and the gas price when interacting with a smart contract in the Rinkeby
    network. If you fail to change the state of the smart contract in the Rinkeby
    network, sometimes it means you haven''t allocated sufficient gas and the gas
    price is not high enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You sign this transaction with your private key. However, in Ganache, you don''t
    have to do this. Instead, you could make a transaction directly without a private
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, for the Rinkeby network or the Ethereum production blockchain,
    you have to sign your transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you broadcast your transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ganache, the execution of the method will be very fast, but in Rinkeby,
    it could take a few minutes. In a proper decentralized application, you would
    handle this with asynchronous programming or threading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The last line is there to ensure that it has changed the `name` variable in
    the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to install a `web3` library. This is the library
    that is designed to connect to a smart contract. On top of that, you learned how
    to run an Ethereum node on the Rinkeby network. You configured `web3` to connect
    to the Ethereum blockchain on the Rinkeby network. You also learned how to tell
    `web3` to connect to an Ethereum testing network, such as Ganache. In addition,
    you created a script to send ethers from one account to another. Finally, you
    created a script to execute methods on a smart contract, either to read the value
    of public variables or to change the state of the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you are going to use a smart contract development framework
    called **Populus** that takes care of the manual work you've undertaken in relation
    to a smart contract, such as compiling the code and deploying it. In addition,
    the Populus framework offers an integrated way to test the smart contract.
  prefs: []
  type: TYPE_NORMAL
