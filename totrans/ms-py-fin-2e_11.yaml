- en: Building an Algorithmic Trading Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithmic trading automates the systematic trading process, where orders are
    executed at the best price possible based on a variety of factors, such as pricing,
    timing, and volume. Brokerage firms may offer an **Application Programming Interface**
    (**API**) as part of their service offering for customers who wish to deploy their
    own trading algorithms. An algorithmic trading system must be highly robust to
    handle any point of failure during the order execution. Network configuration,
    hardware, memory management, speed, and user experience are a number of factors
    to be considered when designing a system for executing orders. Designing larger
    systems inevitably adds more complexity to the framework.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as a position in a market is opened, it is subjected to various types
    of risk, such as market risk, interest rate risk, and liquidity risk. To preserve
    the trading capital as much as possible, it is important to incorporate risk management
    measures into the trading system. Perhaps the most common risk measure used in
    the financial industry is the **Value at Risk** (**VaR**) technique. We will discuss
    the beauty and flaws of VaR, and how it can be incorporated into our trading system
    that we will develop in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of algorithmic trading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of brokers and system vendors with a public API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a programming language for a trading system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an algorithmic trading platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up API access on the Oanda v20 Python module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a mean-reverting algorithmic trading strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a trend-following algorithmic trading strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing VaR for risk management in our trading system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing VaR calculations in Python on AAPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing algorithmic trading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the 1990s, exchanges had already begun to use electronic trading systems.
    By 1997, 44 exchanges worldwide used automated systems for trading futures and
    options with more exchanges in the process of developing automated technology.
    Exchanges such as the **Chicago Board of Trade** (**CBOT**) and the **London International
    Financial Futures and Options Exchange** (**LIFFE**) used their electronic trading
    systems as an after-hours complement to the traditional open outcry trading pits,
    thus giving traders 24-hour access to the exchange's risk management tools. With
    these improvements in technology, technology-based trading became less expensive,
    fueling the growth of trading platforms that are faster and more powerful. The
    higher reliability of order execution and the lower rate of message transmission
    error has deepened the reliance on technology by financial institutions. The majority
    of asset managers, proprietary traders, and market makers have since moved from
    the trading pits to electronic trading floors.
  prefs: []
  type: TYPE_NORMAL
- en: As systematic or computerized trading becomes more commonplace, speed is the
    most important factor in determining the outcome of a trade. Quants, by utilizing
    sophisticated fundamental models, are able to recompute fair values of trading
    products on the fly and execute trading decisions, enabling them to reap profits
    at the expense of those fundamental traders using traditional tools. This has
    given way to the term **high-frequency trading** (**HFT**), which relies on fast
    computers to execute the trading decisions before anyone else can. In fact, HFT
    has evolved into a billion-dollar industry.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmic trading refers to the automation of the systematic trading process,
    where the order execution is heavily optimized to give the best price possible.
    It is not part of the portfolio allocation process.
  prefs: []
  type: TYPE_NORMAL
- en: Banks, hedge funds, brokerage firms, clearing firms, and trading firms typically
    have their servers placed right next to the electronic exchange to receive the
    latest market prices and to perform the fastest order execution where possible.
    They bring enormous trading volumes to the exchange. Anyone who wishes to participate
    in low-latency, high-volume trading activities (such as complex event processing
    or capturing fleeting price discrepancies) by acquiring exchange connectivity
    may do so in the form of co-location, where their server hardware can be placed
    on a rack right next to the exchange for a fee.
  prefs: []
  type: TYPE_NORMAL
- en: The **Financial Information Exchange** (**FIX**) protocol is the industry standard
    for electronic communications with the exchange from the private server for **direct
    market access** (**DMA**) to real-time information. C++ is the common choice of
    programming language for trading over the FIX protocol, though other languages,
    such as .NET Framework Common Language and Java can also be used. The **Representational
    State Transfer**(**REST**) API offerings are becoming more common for retail investors.
    Before creating an algorithmic trading platform, you will need to assess various
    factors, such as the speed and ease of learning before deciding on a specific
    language for the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Brokerage firms will provide a trading platform of some sort for their customers
    in order for them to execute orders on selected exchanges in return for the commission
    fees. Some brokerage firms may offer an API as part of their service offering
    to technically-inclined customers who wish to run their own trading algorithms.
    In most circumstances, customers may also choose from a number of commercial trading
    platforms offered by third-party vendors. Some of these trading platforms may
    also offer API access to route orders electronically to the exchange. It is important
    to read the API documentation beforehand to understand the technical capabilities
    offered by your broker and to formulate an approach in developing an algorithmic
    trading system.
  prefs: []
  type: TYPE_NORMAL
- en: Trading platforms with a public API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table lists some brokers and trading platform vendors who have
    their API documentation publicly available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Broker/vendor** | **URL** | **Programming languages supported** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CQG | [https://www.cqg.com](https://www.cqg.com) | REST, FIX, C#, C++, and
    VB/VBA |'
  prefs: []
  type: TYPE_TB
- en: '| Cunningham Trading Systems | [http://www.ctsfutures.com](http://www.ctsfutures.com)
    | Microsoft .Net Framework 4.0 and FIX |'
  prefs: []
  type: TYPE_TB
- en: '| E*Trade | [https://developer.etrade.com/home](https://developer.etrade.com/home)
    | Python, Java, and Node.js |'
  prefs: []
  type: TYPE_TB
- en: '| Interactive Brokers | [https://www.interactivebrokers.com/en/index.php?f=5041](https://www.interactivebrokers.com/en/index.php?f=5041)
    | Java, C++, Python, C#, C++, and DDE |'
  prefs: []
  type: TYPE_TB
- en: '| IG | [https://labs.ig.com/](https://labs.ig.com/) | REST, Java, JavaScript,
    .NET, Clojure, and Node.js |'
  prefs: []
  type: TYPE_TB
- en: '| Tradier | [https://developer.tradier.com/](https://developer.tradier.com/)
    | REST |'
  prefs: []
  type: TYPE_TB
- en: '| Trading Technologies | [https://www.tradingtechnologies.com/trading/apis/](https://www.tradingtechnologies.com/trading/apis/)
    | REST, .NET, and FIX |'
  prefs: []
  type: TYPE_TB
- en: '| OANDA | [https://developer.oanda.com/](https://developer.oanda.com/) | REST,
    Java, and FIX |'
  prefs: []
  type: TYPE_TB
- en: '| FXCM | [https://www.fxcm.com/uk/algorithmic-trading/api-trading/](https://www.fxcm.com/uk/algorithmic-trading/api-trading/)
    | REST, Java, and FIX |'
  prefs: []
  type: TYPE_TB
- en: Choosing a programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With many options of programming languages available to interface with brokers
    or vendors, the question that comes naturally to anyone starting out in algorithmic
    trading platform development is *Which language should I use?*
  prefs: []
  type: TYPE_NORMAL
- en: Before answering this question, it is important to find out if your broker provides
    developer tools. RESTful APIs are becoming the most common offering alongside
    FIX protocol access. A small number of brokers support Java and C#. With RESTful
    APIs, it is easy to search for, or even write a wrapper around it in almost any
    programming language that supports the **HyperText Transfer Protocol** (**HTTP**).
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that each tool option presents its own limitations. Your broker
    may rate-limit price and event updates. How your product will be developed, the
    performance metrics to follow, the costs involved, latency threshold, risk measures,
    and the expected user interface are pieces of the puzzle to be taken into consideration.
    The risk manager, execution engine, and portfolio optimizer are some major components
    that will affect the design of your system. Your existing trading infrastructure,
    choice of operating system, programming language compiler capability, and available
    software tools pose further constraints on the system design, development, and
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: System functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to define the outcomes of your trading system. An outcome could
    be a research-based system concerned with obtaining high-quality data from data
    vendors, performing computations or running models, and evaluating a strategy
    through signal generation. Part of the research component might include a data-cleaning
    module or a backtesting interface to run a strategy with theoretical parameters
    over historical data. The CPU speed, memory size, and bandwidth are factors to
    be considered while designing our system.
  prefs: []
  type: TYPE_NORMAL
- en: Another outcome could be an execution-based system that is more concerned with
    risk management and order handling features to ensure the timely execution of
    multiple orders. The system must be highly robust in order to handle any point
    of failure during the order execution. As such, network configuration, hardware,
    memory management and speed, and user experience are some factors to be considered
    when designing a system that executes orders.
  prefs: []
  type: TYPE_NORMAL
- en: A system may contain one or more of these functionalities. Designing larger
    systems inevitably adds complexity to the framework. It is recommended that you
    choose one or more programming languages that can address and balance the development
    speed, ease of development, scalability, and reliability of your trading system.
  prefs: []
  type: TYPE_NORMAL
- en: Building an algorithmic trading platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will design and build a live algorithmic trading system
    in Python. Since developer tools and offerings vary with each broker, it is important
    to take into consideration the different programming implementation that is required
    in integrating with our very own trading system. With a good system design, we
    can build a generic service that allows configurations of different brokers to
    plug in and play together nicely with our trading system.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a broker interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing a trading platform, the following three functionalities are
    highly desirable to fulfill any given trading plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting prices**: Pricing data is the one of the most basic units of information
    available from an exchange. It represents the quotation prices that are made by
    the marketplace to buy or sell a traded product. A broker may redistribute data
    from the exchange to be delivered to you in its own format. The most basic form
    of price data available is the date and time of the quotes, the symbol of the
    traded product, and the quoted bidding and asking price of the traded product.
    More often than not, this pricing data is useful to base your trading decisions
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best quoted bidding and asking prices are known as the **Level 1** quote.
    In most cases, it is possible to request for Level 2, 3, or even additional quote
    levels from your broker.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending orders to the market**: When sending orders to the marketplace, it
    may or may not be executed by your broker or the exchange. If it does get executed,
    you will have opened a position in the traded product and subjected yourself to
    all forms of risk, as well as returns. The simplest form of order states the product
    to trade (usually denoted by a symbol), the quantity to trade, the position that
    you want to take (that is, whether you are buying or selling), and, for a non-market
    order, the price to trade at. Depending on your needs, there are many different
    types of orders available to help manage your trading risks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your broker may not support all order types. It is prudent to check with your
    broker which types of order are available and which can best manage your trading
    risks. The most common order type used by market participants are market orders,
    limit orders, and good-till-canceled orders. A **market order** is an order to
    buy or sell a product right away in the market. Because it is executed based on
    the current market prices, an execution price is not required for this type of
    order. A **limit order** is an order to buy or sell a product at a specific or
    better price. A **good-till-canceled** (**GTC**) order is an order that remains
    in the exchange queue for execution until the stated expiry time. Unless specified,
    most orders are GTC orders that expire at the end of the trading day. You can
    find more information of various order types at [https://www.investopedia.com/university/how-start-trading/how-start-trading-order-types.asp](https://www.investopedia.com/university/how-start-trading/how-start-trading-order-types.asp).
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracking positions:** As soon as your order is executed, you will enter into
    a position. Keeping track of your opened position will help determine how well
    (or badly!) your trading strategy is doing, as well as manage and plan your risks.
    Your gains and losses from opened positions vary according to market movements,
    and is known as **unrealized profits and losses**. After closing your position,
    you will have **realized profits and losses**, which are the final outcome of
    your trading strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these three basic functionalities in mind, we can design a generic `Broker`
    class implementing these functions that can be easily extended to any broker-specific
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Python library requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using the publicly-available v20 module with Oanda
    as our broker. All method implementations mentioned in this chapter uses the `v20`
    Python library as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Installing v20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official repository for OANDA v20 REST API is at [https://github.com/oanda/v20-python](https://github.com/oanda/v20-python).
    Install using pip with the terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Detailed documentation on the use of the OANDA v20 REST API can be found at
    [http://developer.oanda.com/rest-live-v20/introduction/](http://developer.oanda.com/rest-live-v20/introduction/).
    The use of APIs varies with each broker, so make sure that you consult with your
    broker for the appropriate documentation before writing your trading system implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an event-driven broker class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether we are fetching prices, sending orders, or tracking positions, an event-driven
    system design will trigger key parts of our system in a multi-threaded fashion
    without blocking the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin writing our `Broker` class in Python, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we can provide the `host` and `port` public connection configurations
    of our broker for the inheriting child classes. Three variables are declared for
    storing the event handlers of prices, orders, and position updates, respectively.
    Here, we are designing for only one listener for each event. A more complex trading
    system might support multiple listeners on the same event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the price event handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `Broker` class, add the following two methods as the getter and
    setter for the price event handler, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The inheriting child classes will notify the listeners through the `on_price_event`
    method invocation of the symbol, the bid price, and the ask price. Later on, we
    will use these pieces of basic information for our trading decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the order event handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following two methods as the getter and setter for the order event
    handler, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After an order is routed to your broker, the inheriting child classes will notify
    the listeners through the `on_order_event` method invocation, along with the order
    transaction ID.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the position event handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following two methods as the getter and setter for the position event
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When a position update event is received from your broker, the inheriting child
    classes will notify the listeners through the `on_position_event` method invocation
    containing the symbol information, a flag indicating a long or short position,
    the number of units traded, the unrealized profit and loss, and the realized profit
    and loss.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an abstract method for getting prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since fetching prices from a data source is a main requirement of any trading
    system, create an abstract method named `get_prices()` to perform such a function.
    It expects a `symbols` parameter to contain a list of broker-defined symbols,
    that will be used for querying data from our broker. The inheriting child classes
    are expected to implement this method, otherwise a `NotImplementedError` exception
    is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that this `get_prices()` method is expected to perform a one-time fetch
    of the current market prices. This gives us a snapshot of the market at a particular
    time. For a continuously-running trading system, we will require streaming market
    prices to feed our trading logic in real time, which we will define next.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an abstract method for streaming prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a `stream_prices()` abstract method that accepts a list of symbols in streaming
    prices using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The inheriting child classes are expected to implement this method in streaming
    prices from your broker, otherwise a `NotImplementedError` exception message will
    be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an abstract method for sending orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a `send_market_order()` abstract method for the inheriting child classes
    to implement when sending a market order to your broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding methods written in our `Broker` base class, we can now write
    broker-specific classes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the broker class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the abstract methods of the `Broker` class
    that are specific to our broker, Oanda. This requires the use of the `v20` library.
    However, you can easily change the configuration and any implemented methods that
    are specific to a broker of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the broker class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write the following `OandaBroker` class, which is specific to our broker, extending
    the generic `Broker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that Oanda uses two different hosts for regular API endpoints and a streaming
    API endpoint. These endpoints are different for their practice and live trading
    environments. All endpoints are connected on the standard **Secure Socket Layer**
    (**SSL**) port 440\. In the constructor, the `is_live` Boolean flag chooses the
    appropriate endpoints for the chosen trading environment for saving in the parent
    class. A `True` value for `is_live` indicates a live trading environment. The
    constructor argument also saves the account ID and token, which are required for
    authenticating the account used for trading. This information can be obtained
    from your broker.
  prefs: []
  type: TYPE_NORMAL
- en: The `api` and `stream_api` variables hold the `v20` library's `Context` objects
    that are used by calling methods to send instructions to your broker.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the method for getting prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following codes implement the parent `get_prices()` method in the `OandaBroker`
    class for getting prices from your broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the response contains a `prices` attribute and a list of objects.
    Each item in the list is processed by the `process_price()` method. Let''s implement
    this method in the `OandaBroker` class as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `price` object contains an `instrument` property of a string object, along
    with `list` objects in the `bids` and `asks` properties. Typically, Level 1 quotes
    are available, so we read the first item of the each list. Each item in the list
    is a `price_bucket` object, from which we extract the bid and ask price.
  prefs: []
  type: TYPE_NORMAL
- en: With this information extracted, we pass it to the `on_price_event()` event
    handler method. Note that, in this example, we are passing only three values.
    In more complex trading systems, you might want to consider extracting more detailed
    information, such as traded volume, last traded price, or multilevel quotes, and
    pass this to the price event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the method for streaming prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following `stream_prices()` method in the `OandaBroker` class to start
    streaming prices from your broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since the host connection expects a continuous stream, the `response` object
    has a `parts()` method that listens for incoming data. The `msg` object is essentially
    a `price` object, which we can reuse with the `process_price()` method to notify
    the listeners of an incoming price event.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the method for sending market orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following `send_market_order()` method in the `OandaBroker` class,
    which will send a market order to your broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When the `market()` method of the v20 `order` library is called, the status
    of the response is expected to be `201` to indicate a successful connection to
    the broker. A further check on the response body is recommended for signs of error
    in the execution of our orders. In the case of a successful execution, the transaction
    ID and the details of the order are passed along to the listeners by calling the
    `on_order_event()` event handler. Otherwise, the order event is triggered with
    an empty transaction ID along with a `NOT_FILLED` status, indicating that the
    order is incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the method for fetching positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following `get_positions()` method in the `OandaBroker` class, which
    will fetch all the available position information for a given account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the response body, the `position` property contains a list of `position`
    objects, each having attributes for the contract symbol, the unrealized and realized
    gains or losses, and the number of long and short positions. This information
    is passed along to the listeners through the `on_position_event()` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the methods of `broker` now defined, we can test the connection that is
    set up between our broker by reading the current market prices. The `Broker` class
    may be instantiated using the following Python codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Replace the two constant variables, `ACCOUNT_ID` and `API_TOKEN`, with your
    own credentials given by your broker, which identifies your own trading account.
    The `broker` variable is an instance of `OandaBroker`, which we can use to perform
    various broker-specific calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we are interested in finding out the current market price of the
    EUR/USD currency pair. Let''s define a constant variable to hold the symbol of
    this instrument that is recognized by our broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define a price event listener coming from our broker, using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `on_price_event()` function is defined as the listener for incoming price
    information and is assigned to the `broker.on_price_event` event handler. We expect
    three values from a pricing event – the contract symbol, the bid price, and the
    ask price – which we simply print to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_prices()` method is called to fetch the current market price from
    our broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get a similar output on the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The output is a single line showing the bid and ask price of the EUR/USD currency
    pair as `1.14361` and `1.14374`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a simple market order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that we use for fetching prices, we can reuse the `broker` variable
    to send a market order to our broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose that we are interested in buying one unit of the same EUR/USD currency
    pair; the following code performs this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `on_order_event()` function is defined as the listener for incoming order
    updates from our broker and is assigned to the `broker.on_order_event` event handler.
    For example, a limit order that is executed, or an order that is canceled, will
    be called on by this method. Finally, the `send_market_order()` method indicates
    that we are interested in buying one unit of the EUR/USD currency pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the currency markets are open when you run the preceding codes, you should
    get the following result with a different transaction ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the order is successfully filled to buy one unit of the
    EUR/USD currency pair with a transaction ID of `754`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting position updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a long position opened by sending a market order to buy, we should be
    able to view our current EUR/USD position. We can do so on the `broker` object
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `on_position_event()` function is defined as the listener for incoming
    position updates from our broker and is assigned to the `broke.on_position_event`
    event handler. When the `get_positions()` method is called, the broker returns
    the position information and triggers the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our position statement is currently one long unit of the EUR/USD currency pair,
    with an unrealized loss of $0.0001\. Since this is our first trade, we have not
    realized any profits or losses yet.
  prefs: []
  type: TYPE_NORMAL
- en: Building a mean-reverting algorithmic trading system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our broker now accepting orders and responding to our requests, we can
    begin to design a fully-automated trading system. In this section, we will explore
    how to design and implement a mean-reverting algorithmic trading system.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the mean-reversion algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we believe that in normal market conditions, prices fluctuate, but tend
    to revert back to some short-term level, such as the average of the most recent
    prices. In this example, we assume that the EUR/USD currency pair is exhibiting
    a mean-reversion property in the near short-term period. First, we resample the
    raw tick-level data into standard time series intervals, for example, at one-minute
    intervals. Then, taking a number of the most recent periods for calculating the
    short-term average price (for example, with five periods), we are saying that
    we believe the EUR/USD prices will revert toward the average of the prior five
    minutes' prices.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the bidding price of the EUR/USD currency pair exceeds the short-term
    average price, with five minutes as our example, our trading system shall generate
    a sell signal, and we can choose to enter into a short position with a sell market
    order. Likewise, when the asking price of EUR/USD falls below the average price,
    a buy signal is generated and we can choose to enter into a long position with
    a buy market order.
  prefs: []
  type: TYPE_NORMAL
- en: The moment that a position is opened, we may use the same signals to close out
    our position. When a long position is opened, we close our position on a sell
    signal by entering an order to sell at the market. Likewise, when a short position
    is opened, we close our position on a buy signal by entering an order to buy at
    the market.
  prefs: []
  type: TYPE_NORMAL
- en: You might observe that there are plenty of flaws in our trading strategy. Closing
    out our position does not guarantee a profit. Our belief of the market can be
    wrong; in adverse market conditions, a signal might remain in one direction for
    some time and there is a high probability of closing out our position at a huge
    loss! As a trader, you should figure out a personal trading strategy that suits
    your beliefs and risk appetite.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the mean-reversion trader class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The resample interval and the number of periods in our calculation are two
    important parameters that are required by our trading system. First, create a
    class named `MeanReversionTrader`, which we can instantiate and run as our trading
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The five parameters in our constructor initialize the state of our trading system
    – the broker used, the symbol to trade, the number of units to trade, the resampling
    interval of our price data, and the number of periods for our mean calculation.
    These values are simply stored as class variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `setup_broker()` method call sets up our class to handle events from our
    `broker` object, which we will define shortly. As we receive price data, these
    are stored in a `pandas` DataFrame variable, `df_prices`. The latest bid and ask
    prices are stored in the `bid_price` and `ask_price` variables for calculating
    signals. The `mean` variable will store the calculated mean of the prior number
    of `mean_period` prices. The `position` variable will store the number of units
    of our current position. A negative value indicates a short position, and a positive
    value indicates a long position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `is_order_pending` Boolean flag indicates whether an order is pending execution
    by our broker, and the `is_next_signal_cycle` Boolean flag indicates whether the
    current trading state cycle is open. Note that our system states can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a buy or sell signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place an order on a buy or sell signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a position is opened, wait for a sell or buy signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place an order on a sell or buy signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the position is closed, go to step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For every cycle of steps from 1 to 5, we will only trade one unit. These Boolean
    flags act as a lock to prevent multiple orders from entering into the system at
    any one time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's hook up the price, order, and position events in our `MeanReversionTrader`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `setup_broker()` method into this class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are simply assigning three class methods as listeners on any broker-generated
    event to listen to price, order, and position updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `on_price_event()` method into this class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When a price event is received, we store them in our `bid_price`, `ask_price`,
    and `df_prices` class variables. As the price changes, so do our open positions
    and signal values. The `get_position()` method call retrieves up-to-date information
    on our positions, and the `generate_signals_and_think()` call recalculates our
    signals and decides whether to make the trade. The current state of the system
    is printed to the console using the `print_state()` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the `get_position()` method to retrieve the position information from
    our broker, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `on_order_event()` method into our class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When an order event is received, we print them out to the console. In our broker's
    `on_order_event` implementation, an order that is executed successfully will pass
    either a `status` value of `FILLED` or `UNFILLED`. Only on a successful order
    can we turn off our Boolean locks, retrieve our latest position, and perform decision-making
    for closing out our position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `on_position_event()` method into our class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When a position update event is received for our intended trade symbol, we store
    our position information, the realized gains, and unrealized gains. The current
    state of the system is printed to the console using the `print_state()` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `print_state()` method into our class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As soon as there are any updates to our orders, positions, or market prices,
    we print the latest state of our system to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the mean-reversion signal generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want our decision-making algorithm to recalculate trading signals on every
    price or order update. Let''s create a `generate_signals_and_think()` method inside
    the `MeanReversionTrader` class to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since price data are stored in the `df_prices` variable as a pandas DataFrame,
    we can resample them at regular intervals, as defined by the `resample_interval` variable
    given in the constructor. The `ffill()` method forward-fills any missing data
    and the `dropna()` command removes the first missing value after resampling. There
    must be sufficient data available for calculating the mean, otherwise this method
    simply exits. The `mean_periods` variable represents the minimum length of resampled
    data that must be available.
  prefs: []
  type: TYPE_NORMAL
- en: The `tail(self.mean_periods)` method takes the most recent resampled intervals
    and calculates the average using the `mean()` method, resulting in another pandas
    DataFrame. The mean level is taken by index referencing the column of the DataFrame,
    which is simply the instrument symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Using the average price available for the mean-reversion algorithm, we can generate
    the buy and sell signals. Here, a buy signal is generated when the average price
    exceeds the market asking price, and a sell signal is generated when the average
    price exceeds the market bidding price. Our short-term belief is that market prices
    will revert to the average price.
  prefs: []
  type: TYPE_NORMAL
- en: 'After printing these calculated values to the console for better debugging,
    we can now make use of the buy and sell signals to perform actual trades in a
    separate method named `think()` inside the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If an order is still in pending state by a broker, we simply do nothing and
    exit the method. Since market conditions may change at any time, you might want
    to add your own logic to handle orders that have stayed in the pending state for
    too long and try another strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three if-else statements handles the trading logic when our position is
    flat, long, or short, respectively. When our position is flat, the `think_when_position_flat()`
    method is called, written as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first `if` statement handles the condition that, upon a buy signal and when
    the current trading cycle is open, we enter into a long position by sending a
    market order to buy and mark that order as pending. Conversely, the second `if`
    statement handles the condition to enter into a short position upon a sell signal.
    Otherwise, since the position is flat with neither a buy nor sell signal, we simply
    set the `is_next_signal_cycle` to `True` until a signal becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are in a long position, the `think_when_position_long()` method is
    called, written as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: On a sell signal, we mark the order as pending and close out our long position
    immediately by sending a market order to sell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when we are in a short position, the `think_when_position_short()`
    method is called, written as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: On a buy signal, we mark the order as pending and close out our short position
    immediately by sending a market order to buy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the order routing functionality, add the following `send_market_order()`class
    method to our `MeanReversionTrader` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The order information is simply forwarded to our `Broker` class for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Running our trading system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, to start running our trading system, we need an entry point. Add the
    following `run()` class method to the `MeanReversionTrader` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: During the first run of our trading system, we read our current positions and
    use the information to initialize all position-related information. Then, we request
    our broker to start streaming prices for the given symbol and hold the connection
    until the program is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an entry point defined, all we need to do is initialize our `MeanReversionTrader`
    class and call the `run()` command using the following codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `broker` variable contains an instance of the `OandaBroker`
    class as defined from the previous *Getting prices* section, and we can reuse
    it for this class. Our trading system will use this broker object to perform broker-related
    calls. We are interested in the EUR/USD currency pair, trading one unit at each
    time. The `resample_interval` variable with a value of `60s` states that our stored
    prices are to be resampled at one-minute intervals. The `mean_periods` variable
    with a value of `5` states that we will take the average of the most recent five
    intervals, or the average price of the past five minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start our trading system, make the call to `run()`; pricing updates will
    start trickling in, enabling our system to trade on its own. You should see an
    output on the console that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: From the output, it looks as though our position is currently flat, and there
    is insufficient pricing data for calculating our trading signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'After five minutes, when there is sufficient data for a trading signal calculation,
    we should be able to observe the following outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The average price of the past five minutes is `1.13934`. Since the current market
    bidding price for EUR/USD is `1.13936`, more than the average price, a sell signal
    is generated. A sell market order is generated to open a short position in EUR/USD
    of one unit. This leads to an unrealized loss of $0.0001.
  prefs: []
  type: TYPE_NORMAL
- en: Let the system run on its own for a while, and it should be able to close out
    the positions on its own. To stop trading, terminate the running process using
    *Ctrl* + *Z* or something similar. Remember to manually close out any remaining
    trading positions once the program stops running. You now have a fully functional
    and automated trading system!
  prefs: []
  type: TYPE_NORMAL
- en: The system design and trading parameters here are stated as an example and don't
    necessarily lead to positive outcomes! You should experiment with various trading
    parameters and improve the handling of events to figure out the optimal strategy
    for your trading plan.
  prefs: []
  type: TYPE_NORMAL
- en: Building a trend-following trading platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we followed the steps for building a mean-reverting
    trading platform. The same functionality can be easily extended to incorporate
    any other trading strategies. In this section, we will take a look at reusing
    the `MeanReversionTrader` class to implement a trend-following trading system.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the trend-following algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that this time, we believe that the current market conditions exhibit
    a trend-following pattern, perhaps due to seasonal changes, economic projections,
    or government policy. As prices fluctuate, and as the short-term average price
    level crosses the average long-term price level by a certain threshold, we generate
    a buy or sell signal.
  prefs: []
  type: TYPE_NORMAL
- en: First, we resample raw tick-level data into standard time series intervals,
    for example, at one-minute intervals. Second, taking a number of the most recent
    periods, for example, with five periods, we calculate the short-term average price
    for the past five minutes. Finally, taking a larger number of the most recent
    periods, for example, with ten periods, we calculate the long-term average price
    for the past ten minutes.
  prefs: []
  type: TYPE_NORMAL
- en: In a market with no movement, the average short-term price should be the same
    as the average long-term price with a ratio of one – this ratio is also known
    as the beta. When the average short-term price increases more than the average
    long-term price, the beta is more than one and the market can be viewed as on
    an uptrend. When the short-term price decreases more than the average long-term
    price, the beta is less than one and the market can be viewed as on a downtrend.
  prefs: []
  type: TYPE_NORMAL
- en: On an uptrend, as soon as the beta crosses above a certain price threshold level,
    our trading system shall generate a buy signal, and we can choose to enter into
    a long position with a buy market order. Likewise, on a downtrend, when the beta
    falls below a certain price threshold level, a sell signal is generated and we
    can choose to enter into a short position with a sell market order.
  prefs: []
  type: TYPE_NORMAL
- en: The moment that a position is opened, the same signals may be used to close
    out our position. When a long position is opened, we close our position on a sell
    signal by entering an order to sell at the market. Likewise, when a short position
    is opened, we close out our position on a buy signal by entering an order to buy
    at the market.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics mentioned are very similar to those of the mean-reversion trading
    system design. Bear in mind that this algorithm does not guarantee any profits,
    and is just a simplistic belief of the markets. You should have a different (and
    better) view than this.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the trend-following trader class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a class for our trend-following trading system with a new class
    named `TrendFollowingTreader`, which simply extends the `MeanReversionTrader`
    class using the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In our constructor, we define three additional keyword arguments, `long_mean_periods`,
    `buy_threshold`, and `sell_threshold`, saved as class variables. The `long_mean_periods` variable
    defines the number of resample intervals of our time series prices to take into
    account for calculating the long-term average price. Note that the existing `mean_periods` variable
    in the parent constructor is used for calculating the short-term average price.
    The `buy_threshold` and `sell_threshold` variables contain values that determine
    the boundaries of beta in generating a buy or sell signal.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the trend-following signal generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because only the decision-making logic needs to be modified from our parent
    `MeanReversionTrader` class, and everything else, including orders, placement,
    and streaming prices, remains the same, we simply override the `generate_signals_and_think()`
    method and implement our new trend-following signal generators using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As before, on every invocation of the `generate_signals_and_think()` method,
    we resample prices at fixed intervals, defined by `resample_interval`. The minimum
    intervals required for the calculation of signals is now defined by `long_mean_periods`
    instead of `mean_periods`. The `mean_short` variable refers to the short-term
    average resampled price, and the `mean_long` variable refers to the long-term
    average resampled price.
  prefs: []
  type: TYPE_NORMAL
- en: The `beta` variable is the ratio of the short-term average price to the long-term
    average price. When the beta rises above the `buy_threshold` value, a buy signal
    is generated and the `is_signal_buy` variable is `True`. Likewise, when the beta
    falls below the `sell_threshold` value, a sell signal is generated and the `is_signal_sell` variable
    is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The trading parameters are printed to the console for debugging purposes, and
    the call to the parent `think()` class method triggers the usual logic of buying
    and selling with market orders.
  prefs: []
  type: TYPE_NORMAL
- en: Running the trend-following trading system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our trend-following trading system by instantiating the `TrendFollowingTrader`
    class and running it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `broker`, is the same object created for our broker in
    the previous section. Again, we are resampling our time series prices at one-minute
    intervals, and we are interested in trading the EUR/USD currency pair, entering
    into a position of at most one unit at any given time. With a `mean_periods` value
    of `5`, we are interested in taking the most recent five resampled intervals in
    calculating the average price of the past five minutes as our short-term average
    price. With a `long_mean_period` of `10`, we are interested in taking the most
    recent 10 resampled intervals in calculating the average price of the past 10 minutes
    as our long-term average price.
  prefs: []
  type: TYPE_NORMAL
- en: The ratio of the short-term average price to the long-term average price is
    taken as the beta. When the beta rises above the value defined by `buy_threshold`,
    a buy signal is generated. When the beta falls below the value defined by `sell_threshold`,
    a sell signal is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our trading parameters set up, the `run()` method is called to start the
    trading system. We should see an output on the console that is similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: At the start of trading, we obtained the current market prices, staying in a
    flat position with neither profits nor losses. There is insufficient data available
    to make any trading decisions, and we will have to wait 10 minutes before we can
    see the calculated parameters take effect.
  prefs: []
  type: TYPE_NORMAL
- en: If your trading system depends on a longer period of past data and you do not
    wish to wait for all this data to be collected, consider bootstrapping your trading
    system with historical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a while, you should see an output that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Let the system run on its own for awhile, and it should be able to close out
    positions on its own. To stop trading, terminate the running process with *Ctrl*
    + *Z*, or something similar. Remember to manually close out any remaining trading
    positions once the program stops running. Take steps to change your trading parameters
    and decision logic to make your trading system a profitable one!
  prefs: []
  type: TYPE_NORMAL
- en: Note that the author is not responsible for any outcomes of your trading system!
    In a live trading environment, it takes more control parameters, order management,
    and position tracking to manage your risk effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss a risk management strategy that we can
    apply to our trading plans.
  prefs: []
  type: TYPE_NORMAL
- en: VaR for risk management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As soon as we open a position in the market, we are exposed to various types
    of risks, such as volatility risk and credit risk. To preserve our trading capital
    as much as possible, it is important to incorporate some form of risk management
    measures to our trading system.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most common measure of risk used in the financial industry is the
    VaR technique. It is designed to simply answer the following question: *What is
    the worst expected amount of loss, given a specific probability level, say 95%,
    over a certain period of time?* The beauty of VaR is that it can be applied to
    multiple levels, from position-specific micro-level to portfolio-based macro-level.
    For example, a VaR of $1 million with a 95% confidence level for a 1-day time
    horizon states that, on average, only 1 day out of 20 could you expect to lose
    more than $1 million due to market movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a normally distributed portfolio returns
    with a mean of 0%, where VaR is the loss corresponding to the 95th percentile
    of the distribution of portfolio returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/467de0d4-9a4e-4bb6-9de3-575a4c3515a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose that we have $100 million under management at a fund claiming to have
    the same risk as an S&P 500 index fund, with an expected return of 9% and a standard
    deviation of 20%. To calculate the daily VaR at the 5% risk level or 95% confidence
    level using the variance-covariance method, we will use the following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/aa4ac48a-9c35-4eb0-a1a2-9c96d4ad6015.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/170e85cd-3453-44fd-ae6a-9f3c5eeb9f53.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/d9180d47-0c28-42d6-82d3-2079ac546b80.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *P* is the value of the portfolio, and *N^(−1)(α,u,σ)* is the inverse
    normal probability distribution with a risk level of *α*, a mean of *u*, a and
    standard deviation of *σ*. The number of trading days per year is assumed to be
    252\. It turns out that the daily VaR at the 5% level is $2,036,606.50.
  prefs: []
  type: TYPE_NORMAL
- en: However, the use of VaR is not without its flaws. It does not take into account
    the probability of the loss for extreme events happening on the far ends of the
    tails on the normal distribution curve. The magnitude of the loss beyond a certain
    VaR level is difficult to estimate as well. The VaR that we investigated uses
    historical data and an assumed constant volatility level – such measures are not
    indicative of our future performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a practical approach to calculate the daily VaR of stock prices;
    we will investigate the AAPL stock prices by downloading from a data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The dataset will be downloaded to the `df` variable as a pandas DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Our DataFrame contains eight columns, with prices starting from the year 1998
    to the present trading day. The column of interest is the adjusted closing prices.
    Suppose that we are interested in calculating the daily VaR of 2017; let''s obtain
    this dataset using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `prices` variable contains our AAPL dataset for 2017.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the formulas discussed earlier, you can implement the `calculate_daily_var()`
    function using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that we are holding $100 million of AAPL stock, and we are interested
    in finding the daily VaR at the 95% confidence level. We can define the VaR parameters
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `mu` and `sigma` variables represent the daily mean percentage returns and
    the daily standard deviation of returns respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can obtain the VaR by calling the `calculate_daily_var()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Assuming 252 trading days per year, the daily VaR of 2017 for the stock AAPL
    with 95% confidence is $114,248.72.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to the evolution of trading from the pits
    to the electronic trading platform, and learned how algorithmic trading came about.
    We looked at some brokers offering API access to their trading service offering.
    To help us get started on our journey of developing an algorithmic trading system,
    we used the Oanda `v20` library to implement a mean-reversion trading system.
  prefs: []
  type: TYPE_NORMAL
- en: In designing an event-driven broker interface class, we defined event handlers
    for listening to orders, prices, and position updates. Child classes inheriting
    the `Broker` class simply extend this interface class with broker-specific functions,
    while still keeping the underlying trading functions compatible with our trading
    system. We successfully tested the connection with our broker by getting market
    prices, sending a market order, and receiving position updates.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the design of a simple mean-reversion trading system that generates
    buy or sell signals based the movements of historical average prices, and opening
    and closing out our positions with market orders. Since this trading system uses
    only one source of trading logic, more work will be required to build a robust,
    reliable, and profitable trading system.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the design of a trend-following trading system that generates
    buy or sell signals based on the movements of a short-term average price against
    a long-term average price. With a well-designed system, we saw how easy it was
    to make a modification to the existing trading logic by simply extending the mean-reversion
    parent class and overriding the decision-making method.
  prefs: []
  type: TYPE_NORMAL
- en: One critical aspect of trading is to manage risk effectively. In the financial
    industry, VaR is the most common technique used to measure risk. Using Python,
    we took a practical approach to calculate the daily VaR of past datasets on AAPL.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have built a working algorithmic trading system, we can explore the
    other ways to measure the performance of our trading strategy. One of these areas
    is backtesting; we will discuss this topic in the next chapter.
  prefs: []
  type: TYPE_NORMAL
