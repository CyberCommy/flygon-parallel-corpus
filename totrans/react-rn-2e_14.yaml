- en: Building Responsive Layouts with Flexbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll get a feel for what it's like to lay out components
    on the screen of mobile devices. Thankfully, React Native polyfills many CSS properties
    that you might have used in the past to implement page layouts in web applications.
    You'll learn how to use the flexbox model to layout our React Native screens.
  prefs: []
  type: TYPE_NORMAL
- en: Before you dive into implementing layouts, you'll get a brief primer on flexbox
    and using CSS style properties in React Native apps—it's not quite what you're
    used to with regular CSS stylesheets. Then, you'll implement several React Native
    layouts using flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox is the new layout standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the flexible box layout model was introduced to CSS, the various approaches
    used to build layouts felt hacky and were prone to errors. Flexbox fixes this
    by abstracting many of the properties that you would normally have to provide
    in order to make the layout work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, the flexbox is exactly what it sounds like—a box model that''s
    flexible. That''s the beauty of flexbox—its simplicity. You have a box that acts
    as a container, and you have child elements within that box. Both the container
    and the child elements are flexible in how they''re rendered on the screen, as
    illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b21c0689-a915-41fe-b299-69805fde62e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Flexbox containers have a direction, either column (up/down) or row (left/right).
    This actually confused me when I was first learning flexbox: my brain refused
    to believe that rows move from left to right. Rows stack on top of one another!
    The key thing to remember is that it''s the direction that the box flexes, not
    the direction that boxes are placed on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more in-depth treatment of flexbox concepts, check out this page: [https://css-tricks.com/snippets/css/a-guide-to-flexbox/](https://css-tricks.com/snippets/css/a-guide-to-flexbox/).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React Native styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to implement your first React Native app, beyond the boilerplate
    that''s generated by `create-react-native-app`. I want to make sure that you feel
    comfortable using React Native stylesheets before you start implementing flexbox
    layouts in the next section. Here''s what a React Native stylesheet looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a JavaScript module, not a CSS module. If you want to declare React
    Native styles, you need to use plain objects. Then, you call `StyleSheet.create()`
    and export this from the style module.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this stylesheet has three styles: `container`, `box`, and `boxText`.
    Within the container style, there''s a call to `Platform.select()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function will return different styles based on the platform of the mobile
    device. Here, you're handling the top padding of the top-level container view.
    You'll probably use this code in most of your apps to make sure that your React
    components don't render underneath the status bar of the device. Depending on
    the platform, the padding will require different values. If it's iOS, `paddingTop`
    is `20`. If it's Android, `paddingTop` will be the value of `StatusBar.currentHeight`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `Platform.select()` code is an example of a case where you need
    to implement a workaround for differences in the platform. For example, if `StatusBar.currentHeight`
    were available on iOS and Android, you wouldn't need to call `Platform.select()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how these styles are imported and applied to React Native components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The styles are assigned to each component via the `style` property. You''re
    trying to render a box with some text in the middle of the screen. Let''s make
    sure that this looks as we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3f0c5355-7581-40c7-8bd7-016d6b588d90.png)'
  prefs: []
  type: TYPE_IMG
- en: Perfect! Now that you have an idea of how to set styles on React Native elements,
    it's time to start creating some screen layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Building flexbox layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn about several potential layouts that you can use
    in your React Native applications. I want to stay away from the idea that one
    layout is better than others. Instead, I'll show you how powerful the flexbox
    layout model is for mobile screens so that you can design the layout that best
    suits your application.
  prefs: []
  type: TYPE_NORMAL
- en: Simple three column layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start things off, let''s implement a simple layout with three sections that
    flex in the direction of the column (top to bottom). Let''s start by taking a
    look at the resulting screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cfc50f9a-7cda-4907-813c-a7ee6061392b.png)'
  prefs: []
  type: TYPE_IMG
- en: The idea with this example is that you've styled and labeled the three screen
    sections so that they stand out. In other words, these components wouldn't necessarily
    have any styling in a real application since they're used to arrange other components
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the components used to create this screen layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The container view (the outermost `<View>` component) is the column and the
    child views are the rows. The `<Text>` component is used to label each row. In
    terms of HTML elements, `<View>` is similar to a `<div>` while `<Text>` is similar
    to a `<p>`.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe this example could have been called *three row layout*, since it has three
    rows. But, at the same time, the three layout sections are flexing in the direction
    of the column that they're in. Use the naming convention that makes the most conceptual
    sense to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the styles used to create this layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `flex` and `flexDirection` properties of `container` enable the layout of
    the rows to flow from top to bottom. The `alignItems` and `justifyContent` properties
    align the child elements to the center of the container and add space around them,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this layout looks when you rotate the device from a portrait
    orientation to a landscape orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/84f1fc09-2559-449a-adda-0ca301c252fa.png)'
  prefs: []
  type: TYPE_IMG
- en: The flexbox automatically figured out how to preserve the layout for you. However,
    you can improve on this a little bit. For example, the landscape orientation has
    a lot of wasted space to the left and right now. You could create your own abstraction
    for the boxes that you're rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Improved three column layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few things that I think you can improve upon from the last example.
    Let''s fix the styles so that the children of the flexbox stretch to take advantage
    of the available space. Remember in the last example, when you rotated the device
    from portrait to landscape orientation? There was a lot of wasted space. It would
    be nice to have the components automatically adjust themselves. Here''s what the
    new styles module looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The key change here is the `alignSelf` property. This tells elements with the
    `box` style to change their width or height (depending on the `flexDirection`
    of their container) to fill space. Also, the `box` style no longer defines a `width`
    property because this will be computed on the fly now. Here''s what the sections
    look like in portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b6823803-9c64-4f2a-a7a1-aaa4d3d62f35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now each section takes the full width of the screen, which is exactly what
    you want to happen. The issue of wasted space was actually more prevalent in landscape
    orientation, so let''s rotate the device and see what happens to these sections
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/09165861-0bf5-4c97-8afe-d797fba4d9e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now your layout is utilizing the entire width of the screen, regardless of
    orientation. Lastly, let''s implement a proper `Box` component that can be used
    by `App.js` instead of having repetitive style properties in place. Here''s what
    the `Box` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You now have the beginnings of a nice layout. Next, you'll learn about flexing
    in the other direction—left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you''ll learn how to make screen layout sections stretch from
    top to bottom. To do this, you need a flexible row. Here are what the styles for
    this screen look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `App` component, using the same `Box` component that you implemented
    in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the resulting screen looks like in portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f56cfffc-2dad-426c-8f05-f7c053f4acf0.png)'
  prefs: []
  type: TYPE_IMG
- en: The two columns stretch all the way from the top of the screen to the bottom
    of the screen because of the `alignSelf` property, which doesn't actually say
    which direction to stretch in. The two `Box` components stretch from top to bottom
    because they're displayed in a flex row. Note how the spacing between these two
    sections goes from left to right? This is because of the container's `flexDirection`
    property, which has a value of `row`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how this flex direction impacts the layout when the screen is
    rotated into a landscape orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/30184fb5-cf9d-4b9d-bc98-cd5a0a89c051.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the flexbox has a `justifyContent` style property value of `space-around`,
    space is proportionally added to the left, the right, and in-between the sections.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need a screen layout that flows like a grid. For example, what
    if you have several sections that are the same width and height, but you're not
    sure how many of these sections will be rendered? The flexbox makes it easy to
    build a row that flows from left to right until the end of the screen is reached.
    Then, it automatically continues rendering elements from left to right on the
    next row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example layout in portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1d539b72-e514-486e-aaa9-def0393fd2fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The beauty of this approach is that you don''t need to know in advance how
    many columns are in a given row. The dimensions of each child determine what will
    fit in a given row. Let''s take a look at the styles used to create this layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `App` component that renders each section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s make sure that the landscape orientation works with this layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6cb2d557-480d-462f-a4f9-928a1420ea5b.png)You might have noticed
    that there''s some superfluous space on the right side. Remember, these sections
    are only visible in this book because we want them to be visible. In a real app,
    they''re just grouping other React Native components. However, if the space to
    the right of the screen becomes an issue, play around with the margin and the
    width of the child components.'
  prefs: []
  type: TYPE_NORMAL
- en: Flexible rows and columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this final section of the chapter, you''ll learn how to combine rows and
    columns to create a sophisticated layout for your app. For example, sometimes
    you need the ability to nest columns within rows or rows within columns. Let''s
    take a look at the `App` component of an application that nests columns within
    rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve created abstractions for the layout pieces (`<Row>` and `<Column>`)
    and the content piece (`<Box>`). Let''s see what this screen looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6c90900f-bf41-4d07-b50a-802aaf13428c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This layout probably looks familiar, because you''ve done it already in this
    chapter. The key difference is in how these content sections are ordered. For
    example, #2 doesn''t go to the left of #1, it goes below it. This is because we''ve
    placed #1 and #2 in a `<Column>`. The same with #3 and #4. These two columns are
    placed in a row. Then the next row begins, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is just one of many possible layouts that you can achieve by nesting row
    flexboxes and column flexboxes. Let''s take a look at the `Row` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This component applies the `row` style to the `<View>` component. The end result
    is cleaner JSX markup in the `App` component when creating a complex layout. Finally,
    let''s look at the `Column` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This looks just like the `Row` component, only with a different style applied
    to it. It also serves the same purpose as `Row` - to enable simpler JSX markup
    for layouts in other components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to styles in React Native. Though you can use many
    of the same CSS style properties that you're used to, the CSS stylesheets used
    in web applications look very different. Namely, they're composed of plain JavaScript
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned how to work with the main React Native layout mechanism—the
    flexbox. This is the preferred way to layout most web applications these days,
    so it makes sense to be able to reuse this approach in a native app. You created
    several different layouts, and you saw how they looked in portrait and in landscape
    orientation.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you'll start implementing navigation for your app.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between CSS styles and styles used with React Native components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React Native shares many style properties with CSS. Style properties are expressed
    as plain object properties in React Native
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no difference—you style React Native components just like any other
    React component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are completely different—React Native doesn't share any style properties
    from CSS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do you need to consider the status bar when designing your layout?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don't need to consider the status bar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the status bar can interfere with your components on iOS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the status bar can interfere with your components on Android
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the flexbox model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's the model that's used to control how View components flex to occupy horizontal
    space in a layout
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides flexible columns that respond to screen orientation changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The flexbox layout model is used to lay out components in a way that abstracts
    away many small details and automatically flexes in response to layout changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is screen orientation a factor when considering your layout options?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, you always need to make sure there are no surprises in portrait or landscape
    orientation during development
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, the orientation details are handled for you so that you can focus on application
    functionality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/flexbox](https://facebook.github.io/react-native/docs/flexbox)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/statusbar](https://facebook.github.io/react-native/docs/statusbar)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/stylesheet](https://facebook.github.io/react-native/docs/stylesheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
