- en: Graph Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a class of computational problems that can be best represented in terms
    of graphs. Such problems can be solved using a class of algorithms called **graph
    algorithms**. For example, graph algorithms can be used to efficiently search
    a value in a graphical representation of data. To work efficiently, these algorithms
    will first need to  discover the structure of the graph. They also need to find
    the right strategy for following the edges of the graph to read the data stored
    in the vertices. As graph algorithms need to search values in order to work, efficient
    searching strategies lie at the center of designing efficient graph algorithms.
    Using graph algorithms is one of the most efficient ways of searching for information
    in complex, interconnected data structures that are linked through meaningful
    relationships. In today's era of big data, social media, and distributed data,
    such techniques are becoming increasingly important and useful.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by presenting the basic concepts behind graph
    algorithms. Then, we will present the basics of network analysis theory. Next,
    we will look at the various techniques that can be used to traverse graphs. Finally,
    we will look at a case study showing how graph algorithms can be used for fraud
    detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Different ways of representing graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing network theory analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding graph traversals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case study: fraud analytics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for establishing a neighborhood in our problem space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of what graphs
    are and how to work with them to represent interconnected data structures and
    mine information from entities that are related by direct or indirect relationships,
    as well as use them to solve some complex real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: Representations of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A graph is a structure that represents data in terms of vertices and edges.
    A graph is represented as `aGraph` = (ùì•,  ùìî), where ùì•  represents a set of vertices
    and ùìî  represents a set of edges. Note that `aGraph` has |ùì•| vertices and |ùìî|
    edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'A vertex, ùìã ‚àà ùì•, represents a real-world object, such as a person, a computer,
    or an activity. An edge, ùìã ‚àà ùìî, connects two vertices in a network:'
  prefs: []
  type: TYPE_NORMAL
- en: e(ùìã[1],  ùìã[2])  |  e  ‚àà  ùìî  &  ùìã[i]  ‚àà  ùì•
  prefs: []
  type: TYPE_NORMAL
- en: The preceding equation indicates that in a graph, all edges belong to a set,
    ùìî, and all vertices belong to a set, ùì•.
  prefs: []
  type: TYPE_NORMAL
- en: 'An edge connects two vertices and so represents a relationship between them.
    For example, it can represent the following relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: Friendships between people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A person connected to a friend on LinkedIn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A physical connection of two nodes in a cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A person attending a research conference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using the `networkx` Python package to represent
    graphs. Let''s try to create a simple graph using the `networtx` package in Python.
    To begin with, let''s try to create an empty graph, `aGraph`, with no vertex or
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a single vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add a bunch of vertices using a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add one edge between the existing vertices, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now print the edges and vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f8489957-6725-46c0-854c-83e6a549647e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please note that if we are adding an edge, this also leads to adding the associated
    vertices, if they do not already exist, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print the list of nodes, the following is the output that we observe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/372a343b-993e-4a4d-a363-7d0d8e249060.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the request to add a vertex that already exists is silently ignored.
    The request is ignored or entertained based on the type of graph we have created.
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphs can be classified into four kinds, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Undirected graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directed graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undirected multigraphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directed multigraphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now look through each one in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Undirected graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most cases, the relationships that the constituent nodes of a graph represent
    can be thought of as undirectional. Such relationships do not impose any order
    on the relationship. Such edges are called **undirected edges** and the resultant
    graph is called an **undirected graph**. An undirected graph is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cf68002d-cedd-4a86-a4b9-bf6e5e2b8d8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some examples of undirectional relationships are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mike and Amine (Mike and Amine know each other).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node A and Node B are connected (this is a peer-to-peer connection).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directed graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A graph where the relationship between the nodes in the graph has some sense
    of direction is called a **directed graph**. A directed graph is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce695903-85c9-4cd3-910f-840172509719.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some examples of directed relationships are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mike and his house (Mike lives in a house, but his house does not live in Mike).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: John manages Paul (John is the manager of Paul).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undirected multigraphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, nodes have more than one type of relationship between them. In that
    case, there can be more than one edge connecting the same two nodes. These kinds
    of graphs, where multiples parallel edges are allowed on the same nodes, are called
    **multigraphs**. We have to explicitly indicate whether a particular graph is
    a multigraph or not. Parallel edges may represent different types of relationships
    between the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A multigraph is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/164e1e18-bf72-4a5a-a265-5a27aff76abd.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of a multidirectional relationship is if Mike and John are classmates
    are well as co-workers.
  prefs: []
  type: TYPE_NORMAL
- en: Directed multigraphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If there is a directional relationship between nodes in a multigraph, we call
    it a **directed multigraph**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0958225c-d78c-45a7-9dc1-b04bcbbf08fb.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of a directed multigraph is that Mike reports to John in the office,
    and John teaches Mike the Python programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Special types of edges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Edges connect various vertices of a graph together and represent the relationship
    between themselves. In addition to simple edges, they can be of the following
    special types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-edge**: Sometimes, a particular vertex can have a relationship with
    itself. For example, John transfers money from his business account to his personal
    account. Such a special relationship can be represented by a self-directed edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hyperedge**: Sometimes, more than one vertex is connected by the same edge.
    An edge that connects more than one vertex to represent such a relationship is
    called a hyperedge. For example, suppose all three of Mike, John, and Sarah are
    working on one specific project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A graph that has one or more hyperedges is called a **hypergraph**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram of a self-edge and hyperedge graph is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8540dc18-6deb-49af-af6a-b7a8d78faf8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that one particular graph can have more than one special type of edge node.
    This means that one particular graph can have both self-edges and hyper edges
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Ego-centered networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The direct neighborhood of a particular vertex, *m*, may have enough important
    information to conduct a conclusive analysis for the node. The ego-center, or
    egonet, is based on this idea. An egonet of a particular vertex, *m*, consists
    of all the vertices directly connected to *m* plus node *m* itself. The node *m*
    is called the **ego** and the one-hop neighbors it is connected to are called
    **alters**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ego network of a particular node, 3, is shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c26bd31-bf63-43dd-bb0a-a18d704a4f7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the egonet represents one degree neighborhood. This concept can be
    extended to n-degree neighborhoods, which consist of all the vertices n-hop away
    from the vertex of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Social network analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Social network analysis** (**SNA**) is one of the important applications
    of graph theory. A network graph analysis is considered social network analysis
    if the following apply:'
  prefs: []
  type: TYPE_NORMAL
- en: The vertices of the graph represent people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edges between them represent social relationships between them, such as
    a friendship, a common hobby, kinship, a sexual relationship, dislikes, and so
    on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The business question that we are trying to answer through graph analysis has
    some strong social aspect to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human behavior is reflected in SNA and should always be kept in mind while working
    on SNA. By mapping human relationships in a graph, SNA gives good insights into
    human interactions, which can help us understand their actions.
  prefs: []
  type: TYPE_NORMAL
- en: By creating a neighborhood around each individual and analyzing the actions
    of an individual based on its social relationship, you can produce interesting,
    and sometimes surprising, insights. The alternative approaches to analyzing individuals
    in isolation, based on their individual job functions, can only provide limited
    insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, SNA can be used for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a users's actions on social media platforms, such as Facebook,
    Twitter, or LinkedIn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding fraud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding society's criminal behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinkedIn has contributed a lot to the research and development of new techniques
    related to SNA. In fact, LinkedIn can be thought of as a pioneer of many algorithms
    in this area.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, SNA‚Äîdue to its inherent distributed and interconnected architecture of
    social networks‚Äîis one of the most powerful use cases for graph theory. Another
    way to abstract a graph is by considering it as a network and applying an algorithm
    designed for networks. This whole area is called **network analysis theory**,
    which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing network analysis theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that interconnected data can be represented as a network. In network
    analysis theory, we study the details of the methodologies developed to explore
    and analyze data represented as a network . Let's look at some important aspects
    of network analysis theory in this section.
  prefs: []
  type: TYPE_NORMAL
- en: First, note that a vertex in a network acts as the basic unit. A network is
    an interconnected web of vertices where each connection represents the relationship
    between various entities under investigation. It is important to quantify the
    usefulness and importance of a vertex in a network in the context of the problem
    we are trying to solve. There are various techniques that can help us quantify
    the importance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the important concepts used in network analysis theory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the shortest path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A path is a sequence of nodes between a start node and an end node, where no
    node appears twice on the path. A path represents a route between the chosen start
    and end vertex. It will be set of vertices, *p*, connecting the start vertex with
    the end vertex. No vertex is repeated in *p*.
  prefs: []
  type: TYPE_NORMAL
- en: The length of a path is calculated by counting the constituent edges. Out of
    all the options, the path with the smallest length is called the **shortest path**.
    Calculation of the shortest path is used extensively in graph theory algorithms
    but is not always straightforward to calculate. There are different algorithms
    that can be used to find the shortest path between a start node and an end node.
    One of the most popular algorithms that can be used to find the shortest distance
    between the start node and the end node is **Dijkstra's algorithm**, published
    in the late 1950s. It calculates the shortest path in a graph. It can be used
    by **Global Positioning System** (**GPS**) devices to calculate the minimum distance
    between a source and destination. Dijkstra's algorithm is also used in network
    routing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: There is a battle between Google and Apple to design the best shortest-distance
    algorithm for Google Maps and Apple Maps. The challenge they face is making the
    algorithm fast enough to calculate the shortest path within seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will discuss the **breadth-first search** (**BFS**)
    **algorithm**, which can be modified to be converted into Dijkstra's algorithm.
    BFS assumes the same cost of traversing each path in a given graph. For Dijkstra's
    algorithm, the cost of traversing a graph can be different and it needs to be
    incorporated to modify BFS into Dijkstra's algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: As indicated, Dijkstra's algorithm is a single sourced algorithm that calculates
    the shortest path. If we want to solve all pairs of shortest paths, then the **Floyd-Warshall
    algorithm** can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a neighborhood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding strategies to create a neighborhood around nodes of interest is pivotal
    for graph algorithms. Methodologies to create neighborhoods are based on selecting
    direct associates with the vertex of interest. One way of creating a neighborhood
    is by choosing a k-order strategy that selects the vertices that are *k* hops
    away from the vertex of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the various criteria for creating neighborhoods.
  prefs: []
  type: TYPE_NORMAL
- en: Triangles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In graph theory, finding vertices that are well-connected to each other is important
    for the purpose of analysis. One technique is to try to identify triangles, which
    are a subgraph that consists of three nodes directly connected to each other,
    in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the use case of fraud detection, which we have also used as a
    case study towards the end of this chapter. If an egonet of a node, *m*, consists
    of three vertices, including vertex *m*, then this egonet is a triangle. Vertex
    *m* will be the ego and the two connected vertices will be alters, say vertex
    *A* and vertex *B*. If both alters are known fraudulent cases, we can safely declare
    vertex *m* as fraudulent as well. If one of the alters is involved in fraud, we
    cannot come up with conclusive evidence, but we will need to conduct a further
    search into the evidence of fraud.
  prefs: []
  type: TYPE_NORMAL
- en: Density
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first define a fully connected network. We call a graph where every vertex
    is directly connected to every other vertex a **fully connected network**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a fully connected network, *N*, then the number of edges in the
    network can be represented by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb1ed3b4-fa12-4cf7-97ab-000e1df20edd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, this is where density comes into play. Density measures the number of
    observed edges to the maximum number of edges, if **Edges****[Observed]**  is
    the number of edges we want to observe. It can be framed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5578cdd3-f96d-4876-9858-b341f9de7e5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that for a triangle, the density of the network is `1` and this represents
    the highest possible connected network.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding centrality measures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different measures for understanding the centrality of a particular
    vertex in a graph or subgraph. For example, they can quantify the importance of
    a person in a social network or the importance of a building in a city.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following centrality measures are widely used in graph analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: Degree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Betweenness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closeness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eigenvector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Degree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of edges connected to a particular vertex is called its **degree**.
    It can indicate how well connected a particular vertex is and its ability to quickly
    spread a message across a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider `aGraph` = (ùì•, ùìî), where ùì•  represents a set of vertices and
    ùìî represents a set of edges. Recall that `aGraph` has |ùì•| vertices and |ùìî| edges.
    If we divide the degree of a node by (|ùì•| -1), it is called **degree centrality**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/914f6329-800b-4437-81ea-0eb2db9e916f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at a specific example. Consider the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ada779e9-dd48-477a-b295-c844ff01a7bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the preceding graph, vertex C has a degree of 4. Its degree centrality
    can be calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cb9a9f2c-b42d-4c45-8ff9-e225b9b68bdd.png)'
  prefs: []
  type: TYPE_IMG
- en: Betweenness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Betweenness is the measure of centrality in a graph. In the context of social
    media, it will quantify the probability that a person is part of the communication
    in a subgroup. For a computer network, betweenness will quantify the negative
    effect on communication between the graph nodes, in the event of vertex failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the betweenness of vertex *a* in a certain `aGraph` = (ùì•,  ùìî),
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the shortest paths between each pair of vertices in `aGraph`. Let's
    represent this with ![](assets/b27f093d-110b-44a6-b83a-d0319c29f6b0.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From ![](assets/7c93ea9a-f562-4a1e-9638-ce41ea2ab0c7.png), count the number
    of shortest paths that pass through vertex *a*. Let's represent this with  ![](assets/e682e160-f38a-4908-9231-1a56061ce210.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the betweenness with ![](assets/22ac572a-c56d-4287-9f79-0a7643903726.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fairness and closeness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a graph, *g*. The fairness of vertex *a* in graph *g* is defined
    as the sum of vertex *a*'s distance from other vertices. Note that the centrality
    of a particular vertex quantifies its total distance from all the other vertices.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of fairness is closeness.
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvector centrality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eigenvector centrality gives scores to all vertices in a graph that measure
    their importance in the network. The score will be an indicator of the connectivity
    of a particular node to other important nodes in the whole network. When Google
    created the **PageRank algorithm**, which assigns a score to each web page on
    the internet (in order to express its importance), the idea was derived from the
    eigenvector centrality measure.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating centrality metrics using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a network and then try to calculate its centrality metrics. The
    following code block illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph produced by this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e42a81ee-f9ee-40e9-b281-3808485e9c29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we have studied different measures of centrality. Let''s calculate
    them for the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab3b6b13-947c-4606-84e3-889fc6109e3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the metrics of centrality are expected to give the centrality measure
    of a particular vertex in a graph or subgraph. Looking at the graph, the vertex
    labeled 7 seems to have the most central location. Vertex 7 has the highest values
    in all four metrics of centrality, thus reflecting its importance in this context.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look into how we can retrieve information from the graphs. Graphs
    are complex data structures with lots of information stored both in vertices and
    edges. Let's look at some strategies that can be used to navigate through graphs
    efficiently in order to gather information from them to answer queries.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding graph traversals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make use of graphs, information needs to be mined from them. Graph traversal
    is defined as the strategy used to make sure that every vertex and edge is visited
    in an orderly manner. An effort is made to make sure that each vertex and edge
    is visited exactly once; no more and no less. Broadly, there can be two different
    ways of traveling a graph to search the data in it. Going by breadth is called
    **breadth-first search** (**BFS**) and going by depth is called **depth-first
    search** (**DFS**). Let's look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BFS works best when there is a concept of layers or levels of neighborhoods
    in the `aGraph` we are dealing with. For example, when the connections of a person
    in LinkedIn are expressed as a graph, there are first-level connections and then
    there are second-level connections, which directly translate to the layers.
  prefs: []
  type: TYPE_NORMAL
- en: The BFS algorithm starts from a root vertex and explores the vertices in the
    neighborhood vertices. It then moves to the next neighborhood level and repeats
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a BFS algorithm. For that, let''s first consider the following
    undirected graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6dcee5c9-ab3c-4e2a-b4c8-3263c2e84e65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by calculating the immediate neighborhood of each vertex and store
    that in a list, called an **adjacency list**. In Python, we can use the dictionary
    data structure to store it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To implement it in Python, we proceed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: We will first explain the initialization and then the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use two data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`visited`: This contains all the vertices that have been visited. Initially,
    it will be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queue`: This contains all the vertices that we have want to visit in next
    iterations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will implement the main loop. It will keep on looping until there isn't
    even a single element in the queue. For each node in the queue, if it has already
    been visited, then it visits its neighbor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this main loop in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we pop the first node from the queue and choose that as current node
    of this iteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then, we check that the node is not in the visited list. If it is not, we add
    it to the list of visited nodes and use neighbors to represent its directly connected
    nodes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will add neighbours of nodes to the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once the main loop is complete, the `visited` data structure is returned, which
    contains all the nodes traversed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The complete code, with both initialization and the main loop, will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9d040f20-0317-421b-a3a4-4006b3876f23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the exhaustive search traversal pattern for the graph that we
    defined using BFS. To visit all the nodes, the traversal pattern is shown in the
    following figure. It can be observed that while executing, it always maintains
    two data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visited**: Contains all the nodes that have been visited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue**: Contains nodes yet to be visited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how the algorithm works:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts from the first node, which is the only node, Amin, on level one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it moves to level two and visits all three nodes Wasim, Nick, and Mike
    one by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, it moves to level three and level four, which have only one node
    each, Imran and Faras.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once all the nodes have been visited, they are added to the Visited data structure
    and the iterations stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/893b3679-9fec-485a-9aca-0fd0ce2a31fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try to find a specific person from this graph using BFS. Let''s
    specify the data that we are searching for and observe the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34839db3-7779-44ae-83b1-9b59b4dbb427.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's look into the depth-first search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DFS is the alternative to BFS, used to search data from a graph. The factor
    that differentiates DFS from BFS is that after starting from the root vertex,
    the algorithm goes down as far as possible in each of the unique single paths
    one by one. For each path, once it has successfully reached the ultimate depth,
    it flags all the vertices associated with that path as visited. After completing
    the path, the algorithm backtracks. If it can find another path from the root
    node that has yet to be visited, the algorithm repeats the previous process. The
    algorithm keeps on moving in the new branch until all the branches have been visited.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a graph may have a cyclic method. As mentioned, we use a Boolean flag
    to keep track of the vertices that have been processed to avoid iterating in cycles.
  prefs: []
  type: TYPE_NORMAL
- en: To implement DFS, we will use a stack data structure, which was discussed in
    detail in [Chapter 2](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml), *Data Structures
    Used in Algorithms*. Remember that stack is based on the **Last In, First Out**
    (**LIFO**) principle. This contrasts with a queue, which was used for BFS, which
    works on the **First In, First Out** (**FIFO**) principal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used for DFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s again use the following code to test the `dfs` function defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this algorithm, the output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1b3b2daa-64c0-4336-aa9b-fddeed85cc08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the exhaustive traversal pattern of this graph using the DFS
    methodology:'
  prefs: []
  type: TYPE_NORMAL
- en: The iteration starts from the top node, Amin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it moves to level two, Wasim. From there, it moves toward the lower levels
    until it reaches the end, which is the Imran and Fares nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After completing the first full branch, it backtracks and then goes to level
    two to visit Nick and Mike.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The traversal pattern is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59e2f789-6a1c-490e-9f89-eaf09155d5a7.png)Note that DFS can be used
    in trees as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at a case study, which explains how the concepts we have discussed
    so far in this chapter can be used to solve a real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: Case study ‚Äì fraud analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how we can use SNA to detect fraud. With humans being social animals,
    human behavior is said to be affected by the people that you are surrounded by.
    The word **homophily** has been coined to represent the effect their social network
    has on a person. Extending this concept, a **homophilic network** is a group of
    people who are likely to be associated with each other due to some common factor;
    for example, having the same origin or hobbies, being part of the same gang or
    the same university, or some combination of other factors.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to analyze fraud in a homophilic network, we can take advantage of
    the relationships between the person under investigation and other people in the
    network, whose risk of involvement in fraud has already been carefully calculated.
    Flagging a person due to their company is sometimes also called **guilt by association**.
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to understand the process, let's first look at a simple case. For
    that, let's use a network with nine vertices and eight edges. In this network,
    four of the vertices are known fraud cases and are classified as **fraud** (**F**).
    Five of the remaining people have no fraud-related history and are classified
    as **non-fraud** (**NF**).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a code with the following steps to generate this graph:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the packages that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the data structures of `vertices` and `edges`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first instantiate the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s draw the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the NF nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the nodes that are known to be involved in fraud:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create labels for the nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding code runs, it will show us a graph like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/55d197c0-472b-4400-92b0-b8167092bbaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we have already conducted detailed analysis to classify each node
    as a graph or non-graph. Let''s assume that we add another vertex, named *q*,
    to the network, as shown in the following figure. We have no prior information
    about this person and whether this person is involved in fraud or not. We want
    to classify this person as **NF** or **F** based on their links to the existing
    members of the social network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2576c00-932c-4b05-8d36-905dca88d809.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have devised two ways to classify this new person, represented by node *q*,
    as **F** or **NF**:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a simple method that does not use centrality metrics and additional information
    about the type of fraud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a watchtower methodology, which is an advanced technique that uses the
    centrality metrics of the existing nodes, as well as additional information about
    the type of fraud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss each method in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting simple fraud analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simple technique of fraud analytics is based on the assumption that in a
    network, the behaviour of a person is affected by the people they are connected
    to. In a network, two vertices are more likely to have similar behaviour if they
    are associated with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this assumption, we devise a simple technique. If we want to find
    the probability that a certain node, *a*, belongs to *F*, the probability is represented
    by *P(F/q)* and is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3512cfbb-df1e-45a6-bd57-f2ae7510a22f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s apply this to the preceding figure, where *Neighborhood[n]* represents
    the neighborhood of vertex *n* and *w(n, nj)* represents the weight of the connection
    between *n* and *n**j*. Also, *degree[q]*  is the degree of node *q*. Then, the
    probability is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/24479db6-04d6-4f69-a4b1-6bad70aa647c.png)'
  prefs: []
  type: TYPE_IMG
- en: Based on this analysis, the likelihood of this person being involved in fraud
    is 67%. We need to set a threshold. If the threshold is 30%, then this person
    is above the threshold value and we can safely flag them as F.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this process needs to be repeated for each of the new nodes in the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at an advanced way of conducting fraud analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the watchtower fraud analytics methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous, simple fraud analytics technique has the following two limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not evaluate the importance of each vertex in the social network. A
    connection to a hub that is involved in fraud may have different implications
    than a relationship with a remote, isolated person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When labeling someone as a known case of fraud in an existing network, we do
    not consider the severity of the crime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The watchtower fraud analytics methodology addresses these two limitations.
    First, let's look at a couple of concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Scoring negative outcomes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a person is known to be involved in fraud, we say that there is a negative
    outcome associated with this individual. Not every negative outcome is of the
    same severity or seriousness. A person known to be impersonating another person
    will have a more serious type of negative outcome associated with them, compared
    to someone who is just trying to use an expired $20 gift card, in an innovative
    way to make it valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a score of 1 to 10, we rate various negative outcomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Negative outcome** | **Negative outcome score** |'
  prefs: []
  type: TYPE_TB
- en: '| Impersonation | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Involvement in credit card theft | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Fake check submission | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| Criminal record | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| No record | 0 |'
  prefs: []
  type: TYPE_TB
- en: Note that these scores will be based on our analysis of fraud cases and their
    impact from historical data.
  prefs: []
  type: TYPE_NORMAL
- en: Degree of suspicion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **degree of suspicion** (**DOS**) quantifies our level of suspicion that
    a person may be involved in fraud. A DOS value of 0 means that this is a low-risk
    person and a DOS value of 9 means that this is a high-risk person.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of historical data shows that professional fraudsters have important
    positions in their social networks. To incorporate this, first we calculate all
    of the four centrality metrics of each vertex in our network. We then take the
    average of these vertices. This translates to the importance of that particular
    person in the network.
  prefs: []
  type: TYPE_NORMAL
- en: If a person associated with a vertex is involved in fraud, we illustrate this
    negative outcome by scoring the person using the pre-determined values shown in
    the preceding table. This is done so that the severity of the crime is reflected
    in the value of each individual DOS.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we multiply the average of the centrality metrics and the negative
    outcome score to get the value of the DOS. We normalize the DOS by dividing it
    by the maximum value of the DOS in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s calculate the DOS for each of the nine nodes in the previous network:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Node 1** | **Node 2** | **Node 3** | **Node 4** | **Node 5** | **Node
    6** | **Node 7** | **Node 8** | **Node 9** |'
  prefs: []
  type: TYPE_TB
- en: '| Degree of centrality | 0.25 | 0.5 | 0.25 | 0.25 | 0.25 | 0.13 | 0.63 | 0.13
    | 0.13 |'
  prefs: []
  type: TYPE_TB
- en: '| Betweenness | 0.25 | 0.47 | 0 | 0 | 0 | 0 | 0.71 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Closeness | 0.5 | 0.61 | 0.53 | 0.47 | 0.47 | 0.34 | 0.72 | 0.4 | 0.4 |'
  prefs: []
  type: TYPE_TB
- en: '| Eigenvector | 0.24 | 0.45 | 0.36 | 0.32 | 0.32 | 0.08 | 0.59 | 0.16 | 0.16
    |'
  prefs: []
  type: TYPE_TB
- en: '| Average of centrality Metrics | 0.31 | 0.51 | 0.29 | 0.26 | 0.26 | 0.14 |
    0.66 | 0.17 | 0.17 |'
  prefs: []
  type: TYPE_TB
- en: '| Negative outcome score | 0 | 6 | 0 | 0 | 7 | 8 | 10 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| DOS | 0 | 3 | 0 | 0 | 1.82 | 1.1 | 6.625 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Normalized DOS | 0 | 0.47 | 0 | 0 | 0.27 | 0.17 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Each of the nodes and their normalized DOS is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30b77bac-79b9-4ef2-9bea-a627c4982bea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to calculate the DOS of the new node that has been added, we will
    use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b49b7849-b828-4aea-9d55-63519ba02edb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the relevant values, we will calculate the DOS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/14d3681c-ee75-4ca6-8cd5-fb10141e3038.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will indicate the risk of fraud associated with this new node added to
    the system. It means that on a scale of 0 to 1, this person has a DOS value of
    0.42\. We can create different risk bins for the DOS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value of the DOS** | **Risk classification** |'
  prefs: []
  type: TYPE_TB
- en: '| DOS = 0 | No risk |'
  prefs: []
  type: TYPE_TB
- en: '| 0<DOS<=0.10 | Low risk |'
  prefs: []
  type: TYPE_TB
- en: '| 0.10<DOS<=0.3 | Medium risk |'
  prefs: []
  type: TYPE_TB
- en: '| DOS>0.3 | High risk |'
  prefs: []
  type: TYPE_TB
- en: Based on these criteria, it can be seen that the new individual is a high-risk
    person and should be flagged.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a time dimension is not involved when conducting such an analysis.
    But now, there are some advanced techniques that look at the growth of a graph
    as time progresses. This allows researchers to look at the relationship between
    vertices as the network evolves. Although such time-series analysis on graphs
    will increase the complexity of the problem by many times, it may give additional
    insight into the evidence of fraud that was not possible otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about graph-based algorithms. After going through
    this chapter, I expect that we should be able to use different techniques of representing,
    searching, and processing data represented as graphs. We also developed skills
    to be able to calculate the shortest distance between two vertices and we built
    neighborhoods in our problem space. This knowledge should help us use graph theory
    to address problems such as fraud detection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on different unsupervised machine learning
    algorithms. Many of the use-case techniques discussed in this chapter complement
    unsupervised learning algorithms, which will be discussed in detail in the next
    chapter. Finding evidence of fraud in a dataset is an example of such use cases.
  prefs: []
  type: TYPE_NORMAL
