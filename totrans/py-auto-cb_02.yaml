- en: Automating Tasks Made Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a cron job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing errors and problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending email notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To properly automate tasks, we need a platform so that they run automatically
    at the proper times. A task that needs to be run manually is not really fully
    automated.
  prefs: []
  type: TYPE_NORMAL
- en: But, in order to be able to leave them running in the background while worrying
    about more pressing issues, the task will need to be adequate to run in *fire-and-forget* mode.
    We should be able to monitor that it runs correctly, be sure that we are capturing
    future actions (such as receiving notifications if something interesting arises),
    and know whether there have been any errors while running it.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that a piece of software runs consistently with a high reliability
    is actually a very big deal and is one area that, to be done properly, requires
    specialized knowledge and staff, which typically go by the names of sysadmin,
    operations, or **SRE** (**Site Reliability Engineering**). Sites like Amazon and
    Google require huge investment in ensuring that everything works 24/7.
  prefs: []
  type: TYPE_NORMAL
- en: The objective for this book is way more modest than that. You probably don't
    require a downtime lower than a few seconds per year. Running a task with reasonable
    reliability is a much easier thing to do. But, be aware that there's maintenance
    to be done, so be prepared for that.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It all starts with defining exactly what task needs to be run, and designing
    it in a way that doesn't require human intervention to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some ideal characteristic points are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single, clear entry point**: No confusion on what the task to run is.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clear parameters**: If there are any parameters, they should be very explicit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**No interactivity**: Stopping the execution to request information from the
    user is not possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The result should be stored**: To be able to be checked at a different time
    than when it runs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clear result**: If we are working interactively in a result, we accept more
    verbose results, or progress reports. But, for an automated task, the final result
    should be as concise and to the point as possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Errors should be logged**: To analyze what went wrong.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A command-line program has a lot of those characteristics already. It has a
    clear way of running, with defined parameters, and the result can be stored, even
    if just in text format. But, it can be improved with a config file to clarify
    the parameters, and an output file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that point 6 is the objective of the *Capturing errors and problems* recipe,
    and will be covered there.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid interactivity, do not use any command that stops for the user to input,
    like `input`. Remember to delete breakpoints for debugging!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by following a structure in which a main function will serve as
    the entry point, and all parameters are supplied to it.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same the basic structure the was presented in the *Adding command-line
    arguments* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let's
    Begin Our Automation Journey*.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of a main function will all the explicit arguments covers points
    1 and 2. Point 3 is not difficult to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: To improve point 2 and 5, we'll look at retrieving the configuration from a
    file and storing the result in another. Another option is to send a notification,
    such as an email, which will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prepare the following task and save it as `prepare_task_step1.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the file to define a config file that contains both arguments, and save
    it as `prepare_task_step2.py`. Note that defining a config file overwrites any
    command-line parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the config file `config.ini`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the command with the config file. Note that the config file overwrites
    the command-line parameters, as described in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a parameter to store the result in a file, and save it as `prepare_task_step5.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the result to check that it''s sending the output to the defined file.
    Note that there''s no output outside the result files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that the `argparse` module allows us to define files as parameters, with
    the `argparse.FileType` type, and opens them automatically. This is very handy,
    and will raise an error if the file is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to open the file in the correct mode. In Step 5, the config file is
    opened in read mode (`r`) and the output file in write mode (`w`), which will
    overwrite the file if it exists. You may find the append mode (`a`), which will
    add the next piece of data at the end of an existing file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `configparser` module allows us to use config files with ease. As demonstrated
    in Step 2, the parsing of the file is as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The config will then be accessible as a dictionary divided by sections, and
    then values. Note that the values are always stored in string format, requiring
    to be transformed into other types, such as integers:'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to obtain boolean values, do not perform `value = bool(config[raw_value])` as
    it will be transformed into `True` no matter what; for instance, the string `False`
    is a true string, as it's not empty. Use the `.getboolean` method instead, for
    example, `value = config.getboolean(raw_value)`.
  prefs: []
  type: TYPE_NORMAL
- en: Python3 allows us to pass a `file` parameter to the `print` function, which
    will write to that file. Step 5 shows the usage to redirect all the printed information
    to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the default parameter is `sys.stdout`, which will print the value
    to the Terminal (standard output). This makes it so that calling the script without
    an `-o` parameter will display the information on the screen, which is helpful
    in debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please check out the full documentation of `configparse` in the official Python
    documentation: [https://docs.python.org/3/library/configparser.html.](https://docs.python.org/3/library/configparser.html)
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, this configuration parser should be good enough, but if more
    power is needed, you can use YAML files as configuration files. YAML files ([https://learn.getgrav.org/advanced/yaml](https://learn.getgrav.org/advanced/yaml))
    are very common as configuration files, and are better structured and can be parsed
    directly, taking into account data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add PyYAML to the `requirements.txt` file and install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `prepare_task_yaml.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the config file `config.yaml,` available in GitHub [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter02/config.yaml](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter02/config.yaml)[ ](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/chapter2/config.yaml):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's also the possibility of setting a default config file, as well as a
    default output file. This can be handy to create a pure task that requires no
    input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, try to avoid creating too many input and configuration parameters
    if the task has a very specific objective in mind. Try to limit the input parameters
    to different executions of the task. A parameter that never changes is probably
    fine being defined as a **constant**. A high number of parameters will make config
    files or command-line arguments complicated and will create more maintenance in
    the long run. On the other hand, if your objective is to create a very flexible
    tool to be used in very different situations, then creating more parameters is
    probably a good idea. Try to find your own proper balance!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Command-line arguments* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let's
    Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending email notifications* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging with breakpoints* recipe in [Chapter 10](8c793eca-22a6-4688-afa9-e5175b4fb380.xhtml), *Debugging
    Techniques*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a cron job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cron is an old-fashioned but reliable way of executing commands. It has been
    around since the 70s in Unix, and it's an old favorite in system administration
    to perform maintenance, such as freeing space, rotating logs, making backups,
    and other common operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe is Unix-specific, so it will work in Linux and MacOS. While it''s
    possible to schedule a task in Windows, it''s very different and uses Task Scheduler,
    which won''t be described here. If you have access to a Linux server, it can be
    a good way of scheduling periodic tasks.The main advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's present in virtually all Unix or Linux systems and configured to run automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to use, though a little deceptive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's well-known. Almost anyone involved with admin tasks will have a general
    idea on how to use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows for easy periodic commands, with good precision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But, it also has some disadvantages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, it may not give much feedback. Retrieving the output, logging execution,
    and errors is critical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task should be as self-contained as possible to avoid problems with environment
    variables, such as using the wrong Python interpreter, or what path should execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is Unix-specific.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only fixed periodic times are available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't control how many tasks run at the same time. Each time the countdown
    goes off, it creates a new task. For example, a task that takes one hour to complete,
    and that is scheduled to run once every 45 minutes, will have 15 minutes of overlap
    where two tasks will be running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't understate the latest effect. Running multiple expensive tasks at the
    same time can have bad effects on performance. Having expensive tasks overlapping
    may result in a race condition where each task is making the others never finish!
    Allow ample time for your tasks to finish and keep an eye on them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will produce a script, called  `cron.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: The config file, is by default, `/etc/automate.ini`. Reuse `config.ini` from
    the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A timestamp has been added to the output. This will make it explicit when the
    task is run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is being added to the file, as shown with the `'a'` mode where the
    file is open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ArgumentDefaultsHelpFormatter` parameter automatically adds information
    about default values when printing the help using the `-h` argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check that the task is producing the expected result and that you can log to
    a known file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obtain the full path of the Python interpreter. This is the interpreter that''s
    on your virtual environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare the cron to be executed. Get the full path and check that it can be
    executed with no problem. Execute it a couple of times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the result is being added correctly to the result file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the crontab file to run the task once every five minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that this opens an editing Terminal with your default command-line editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t set up your default command-line editor, by default, it is
    likely Vim. This can be disconcerting if you don''t have experience with Vim.
    Press *I* to start inserting text and *Esc *when you''re done. Then, exit after
    saving the file with `:wq`. For more information about Vim, see this introduction:
    [https://null-byte.wonderhowto.com/how-to/intro-vim-unix-text-editor-every-hacker-should-be-familiar-with-0174674](https://null-byte.wonderhowto.com/how-to/intro-vim-unix-text-editor-every-hacker-should-be-familiar-with-0174674).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For information on how to change the default command-line editor, see the following:
    [https://www.a2hosting.com/kb/developer-corner/linux/setting-the-default-text-editor-in-linux.](https://www.a2hosting.com/kb/developer-corner/linux/setting-the-default-text-editor-in-linux)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the crontab contents. Note that this displays the crontab contents, but
    doesn''t set it to edit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait and check the result file to see how the task is being executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The crontab line consists of a line describing how often to run the task (first
    six elements), plus the task. Each of the initial six elements mean a different
    unit of time to execute. Most of them are stars, meaning *any*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, our line, `*/5 * * * * *`, means *every time the minute is divisible
    by 5, in all hours, all days... all years*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Do not try to guess too much. Use a cheat sheet like [https://crontab.guru/](https://crontab.guru/)
    for examples and tweaks. Most of the common usages will be described there directly.
    You can also edit a formula and get a descriptive text on how it's going to run.
  prefs: []
  type: TYPE_NORMAL
- en: After the description of how to run the cron job, include the line to execute
    the task, as prepared in Step 2 in the *How to do it…* section.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the task is described with all the full paths for every related file—the
    interpreter, the script, and the output file. This removes all ambiguity related
    to paths and reduces the chances of possible errors. A very common one is not
    being able to determine one (or more) of the three elements.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If there''s any problem in the execution of the crontab, you should receive
    a system mail. This will show up as a message in the Terminal, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be read with `mail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the next recipe, we will see methods to capture the errors independently
    so that the task can run smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Adding command-line options* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml),
    *Let's Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Capturing errors and problems* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing errors and problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An automated task's main characteristic is its *fire-and-forget* quality. We
    are not actively looking at the result, but making it run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as most of the recipes in this book deal with external information, such
    as web pages or other reports, the likelihood of finding an unexpected problem
    when running it is high. This recipe will present an automated task that will
    safely store unexpected behaviors in a log file that can be checked afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a starting point, we'll use a task that will divide two numbers, as described
    in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: This task is very similar to the one presented in Step 5 in the *How to do it…*
    section, but instead of multiplying two numbers, we'll divide them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `task_with_error_handling_step1.py` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute it a couple of times to see that it divides two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that dividing by `0` produces an error, and that the error is not logged
    on the result file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `task_with_error_handling_step4.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it to check that it displays the proper `INFO` and `ERROR` log, and that
    it stores it on the log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To properly capture any unexpected exceptions, the main function should be
    wrapped into a `try-except` block, as done in Step 4 in the *How to do it…* section.
    Compare this to how Step 1 is not wrapping the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that logging the exception is important for getting information on what
    went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of exception is nicknamed *Pokémon*, because it can *catch'em all*,
    as it will capture any unexpected error at the highest level. Do not use it in
    other areas of the code, as capturing everything can hide unexpected errors. At
    the very least, any unexpected exception should be logged to allow for further
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The extra step to exit with status 1 with the `exit(1)` call informs the operating
    system that something went wrong with our script.
  prefs: []
  type: TYPE_NORMAL
- en: The `logging` module allows us to log. Note the basic configuration, which includes
    an optional file to store the logs, the format, and the level of the logs to display.
  prefs: []
  type: TYPE_NORMAL
- en: The available level for logs are, from less critical to more critical—`DEBUG`,
    `INFO`, `WARNING`, `ERROR`, and `CRITICAL`. The logging level will set the minimal
    severity required to log the message. For example, an `INFO` log won't be stored
    if the severity is set to `WARNING`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating logs is easy. You can do this by making a call to the method `logging.<logging
    level>`, (where `logging level` is `debug`, `info`, and so on). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note how logs with a severity lower than `INFO` are not displayed. Use the level
    definition to tweak how much information to display. This may change, for example,
    how `DEBUG` logs may be used only while developing the task, but not be displayed
    when running it. Notice that `task_with_error_handling_step4.py` is defining the
    logging level to be `DEBUG`, by default.
  prefs: []
  type: TYPE_NORMAL
- en: A good definition of log levels is key to displaying relevant information, while
    reducing spam. It is not easy to set up sometimes, but especially if more than
    one person is involved, try to agree on exactly what `WARNING` versus `ERROR`
    means to avoid misinterpretations.
  prefs: []
  type: TYPE_NORMAL
- en: '`logging.exception()` is a special case that will create an `ERROR` log, but
    it will also include information about the exception, such as the **stack trace**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to check logs to discover errors. A useful reminder is to add a note
    on the results file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python `logging` module has a lot of capabilities, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Further tweaks the format of the log, for example, including the file and line
    number of the log that was produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines different logger objects, each one with its own configuration, like
    logging level and format. This allows to produce logs to different systems in
    different ways, though is normally not used for simplicity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends logs to multiple places, such as that standard output and file, or even
    a remote logger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically rotates logs, creating new log files after a certain time or size.
    This is handy in keeping logs organized by day, and allowing for the compression
    or removal of old logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads standard logging configurations from files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of creating complex rules, try to log  extensively, but with the proper
    level, and then filter.
  prefs: []
  type: TYPE_NORMAL
- en: For comprehensive detail, check the Python docs of the module at [https://docs.python.org/3.7/library/logging.html](https://docs.python.org/3.7/library/logging.html),
    or the tutorial at [https://docs.python.org/3.7/howto/logging.html](https://docs.python.org/3.7/howto/logging.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Adding command-line options* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let's
    Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preparing a task* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending email notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Email has become an inescapable tool that everyone uses everyday. It's probably
    the best place to send a notification if an automated task has detected something.
    On the other hand, email inboxes are already too filled up with spam messages,
    so be careful.
  prefs: []
  type: TYPE_NORMAL
- en: Spam filters are also a reality. Be careful with who to send emails to and the
    number of emails to be sent. An email server or address can be labelled as *spam,*
    and all emails will be quietly dropped by the internet.This recipe will show how
    to send a single email, using an already existing email account.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is viable for spare emails sent to a couple of people, as a result
    from an automated task, but no more than that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we require a valid email account set up, which includes the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A valid email server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A port to connect to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These four elements should be enough to be able to send an email.
  prefs: []
  type: TYPE_NORMAL
- en: Some email services, for example, Gmail, will encourage you to set up 2FA, meaning
    that a password is not enough to send an email. Typically, they'll allow you to
    create an specific password for apps to use, bypassing the 2FA request. Check
    your email provider's information for options.
  prefs: []
  type: TYPE_NORMAL
- en: The email provider to use should indicate what the SMTP server is and port to
    use in their documentation. They can be retrieved from email clients as well,
    as they are the same parameters. Check your provider documentation. In the following
    example, we will use a Gmail account.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `email_task.py` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a configuration file called `email_conf.ini` with the specifics of your
    email account. For example, for a Gmail account, fill the following template.
    The template is available in GitHub [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter02/email_conf.ini](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter02/email_conf.ini),
    but be sure to fill it with your data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the file cannot be read or written by other users on the system,
    setting the permissions of the file to allow only our user. `600` permissions
    means read and write access for our user, and no access to anyone else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script to send a test email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Check the inbox of the destination email; an email should be received with the
    subject `With love, from ME to YOU`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two key steps in the scripts—the generation of the message, and the
    sending.
  prefs: []
  type: TYPE_NORMAL
- en: The message needs to contain mainly the `To` and `From` email addresses, as
    well as the `Subject`. If the content is pure text, as in this case, calling `.set_content() `
    is enough. The whole message can then be sent.
  prefs: []
  type: TYPE_NORMAL
- en: It is technically possible to send an email from a different email than the
    account used to send it. This is discouraged, though, as it can be considered
    by your email provider as trying to impersonate a different email. You can use
    the `reply-to` header as a way of allowing answering to a different account.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the email requires you to connect to the specified server and start
    an SMPT connection. SMPT is the standard for email communication.
  prefs: []
  type: TYPE_NORMAL
- en: The steps are quite straightforward—configure the server, log into it, send
    the prepared message, and quit.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to send more than one message, you can log in, send multiple emails,
    and then quit, instead of connecting each time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the objective is a bigger operation, like a marketing campaign, or even production
    emails like confirming a user's email, please check [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml), *Dealing
    with Communication Channels*
  prefs: []
  type: TYPE_NORMAL
- en: The email message content used in this recipe is very simple, but emails can
    be much more complicated than that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `To` field can contain multiple recipients. Separate them with commas,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Emails can be defined in HTML, with an alternative plain text, and have attachments.
    The basic operation is to set up a `MIMEMultipart` and then attach each of the
    MIME parts that compose the email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The most common SMPT connection is `SMPT_SSL`, which is more secure and requires
    a login and password, but plain, unauthenticated SMPT exists; check your email
    provider documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this recipe is aimed for simple notifications. Emails can grow
    quite complex if attaching different information. If your objective is an email
    for customers or any general group, try to use the ideas in [Chapter 8](aefbed90-7a63-4611-b430-85d216ab03c0.xhtml),
    *Dealing with Communication Channels*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Adding command-line options* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml),
    *Let's Begin Our Automation Journey*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preparing a task* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
