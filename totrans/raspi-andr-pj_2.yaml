- en: Chapter 2. Server Management with Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first half of this project, we will move from a desktop-based console
    to a text-based one that gives more power to the user and lets you perform more
    advanced tasks compared to the desktop. We will access the Pi''s Linux console
    from an Android device and control it remotely. In the second half, we will send
    and receive files between the Pi and Android through FTP. We will even combine
    the two parts by managing our newly installed FTP server remotely using the text-based
    console. In this chapter, we will even install database and web servers on to
    the Pi to show how to manage them later on. To make it even more fun, we will
    implement a simple but useful mini project that makes use of both web and database
    servers. The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Remote console to the Pi from Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchanging files between the Pi and Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple database and web server implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple management of servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote console to the Pi from Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The administrators of Linux and Unix computers have been using text-based command-line
    interfaces called **shell** for many years to manage and administer their servers.
    As the Pi's OS, Raspbian, is a Linux variant, the most natural way to access and
    issue commands or check the status of running programs, services, and different
    servers on the Pi is again by issuing commands on this text-based shell. There
    are different shell implementations but the one that is used on Raspbian by default
    is **bash**. The most well-known way of accessing shell remotely on a Linux server
    is through the **Secure Shell** protocol known, in general, as **SSH**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Secure Shell** (**SSH**) is an encrypted network protocol used to send shell
    commands to a remote machine in a secure way. SSH does two things for you. It
    enables, through different tools, such as the ones we will present to you in a
    moment, you to send commands to the remote machine and it does this using a secure
    channel established over an insecure network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For SSH to work, there should be an SSH server already running that can accept
    and respond to SSH client requests. On Raspberry Pi, this feature is enabled by
    default. If by any means, it is disabled, you can enable it using the Pi configuration
    program by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, navigate to **ssh** and hit *Enter*, and then select **Enable or disable
    ssh server**.
  prefs: []
  type: TYPE_NORMAL
- en: On the client side, and as we are using Android as our client throughout this
    book, we will download an app called ConnectBot. It is one of the most popular
    SSH clients on Android and the latest version as of today is 1.8.4\. Download
    it to your device and open it.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to provide the username and IP address that we found out in the
    previous chapter. We do not need to provide the port as ConnectBot will use the
    default port for SSH in this case. Click on **Yes** if you are asked to continue
    with the connection because of problems with the authenticity of the host. You
    are asked this question because you are connecting to the Pi for the first time
    through a remote SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the following screenshot, I have provided the internal IP address
    of my home network. You might want to use an external IP address and connect to
    the Pi from outside your home network. For this purpose, you'll need to add the
    standard FTP ports `21` and `20` to your port forwarding settings as well. The
    same applies to the SSH protocol, which has a default port number of `22`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have discussed earlier, there is a security risk in opening ports this
    way and also keeping the default password for the user `pi` on the Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates connection details on ConnectBot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Remote console to the Pi from Android](img/image00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connection details on ConnectBot
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, provide the default password for the `pi` account, which is `raspberry`,
    or the one you have changed it to. After this step, you will be connected to the
    Pi remotely using SSH, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Remote console to the Pi from Android](img/image00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The prompt provided by ConnectBot
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to issue commands on your Pi and check the status of different
    services. This connection will be saved with all its properties. Next time you
    want to log in, you will not need to provide an address, username, and password
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a Mac or Linux, you can use the `ssh` command installed on your system by
    default. On Windows, you can download PuTTY to issue the same commands as the
    ones in ConnectBot.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging files between the Pi and Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the second part of this chapter, we will use the Pi as an FTP server to
    share files between our Android devices or send files to the Pi to view them on
    a larger screen that you connect to the Pi HDMI port. The FTP server we will use
    is `vsftpd`. It is a lightweight FTP server used in many small projects. To install
    it on our Pi, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will even start the FTP service.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we should make some changes in the configuration of the FTP server
    to use it effectively. For this purpose, we need to edit the FTP server configuration
    file using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the two lines containing #`local_enable=YES` and `#write_enable=YES` and
    remove the `#` comment sign at the beginning of these lines before you save and
    exit. These changes will enable the user `pi` to login and be able to send files
    to the Pi. To restart the FTP server, issue this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to install an FTP client on Android. For this purpose, we will
    use **AndFTP**. It is enough to use the free version for our project. We see the
    following initial view on the Android device after opening it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exchanging files between the Pi and Android](img/image00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An initial view of the AndFTP client
  prefs: []
  type: TYPE_NORMAL
- en: 'Pressing the plus button will take you to the following view, where you will
    be asked for connection properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exchanging files between the Pi and Android](img/image00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connection properties on AndFTP
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide the IP address of the Pi you found out in the first chapter, `pi` as
    username, and `raspberry` as the password or the one you have changed to. Then,
    scroll down to the end of the view and press the **Save** button. This will save
    the connection properties and send you back to the main view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exchanging files between the Pi and Android](img/image00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The list of connections in AndFTP
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the newly created connection, shown as a blue folder, will initiate
    the FTP connection to the Pi and log the user `pi` in. This will get you into
    the `home` directory for the `pi` user, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exchanging files between the Pi and Android](img/image00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The home directory of user pi
  prefs: []
  type: TYPE_NORMAL
- en: Now you will be able to upload files from your Android device to the Pi by pressing
    the mobile phone-like icon in AndFTP and choosing a file to upload afterwards.
    You can set up AndFTP from another Android device on the same network or even
    another computer using a built-in FTP client, and download the newly uploaded
    file to view it; this way, you have shared your first file between different Android
    clients using Raspberry Pi as an FTP server.
  prefs: []
  type: TYPE_NORMAL
- en: A simple database and web server implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll take our project one step further and install both a database and
    web server, which we can administer later on using ConnectBot. We will even make
    it more fun by implementing a real project that makes use of these servers. The
    best candidate for this purpose is a sensor measurement scenario. We will connect
    a temperature/humidity sensor to our Pi and save the measurements into a database
    that we will install on the Pi, which a web server will make available to clients.
    We can later on manage these servers remotely, which is the main objective in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purpose of this project, we will use a sensor, **DHT11**, which measures
    both temperature and humidity, but for the sake of easier connections, we will
    use an off-the-shelf module called **Keyes DHT11** or DHT11 for short, which contains
    these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is even an improved version of DHT11, which is DHT22\. It costs a little
    bit more but has more accurate sensors on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this sensor module instead of the sensors itself will enable us to connect
    the sensors to the Pi using only three jumper wires and without a breadboard or
    resistor. There is another advantage of using this module instead of the sensors:
    the sensors provide analog data that the Pi cannot handle. Pi is capable of handling
    digital information on its GPIO ports. The DHT11 module does the conversion for
    us. The following image illustrates the DHT11 sensor module along with a description
    of the pins associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the sensor](img/image00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The DHT11 sensor module
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image illustrates the Keyes DHT11 sensor module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the sensor](img/image00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Keyes DHT11 sensor module
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, connect the **GND** output from the sensor module to Pi''s GPIO Ground,
    **5V** output to Pi''s 5V pin, and **DATA** to Pi''s **GPIO-4** pin. The following
    diagram shows the layout of Pi''s GPIO pins and their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the sensor](img/image00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi GPIO pin layout
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to read the values these sensors provide. For this purpose,
    we will use a widely used library from **Adafruit**, which is specially designed
    for these kinds of sensors developed in the Python programming language. Before
    we can use it, we need to install some software components to our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to update our Pi and install some dependencies using these
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The sensor library itself is on GitHub and we will download it from there onto
    our Pi using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command downloads the library and saves it in a subdirectory. Now, go
    into this subdirectory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to actually install the sensor library using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the standard Python third-party module install functionality, which
    installs the Adafruit library globally onto your system at the standard Python
    library install location, `/usr/local/lib/python2.7/dist-packages/`. This is why
    we need superuser privileges, which we can get using `sudo` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to begin reading measurements from the sensor using the example
    code that we downloaded together with the library. Assuming that you are still
    in the `Adafruit_Python_DHT` directory, the following command does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, `11` is the descriptor used to identify DHT11 sensor and `4`
    denotes the GPIO pin 4\. You should now get an output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Installing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After verifying that the sensor and connections to the Pi work, we will save
    the measurements in a database. The database we will use is MySQL. Use the following
    command to install MySQL to the Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'During the installation, you will be asked to set a password for the administrator
    account root. I will set admin as the password and refer to it in the upcoming
    code. The following command takes you into the MySQL shell where you can issue
    SQL commands, such as inserting data into a database or querying data already
    in the database. You should provide the password you have set when you''re asked
    for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can exit from the MySQL shell anytime using the `exit` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step in the MySQL shell is to create a database and use it for any
    further SQL statement that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following SQL statement will create a table in this newly created database
    that we will use to save sensor measurements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement a Python script that reads from our sensor and
    saves it to the database. Put the following code in a file with the name `sense.py`
    under the `home` directory using the previously discussed `nano` command. You
    can use the `cd` command without parameters to go back to the `home` directory
    from any place in the `pi` directory structure. Note an important fact that the
    file should not contain any empty preceding lines, which means that the line referring
    to the Python command should be the first line in the file. The following code
    forms the content of our `sense.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should change the password parameter in the `MySQLdb.connect` method call
    to the one you have assigned to the root user on the MySQL server. You should
    even consider creating a new user with access to just the `measurements` table
    for security reasons, as the root user has full access to the database. Refer
    to the MySQL documentation for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to change the file properties and make it an executable file
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this script saves only a single measurement. We need to schedule
    the running of this script. For this purpose, we will use a built-in Linux utility
    called **cron**, which allows tasks to be automatically run in the background
    at regular intervals by the cron daemon. **crontab,** also known as CRON TABle,
    is a file that contains the schedule of cron entries to be run at specified times.
    By running the following command, we can edit this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to this file and save it. This will make the cron deamon
    run our script once every five minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Installing the web server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will save our measurements into the database. The next step is to view
    them in a web browser using a web server. For this purpose, we will use **Apache**
    as the web server and **PHP** as the programming language. To install Apache and
    the packages required for our purpose, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change your directory to the web server''s default directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will create a file that will be accessed by users through the web
    server we have installed. The file is executed by the web server and the result
    of this execution is sent to the clients connected. We will name it `index.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents should look like the following code. Here, you should again change
    the password for the MySQL user root to the one you have chosen in the call to
    the `new mysqli` constructor method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We want this page to be the default start page that web browsers get whenever
    they access the server directly with only an IP address. You can back up the old
    default start page for Apache as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Navigating to the IP address of the Pi from a browser will result in a view
    similar to the following screenshot after a few hours of sensor measurements.
    Here, I can access the Pi using the external IP address outside my home network
    as I have added the HTTP port of `80` to the port forwarding settings of my home
    router.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the web server](img/image00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have a running FTP, database, and web servers. Let's administer these
    using ConnectBot.
  prefs: []
  type: TYPE_NORMAL
- en: Simple management of servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command simply checks the status of the FTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This command restarts the FTP server if there''s any problem with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `service` utility that we have used lets you restart the database and web
    server using these two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to check the status of the MySQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you believe that the database has grown too much in size, you can start
    the MySQL console and run a SQL query to see the database size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even delete records that are older than three days using the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, as an alternative, you can check the size of the filesystem using the shell
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the management of Raspberry Pi as a server and
    how to issue commands to it from Android. We installed an FTP server on the Pi
    and shared files between Android clients. To show an example of database and web
    servers, we implemented a useful project and learned to manage these servers remotely
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce you to the Pi camera and help you implement
    a surveillance solution.
  prefs: []
  type: TYPE_NORMAL
