- en: 2B. No Ducks Allowed – Templates and Deduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2B.不允许鸭子-模板和推导
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够：
- en: Develop your own classes to an even greater effect using inheritance and polymorphism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承和多态将自己的类发挥到更大的效果
- en: Implement an alias to make your code easier to read
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现别名以使您的代码更易于阅读
- en: Develop templates using SFINAE and constexpr to simplify your code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SFINAE和constexpr开发模板以简化您的代码
- en: Implement your own solutions using the STL to leverage generic programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用STL实现自己的解决方案，以利用通用编程
- en: Describe the context and basic rules for type deduction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述类型推导的上下文和基本规则
- en: This chapter will show you how to define and extend your types through inheritance,
    polymorphism, and templates.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何通过继承，多态和模板来定义和扩展您的类型。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how to develop our own types (classes) with
    the help of unit tests and made them behave like built-in types. We were introduced
    to function overloading, Rule of Three/Five, and Rule of Zero.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何通过单元测试开发自己的类型（类），并使它们表现得像内置类型。我们介绍了函数重载，三/五法则和零法则。
- en: In this chapter, we will learn how to extend the type system even further. We'll
    learn how to create functions and classes using templates and revisit function
    overloading since it's impacted by the use of templates. We'll be introduced to
    a new technology, **SFINAE**, and use it to control the parts of our templates
    that are included in the generated code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何进一步扩展类型系统。我们将学习如何使用模板创建函数和类，并重新讨论函数重载，因为它受到模板的影响。我们将介绍一种新技术**SFINAE**，并使用它来控制我们模板中包含在生成代码中的部分。
- en: Inheritance, Polymorphism, and Interfaces
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承，多态和接口
- en: 'So far in our journey of object-oriented design and C++, we have focused on
    abstraction and data encapsulation. We will now turn our attention to **inheritance**
    and **polymorphism**. What is inheritance? What is polymorphism? Why do we need
    it? Consider the following three objects:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的面向对象设计和C++的旅程中，我们已经专注于抽象和数据封装。现在我们将把注意力转向**继承**和**多态**。什么是继承？什么是多态？我们为什么需要它？考虑以下三个对象：
- en: '![Figure 2B.1: Vehicle objects'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.1：车辆对象'
- en: '](img/C14583_02B_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_01.jpg)'
- en: 'Figure 2B.1: Vehicle objects'
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.1：车辆对象
- en: In the preceding diagram, we can see that there are three very different objects.
    They have some things in common. They all have wheels (a different number), an
    engine (different size, power, or configuration), start engine, drive, apply brakes,
    stop engine, and so on, using which we can do something.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到有三个非常不同的对象。它们有一些共同之处。它们都有轮子（不同数量），发动机（不同大小，功率或配置），启动发动机，驾驶，刹车，停止发动机等，我们可以使用这些来做一些事情。
- en: 'So, we can abstract them into something called a vehicle that demonstrates
    these attributes and general behaviors. If we express this as a C++ class, it
    might look like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将它们抽象成一个称为车辆的东西，展示这些属性和一般行为。如果我们将其表达为C++类，可能会看起来像下面这样：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Vehicle` class is a more generalized (or abstract) expression of `Motorcycle`,
    `Car`, and `Truck`. We can now create more specialized types by reusing what is
    already available in the Vehicle class. We are going to reuse Vehicle''s properties
    and methods by using inheritance. The syntax for inheritance is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`类是`Motorcycle`，`Car`和`Truck`的更一般（或抽象）表达。我们现在可以通过重用Vehicle类中已有的内容来创建更专业化的类型。我们将通过继承来重用Vehicle的属性和方法。继承的语法如下：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have come across access modifiers such as `public`, `protected` and `private`
    before. They control how we have access to the base classes'' members. The Motorcycle
    class will be derived as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前遇到过`public`，`protected`和`private`等访问修饰符。它们控制我们如何访问基类的成员。Motorcycle类将派生如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, the Vehicle class is referred to as the **base class** or the
    **super class**, while the Motorcycle class is referred to as the **derived class**
    or **subclass**. Graphically, we can represent this as follows, where the arrows
    point from the derived class to the base class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Vehicle类被称为**基类**或**超类**，而Motorcycle类被称为**派生类**或**子类**。从图形上看，我们可以表示为下面的样子，箭头从派生类指向基类：
- en: '![Figure 2B.2: Vehicle class hierarchy'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.2：车辆类层次结构'
- en: '](img/C14583_02B_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_02.jpg)'
- en: 'Figure 2B.2: Vehicle class hierarchy'
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.2：车辆类层次结构
- en: 'But a motorcycle drives differently from a generic vehicle. So, we need to
    modify the `Motorcycle` class so that it behaves differently. The updated code
    will be as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但摩托车的驾驶方式与通用车辆不同。因此，我们需要修改`Motorcycle`类，使其行为不同。更新后的代码将如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we think about object-oriented design, this is about modeling a problem space
    in terms of objects that collaborate. These objects communicate with each other
    through messages. Now, we have two classes that respond to the same message (the
    `Drive()` method) in different ways. The sender of the message has no knowledge
    of what will happen and doesn't really care, and this is the essence of polymorphism.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑面向对象设计，这是关于以对象协作的方式对问题空间进行建模。这些对象通过消息相互通信。现在，我们有两个类以不同的方式响应相同的消息（`Drive()`方法）。发送消息的人不知道会发生什么，也不真的在乎，这就是多态的本质。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Polymorphism comes from the Greek words poly and morph, where `poly` means many
    and `morph` means form. So, polymorphism means `having many forms`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多态来自希腊词poly和morph，其中`poly`表示许多，`morph`表示形式。因此，多态意味着`具有多种形式`。
- en: 'We can now use these classes to try out polymorphism:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些类来尝试多态：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we compile and run this program, we get the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行此程序，我们会得到以下输出：
- en: '![Figure 2B.3: Vehicle program output'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.3：车辆程序输出'
- en: '](img/C14583_02B_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_03.jpg)'
- en: 'Figure 2B.3: Vehicle program output'
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.3：车辆程序输出
- en: 'In the preceding screenshot, the lines after the line `Vehicle::StartEngine
    1500 cc` are all related to the `Motorcycle`. But the Drive line still shows `Vehicle::Drive`
    and not the expected `Motorcycle::Drive`. What''s going on? The problem is that
    we have not told the compiler that the `Drive` method in the `Vehicle` class can
    be modified (or overridden) by a derived class. We need to make one change in
    our code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By adding the `virtual` keyword before the member function declaration, we
    are telling the compiler that a derived class can (but doesn''t have to) override
    or replace the function. If we make this change and then compile and run the program,
    we get the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.4: Vehicle program output with virtual methods'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.4: Vehicle program output with virtual methods'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, we have learned about inheritance and polymorphism. We used a pointer
    to a `Vehicle` class to control the `Motorcycle` class. Another change to the
    code should be made as a matter of best practice. We should also change the declaration
    of the `Drive` function in the `Motorcyle` as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'C++11 introduced the `override` keyword as a hint to the compiler, stating
    that a particular method should have the same function prototype as a method somewhere
    in its parent tree. If it cannot find one, then the compiler will report an error.
    This is a very useful feature and can save you from hours of debugging. If there
    is some way for the compiler to report an error, use it. The earlier a defect
    is detected, the easier it is to fix. One final change is that whenever we add
    a virtual function to a class, we must declare its destructor `virtual`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We saw this with the `Drive()` function before it was made virtual. When the
    destructor is called through the pointer to a Vehicle, it needs to know which
    destructor to call. Thus, making it virtual enables this. If you fail to do so,
    then you can end up with resource leaks or spliced objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and Access Specifiers
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned previously, the general form of inheriting one subclass from
    a super class is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we derived Motorcycle class from Vehicle class, we use the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The access modifier is optional and is one of the ones that we have met before:
    `public`, `protected`, and `private`. In the following table, you can see the
    accessibility of the base classes'' members. If access_modifier is omitted, then
    the compiler assumes private was specified.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.5: Accessibility of base class members in derived classes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.5: Accessibility of base class members in derived classes'
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Abstract Classes and Interfaces
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the classes that we have talked about up until now are **concrete class**
    – they can be instantiated as a type for a variable. There is another type of
    class – an **abstract class**– that contains at least one **pure virtual member
    function**. A pure virtual function is a virtual function that has no definition
    (or implementation) in the class. And because it has no implementation, the class
    is malformed (or abstract) and cannot be instantiated. If you attempt to create
    a variable of an abstract type, then the compiler will generate an error.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a pure virtual member function, end the function prototype declaration
    with `= 0`. To make Drive() a pure virtual function in the Vehicle class, we would
    declare it as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, to be able to use a derived class as a variable type (for example, the
    `Motorcycle` class), it must define an implementation of the `Drive()` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, declare a variable to be either a pointer to the abstract
    class or a reference to the abstract class. In either case, it must point to,
    or reference, some non-abstract class derived from the abstract class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there is a keyword interface that allows you to define a class that
    is all pure virtual functions. The same is achieved in C++ by declaring a class
    that only declares public pure virtual functions (and a virtual destructor). In
    this way, we define an interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before solving any practical in this chapter, download this book's GitHub repository
    ([https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus))
    and import the folder for Lesson 2B in Eclipse so that you can view the code for
    each exercise and activity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Implementing Game Characters with Polymorphism'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will demonstrate inheritance, interfaces, and polymorphism.
    We will start with an ad hoc implementation of a role-playing game and evolve
    it to be more generic and expandable. Let''s get started:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse and create a new project named **Lesson2B** using the files found
    in the **Lesson2B** examples folder.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a **CMake-based project**, change the current builder to **Cmake
    Build (portable)**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Project** | **Build All** menu to build all exercises. By default,
    the console at the bottom of the screen will display the **CMake console [Lesson2B]**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure a **New Launch Configuration** named **L2BExercise1** that runs the
    **Exercise1** binary and click on **Run** to build and run **Exercise 1**. You
    will receive the following output:![Figure 2B.6: Exercise 1 default output'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.6: Exercise 1 default output'
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open `speak()` and `act()` directly. This is fine for a small program. But
    as the game grew to tens or hundreds of characters, it would become unmanageable.
    So, we need to abstract all the characters. Add the following Interface declaration
    to the top of the file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Normally, the destructor would be empty, but here, it has logging to show the
    behavior.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Derive the `Wizard`, `Healer`, and `Warrior` classes from this interface class
    and add the `override` keyword to the end of the declarations of the `speak()`
    and `act()` functions for each class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Click the **Run** button to rebuild and run the exercise. We will now see that
    the base class destructor is also called after the destructor of the derived class:![Figure
    2B.7: Output of the modified program'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.7: Output of the modified program'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create the characters and manage them in a container such as a `vector`. Create
    the following two methods in the file, before the `main()` function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace the content of `main()` with the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Click the **Run** button to rebuild and run the exercise. Here is the output
    that is generated:![Figure 2B.8: Output of the polymorphic version'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.8: Output of the polymorphic version'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, the logging for **Destroying Wizard**
    and so on has disappeared. The problem is that the container holds the pointers
    to the base class and that it doesn't know how to call the full destructor in
    each case.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, simply declare the destructor for `ICharacter` as virtual:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Click the **Run** button to rebuild and run the exercise. The output now reads
    as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2B.9: Output from the full polymorphic version'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_09.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.9: Output from the full polymorphic version'
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have now implemented an interface to our `ICharacter` characters and used
    them polymorphically by simply calling the `speak()` and `act()` methods through
    a base class pointer stored in a container.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Classes, Structs, and Unions Revisited
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, we discussed that the difference between a class and a struct was
    the default access modifier – private for class and public for struct. This difference
    goes one step further – it applies to the base class if it does not specify anything:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It should be noted that a union can neither be a base class nor be derived
    from a base class. If there is essentially no difference between a struct and
    a class, then which type should we use? Essentially, it is one of convention.
    A **struct** is used to bundle together several related elements, while a **class**
    can do things and has responsibilities. An example of a struct is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，联合既不能是基类，也不能从基类派生。如果结构和类之间本质上没有区别，那么我们应该使用哪种类型？本质上，这是一种惯例。**结构**用于捆绑几个相关的元素，而**类**可以执行操作并具有责任。结构的一个例子如下：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we can see that it groups together three coordinates
    so that we can reason about a point in a 3D space. This structure can be passed
    as a coherent dataset to methods that need points, rather than three separate
    arguments per point. A class, on the other hand, models an object that can perform
    actions. Take a look at the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到它将三个坐标组合在一起，这样我们就可以推断出三维空间中的一个点。这个结构可以作为一个连贯的数据集传递给需要点的方法，而不是每个点的三个单独的参数。另一方面，类模拟了一个可以执行操作的对象。看看下面的例子：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A rule of thumb is to use a class if there is at least one private member as
    this implies that the details of the implementation will be behind the public
    member functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则是，如果至少有一个私有成员，则应使用类，因为这意味着实现的细节将在公共成员函数的后面。
- en: Visibility, Lifetime, and Access
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可见性、生命周期和访问
- en: We have talked about creating our own types and declaring variables and functions
    while mainly focusing on simple functions and a single file. We will now look
    at what happens when there are multiple source files (translation units) that
    contain classes and function definitions. Also, we'll check which variables and
    functions can be visible from the other parts of the source files, how long the
    variables live, and look at the difference between internal and external linkage.
    In *Chapter 1*, *Anatomy of Portable C++ Software*, we saw how the toolchain works
    to compile the source files and produce the object files and that the the linker
    puts it all together to form an executable program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了创建自己的类型和声明变量和函数，主要关注简单函数和单个文件。现在我们将看看当有多个包含类和函数定义的源文件（翻译单元）时会发生什么。此外，我们将检查哪些变量和函数可以从源文件的其他部分可见，变量的生存周期有多长，并查看内部链接和外部链接之间的区别。在*第1章*，*可移植C++软件的解剖学*中，我们看到了工具链是如何工作的，编译源文件并生成目标文件，链接器将其全部组合在一起形成可执行程序。
- en: 'When a compiler processes a source file, it generates an object file that contains
    the translated C++ code and enough information for the linker to resolve any references
    from the compiled source file to another source file. In *Chapter 1*, *Anatomy
    of Portable C++ Software*, `sum()`, which is defined in the **SumFunc.cpp** file.
    When the compiler constructs an object file, it creates the following segments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器处理源文件时，它会生成一个包含转换后的C++代码和足够信息的目标文件，以便链接器解析已编译源文件到另一个源文件的任何引用。在*第1章*，*可移植C++软件的解剖学*中，`sum()`在**SumFunc.cpp**文件中定义。当编译器构建目标文件时，它创建以下段：
- en: '**Code segment** (also known as text): This is the translation of the C++ functions
    into the target machine instructions.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码段**（也称为文本）：这是C++函数翻译成目标机器指令的结果。'
- en: '**Data segment**: This contains all the variables and data structures that
    are declared in the program, not local or allocated off the heap or stack, and
    are initialized.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据段**：这包含程序中声明的所有变量和数据结构，不是本地的或从堆栈分配的，并且已初始化。'
- en: '**BSS segment**: This contains all the variables and data structures that are
    declared in the program, not local or allocated off the heap or stack, and are
    not initialized (but will be initialized to zero).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BSS段**：这包含程序中声明的所有变量和数据结构，不是本地的或从堆栈分配的，并且未初始化（但将初始化为零）。'
- en: '**Database of exported symbols**: A list of variables and functions that are
    in this object file and their location.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出符号数据库**：此对象文件中的变量和函数列表及其位置。'
- en: '**Database of referenced symbols**: A list of variables and functions this
    object file needs from outside itself and where they are used.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用符号数据库**：此对象文件需要从外部获取的变量和函数列表以及它们的使用位置。'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: BSS is used to name the uninitialized data segment and its name is historically
    derived from Block Started by Symbol.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: BSS用于命名未初始化的数据段，其名称历史上源自Block Started by Symbol。
- en: 'The linker then collects all the code segments, data segments, and **BSS**
    segments together to form the program. It uses the information in the two databases
    (DB) to resolve all the referenced symbols to the exported symbols list and patch
    the code segments with this information so that they can operate correctly. Graphically,
    this is depicted as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，链接器将所有代码段、数据段和**BSS**段收集在一起形成程序。它使用两个数据库（DB）中的信息将所有引用的符号解析为导出的符号列表，并修补代码段，使其能够正确运行。从图形上看，这可以表示如下：
- en: '![Figure 2B.10: Parts of the object files and the executable file'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.10：目标文件和可执行文件的部分'
- en: '](img/C14583_02B_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_10.jpg)'
- en: 'Figure 2B.10: Parts of the object files and the executable file'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.10：目标文件和可执行文件的部分
- en: 'For the purposes of the discussion that follows, BSS and data segments will
    be referred to simply as data segment (the only difference being that BSS is not
    initialized). When a program is executed, it is loaded into memory and its memory
    looks a bit like the executable file layout – it contains the text segment, data
    segment, BSS segment, and free memory allocated by the host system, which contains
    what is known as the **stack** and the **heap**. The stack typically starts at
    the top of the memory and grows down, while the heap starts where BSS finishes
    and grows up, toward the stack:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.11: CxxTemplate runtime memory map'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.11: CxxTemplate runtime memory map'
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The section of the program in which a variable or identifier is accessible
    is known as the **scope**. There are two broad categories of scope:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '`{}`). The variable can be accessed inside the curly braces. Just like blocks
    can be nested, so can the scope of the variable. This typically includes local
    variables and function parameters, and these are generally stored in the stack.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global / file scope**: This applies to variables declared outside a normal
    function or class, as well as to the normal functions. The variable can be accessed
    anywhere in the file and possibly from other files (global) if the linkage is
    correct. These variables are allocated memory by the linker in the data segment.
    The identifiers are placed into the global namespace, which is the default namespace.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can think of a namespace as a dictionary of names of variables, functions,
    and user-defined types. For small programs, it is ok to use the global namespace
    as there is very little chance of you creating multiple variables with the same
    name and getting name clashes. As programs get larger, and more third-party libraries
    are included, the chance of name clashes increases. Therefore, library writers
    will put their code into a namespace (that is hopefully unique). This allows the
    programmer to control access to the identifiers in the namespace. By using the
    standard library, we have already been using the std namespace. A namespace is
    declared like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is usual for name_of_namespace to be short, and namespaces can be nested.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A good use of namespaces can be seen in the boost libraries here: [https://www.boost.org/](https://www.boost.org/).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable has another attribute, that of **lifetime**. There are three fundamental
    lifetimes; two that are managed by the compiler and one that the programmer chooses:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic lifetime**: Local variables are created when they are declared
    and are destroyed upon exiting the scope that they are in. These are managed by
    the stack.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permanent lifetime**: Global variables and static local variables. The compiler
    causes global variables to be created when the program begins (before entering
    the main() function) and causes static local variables to be created when they
    are first accessed. In both cases, the variable is destroyed when the program
    exits. These variables are placed in the data segments by the linker.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new` and `delete`). These variables have their memory allocated from the heap.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final attribute of a variable we will consider is **linkage**. Linkage
    indicates what the compiler and linker will do if they encounter variables and
    functions that have the same name (or identifier). For a function, its actually
    what is known as the mangled name – the compiler uses the name of the function,
    its return type, and its argument types to produce a mangled name. There are three
    types of linkage:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**No linkage**: This means that the identifier only refers to itself and applies
    to local variables and locally defined user types (that is, inside a block).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal linkage**: This means that the identifier can be accessed anywhere
    in the file in which it is declared. This applies to static global variables,
    const global variables, static functions, and any variables or functions declared
    in an anonymous namespace within the file. An anonymous namespace is a namespace
    with no stated name.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部链接**：这意味着可以在声明它的文件中的任何地方访问该标识符。这适用于静态全局变量、const全局变量、静态函数以及文件中匿名命名空间中声明的任何变量或函数。匿名命名空间是一个没有指定名称的命名空间。'
- en: '**External linkage**: This means that, with the right forward declarations,
    it can be accessed from within all files. This includes normal functions, non-static
    global variables, extern const global variables, and user-defined types.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部链接**：这意味着在正确的前向声明的情况下，可以从所有文件中访问它。这包括普通函数、非静态全局变量、extern const全局变量和用户定义类型。'
- en: While these are termed linkages, only the last one actually involves the linker.
    The other two are achieved by the compiler excluding information from the DB of
    exported identifiers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些被称为链接，但只有最后一个实际上涉及链接器。其他两个是通过编译器排除导出标识符数据库中的信息来实现的。
- en: Templates – Generic Programming
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板-泛型编程
- en: 'As a computer scientist, or as a programming enthusiast, at some point in time,
    you probably had to write one (or more) sort algorithms. When discussing the algorithm,
    you were not particularly concerned about the type of data being sorted, just
    that the two objects of that type could be compared and that the domain is a totally
    ordered set (that is, if one object is compared with any other, you can determine
    which comes first). Different programming languages provide different solutions
    to this problem:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为计算机科学家或编程爱好者，您可能在某个时候不得不编写一个（或多个）排序算法。在讨论算法时，您可能并不特别关心正在排序的数据类型，只是该类型的两个对象可以进行比较，并且该域是一个完全有序的集合（也就是说，如果一个对象与任何其他对象进行比较，您可以确定哪个排在前面）。不同的编程语言为这个问题提供了不同的解决方案：
- en: '`swap` function.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap`函数。'
- en: '`void pointer`. `size_t` size defines how big each object is, while the `compare()`
    function defines how to compare the two objects.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void指针`。`size_t`大小定义了每个对象的大小，而`compare()`函数定义了如何比较这两个对象。'
- en: '`std::sort()` is a function provided in its standard library, where one of
    its signatures is as follows:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort()`是标准库中提供的一个函数，其中一个签名如下：'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, the details of the type are captured in the iterator type called
    `RandomIt` and passed to the method when compiled.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类型的细节被捕获在名为`RandomIt`的迭代器类型中，并在编译时传递给方法。
- en: In the next section, we will briefly define generic programming, show how C++
    implements them through templates, highlight what the language already provides,
    and discuss how the compiler deducts the types so that they can be used for the
    template.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要定义泛型编程，展示C++如何通过模板实现它们，突出语言已经提供的内容，并讨论编译器如何推断类型，以便它们可以用于模板。
- en: What is Generic Programming?
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是泛型编程？
- en: When you developed a sort algorithm, you may have originally focused on just
    sorting plain numbers. But once that is established, you could then abstract that
    to any type, provided that the type exhibits certain attributes such as total
    ordered set (that is, the comparison operator, <, has meaning between all the
    elements in the domain we are sorting over). So, to express an algorithm in terms
    of generic programming, we define a placeholder in the algorithm for the type
    that needs to be manipulated by that algorithm.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开发排序算法时，您可能最初只关注对普通数字的排序。但一旦建立了这一点，您就可以将其抽象为任何类型，只要该类型具有某些属性，例如完全有序集（即比较运算符<在我们正在排序的域中的所有元素之间都有意义）。因此，为了以泛型编程的方式表达算法，我们在算法中为需要由该算法操作的类型定义了一个占位符。
- en: '**Generic programming** is the development of a type-agnostic general algorithm.
    The algorithm can be reused by passing types as arguments. In this way, algorithms
    are abstracted and allow the compiler to optimize based on types.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型编程**是开发一种类型不可知的通用算法。通过传递类型作为参数，可以重用该算法。这样，算法被抽象化，并允许编译器根据类型进行优化。'
- en: In other words, generic programming is an approach to programming where an algorithm
    is defined with types as parameters that are specified when the algorithm is instantiated.
    Many languages provide support for generic programming with different names. In
    C++, generic programming is supported through the language feature known as templates.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，泛型编程是一种编程方法，其中算法是以参数化的类型定义的，当实例化算法时指定了参数。许多语言提供了不同名称的泛型编程支持。在C++中，泛型编程是通过模板这种语言特性来支持的。
- en: Introducing C++ Templates
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍C++模板
- en: 'Templates are C++''s support for generic programming. Think of a template as
    a cookie cutter, and the type that we give it as a parameter as cookie dough (which
    can be chocolate brownie, ginger snap, or some other delicious flavor). When we
    apply the cookie cutter, we end up with instances of cookies that are in the same
    form but have different flavors. So, a template captures the definition of a generic
    function or class and when specified with types as arguments, the compiler goes
    to work to write the class or function for us as if the type was hand-coded by
    us. It has several advantages, such as the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++对泛型编程的支持。把模板想象成一个饼干模具，我们给它的类型参数就像饼干面团（可以是巧克力布朗尼、姜饼或其他美味口味）。当我们使用饼干模具时，我们得到的饼干实例形式相同，但口味不同。因此，模板捕获了泛型函数或类的定义，当指定类型参数时，编译器会根据我们手动编码的类型来为我们编写类或函数。它有几个优点，例如：
- en: You only need to develop the class or algorithm once and evolve it.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只需要开发一次类或算法，然后进行演化。
- en: You can apply it to many types.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将其应用于许多类型。
- en: You can hide complex details behind a simple interface and the compiler can
    apply optimizations to the generated code, based on the type.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将复杂细节隐藏在简单的接口后，编译器可以根据类型对生成的代码进行优化。
- en: 'So, how do we write a template? Let''s start with a template that will allow
    us to clamp a value within a range from `lo` to `hi` and be able to use it on
    `int`, `float`, `double`, or any other built-in type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s break this down:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '`template <class T>` declares what follows to be a template and uses one type,
    which has a placeholder of `T` in the template.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T` is substituted. It declares that the function clamp takes three arguments
    of type `T` and returns a value of type `T`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<` operator, then we can perform a clamp on the three values so that `lo <=
    val <= hi`. This algorithm is valid for all the types that can be ordered.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say we use it in the following program:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will get the following expected output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.12: Clamp program output'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_12.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.12: Clamp program output'
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the last call to clamp, we have passed the template the double type between
    `<` and `>`. But we haven't followed the same for the other four calls. Why? It
    turns out that the compiler is getting smarter as it gets older. With every release
    of the standard, they improve what is known as **type deduction**. Because the
    compiler is able to deduce the type, we do not need to tell it what type to use.
    The reason for this is that the three arguments to the class without the template
    parameter have the same type – the first three are all int while the fourth one
    is double. But we had to tell the compiler which type to use for the final one
    because it has two doubles and an int as arguments, which resulted in a compilation
    error saying no function found. But then, it gave us information about why the
    template could not be used. This form, where you force the types, is known as
    **explicit template argument specification**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: C++ Pre-Packaged Templates
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C++ Standard is comprised of two major parts:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The language definition, that is, the keywords, syntax, lexical definitions,
    structures, and so on.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Standard Library, that is, all the pre-written general-purpose functions
    and classes to be provided by the compiler vendor. A subset of this library is
    implemented using templates and is known as the **Standard Template Library**
    (**STL**).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STL has origins in the generics provided in the Ada language that was developed
    by David Musser and Alexander Stepanov. Stepanov was a strong advocate for the
    use of generic programming as the basis for software development. In the 90s,
    he saw the opportunity to do this with the new language C++ to influence mainstream
    development, and proposed to the ISO C++ committee that the STL should be included
    as part of the language. The rest is history.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL is comprised of four categories of predefined generic algorithms and
    classes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers**: General sequence (vector, list, deque) and associative containers
    (set, multiset, map)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`begin()` and `end()`). Note that one fundamental design choice in the STL
    is that `end()` points to a position one after the last item – mathematically,
    that is [`begin()`, `end()`).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithms**: Over 100 different algorithms covering sorting, searching,
    set operations, and others.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_if()`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The clamp function template that we implemented previously is simplistic and
    while it would work for any type that supports the less than operator, it would
    not be very efficient – it could result in very large copies if the type has a
    large size. Since C++17, the STL includes a `std::clamp()` function that is declared
    more like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, it uses references for the arguments and the return value. Changing
    the arguments to use references reduces what has to be passed on and returned
    on the stack. Also, note that the designers have worked to produce a more general
    version of the template so that we are not reliant on the < operator that exists
    for the type. However, we can define the ordering by passing comp.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding examples, we have seen that, like functions, templates can
    take multiple comma-separated parameters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Type Aliases – typedef and using
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have used the `std::string` class, then you have been using an alias.
    There are a few template classes related to strings that need to implement the
    same functionality. But the type representing a character is different. For example,
    for `std::string`, the representation is `char`, while `std::wstring` uses `wchar_t`.
    There are several others for `char16_t` and `char32_t`. Any variation in the functionality
    will be managed through traits or template specialization.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了`std::string`类，那么您一直在使用别名。有一些与字符串相关的模板类需要实现相同的功能。但是表示字符的类型是不同的。例如，对于`std::string`，表示是`char`，而`std::wstring`使用`wchar_t`。还有一些其他的用于`char16_t`和`char32_t`。任何功能上的变化都将通过特性或模板特化来管理。
- en: 'Prior to C++11, this would have been aliased from the `std::basic_string` base
    class, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，这将从`std::basic_string`基类中进行别名处理，如下所示：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This does two main things:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这做了两件主要的事情：
- en: 'Reduces the amount of typing required to declare the variable. This is a simple
    case, but when you declare a unique pointer to a map of strings to object, it
    can get very long and you will make errors:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少声明变量所需的输入量。这是一个简单的情况，但是当你声明一个指向字符串到对象的映射的唯一指针时，可能会变得非常长，你会犯错误：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Improves the readability as you now conceptually think of it as a string and
    do not need to worry about the details.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了可读性，因为现在你在概念上将其视为一个字符串，不需要担心细节。
- en: 'But C++11 introduced a better way – `alias declarations` – which utilizes the
    `using` keyword. The preceding code can be implemented like so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是C++11引入了一种更好的方式 - `别名声明` - 它利用了`using`关键字。前面的代码可以这样实现：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding example is simple and the alias, either typedef or using, is
    not too hard to grok. But when the alias involves more complicated expressions,
    they too can be a little unreadable – particularly function pointers. Consider
    the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子很简单，别名，无论是typedef还是using，都不太难理解。但是当别名涉及更复杂的表达式时，它们也可能有点难以理解 - 特别是函数指针。考虑以下代码：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, consider the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is a reason for the new feature in C++11 where alias declaration may be
    incorporated easily into templates – they can be templatized. A `typedef` cannot
    be templatized and while it is possible to achieve the same outcome with `typedef`,
    the alias declaration (`using`) is the preferred method as it results in simpler
    and easier to understand template code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: C++11中有一个新功能，即别名声明可以轻松地并入模板中 - 它们可以被模板化。`typedef`不能被模板化，虽然可以通过`typedef`实现相同的结果，但别名声明（`using`）是首选方法，因为它会导致更简单、更易于理解的模板代码。
- en: 'Exercise 2: Implementing Aliases'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：实现别名
- en: 'In this exercise, we will implement aliases using a typedef and see how the
    code becomes easier to read and efficient by using a reference. Follow these steps
    to implement this exercise:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用typedef实现别名，并看看通过使用引用使代码变得更容易阅读和高效。按照以下步骤实现这个练习：
- en: Open the **Lesson2B** project in Eclipse, and then in the Project Explorer,
    expand **Lesson2B**, then **Exercise02** and double-click on **Exercise2.cpp**
    to open the file for this exercise in the editor.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2B**项目，然后在项目资源管理器中展开**Lesson2B**，然后展开**Exercise02**，双击**Exercise2.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** dropdown menu and select **New Launch
    Configuration…**. Configure **L2BExercise2** to run with the name **Exercise2**.
    When that is complete, it will be the currently selected Launch Configuration.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，然后选择**新启动配置...**。配置**L2BExercise2**以使用名称**Exercise2**运行。完成后，它将成为当前选择的启动配置。
- en: 'Click on the **Run** button. **Exercise 2** will run and produce something
    similar to the following output:![Figure 2B.13: Exercise 2 output'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。**Exercise 2**将运行并产生类似以下输出：![图2B.13：练习2输出
- en: '](img/C14583_02B_13.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_13.jpg)'
- en: 'Figure 2B.13: Exercise 2 output'
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.13：练习2输出
- en: 'In the editor, before the declaration of the `printVector()` function, add
    the following line:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，在`printVector()`函数的声明之前，添加以下行：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, change all occurrences of `std::vector<int>` in the file with `IntVector`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将文件中所有的`std::vector<int>`更改为`IntVector`。
- en: Click on the **Run** button. The output should be the same as before.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。输出应与以前相同。
- en: 'In the editor, change the line that you previously added to the following:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，更改之前添加的行为以下内容：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Click on the **Run** button. The output should be the same as before.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。输出应与以前相同。
- en: 'In the editor, add the following line:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，添加以下行：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, change the one occurrence of `IntVector::iterator` to `IntVectorIter.`
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`IntVector::iterator`的一个出现更改为`IntVectorIter`。
- en: Click on the **Run** button. The output should be the same as before.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。输出应与以前相同。
- en: In this exercise, there appears to be little difference between typedef and
    using alias. In either case, the use of a well-named alias makes code easier to
    read and understand. When more complicated aliases are involved, `using` produces
    an easier way to write an alias. Introduced in C++11, `using` is now the preferred
    method for defining an alias. It has other advantages over `typedef`, such as
    being able to use it inside templates.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，typedef和使用别名似乎没有太大区别。在任何一种情况下，使用一个命名良好的别名使得代码更容易阅读和理解。当涉及更复杂的别名时，`using`提供了一种更容易编写别名的方法。在C++11中引入，`using`现在是定义别名的首选方法。它还比`typedef`有其他优点，例如能够在模板内部使用它。
- en: Templates – More than Generic Programming
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板 - 不仅仅是泛型编程
- en: Templates can also deliver much more than just generic programming (a cookie
    cutter with types). In the case of generic programming, the template operates
    as a blueprint that cannot be changed and delivers the compiled version of the
    template for the specified type or types.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 模板还可以提供比泛型编程更多的功能（一种带有类型的模板）。在泛型编程的情况下，模板作为一个不能更改的蓝图运行，并为指定的类型或类型提供模板的编译版本。
- en: Templates can be written to provide specialization of a function or algorithm
    based on the types involved. This is known as **template specialization** and
    is not generic programming in the sense we previously used it. It can only be
    called generic programming when it makes certain types behave as we would expect
    them to do in a given context. It cannot be called generic programming when the
    algorithm that's used for all types is modified.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine the following sample of specialization code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It defines a template that calls `printf()` with a different format string,
    based on the specialization of the template using `std::enable_if_t<>` and `sizeof()`.
    When we run it, the following output is generated:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.14: Erroneous print template program output'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_14.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.14: Erroneous print template program output'
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Substitution Failure Is Not An Error – SFINAE
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The value printed for `32.1F` (`-1073741824`) does not bear any resemblance
    to the number. If we examine the code that was generated by the compiler for the
    following program, we will find that it has generated the code as if we wrote
    the following (and more):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Why does it generate this code? The preceding templates use a feature of the
    C++ compiler called `std::enable_if_t<>` and access what are known as **type traits**
    to help us. Firstly, we will replace the last template with the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This takes some explaining. Firstly, we consider the definition of `std::enable_if_t`,
    which is actually a type alias:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first template for `enable_if` will result in the definition of an empty
    struct (or class). The second template for `enable_if` is a specialization for
    true as a first template argument that will result in the class with a typedef
    definition. The definition of `enable_if_t` is a helper template that removes
    the need for us to enter `::type` on the end of the template when we use it. So,
    how does this work? Consider the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the condition that is evaluated at compile time results in `enable_if_t`
    template will result in a template that looks like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is valid syntax and the function is added to the symbol table as a candidate
    function. If the condition that is calculated at compile time results in `enable_if_t`
    template will result in a template that looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is **malformed code** which is now discarded – SFINAE at work.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '`std::is_floating_point_v<T>` is another helper class that accesses the `::value`
    member of the `std::is_floating_point<T>` template. Its name says it all – it
    will be true if T is a floating-point type (float, double, long double); otherwise,
    it will be false. If we make this change, then the compiler (GCC) generates the
    following error:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.15: Compiler error for the modified print template program'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_15.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.15: Compiler error for the modified print template program'
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The problem now is that we have two templates that can satisfy when the type
    is a float:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It turns out that (usually) `sizeof(float) == sizeof(int)`, so we need to make
    another change. We'll replace the first condition with another type trait – `std::is_integral_v<>:`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we make this change, then the compiler (GCC) generates the following error:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.16: Second compiler error for the modified print template program'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_16.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.16: Second compiler error for the modified print template program'
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We fixed the floating-point ambiguity, but the problem here is that `std::is_integral_v(char)`
    returns true and again there are two functions that are generated by the templates
    for a type of char with the same prototype. It turns out that the conditions that''s
    passed to `std::enable_if_t<>` obeys standard C++ logic expressions. So, to fix
    this problem, we will add an extra condition that will exclude chars:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we compile the program now, it completes the compilation and links the program.
    If we run it, it now produces the following (expected) output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.17: Corrected print template program output'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_17.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.17: Corrected print template program output'
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Floating-Point Representations
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shouldn't that `32.099998` be `32.1`? That is what was passed to the function.
    The problem with performing floating-point operations on a computer is that the
    representation automatically introduces an error. Real numbers form a continuous
    (infinite) domain. If you consider the numbers 1 and 2 in the real domain, then
    there is an infinite amount of real numbers between them. Unfortunately, a computer's
    representation of floating-point numbers quantizes the values and cannot represent
    all of the infinite number of numbers. The bigger the number of bits used to store
    the number, the better the representation of the value is on the real domain.
    So, long double is better than double is better than float. It really depends
    on your problem domain as to what is appropriate for storing the data. Back to
    `32.099998`. The computer stores the single precision numbers as the sum of powers
    of 2 and then shifts them by a power factor. Integral numbers are usually easy
    as they can be easily represented by the sum of `2^n` powers (n>=0). The fractional
    part, which in this case is 0.1, has to be expressed as the sum of `2^(-n) (n>0)`.
    We add more power-2 fractions to attempt to get the number closer to the target
    until we have used up the 24 bits that we have for precision in a single precision
    floating-point number.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to know more about how computers store floating-point numbers, research
    the IEEE 754 standard that defines it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Constexpr if Expressions
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++17 introduced the `constexpr if` expression to the language, which simplifies
    template writing greatly. We can rewrite the preceding three templates that use
    SFINAE as one simpler template:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the call to `print(55)`, the compiler generates the function to call as
    follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What happened to the if/else if statements? What happens with a `constexpr if`
    expression is that the compiler contextually determines the value of the condition
    and converts it into a bool value (true/false). If the evaluated value is true,
    then the if condition and the else clause are discarded, leaving only the true
    clause to generate code. Likewise, if it is false, then the false clause is left
    to generate code. In other words, only the first constexpr if condition that evaluates
    to true will have the code for its clause generated, while the rest are discarded.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Non-Type Template Arguments
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have only seen template arguments that are types. It is also possible
    to pass an integral value as a template argument. This allows us to prevent array
    decay for a function. For example, consider a template function that calculates
    the `sum`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this case, we need to pass the length of the array in the call:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: But wouldn't it be better if we could just call the following?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can do it by making changes to the template, like in the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we changed the data to be a reference to an array of a certain size –
    a size that is passed to the template – and so the compiler figures it out. We
    no longer need the second argument to the function call. This simple example showed
    how to pass and use a non-type argument directly. We will explore this more in
    the *Template Type Deduction* section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Implementing Stringify – specialization Versus constexpr'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement a stringify template by utilizing constexpr
    to produce an easier to read and simpler version of the code. Follow these steps
    to implement this exercise:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The stringify specialization templates can be found at [https://isocpp.org/wiki/faq/templates#template-specialization-example](https://isocpp.org/wiki/faq/templates#template-specialization-example).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2B** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2B**, then **Exercise03**, and double-click on **Exercise3.cpp**
    to open the file for this exercise in the editor.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** dropdown menu and select **New Launch
    Configuration…**. Configure **L2BExercise3** to run with the name **Exercise3**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. **Exercise 3** will run and produce the following
    output:![Figure 2B.18: Exercise 3 specialized template output'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_18.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.18: Exercise 3 specialized template output'
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In **Exercise3.cpp**, comment out all of the template specializations for the
    stringify template while leaving the original general template.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. The output will change to have the boolean printed
    as a number and the double printed to only two decimal places:![Figure 2B.19:
    Exercise 3 general template only output'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_19.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.19: Exercise 3 general template only output'
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We will now "specialize" the template for the boolean type again. Add the `#include
    <type_traits>` directive with the other `#includes` and modify the template so
    that it reads as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Click on the **Run** button. The output boolean stringify works as before:![Figure
    2B.20: stringify tailored for boolean'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_20.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.20: stringify tailored for boolean'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We will now "specialize" the template for the floating-point types (`float`,
    `double`, `long double`) again. Modify the template so that it reads as follows:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Click on the **Run** button. The output is restored to the original:![Figure
    2B.21: constexpr if version template output'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_21.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.21: constexpr if version template output'
  id: totrans-304
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you compare the original version with multiple templates to the final version,
    you will find that the final version is more like a normal function and is easier
    to read and maintain.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the exercise, we learned how much simpler and compact our templates can be
    when using the new constexpr if construct in C++17.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Function Overloading Revisited
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we first discussed function overloading, we only considered the scenarios
    where the name of the function came from the list of functions that we wrote by
    hand. Now, we need to update this. We can also write templated functions that
    can have the same name. Like we did previously, when the compiler meets the line
    `print(55)`, it needs to work out which of the previously defined functions to
    call. So, it performs the following process (grossly simplified):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.22: Function overload resolution with templates (simplified)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_22.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.22: Function overload resolution with templates (simplified)'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Template Type Deduction
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we first introduced templates, we touched on Template type deduction.
    Now, we are going to explore this further. We will start by considering the general
    declaration for a function template:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The call for this might look like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When the compiler reaches this line, it must now deduce two types related to
    the template – `T` and `ParamType`. These are often different due to qualifiers
    and other attributes attached to the T in the ParamType (for example pointer,
    reference, const, and so on). The types are related but the deduction progresses
    differently, depending on the form of `expression` used.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Deduced Types
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we look into the different forms, it might be useful if we could get
    the compiler to tell us the types that it has deduced. We have a few options here,
    including the IDE editors showing types, the compiler generating errors, and runtime
    support (which, due to the C++ standard, is not necessarily effective). We will
    use the compiler errors to help us explore some of the type deductions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve a type displayer by declaring a template without a definition.
    Any attempt to instantiate the template will cause the compiler to generate an
    error message as there is no definition, along with the type information that
    it is trying to instantiate:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s attempt to compile the following program:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The compiler spits out the following errors:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.23: Compiler errors showing deduced types'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_23.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.23: Compiler errors showing deduced types'
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that, in each case, the aggregate being named includes the type being deduced
    – for x, it is an int, for y, an unsigned int, and for x+y, an unsigned int. Also,
    note that the TypeDisplay template requires a type for its arguments and so the
    `decltype()` function is used to get the compiler to provide the type for the
    expression in brackets.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to display the deduced type at runtime either using the
    built-in `typeid(T).name()` operator, which returns a std::string, or by using
    the boost library called type_index.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For more information on this, visit the following link: [https://www.boost.org/doc/libs/1_70_0/doc/html/boost_typeindex.html](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_typeindex.html).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Because of the type deduction rules, the built-in operator will give you an
    indication of the type, but it will lose reference (`&`, and `&&`) and any constness
    information (const or volatile). If required at runtime, then consider `boost::type_index`,
    which will produce the same output for all the compilers.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Template Type Deduction – the Details
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s return to the generic template:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s say that the call looks like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Type deduction proceeds differently depending on the form of ParamType used:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '**ParamType is a value (T)**: Pass-by-value function call'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ParamType is a reference or pointer (T& or T*)**: Pass-by-reference function
    call'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ParamType is a rvalue reference (T&&)**: Pass-by-reference function call
    or something else'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case 1: ParamType is pass-by-value (T)**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As a pass-by-value call, this means that the parameter will be a copy of whatever
    is passed in. Because this is a new instance of the object, the following rules
    are applied to the expression:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: If the expression's type is a reference, then ignore the reference part.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If, after step 1, the remaining type is const and/or volatile, then ignore those
    as well.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What''s left is T. Let''s attempt to compile the following file code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The compiler produces the following error:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.24: Compiler error showing a deduced type for the pass by type'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_24.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.24: Compiler error showing a deduced type for the pass by type'
  id: totrans-352
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So, the type is deduced to be `int`. Likewise, we get exactly the same error
    if we declare the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The same will happen if we declare this version:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In all three cases, the deduced type is `int`, as per the rules stated previously.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 2: ParamType is pass-by-reference (T&)**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'As a pass-by-reference call, this means that the parameter will be able to
    access the original storage location of the object. Because of this, the generated
    function has to honor the constness and volatileness we ignored before. The following
    rules are applied to type deduction:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: If the expression's type is a reference, then ignore the reference part.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern match what's left of the type of expression with ParamType to determine
    T.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s attempt to compile the following file:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The compiler will generate the following error:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.25: Compiler error showing the deduced type for pass by reference'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_25.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.25: Compiler error showing the deduced type for pass by reference'
  id: totrans-367
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From this, we can see that the compiler has T as an `int` from ParamType as
    `int&`. Changing x to be a const int provides no surprises as T is deduced to
    be `const int` from ParamType as `const int&`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.26:  Compiler error showing the deduced type for pass by const
    reference'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_26.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.26: Compiler error showing the deduced type for pass by const reference'
  id: totrans-371
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Likewise, introducing rx as a reference to a const int, as before, gives no
    surprises, as T is deduced to be `const int` from ParamType as `const int&`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![Figure 2B.27: Compiler error showing the deduced type when passing a const
    reference'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_27.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.27: Compiler error showing the deduced type when passing a const
    reference'
  id: totrans-376
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we change the declaration to include a const, then the compiler will honor
    the constness when it generates the function from the template:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This time, the compiler reports the following
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '`int x`: T is int (as the constness will be honored), while the parameter''s
    type is `const int&`.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int x`: T is int (const is in the pattern, leaving int), while the parameter''s
    type is `const int&`.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int& rx`: T is int (reference is ignored, const is in the pattern, leaving
    int), while the parameter''s type is `const int&`.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we attempt to compile the following, what do we expect? Normally, an array
    decays to be a pointer:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The compiler error is as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.28:  Compiler error showing the deduced type for the array argument'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: when passed by reference
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_28.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.28: Compiler error showing the deduced type for the array argument
    when passed by reference'
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This time, the array is captured as a reference and the size is also included.
    So, if ary was declared as `ary[10]`, then a completely different function would
    result. Let''s revert the template to the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we attempt to compile the array call, then the error reports the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.29: Compiler error showing the deduced type for the array argument'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: when passed by value
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_29.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.29: Compiler error showing the deduced type for the array argument
    when passed by value'
  id: totrans-396
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that, in this case, the array has decayed as the usual behavior when
    passing an array to a function. We saw this behavior when talking about *Non-Type
    Template Arguments*.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 3: ParamType is a rvalue reference (T&&)**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'T&& is called a rvalue reference while T& is called a lvalue reference. C++
    not only characterizes an expression by type but also by a property called the
    **value category**. These categories control expression evaluation in the compiler,
    including the rules for creating, copying, and moving temporary objects. There
    are five expression value categories defined in the C++17 standard that have the
    following relationships:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.30: C++ value categories'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_30.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.30: C++ value categories'
  id: totrans-402
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The definitions of each are as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: An expression that determines the identity of an object is a `glvalue`.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression whose evaluation initializes an object or the operand of an operator
    is a `prvalue`. Examples include a literal (except string literal) such as 3.1415,
    true or nullptr, the this pointer, post increment, and post decrement expressions.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A glvalue object that has resources and can be reused (because its life is ending)
    is an `xvalue`. Examples include a function call whose return type is an rvalue
    reference to an object, such as `std::move()`.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A glvalue that is not an xvalue is an `lvalue`. Examples include the name of
    a variable, a function or a data member, or a string literal.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prvalue or xvalue is an `rvalue`.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It does not matter if you do not fully understand these for the explanation
    that follows – just know that an expression that is considered to be an lvalue
    can have its address taken (using the address of operator, that is, "&"). The
    type deduction rules for the following require that you know what an lvalue is,
    as well as what it isn''t:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The type deduction rules for this ParamType form are as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: If the expression is an lvalue reference, then both T and ParamType are deduced
    to be an lvalue reference. This is the only scenario where the type is deduced
    to be a reference.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the expression is an rvalue reference, then the rules for Case 2 apply.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFINAE Expression and Trailing Return Types
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++11 introduced a feature called `trailing return types` to provide a mechanism
    for templates so that they can generalize the return type. A simple example is
    as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, `auto` is used to indicate that a trailing return type is defined. The
    trailing return type starts with the `->` pointer and in this case, the return
    type is the type that's returned by multiplying `a` and `b`. The compiler will
    process the content of the decltype and, if it is malformed, it will remove the
    definition from the function name's lookup, as per usual. This capability opens
    up many possibilities as the comma operator, "`,`", can be used inside `decltype`
    to check for certain attributes.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to test that a class implements a method or contains a type then
    we can place this inside the decltype by converting it into a void (in case the
    comma operator has been overloaded) and then define an object of the real return
    type at the end of the comma operator. An example of this is shown in the following
    program:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When this program is compiled and executed, we obtain the following output:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.31: Output from the SFINAE expression'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_31.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.31: Output from the SFINAE expression'
  id: totrans-423
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The return type is given by the following code:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s break this down:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: The operand of `decltype` is a comma-separated list of expressions. This means
    that the compiler will construct but not evaluate the expressions and use the
    type of the right-most value to determine the return type for the function.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::declval<T>()` allows us to convert the T type into a reference type that
    we can then use to access member functions without having to actually construct
    an object.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with all SFINAE-based operations, if any expression in the comma-separated
    list is invalid, then the function is discarded. If they are all valid, then it
    is added to the list of functions for lookup.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cast to void is to prevent any problems that may arise if the user overloads
    the comma operator.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, this is testing whether the `C` class has a member function called
    `find()` that takes `class T`, `class T&`, or `const class T&` as an argument.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method will work for `std::set`, which has a `find()` method that takes
    one argument but will fail for other containers because they do not have a `find()`
    member method.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach works well if we are only dealing with one type. But if we have
    a function that needs to produce different implementations based on type, as we
    have seen before, the `if constexpr` approach is much cleaner and generally easier
    to understand. To use the `if constexpr` approach, we need to produce templates
    that will evaluate to `true` or `false` at compile time. The standard library
    provides helper classes for this: `std::true_type` and `std::false_type`. These
    two structures have a static constant member named value set to `true` and `false`,
    respectively. Using SFINAE and template overloads, we can create new detection
    classes that derive from either of these classes to give us the desired outcome:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The first template for `test_find` creates the default behavior that will set
    the return type to `std::false_type`. Note that this has an argument type of `long`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The second template for `test_find` creates a specialization that tests for
    a class that has a member function called `find()` and has a return type of `std::true_type`.
    Note that this has an argument type of `int`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The `has_find<T,A0>` template works by deriving itself from the return types
    of the `test_find()` functions. If the T class does not have the `find()` method,
    then only the `std::false_type` version of `test_find()` is generated and so the
    `has_find<T,A0>::value` value will be false and can be used in `if constexpr()`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part occurs if the T class has the `find()` method as both of
    the `test_find()` methods are generated. But the specialized version takes an
    argument of the `int` type while the default takes an argument of the `long` type.
    As we "call" the function with zero (0), it will match the specialized version
    and use it. The argument difference is important because you cannot have two functions
    with the same argument types and only differ by return type. If you want to check
    this behavior, then change the argument from 0 to 0L to force the long version.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Class Templates
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only dealt with function templates so far. But templates can also be
    used to provide blueprints for classes. The general structure of a templated class
    declaration is as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Whereas template functions allow us to produce generic algorithms, template
    classes allow us to produce generic data types and their associated behaviors.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: When we introduced the Standard Template Library, we highlighted that it includes
    templates for containers – `vector`, `deque`, `stack`, and so on. These templates
    allow us to store and manage any data type that we want, but still behave as we
    would expect.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Writing a Class Template'
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two of the most commonly used data structures in computing science are stack
    and queue. Both currently have implementations in the STL. But to get our feet
    wet with a templated class, we are going to write a stack template class that
    can be used for any type. Let''s get started:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2B** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2B**, then **Exercise04**, and double-click on **Exercise4.cpp**
    to open the file for this exercise in the editor.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a new **Launch Configuration**, **L2BExercise4**, to run with the
    name **Exercise4**.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, configure a new C/C++ Unit Run Configuration, **L2BEx4Tests**, to run
    **L2BEx4tests**. Set the **Google Tests Runner**.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** option for the test, which we have to run for the first
    time:![Figure 2B.32: Initial unit test for stacks'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_32.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.32: Initial unit test for stacks'
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open `#pragma once`) which tells the compiler that if it encounters this file
    again to be #included, it does not need to be. While not strictly part of the
    standard, nearly all modern C++ compilers support it. Finally, note that, for
    the purpose of this exercise, we have chosen to store the items in the STL vector.'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, add the following declaration in the `public` section of the
    `Stack` class:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'At the top of the file, change **EXERCISE4_STEP** to a value of **10**. Click
    on the **Run** button. The Exercise 4 tests should run and fail:![Figure 2B.33:
    Jumping to a Failing test'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_33.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.33: Jumping to a Failing test'
  id: totrans-457
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on the name of the failing test, that is, `empty()` reports false.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `ASSERT_FALSE` to `ASSERT_TRUE` and rerun the test. This time, it passes
    because it is testing the right thing.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next thing we will do is add some type aliases ready for use with the next
    few methods. In the editor, add the following lines just above the `empty()` method:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Click on the **Run** button to rerun the tests. They should pass. When doing
    test-driven development, the mantra is to write a small test and see it fail,
    and then write just enough code to make it pass. In this case, we actually tested
    that we got the definition of the aliases correct because failing to compile is
    one form of test failure. We are now ready to add the push function.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change **Stack.hpp** by adding the following code just below
    the **empty()** method:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: At the top of the file, change `EXERCISE4_STEP` to a value of `15`. Click on
    the `PushOntoStackNotEmpty`, in **StackTests.cpp** proves that the push does something
    to make the stack no longer empty. We need to add more methods to make sure that
    it has done the expected.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change `push()` method and change `EXERCISE4_STEP` to a value
    of `16`:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Click on the **Run** button to run the tests. There should now have three passing
    tests.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change `push()` method and change `EXERCISE4_STEP` to a value
    of `18`:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Click on the **Run** button to run the tests. There should now be four passing
    tests.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change `pop()` method and change `EXERCISE4_STEP` to a value
    of `20`:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Click on the **Run** button to run the tests. There are now five passing tests
    and we have implemented a stack.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Launch Configuration dropdown, select **L2BExercise4** and click on
    the **Run** button. Exercise 4 will run and produce something similar to the following
    output:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2B.34: Exercise 4 output'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_34.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.34: Exercise 4 output'
  id: totrans-478
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Examine the code that is now in the `std::stack` template takes two arguments,
    with the second one defining the container to be used – vector could be the first.
    Examine the tests in **StackTests.cpp**. The tests should be named to indicate
    what they aim to test, and they should focus on doing that.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Developing a Generic "contains" Template Function'
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The programming language Python has a membership operator called "in" that can
    be used on any sequence, that is, list, sequence, set, string, and so on. Even
    though C++ has over 100 algorithms, it does not have an equivalent method to achieve
    the same. C++ 20 introduced the `contains()` method on `std::set`, but that is
    not enough for us. We need to create a `contains()` template function that works
    with `std::set`, `std::string`, `std::vector`, and any other container that provides
    iterators. This is determined by the ability to call end() on it. We are aiming
    for best performance, so we will call the `find()` member method on any container
    that has one (it will be the most efficient) and otherwise fall back to using
    `std::end()` on the container. We also need to treat `std::string()` differently
    as its `find()` method returns a special value.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'We could implement this using a general template and two specializations, but
    this activity is being used to get it working using the techniques of SFINAE and
    if constexpr. In addition, this template must only work on a class that supports
    `end(C)`. Follow these steps to implement this activity:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Load the prepared project from the **Lesson2B/Activity01** folder.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the helper template functions and class to detect the std:string case
    using the `npos` member.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the helper template functions and class to detect whether the class has
    a `find()` method.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the contains template function that uses constexpr to select between
    one of three implementations – string case, the has find method, or general case.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After implementing the preceding steps, the expected output should look as
    follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.35: Output from the successful implementation of contains'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_35.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.35: Output from the successful implementation of contains'
  id: totrans-490
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 653.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned about interfaces, inheritance, and polymorphism,
    which extended our skills of what we can do with our types. We had our first adventure
    into generic programming with C++ templates and touched on what the language gives
    us for free from the C++ Standard Library, which includes the STL. We explored
    a feature of C++ that just works, that is, template type deduction, which makes
    our life easier when using templates. We then went further with templates and
    learned how to control the parts of the template that are included by the compiler
    using SFINAE and if constexpr. These form the building blocks for our journey
    into C++. In the next chapter, we will revisit the stack and the heap, and understand
    what an exception is, what happens, and when it occurs. We'll also learn how to
    protect our programs from resource losses when exceptions occur.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
