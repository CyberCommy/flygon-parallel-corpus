- en: 2B. No Ducks Allowed – Templates and Deduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop your own classes to an even greater effect using inheritance and polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an alias to make your code easier to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop templates using SFINAE and constexpr to simplify your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement your own solutions using the STL to leverage generic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the context and basic rules for type deduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will show you how to define and extend your types through inheritance,
    polymorphism, and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to develop our own types (classes) with
    the help of unit tests and made them behave like built-in types. We were introduced
    to function overloading, Rule of Three/Five, and Rule of Zero.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to extend the type system even further. We'll
    learn how to create functions and classes using templates and revisit function
    overloading since it's impacted by the use of templates. We'll be introduced to
    a new technology, **SFINAE**, and use it to control the parts of our templates
    that are included in the generated code.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance, Polymorphism, and Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far in our journey of object-oriented design and C++, we have focused on
    abstraction and data encapsulation. We will now turn our attention to **inheritance**
    and **polymorphism**. What is inheritance? What is polymorphism? Why do we need
    it? Consider the following three objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.1: Vehicle objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.1: Vehicle objects'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see that there are three very different objects.
    They have some things in common. They all have wheels (a different number), an
    engine (different size, power, or configuration), start engine, drive, apply brakes,
    stop engine, and so on, using which we can do something.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can abstract them into something called a vehicle that demonstrates
    these attributes and general behaviors. If we express this as a C++ class, it
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Vehicle` class is a more generalized (or abstract) expression of `Motorcycle`,
    `Car`, and `Truck`. We can now create more specialized types by reusing what is
    already available in the Vehicle class. We are going to reuse Vehicle''s properties
    and methods by using inheritance. The syntax for inheritance is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have come across access modifiers such as `public`, `protected` and `private`
    before. They control how we have access to the base classes'' members. The Motorcycle
    class will be derived as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the Vehicle class is referred to as the **base class** or the
    **super class**, while the Motorcycle class is referred to as the **derived class**
    or **subclass**. Graphically, we can represent this as follows, where the arrows
    point from the derived class to the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.2: Vehicle class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.2: Vehicle class hierarchy'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'But a motorcycle drives differently from a generic vehicle. So, we need to
    modify the `Motorcycle` class so that it behaves differently. The updated code
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we think about object-oriented design, this is about modeling a problem space
    in terms of objects that collaborate. These objects communicate with each other
    through messages. Now, we have two classes that respond to the same message (the
    `Drive()` method) in different ways. The sender of the message has no knowledge
    of what will happen and doesn't really care, and this is the essence of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Polymorphism comes from the Greek words poly and morph, where `poly` means many
    and `morph` means form. So, polymorphism means `having many forms`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use these classes to try out polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run this program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.3: Vehicle program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.3: Vehicle program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the lines after the line `Vehicle::StartEngine
    1500 cc` are all related to the `Motorcycle`. But the Drive line still shows `Vehicle::Drive`
    and not the expected `Motorcycle::Drive`. What''s going on? The problem is that
    we have not told the compiler that the `Drive` method in the `Vehicle` class can
    be modified (or overridden) by a derived class. We need to make one change in
    our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `virtual` keyword before the member function declaration, we
    are telling the compiler that a derived class can (but doesn''t have to) override
    or replace the function. If we make this change and then compile and run the program,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.4: Vehicle program output with virtual methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.4: Vehicle program output with virtual methods'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, we have learned about inheritance and polymorphism. We used a pointer
    to a `Vehicle` class to control the `Motorcycle` class. Another change to the
    code should be made as a matter of best practice. We should also change the declaration
    of the `Drive` function in the `Motorcyle` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'C++11 introduced the `override` keyword as a hint to the compiler, stating
    that a particular method should have the same function prototype as a method somewhere
    in its parent tree. If it cannot find one, then the compiler will report an error.
    This is a very useful feature and can save you from hours of debugging. If there
    is some way for the compiler to report an error, use it. The earlier a defect
    is detected, the easier it is to fix. One final change is that whenever we add
    a virtual function to a class, we must declare its destructor `virtual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We saw this with the `Drive()` function before it was made virtual. When the
    destructor is called through the pointer to a Vehicle, it needs to know which
    destructor to call. Thus, making it virtual enables this. If you fail to do so,
    then you can end up with resource leaks or spliced objects.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and Access Specifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned previously, the general form of inheriting one subclass from
    a super class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we derived Motorcycle class from Vehicle class, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The access modifier is optional and is one of the ones that we have met before:
    `public`, `protected`, and `private`. In the following table, you can see the
    accessibility of the base classes'' members. If access_modifier is omitted, then
    the compiler assumes private was specified.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.5: Accessibility of base class members in derived classes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.5: Accessibility of base class members in derived classes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Abstract Classes and Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the classes that we have talked about up until now are **concrete class**
    – they can be instantiated as a type for a variable. There is another type of
    class – an **abstract class**– that contains at least one **pure virtual member
    function**. A pure virtual function is a virtual function that has no definition
    (or implementation) in the class. And because it has no implementation, the class
    is malformed (or abstract) and cannot be instantiated. If you attempt to create
    a variable of an abstract type, then the compiler will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a pure virtual member function, end the function prototype declaration
    with `= 0`. To make Drive() a pure virtual function in the Vehicle class, we would
    declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, to be able to use a derived class as a variable type (for example, the
    `Motorcycle` class), it must define an implementation of the `Drive()` function.
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, declare a variable to be either a pointer to the abstract
    class or a reference to the abstract class. In either case, it must point to,
    or reference, some non-abstract class derived from the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there is a keyword interface that allows you to define a class that
    is all pure virtual functions. The same is achieved in C++ by declaring a class
    that only declares public pure virtual functions (and a virtual destructor). In
    this way, we define an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before solving any practical in this chapter, download this book's GitHub repository
    ([https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus))
    and import the folder for Lesson 2B in Eclipse so that you can view the code for
    each exercise and activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Implementing Game Characters with Polymorphism'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will demonstrate inheritance, interfaces, and polymorphism.
    We will start with an ad hoc implementation of a role-playing game and evolve
    it to be more generic and expandable. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse and create a new project named **Lesson2B** using the files found
    in the **Lesson2B** examples folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a **CMake-based project**, change the current builder to **Cmake
    Build (portable)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Project** | **Build All** menu to build all exercises. By default,
    the console at the bottom of the screen will display the **CMake console [Lesson2B]**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure a **New Launch Configuration** named **L2BExercise1** that runs the
    **Exercise1** binary and click on **Run** to build and run **Exercise 1**. You
    will receive the following output:![Figure 2B.6: Exercise 1 default output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.6: Exercise 1 default output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open `speak()` and `act()` directly. This is fine for a small program. But
    as the game grew to tens or hundreds of characters, it would become unmanageable.
    So, we need to abstract all the characters. Add the following Interface declaration
    to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Normally, the destructor would be empty, but here, it has logging to show the
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derive the `Wizard`, `Healer`, and `Warrior` classes from this interface class
    and add the `override` keyword to the end of the declarations of the `speak()`
    and `act()` functions for each class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the **Run** button to rebuild and run the exercise. We will now see that
    the base class destructor is also called after the destructor of the derived class:![Figure
    2B.7: Output of the modified program'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.7: Output of the modified program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create the characters and manage them in a container such as a `vector`. Create
    the following two methods in the file, before the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the content of `main()` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the **Run** button to rebuild and run the exercise. Here is the output
    that is generated:![Figure 2B.8: Output of the polymorphic version'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.8: Output of the polymorphic version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, the logging for **Destroying Wizard**
    and so on has disappeared. The problem is that the container holds the pointers
    to the base class and that it doesn't know how to call the full destructor in
    each case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, simply declare the destructor for `ICharacter` as virtual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the **Run** button to rebuild and run the exercise. The output now reads
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2B.9: Output from the full polymorphic version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.9: Output from the full polymorphic version'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have now implemented an interface to our `ICharacter` characters and used
    them polymorphically by simply calling the `speak()` and `act()` methods through
    a base class pointer stored in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, Structs, and Unions Revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, we discussed that the difference between a class and a struct was
    the default access modifier – private for class and public for struct. This difference
    goes one step further – it applies to the base class if it does not specify anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be noted that a union can neither be a base class nor be derived
    from a base class. If there is essentially no difference between a struct and
    a class, then which type should we use? Essentially, it is one of convention.
    A **struct** is used to bundle together several related elements, while a **class**
    can do things and has responsibilities. An example of a struct is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that it groups together three coordinates
    so that we can reason about a point in a 3D space. This structure can be passed
    as a coherent dataset to methods that need points, rather than three separate
    arguments per point. A class, on the other hand, models an object that can perform
    actions. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A rule of thumb is to use a class if there is at least one private member as
    this implies that the details of the implementation will be behind the public
    member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility, Lifetime, and Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have talked about creating our own types and declaring variables and functions
    while mainly focusing on simple functions and a single file. We will now look
    at what happens when there are multiple source files (translation units) that
    contain classes and function definitions. Also, we'll check which variables and
    functions can be visible from the other parts of the source files, how long the
    variables live, and look at the difference between internal and external linkage.
    In *Chapter 1*, *Anatomy of Portable C++ Software*, we saw how the toolchain works
    to compile the source files and produce the object files and that the the linker
    puts it all together to form an executable program.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a compiler processes a source file, it generates an object file that contains
    the translated C++ code and enough information for the linker to resolve any references
    from the compiled source file to another source file. In *Chapter 1*, *Anatomy
    of Portable C++ Software*, `sum()`, which is defined in the **SumFunc.cpp** file.
    When the compiler constructs an object file, it creates the following segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code segment** (also known as text): This is the translation of the C++ functions
    into the target machine instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data segment**: This contains all the variables and data structures that
    are declared in the program, not local or allocated off the heap or stack, and
    are initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BSS segment**: This contains all the variables and data structures that are
    declared in the program, not local or allocated off the heap or stack, and are
    not initialized (but will be initialized to zero).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database of exported symbols**: A list of variables and functions that are
    in this object file and their location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database of referenced symbols**: A list of variables and functions this
    object file needs from outside itself and where they are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: BSS is used to name the uninitialized data segment and its name is historically
    derived from Block Started by Symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The linker then collects all the code segments, data segments, and **BSS**
    segments together to form the program. It uses the information in the two databases
    (DB) to resolve all the referenced symbols to the exported symbols list and patch
    the code segments with this information so that they can operate correctly. Graphically,
    this is depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.10: Parts of the object files and the executable file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.10: Parts of the object files and the executable file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the purposes of the discussion that follows, BSS and data segments will
    be referred to simply as data segment (the only difference being that BSS is not
    initialized). When a program is executed, it is loaded into memory and its memory
    looks a bit like the executable file layout – it contains the text segment, data
    segment, BSS segment, and free memory allocated by the host system, which contains
    what is known as the **stack** and the **heap**. The stack typically starts at
    the top of the memory and grows down, while the heap starts where BSS finishes
    and grows up, toward the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.11: CxxTemplate runtime memory map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.11: CxxTemplate runtime memory map'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The section of the program in which a variable or identifier is accessible
    is known as the **scope**. There are two broad categories of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{}`). The variable can be accessed inside the curly braces. Just like blocks
    can be nested, so can the scope of the variable. This typically includes local
    variables and function parameters, and these are generally stored in the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global / file scope**: This applies to variables declared outside a normal
    function or class, as well as to the normal functions. The variable can be accessed
    anywhere in the file and possibly from other files (global) if the linkage is
    correct. These variables are allocated memory by the linker in the data segment.
    The identifiers are placed into the global namespace, which is the default namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can think of a namespace as a dictionary of names of variables, functions,
    and user-defined types. For small programs, it is ok to use the global namespace
    as there is very little chance of you creating multiple variables with the same
    name and getting name clashes. As programs get larger, and more third-party libraries
    are included, the chance of name clashes increases. Therefore, library writers
    will put their code into a namespace (that is hopefully unique). This allows the
    programmer to control access to the identifiers in the namespace. By using the
    standard library, we have already been using the std namespace. A namespace is
    declared like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It is usual for name_of_namespace to be short, and namespaces can be nested.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A good use of namespaces can be seen in the boost libraries here: [https://www.boost.org/](https://www.boost.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable has another attribute, that of **lifetime**. There are three fundamental
    lifetimes; two that are managed by the compiler and one that the programmer chooses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic lifetime**: Local variables are created when they are declared
    and are destroyed upon exiting the scope that they are in. These are managed by
    the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permanent lifetime**: Global variables and static local variables. The compiler
    causes global variables to be created when the program begins (before entering
    the main() function) and causes static local variables to be created when they
    are first accessed. In both cases, the variable is destroyed when the program
    exits. These variables are placed in the data segments by the linker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new` and `delete`). These variables have their memory allocated from the heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final attribute of a variable we will consider is **linkage**. Linkage
    indicates what the compiler and linker will do if they encounter variables and
    functions that have the same name (or identifier). For a function, its actually
    what is known as the mangled name – the compiler uses the name of the function,
    its return type, and its argument types to produce a mangled name. There are three
    types of linkage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No linkage**: This means that the identifier only refers to itself and applies
    to local variables and locally defined user types (that is, inside a block).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal linkage**: This means that the identifier can be accessed anywhere
    in the file in which it is declared. This applies to static global variables,
    const global variables, static functions, and any variables or functions declared
    in an anonymous namespace within the file. An anonymous namespace is a namespace
    with no stated name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External linkage**: This means that, with the right forward declarations,
    it can be accessed from within all files. This includes normal functions, non-static
    global variables, extern const global variables, and user-defined types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are termed linkages, only the last one actually involves the linker.
    The other two are achieved by the compiler excluding information from the DB of
    exported identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Templates – Generic Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a computer scientist, or as a programming enthusiast, at some point in time,
    you probably had to write one (or more) sort algorithms. When discussing the algorithm,
    you were not particularly concerned about the type of data being sorted, just
    that the two objects of that type could be compared and that the domain is a totally
    ordered set (that is, if one object is compared with any other, you can determine
    which comes first). Different programming languages provide different solutions
    to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '`swap` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void pointer`. `size_t` size defines how big each object is, while the `compare()`
    function defines how to compare the two objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::sort()` is a function provided in its standard library, where one of
    its signatures is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the details of the type are captured in the iterator type called
    `RandomIt` and passed to the method when compiled.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will briefly define generic programming, show how C++
    implements them through templates, highlight what the language already provides,
    and discuss how the compiler deducts the types so that they can be used for the
    template.
  prefs: []
  type: TYPE_NORMAL
- en: What is Generic Programming?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you developed a sort algorithm, you may have originally focused on just
    sorting plain numbers. But once that is established, you could then abstract that
    to any type, provided that the type exhibits certain attributes such as total
    ordered set (that is, the comparison operator, <, has meaning between all the
    elements in the domain we are sorting over). So, to express an algorithm in terms
    of generic programming, we define a placeholder in the algorithm for the type
    that needs to be manipulated by that algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic programming** is the development of a type-agnostic general algorithm.
    The algorithm can be reused by passing types as arguments. In this way, algorithms
    are abstracted and allow the compiler to optimize based on types.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, generic programming is an approach to programming where an algorithm
    is defined with types as parameters that are specified when the algorithm is instantiated.
    Many languages provide support for generic programming with different names. In
    C++, generic programming is supported through the language feature known as templates.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing C++ Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Templates are C++''s support for generic programming. Think of a template as
    a cookie cutter, and the type that we give it as a parameter as cookie dough (which
    can be chocolate brownie, ginger snap, or some other delicious flavor). When we
    apply the cookie cutter, we end up with instances of cookies that are in the same
    form but have different flavors. So, a template captures the definition of a generic
    function or class and when specified with types as arguments, the compiler goes
    to work to write the class or function for us as if the type was hand-coded by
    us. It has several advantages, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You only need to develop the class or algorithm once and evolve it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can apply it to many types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can hide complex details behind a simple interface and the compiler can
    apply optimizations to the generated code, based on the type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, how do we write a template? Let''s start with a template that will allow
    us to clamp a value within a range from `lo` to `hi` and be able to use it on
    `int`, `float`, `double`, or any other built-in type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template <class T>` declares what follows to be a template and uses one type,
    which has a placeholder of `T` in the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T` is substituted. It declares that the function clamp takes three arguments
    of type `T` and returns a value of type `T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<` operator, then we can perform a clamp on the three values so that `lo <=
    val <= hi`. This algorithm is valid for all the types that can be ordered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say we use it in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.12: Clamp program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.12: Clamp program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the last call to clamp, we have passed the template the double type between
    `<` and `>`. But we haven't followed the same for the other four calls. Why? It
    turns out that the compiler is getting smarter as it gets older. With every release
    of the standard, they improve what is known as **type deduction**. Because the
    compiler is able to deduce the type, we do not need to tell it what type to use.
    The reason for this is that the three arguments to the class without the template
    parameter have the same type – the first three are all int while the fourth one
    is double. But we had to tell the compiler which type to use for the final one
    because it has two doubles and an int as arguments, which resulted in a compilation
    error saying no function found. But then, it gave us information about why the
    template could not be used. This form, where you force the types, is known as
    **explicit template argument specification**.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Pre-Packaged Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C++ Standard is comprised of two major parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The language definition, that is, the keywords, syntax, lexical definitions,
    structures, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Standard Library, that is, all the pre-written general-purpose functions
    and classes to be provided by the compiler vendor. A subset of this library is
    implemented using templates and is known as the **Standard Template Library**
    (**STL**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STL has origins in the generics provided in the Ada language that was developed
    by David Musser and Alexander Stepanov. Stepanov was a strong advocate for the
    use of generic programming as the basis for software development. In the 90s,
    he saw the opportunity to do this with the new language C++ to influence mainstream
    development, and proposed to the ISO C++ committee that the STL should be included
    as part of the language. The rest is history.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL is comprised of four categories of predefined generic algorithms and
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers**: General sequence (vector, list, deque) and associative containers
    (set, multiset, map)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`begin()` and `end()`). Note that one fundamental design choice in the STL
    is that `end()` points to a position one after the last item – mathematically,
    that is [`begin()`, `end()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithms**: Over 100 different algorithms covering sorting, searching,
    set operations, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_if()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The clamp function template that we implemented previously is simplistic and
    while it would work for any type that supports the less than operator, it would
    not be very efficient – it could result in very large copies if the type has a
    large size. Since C++17, the STL includes a `std::clamp()` function that is declared
    more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, it uses references for the arguments and the return value. Changing
    the arguments to use references reduces what has to be passed on and returned
    on the stack. Also, note that the designers have worked to produce a more general
    version of the template so that we are not reliant on the < operator that exists
    for the type. However, we can define the ordering by passing comp.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding examples, we have seen that, like functions, templates can
    take multiple comma-separated parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Type Aliases – typedef and using
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have used the `std::string` class, then you have been using an alias.
    There are a few template classes related to strings that need to implement the
    same functionality. But the type representing a character is different. For example,
    for `std::string`, the representation is `char`, while `std::wstring` uses `wchar_t`.
    There are several others for `char16_t` and `char32_t`. Any variation in the functionality
    will be managed through traits or template specialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to C++11, this would have been aliased from the `std::basic_string` base
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This does two main things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reduces the amount of typing required to declare the variable. This is a simple
    case, but when you declare a unique pointer to a map of strings to object, it
    can get very long and you will make errors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Improves the readability as you now conceptually think of it as a string and
    do not need to worry about the details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But C++11 introduced a better way – `alias declarations` – which utilizes the
    `using` keyword. The preceding code can be implemented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is simple and the alias, either typedef or using, is
    not too hard to grok. But when the alias involves more complicated expressions,
    they too can be a little unreadable – particularly function pointers. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is a reason for the new feature in C++11 where alias declaration may be
    incorporated easily into templates – they can be templatized. A `typedef` cannot
    be templatized and while it is possible to achieve the same outcome with `typedef`,
    the alias declaration (`using`) is the preferred method as it results in simpler
    and easier to understand template code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Implementing Aliases'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement aliases using a typedef and see how the
    code becomes easier to read and efficient by using a reference. Follow these steps
    to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2B** project in Eclipse, and then in the Project Explorer,
    expand **Lesson2B**, then **Exercise02** and double-click on **Exercise2.cpp**
    to open the file for this exercise in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** dropdown menu and select **New Launch
    Configuration…**. Configure **L2BExercise2** to run with the name **Exercise2**.
    When that is complete, it will be the currently selected Launch Configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. **Exercise 2** will run and produce something
    similar to the following output:![Figure 2B.13: Exercise 2 output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.13: Exercise 2 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the editor, before the declaration of the `printVector()` function, add
    the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, change all occurrences of `std::vector<int>` in the file with `IntVector`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Run** button. The output should be the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change the line that you previously added to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button. The output should be the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, change the one occurrence of `IntVector::iterator` to `IntVectorIter.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Run** button. The output should be the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, there appears to be little difference between typedef and
    using alias. In either case, the use of a well-named alias makes code easier to
    read and understand. When more complicated aliases are involved, `using` produces
    an easier way to write an alias. Introduced in C++11, `using` is now the preferred
    method for defining an alias. It has other advantages over `typedef`, such as
    being able to use it inside templates.
  prefs: []
  type: TYPE_NORMAL
- en: Templates – More than Generic Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Templates can also deliver much more than just generic programming (a cookie
    cutter with types). In the case of generic programming, the template operates
    as a blueprint that cannot be changed and delivers the compiled version of the
    template for the specified type or types.
  prefs: []
  type: TYPE_NORMAL
- en: Templates can be written to provide specialization of a function or algorithm
    based on the types involved. This is known as **template specialization** and
    is not generic programming in the sense we previously used it. It can only be
    called generic programming when it makes certain types behave as we would expect
    them to do in a given context. It cannot be called generic programming when the
    algorithm that's used for all types is modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine the following sample of specialization code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It defines a template that calls `printf()` with a different format string,
    based on the specialization of the template using `std::enable_if_t<>` and `sizeof()`.
    When we run it, the following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.14: Erroneous print template program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.14: Erroneous print template program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Substitution Failure Is Not An Error – SFINAE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The value printed for `32.1F` (`-1073741824`) does not bear any resemblance
    to the number. If we examine the code that was generated by the compiler for the
    following program, we will find that it has generated the code as if we wrote
    the following (and more):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Why does it generate this code? The preceding templates use a feature of the
    C++ compiler called `std::enable_if_t<>` and access what are known as **type traits**
    to help us. Firstly, we will replace the last template with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes some explaining. Firstly, we consider the definition of `std::enable_if_t`,
    which is actually a type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first template for `enable_if` will result in the definition of an empty
    struct (or class). The second template for `enable_if` is a specialization for
    true as a first template argument that will result in the class with a typedef
    definition. The definition of `enable_if_t` is a helper template that removes
    the need for us to enter `::type` on the end of the template when we use it. So,
    how does this work? Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If the condition that is evaluated at compile time results in `enable_if_t`
    template will result in a template that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is valid syntax and the function is added to the symbol table as a candidate
    function. If the condition that is calculated at compile time results in `enable_if_t`
    template will result in a template that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is **malformed code** which is now discarded – SFINAE at work.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::is_floating_point_v<T>` is another helper class that accesses the `::value`
    member of the `std::is_floating_point<T>` template. Its name says it all – it
    will be true if T is a floating-point type (float, double, long double); otherwise,
    it will be false. If we make this change, then the compiler (GCC) generates the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.15: Compiler error for the modified print template program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.15: Compiler error for the modified print template program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The problem now is that we have two templates that can satisfy when the type
    is a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that (usually) `sizeof(float) == sizeof(int)`, so we need to make
    another change. We'll replace the first condition with another type trait – `std::is_integral_v<>:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we make this change, then the compiler (GCC) generates the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.16: Second compiler error for the modified print template program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.16: Second compiler error for the modified print template program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We fixed the floating-point ambiguity, but the problem here is that `std::is_integral_v(char)`
    returns true and again there are two functions that are generated by the templates
    for a type of char with the same prototype. It turns out that the conditions that''s
    passed to `std::enable_if_t<>` obeys standard C++ logic expressions. So, to fix
    this problem, we will add an extra condition that will exclude chars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile the program now, it completes the compilation and links the program.
    If we run it, it now produces the following (expected) output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.17: Corrected print template program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.17: Corrected print template program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Floating-Point Representations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shouldn't that `32.099998` be `32.1`? That is what was passed to the function.
    The problem with performing floating-point operations on a computer is that the
    representation automatically introduces an error. Real numbers form a continuous
    (infinite) domain. If you consider the numbers 1 and 2 in the real domain, then
    there is an infinite amount of real numbers between them. Unfortunately, a computer's
    representation of floating-point numbers quantizes the values and cannot represent
    all of the infinite number of numbers. The bigger the number of bits used to store
    the number, the better the representation of the value is on the real domain.
    So, long double is better than double is better than float. It really depends
    on your problem domain as to what is appropriate for storing the data. Back to
    `32.099998`. The computer stores the single precision numbers as the sum of powers
    of 2 and then shifts them by a power factor. Integral numbers are usually easy
    as they can be easily represented by the sum of `2^n` powers (n>=0). The fractional
    part, which in this case is 0.1, has to be expressed as the sum of `2^(-n) (n>0)`.
    We add more power-2 fractions to attempt to get the number closer to the target
    until we have used up the 24 bits that we have for precision in a single precision
    floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to know more about how computers store floating-point numbers, research
    the IEEE 754 standard that defines it.
  prefs: []
  type: TYPE_NORMAL
- en: Constexpr if Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++17 introduced the `constexpr if` expression to the language, which simplifies
    template writing greatly. We can rewrite the preceding three templates that use
    SFINAE as one simpler template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For the call to `print(55)`, the compiler generates the function to call as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What happened to the if/else if statements? What happens with a `constexpr if`
    expression is that the compiler contextually determines the value of the condition
    and converts it into a bool value (true/false). If the evaluated value is true,
    then the if condition and the else clause are discarded, leaving only the true
    clause to generate code. Likewise, if it is false, then the false clause is left
    to generate code. In other words, only the first constexpr if condition that evaluates
    to true will have the code for its clause generated, while the rest are discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Type Template Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have only seen template arguments that are types. It is also possible
    to pass an integral value as a template argument. This allows us to prevent array
    decay for a function. For example, consider a template function that calculates
    the `sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we need to pass the length of the array in the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: But wouldn't it be better if we could just call the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do it by making changes to the template, like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we changed the data to be a reference to an array of a certain size –
    a size that is passed to the template – and so the compiler figures it out. We
    no longer need the second argument to the function call. This simple example showed
    how to pass and use a non-type argument directly. We will explore this more in
    the *Template Type Deduction* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Implementing Stringify – specialization Versus constexpr'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement a stringify template by utilizing constexpr
    to produce an easier to read and simpler version of the code. Follow these steps
    to implement this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The stringify specialization templates can be found at [https://isocpp.org/wiki/faq/templates#template-specialization-example](https://isocpp.org/wiki/faq/templates#template-specialization-example).
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2B** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2B**, then **Exercise03**, and double-click on **Exercise3.cpp**
    to open the file for this exercise in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** dropdown menu and select **New Launch
    Configuration…**. Configure **L2BExercise3** to run with the name **Exercise3**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. **Exercise 3** will run and produce the following
    output:![Figure 2B.18: Exercise 3 specialized template output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.18: Exercise 3 specialized template output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In **Exercise3.cpp**, comment out all of the template specializations for the
    stringify template while leaving the original general template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. The output will change to have the boolean printed
    as a number and the double printed to only two decimal places:![Figure 2B.19:
    Exercise 3 general template only output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.19: Exercise 3 general template only output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We will now "specialize" the template for the boolean type again. Add the `#include
    <type_traits>` directive with the other `#includes` and modify the template so
    that it reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The output boolean stringify works as before:![Figure
    2B.20: stringify tailored for boolean'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.20: stringify tailored for boolean'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We will now "specialize" the template for the floating-point types (`float`,
    `double`, `long double`) again. Modify the template so that it reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. The output is restored to the original:![Figure
    2B.21: constexpr if version template output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.21: constexpr if version template output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you compare the original version with multiple templates to the final version,
    you will find that the final version is more like a normal function and is easier
    to read and maintain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the exercise, we learned how much simpler and compact our templates can be
    when using the new constexpr if construct in C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Function Overloading Revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we first discussed function overloading, we only considered the scenarios
    where the name of the function came from the list of functions that we wrote by
    hand. Now, we need to update this. We can also write templated functions that
    can have the same name. Like we did previously, when the compiler meets the line
    `print(55)`, it needs to work out which of the previously defined functions to
    call. So, it performs the following process (grossly simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.22: Function overload resolution with templates (simplified)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.22: Function overload resolution with templates (simplified)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Template Type Deduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we first introduced templates, we touched on Template type deduction.
    Now, we are going to explore this further. We will start by considering the general
    declaration for a function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The call for this might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When the compiler reaches this line, it must now deduce two types related to
    the template – `T` and `ParamType`. These are often different due to qualifiers
    and other attributes attached to the T in the ParamType (for example pointer,
    reference, const, and so on). The types are related but the deduction progresses
    differently, depending on the form of `expression` used.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Deduced Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we look into the different forms, it might be useful if we could get
    the compiler to tell us the types that it has deduced. We have a few options here,
    including the IDE editors showing types, the compiler generating errors, and runtime
    support (which, due to the C++ standard, is not necessarily effective). We will
    use the compiler errors to help us explore some of the type deductions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve a type displayer by declaring a template without a definition.
    Any attempt to instantiate the template will cause the compiler to generate an
    error message as there is no definition, along with the type information that
    it is trying to instantiate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s attempt to compile the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler spits out the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.23: Compiler errors showing deduced types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.23: Compiler errors showing deduced types'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that, in each case, the aggregate being named includes the type being deduced
    – for x, it is an int, for y, an unsigned int, and for x+y, an unsigned int. Also,
    note that the TypeDisplay template requires a type for its arguments and so the
    `decltype()` function is used to get the compiler to provide the type for the
    expression in brackets.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to display the deduced type at runtime either using the
    built-in `typeid(T).name()` operator, which returns a std::string, or by using
    the boost library called type_index.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For more information on this, visit the following link: [https://www.boost.org/doc/libs/1_70_0/doc/html/boost_typeindex.html](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_typeindex.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the type deduction rules, the built-in operator will give you an
    indication of the type, but it will lose reference (`&`, and `&&`) and any constness
    information (const or volatile). If required at runtime, then consider `boost::type_index`,
    which will produce the same output for all the compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Template Type Deduction – the Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s return to the generic template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that the call looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Type deduction proceeds differently depending on the form of ParamType used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ParamType is a value (T)**: Pass-by-value function call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ParamType is a reference or pointer (T& or T*)**: Pass-by-reference function
    call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ParamType is a rvalue reference (T&&)**: Pass-by-reference function call
    or something else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case 1: ParamType is pass-by-value (T)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As a pass-by-value call, this means that the parameter will be a copy of whatever
    is passed in. Because this is a new instance of the object, the following rules
    are applied to the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: If the expression's type is a reference, then ignore the reference part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If, after step 1, the remaining type is const and/or volatile, then ignore those
    as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What''s left is T. Let''s attempt to compile the following file code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler produces the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.24: Compiler error showing a deduced type for the pass by type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.24: Compiler error showing a deduced type for the pass by type'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So, the type is deduced to be `int`. Likewise, we get exactly the same error
    if we declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The same will happen if we declare this version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In all three cases, the deduced type is `int`, as per the rules stated previously.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 2: ParamType is pass-by-reference (T&)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a pass-by-reference call, this means that the parameter will be able to
    access the original storage location of the object. Because of this, the generated
    function has to honor the constness and volatileness we ignored before. The following
    rules are applied to type deduction:'
  prefs: []
  type: TYPE_NORMAL
- en: If the expression's type is a reference, then ignore the reference part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern match what's left of the type of expression with ParamType to determine
    T.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s attempt to compile the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will generate the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.25: Compiler error showing the deduced type for pass by reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.25: Compiler error showing the deduced type for pass by reference'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From this, we can see that the compiler has T as an `int` from ParamType as
    `int&`. Changing x to be a const int provides no surprises as T is deduced to
    be `const int` from ParamType as `const int&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.26:  Compiler error showing the deduced type for pass by const
    reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.26: Compiler error showing the deduced type for pass by const reference'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Likewise, introducing rx as a reference to a const int, as before, gives no
    surprises, as T is deduced to be `const int` from ParamType as `const int&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2B.27: Compiler error showing the deduced type when passing a const
    reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.27: Compiler error showing the deduced type when passing a const
    reference'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we change the declaration to include a const, then the compiler will honor
    the constness when it generates the function from the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This time, the compiler reports the following
  prefs: []
  type: TYPE_NORMAL
- en: '`int x`: T is int (as the constness will be honored), while the parameter''s
    type is `const int&`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int x`: T is int (const is in the pattern, leaving int), while the parameter''s
    type is `const int&`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int& rx`: T is int (reference is ignored, const is in the pattern, leaving
    int), while the parameter''s type is `const int&`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we attempt to compile the following, what do we expect? Normally, an array
    decays to be a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler error is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.28:  Compiler error showing the deduced type for the array argument'
  prefs: []
  type: TYPE_NORMAL
- en: when passed by reference
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.28: Compiler error showing the deduced type for the array argument
    when passed by reference'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This time, the array is captured as a reference and the size is also included.
    So, if ary was declared as `ary[10]`, then a completely different function would
    result. Let''s revert the template to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to compile the array call, then the error reports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.29: Compiler error showing the deduced type for the array argument'
  prefs: []
  type: TYPE_NORMAL
- en: when passed by value
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.29: Compiler error showing the deduced type for the array argument
    when passed by value'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that, in this case, the array has decayed as the usual behavior when
    passing an array to a function. We saw this behavior when talking about *Non-Type
    Template Arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 3: ParamType is a rvalue reference (T&&)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'T&& is called a rvalue reference while T& is called a lvalue reference. C++
    not only characterizes an expression by type but also by a property called the
    **value category**. These categories control expression evaluation in the compiler,
    including the rules for creating, copying, and moving temporary objects. There
    are five expression value categories defined in the C++17 standard that have the
    following relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.30: C++ value categories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.30: C++ value categories'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The definitions of each are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An expression that determines the identity of an object is a `glvalue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression whose evaluation initializes an object or the operand of an operator
    is a `prvalue`. Examples include a literal (except string literal) such as 3.1415,
    true or nullptr, the this pointer, post increment, and post decrement expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A glvalue object that has resources and can be reused (because its life is ending)
    is an `xvalue`. Examples include a function call whose return type is an rvalue
    reference to an object, such as `std::move()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A glvalue that is not an xvalue is an `lvalue`. Examples include the name of
    a variable, a function or a data member, or a string literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prvalue or xvalue is an `rvalue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It does not matter if you do not fully understand these for the explanation
    that follows – just know that an expression that is considered to be an lvalue
    can have its address taken (using the address of operator, that is, "&"). The
    type deduction rules for the following require that you know what an lvalue is,
    as well as what it isn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The type deduction rules for this ParamType form are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the expression is an lvalue reference, then both T and ParamType are deduced
    to be an lvalue reference. This is the only scenario where the type is deduced
    to be a reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the expression is an rvalue reference, then the rules for Case 2 apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFINAE Expression and Trailing Return Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++11 introduced a feature called `trailing return types` to provide a mechanism
    for templates so that they can generalize the return type. A simple example is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, `auto` is used to indicate that a trailing return type is defined. The
    trailing return type starts with the `->` pointer and in this case, the return
    type is the type that's returned by multiplying `a` and `b`. The compiler will
    process the content of the decltype and, if it is malformed, it will remove the
    definition from the function name's lookup, as per usual. This capability opens
    up many possibilities as the comma operator, "`,`", can be used inside `decltype`
    to check for certain attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to test that a class implements a method or contains a type then
    we can place this inside the decltype by converting it into a void (in case the
    comma operator has been overloaded) and then define an object of the real return
    type at the end of the comma operator. An example of this is shown in the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When this program is compiled and executed, we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.31: Output from the SFINAE expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.31: Output from the SFINAE expression'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The return type is given by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: The operand of `decltype` is a comma-separated list of expressions. This means
    that the compiler will construct but not evaluate the expressions and use the
    type of the right-most value to determine the return type for the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::declval<T>()` allows us to convert the T type into a reference type that
    we can then use to access member functions without having to actually construct
    an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with all SFINAE-based operations, if any expression in the comma-separated
    list is invalid, then the function is discarded. If they are all valid, then it
    is added to the list of functions for lookup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cast to void is to prevent any problems that may arise if the user overloads
    the comma operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, this is testing whether the `C` class has a member function called
    `find()` that takes `class T`, `class T&`, or `const class T&` as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method will work for `std::set`, which has a `find()` method that takes
    one argument but will fail for other containers because they do not have a `find()`
    member method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach works well if we are only dealing with one type. But if we have
    a function that needs to produce different implementations based on type, as we
    have seen before, the `if constexpr` approach is much cleaner and generally easier
    to understand. To use the `if constexpr` approach, we need to produce templates
    that will evaluate to `true` or `false` at compile time. The standard library
    provides helper classes for this: `std::true_type` and `std::false_type`. These
    two structures have a static constant member named value set to `true` and `false`,
    respectively. Using SFINAE and template overloads, we can create new detection
    classes that derive from either of these classes to give us the desired outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The first template for `test_find` creates the default behavior that will set
    the return type to `std::false_type`. Note that this has an argument type of `long`.
  prefs: []
  type: TYPE_NORMAL
- en: The second template for `test_find` creates a specialization that tests for
    a class that has a member function called `find()` and has a return type of `std::true_type`.
    Note that this has an argument type of `int`.
  prefs: []
  type: TYPE_NORMAL
- en: The `has_find<T,A0>` template works by deriving itself from the return types
    of the `test_find()` functions. If the T class does not have the `find()` method,
    then only the `std::false_type` version of `test_find()` is generated and so the
    `has_find<T,A0>::value` value will be false and can be used in `if constexpr()`.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part occurs if the T class has the `find()` method as both of
    the `test_find()` methods are generated. But the specialized version takes an
    argument of the `int` type while the default takes an argument of the `long` type.
    As we "call" the function with zero (0), it will match the specialized version
    and use it. The argument difference is important because you cannot have two functions
    with the same argument types and only differ by return type. If you want to check
    this behavior, then change the argument from 0 to 0L to force the long version.
  prefs: []
  type: TYPE_NORMAL
- en: Class Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only dealt with function templates so far. But templates can also be
    used to provide blueprints for classes. The general structure of a templated class
    declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Whereas template functions allow us to produce generic algorithms, template
    classes allow us to produce generic data types and their associated behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: When we introduced the Standard Template Library, we highlighted that it includes
    templates for containers – `vector`, `deque`, `stack`, and so on. These templates
    allow us to store and manage any data type that we want, but still behave as we
    would expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Writing a Class Template'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two of the most commonly used data structures in computing science are stack
    and queue. Both currently have implementations in the STL. But to get our feet
    wet with a templated class, we are going to write a stack template class that
    can be used for any type. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2B** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2B**, then **Exercise04**, and double-click on **Exercise4.cpp**
    to open the file for this exercise in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a new **Launch Configuration**, **L2BExercise4**, to run with the
    name **Exercise4**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, configure a new C/C++ Unit Run Configuration, **L2BEx4Tests**, to run
    **L2BEx4tests**. Set the **Google Tests Runner**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** option for the test, which we have to run for the first
    time:![Figure 2B.32: Initial unit test for stacks'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.32: Initial unit test for stacks'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open `#pragma once`) which tells the compiler that if it encounters this file
    again to be #included, it does not need to be. While not strictly part of the
    standard, nearly all modern C++ compilers support it. Finally, note that, for
    the purpose of this exercise, we have chosen to store the items in the STL vector.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, add the following declaration in the `public` section of the
    `Stack` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the file, change **EXERCISE4_STEP** to a value of **10**. Click
    on the **Run** button. The Exercise 4 tests should run and fail:![Figure 2B.33:
    Jumping to a Failing test'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_02B_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.33: Jumping to a Failing test'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on the name of the failing test, that is, `empty()` reports false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `ASSERT_FALSE` to `ASSERT_TRUE` and rerun the test. This time, it passes
    because it is testing the right thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next thing we will do is add some type aliases ready for use with the next
    few methods. In the editor, add the following lines just above the `empty()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to rerun the tests. They should pass. When doing
    test-driven development, the mantra is to write a small test and see it fail,
    and then write just enough code to make it pass. In this case, we actually tested
    that we got the definition of the aliases correct because failing to compile is
    one form of test failure. We are now ready to add the push function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change **Stack.hpp** by adding the following code just below
    the **empty()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the file, change `EXERCISE4_STEP` to a value of `15`. Click on
    the `PushOntoStackNotEmpty`, in **StackTests.cpp** proves that the push does something
    to make the stack no longer empty. We need to add more methods to make sure that
    it has done the expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change `push()` method and change `EXERCISE4_STEP` to a value
    of `16`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to run the tests. There should now have three passing
    tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change `push()` method and change `EXERCISE4_STEP` to a value
    of `18`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to run the tests. There should now be four passing
    tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change `pop()` method and change `EXERCISE4_STEP` to a value
    of `20`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to run the tests. There are now five passing tests
    and we have implemented a stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Launch Configuration dropdown, select **L2BExercise4** and click on
    the **Run** button. Exercise 4 will run and produce something similar to the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2B.34: Exercise 4 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.34: Exercise 4 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Examine the code that is now in the `std::stack` template takes two arguments,
    with the second one defining the container to be used – vector could be the first.
    Examine the tests in **StackTests.cpp**. The tests should be named to indicate
    what they aim to test, and they should focus on doing that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Developing a Generic "contains" Template Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The programming language Python has a membership operator called "in" that can
    be used on any sequence, that is, list, sequence, set, string, and so on. Even
    though C++ has over 100 algorithms, it does not have an equivalent method to achieve
    the same. C++ 20 introduced the `contains()` method on `std::set`, but that is
    not enough for us. We need to create a `contains()` template function that works
    with `std::set`, `std::string`, `std::vector`, and any other container that provides
    iterators. This is determined by the ability to call end() on it. We are aiming
    for best performance, so we will call the `find()` member method on any container
    that has one (it will be the most efficient) and otherwise fall back to using
    `std::end()` on the container. We also need to treat `std::string()` differently
    as its `find()` method returns a special value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could implement this using a general template and two specializations, but
    this activity is being used to get it working using the techniques of SFINAE and
    if constexpr. In addition, this template must only work on a class that supports
    `end(C)`. Follow these steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the prepared project from the **Lesson2B/Activity01** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the helper template functions and class to detect the std:string case
    using the `npos` member.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the helper template functions and class to detect whether the class has
    a `find()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the contains template function that uses constexpr to select between
    one of three implementations – string case, the has find method, or general case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After implementing the preceding steps, the expected output should look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2B.35: Output from the successful implementation of contains'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.35: Output from the successful implementation of contains'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 653.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned about interfaces, inheritance, and polymorphism,
    which extended our skills of what we can do with our types. We had our first adventure
    into generic programming with C++ templates and touched on what the language gives
    us for free from the C++ Standard Library, which includes the STL. We explored
    a feature of C++ that just works, that is, template type deduction, which makes
    our life easier when using templates. We then went further with templates and
    learned how to control the parts of the template that are included by the compiler
    using SFINAE and if constexpr. These form the building blocks for our journey
    into C++. In the next chapter, we will revisit the stack and the heap, and understand
    what an exception is, what happens, and when it occurs. We'll also learn how to
    protect our programs from resource losses when exceptions occur.
  prefs: []
  type: TYPE_NORMAL
