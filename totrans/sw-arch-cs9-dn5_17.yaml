- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Practices in Coding C# 9
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you act as a software architect on a project, it is your responsibility
    to define and/or maintain a coding standard that will direct the team to program
    according to the expectations of the company. This chapter covers some of the
    best practices in coding that will help developers like you program safe, simple,
    and maintainable software. It also includes tips and tricks for coding in C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: How the complexity of your code can affect performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of using a version control system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing safe code in C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET core tips and tricks for coding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book use case – DOs and DON'Ts in writing code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# 9 was launched together with .NET 5\. However, the practices presented here
    can be used in many versions of .NET, but they refer to the basics of programming
    C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the Visual Studio 2019 free Community Edition or better
    with all database tools installed. You will find the sample code for this chapter
    at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The more complex your code, the worse a programmer you are
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many people, a good programmer is one who writes complex code. However,
    the evolution of maturity in software development means there is a different way
    of thinking about it. Complexity does not mean a good job; it means poor code
    quality. Some incredible scientists and researchers have confirmed this theory
    and emphasize that professional code needs to be focused on time, high quality,
    and within budget.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Even when you have a complex scenario on your hands, if you reduce ambiguities
    and clarify the process of what you are coding, especially using good names for
    methods and variables, and respecting SOLID principles, you will turn complexity
    into simple code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want to write good code, you need to keep the focus on how to do
    it, considering you are not the only one who will read it later. This is a good
    tip that changes the way you write code. This is how we will discuss each point
    of this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'If your understanding of the importance of writing good code is aligned to
    the idea of simplicity and clarity while writing it, you should look at the Visual
    Studio tool **Code Metrics**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: Calculating code metrics in Visual Studio'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Code Metrics** tool will deliver metrics that will give you insights
    regarding the quality of the software you are delivering. The metrics that the
    tool provides can be found at this link: [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019).
    The following subsections are focused on describing how they are useful in some
    real-life scenarios.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability index
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This index indicates how easy it is to maintain the code – the easier the code,
    the higher the index (limited to 100). Easy maintenance is one of the key points
    to keep software in good health. It is obvious that any software will require
    changes in the future, since change is inevitable. For this reason, consider refactoring
    your code if you have low levels of maintainability. Writing classes and methods
    dedicated to a single responsibility, avoiding duplicate code, and limiting the
    number of lines of code of each method are examples of how you can improve the
    maintainability index.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Cyclomatic complexity
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The author of *Cyclomatic Complexity Metric* is Thomas J. McCabe. He defines
    the complexity of a software function according to the number of code paths available
    (graph nodes). The more paths you have, the more complex your function is. McCabe
    considers that each function must have a complexity score of less than 10\. That
    means that, if the code has more complex methods, you must refactor it, transforming
    parts of these codes into separate methods. There are some real scenarios where
    this behavior is easily detected:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Loops inside loops
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of consecutive `if-else`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch` with code processing for each `case` inside the same method'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, look at the first version of this method for processing different
    responses of a credit card transaction. As you can see, the cyclomatic complexity
    is bigger than the number considered by McCabe as a basis. The reason why this
    happens is because of the number of `if-else` inside each case of the main `switch`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you calculate the code metrics of this code, you will find a bad result
    when it comes to cyclomatic complexity, as you can see in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: High level of cyclomatic complexity'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The code itself makes no sense, but the point here is to show you the number
    of improvements that can be made with a view to writing better code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The options from `switch-case` could be written using `Enum`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `case` processing can be done in a specific method
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch-case` can be substituted with `Dictionary<Enum, Method>`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By refactoring this code with the preceding techniques, the result is a piece
    of code that is much easier to understand, as you can see in the following code
    snippet of its main method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The full code can be found on the GitHub repository of this chapter and demonstrates
    how lower-complexity code can be achieved. The following screenshot shows these
    results according to code metrics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_03.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: Cyclomatic complexity reduction after refactoring'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, there is a considerable reduction
    in complexity after refactoring. In *Chapter 13*, *Implementing Code Reusability
    in C# 9*, we discussed the importance of refactoring for code reuse. The reason
    why we are doing this here is the same – we want to eliminate duplication.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is that with the techniques applied, the understanding of
    the code increased and the complexity decreased, proving the importance of cyclomatic
    complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Depth of inheritance
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This metric represents the number of classes connected to the one that is being
    analyzed. The more classes you have inherited, the worse the metric will be. This
    is like class coupling and indicates how difficult it is to change your code.
    For instance, the following screenshot has four inherited classes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_04.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: Depth of inheritance sample'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in the following screenshot that the deeper class has the worse
    metric, considering there are three other classes that can change its behavior:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_05.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: Depth of inheritance metric'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is one of the basic object-oriented analysis principles. However,
    it can sometimes be bad for your code in that it can cause dependencies. So, if
    it makes sense to do so, instead of using inheritance, consider using composition.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Class coupling
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you connect too many classes in a single class, obviously you will get
    coupling, and this can cause bad maintenance of your code. For instance, refer
    to the following screenshot. It shows a design where aggregation has been performed
    a lot. There is no sense to the code itself:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_06.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: Class coupling sample'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have calculated the code metrics for the preceding design, you will
    see that the number of class coupling instances for the `ProcessData()` method,
    which calls `ExecuteTypeA()`, `ExecuteTypeB()`, and `ExecuteTypeC()`, equals three
    (`3`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_07.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: Class coupling metric'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Some papers indicate that the maximum number of class coupling instances should
    be nine (`9`). With aggregation being a better practice than inheritance, the
    use of interfaces will solve class coupling problems. For instance, the same code
    with the following design will give you a better result:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_08.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.8: Reducing class coupling'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that using the interface in the design will allow you the possibility
    of increasing the number of execution types without increasing the class coupling
    of the solution:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_09.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.9: Class coupling results after applying aggregations'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you must consider designing your solution to have more
    cohesion than coupling. The literature indicates that good software has low coupling
    and high cohesion. In software development, high cohesion indicates a scenario
    where you should have a software in which each class must have its methods and
    data with good relationships between them. On the other hand, low coupling indicates
    software where the classes are not closely and directly connected. This is a basic
    principle that can guide you to a better architectural model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Lines of code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This metric is useful in terms of making you understand the size of the code
    you are dealing with. There is no way to connect lines of code and complexity
    since the number of lines is not indicative of that. On the other hand, the lines
    of code show the software size and software design. For instance, if you have
    too many lines of code in a single class (more than 1,000 lines of code – 1KLOC),
    this indicates that it is a bad design.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Using a version control system
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may find this topic in this book a bit obvious, but many people and companies
    still do not regard having a version control system as a basic tool for software
    development! The idea of writing about it is to force you to understand it. There
    is no architectural model or best practice that can save software development
    if you do not use a version control system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, we have been enjoying the advantages of online version
    control systems, such as GitHub, BitBucket, and Azure DevOps. The fact is, you
    must have a tool like that in your software development life cycle and there is
    no reason to not have it anymore since most providers offer free versions for
    small groups. Even if you develop by yourself, these tools are useful for tracking
    your changes, managing your software versions, and guaranteeing the consistency
    and integrity of your code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with version control systems in teams
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of a version control system tool when you are alone is obvious. You
    want to keep your code safe. But this kind of system was developed to solve team
    problems while writing code. For this reason, some features, such as branching
    and merging, were introduced to keep code integrity even in scenarios where the
    number of developers is quite large.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you will have to decide which branch strategy you will
    conduct in your team. Azure DevOps and GitHub suggest different ways to deliver
    that, and both are useful in some scenarios.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about how the Azure DevOps team deals with this can be found here:
    [https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/).
    GitHub describes its process at [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
    We have no idea of which is the one that best fits your needs, but we do want
    you to understand that you need to have a strategy for controlling your code.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 20*, *Understanding DevOps Principles*, we will discuss this in
    more detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Writing safe code in C#
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# can be considered a safe programming language by design. Unless you force
    it, there is no need for pointers, and memory release is, in most cases, managed
    by the garbage collector. Even so, some care should be taken so you can get better
    and safe results from your code. Let us have a look at some common practices to
    ensure safe code in C#.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: try-catch
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exceptions in coding are so frequent that you should have a way to manage them
    whenever they happen. `try-catch` statements are built to manage exceptions and
    they are important for keeping your code safe. There are a lot of cases where
    an application crashes and the reason for that is the lack of using `try-catch`.
    The following code shows an example of the lack of usage of the `try-catch` statement.
    It is worth mentioning that this is just an example for understanding the concept
    of an exception thrown without correct treatment. Consider using `int.TryParse(textToConvert,
    out int result)` to handle cases where a parse is unsuccessful:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the other hand, bad `try-catch` usage can cause damage to your code too,
    especially because you will not see the correct behavior of that code and may
    misunderstand the results provided.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example of an empty `try-catch` statement:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`try-catch` statements must always be connected to logging solutions, so that
    you can have a response from the system that will indicate the correct behavior
    and, at the same time, will not cause application crashes. The following code
    shows an ideal `try-catch` statement with logging management. It is worth mentioning
    that specific exceptions should be caught whenever possible, since catching a
    general exception will hide unexpected exceptions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As a software architect, you should conduct code inspections to fix this kind
    of behavior found in the code. Instability in a system is often connected to the
    lack of `try-catch` statements in the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: try-finally and using
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory leaks can be considered one of software's worst behaviors. They cause
    instability, bad usage of computer resources, and undesired application crashes.
    C# tries to solve this with Garbage Collector, which automatically releases objects
    from memory as soon as it realizes the object can be freed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects that interact with I/O are the ones that generally are not managed
    by Garbage Collector: filesystem, sockets, and so on. The following code is an
    example of the incorrect usage of a `FileStream` object, because it thinks Garbage
    Collector will release the memory used, but it will not:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Besides, it takes a while for Garbage Collector to interact with objects that
    need to be released and sometimes you may want to do it yourself. For both cases,
    the use of `try-finally` or `using` statements is the best practice:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code shows exactly how to deal with objects that are not managed
    by Garbage Collector. You have both `try-finally` and `using` being implemented.
    As a software architect, you do need to pay attention to this kind of code. The
    lack of `try-finally` or `using` statements can cause huge damage to software
    behavior when it is running. It is worth mentioning that using code analysis tools
    (now distributed with .NET 5) will automatically alert you to these sorts of problems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The IDisposable interface
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the same way that you will have trouble if you do not manage objects created
    inside a method with `try-finally`/`using` statements, objects created in a class
    that does not properly implement the `IDisposable` interface may cause memory
    leaks in your application. For this reason, when you have a class that deals with
    and creates objects, you should implement the disposable pattern to guarantee
    the release of all resources created by it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_17_10.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.10: IDisposable interface implementation'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once you have the code inserted, you need to follow the TODO instructions so
    that you have the correct pattern implemented.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: .NET 5 tips and tricks for coding
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET 5 implements some good features that help us to write better code. One
    of the most useful for having safer code is **dependency injection** (**DI**),
    which was already discussed in *Chapter 11*, *Design Patterns and .NET 5 Implementation*.
    There are some good reasons for considering this. The first one is that you will
    not need to worry about disposing the injected objects since you are not going
    to be the creator of them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, DI enables you to inject `ILogger`, a useful tool for debugging exceptions
    that will need to be managed by `try-catch` statements in your code. Furthermore,
    programming in C# with .NET 5 must follow the common good practices of any programming
    language. The following list shows some of these:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**Classes, methods, and variables should have understandable names**: The name
    should explain everything that the reader needs to know. There should be no need
    for an explanatory comment unless these declarations are public.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods cannot have high complexity levels**: Cyclomatic complexity should
    be checked so that methods do not have too many lines of code.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Members must have the correct visibility**: As an object-oriented programming
    language, C# enables encapsulation with different visibility keywords. C# 9.0
    is presenting *Init-only setters* so you can create `init` property/index accessors
    instead of `set`, defining these members as read-only following construction of
    the object.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duplicate code should be avoided**: There is no reason for having duplicate
    code in a high-level programming language such as C#.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects should be checked before usage**: Since null objects can exist, the
    code must have null-type checking. It is worth mentioning that since C# 8, we
    have nullable reference types to avoid errors related to nullable objects.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constants and enumerators should be used**: A good way of avoiding magic
    numbers and text inside code is to transform this information into constants and
    enumerators, which generally are more understandable.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsafe code should be avoided**: Unsafe code enables you to deal with pointers
    in C#. Unless there is no other way to implement the solution, unsafe code should
    be avoided.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**try-catch statements cannot be empty**: There is no reason for a `try-catch`
    statement without treatment in the `catch` area. More than that, the caught exceptions
    should be as specific as possible, and not just an "exception," to avoid swallowing
    unexpected exceptions.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dispose of the objects that you have created, if they are disposable**: Even
    for objects where Garbage Collector will take care of the disposed-of object,
    consider disposing of objects that you were responsible for creating yourself.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**At least public methods should be commented**: Considering that public methods
    are the ones used outside your library, they must be explained for their correct
    external usage.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**switch-case statements must have a default treatment**: Since the `switch-case`
    statement may receive an entrance variable unknown in some cases, the default
    treatment will guarantee that the code will not break in such a situation.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-t)
    for more information about nullable reference types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you may consider a good practice of providing a code
    pattern for your developers that will be used to keep the style of the code consistent.
    You can also use this code pattern as a checklist for coding inspection, which
    will enrich software code quality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: WWTravelClub – DOs and DON'Ts in writing code
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a software architect, you must define a code standard that matches the needs
    of the company you are working for.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In the sample project of this book (check out more about the WWTravelClub project
    in *Chapter 1*, *Understanding the Importance of Software Architecture*), this
    is no different. The way we decided to present the standard for it is by describing
    a list of DOs and DON'Ts that we followed while writing the samples we produced.
    It is worth mentioning that the list is a good way to start your standard and,
    as a software architect, you should discuss this list with the developers you
    have in the team so that you can evolve it in a practical and good manner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, these statements are designed to clarify the communication between
    team members and improve the performance and maintenance of the software you are
    developing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: DO write your code in English
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO follow C# coding standards with CamelCase
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO write classes, methods, and variables with understandable names
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO comment public classes, methods, and properties
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO use the `using` statement whenever possible
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DO use `async` implementation whenever possible
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DON'T write empty `try-catch` statements
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DON'T write methods with a cyclomatic complexity score of more than 10
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DON'T use `break` and `continue` inside `for/while/do-while/foreach` statements
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These DOs and DON'Ts are simple to follow and, better than that, will yield
    great results for the code your team produces. In *Chapter 19*, *Using Tools to
    Write Better Code*, we will discuss the tools to help you implement these rules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During this chapter, we discussed some important tips for writing safe code.
    This chapter introduced a tool for analyzing code metrics so that you can manage
    the complexity and maintainability of the software you are developing. To finish,
    we presented some good tips to guarantee that your software will not crash due
    to memory leaks and exceptions. In real life, a software architect will always
    be asked to solve this kind of problem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about some unit testing techniques, the principles
    of unit testing, and a software process model that focuses on C# test projects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need to care about maintainability?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is cyclomatic complexity?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the advantages of using a version control system.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Garbage Collector?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the importance of implementing the `IDisposable` interface?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages do we gain from .NET 5 when it comes to coding?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some books and websites where you will find more information about
    the topics of this chapter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*Clean Code: A Handbook of Agile Software Craftmanship*, by Martin, Robert
    C. Pearson Education, 2012.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Art of Designing Embedded Systems*, by Jack G. Ganssle. Elsevier, 1999.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring*, by Martin Fowler. Addison-Wesley, 2018.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Complexity Measure*, by Thomas J. McCabe. IEEE Trans. Software Eng. 2(4):
    308-320, 1976 ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html)).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/](https://github.com/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://bitbucket.org/](https://bitbucket.org/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/](https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9)'
