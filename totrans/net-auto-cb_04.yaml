- en: Building Data Center Networks with Arista and Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will outline how to automate Arista switches in a typical
    data center environment in a leaf-spine architecture. We will explore how to interact
    with Arista devices using Ansible, and how to deploy **virtual local area networks**
    (**VLANs**) and **virtual extensible LANs** (**VXLANs**) in a **Border Gateway
    Protocol/Ethernet virtual private network** (**BGP/EVPN)** setup on the Arista
    switches using various Ansible modules. We will base our illustration on the following
    sample network diagram of a basic leaf-spine **data center network** (**DCN**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c1fb1ade-4c7d-4961-ad9d-24c18b2d42d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table outlines the devices in our sample topology and their respective
    management **internet protocols** (**IPs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device** | **Role** | **Vendor** | **Management (MGMT) Port** | **MGMT
    IP** |'
  prefs: []
  type: TYPE_TB
- en: '| Spine01 | Spine Switch | Arista vEOS 4.20 | Management1 | `172.20.1.35` |'
  prefs: []
  type: TYPE_TB
- en: '| Spine02 | Spine Switch | Arista vEOS 4.20 | Management1 | `172.20.1.36` |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf01 | Leaf Switch | Arista vEOS 4.20 | Management1 | `172.20.1.41` |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf02 | Leaf Switch | Arista vEOS 4.20 | Management1 | `172.20.1.42` |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf03 | Leaf Switch | Arista vEOS 4.20 | Management1 | `172.20.1.43` |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf04 | Leaf Switch | Arista vEOS 4.20 | Management1 | `172.20.1.44` |'
  prefs: []
  type: TYPE_TB
- en: 'The main recipes covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the Ansible network inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to and authenticating Arista devices from Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling **extensible operating system** (**EOS**) **API** (**eAPI**) on Arista
    devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring generic system options on Arista devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring interfaces on Arista devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the underlay BGP on Arista devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the overlay BGP/EVPN on Arista devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the configuration on Arista devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring VLANs on Arista devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring VXLAN tunnels on Arista devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering Arista device facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving operational data from Arista devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for all the recipes in this chapter can be found on the following
    GitHub repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch4_arista](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch4_arista).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is based on the following software releases:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible machine running CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arista **virtualized EOS** (**vEOS**) running EOS 4.20.1F
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3coydTp](https://bit.ly/3coydTp)'
  prefs: []
  type: TYPE_NORMAL
- en: Building the Ansible network inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to build and structure the Ansible inventory
    to describe our sample leaf-spine **direct current** (**DC**) network. The Ansible
    inventory is a pivotal part of Ansible as it outlines and groups devices that
    should be managed by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create a new folder that will host all the files that we will create
    in this chapter. The new folder should be named `ch4_arista`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the new folder (`ch4_arista`), we create a `hosts` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `ansible.cfg` file, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining an Ansible inventory is mandatory, in order to describe and classify
    the devices in our network that should be managed by Ansible. In the Ansible inventory,
    we also specify the IP addresses through which Ansible will communicate with these
    managed devices, using the `ansible_host` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We built the Ansible inventory using the `hosts` file and we defined multiple
    groups in order to group the different devices in our topology. These groups are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We created the `leaf` group, which references all the `leaf` switches in our
    topology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the `spine` group, which references all the `spine` switches in our
    topology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the `arista` group, which references both the `leaf` and `spine`
    groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we created the `ansible.cfg` file and configured it to point to our
    `hosts` file, to be used as the Ansible inventory file. Further, we disabled the
    `setup` module (by setting `gathering` to `explicit)`, which is not needed when
    running Ansible against network nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to and authenticating Arista devices from Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to connect to Arista devices from Ansible
    via **Secure Shell** (**SSH**) in order to start managing the devices from Ansible.
    We are going to use a username and password to authenticate the Arista devices
    in our topology.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. IP reachability between the Ansible
    control machine and all the devices in the network must also be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the `ch4_arista` folder, create a `group_vars` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `group_vars` folder, create an `arista.yml` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Arista switches, we configure the username and password and enable SSH,
    as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Arista switches, configure the management interface with the correct
    IP addresses and place them in the required management **virtual routing and forwarding**
    (**VRF**), as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We specified the username and password that we will configure on all the Arista
    switches in the `arista.yml` file under the `group_vars` directory. This will
    apply these parameters to all the Arista switches in our inventory. On the Arista
    switches, we set up the username and password and enabled SSH, as well as set
    up the correct IP address (the one used in the `ansible_host` parameter in our
    inventory) on the management interface. We configured the management VRF and associated
    the management interface with this VRF.
  prefs: []
  type: TYPE_NORMAL
- en: We are specifying the SSH password in plaintext in our Ansible variables. This
    is only for a lab setup; however, for production, we should use the Ansible vault
    to secure any sensitive information, as outlined in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we are using the `network_cli` connection method so as to use
    SSH to connect to the Arista switches. We can verify that the Ansible controller
    can reach and correctly log in to the devices with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Enabling eAPI on Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to enable eAPI on Arista devices. eAPI is
    a **representational state transfer** (**REST**ful) API on Arista devices, which
    simplifies the management of such devices and provides a consistent and robust
    API to manage them. This task is critical since we will use eAPI in all future
    recipes to manage the Arista device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a prerequisite for this recipe, an Ansible inventory file must be present.
    The SSH authentication should also be deployed and working, as per the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `all.yml` file inside the `group_vars` folder, with the following
    management VRF data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `pb_eos_enable_eapi.yml`, as shown in the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_eos_enable_eapi.yml` playbook with the following task, to enable
    eAPI under the management VRF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `arista.yml` file inside the `group_vars` folder with the connection
    setting to use eAPI as the connection plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start interacting with the Arista devices via eAPI, we need to enable
    it first; thus, we need to SSH into the device initially and enable eAPI. That
    is why, in this recipe, we are using the `network_cli` Ansible connection in order
    to connect with the Arista devices via traditional SSH. Since we are going to
    use eAPI in all interactions with Arista devices in all coming recipes, we enabled `network_cli`
    only under the `vars` parameter on the playbook level, in order to override any
    group- or host-level setting for the `ansible_connection` setting.
  prefs: []
  type: TYPE_NORMAL
- en: We created a new playbook called `pb_eos_enable_eapi.yml`, and, in the first
    task, we used the `eos_eapi` module to enable eAPI protocol on the remote Arista
    devices. We specified that we will use the **Hypertext Transfer Protocol Secure**
    (**HTTPS**) and the standard HTTPS port, which is `443`. In the second task, we
    used the `eos_eapi` module in order to enable eAPI only under a specific VRF,
    which is the management VRF that we are using to manage our devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to start managing the Arista devices using eAPI, we modified
    our Ansible connection settings, which we defined in the `group_vars/arista.yml`
    file, and we included the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible_connection` was set to `httpapi`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_httpapi_use_ssl` was set to `yes` in order to force the use of HTTPS
    and not HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_httpapi_validate_certs` was set to `no` in order to disable certificate
    validations (since we are using the default certificate on the Arista devices,
    which is not signed by a trusted **certificate authority** (**CA**)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we run the playbook, we will see that all the Arista devices are configured
    with eAPI, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate that we are using the correct connection setting and that Ansible
    is able to communicate with the Arista devices using eAPI with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `eos_eapi` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_eapi_module.html](https://docs.ansible.com/ansible/latest/modules/eos_eapi_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring generic system options on Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure some basic system options such
    as hostname and **Domain Name System** (**DNS**) servers, and provision users
    on Arista devices. We will understand how to set up all these system-level parameters
    using the various Ansible modules, and we will outline the different ways to manage
    these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, it is assumed that an Ansible inventory has
    already been set up and eAPI is enabled on all Arista devices, as per the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/all.yml` file with the generic system parameters, as
    shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook, `pb_arista_basic_config.yml`, and add the following
    task to set up the DNS and the hostname:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_arista_basic_config.yml` playbook with the following task to
    create users on the Arista devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides different declarative modules in order to manage the different
    resources on the Arista switches. In this recipe, we outlined how to use the `eos_system`
    and the `eos_user` Ansible modules in order to provision basic system attributes
    on the Arista devices. We started by defining the data that we will use under
    the `group_vars/all.yml` file, and we included the DNS and users that we want
    to provision. We created the `pb_arista_basic_config.yml` playbook, which will
    include all the tasks needed in order to set up the basic settings on the Arista
    switches.
  prefs: []
  type: TYPE_NORMAL
- en: The first task in the playbook used the `eos_system` Ansible module, which sets
    up the DNS and the hostname on all the Arista devices. The second task used the
    `eos_user` Ansible module to set up the system users on the Arista switches. In
    this last task, we looped over the `users` data structure that we defined in the
    `group_vars/all.yml` file in order to provision each user in this `list` data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the playbook, we can see that the configuration of our Arista switches
    is updated, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The declarative Ansible modules that we have outlined in this section provide
    a simple way to configure the basic system-level parameters for Arista devices;
    however, they might not cover all the parameters that we need to set up on an
    Arista switch. In order to have more control and flexibility to configure the
    system-level parameters, we can use Jinja2 templates along with the `template` Ansible
    module to generate the specific system-level configuration needed for our deployment.
    In this section, we will outline this method in order to achieve this goal. This
    will be the method that we will use in subsequent recipes to generate the configuration
    for other configuration sections, which don't have a built-in Ansible module that
    can satisfy all our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to reuse this method to generate the configuration for our Arista
    devices for different sections such as system, interfaces, and BGP. We are going
    to create an Ansible role in order to include all the Jinja2 templates and tasks
    required to generate the final configuration that we will push to our devices.
    The following procedure outlines the steps needed to create the role, and the
    playbook required to generate the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the same role structure and tasks that we used in [Chapter
    3](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml), *Automating Juniper Devices in
    the Service Providers Using Ansible,* to generate the Juniper devices' configuration.
    The only difference will be in the Jinja2 templates that we will use to generate
    the specific configuration for Arista devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `roles` directory and add a new role called `dc_fabirc_config`,
    with the following directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `tasks` folder, create a `build_config_dir.yml` file to create the required
    folders to store the configuration that will be generated, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `templates` folder, create a new folder called `eos`, and within this
    folder, create a new Jinja2 template called `mgmt.j2`, as shown in the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `tasks` folder, create a new YAML file called `build_device_config.yml`
    to create a system configuration, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `main.yml` file in the `tasks` folder, with the following tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `pb_arista_dc_fabric.yml` to generate the configuration
    for all `arista` devices in our inventory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using this method, we created a role called `dc_fabric_config` and we created
    a new Jinja2 template called `mgmt.j2`, which includes the template for `arista`
    system-level configuration. We used the `template` Ansible module in order to
    render the Jinja2 template with the Ansible variables defined under the `group_vars/all.yml`
    file. In order to save the configuration for each device, we created the `configs`
    folder directory, which stores the final configuration for each device.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are utilizing the Jinja2 approach in order to generate the configuration
    for each section (MGMT, interfaces, BGP, and so on), we will segment each section
    into a separate Jinja2 template and we will generate each section in a separate
    file. We use the `assemble` module in order to group all these different sections
    into a single configuration file, which we will store in the `configs` directory,
    and this is the final and assembled configuration file for each device. We store
    the temporarily assembled sections in a temporary folder for each device, and
    we delete this temporary folder at the end of the playbook run.
  prefs: []
  type: TYPE_NORMAL
- en: In this playbook, we use the `delegate_to` localhost in the `import_role` task.
    Since in all the tasks within this role we don't need to connect to the remote
    device, all these tasks should be run on the Ansible control machine so as to
    store the file locally on the Ansible machine. Thus, we use the `delegate_to` localhost
    in order to run all the tasks on the Ansible control machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the `pb_junos_net_build.yml` playbook, we can see that the following
    configuration files are created inside the `configs` directory and, at this stage,
    it has only the management section of the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the configuration generated for one of the devices (`leaf01`,
    for example), as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, we have generated the system configuration for all the `arista`
    switches in our inventory; however, we still haven't pushed this configuration
    to the devices. In later recipes, we will outline how to push the configuration
    to the `arista` devices.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring interfaces on Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure different interface parameters
    on Arista devices, such as the interface description and IP address information.
    We will outline how to use the various Ansible modules to interact with the interfaces
    on Arista devices, and how to set up the interfaces on all the Arista devices
    in our sample network topology.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are assuming the network inventory is already in place and that eAPI is already
    enabled on Arista switches, as per the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following content to the `group_vars/all.yml` file, which describes
    the interfaces on our sample DC fabric network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_arista_basic_config.yml` playbook with the following task to
    enable the interfaces and set the description on all the fabric interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_arista_basic_config.yml` playbook with the following task to
    set up the IPv4 address on all the **point-to-point** (**P2P**) fabric links:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We defined all the data for all the interfaces in our sample network topology
    in two main data structures in the `group_vars/all.yml` file. We used the `p2p_ip`
    dictionary to model all the P2P IP addresses in our sample network, and we used
    the `lo_ip` dictionary to specify the loopback IP addresses for our nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `eos_interface` Ansible module to enable the interfaces and set
    the basic parameters for the interfaces, such as interface description. We looped
    over the `p2p_ip` data structure for each device, and we set the correct parameters
    for each interface on all the devices in our network inventory. We used the `eos_l3_interface`
    Ansible module to set the correct IPv4 address on all the interfaces in our sample
    network topology across all the devices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case we need to have more control over the interface configuration and to
    set parameters that are not covered by the declarative Ansible modules that we
    have outlined in this section, we can use Jinja2 templates to achieve this goal.
    Using the exact same approach that we outlined in the previous recipe for system
    configuration, we can generate the interface configuration needed for our Juniper
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same Ansible role that we have created in the previous recipe, we
    can extend it to generate the interface configuration for our Arista devices.
    We use the following steps in order to accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Jinja2 template file, `intf.js`, in the `templates` folder, with
    the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `build_device_config.yml` file in the `tasks` directory with the
    new task to generate the interface configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run our `pb_arista_dc_fabric.yml` playbook, we will generate the configuration
    for our devices, with the `interface` section updated for `leaf01`, as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `eos_interface` module and the different
    parameters supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_interface_module.html](https://docs.ansible.com/ansible/latest/modules/eos_interface_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding the `eos_l3_interface` module and the different
    parameters supported by this module, please, consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_l3_interface_module.html](https://docs.ansible.com/ansible/latest/modules/eos_l3_interface_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the underlay BGP on Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will outline how to configure eBGP as the underlay routing
    protocol for our sample leaf/spine DC fabric. We are going to build the eBGP peering
    setup, using the P2P IP address between the leaf switches and spine switches.
    The BGP **autonomous system number** (**ASN**) assignment is as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Node** | **BGP ASN** |'
  prefs: []
  type: TYPE_TB
- en: '| Spine01 | 65100 |'
  prefs: []
  type: TYPE_TB
- en: '| Spine02 | 65100 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf01 | 65001 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf02 | 65002 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf03 | 65003 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf04 | 65004 |'
  prefs: []
  type: TYPE_TB
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are assuming that the interface and IP address information
    is already configured, as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `host_vars` directory and create a folder for each device in our inventory.
    In each folder, create a new YAML file, `underlay_bgp.yml`, with the BGP peering
    details. Here is an example for the `leaf01` device in our inventory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Jinja2 file, `underlay_bgp.j2`, in the `templates/eos` directory,
    with the following data. This template is for the `prefix-list` that we will use
    to control BGP advertisement in our DC fabric:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `underlay_bgp.j2` Jinja2 file in the `templates/eos` directory with
    the BGP template, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `build_config.yml` file inside the `tasks` folder, add the following
    task to render the underlay BGP configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per our design, we are going to run eBGP between the leaf and spine nodes,
    and each leaf switch in our topology will have its own BGP ASN. The optimal method
    to describe this setup is to include all this data on a per-host basis, using
    the `host_vars` folder. We created a folder for each node to include all the relevant
    host data under this folder. We created a YAML file to hold the BGP information
    for each device, thus we can easily add a new file if we need to add more host-specific
    data for another protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the `tasks/build_device_config.yml` file, we added a new task that uses the `underlay_bgp.j2` Jinja2
    template to render the Jinja2 template and output the underlay BGP configuration
    section for each device outlined in our Ansible inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each device, we generated a `prefix-list` to match all the prefixes that
    will advertise to its eBGP peers, as per the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: For spine switches, we advertise all the leaf loopback IP addresses along with
    the spine loopback interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the leaf switches, we advertise only the loopback IP address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet outlines the BGP configuration generated for the `leaf01`
    device after running the playbook with the new task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the overlay BGP EVPN on Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure the overlay BGP EVPN as the
    control plane for VXLAN tunnels across our leaf-spine DC fabric in our sample
    topology, using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes the P2P IP addresses and loopback interfaces have been configured
    as per previous recipes. Also, the underlay BGP configuration should already be
    generated as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Jinja2 file, `overlay_bgp.j2`, in the `templates/eos` directory,
    with the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `build_config.yml` file inside the `tasks` folder, add the following
    highlighted task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we used a similar methodology to how we configured the underlay
    eBGP. We built a Jinja2 template to generate the needed BGP EVPN configuration
    for the Arista devices in our inventory. The following code block shows a sample
    of the BGP EVPN configuration for the `leaf01` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Deploying the configuration on Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to push the configuration to the Arista
    devices. We will use the configuration that we have generated in the previous
    recipes to provision the devices in our topology. We will learn how to interact
    with the Arista configuration using the suitable Ansible module, in order to correctly
    provision the devices as per the intended network design.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires eAPI to be enabled on the Arista devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `pb_arista_dc_fabric.yml` file, add the following task to deploy the
    configuration to the Arista switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we generated different sections of the configuration
    for the Arista switches, such as interfaces, and underlay/overlay BGP. We have
    used the `assemble` Ansible module in order to combine the different sections
    of the configuration into a single configuration file that holds all the device
    configurations. In this recipe, we used the `eos_config` module in order to push
    the configuration file to the Arista switch.
  prefs: []
  type: TYPE_NORMAL
- en: In the `eos_config` module, we used the `src` parameter in order to specify
    the location of the configuration file that we want to load into our devices.
    We used the `replace` directive with the `config` option in order to replace all
    the configuration on the target device with the new configuration that we specified
    in the `src` option. Thus, the configuration on the devices is completely managed
    and controlled by Ansible. This also means that if there is any configuration
    that was implemented outside of our Ansible playbook, the configuration will be
    deleted once we run the playbook and push the new configuration to the devices.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the `save_when` parameter and set it to `changed` in order
    to copy the running configuration to the `startup-config` and save the configuration.
    We only perform this action in case the task changed the configuration on the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `eos_config` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_config_module.html](https://docs.ansible.com/ansible/latest/modules/eos_config_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VLANs on Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will outline how to configure VLANs on Arista switches.
    The VLANs that we will build across our DC fabric are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Node** | **Interface** | **Interface Type** | **VLANs** |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf01 | Ethernet1 | Access | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf02 | Ethernet1 | Access | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf03 | Ethernet1 | Access | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf03 | Ethernet2 | Access | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf04 | Ethernet1 | Access | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf04 | Ethernet2 | Access | 20 |'
  prefs: []
  type: TYPE_TB
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is assuming that underlay and overlay BGP configuration is already
    generated, as per the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new YAML file called `vlan_design.yml` that will hold our VLAN design
    for our DC fabric, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new role, `provision_vlans`, in the `roles` folder, with the following
    structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `tasks/main.yml` file, include the following task to configure the VLANs
    on our DC fabric:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook, `pb_deploy_vlans.yml`, that uses the role to order to
    provision VLANs on our DC fabric, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to provision the VLANs on our DC fabric, we modeled and defined our
    VLAN membership in a YAML file called `vlan_design.yml`. This file models all
    the VLANs across all the switches in our fabric in the `vlan_data` dictionary.
    Each key in this dictionary is the device, and the values are a list of dictionaries,
    each corresponding to a single VLAN definition.
  prefs: []
  type: TYPE_NORMAL
- en: We created a specific role, `provision_vlans`, to provision VLANs on our fabric, and
    the initial task in this role used the `eos_vlan` Ansible module to provision
    the VLANs. We looped over the `vlan_data` specific to each node and provisioned
    these VLANs.
  prefs: []
  type: TYPE_NORMAL
- en: We created a `pb_deploy_vlans.yml` playbook that uses this role to deploy the
    VLANs. We read the `vlan_design.yml`  file using the `vars_files` parameter, and
    we imported the `provision_vlans` role using `import_roles`. We used the `when`
    directive in order to only call this role on the devices defined in our VLAN `design`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run our playbook, we can see that the VLANs are deployed across our
    fabric as outlined here for `leaf03`, as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `eos_vlan` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_vlan_module.html](https://docs.ansible.com/ansible/latest/modules/eos_vlan_module.html).[ ](https://docs.ansible.com/ansible/latest/modules/eos_vlan_module.html)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VXLANs tunnels on Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will outline how to configure VXLAN tunnels using BGP EVPN
    across our leaf-spine fabric. In an IP fabric similar to our sample topology,
    we need to have VXLAN tunnels in order to transport the L2 VLANs across our fabric.
    The following table outlines the VLAN to the **virtual network identifier** (**VNI**)
    mapping that we will use across our fabric:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **VLAN** | **VNI** |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1010 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 1020 |'
  prefs: []
  type: TYPE_TB
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is assuming that BGP EVPN is already deployed across our fabric
    and that all the VLANs are provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `vars/main.yml` folder in the `provision_vlans` role with the following
    variable. This will define the directory to store the VXLAN configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `provision_vlans` role, create a `templates` folder. Then, in it, create
    an `eos` folder. After that, create a Jinja2 `vxlan.j2` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `tasks/main.yml` file in the `provision_vlans` role with the following
    tasks to generate the VXLAN configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `tasks/main.yml` file with the following tasks to deploy the VXLAN
    configuration on our DC fabric switches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we outlined how to provision VLANs across our DC fabric.
    However, in an IP fabric, we need to have tunneling in order to transport the
    L2 VLANs across the DC fabric. In this recipe, we outlined how to build VXLAN
    tunnels using BGP EVPN in order to transport the L2 VLANs and to finish the VLAN
    provisioning task across our DC fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Since the VXLAN tunnels are tightly coupled with the respective VLANs, we included
    the setup of the VXLAN tunnels within our `provision_vlans` role. We used the
    Jinja2 templates and the `template` Ansible module in order to generate the VXLAN
    and BGP configuration needed on each switch to deploy our VXLAN tunnels. We created
    a new folder to house the VXLAN configuration that we will generate for each switch.
    We utilized the `template` Ansible module to render the VLAN data defined in our
    `vlan_design.yml` file with the Jinja2 template to generate the VXLAN configuration
    for each switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run our updated playbook, we can see that the new folder is created
    and the configuration for all our switches is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block shows a sample configuration for the VXLAN configuration,
    generated for the `leaf01` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Gathering Arista device facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to retrieve the basis system facts collected
    by Ansible for an Arista device running the Arista EOS software. These basic system
    facts provide us with a basic health check regarding our Arista devices, which
    we can use to validate its operational state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: eAPI must be enabled on the Arista devices so you can use the Ansible modules
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook, `pb_arista_facts.yml`, with the following task to collect
    the facts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_arista_facts.yml` playbook with the following tasks to validate
    the operational state of all our fabric interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to validate the correct IP address
    assignment for all our fabric interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a fact-gathering module to collect the basic system properties
    for Arista devices and returns these facts in a consistent and structured data
    structure. We can use the facts collected by this module in order to validate
    the basic properties and operational state of our devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we used the `eos_facts` module to collect the device facts
    for all our Arista devices. This module returned the basic facts collected by
    Ansible for each device in multiple variables. The main variable that we are interested
    in is the `ansible_net_interfaces` variable, which holds all the operational state
    of all the interfaces on the device. The following snippet outlines a sample of
    the data stored in this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We used the data retrieved by Ansible and stored in the `ansible_net_interfaces` variable
    in order to validate that all the fabric interfaces are operational and that they
    have the correct IP address assigned as per our design. We used the `assert` module
    in order to perform this validation, and we looped over the `p2p_ip` data structure
    for each device in order to validate the state for only our fabric interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `eos_facts` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_facts_module.html](https://docs.ansible.com/ansible/latest/modules/eos_facts_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving operational data from Arista devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to execute operational commands on Arista
    devices, and use the output to validate the state of the devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: eAPI must be enabled on the Arista devices in order to follow along with this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook called `pb_get_vlans.yml` and populate it to execute
    the `show vlan` command on all leaf switches and store the output in a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_get_vlans.yml` playbook and populate it with the following task
    to compare and validate that correct VLANs are configured on the devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We executed operational commands on the Arista switches using the `eos_command`
    Ansible module and, in order to return structured output, we used the `json` keyword
    in the command to return the JSON output of the operational command (if supported).
    In this example, we sent the `show vlan` command to get the list of VLANs configured
    on the devices, and we collected the output in the `show_vlan` variable. The following
    snippet outlines the output we get from the devices, which is stored in this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We used the `assert` module to validate that the VLANs defined within our design
    (in the `vlans_design.yml` file) were all configured and operational for each
    of the switches. We compared the VLANs defined in this file with the output that
    we retrieved from the devices using the `eos_command` module (which is stored
    in the `show_vlan` variable) in order to ensure that each VLAN was active on the
    switches.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `string` Jinja2 filter in our `assert` statement since the
    VLANs are defined as integers in our `vlan_design.yml` file. However, the VLANs
    stored in the `show_vlan` variable are strings. Thus, in order for the `assert` statement
    to succeed, we need to make sure that the type is similar.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `eos_command` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_command_module.html](https://docs.ansible.com/ansible/latest/modules/eos_command_module.html)
  prefs: []
  type: TYPE_NORMAL
