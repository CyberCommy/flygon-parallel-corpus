- en: Chapter 6. UDP and Multicasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**User Datagram Protocol** (**UDP**) sits on top of IP and provides an unreliable
    counterpart to TCP. UDP sends individual packets between two nodes in a network.
    UDP packets do not have knowledge of other packets, and there is no guarantee
    that a packet will actually arrive at its intended destination. When multiple
    packets are sent, there is no guarantee of the arrival order. UDP messages are
    simply sent and then forgotten as there are no acknowledgements sent from a recipient.'
  prefs: []
  type: TYPE_NORMAL
- en: UDP is a connectionless protocol. There is no exchange of messages between two
    nodes to facilitate the packet transmission. No state information is maintained
    about the connection.
  prefs: []
  type: TYPE_NORMAL
- en: UDP is appropriate for services where delivery needs to be efficient, and no
    guarantee of delivery is needed. For example, it is used for **Domain Name System**
    (**DNS**) services, **Network** **Time Protocol** (**NTP**) services, **Voice
    Over IP** (**VOIP**), network communication coordination by P2P networks, and
    for video streaming. If a video frame is lost, then the viewer may never notice
    it if the loss does not occur frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several protocols that use UDP, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real Time Streaming Protocol (RTSP)**: This protocol is used to control the
    streaming of media'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing Information Protocol (RIP)**: This protocol determines the route
    that is used to transmit packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain Name System (DNS)**: This protocol looks up an Internet domain name
    and returns its IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Time Protocol (NTP)**: This protocol synchronizes clocks across the
    Internet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A UDP packet consists of an IP address and port number to identify its destination.
    The UDP packets have a fixed size and can be as large as 65,353 bytes. However,
    each packet uses a minimum of 20 bytes for an IP header and 8 bytes for a UDP
    header, limiting the size of a message to 65,507 bytes. If a message is larger
    than that, then multiple packets will need to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: UDP packets can also be multicast. This means that a packet is sent to every
    node that belongs to a UDP group. This is an efficient way of sending information
    to multiple nodes without having to explicitly target each node. Instead, the
    packet is sent to a group whose members are responsible for capturing its group's
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will illustrate how the UDP protocol can be used to:'
  prefs: []
  type: TYPE_NORMAL
- en: Support the traditional client/server model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use NIO Channels to perform UDP operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicast packets to group members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream media such as audio or video to a client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with an overview of Java support for UDP and provide more UDP
    protocol details.
  prefs: []
  type: TYPE_NORMAL
- en: Java support for UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java uses the `DatagramSocket` class to form socket connections between nodes.
    The `DatagramPacket` class represents a packet of data. Simple send and receive
    methods will transmit the packets across a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'UDP uses an IP address and a port number to identify nodes. UDP port numbers
    range from `0` to `65535`. Port numbers are broken down into three types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well-known ports (`0` to `1023`): These are port numbers that are used for
    relatively common services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Registered ports (`1024` to `49151`): These are port numbers that are assigned
    by IANA to a process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamic/private ports (`49152` to `65535`): These are dynamically assigned
    to clients when a connection is initiated. These are normally temporary and cannot
    be assigned by IANA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table is a short list of UDP specific port assignments. They
    illustrate how UDP is widely used to support many diverse applications and services.
    A more complete list of TCP/UDP port numbers is found at [https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Well-known ports (0 to 1023) | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `7` | This is the echo protocol |'
  prefs: []
  type: TYPE_TB
- en: '| `9` | This means wake-on-LAN |'
  prefs: []
  type: TYPE_TB
- en: '| `161` | This is the **Simple** **Network Management Protocol** (**SNMP**)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `319` | These are **Precision Time Protocol** (**PTP**) event messages |'
  prefs: []
  type: TYPE_TB
- en: '| `320` | These are PTP general messages |'
  prefs: []
  type: TYPE_TB
- en: '| `513` | This indicates who the user is |'
  prefs: []
  type: TYPE_TB
- en: '| `514` | This is the syslog—used for system logging |'
  prefs: []
  type: TYPE_TB
- en: '| `520` | This is the **Routing Information Protocol** (**RIP**) |'
  prefs: []
  type: TYPE_TB
- en: '| `750` | This is `kerberos-iv`, Kerberos version IV |'
  prefs: []
  type: TYPE_TB
- en: '| `944` | This is the network file system service |'
  prefs: []
  type: TYPE_TB
- en: '| `973` | This is the network file system over IPv6 service |'
  prefs: []
  type: TYPE_TB
- en: 'The following table gives a list of the registered ports and their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Registered ports (1024 to 49151) | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1534` | This is used for Eclipse **Target Communication Framework** (**TCF**)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `1581` | This is used for MIL STD 2045-47001 VMF |'
  prefs: []
  type: TYPE_TB
- en: '| `1589` | This is used for Cisco **VLAN Query Protocol** (**VQP**) / VMPS
    |'
  prefs: []
  type: TYPE_TB
- en: '| `2190` | This is used for TiVoConnect Beacon |'
  prefs: []
  type: TYPE_TB
- en: '| `2302` | This is used for Halo: Combat Evolved multiplayer |'
  prefs: []
  type: TYPE_TB
- en: '| `3000` | This is used for BitTorrent sync |'
  prefs: []
  type: TYPE_TB
- en: '| `4500` | This is used for IPSec NAT traversal |'
  prefs: []
  type: TYPE_TB
- en: '| `5353` | This is used for **Multicast DNS** (**mDNS**) |'
  prefs: []
  type: TYPE_TB
- en: '| `9110` | This is used for SSMP message protocol |'
  prefs: []
  type: TYPE_TB
- en: '| `27500` to `27900` | This is used for id Software''s QuakeWorld |'
  prefs: []
  type: TYPE_TB
- en: '| `29900` to `29901` | This is used for Nintendo Wi-Fi connection |'
  prefs: []
  type: TYPE_TB
- en: '| `36963` | This is used for Unreal Software multiplayer games |'
  prefs: []
  type: TYPE_TB
- en: TCP versus UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several differences between TCP and UDP. These differences include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: TCP is more reliable than UDP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordering**: TCP guarantees the order of packet transmission will be preserved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header size**: The UDP header is smaller than the TCP header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: UDP is faster than TCP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a packet is sent using TCP, the packet is guaranteed to arrive. If it is
    lost, then it is re-sent. UDP does not offer this guarantee. If the packet does
    not arrive, then it is not re-sent.
  prefs: []
  type: TYPE_NORMAL
- en: TCP preserves the order that packets are sent in, while UDP does not. If the
    TCP packets arrive at a destination in a different order than how they were sent,
    TCP will reassemble the packets in their original order. With UDP, this ordering
    is not preserved.
  prefs: []
  type: TYPE_NORMAL
- en: When a packet is created, header information is attached to assist in the delivery
    of the packet. With UDP the header consists of 8 bytes. The usual size of a TCP
    header is 32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: With a smaller header size and lack of the overhead to ensure reliability, UDP
    is more efficient than TCP. In addition, less effort is required to create a connection.
    This efficiency makes it a better choice to stream media.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin our UDP examples with how a traditional client/server architecture
    is supported.
  prefs: []
  type: TYPE_NORMAL
- en: UDP client/server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UDP client/server applications are similar in structure to the structure
    used for TCP client/server applications. On the server side, a UDP server socket
    is created, which waits for client requests. The client will create a corresponding
    UDP socket and use it to send a message to the server. The server can then process
    the request and send back a response.
  prefs: []
  type: TYPE_NORMAL
- en: A UDP client/server will use the `DatagramSocket` class for the socket and a
    `DatagramPacket` to hold the message. There is no restriction on the message's
    content type. In our examples, we will be using a text message.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP server application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our server is defined next. The constructor will perform the work of the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor''s try-with-resources block, we create an instance of the
    `DatagramSocket` class. Several of the methods that we will be using may throw
    an `IOException` exception, which will be caught if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternate way of creating the socket is to use the `bind` method, as shown
    next. The `DatagramSocket` instance is created using `null` as the parameter.
    The port is then assigned with the `bind` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Both approaches will create a `DatagramSocket` instance using port `9003`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of sending a message consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array of bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `DatagramPacket` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `DatagramSocket` instance to wait for a message to arrive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process is enclosed in a loop, as shown next, to allow multiple requests
    to be handled. The message that is received is simply echoed back to the client
    program. The `DatagramPacket` instance is created using the byte array and its
    length. It is used as the argument of the `DatagramSocket` class''s `receive`
    method. The packet does not hold any information at this time. This method will
    block until a request is made, and the packet will then be populated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the method returns, the packet is converted into a string. If some other
    data type was sent, then some other conversion will be needed. The message that
    was sent is then displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To send a response, the address and port number of the client are needed. These
    are obtained using the `getAddress` and `getPort` methods, respectively, against
    the packet, which possesses this information. We will see this when we discuss
    the client. Also needed is the message that is represented as an array of bytes,
    which the `getBytes` method provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A new `DatagramPacket` instance is created using the message, its length, and
    the client''s address and port number. The `send` method sends the packet to the
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the server defined, let's examine the client.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP client application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The client application will prompt the user for a message to send, and then
    it will send the message to the server. It will wait for a response and then display
    the response. It is declared here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Scanner` class supports getting user input. The try-with-resources block
    creates a `DatagramSocket` instance and handles exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The client''s current address is accessed using the `getByName` method, and
    a reference to an array of bytes is declared. This address will be used to create
    a packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'An infinite loop is used to prompt the user for messages. When the user enters
    "quit", the application will terminate, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a `DatagramPacket` instance holding the message, its constructor
    needs an array of bytes representing the message, its length, and the client''s
    address and port number. In the following code, the server''s port is `9003`.
    The `send` method will send the packet to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To receive a response, a receive packet is created and used with the `receive`
    method in the same way that it was handled in the server. This method will block
    until the server responds, and then the message is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see these applications at work.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server is started first. It will display the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start the client application. It will display the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter a message:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message, such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter a message: Top of the morning to you**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will display that it has received the message, as shown next. You
    will see several empty lines of output. This is the content of the 1024-byte array
    that is used to hold the message. The message is then echoed back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Received from client: [Top of the morning to you**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From: /127.0.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, the response is displayed. In this example, the users then
    enter "quit" to terminate the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Received from server [Top of the morning to you**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**from /127.0.0.1:9003**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter a message: quit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Client Terminating**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are sending and receiving test messages, we can simplify the display
    of the message using the `trim` method when the message is displayed, as shown
    next. This code can be used on both the server and the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be easier to read, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Received from client: [Top of the morning to you]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From: /127.0.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: This client/server application can be enhanced in a number of ways, including
    the use of threads, to enable it to work better with multiple clients. This example
    illustrates the basics of developing a UDP client/server application in Java.
    In the next section, we will see how channels support UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Channel support for UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DatagramChannel` class provides additional support for UDP. It can support
    nonblocking interchanges. The `DatagramChannel` class is derived from the `SelectableChannel`
    class that makes multithreaded application easier. We will examine its use in
    [Chapter 7](ch07.html "Chapter 7. Network Scalability"), *Network Scalability*.
  prefs: []
  type: TYPE_NORMAL
- en: The `DatagramSocket` class binds a channel to a port. After this class is used,
    it is no longer used directly. Using the `DatagramChannel` class means, we do
    not have to use datagram packets directly. Instead, data is transferred using
    an instance of the `ByteBuffer` class. This class provides several convenient
    methods to access its data.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the use of the `DatagramChannel` class, we will develop an echo
    server and client application. The server will wait for a message from a client,
    and then send it back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP echo server application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The UDP echo server application declaration follows and uses port `9000`. In
    the `main` method a try-with-resources block opens the channel and creates a socket.
    The `DatagramChannel` class does not possess public constructors. To create a
    channel, we use the `open` method, which returns an instance of the `DatagramChannel`
    class. The channel''s `socket` method creates a `DatagramSocket` instance for
    the channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, we need to associate it with a port. This is done first by creating
    an instance of the `SocketAddress` class, which represents a socket address. The
    `InetSocketAddress` class is derived from the `SocketAddress` class and implements
    an IP address. Its use in the following code sequence will associate it with port
    `9000`. The `DatagramSocket` class''s `bind` method ties this address to the socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ByteBuffer` class is central to using a datagram channel. We discussed
    its creation in [Chapter 3](ch03.html "Chapter 3. NIO Support for Networking"),
    *NIO Support for Networking*. In the next statement, an instance of this class
    is created with the `allocateDirect` method. This method will attempt to use native
    OS support directly on the buffer. This can be more efficient than using the datagram
    packet approach. Here, we created a buffer with the maximum size possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the infinite loop that follows, which will receive a message from a client,
    display the message, and then send it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `receive` method is applied against a channel to get a client's message.
    It will block until the message is received. Its single argument is the byte buffer
    that is used to hold the incoming data. If the message exceeds the size of the
    buffer, the extra bytes are silently thrown away.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flip` method enables the buffer to be processed. It sets the buffer''s
    limit to the current position in the buffer and then sets the position to `0`.
    Subsequent get type methods will start at the beginning of the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While not necessary for an echo server, the message that is received is displayed
    on the server. This allows us to verify that the message was received and suggests
    how messages can be modified to do more than simply echoing the message.
  prefs: []
  type: TYPE_NORMAL
- en: In order to display the message, we need to use the `get` method to get each
    byte and then convert it to the appropriate type. The echo server is intended
    to echo simple strings. Thus, the byte needs to be cast to a char before it is
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `get` method modifies the current position in the buffer. We need
    to restore the position to its original state before we send the message back
    to the client. The buffer's `mark` and `reset` method are used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this is performed in the following code sequence. The `mark` method
    sets the mark at the current position. A `StringBuilder` instance is used to recreate
    the string that was sent by the client. The buffer''s `hasRemaining` method controls
    the while loop. The message is displayed and the `reset` method restores the position
    to the previously marked value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to send the byte buffer back to the client. The `send` method
    does this. A message indicating that the message has been sent is displayed, followed
    by the `clear` method. This method is used because we are through with the buffer.
    It will set the position to 0, set the limit of the buffer to its capacity, and
    discard the mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is started, we will see a message to this effect, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Echo Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to see how the client is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP echo client application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of the UDP echo client is simple and uses these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A connection to the echo server is established
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A byte buffer is created to hold the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The buffer is sent to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client blocks until the message is sent back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The client''s implementation details are similar to the server''s. We start
    with the declaration of the application, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the server, the single argument `InetSocketAddress` constructor associates
    port `9000` with the current IP address. Within the client, we need to specify
    the IP address of the server along with the port. Otherwise, it will be unable
    to determine where to send the message. This is accomplished in the following
    statement using the class''s two-argument constructor. We use the address, `127.0.0.1`,
    assuming that the client and the server are on the same machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The channel is then created with the `open` method and connected to the socket
    address with the `connect` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code sequence, the message string is created, and the byte buffer
    is allocated. The size of the buffer is set to the length of the string. The `put`
    method then assigns the message to the buffer. As the `put` method expects an
    array of bytes, we use the `String` class''s `getBytes` method to obtain an array
    of bytes corresponding to the message''s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we send the buffer to the server, the `flip` method is called. It will
    set the limit to the current position and set the position to 0\. Thus, when received
    by the server it can be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To send the message to the server, the channel''s `write` method is called,
    as shown next. This will send the underlying packet directly to the server. However,
    this method only works if the channel''s socket is connected, which was achieved
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the buffer is cleared, allowing us to reuse the buffer. The `read` method
    will receive the buffer, and the buffer will be displayed using the same process
    that was used in the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to use the client in conjunction with the server.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP echo client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server needs to be started first. We will see the initial server message,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Echo Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start the client. The following output will be displayed showing the
    client sending the message and then showing the returned message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Echo Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: [The message]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Received: [The message]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Echo Client Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, we will see the message being received and then being sent
    back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Received: [The message]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: [The message]**'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `DatagramChannel` class can make UDP communications faster.
  prefs: []
  type: TYPE_NORMAL
- en: UDP multicasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multicasting is the process of sending a message to multiple clients at the
    same time. Each client will receive the same message. In order to participate
    in this process, clients need to join a multicast group. When a message is sent,
    its destination address indicates that it is a multicast message. The multicast
    groups are dynamic with clients entering and leaving the group at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast is the old IPv4 CLASS D space and uses addresses `224.0.0.0` through
    `239.255.255.255`. The IPv4 Multicast Address Space Registry lists multicast address
    assignments and is found at [http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml](http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml).
    The *Host Extensions for IP Multicasting* document is found at [http://tools.ietf.org/html/rfc1112](http://tools.ietf.org/html/rfc1112).
    It defines the implementation requirements to support multicasting.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP multicast server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server application is declared next. This server is a time server that
    will broadcast the current data and time every second. This is a good use for
    multicast messages as there may be several clients interested in the same information,
    and reliability is not a concern. The try block will handle exceptions as they
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of the `MulticastSocket` class is needed along with an `InetAddress`
    instance holding the multicast IP address. In this example, the address, `228.5.6.7`,
    represents the multicast group. The `joinGroup` method is used to join this multicast
    group, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to send a message, we need an array of bytes to hold the message and
    a packet. These are declared as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The server application will use an infinite loop to broadcast a new date and
    time every second. The thread is paused for one second, and then a new date and
    time is created using the `Data` class. The `DatagramPacket` instance is created
    using this information. Port `9877` is assigned for this server and will need
    to be known by the client. The `send` method sends the packet to interested clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The client application is discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP multicast client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This application will join the multicast group as defined by the address `228.5.6.7`.
    It will block until a message is received, and then it will display the message.
    The application is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: An instance of the `MulticastSocket` class is created using the port number
    `9877`. This is needed so that it can connect to the UDP multicast server. An
    `InetAddress` instance is created using the multicast address of `228.5.6.7`.
    The client then joins the multicast group using the `joinGroup` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A `DatagramPacket` instance is needed to receive messages that were sent to
    the client. An array of bytes is created and used to instantiate this packet,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The client application then enters an infinite loop where it blocks at the
    `receive` method until the server sends a message. Once the message has arrived,
    the message is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will demonstrate how the client and the server interact.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP multicast client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server. The output of the server will be similar to the following
    one, but the date and time will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Multicast Time Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: [Sat Sep 19 13:48:42 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: [Sat Sep 19 13:48:43 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: [Sat Sep 19 13:48:44 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: [Sat Sep 19 13:48:45 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: [Sat Sep 19 13:48:46 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: [Sat Sep 19 13:48:47 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start the client application. It will start receiving messages similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Multicast Time Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message from: /192.168.1.7 Message: [Sat Sep 19 13:48:44 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message from: /192.168.1.7 Message: [Sat Sep 19 13:48:45 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message from: /192.168.1.7 Message: [Sat Sep 19 13:48:46 CDT 2015]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the program is executed on a Mac, it may be through a socket exception. If
    this happens, use the `-Djava.net.preferIPv4Stack=true VM` option.
  prefs: []
  type: TYPE_NORMAL
- en: If you start subsequent clients, each client will receive the same series of
    server messages.
  prefs: []
  type: TYPE_NORMAL
- en: UDP multicasting with channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also multicast with channels. We will use IPv6 to demonstrate this process.
    The process is similar to our previous use of the `DatagramChannel` class, except
    that we need to use a multicast group. To do this, we need to know which network
    interfaces are available. Before we get into the specifics of using channels to
    multicast, we will demonstrate how to obtain a list of network interfaces for
    a machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NetworkInterface` class represents a network interface. This class was
    discussed in [Chapter 2](ch02.html "Chapter 2. Network Addressing"), *Network
    Addressing*. The following is a variation of the approach demonstrated in that
    chapter. It has been augmented to show whether a specific interface supports multicasting,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `displayNetworkInterfaceInformation` method is shown next. This approach
    has been adapted from [https://docs.oracle.com/javase/tutorial/networking/nifs/listing.html](https://docs.oracle.com/javase/tutorial/networking/nifs/listing.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When this example is executed, you will get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Display name: Software Loopback Interface 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name: lo**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supports Multicast: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /127.0.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /0:0:0:0:0:0:0:1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Display name: Microsoft Kernel Debug Network Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name: eth0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supports Multicast: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Display name: Realtek PCIe FE Family Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name: eth1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supports Multicast: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /fe80:0:0:0:91d0:8e19:31f1:cb2d%eth1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Display name: Realtek RTL8188EE 802.11 b/g/n Wi-Fi Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name: wlan0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supports Multicast: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /192.168.1.7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /2002:42be:6659:0:0:0:0:1001**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /fe80:0:0:0:9cdb:371f:d3e9:4e2e%wlan0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: For our client/server, we will use the `eth0` interface. You will need to choose
    the one most appropriate for you platform. For example, on a Mac this may be `en0`
    or `awdl0`.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP channel multicast server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The UDP channel multicast server will:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the channel and multicast group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a buffer containing a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an infinite loop to send and display the group message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The definition of the server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first task uses the `System` class''s `setProperty` method to specify that
    IPv6 be used. A `DatagramChannel` instance is then created, and the `eth0` network
    interface is created. The `setOption` method will associate the channel with the
    network interface that was used to identify the group. The group is represented
    by an `InetSocketAddress` instance using an IPv6 node-local scope multicast address,
    as shown next. More details about the *IPv6 Multicast Address Space Registry*
    document can be found at [http://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml](http://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A byte buffer is then created, based on a message string. The buffer''s size
    is set to the length of the string and is assigned using a combination of the
    `put` and `getBytes` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the while loop, the buffer is sent out to group members. To clearly
    see what was sent, the contents of the buffer is displayed using the same code
    that was used in the *The UDP echo server application* section. The buffer is
    reset so that it can be used again. The application pauses for one second to avoid
    excessive messages for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready for the client application.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP channel multicast client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UDP channel multicast client will join the group, receive a message, display
    it, and then terminate. As we will see, the `MembershipKey` class represents membership
    to a multicast group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application is declared as follows. First, we specify that IPv6 is to be
    used. The network interface is then declared, which is the same one that was used
    by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DatagramChannel` instance is created next. The channel is bound to port
    `9003` and is associated with the network interface instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The group is then created based on the same IPv6 address that was used by the
    server, and a `MembershipKey` instance is created using the channel''s `join`
    method, as shown next. The key and a waiting message is displayed to illustrate
    how the client works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A byte buffer is created with a size of `1024`. This size will be sufficient
    for this example, The `receive` method is then called, which will block until
    a message is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To display the contents of the buffer, we need to flip it. The contents are
    displayed as we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are done with a membership key, we should indicate that we are no longer
    interested in receiving group messages using the `drop` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Messages may still arrive if there are packets waiting to be processed by the
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP channel multicast client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server first. This server will display a series of messages every
    second, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent the multicast message: The message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: [The message]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent the multicast message: The message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: [The message]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent the multicast message: The message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent: [The message]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start the client application. It will display the multicast group, wait
    for a message, and then display the message, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Joined Multicast Group: <ff01:0:0:0:0:0:0:fc,eth1>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for a message...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Received: [The message]**'
  prefs: []
  type: TYPE_NORMAL
- en: The use of a channel can improve the performance of UDP multicast messages.
  prefs: []
  type: TYPE_NORMAL
- en: UDP streaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using UDP to stream audio or videos is common. It is efficient and any loss
    of packets or out-of-order packets will cause minimal problems. We will illustrate
    this technique by steaming live audio. A UDP server will capture the microphone's
    sound and send it to a client. The UDP client will receive the audio and play
    it on the system's speakers.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a UDP streaming server is to break up the stream into a series of
    packets that are sent to a UDP client. The client will then receive these packets
    and use them to reconstitute a stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to illustrate streaming audio, we need to know a bit about how Java
    handles audio streams. Audio is handled by a series of classes that are found
    in the `javax.sound.sampled` package. The primary classes that are used to capture
    and play audio include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AudioFormat`: This class specifies the characteristics of the audio format
    that is used. As there are several audio formats available, the system needs to
    know which one is being used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AudioInputStream`: This class represents the audio that is being recorded
    or played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AudioSystem`: This class provides access to the system''s audio devices and
    resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataLine`: This interface controls operations applied against a stream, such
    as starting and stopping a stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SourceDataLine`: This represents the destination of the sound, such as a speaker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TargetDataLine`: This represents the source of the sound, such as a microphone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The terminology that is used for the `SourceDataLine` and `TargetDataLine` interfaces
    may be a bit confusing. The terms are from the perspective of a line and a mixer.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP audio server implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The declaration of the `AudioUDPServer` class is as follows. It uses a `TargetDataLine`
    instance for the source of the audio. It is declared as an instance variable because
    it is used in multiple methods. The constructor uses a `setupAudio` method to
    initialize the audio and a `broadcastAudio` method to send this audio to a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `getAudioFormat` method, and it is used in both the server
    and the client to specify the audio-stream characteristics. The analog audio signal
    is sampled 1,600 times a second. Each sample is a signed 16-bit number. The `channels`
    variable is assigned `1`, meaning that the audio is mono. The order of the bytes
    in the sample is important and is set to big endian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Big endian and little endian refers to the order of bytes. Big endian means
    that the most-significant byte of a word is stored at the smallest memory address
    and the least significant byte at the largest memory address. Little endian reverses
    this order. Different computer architectures use different orderings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setupAudio` method initializes the audio. The `DataLine.Info` class uses
    the audio format information to create a line representing audio. The `AudioSystem`
    class''s `getLine` method returns a data line that corresponds to a microphone.
    The line is opened and started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `broadcastAudio` method creates the UDP packets. A socket is created using
    port `8000` and an `InetAddress` instance is created for the current machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'An infinite loop is entered where the `read` method fills the `audioBuffer`
    array and returns the number of bytes read. For counts greater than `0`, a new
    packet is created using the buffer and is sent to the client listening on port
    `9786`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When executed, the sound from the microphone is sent to the client as a series
    of packets.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP audio client implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AudioUDPClient` application is declared next. In the constructor, an `initiateAudio`
    method is called to start the process of receiving packets from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initiateAudio` method creates a socket that is bound to port `9786`. An
    array of bytes is created to hold audio data contained in the UDP packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'An infinite loop will receive packets from the server, create an `AudioInputStream`
    instance, and then call the `playAudio` method to play the sound. The packet is
    created in the following code and then blocks until a packet is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the audio stream is created. An array of bytes is extracted from the
    packet. It is used as the argument of the `ByteArrayInputStream` constructor,
    which is used, along with the audio format information, to create the actual audio
    stream. This is associated with the `SourceDataLine` instance, which is opened
    and started. The `playAudio` method is called to play the sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getAudioFormat` method is used and is the same one that was declared in
    the `AudioUDPServer` application. The `playAudio` method follows. The `read` method
    of `AudioInputStream` populates a buffer, which is written to the source data
    line. This effectively plays the sound on the system''s speakers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: With the server running, starting the client will play the sounds from the server.
    The play can be enhanced through the use of threads in the server and client to
    handle the recording and playback of the sound. This detail has been left out
    to simplify the example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the continuous analog sound is digitized and broken into packets.
    These packets were then sent to a client where they were converted back into a
    sound and played.
  prefs: []
  type: TYPE_NORMAL
- en: There is additional support for UDP streaming found in several other frameworks.
    The **Java Media Framework** (**JMF**) ([http://www.oracle.com/technetwork/articles/javase/index-jsp-140239.html](http://www.oracle.com/technetwork/articles/javase/index-jsp-140239.html))
    supports the processing of audio and video media. The **Real-time Transport Protocol**
    (**RTP**) ([https://en.wikipedia.org/wiki/Real-time_Transport_Protocol](https://en.wikipedia.org/wiki/Real-time_Transport_Protocol))
    is used to send audio and video data across a network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the nature of the UDP protocol and how Java supports
    it. We contrasted TCP and UDP to provide some guidance in deciding which protocol
    was best for a given problem.
  prefs: []
  type: TYPE_NORMAL
- en: We started with a simple UDP client/server to demonstrate how the `DatagramPacket`
    and `DatagramSocket` classes are used. We saw how the `InetAddress` class was
    used to obtain addresses used by sockets and packets.
  prefs: []
  type: TYPE_NORMAL
- en: The `DatagramChannel` class supports using NIO techniques in a UDP environment,
    which can be more efficient than using the `DatagramPacket` and `DatagramSocket`
    approach. The approach used a byte buffer to hold messages that were sent between
    a server and a client. This example illustrated many of the techniques that were
    developed in [Chapter 3](ch03.html "Chapter 3. NIO Support for Networking"), *NIO
    Support for Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: This was followed by a discussion of how UDP multicasting works. This provides
    a simple technique to broadcast a message to members of a group. The use of the
    `MulticastSocket`, `DatagramChannel`, and `MembershipKey` classes were illustrated.
    The latter class is used to establish a group when the `DatagramChannel` class
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded with an example of how UDP is used to support the streaming of
    audio. We detailed the use of several classes in the `javax.sound.sampled` package,
    including the `AudioFormat` and `TargetDataLine` classes to gather and play audio.
    We used the `DatagramSocket` and `DatagramPacket` classes to transmit the audio.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the techniques that are available to improve
    the scalability of client/server applications.
  prefs: []
  type: TYPE_NORMAL
