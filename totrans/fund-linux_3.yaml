- en: The Linux Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced you to Linux files and folders by navigating
    the filesystem. In this chapter, we will learn how to work with, find, and change
    permissions and access to reading and editing files. We will expand our knowledge
    on this topic, define what a filesystem is, and show you important commands for
    working with files, such as copying and moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll walk you through the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with file links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with file permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with VIM text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A filesystem is not only a tree of files and folders exposed to the Linux user,
    but it's also the structure and management to access and save data, and keep everything
    consistent. As already mentioned, you often hear the phrase that in Linux, everything
    is a file, and this is true. This means that a lot of different things in Linux
    get abstracted as files. For example, a directory is a file, hardware devices
    get represented by special system files, or ,useful, such as a random number generator,
    is also a file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly recap and summarize what we already know about working with files
    from the last two chapters. `ls` lists and displays files, `touch` creates a file,
    files are case sensitive, and `.` files are hidden files and are excluded from
    normal command execution, such as the `ls` command, and also from shell expansion
    using file globbing characters. Next, you should also already know `mkdir` creates
    a directory, `rmdir` deletes an empty directory, `rm` deletes a file, and `mkdir
    -p` creates a full subdirectory structure. `rmdir` cannot be applied on nonempty
    directories; in our example, it contained subfolders. `rm -rf` deletes a directory
    with all the subdirectories, but handle it with caution. When you use the `rm
    -rf` option to delete a whole directory structure, the `r` option stands for recursive,
    `f` for force. The recursive option is an important option you will often encounter
    when working with commands that do something for a whole subdirectory tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s learn some other important new file-based commands. If you need
    to copy a file, you can use the `cp` command. We already saw the general usage
    of `cp`in the previous chapter. If you go to the man page of the `cp` command,
    there are three different usage formats: `cp [option]... [-T] SOURCE DEST`, `cp
    [option]... SOURCE... DIRECTORY`, and `cp [option]... -t DIRECTORY SOURCE...`
    It''s important to remember that there can be multiple source directories, but
    only one target directory. You have to memorize this. To copy one single file
    to one destination file, you can use the first usage form. To copy several files
    to one destination folder, you can use the second usage form. The third usage
    form is like the second usage form, but with mixed source and directory arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to create a copy of a file with a different filename, use `cp
    firstfile secondfile`; you can also do the same using local pathnames. As we have
    learned from the manual, you can also copy files to directories leaving the original
    filename. As shown in the manual, you can also do this for multiple source files.
    Note that you cannot copy complete directories out of the box using the `cp` command.
    In order to do so, you need to provide the `-R` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bebc3942-7fa4-42e9-bcec-02a1bcc83191.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the complete `olip` home directory has been copied to the `/tmp`
    directory with all subdirectories and files. Please memorize that the `cp -R`
    option stands for recursive, again. To move files and folders on the command line
    you can use the move command, which implicitly copies and deletes the source files.
    The move command `mv` is often used to rename files and folders. Note that you
    can move or rename not only files, but also folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, again if you have a look at the `ls -l` option, for example, in the `/etc`
    directory, you will notice some things. You will be presented with a lot of useful
    information. The first character in the `-l` listing here is a `d`, or `-`, or `l`,
    and this represents the type of the file. A `d` stands for directory, a `-` is
    a normal file, and `l` is a link. The first character in the `ls -l` output is
    also called the file type flag. Besides the shown `d`, `-`, and `l` flags, there
    are a number of other available file types. To get a full list of all the available
    file type flags, use `man find`, search for `type`, then search for `type c`.
    You will get a full list of all the available file type flags in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d307e470-cc66-4be1-8e8f-87c8e340b3a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, there is another very useful piece of information given in the column
    adjacent to the permissions column. The number presented is the number of links
    a file contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d56b799-e748-443f-99d6-ed806ae1302a.png)'
  prefs: []
  type: TYPE_IMG
- en: File links tell us how many references exist on any given file or directory.
    Every normal file by default has one link and every directory has two links. There
    are hard links and soft links, which we'll discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Working with file links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we take a look at what Linux file links are and how to work
    with them. As you already might know, files are stored on the hard disk. In a
    Linux filesystem, the file''s filename and the data are two separate concepts
    and are not stored together. A general structure is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8ee3da0-feea-4027-be6b-0d3a9cba07f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Connecting a filename to the actual data is managed by the filesystem using
    a table or database data structure, which is called a title allocation table.
    In the Linux filesystem, an Inode is the actual entry point or starting point
    to the beginning of a specific file's data on the hard disk. To simplify, we can
    just say that the Inode represents the actual data of a file. The filesystem management
    now takes care that every normal file, upon creation, has one link entry in its
    allocation table to connect the actual filename to the Inode or data on the hard
    disk. Such a link is also called **hard link**. The original filename to Inode
    relationship is also linked using a hard link, that's why in the last section
    the `ls -l` command gave us the number `1` for most of the files in the column
    adjacent to the permissions. Now, the cool thing about the Linux filesystem is
    that you can create additional hard links to an existing Inode, which is like
    having alternative names for a file.
  prefs: []
  type: TYPE_NORMAL
- en: One of the drawbacks of a hard link are that you cannot differentiate a hard
    link from the original filename or the Inode. This can cause problems and side
    effects, because if you change the original file's content the hard link's content
    will be changed as well. Another limitation of hard links is that you can only
    define them for Inodes, which are on the same partition as the hard link should
    go. Also, you cannot create hard links on directories. You can only create them
    on normal files. To solve these limitations of hard links, you can use **soft
    links**, also known as symbolic links. These are the type of links that you will
    use almost all the time in your everyday work as a Linux system administrator.
    Hard links also have their special use cases, for example, for creating backups
    of files, but are only used very rarely by the Linux user.
  prefs: []
  type: TYPE_NORMAL
- en: A symbolic link is a link to the filename and not to the Inode. Symbolic links
    also don't have the boundary that they must be on the same partition or hard disk
    as the original file. You can also create symbolic links on a directory. The main
    drawback is that if you delete or move the original file, you will have a broken
    symbolic link without further warning, which can also create some bad side effects.
    The main use cases and power of symbolic links are referencing configuration files
    or dynamic library versions in the Linux filesystem. Using links can save a lot
    of disk space because no actual data must be copied and they are very effective
    for quickly testing out such things as alternate configuration files for services.
  prefs: []
  type: TYPE_NORMAL
- en: 'File links are managed by the `ln` command. The basic syntax is `ln [OPTION]`,
    then the filename you want to create a link on, and finally the link name. To
    create a hard link to a file called `fileX` in your `home` directory, use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b405a283-2d42-4d1b-bcb5-60d5074e96d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there''s no way to differentiate the additional hard link from
    the original one. You can also create multiple links on the same file. To delete
    a hard link, use the `rm` command. There''s a maximum number of Inodes on every
    filesystem, or we can just simply say files, which you can display using `df -i`.
    If you use the `mount` command, you will see that the `tmp` filesystem for the
    user is on a different partition than the `home` directory, which is in turn,
    on the root partition as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c09ea1e8-16e4-4157-823d-9592ea0ddb58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So the next command `ln ~/folderABC ~/folderABC_link` will fail because it
    is not allowed to create hard links between partitions. Also, you cannot create
    a hard link on a directory, and changing the origin of the file''s content will
    change the hard link''s file content as well. This can create some bad side effects.
    To create a symbolic link, use the `ln -s` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efebda5f-f05f-4675-8195-fe6bf16637cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it''s easy to show if a file as a symbolic link marked with
    the arrow. To create a symbolic link of a file in another directory, preserving
    the original file''s name, you can use `ln -s /etc/passwd`. This created a symbolic
    link of the /`etc/passwd` file in the current directory under the same name, `passwd`.
    To delete a symbolic link, use the `rm` command; the original file will not be
    touched. You can also create a symbolic link on a directory. If you delete the
    original file that the symbolic link is pointing to, that is `fileX` here the
    symbolic link will broke. This can get problematic, which is denoted here with
    the blue color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35bdba9a-a00c-4743-b09f-2ddac711b66e.png)'
  prefs: []
  type: TYPE_IMG
- en: Searching for files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to search for files in Linux. The `man find`
    command, as the name implies, can find files based on versatile criteria. But
    more than that, you can even apply actions on every search result during execution
    of the program, which is a very useful feature. Find can take some options to
    change its default behavior, for example, how to treat files, which are symbolic
    links during execution of the program. The first few arguments are a list of directories
    or starting points to start your search in, all the other arguments are search
    expressions or conditions to find in your search. It's important to discuss what
    search expressions are. A search expression typically is a test and an action.
    Tests are typically separated by logical operators. If no operator is given, the
    end operator is assumed. If the expression contains no action by the user, then
    the `print` action will be performed for all the files in the search result.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start using the `man find command`, it's important to know how the
    `man find` command processes the search results. For every file in the list of
    search paths, all the expressions get evaluated from left to right. By default,
    only if all the expressions are correct, the `man find` command marks the file
    as a hit. You can change this logical end behavior if you like using an `OR` expression
    as well, as we will see later in one of our examples. The `man find` command lets
    you create very sophisticated search queries using a broad range of very useful
    file test expressions. If you search for `tests` in the manual page of the `man
    find` command, you will get a full list of all the available test operators. For
    example, you can search for files that have been modified or accessed at specific
    time in the past, or which have a certain size. As mentioned earlier, the default
    action is the `print` action on every file match. Another very useful action is
    the `exec` expression, which lets you execute a specific command for every file
    match. The `man find` command is a very complex command and we cannot show you
    everything here. Thus, for the rest of this section we will show you some very
    useful use cases. You can use the `find` command without any options or arguments.
    This is the same as writing because without any options and arguments the search
    path is the current directory and the default action is the `print` action. This
    command goes through your current directory and prints out all the files and directories,
    including all subdirectories and files beneath the subdirectories, recursively.
    It does so because you have not provided any test expression, so it will just
    match any file or directory in your current directory and apply the `print` action
    to it. As mentioned earlier, what makes the `find` command so powerful is its
    huge list of different test expressions to locate files based on a variety of
    useful conditions. Such file search tests can be anything imaginable, such as
    timestamps, user permissions, users, groups, file type, date, size, or any other
    possible search criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following examples, we will use the root user account set up during
    installation, because in the example shown here, we search a lot in the system
    directories, which need special privileges. To search for only files and not directories
    in the `/etc` directory for the filename `logrotate.conf` use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file is found, you won''t encounter any errors. What this command does
    in the background is it goes through the `/etc` directory and picks up all the
    files and subdirectories included in the `/etc` directory and it processes them
    recursively one by one. Then, for every file, it checks whether the file is the
    actual file, and whether the name is equal to the filename. You can also use multiple
    directories as search starting points, as well as use the `-type d` to search
    only directories, this will print out all subdirectory names beginning with the
    `/etc` and `/var` directories and starting with the letter `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1be45990-ff19-4f1e-b07a-8571163036bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the name expression takes normal POSIX 5 globbing characters, not regular
    expressions. If you want to use regular expressions for file search use the `-regex`
    expression instead. Note that if you use `-iname` expression instead, it will
    search case-insensitive. You can also search for files using file size as a criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94378bbd-41cb-4999-8117-71cebab507ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `find / -type f -size +4M -name ''l*''` searches for all the files equal
    to or larger than 4 MB starting with the name `l` and only files and not directories
    starting in the `root` directory, which means it will recursively search in the
    whole filesystem tree. As you see, only two files match all of these conditions.
    By the way, the `+` stands for greater or equals, if you use a `-` symbol it stands
    for less than. You can also search for specific file permissions. File permissions
    in general are discussed in later sections. To get a list of all the very dangerous
    directories with read, write, execute permissions for everybody searching in the
    whole filesystem, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if the user doesn''t provide any action for the `find` command itself
    the default `print` action is assumed, so the command will print out every matched
    file to the `stdout` command line. We can change that using the `-exec` action
    expression, which will apply a command after the `-exec` expression for every
    matched file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the `chmod 755` command will be applied for every matched file
    using the placeholder `{}`, which stands for matched. The `find` command here
    will search for all the files having a very dangerous file permission, `777`,
    and changes it back to a more moderate permission, `755`. So if we search again
    for the dangerous permission, the result will be empty. Why do we have to escape
    the semicolon? This is because normally a semicolon in the Bash shell delimits
    commands, so we have to disable its special meaning here. In all the examples
    shown so far, all the tests and expressions of a single `find` command must be
    true that the file can be counted as match.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example command `find / -type f -size +4M -name ''l*''` only files are
    matched and printed out if they are of type file and have a size of `4` MB or
    more and have a name starting with `l`. All of these three test expressions have
    to be `true` and are connected via a logical and. By default, the logical AND
    operator is connecting all the test expressions, which means only if all test
    expressions are true, the file can be matched as a hit. You can easily change
    a logical AND to a logical OR using the `-or` expression, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will match all files starting with a `p` and having the extension `conf`
    or `.d` in the `/etc` directory, and having the type file. There are also some
    very useful test expressions based on the time of a file. For example, `find /var
    -mtime 10`| head will output all the files, which have been modified in the last
    three days, outputting only the first `10` hits before the last three days or
    longer. Using time-based test expressions is very useful and is often needed in
    your daily work as a system administrator. For example, if you would need to delete
    all the files uploaded by users of a web application running on your server, which
    are older than `30` days, you could do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command could also be easily put into a script running each day, such
    as in a `Cron` job, to automate deleting of all the files which are older than
    `30` days, so you don''t have to take care of this manually anymore. To search
    for all the files in the entire filesystem, which start with the `l` and `r` and
    has a size between 1 and 4 MB use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also quickly search for files using the `locate` command instead of
    using find. You first need to install using the `package` and `locate`. The `locate`
    command does not do a live search in the filesystem, but rather uses a snapshot
    of the filesystem using a specific time point. This database gets updated every
    day at a certain point in time, but you can also regenerate the snapshot database
    by yourself using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now if you use the `locate` command, it will search the database you just generated
    for all the files matching the name `logrotate`. This will only search for literal
    text. If you want to use for regular expressions, use the `--regex` option.
  prefs: []
  type: TYPE_NORMAL
- en: As we are searching a database, this is usually faster than doing a live search
    using the `find` command, but always remember this is not a live state of the
    current filesystem. Hence, you can run into problems especially when searching
    for files, which are newer than the search database.
  prefs: []
  type: TYPE_NORMAL
- en: Working with users and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to create and remove users and groups, and
    how to add groups to users. Also, we will see how Linux internally stores user
    information and passwords, and how to retrieve user information programmatically.
    Finally, we will learn how to substitute user accounts while staying logged in.
    Linux is a multiuser system, which means more than one user can work with the
    system simultaneously. Therefore, a system is needed, which guarantees common
    access to Linux objects such as files using measurements of excess protection.
    For example, all files which have been created by one user should not be allowed
    to be erased by another user. Every Linux user is defined and identified by a
    unique user ID, as humans more easily can work with names than numbers. There
    also exists a literal username connected to each user ID, but Linux internally
    works with the **user ID** (**UID**) number when managing control on Linux objects
    such as files. There are two types of users accounts, login users which need a
    password to authenticate, and nonlogin users, which are useful for attaching user
    IDs to running programs or processes, as we will see later. Also there's one special
    account on every Linux system, the root user account, or administrator account,
    which we set up a password for during installation. This account on every system
    has access and is the owner to all objects, such as files presented in the Linux
    system, and this account can do anything to the system. If in Linux we have the
    username to control access files, it will be very limiting and time-consuming
    to grant or revoke permissions. Therefore, Linux also has the concept of groups
    to access control. Using groups can drastically simplify permission management
    by assigning permissions on a shared resource to a group, rather than to individual
    users. Assigning permissions to a group assigns the same access to the resource
    to all members of that group. Linux groups are also represented by a group ID,
    which is a number, but can also be referenced by its name, the group name. Every
    user in Linux has exactly one UID, but can belong to multiple groups or group
    IDs. One group is the primary group, which will be used when new files are created
    by that user.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating some new user accounts for our tests. Only `root` can
    do this. So first, let's log in as root. The `useradd` command adds a new user
    with the username given as an argument. This command creates a new user in the
    system and also creates the corresponding home directories. To make our new login
    accounts functional, we need to set passwords as well; we can do this with the
    `passwd` command. You can also use this command to change your own password. To
    set or change a password for other users, we type `passwd ` `username`-this can
    only be done using the root user account. To delete a user, use the `userdel`
    command. By default, the `userdel` command will not delete the user's `home` directory,
    so you have to do it yourself. To delete a user, it's better to use the `userdel
    -r` flag, which not only deletes the user but also deletes the associated `home`
    directory and mailbox. Let's recreate the user. Let's log out the root user. You
    can use the `su` command, or substitute user command, to switch the user while
    you are logged in. When you call the `su` command without any argument, the root
    user is assumed to be switched. To switch a substitute to a different user, you
    use the username as the first argument. You can recheck who is logged in using
    the `whoami` command. Using the `su` command, will preserve the original environment
    of the user who has executed the `su` command, and will not switch to the home
    user of the substituted user account.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's exit the substituted user and switch to another user. Using the `su`
    command with a dash symbol as an argument, we create a more login shell-like environment,
    which means it behaves more like a user who would login to the shell for real.
    By executing `pwd`, you can see that the `home` directory has been changed to
    the substituted user's `home` directory. Now, exit the substituted user again.
    You can also directly execute a single command with another user account using
    `su -c` flag; `su` username `-c`. This is useful if you want to quickly start
    a script or a command using a different user account without completely switching
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Only the root user is allowed to substitute users using the `su` command without
    providing a password. Any other user who wants to use the `su` command needs to
    know the password of the substituted user.
  prefs: []
  type: TYPE_NORMAL
- en: The `useradd` and `passwd` commands are making changes to the `etc/passwd` and
    `etc/shadow` files, which are the most important files to store authentication
    and user information in the entire Linux system. The `passwd` file stores a list
    of all the user accounts known to the system, all the login users and all the
    system users. Login users are typical physical persons who can log into a shell
    such as the Bash shell using a password for authentication. System users typically
    cannot log into a shell and are often associated to system services and processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to get a list of all the usernames available in the Linux system
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `passwd` file stores a lot of useful information such as the user's `home`
    directory, the default shell, or the user ID number. Refer to the manual page
    of the `passwd` command to find out more. The `/etc/shadow` file contains all
    the password information for all the users in an encrypted format. You need the
    root user account in order to view this file. To create a new group, use the `groupadd`
    command and to delete a group, use the `groupdel` command. The `groupadd` and
    `groupdel` commands internally work with the `/etc/group` file. This file shows
    you all groups available in the system as well as all the user IDs associated
    to these groups. Instead of reading the `/etc/group` or `/etc/passwd` file for
    getting information about a user, you can also use the `id` command. This will
    tell you the user ID, the group ID, and all the associated groups a user has.
    To add existing groups to a user, you can use the `usermod -G` command. `-G` overrides
    all the secondary groups a user has, leaving the primary group as it is. You can
    also define a comma-separated list of group names to be added to a username. It's
    important to remember that the `-G` always overrides the existing group names
    a user has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine the `permission string`, which specifies what the file
    owner, group owner, or any other user is allowed to do or not, based on who he
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1323c58-f325-4612-b11a-40cd1103020b.png)'
  prefs: []
  type: TYPE_IMG
- en: '`-l` outputs the file owner in the third column. Here, it is `root`, and for
    this file it is `olip`. In the fourth column, the `ls -l` outputs the group owner
    of the file. Also, here it is `root` and here it is `olip`. You already know that
    the first character in the `ls -l` output is the file type. Now, the nine bits
    afterward `l` and `d` define the file''s permission string. The first three characters
    of the permission string define the permissions for the file owner. The second
    three bits of the permission string define the permissions for the group owner.
    The last three bits in the permission string define the permissions for all the
    other users. In this example, `folderABC` has the file owner `olip`, the group
    owner `olip`. Furthermore, the file owner `olip` has full permissions on the directory,
    the group owner `olip` has full permissions on the directory, and all the other
    users have read and execute permissions on this directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a directory. We''ll put in some files to work with and
    then change to the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/322825a2-110b-4558-a1a9-bd7df470bf33.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's create some files to play around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's look at the file permissions of the files we have just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the root user has created all these
    files. Hence, the file ownership and the group ownership are both `root` for all
    the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, to change the file ownership and group ownership information you can use
    the `chown` or `chgrp` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of using the `chgrp` command, you can also use the `chown` command using
    a different notation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, to change a file's group, you can modify both the file owner and
    group ownership.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's also create some subfolders as well for testing directory permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put some files into these folders as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let us use some very dangerous `test` directories so that everyone is
    able to work with the files properly during our tests. This is not meant to be
    for production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create some common permissions for our files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create some unusual permissions, also create some permissions for directory
    tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change some file ownership permissions on files and group ownership permissions
    on a directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s work with our new files and change permissions. Let''s first review
    the output of the `ls -l` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89a45fbe-4360-4d1a-9546-ae79655018b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'File one is a file which has full read, write, and execute permissions for
    anyone. For example, any user known to the system can modify this file. The next
    file has the standard permission every file gets upon creation on a CentOS 7 machine.
    File owners have read and write access, whereas the group and all the other users
    only have read access. Let''s find out what this means if different users want
    to modify the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15ca13bd-6901-464a-a826-322091874ed1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we can see some interesting things. The `root` user has read, write, and
    execute permissions to any file despite what has been set in the permission string
    for the `root` user. `Peter` is the file owner, so he can write to this file.
    `Paul` is neither the file owner nor the group owner, so he has no write permissions
    at all. The next file has a permission often used for confidential files such
    as password files. Often this is done for services running a filesystem user account
    to protect others from reading credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54105fbf-0f46-41c6-84cd-95a6cf81d6d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, only the `root` user has the ability to read the file, nobody
    else. The next file has a common permission set used if not only the file owner
    but also members of the group that owns the file''s owning group should have full
    control over the file. As you see, `Peter` and `Paul` don''t have access to write
    to this file because they are neither the file owner nor the group owner. To change
    this, let us add `Peter` to the group that owns this file, and then test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5e58430-c579-4a7b-a32b-38791ef28882.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, `file5` has some unusual permissions, which are valid. `file5` is a script
    file, which prints something out. As you can see, only the `root` user can execute
    the file. To let `Peter` execute the script, add one of the groups that is associated
    with it to the file. This still does not work because now `Peter` can execute
    this file, but cannot read it. To change this, add read permissions for the group
    ownership of the file as well. Now, `Peter` is finally able to run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c12d9566-17a9-45a4-ad6b-c546448c45c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, a common misconception is to delete a file you need to set the file''s
    write permission flag correctly for the user, but this is not true, as we can
    see. Why can''t `Peter` delete this file even though we''ve assigned full permissions
    to everyone here? This is because file deletion is completely dependent on the
    write permission of the directory the file you want to delete is in, and not on
    any file permission. The following screenshot is where the user `Peter` is denied
    permission to delete the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f4d9349-d4fb-4101-8566-171c1c673dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s discuss directory permissions. The following screenshot is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57e6ce49-71ac-46a5-bc88-fbccfed423b3.png)'
  prefs: []
  type: TYPE_IMG
- en: '`folderA` has read permissions for the file owner, so he''s the only one who
    is able to see what''s in the folder but cannot change into the directory. `folderB`
    has only read permissions for the group owner, which means only members of the
    `projectA`a group can change into this directory, but `Peter` cannot do anything
    in this folder other than entering it using the `cd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f32ce42-c0f1-4e3a-848e-f2fca00ca2f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to list files in this directory, let''s order the read permissions
    to the group owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51269d51-81b5-48f1-aab1-31f17633966b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have learned before, we need to enable the `write` flag on a directory
    in order to create or delete new files in it. But why is this not working here?
    It''s because we also need to enable execute permissions on a directory, which
    makes sense because in order to create or delete a file in the directory, we need
    to have access to this directory. What can we do if we want to change permissions
    on a lot of files, for example, a whole subdirectory tree? Using the `ls -lR`
    flag, we can list all the subdirectories and files included. Now, to change the
    permission string for all the files in a subdirectory, you can use the `chmod
    -R` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As always, be careful with the recursive flag as you easily can change the file
    permissions for your whole filesystem to an unsecure permission irreversible.
  prefs: []
  type: TYPE_NORMAL
- en: Working with file permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the concept of file access control in Linux.
    We will also learn and understand how to read file permissions. Finally, we will
    learn how to change file ownership as well as file permissions and show you practical
    file permission examples. If you print out the file's details using `ls -l`, you
    will see a list of different important file attributes we need to learn about
    so as to understand file permissions. A typical `ls -l` output looks like `-lrwxr-xr-x
    olip administrator my-awsome-file.txt.` Every file in the system is associated
    to exactly one username, which is also called the file owner.
  prefs: []
  type: TYPE_NORMAL
- en: Every file is also associated to exactly one group name, which is also called
    the group owner. The file ownership of a file can be changed by the root user
    only. The group ownership can also be changed by the file owner. When a user creates
    a new file or directory, the file's ownership will be set to the user's UID who
    created the file. We already know that a user can belong to multiple groups, but
    one needs to be set as the primary group. This is why every new user that is created
    has a group with the same name as the username. Now, every Linux user who wants
    to access a file can be categorized into one of these groups. The user is the
    file owner if the user ID matches the ID of the file owner whose file we want
    to access. The user is the group owner if one of the groups he is associated with
    matches the group owner of the file he wants to access. If the user is not the
    file or group owner he falls into the other users category. These three permission
    categories are also called permission groups. Finally, all these permission groups,
    the file owner, the group owner, and the others group, have exactly three permission
    types each, read, write, and execute. These permission types manage the actual
    action a user belonging to one of these groups can or cannot do with the file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we are working with a lot of different information for every file,
    the user owner, the group owner, the permission categories, and the permission
    types, some Linux commands such as the `ls` command use a very compact form for
    viewing, which use 9-bits to fully map all permissions for all the permission
    groups. This 9-bit information is also called the permission string. If a permission
    is granted a read/write/execute or `rwx` flag is put at a fixed permission in
    the string. If a permission is revoked, a dash symbol can be found at a specific
    position in the string. From left to right in the permission string the first
    three bits are the read/write/execute permissions for the file owner. The next
    three bits are for the group owner, and the last three bits are for all the other
    users. The 9-bit permission string is a very dense notation to fit the screen
    and coming from a time when space and memory were expensive in computer hardware.
    Changes to permission types or 9-bit permission string can be set or removed by
    the root user only. Read, write, and execute permissions are defined differently
    on files and on directories.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first discuss what read, write, and execute means in a file context. If
    the `r`, or read, flag is set on a file, the corresponding permission categories,
    file owner, group owner, or other user can open a file and read its content. The
    `w`, or write, flag is to modify or truncate an existing file, but it's a common
    misconception and important fact to know that the write flag does not allow for
    new file creation or deleting of existing files. This is not a property of a file,
    but rather of the parent directory, as we will soon see. The `x`, or execute flag
    allows files to be executed. This is important for running script files or commands
    on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: In order to execute a file to run it as a script or command, the read flag needs
    to also be set because the shell needs to read the content of a file in order
    to execute its instructions. In a directory context, read, write, and execute
    permissions mean something completely different than working on files, which every
    Linux user must be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first start with the `x`, or execute, permissions, as this is the most
    essential permission for folders. `x`, or execute, permissions in a directory
    context means something completely different than in the file context. If an execute
    flag is set on a folder, it means that the corresponding user group or other is
    allowed to enter that directory or path into a directory, for example, using the
    `cd` command. But the `x` flag is not only important for the `cd` command, it's
    also mandatory if you need to rename, delete, or create new files using the write
    flag. The execute flag has to be set as well here. It's also mandatory if you
    need to rename, delete, or create new files using the write flag. As a rule of
    thumb, if you need to set some standard permissions on the folder, never miss
    the execute permission for the permission group you want to work with or otherwise
    you will run into problems, as you always need to change into a directory if you
    want to perform some actions. `r`, or read, is the permission to read the content
    of a directory, for example, using the `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `w`, or write, flag creates new files or deletes existing files in a directory.
    As we've seen before, deleting or creating new files is not a property of a file
    permission, but always a property of the directory permission the files you want
    to create or delete are in, so the write flag has to be set if you want to be
    able to create or delete files in it. In order to use the write flag for creating,
    deleting, or removing files, we also need to set the execute flag for commands
    such as `touch` or `rm`, because they need access to a directory in order to perform
    the actions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, each actual user who wants to perform an action, that is, read, write,
    or execute on a file or directory is now being checked by the operating system
    based on whether the attempt access is legal or not. This is a hierarchical process.
    The first check which is being done is whether the user ID of the user who wants
    to work on a file matches the file's user owner. If this is not the case, all
    the user's group IDs get checked if one matches the file's group ownership. If
    no user group matches at all, the other user is assumed and will be used. Now,
    every user in the system matches one of these three permission categories. If
    the right category has been found, the corresponding three permission types, read,
    write, and execute will be checked to see whether they are allowed or not and
    whether they match the user's attempt read, write, or execute action.
  prefs: []
  type: TYPE_NORMAL
- en: Changing values in the 9-bit permission string is best done using a shortcut
    method based on the octal numbering system counting. Note that there is also another
    notation available which uses short options such as `-`, `+`, `r`, `w`, and `e`,
    which we will not discuss in this section. You can look it up using `man chmod`.
    Using a number between `0` and `7`, which are eight different states, and therefore
    can be called octal notation, we can define every possible combination of read,
    write, and execute for every permission category, user owner, group owner, or
    other users uniquely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the `chmod` octal notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: Using `0`, no read, write, or execute permissions are allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: It means execute permission only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: It means write permission only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`: It means read permission only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: It means the combination of execute and write permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5`: It means the combination of execute and read comments only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6`: It means a combination of write permissions and read permissions only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`7`: It means full permission or read, write, and execute permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So we can easily express the permission types of all three permission categories
    using three numbers only. The first digit represents the read, write, and execute
    permissions for the file's user owner. The second digit represents all the file
    permissions for the group owner, and the third digit represents all the read,
    write, and execute permissions available for all the other users in the system.
    So for example, the octal permission `777` means read, write, and execute permissions
    for all the users available in a system. A permission of `775` means read, write,
    and execute permissions for the user owner of a file, read, write, and execute
    permissions for the group owner of a file, and read and execute permissions only
    for all the other users in the system. A permission of `660` means read and write
    permissions for the user owner of a file, read/write permissions for the group
    owner of a file, and no permissions at all for all the other users in the system,
    meaning that they cannot read, write, or execute this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have created some new users, `Peter` and `Paul` and associated groups
    `project_a` and `project_b` in the previous section, let''s now work and experiment
    with the actual file permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: As we are working on permissions on the time in this chapter first login as
    root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s first create a directory where we put in some files to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change to this directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create some files to play with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's have a look at the file permissions using `ls-l`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we now know, every file has a file owner, which can be seen in the `ls -l`
    output in the third column. Every file also has a group owner in the fourth column.
    The first character in the `ls -l` output is the file type, followed by the 9-bit
    permission string.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s learn how to change the file''s user owner. You can use the `chown`
    command to change the user owner of a file. You can use the `chgrp` command to
    change a file''s user group. Let''s use `ls -l` again to see what has been changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/baf697f8-c90b-434b-ae88-2fc7d42e0850.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you see, `file1` and `file3` have changed the user owner, `file4` has a
    new group owner. Instead of using the `chgrp` command, there is an alternate way
    to define group membership of a file, which system admins often use. It has the
    following notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses a colon to specify the user owner or group owner of a file. For example,
    to change only the group owner of a file use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to change both the username and group use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's also create some subfolders as well for testing directory permissions
    later. Put some files in our newly created subfolders as well. Next, let's use
    some very dangerous permissions for the `test` directory so that everyone is able
    to work with the files properly during our tests. This is not meant to be for
    production.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have learned before, we will use the `chmod` octal notation for changing
    the 9-bit permission string file permissions. Next, let''s create some common
    permissions for our new test files. Also, for showing things, create some unusual
    permissions. Also, change the permissions of our test directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03ed74fc-1212-4fc1-9f4b-f0249bb081ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in order to prepare our tests, we also need to change some user ownership
    permissions and group ownership permissions on some of the directories. Now, let''s
    play around with our new files'' and folders'' permissions. `file1` is a file,
    which has full read, write, and execute permissions for anyone. This is a very
    dangerous permission and is never recommended in any scenario because anyone can
    modify this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/125881e6-8deb-4243-847b-ec5c86a4bcc1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `peter` and `paul` can modify this file and have full access
    on it. The next `file1`, `file2`, has a permission, has the standard permission
    every file gets upon creation. The file owner can read and write, the group and
    all the other users can only read and execute, but not modify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if various users try to write to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af16701b-2ede-47f0-935e-e857fc9139dc.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, only the file owner can write to this file; all the other users
    have no write access. The next file has a permission often used for protecting
    confidential data, such as password files.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/772a7ffe-bdbc-454b-97f3-a2cabbcd63e7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, only the file owner can read the file and no one else can perform
    any other action on the file. The file owner is `paul`. If you try to read this
    file using various usernames, you will learn two things. First, despite which
    permission has been set to a file the root user always has full access to the
    file. Second, other than the root user, who has full access to a file anyways,
    in this example only `paul`, who has read access, can read this file, and no one
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next file has the common permission set used. Not only the file owner,
    but also members of the file''s only group, should have full control over the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1534fe40-c894-44a8-b86b-8173b62ab4aa.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, both `olip` and `peter` have write access to the file, `paul`
    doesn't have access to that file. `olip` has write access to the file because
    he is the file owner. `peter` has access to the file because the group owner also
    has access to the file, and Peter is member of the `project_a` group and also
    of the file's group owner group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `file5` has some unusual permissions, which are valid. `file5` is a script
    file, which prints something out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/876d52d0-cc77-40b9-a266-c714ca34c026.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, only the root user has permissions to execute this file. To execute
    a script, we will use the `./` notation, as we will see later in another section.
    In order to make `peter` available to execute a script, we can just add the `project_a`
    group to `file5` because we know that `peter` is a member of this group. But wait,
    why do we get a permission denied error when `peter` is a member of the `project_a`
    group and `project_a` has permission to execute the script? This is because in
    order for the shell to run a script, it also needs access to read the script file's
    content. So, let's change the file's permission to also include the read flag.
    Now, the user `peter` is able to execute the script. For the `root` user, you
    don't need to set the read permissions because the `root` user has all the permissions
    on every file regardless what is said in the permission string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a common misconception is that in order to delete a file, you need
    to set the file''s write permission flag correctly for the user who wants to delete
    the file, but this is not true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1c5895b-d3fa-4274-9411-95e7ec5abcd8.png)'
  prefs: []
  type: TYPE_IMG
- en: If this would be true, why can't Peter delete this file as we assigned full
    permissions to everyone here? The reason for this is because file deletion is
    completely dependent on the write permissions of the directory the file you want
    to delete is in, and never ever on any file permissions at all. So, in this example,
    the file we want to delete is in the `root` directory, which has no write permissions
    for the user Peter at all. So Peter is not able to delete or create any file in
    the `/root` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s discuss directory permissions. Let''s first review our test
    folder''s directory permissions. In order to do so, let''s change to the `test`
    folder''s directory. Let''s first test out permissions on `folderA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/550e69f2-8b8c-4eac-8d91-5ad3b3163622.png)'
  prefs: []
  type: TYPE_IMG
- en: As you see, `folderA` has read permissions for the file owner only, so Peter
    is the only one who is able to read all the files and subfolders in `folderA`;
    no one else can do this. You can also see because there is no execute flag set
    on a directory; nobody's able to change into this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the `folderB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4588cbc-c587-4585-92eb-22d5f587855a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As only execute permissions are set on the `project_a` folder, and only execute
    permissions are set for the group owner `project_a` group, only Peter who is part
    of the `project_a` group can `cd` into this directory, but you cannot list files.
    So, it''s always a good idea to always combine the execute flag on a directory
    with the read flag. The same is true for `folderC`. First, let''s try out if someone
    is able to write a file in this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see no one can. If you review folder permissions, this is because
    none of our users has ownership permissions on that file.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's set user ownership to the user `olip`. Still no luck to create a new
    file in the `folderC` with the user `olip`. This is because in order to create
    a new file in a directory, not only the write permission has to be set on the
    directory, but also the execute permission. This is also true if you want to delete
    a file in a directory. Finally, how can we change file and folder permissions
    for a whole subdirectory tree recursively for all entries? In order to change
    all the files and folders included in `folderA` recursively with only one command,
    use the `chmod -R` flag, which stands for recursive, and changes all the files
    and folder entries in a directory given as an argument. You can also use the `-R`
    flag for the change owner command as well. As always, be very careful with the
    recursive flag as you might change files to a permission. When it comes to understanding
    permissions in Linux, there are three things you need to memorize. Each of these
    three concepts have to be used from left to right. First, every file has a set
    of permission states for the user owner, group owner, and all the other users,
    for short, `u`, `g`, and `o`. For each of these categories, there exists three
    possible permission states, read, write, and execute, or `r`, `w`, and `x`. Read,
    write, and execute can be represented by the octal numbers 4, 2, and 1, for `r`,
    `w`, and `x`, respectively. Every combination of read, write, and execute you
    want to allow can be represented by a sum of the read, write, and execute corresponding
    octal number values.
  prefs: []
  type: TYPE_NORMAL
- en: Working with text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn all the important tools to print out text file
    content on the command line. We''ll also learn how to view text files using a
    text file viewer. In Linux, there exists two different basic file types, text
    files and binary files. Text files are configuration files, while binary files
    can be image files or compressed data files. The files'' encoding defines whether
    a file should be treated as a text file or binary file. Text files normally use
    UTFR. On Linux, text files normally are encoded using UTF-8 or ASCII. You can
    use the `file` command to detect the file type, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To print out a text file''s content, you can use the `cat` command. `cat` stands
    for concatenate, that''s also the reason where the command has its name from.
    So, let''s concatenate some files and put the results in a new file by redirecting
    `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This line concatenates the three files `passwd`,`group`, and `services` to
    a new file called `concatenated-files` in the `/tmp` directory. Sometimes using
    `cat` to print out the whole file''s content is pure overkill. If we are only
    interested in some lines at the beginning or end of the file, we can use the `head`
    or `tail` commands instead. The beginning of a file is also sometimes called the
    file header, while the end of a file is also called the file footer. To display
    the first `10` lines of our new concatenated file, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you are only interested in the last 10 lines of our new file,
    use instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To change `head` and `tail` default behavior of printing the first 10 lines
    use the `-n` option. Head and tail have other very useful options, use the manual
    pages to learn more. A more important and often used feature is to use the `tail
    follow` option. For example, using the `follow` option with the `root` account,
    the `-f` flag keeps the `tail` command open and tail will listen for new file
    content constantly and outputs it if new text is appended to the `var/log/messages`
    file. If you need a live view on a file which gets written to permanently and
    in real-time, this command needs to be memorized. To close the tail program, use
    *Ctrl* + *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, to read a file's content the `cat` command can be used for smaller files.
    For bigger files, it's better to use a real text viewer program such as `less`,
    which has some powerful features such as searching, scrolling, and displaying
    line numbers. It's also very useful to learn how to navigate text files using
    the less command, as a lot of Linux commands are using less, also called lesser
    navigation, to browse text content for the page or settings, as we will see later.
    To open a file using less, you can use less and then the filename as an argument.
    You can also directly use `stdout` unless using pipes, which is very useful so
    we can easily navigate and scroll bigger command output, which does not fit the
    screen. Navigating in less is pretty simple and should be memorized because you
    will use it a lot in your Linux career. There is a lot more to learn. Read the
    manual pages for the less command to view all the available options.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of movement actions can be done in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: To scroll down a line, you can either use the arrow key or the *J* key. Here,
    we will only show you one of these keyboard options per action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To quit out of the less command, use the *Q* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The uppercase *G* scrolls to the end of the file, while small g scrolls to the
    beginning of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *down arrow* key scrolls down line by line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *up arrow key* scrolls up line by line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the *Page Down* key to scroll down a page and press the *Page Up* key
    to scroll up a page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the right arrow key to scroll to the right for longer lines; to scroll
    back to the left, use the left arrow key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *G* to display file information at the bottom of the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the *Return* key to quit the file information field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type the slash key followed by search term, for example, `HTTP`, and press the
    *Return* key for searching for a keyword `HTTP` in the file using a forward search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing the *n* key will jump to the next search result. Pressing the capital
    *N* key will jump back to the last form of search result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the search is case insensitive if the search pattern is all lowercase;
    otherwise, it's case sensitive. For example, if you search for the word `HTTP`
    all in capital letters, it will only find patterns, which exactly have the HTTP
    in case-sensitive form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, jump to the end of the file by pressing capital *G*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A normal search using the forward slash key searches the file for a keyword
    from top to bottom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to search for a keyword the other way around, from bottom to top,
    you can use the question mark operator, the question mark key, and then the keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the *n* key to jump to the next higher search result in the file. Press
    capital *N* to jump to the last form of search result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Less -N` starts less in line number mode, which means that every line is prefixed
    by the corresponding line number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To go to a specific line number, for example, line 100, type the line number
    followed by a `g`, or to go to line number `20`, type `20g`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To view text files without editing it, you can also use the VIM editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start VIM in read-only mode, type view space and then the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will proceed with VIM editor in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with VIM text editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to install the vi improved, for short VIM,
    text editor. We will also learn all the basics of using VIM. The most simple text
    editor one can imagine is, this creates a new file `my-lorum-file` with the content
    `lorem ipsum dollar sit`, or you can create a new text file with the `cat` command
    interactively as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Use the string `EOF` uppercase to stop writing to that file. Now the `echo`
    and `cat` commands are very useful if you need to create text files with just
    a few words or lines of text. If you need to edit bigger text files or want to
    compose your own files, for example, read-me files for your projects, it's better
    to use a real text editor. One of the available text editors in Linux is VIM,
    or vi improved, which is a very powerful text editor available for every Linux
    distribution. It allows mouse-free text editing, and once you get good with VIM,
    you can really start typing or editing text files at the speed of thought. But
    mastering VIM can take months or even years to get really good, because VIM is
    a very complex editor with a lot of different shortcuts and features Therefore,
    we cannot show you everything in this section, but only the fundamentals to get
    you started quickly with VIM.
  prefs: []
  type: TYPE_NORMAL
- en: 'VIM is the improved version of, and fully compatible to, vi, the text editor
    for UNIX developed in the ''70s. On a CentOS 7 Minimal installation, VIM is not
    installed by default. So, let''s start by installing the VIM editor `- su root
    -c ''yum install vim -y''`. You can open VIM with the filename to open as an argument,
    or without, and save a filename later. The most fundamental concept of VIM is
    its modes. There are three different modes. An insert mode, a command or normal
    mode, and an ex mode. The following screenshot shows the different modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de5683ce-09ec-46f8-89b4-48320eb698f3.png)'
  prefs: []
  type: TYPE_IMG
- en: When you open VIM, you start in normal or command mode. From every mode, you
    can always go back to normal mode by pressing the *Esc* key. This is very useful
    if you don't know in which mode you are currently at. Just press the *Esc* key
    and you are always in normal mode. From there, you can either switch to insertion
    or ex mode. There are several keys available to start the insertion mode. Pressing
    the *i* or *o* key will bring you from command or normal mode into insertion mode,
    where you can start typing text. If you have finished typing text, or you want
    to execute another normal mode command or `ex` command, press the *Esc* key to
    go back to normal mode. From there, if you press the colon key, you go to ex mode.
    From there, pressing the *Return* or *Esc* key brings you back to normal mode.
    The insert mode is for typing or inserting text. In the insert mode, every keystroke
    will be printed on screen in the editor. If you want to navigate the cursor or
    do things such as copying and pasting, deleting of lines, text search, or undo,
    redo, and so on in the file, you need to change to the normal mode. In the normal
    mode, every keystroke is a command. Ex mode is for executing `ex` commands, for
    example, to jump to a certain line in the file, or make a substitution in the
    whole file, or to make a substitution of text in the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will start working with VIM practically. First things first, to exit
    the editor, press the following sequence in normal mode, press `:q!` and then
    press the *Return* key. If you are not in normal mode, for example, you are in
    insertion mode, then you first have to press the *Esc* key, then the `:q!`, and
    then press the *Return* key to exit VI. Now, let's open VIM again with the `/etc/services`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first discuss basic cursor movement commands. Cursor movement commands
    can only be done in normal mode or command mode, which is the default mode when
    you start VIM. If you''re in another mode, such as insertion mode, press the *Esc*
    key to enter the normal mode. Now, to move the cursor, you can use various keyboard
    shortcuts:'
  prefs: []
  type: TYPE_NORMAL
- en: To move the cursor to the right, use the *l* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the cursor to the left, use the *h* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the cursor down, use the *j* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the cursor up, use the *k* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use the arrow keys to do exactly the preceding operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the cursor to the end of a line, press the *$* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the cursor to the beginning of a line, press the *0* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the cursor forward one word, use the *w* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the cursor backwards one word, use the *b* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To jump to the end of the document, use the capital *G* key, which is the same
    key in the less text file viewer for jumping to the end of the document as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To jump to the beginning of the document type `gg`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is also similar to the less command, where you used the small `g` once
    to jump to the beginning of the document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To jump to a certain line number, type the line number; for example, line 100,
    followed by a capital *G*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for text patterns in the VI editor is basically the same as searching
    for text in the less text viewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use /keyword followed by return to start a forward text search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press small *n* to jump to the next search result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press capital *N* to jump to the last former search result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start a backwards search, first go to the end of the document by pressing
    capital *G*, then use the familiar question mark keyword to search for and press
    the *Return* key to start a text search from bottom to top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press *n* to jump to the next higher search result and press *N* to jump to
    the next lower search result at the bottom of the text document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, again jump to the beginning of the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very useful feature in the normal mode is to set marks at specific lines for
    referencing. For example, first go to the line domain. To set a marker to the
    specific line, type the character `m` followed by another character from a to
    z. For example, type `ma`. This creates a new mark referenced by the character
    a in the line, which starts with the domain. In the current line starting with
    domain, if we go to a different location in that file, for example, scrolling
    down pagewise and then if we now use the tick character followed by the character
    which represents our mark, for example `'a,` we will jump back to the line where
    we set our reference mark `a`. As said before, you can set multiple marks from
    a to z, so let's add another mark. Just go to another line, for example, the saft
    line. Now, we will use `b` for our mark. Let's create a mark, type `mb`. Now if
    you go to a different location in the file, like in the fido line, just type `'b`
    to scroll back to the saft line. Type `'a` to go back to the domain line. Easy
    as that.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned all there is to know for basic movement commands in
    the normal or command mode, let's now switch over to learn some deletion commands
    in the normal mode. Pressing the *x* key will delete the character under the cursor,
    while staying in normal mode. Pressing the `dd` key twice deletes a line and puts
    the deleted text into the copy buffer. The d key can be combined with other keys
    too for efficient text deletion. Use `dw` to delete the current word under cursor.
    You can even combine the `dw` command with a number, for example to delete the
    next five words type `5dw`. You already know that in order to jump to the end
    of the line, you use *$*, and to jump to the beginning of the line you use *0*.
    If you want to delete from the current cursor position to the end of the line
    use `d$`. On the other hand, if you want to delete from the current cursor position
    to the beginning of the line use `d0`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the undo and redo commands of the deleted text. The u key
    undoes the last change. For every undo step you perform, you can also perform
    a corresponding redo step using *Ctrl* + *R*. Now for copying and pasting commands,
    simply copy and paste the complete line type `yyp`. To copy multiple lines, first
    mark all the lines you want to copy. To do this, press *Shift* + *V* to start
    your mark, then press the down or up arrow key to select all the lines you want
    to copy. Now, press the *y* key to copy your text, and then press capital *P*
    to insert your copied text.
  prefs: []
  type: TYPE_NORMAL
- en: You can also cut text. In order to cut text lines, first mark your text using
    capital *V*. Now, instead of using the *y* key to yank or copy the text, press
    the capital *C* key to cut out the text. Note that cutting the text will put you
    into insertion mode. To paste the text, you need to go back to normal mode; so,
    press the *Esc* key now. To paste your text somewhere else, use the capital *P*
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed all the basic commands in normal or command mode,
    let's shift to the insert mode. There are several ways to go from normal mode
    to insertion mode. Normally, to enter insert mode, you can use small *i* and small
    *o* and capital *O* keys. Pressing small *o* inserts a new line while entering
    insert mode after the cursor. Pressing capital *O* inserts a new line while entering
    insert mode before the cursor. Pressing *i* takes you to the insert mode right
    after the cursor without inserting a new line.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's discuss `ex` commands. Let's first make some changes to our file.
    Now, in order to execute `ex` commands, we first need to go to normal mode, pressing
    the *Esc* key from the insertion mode, and then pressing the colon key to start
    typing `ex` commands. For example, to write to a file, type the `w`. This will
    write and save your changes to the file. You can also use `:` to enter `ex` commands
    and then press `wq` to write and quit the VIM editor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's open VIM again. To leave the editor, press `:q` and press the *Return*
    key. This will leave the editor if you have not made any changes. Now go back
    to the vi editor. Using the `q ex` command and pressing return will only work
    if you haven't made any changes to the file. Let's change the file. Now, if you
    want to leave the editor while you have made some changes to the file, using the
    ex command `q` will inform you that you are about to leave the editor without
    saving your changes. So if you want to quit the editor without saving changes,
    just type the `:q!`. Now, go back to the services file from the terminal. Another
    very useful ex command is to execute commands on the command line while staying
    in the vi editor. This can be done using the `ex` command exclamation mark and
    then the command you want to execute on the command line, for example, `ls`. This
    will switch over to the command line and present you with the result; then if
    you press the return key, you go back to the editor. Another very useful ex command
    is the `sh` command. Typing in `sh` as an `ex` command will switch to a command
    line while VI is still running in the background. Here, you can execute commands
    as you would normally on a command line. If you are done working on the command
    line, you can go back to the VIM editor by typing `exit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search and replace a word, VIM offers us a set-like substitution mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to substitute the word `echo` with the word `hello world` in the
    whole file, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To enable line number mode, type `set number`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To go to a specific line, type the number line in ex mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To leave number mode, type `set nonumber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To open a different file in VIM, type `e` and then the filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To save a file under a different name, type `w` and then the different filename,
    for example `my-test-file`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have extensively covered the Linux filesystem, wherein we
    discussed file links, searching for files, file permissions, user and groups and
    the VIM text editor. We also looked into the functionalities of each concept.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover how to work with the command line.
  prefs: []
  type: TYPE_NORMAL
