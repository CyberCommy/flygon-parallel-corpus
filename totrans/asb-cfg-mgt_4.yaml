- en: Chapter 4. Larger Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now we have been looking at single plays in one playbook file. This approach
    will work for simple infrastructures, or when using Ansible as a simple deployment
    mechanism. However, if you have a large and complicated infrastructure, then you
    will need to take actions to prevent things from going out of control. This chapter
    will include the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Separating your playbooks into different files, and including them from some
    other location
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using roles to include multiple files that perform a similar function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods for increasing the speed at which Ansible configures your machines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first issues you will face with a complex infrastructure is that
    your playbooks will rapidly increase in size. Large playbooks can become difficult
    to read and maintain. Ansible allows you to combat this problem by way of includes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Includes allow you to split your plays into multiple sections. You can then
    include each section from other plays. This allows you to have several different
    parts built for a different purpose, all included in a main play.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of includes, namely, variable includes, playbook includes,
    task includes, and handler includes. Including variables from an external `vars_file`
    files has been discussed already in [Chapter 2](ch02.html "Chapter 2. Simple Playbooks"),
    *Simple Playbooks*. The following is a description of what each includes does:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable includes**: They allow you to put your variables in external YAML
    files'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playbook includes**: They are used to include plays from other files in a
    single play'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task includes**: They let you put common tasks in other files and include
    them wherever required'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler includes**: They let you put all your handlers at one place'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be looking at these includes in the following section; however, including
    variables from an external `vars_file` files has been discussed already in [Chapter
    2](ch02.html "Chapter 2. Simple Playbooks"), *Simple Playbooks*, so we will not
    be discussing it in detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Task includes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Task includes can be used when you have a lot of common tasks that will be repeated.
    For example, you may have a set of tasks that removes a machine from monitoring
    and a load balancer before you can configure it. You can put these tasks in a
    separate YAML file, and then include them from your main task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Task includes inherit the facts from the play they are included from. You can
    also provide your own variables, which are passed into the task and are available
    for use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Finally, task includes can have conditionals applied to them. If you do this,
    conditionals will separately be added to each included task by Ansible automatically.
    The tasks are all still included. In most cases, this is not an important distinction;
    however, in circumstances where variables may change, it is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The file to include as a task includes contains a list of tasks. If you assume
    the existence of any variables, hosts, or groups, then you should state them in
    comments at the top of the file. This makes it easier for people who wish to reuse
    the file later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you wanted to create a bunch of users and set up their environment with
    their public keys, you would split out the tasks that do a single user to one
    file. This file will look similar to the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We expect that a variable named `user` will be passed to us, and that their
    public key will be in the `keys` directory. The account is created, the `ssh config`
    directory is made, and finally we can copy this in their public key. The easiest
    way to use this `config` file would be to include it with the `with_items` keyword
    you learned about in [Chapter 3](ch03.html "Chapter 3. Advanced Playbooks"), *Advanced
    Playbooks*. This will look similar to the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Handler includes
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing Ansible playbooks, you will constantly find yourself reusing the
    same handlers multiple times. For instance, a handler used to restart MySQL is
    going to look the same everywhere. To make this easier, Ansible allows you to
    include other files in the handlers section. Handler includes look the same as
    task includes. You should make sure to include a name on each of your handlers;
    otherwise, you will not be able to refer to them easily in your tasks. A handler
    includes file looks similar to the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This file provides several common tasks that you would want to handle after
    configuring `sendmail`. By including the following handlers in their own files,
    you can easily reuse them whenever you need to change the `sendmail` configuration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The first handler regenerates the `sendmail` database's `config` file and triggers
    a `reload` file of `sendmail` later
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second handler initializes the `aliases` database, and also schedules a
    `reload` file of `sendmail`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third handler reloads `sendmail`; it may be triggered by the previous two
    jobs, or it may be triggered directly from a task
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth handler restarts `sendmail` when triggered; this is useful if you
    upgrade `sendmail` to a new version
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Handlers can trigger other handlers provided they only trigger the ones specified
    later, instead of the triggered ones. This means you can set up a series of cascading
    handlers that call each other. This saves you from having long lists of handlers
    in the notify section of tasks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding handler file is easy now. We simply need to remember that
    if we change a `sendmail` configuration file, then we should trigger `config sendmail`,
    and if we change the `aliases` file, we should trigger `config aliases`. The following
    code shows us an example of this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This playbook makes sure `sendmail` is installed. If it isn't installed, or
    if it isn't running the latest version, then it installs it or updates it. After
    it is updated, it schedules a restart so that we can be confident that the latest
    version will be running once the playbook is done. In the next step, we replace
    the `sendmail` configuration file with our template. If the `config` file was
    changed by the template, then the `sendmail` configuration files will be regenerated,
    and finally `sendmail` will be reloaded.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Playbook includes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playbook includes should be used when you want to include a whole set of tasks
    designated for a set of machines. For example, you may have a play that gathers
    the host keys of several machines and builds a `known_hosts` file to copy to all
    the machines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: While task includes allows you to include tasks, playbook includes allows you
    to include whole plays. This allows you to select the hosts you wish to run on,
    and provide handlers for notify events. Because you are including whole playbook
    files, you can also include multiple plays.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Playbook includes allows you to embed fully self-contained files. It is for
    this reason that you should provide any variables that it requires. If they depend
    on any particular set of hosts or groups, this should be noted in a comment at
    the top of the file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'This is handy when you wish to run multiple different actions at once. For
    example, let''s say we have a playbook that switches to our DR site, named `drfailover.yml`,
    another named `upgradeapp.yml` that upgrades the app, another named `drfailback.yml`
    that fails back, and finally `drupgrade.yml`. All these playbooks might be valid
    to use separately; however, when performing a site upgrade, you will probably
    want to perform them all at once. You can do this as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, you can put full plays in the playbooks that you are including
    other playbooks into.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your playbooks start expanding beyond what includes can help you solve, or
    you start gathering a large number of templates, you may want to use roles. Roles
    in Ansible allow you to group files together in a defined structure. They are
    essentially an extension to includes that handles a few things automatically,
    and this helps you organize them inside your repository.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Roles allow you to place your variables, files, tasks, templates, and handlers
    in a folder, and then easily include them. You can also include other roles from
    within roles, which effectively creates a tree of dependencies. Similar to task
    includes, they can have variables passed to them. Using these features, you should
    be able to build self-contained roles that are easy to share with others.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Roles are commonly set up to manage services provided by machines, but they
    can also be daemons, options, or simply characteristics. Things you may want to
    configure in a role are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Web servers, such as Nginx or Apache
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages of the day customized for the security level of the machine
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database servers running PostgreSQL or MySQL
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To manage roles in Ansible, perform the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named roles with your playbooks.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `roles` folder, make a folder for each role that you would like.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder for each role, make folders named `files`, `handlers`, `meta`,
    `tasks`, `templates`, and finally `vars`. If you aren't going to use all these,
    you can leave out the ones you don't need. Ansible will silently ignore any missing
    files or directories when using roles.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your playbooks, add the keyword roles followed by a list of roles that you
    would like to apply to the hosts.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, if you had the `common`, `apache`, `website1`, and `website2` roles,
    your directory structure would look similar to the following example. The `site.yml`
    file is for reconfiguring the entire site, and the `webservers1.yml` and `webservers2.yml`
    files are for configuring each web server farm.![Roles](graphics/4267_04_01.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following file is what could be in `website1.yml`. It shows a playbook
    that applies the `common`, `apache`, and `website1` roles to the `website1` group
    in the inventory. The `website1` role is included using a more verbose format
    that allows us to pass variables to the role, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the role named `common`, Ansible will then try to load `roles/common/tasks/main.yml`
    as a task include, `roles/common/handlers/main.yml` as a handler include, and
    `roles/common/vars/main.yml` as a variable file include. If all of these files
    are missing, Ansible will throw an error; however, if one of the files exists,
    then the others, if missing, will be ignored. The following directories are used
    by a default install of Ansible (other directories may be used by different modules):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '| Directory | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `tasks` | The `tasks` folder should contain a `main.yml` file, which should
    include a list of the tasks for this role. Any task includes that are contained
    in these roles will look for their files in this folder also. This allows you
    to split a large number of tasks into separate files, and use other features of
    task includes. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `files` | The `files` folder is the default location for files in the roles
    that are used by the copy or the script module. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `templates` | The `templates` directory is the location where the template
    module will automatically look for the jinja2 templates included in the roles.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `handlers` | The `handlers` folder should contain a `main.yml` file, which
    specifies the handlers for the roles, and any includes in that folder will also
    look for the files in the same location. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `vars` | The `vars` folder should contain a `main.yml` file, which contains
    the variables for this role. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `meta` | The `meta` folder should contain a `main.yml` file. This file can
    contain settings for the role, and a list of its dependencies. This feature is
    available only in Ansible 1.3 and above. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `default` | You should use the `default` folder if you are expecting variables
    to be sent to this role, and you want to make them optional. A `main.yml` file
    in this folder is read, to get the initial values for variables that can be overridden
    by variables, which are passed from the playbook calling the role. This feature
    is only available in Ansible 1.3 and above. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: 'When using roles, the behavior of the copy, the template, and the script modules
    is slightly altered. In addition to searching for files by looking from the directory
    in which the playbook file is located, Ansible will also look for the files in
    the location of the role. For example, if you are using a role named `common`,
    these modules will change to the following behavior:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The copy module will look for files in `roles/common/files`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template module will first look for templates in `roles/common/templates`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script module will first look for files in `roles/common/files`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other modules might decide to look for their data in other folders inside
    `roles/common/`. The documentation for modules can be retrieved using `ansible-doc`,
    as was discussed in the *Module help* section of [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Ansible"), *Getting Started with Ansible*.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role metadata
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using role metadata allows us to specify that our role depends on other roles.
    For example, if the application you are deploying needs to send an e-mail, your
    role could depend on a Postfix role. This would mean that before the application
    is set up and installed, Postfix will be installed and set up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The `meta/main.yml` file will look similar to the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `allow_duplicates` line is set to `no`, which is the default. If you set
    this to `no`, Ansible will not run a role the second time, if it is included twice
    with the same arguments. If you set it to `yes`, it will repeat the role even
    if it has run before. You can leave it `off` instead of setting it to `no`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are specified in the same format as roles. This means you can pass
    variables here; either static values or variables that are passed to the current
    role.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Role defaults
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second feature included with Ansible 1.3 is variable default values. If
    you place a `main.yml` file in the defaults directory for the role, these variables
    will be read into the role; however, they can be overridden by variables in the
    `vars/main.yml` file, or the variables that are passed to the role when it is
    included. This allows you to make passing variables to the role optional. These
    files look exactly like other variable files. For example, if you used a variable
    named `port` in your role, and you want to default it to port `80`, your `defaults/main.yml`
    file will look similar to the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Speeding things up
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you add more and more machines and services to your Ansible configuration,
    you will find things getting slower and slower. Fortunately, there are several
    tricks you can use to make Ansible work on a bigger scale.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible isn't just limited to being able to configure our machines; we can also
    use it to create the machines that we will be configuring. We are also not limited
    to just making the machines to be configured, we can also make networks, load
    balancers, DNS entries, or even your whole infrastructure. You can even have this
    automatically happen before you provision the machine by using the `group`, `group_by`
    and `add_host` modules.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use Google Compute to create two machines, and
    then install and start MySQL server on them:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tags
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible tags are features that allow you to select the parts of a playbook that
    you need to run, and which should be skipped. While Ansible modules are idempotent
    and will automatically skip if there are no changes, this often requires a connection
    to the remote hosts. The yum module is often quite slow in determining whether
    a module is the latest, as it will need to refresh all the repositories.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: If you know you don't need certain actions to be run, you can select to run
    only those tasks that have been tagged with a particular tag. This doesn't even
    try to run the tasks, it simply skips over it. This will save time on almost all
    the modules even if there is nothing to be done.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you have a machine that has a large number of shell accounts, but
    also several services set up to run on it. Now, imagine that a single user's SSH
    key has been compromised and needs to be removed immediately. Instead of running
    the entire playbook, or rewriting the playbooks to only include the steps necessary
    to remove that key, you could simply run the existing playbooks with the SSH keys
    tag, and it would only run the steps necessary to copy out the new keys, instantly
    skipping anything else.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly useful if you have a playbook with playbook includes in
    it that covers your whole infrastructure. With this setup, you can quickly deploy
    security patches, change passwords, and revoke keys across your entire infrastructure
    as quickly as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Tagging tasks is really easy; simply add a key named `tag`, and set its value
    to a list of the tags you want to give it. The following code shows us how to
    do this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This play defines the `patch`, `deploy`, and `config` tags. If you know which
    operation you wish to do in advance, you can run Ansible with the correct argument,
    only running the operations you choose. If you don''t supply a tag on the command
    line, the default is to run every task. For example, if you want Ansible to only
    run the tasks tagged as `deploy`, you will run the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In addition to working on discrete tasks, tags are also available to roles,
    which make Ansible apply only the roles for the tags that have been supplied on
    the command line. You apply them similarly to the way they are applied to tasks.
    For example, refer to the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, the `common` role does not get any tags, and will not
    be run if there are any tags applied. If the `patch` tag is applied, the `apache`
    and `website2` roles will be applied, but not `common`. If the `deploy` tag is
    applied; only the `website2` tag will be run. This will shorten the time required
    to patch servers or run deployments, as the unnecessary steps will be completely
    skipped.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Ansible's pull mode
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible includes a pull mode that can drastically improve the scalability of
    your playbooks. So far we have only covered using Ansible to configure another
    machine over SSH. This is a contrast to Ansible's pull mode, which runs on the
    host that you wish to configure. Since `ansible-pull` runs on the machine that
    it is configuring, it doesn't need to make connections to other machines and runs
    much faster. In this mode, you provide your configuration in a git repository
    that Ansible downloads and uses to configure your machine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use Ansible''s pull mode in the following situations:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Your node might not be available when configuring them, such as members of auto-scaling
    server farms
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a large amount of machines to configure and even with large values
    of forks, it would take a long time to configure them all
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want machines to update their configuration automatically when the repository
    changes
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to run Ansible on a machine that may not have network access yet, such
    as in a kick start post install
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the pull mode does have the following disadvantages that make it unsuitable
    for certain circumstances:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: To connect to other machines and gather variables, or to copy a file, you need
    to have credentials on the managed nodes
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to co-ordinate the running of the playbook across a server farm; for
    example, if you could only take three servers offline at a time
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The servers are behind strict firewalls that don't allow incoming SSH connections
    from the nodes you used to configure them for Ansible
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pull mode doesn''t require anything special in your playbooks, but it does
    require some setup on the nodes you want configured. In some circumstances, you
    can do this using Ansible''s normal push mode. Here is a small play to setup pull
    mode on a machine:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we performed the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: First we installed and set up **EPEL**. This is a repository with extra software
    for CentOS. Ansible is available in the EPEL repository.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we installed Ansible, making sure to enable the EPEL repository.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we created a directory for Ansible's pull mode to put the playbooks in.
    Keeping these files around means you don't need to download the whole git repository
    all the time; only updates are required.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally we set up a cron job that will try to run the `ansible-pull` mode config
    every five minutes.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code downloads the repository off an internal HTTPS git server.
    If you want to download the repository instead of SSH, you will need to add a
    step to install SSH keys, or generate keys and copy them to the git machine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Storing secrets
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eventually, you will need to include sensitive data in your Ansible recipes.
    All the recipes that we have discussed so far have to be stored on the disk in
    plain text; if you are also storing it in source control, then third parties may
    even have access to this data. This is risky and may be in violation of your corporate
    policies.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: This can be avoided using Ansible vaults. Vaults are files that are encrypted
    and can be decrypted by Ansible transparently. You can use them for includes,
    variable files, tasks lists in roles and any other YAML formatted file that Ansible
    uses. You can also use it with both JSON and YAML files included with the `-e`
    command-line argument to ansible-playbook. Vault files are managed with the `ansible-vault`
    command and can be used as if they were not encrypted at all.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ansible-vault` command has several modes, which are given as the first
    argument. This table describes the modes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Action |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `Create` | This starts your default editor to create a new encrypted file
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `Encrypt` | This encrypts an existing file, turning it into a vault |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `Edit` | This edits a vault allowing you to change the content |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `Rekey` | This changes the password that is used to encrypt the vault |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `Decrypt` | This decrypts the vault turning it back into a regular file |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: 'For example, to create a new variable file for your staging environment you
    would run:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command will prompt you for a password, ask you to confirm it, and then
    open your editor so that you can add the content; finally, the encrypted content
    will be saved in `vars/staging.yml`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: When using a vault file, you need to provide the password so that they can be
    decrypted. This can be done in one of three ways. You can give the `--ask-vault-pass`
    argument to Ansible, which will cause Ansible to prompt for the password every
    time it starts. You can also use the `--vault-password-file` argument, which points
    to a file containing the password. Finally, you can add `vault_password_file`
    to the `ansible.cfg` file to automatically make Ansible use the vault password
    file for every command. It is important to note that only one password can be
    supplied for each Ansible run, so you can't include several different files with
    different passwords.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have Ansible prompt for a password to run a playbook that is encrypted,
    you will do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The password file can also be an executable. To print to the screen print to
    standard error, to read from the user you can use `stdin` as usual and finally
    the script needs to print the password to `stdout` before it exits.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the techniques required when moving from a
    simple setup to a larger deployment. We discussed how to separate your playbook
    into multiple parts using includes. We then looked at how we can package related
    includes and automatically include them all at once using roles. Finally, we discussed
    the pull mode, which allows you to automate the deployment of playbooks on the
    remote node itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了从简单设置转移到更大规模部署时所需的技术。我们讨论了如何使用包含来将你的playbook分成多个部分。然后，我们看了一下如何打包相关的包含，并使用角色自动全部包含它们。最后，我们讨论了拉取模式，它允许你在远程节点上自动化部署playbook。
- en: In the next chapter, we will cover writing your own modules. We start this by
    building a simple module using bash scripting. We then look at how Ansible searches
    for modules, and how to make it find your own custom ones. Then, we take a look
    at how you can use Python to write more advanced modules using features that Ansible
    provides. Finally we will write a script that configures Ansible to pull its inventory
    from an external source.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何编写自己的模块。我们首先通过使用bash脚本构建一个简单的模块来开始。然后，我们将看看Ansible是如何搜索模块的，以及如何让它找到你自己定制的模块。接下来，我们将介绍如何使用Python编写更高级的模块，利用Ansible提供的功能。最后，我们将编写一个脚本，配置Ansible从外部来源获取清单。
