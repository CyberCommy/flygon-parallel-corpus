- en: '*Chapter 8*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the workings of an asynchronous operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use callback to handle async operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrate callbacks and event loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement promises to handle async operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite async code with callbacks using promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactor your legacy code using async and await functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will explore the asynchronous (later abbreviated as async)
    nature of JavaScript. The focus will be on how conventional languages handle operations
    that take time to complete, and how JavaScript handles these operations. Later,
    we will discuss various methods we can adopt to handle these situations in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how we can use arrays and objects and their
    helper functions. In this chapter, we will learn more about how JavaScript runs
    and how we can handle time-consuming operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working on large-scale projects with JavaScript, often, we must deal with
    network requests, disk IO, and data processing. Many of these operations take
    time to complete, and for beginners who have just started using JavaScript, it
    is very difficult to understand how to retrieve the results of these time-consuming
    operations. This is because, unlike other languages, JavaScript has a special
    way of handling these operations. When coding programs, we are used to linear
    thinking; that is, the program executes line by line and only breaks that flow
    when we have loops or branches. For example, if you wanted to make a simple network
    request in Java, you would have to do something similar to what''s shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s simple to understand: you create an HTTP client and call a method within
    the client to request the contents of that URL. Once the request is made and a
    response is received, it will continue to run the next line of code that returns
    the body of the response. During this time, the whole function will halt and wait
    for the `fetch` and will only continue once the request is completed. This is
    the normal way these operations are handled in other languages. This way of handling
    time-consuming operations is called **synchronous handling** because it forces
    the program to pause and only resume once the operation is completed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this linear thinking, many developers (including me) get very confused
    when they first start coding in JavaScript. Most people will start writing code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the look of the code, it should behave just like our preceding code. It
    will make the request, set the response variable to the response body once it
    is completed, and then it will output the response. Most developers that have
    tried this will know that this is not how JavaScript works; the code will run,
    produce 'undefined' output, and exit.
  prefs: []
  type: TYPE_NORMAL
- en: How JavaScript Handles Time-Consuming Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, these operations are often handled using async programming.
    There are multiple ways to do that in JavaScript; the most widely used method,
    and the one you will see the most in legacy programs, is called a **callback**.
    A callback is just a fancy term for passing a function that includes the rest
    of your application logic to another function; they are actually very easy to
    understand. Consider the fact that traditional functions return their values once
    the logic is complete. In async programming, they often don''t return a value;
    instead, they pass their result to the callback function provided by the caller.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at why this is not going to produce the result we want. The `request`
    library that we have used can be considered as a function that performs some operation
    logic that is time-consuming. The `request` function expects you to pass it a
    parameter as a callback that includes everything you are about to do next. In
    the callback function, we accept two parameters, `err` and `res`; inside the function,
    we assign the response variable we declared earlier to the `res` body (the response
    body). Outside the `request` function, we have `console.log` to log out the response.
    Because the callback function will get called sometime in the future, we will
    log the value of the response before we set any value to it. Most developers get
    very frustrated when dealing with JavaScript because the preceding code is not
    linear. The order of the execution follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the order of execution in the preceding code, the first
    three lines work just as we expected. We import the `request` library and declare
    a variable response, and then call the `request` library with a URL with a callback.
    Because the callback is only invoked when the network request finishes, the program
    will continue executing the rest of the code, which outputs the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, when the network request is finished, it will invoke our callback function
    and run the line that assigns the body to our response. To make this code behave
    as we expected, we need to modify the code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we pulled `console.log` inside the callback so that it
    can be executed only when the assignment is complete. Now, when we run this code,
    it will output the actual response body.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Async Operations Using Callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the introduction, we talked about how JavaScript treats async operations
    differently compared with other languages. In this chapter, we will explore how
    we can write complex JavaScript applications with many async operations using
    the callback method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 61: Writing Your First Callback'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will first write a small function mimicking a function
    that takes a while to finish. Later, we will write another function that consumes
    our async function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise61](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise61).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `slowAPI` object to create a mock API library; its purpose is to return
    the results in a reasonable amount of time. We write this first to introduce you
    to how we can mimic an async function without the need to perform async operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `getUsers` function in the `slowAPI` object we just defined that returns
    nothing and expects a callback. Call the `setTimeout` function inside `getUsers`,
    which is used to add a 1-second delay to our code if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `getCart` function in the `slowAPI` object and create an `if-else`
    loop inside the function to match the username and return an error if it doesn''t:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `runRequests` function that calls `getUsers` to grab a user list.
    Inside the callback function, we are going to print out the response or error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `run Request` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Output of runRequest'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.1: Output of runRequest'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that the `runRequest` function has finished running and our response
    is correctly printed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `runRequest` function to call `getCart` as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we put a similar call to `slowAPI` inside our `runRequest` function;
    nothing else is changed. When we run this, we get a very interesting output, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Output after modifying the runRequest function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.2: Output after modifying the runRequest function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It's very interesting because it first outputs the result from `getCart`, and
    then the result for `getUsers`. The program is behaving like this because of the
    async and non-blocking nature of JavaScript. In our operations, because the `getCart`
    function only takes 500 milliseconds to complete, it will be the first output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the preceding function to output the cart of the first user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Output of the cart for the first user'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.3: Output of the cart for the first user'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because we will be using the data from the first request, we must write the
    logic for our next request inside the callback of the first request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trigger an error when accessing the cart of an unknown user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What we do know about the data we are returning from `getCart` is that the
    last user does not match any `if` statements. Therefore, it will throw an error
    when called. When we run the code, we will see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Printing the error'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.4: Printing the error'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first error output we see in white is the error we are outputting through
    `console.error`. This can be customized to your preferred error message or output
    in a specific format using the logging framework. The second is from the process
    crashing because we are throwing a new error right after `console.log`.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we checked how we can mimic async functions with `setTimeout`.
    `setTimeout` is a very useful function. Although it's not really recommended for
    use in actual code, it is very useful if you need to mock a network request that
    takes time in tests or produces a race condition when debugging your software.
    Later, we went over ways to use async functions using callbacks and how error
    handling works in async functions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to briefly talk about why callbacks are slowly becoming outdated
    and what can happen if you don't use callbacks properly.
  prefs: []
  type: TYPE_NORMAL
- en: Event Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have heard this term before, referring to how JavaScript handles time-consuming
    operations. It is also very important to know how event loops work under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you consider what JavaScript is used most for, it is for making dynamic
    websites and it is used mostly in the browser. To the surprise of a lot of people,
    JavaScript code runs in a single thread, which simplifies a lot of things for
    developers, yet it opens challenges when dealing with multiple operations happening
    at the same time. In the JavaScript runtime, there is an infinite loop run in
    the background that manages messages for your code and handles events. The event
    loop is responsible for consuming callbacks in the callback queue, running functions
    in the stack, and calling web APIs. Most of the operations you can do in JavaScript
    are classified into two types: blocking and non-blocking. By blocking, we mean
    blocking the event loop (you can consider this as the normal UI thread for other
    languages). When the event loop is blocked, it cannot process any more events
    from other parts of the application, and the application will freeze until it
    is unblocked. Here is a list of sample operations and their classification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Table with sample operations and their classification'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.5: Table with sample operations and their classification'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'What you can see from the preceding list is that almost all I/O in JavaScript
    is non-blocking, meaning that even if it takes more time to complete than expected,
    it will not block the event loop. Blocking the event loop, as in any language,
    is a terrible thing to do because it makes the application unstable and unresponsive.
    This brings us to a question: How can we know if a non-blocking operation was
    completed.'
  prefs: []
  type: TYPE_NORMAL
- en: How JavaScript Executes Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When JavaScript is executing blocking code, it will block the loop and complete
    the operation before the program can continue with the rest of the code. If you
    run a loop that iterates 1 million times, the rest of your code must wait for
    that loop to finish before continuing. Therefore, it is not recommended to have
    a lot of blocking operations in your code because they affect performance, stability,
    and user experience. When JavaScript is executing non-blocking code, it initiates
    the process by handing it to web APIs to do the fetching, timeouts, and rests.
    Once the operation is complete, the callback is pushed to the callback queue so
    it can be consumed by the event loop later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In modern browsers, this is implemented as follows, where we have the heap
    that stores most of our object allocations, and the stack for the function calls.
    During each event loop cycle, the event loop favors the stack first and executes
    those events by calling appropriate web APIs. Once the operation is complete,
    the callback for that operation will then be pushed to the callback queue, which
    will be consumed later by the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Event loop cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.6: Event loop cycle'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To see how everything works under the hood, let''s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From the look of it, the code does two things: it creates a timeout that prints
    out ''`hi`'' after 2 seconds, and an infinite loop that does nothing at all. When
    you run the preceding code, it will behave a bit strangely – nothing gets printed
    out and the program just hangs. The reason it behaves like that is the event loop
    favors items on the stack more than items in the callback queue. Because we have
    an infinite `while` loop that keeps pushing to the call stack, the event loop
    is occupied with running the loop and ignores the completed `setTimeout` callback
    in the callback queue. Another interesting fact about the way `setTimeout` works
    is that we can use it to delay our function to the next cycle of the event loop.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have `setTimeout` followed by `console.log`, but here we are using
    `0` as the timeout, meaning we want this to be completed immediately. Once the
    timeout is complete and the callback is pushed to the callback queue, as our event
    loop favors call stacks, you can expect output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: Output after the timeout is complete'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.7: Output after the timeout is complete'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We see that `hi` is printed out before `hi again` because even when we set the
    timeout to zero, it will still be executed last because the event loop will execute
    items on the call stack before items in the callback queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11: Using Callbacks to Receive Results'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will use callbacks to receive results. Suppose you are
    working as a software engineer for a local gas company and they want you to write
    a new feature for them:'
  prefs: []
  type: TYPE_NORMAL
- en: You are given a client API library that you can use to request a list of local
    users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to implement a feature that calculates the bill for those users and
    returns the result in the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You need to implement a `calculateBill` function that takes `id` and calculates
    the gas bill for that user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To accomplish this, you need to request the list of users and get the rates
    for those users and their usage. Lastly, calculate the final amount due and return
    the combined result.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Activity11](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Activity11).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `calculate` function that takes `id` and a callback as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `getUsers` to get all of the users, which will give us the address we need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `getUsage` to get the usage of our user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, call `getRate` to get the rate of the user we are doing the calculation
    for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `calculate` function using an existing ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `calculate` function using an ID that does not exist to check the
    resulting error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output with the error returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Invoking a function using an ID that doesn’t exist'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.8: Invoking a function using an ID that doesn''t exist'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 613.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, the feature we implemented is very similar to what you might
    see in the real world. We worked with multiple async operations in one function.
    Next, we will talk about callback hell and how that can be a problem when we are
    dealing with multiple async operations.
  prefs: []
  type: TYPE_NORMAL
- en: Callback Hell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Callback hell refers to the obstacles faced by JavaScript developers when working
    on large-scale projects. The cause of callback hell is not entirely the fault
    of the developer; it''s partially because of how JavaScript handles async operations.
    By using callbacks to handle multiple async operations, it''s very easy for things
    to get out of control. The following code illustrates an example of callback hell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code example is a perfect example of callback hell. Although
    this code is shorter than actual callback hell code you will find in the real
    world, it is equally terrible. Callback hell is the condition where a block of
    code has so many callbacks nested inside it that it becomes hard for the developer
    to understand, maintain, and even debug the code. If the preceding code was being
    used to implement actual business logic, it would extend to more than 200 lines.
    With that many lines and that many levels of nesting, it would create the following
    issues:'
  prefs: []
  type: TYPE_NORMAL
- en: It would be difficult to figure out which callback you were currently in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could cause variable name collision and overwrite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be almost impossible to debug and breakpoint the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code would be very hard to reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code would not be testable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These issues are just some of a list of issues that can be caused by callback
    hell. They are the reason why many companies even include questions about callback
    hell in their interview questions. There are many proposed ways to make code much
    more readable than the preceding code. One way is to pull almost every callback
    out as a separate function. Using this technique, the preceding code can be modified
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the code is rewritten like this, we can see that all our processing functions
    are separated out. Later, we can put them in a separate file and reference them
    using `require()` to import it. This does solve the problem of having all the
    code in one place and testability issues. It also makes the code base unnecessarily
    big and fragmented. In ES6, the promise was introduced. It opened up a brand new
    way to handle async operations. In the next section, we will go over how promises
    work and how we can use them to save us from callback hell.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, a promise is an object that represents some value in the future.
    Usually, it is a wrapper for an async operation. Promises can also be passed around
    in functions and used as returns for promises. Because a promise represents an
    async operation, it can have one of the following states:'
  prefs: []
  type: TYPE_NORMAL
- en: Pending, meaning the promise is pending, which means there might be an async
    operation still running and there is no way to determine its result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fulfilled, meaning the async operation has completed without errors and the
    value is ready to be received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rejected, meaning the async operation has finished with errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A promise can have only one of the preceding three states. When a promise is
    fulfilled, it will call the handler provided to the `.then` promise function,
    and when it is rejected, it will call the handler provided to the `.catch` promise
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a promise, we use the `new` keyword in the `Promise` constructor.
    The constructor takes a function that will include the code for the async operation.
    It also passes two functions as a parameter, `resolve` and `reject`. `resolve`
    is called with the resulting value when the async operation is completed and the
    value is ready to be passed. `reject` is called when the async operation has failed
    and you want to return the failure reason, which is typically an error object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code uses Promise.resolve to return a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.resolve` returns a promise that is resolved to the value you passed
    down as the parameter. It is very useful when you want to keep your code base
    consistent, or are unsure whether a value is a promise or not. Once you wrap the
    value using `Promise.resolve`, you can start work on the value of the promise
    using the `then` handler.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will look at how we can handle async operations with
    promises and how we can combine multiple async operations with promises without
    resulting in callback hell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 62: Using Promises as Alternatives to Callbacks'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last activity, we talked about how we can combine multiple async operations
    into one single result. It's very easy to understand, but it can also make the
    code very long and hard to manage. We went over callback hell and how to avoid
    it. One thing we can do is to utilize the `Promise` object introduced in ES6\.
    In this exercise, we will go over ways in which we can use promises in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise62](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise62).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When creating a promise, we need to use the `new` keyword in the `Promise` constructor.
    The `Promise` constructor requires you to provide a resolver function to execute
    async operations. When a promise is created, it will automatically invoke the
    resolver function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an operation to the resolver function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: Adding an operation in the resolver function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.9: Adding an operation to the resolver function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Even though `console.log` is not an async operation, when we create a promise,
    it will automatically execute our resolver function and print out `hi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolve the promise using `resolve`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the function is called, a `resolve` function is passed to our resolver
    function. When it is called, the promise will be resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: Resolved promise after the function is called'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.10: Resolved promise after the function is called'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Retrieve the value using the `then()` function. By attaching a `then` handler,
    you are expected to read the resolved promise value from the callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: Retrieving the value using the then function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.11: Retrieving the value using the then function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Whenever you create a promise, you expect the async function to complete and
    return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an immediately resolved promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an immediately rejected promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: Immediately rejected promise creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.12: Immediately rejected promise creation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just like `Promise.resolve`, creating a promise using `Promise.reject` will
    return a promise that is rejected with the reason you provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handle `error` in the promise using `catch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can provide an error handler using `catch`. This adds a rejection callback
    to the promise. When you provide a catch handler, the error returned from the
    promise will be passed as the argument of the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13: Handling an error in a promise using catch'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.13: Handling an error in a promise using catch'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create a `wait` function that returns a promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Use an `async` function to delay our console log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14: Delaying the console log using an async function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.14: Delaying the console log using an async function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, using it is very simple. Our `wait` function returns a new promise
    every time we invoke it. To run our code once the operation is complete, pass
    it into the `then` handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chain the promises using the `then` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15: Promises chained using the then function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.15: Promises chained using the then function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For example, when we want to chain two promises together, all we need to do
    is to pass them inside the `then` handler and make sure the result is also a promise.
    Here, we see that after we call `wait` for 2 seconds, we call another `wait` for
    2 seconds and make sure the timer starts after the first one finishes.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we went over a couple of ways to create promises and how to
    create an async function that handles operations using promises instead of callbacks.
    Lastly, we chained promises using the `then` function. These are very simple ways
    to use promises. In the next chapter, we will talk about how to effectively chain
    them and how to handle errors from promises.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining Promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last exercise, we looked at a very simple way to chain promises. Promise
    chaining can be complex as well, and doing it properly can avoid a lot of potential
    issues in your code. When you are designing a complex application that requires
    you to do multiple async operations at once, it''s easy to get into callback hell
    when using callbacks. Using promises solves some of the problems related to callback
    hell, but it is not a silver bullet. Often, you will see code written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you see code written like this, it's hard to tell whether switching to
    promises solved anything. The preceding code has the same problem as our callback-hell
    code; all the logic is fragmented and nested. We also have other issues, such
    as the potential for the value on the upper scope to be accidentally overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are writing code with promises, we should think about making the code
    as modular as possible and treat the collection of operations as a pipeline. For
    our preceding example, the pipeline would be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16: Example pipeline (a collection of operations)'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.16: Example pipeline (a collection of operations)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You will see that we want to pipe our values from one process to the next.
    This helps us to chain promises and can make our code very clean and very easy
    to maintain. We can rewrite the preceding code as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the rewritten code is much more readable, and anyone looking
    at this code will know exactly what is going to happen. When we chain promises
    in this way, we basically pass values from one process to another. By using this
    approach, we not only solve the problem of callback hell, but also make the code
    more testable as each of these helper functions is totally separate and they do
    not require anything more than the arguments passed to them. Not to mention that
    if there is any part of your application that wants to do a similar operation
    (for example, `optimizeImage`), you can reuse that part of the code easily. In
    the next exercise, we will go over how we can write complex functionality with
    multiple async operations using promise chaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 63: Advanced JavaScript Promises'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will write a simple program to run multiple async operations
    and chain their results together using promise chaining. Later, we will also use
    useful static methods from the `Promise` class to help us manage multiple promises
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise63](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise63).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `getProfile` and `getCart` functions that return a promise. `getProfile`
    should take the `id` string as input and resolve different results based on the
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another async function, `getSubscription`, which takes an ID and resolves
    `true` and `false` values for that ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, the function only takes a string ID as input. If we want to chain this
    in our promise chain, we need to make sure the promise feeding this function resolves
    into a single string value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `getFullRecord`, which returns a combined record for `id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the `getFullRecord` function, we want to call all the preceding functions
    and combine the record into the return shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the function we declared before, in `getFullRecord`, and return the combined
    result from `getProfile`, `getCart`, and `getSubscription`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This function also returns a promise. We can invoke the function and print
    out its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17: Calling the declared function in getFullRecord'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.17: Calling the declared function in `getFullRecord`'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But our code is very messy, and it didn't really utilize the promise chaining
    we mentioned earlier. To solve this, we need to make a modification to `getCart`
    and `getSubscription`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `getCart` function, which returns a new object, including every
    property of the `user` object and the `cart` items instead of just returning the
    `cart` items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `getSubscription` function, which takes the `user` object as an
    input and returns an object instead of a single value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `getFullRecord` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is much more readable than all the nesting we had before. We just
    reduced `getFullRecord` a lot with minimal changes to the two functions we had
    previously. When we call this function again, it should produce the exact same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18: Updated getFullRecord function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.18: Updated getFullRecord function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create the `getFullRecords` function, which we will use to call multiple records
    and combine them into an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `array.map` to generate a list of promises:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we utilized the `array.map` function to iterate through the array and
    return a new array. Because the array includes just the IDs, we can simply just
    pass the `getFullRecord` function in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `Promise.all` to combine the results of a list of promises:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`Promise.all` simply takes an array of promises and returns a promise that
    waits for all the promises to resolve. Once all the promises in the array are
    resolved, it will resolve with an array of the results from those promises. Because
    our objective is to return a list of full records, this does exactly what we want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test out `getFullRecords`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: Testing the getFullRecords function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.19: Testing the getFullRecords function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we implemented complex logic using multiple async functions
    and their promise returns. We also tried to chain them and modified some of our
    functions to make chaining easy. Lastly, we used both `array.map` and `Promise.all`
    to create multiple promises using arrays and wait for all of them to resolve.
    This helps us to manage multiple promises and track their results. Next, we will
    talk about error handling in promises.
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling in Promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we make requests to web servers or access files on disk, there is no guarantee
    that the operation we want to perform will be 100% successful. When it doesn't
    work the way we want, we will need to make sure that our application can handle
    these errors, so it doesn't quit unexpectedly or damage our data. When we were
    writing handlers for async functions before, we could simply get the error returned
    from the process in the error argument passed to our callback. When we are using
    promises, we can also get the error from the `catch` handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when we are handling errors, we are not only trying to prevent something
    bad from happening to us or our users; we also need to make sure that our errors
    are meaningful enough for us to use that information and prevent that error from
    reoccurring. Generally, if we want to handle errors in promises, we can just do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want to handle a certain type of error, we can call the `catch` function
    and pass it an error handler. But what if we are dealing with multiple promises
    at once? What if we are using promise chaining? When dealing with multiple promises,
    you might think we need to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are handling any type of error from the promise returned by the `aFunctionReturnsPromise`
    function. Inside the `then` handler for that promise, we are calling `anotherFunctionReturnsPromise`,
    and inside the `then` handler for that, we are handling the error from that promise.
    This doesn''t look too terrible because we are only using two nested promises,
    so chaining them is not strictly necessary, and we are handling each error separately.
    But usually, when you see people writing code like this, you will also see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'I have even seen production-grade code written like this. While this looks
    like a great idea to a lot of developers, it is not an ideal way to handle errors
    in promises. There are some use cases for this way of handling errors. One is
    if you are certain of the type of error you are going to get and you want to do
    custom handling for each of the different types. When you have code like this,
    it is very easy for you to have duplication in your log files because, as you
    can see from the preceding code, the error is logged twice: once in the catch
    handler in the nested promise, and once in the parent promise. To reduce the duplication
    of error handling, you can simply remove any handler in the nested promise, so
    the preceding code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You don't have to worry that the error in the nested promise is not handled
    – because we are returning the promise in the `then` handler, and we are passing
    the status over, not the value. So, when the nested promise encounters an error,
    it will eventually be caught by the `catch` handler in the parent error handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing we must keep in mind is that when we are using promises, the `then`
    handler is not called when there is an error. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you are creating a file processing function and after it is finished
    processing, you run your cleanup logic in the `then` handler. This creates an
    issue when we have errors because the cleanup process will never be called when
    this promise is rejected. This can cause a lot of issues. We can run out of disk
    space because temp files are not being removed. We can also risk memory leak if
    we don''t properly close connections. To solve this issue, some developers take
    the easy way and copy over the cleanup logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'While this solves our issue, it also creates a duplicated block, so eventually,
    when we want to change some logic in the cleanup process, we need to remember
    to make the change in both places. Luckily for us, the `Promise` class gives us
    a very useful handler we can set to make sure that the handler is always called
    regardless of the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are appending a new type of handler to our promise. The `.finally`
    handler will always be called when the promise is `settled`, regardless of whether
    it is resolved or rejected. This is a very useful handler we can set on our promises
    to make sure that we properly clean up connections or remove files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous exercise, we managed to use `Promise.all` to grab a list of
    results from a list of promises. In our example, all the promises eventually resolved,
    and we got a very clean array returned to us. How would we handle cases where
    we are unsure about the result of the promises? Consider the `getFullRecords`
    function in the last exercise; when we run the function, it executes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20: Executing the getFullRecords function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.20: Executing the getFullRecords function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The function executes all three operations at the same time and will resolve
    when they are resolved. Let''s modify the `getFullRecords` function to make it
    output an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the third ID we have provided doesn''t exist in our `getProfile`
    function, so it will be rejected. When we run this function, we will get an output
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21: Error when running the getProfile function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.21: Error when running the getProfile function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Promise.all` waits for all the promises in the array to settle and will return
    a rejected promise if one of the requests is rejected. Keep this in mind when
    you are dealing with multiple promises using `Promise.all`; if a promise request
    is rejected, make sure you include as much info on the error message as you can
    so that you can tell which operation was rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 64: Refactor the Bill Calculator Using Promises'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last exercise, we wrote bill calculator logic using callbacks. Suppose
    the company you work for has now upgraded their Node.js runtime and they require
    you to rewrite that part of the logic with promises. Open the `promises.js` file
    and you will see the updated `clientApi` rewritten using promises:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Promises.js is available at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise64](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise64).
  prefs: []
  type: TYPE_NORMAL
- en: You are given `clientApi`, which supports promises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to implement a feature that calculates the bill for a user and returns
    the result in this format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You need to implement a `calculateBill` function that takes an ID and calculates
    the gas bill for that user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to implement a new `calculateAll` function to calculate the bill of
    all the users from `getUsers`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will open the file that includes `clientApi` and do our work there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create the `calculate` function. This time, we will only pass
    `id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In `calculate`, we will call `getUsers` first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Because we want to calculate and return a promise, and `getUsers` returns a
    promise, we will simply return promise when we call `getUsers`. Here, we will
    run the same `find` method to find the user we are currently calculating. Then,
    if the user doesn't exist, we can just throw an error inside the `then` handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call `getUsage` inside the `then` handler of `getUsers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are returning `clientApi` because we want to chain our promise and
    want the innermost promise to surface and be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call `getRate` inside the `then` handler of `getUsage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is the last function we need to call. We will also use `return` here. Inside
    our `then` handler, we will have all the information we need. Here, we can just
    run our calculation and return the value directly. That value will be the resolved
    value for the promise we are returning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `calculateAll` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `getUsers` to get the list of our users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the result will be a list of the users in our system. Then, we will run
    `calculate` on each of them. Use `Promise.all` and a map array to call the `calculate`
    function on every user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We are using a map array to return a new array of promises. The array of promises
    will be the promise returned when we call our existing `calculate` function. When
    we feed that array to `Promise.all`, it will return a promise that will resolve
    into a list of results from the list of promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call `calculate` on one of our users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22: Calling calculate on one of our users'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.22: Calling calculate on one of our users'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Call the `calculateAll` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23: Calling the calculateAll function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.23: Calling the calculateAll function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the previous exercises and the activity, we created functions that calculate
    results from multiple async functions using callbacks and later rewrote those
    functions using promises. Now, you know how to refactor old callback-style code
    using promises. This is very useful when you are working on refactoring big projects
    that require you to start using promises while keeping the same functionality.
    In the next chapter, we will go over a new method we can adopt to handle async
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Async and Await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It has always been the dream of JavaScript developers to handle async functions
    without the need to write wrappers around them. Then, a new feature was introduced,
    and that changed everything we know about JavaScript async operations. Consider
    the code we used in the last exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It is simple enough because we used promise chaining, but it doesn''t really
    tell us anything more than that, and it appears we are just calling a bunch of
    functions. What if we could have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you look at the preceding code, it makes much more sense and it looks
    like we are just calling some non-async functions to grab the data and later returning
    combined data. This is what async and await can achieve. By using async and await,
    we can write our code like this while maintaining full control of our async operations.
    Consider a simple `async` function that returns a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a simple `async` function like the ones we used in the previous
    exercises and in the activity. Normally, if we wanted to call this function and
    get the value of the returned promise, we would need to execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24: Getting the value of the returned promise'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.24: Getting the value of the returned promise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is nothing new about this method; we are still calling the function to
    return a promise and later getting the resolved value via the `then` handler.
    If we want to use the new async and await feature, we first create a function
    that will run the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'All we did is add `async` before the `function` keyword. We do this to mark
    this function as an `async` function so that we can use `await` on the `sayHello`
    function inside the `printHello()` function without the need to use the `then`
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `async` function, we are calling our `sayHello` function, which returns
    a promise. Because we used the `await` keyword before, it will try to resolve
    that promise and feed the resolved value into the constant we declared as a message.
    By using this, we just made our `async` function look like a synchronous function.
    Later, we can call the function just like a normal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25: Calling the printHello function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.25: Calling the printHello function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 65: Async and Await Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will go over creating async functions and calling them
    inside other async functions. Using async and await can really help us when dealing
    with a large amount of async operations within a single function. We will write
    our first `async` function together and explore some of the things you need keep
    in mind when dealing with async and await in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise65](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise65).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `getConcertList` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the function and use `await`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code, we will get an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26: Calling the function using await'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.26: Calling the function using await'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The reason we will get this error is that we can only use the `await` keyword
    inside an `async` function. If we want to use it, we must wrap the statement in
    an `async` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the statement and wrap it in an `async` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27: Modifying the statement and wrapping it in an async function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.27: Modifying the statement and wrapping it in an async function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When we run this function, we will see the list printed out and everything has
    worked out. We can also treat the `async` function as a function that returns
    a promise, so if we want to run code after the operation is over, we can use the
    `then` handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `then()` function with a handler of the `async` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28: Calling the then function with a handler of the async function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.28: Calling the then function with a handler of the async function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, we know that the `async` function behaves just like a normal function that
    returns a promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `getPrice` function to retrieve the price of a concert:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `printList` to include the price from `getPrice`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we are simply trying to get all the prices using the `getPrice`
    function. In the last section, we mentioned how to use `Promise.all` to wrap an
    array of promises in a promise that will only resolve once every promise in the
    array is resolved. Because the `await` keyword can be used on any function that
    returns a promise and will resolve its value, we can use this to get a price array.
    When we run the preceding code, we will see that this function resolves into the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29: Modifying printList to include the price from getPrice'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.29: Modifying printList to include the price from getPrice'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This means that if we have a promise-returning function, we don't need to use
    the `then` handler anymore. In an `async` function, we can simply use the `await`
    keyword to get the resolved value. However, handling errors in `async` functions
    work a bit differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `buggyCode` function that returns a rejected promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `buggyCode` in `printList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30: Calling buggyCode in printList'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.30: Calling buggyCode in printList'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because `buggyCode` throws an error, this stops the execution of our function
    and, in the future, it might even terminate our process. To handle this type of
    error, we will need to catch it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a `catch` handler on `buggyCode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can handle the error of `buggyCode` just like a regular promise and pass
    it a `catch` handler. This way, the promise rejection will be marked as handled
    and will not return `UnhandledPromiseRejectionWarning`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.31: Using the catch handler on buggyCode'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.31: Using the catch handler on buggyCode'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is one way to handle promise rejection in `async` functions. There is also
    a more familiar way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify error handling using `try`…`catch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.32: Modifying error handling using try…catch'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.32: Modifying error handling using try…catch'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using `try`…`catch` is what many developers are familiar with when dealing with
    functions that might throw errors. To handle the error from our `buggyCode`, using
    a `try`…`catch` block will make the code much more readable and achieve the goal
    of async, that is, eliminating passing promise handlers. Next, we will talk about
    how to properly handle multiple promises and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Async Await Concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When dealing with multiple async operations in JavaScript, it''s crucial to
    know the order of the operations you want to run. The way you write this code
    can alter the behavior of your application a lot. Let''s look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple function that returns a promise that only resolves after
    `n` seconds has passed. To visualize concurrency, we declare the `runAsync` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this function, we will see that our program will wait 1 second
    and print out the first statement, and another one after 2 seconds. The total
    wait time will be 3 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.33: Function returning a promise that resolves after n seconds'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.33: Function returning a promise that resolves after n seconds'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'What if we want to run both `wait` functions together? Here, we can use `Promise.all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.34: Running both wait functions using Promise.all'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.34: Running both wait functions using Promise.all'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'What we did here is we removed `await` and put the two promises returned by
    the `wait` function in the array, and then fed it to `Promise.all`. When we remove
    the `await` keyword and use `Promise.all`, we can make sure that the code is not
    out of control and will continue to execute. What if you are dealing with promises
    in a loop, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This offers no concurrency. Imagine that, instead of waiting, we are getting
    user information from a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, our use case is fetching multiple user profiles from the database. While
    the preceding code will work, it is not the most performant implementation. Just
    as we have mentioned previously, this code will wait until the last request has
    finished before fetching the next one. To optimize this code, we can simply use
    `array.map` and `Promise.all` together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This way, we aren't waiting for each operation to finish; we are only waiting
    for the wrapper promise to be resolved. In map array, we are only generating the
    promises and, once they are created, it will execute our operation. Compared to
    the `for` loop method, we don't need to wait for the previous promise to settle
    before executing the next promise. We will talk about their differences in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use await
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous examples, we went over using the `await` keyword inside our
    `async` functions. But when should we use `await`, and when should we avoid it?
    In the last section, we discussed avoiding using `await` when we want to enable
    concurrency and make sure operations are not waiting for one another. Consider
    the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `operation2` function will only be executed once `operation1`
    is complete. This is useful when you have dependencies and `result2` depends on
    something from `result1`, as shown in the example. If they don''t have dependencies
    on one another, you could leverage `Promise.all` to ensure concurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the `await` keyword, the code simply assigns the promise returned from
    both operations in the constant we declared. This ensures that `operations2` is
    fired right after `operation1` and that there is no `wait`. Another point that
    we need to be careful of is error handling. Consider the `buggyCode` we used in
    the last exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This function simply returns a promise that is rejected. When using it, we
    should use `catch` to handle the error from the promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, we will see that our error is handled beautifully, and
    the error message is logged. Here, we used `await` when we ran the `buggyCode`
    function, but when we remove the `await` keyword, here is what we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.35: Running the buggyCode function after removing the await keyword'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.35: Running the buggyCode function after removing the await keyword'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will see that we have an unhandled promise rejection; it just appeared as
    our `try`…`catch` didn't do anything. The reason for this is that without the
    `await` keyword, JavaScript will not try to wait for the promise to resolve; therefore,
    it has no idea that an error is going to be thrown in the future. What this `try`…`catch`
    block will catch is if there is an error thrown when executing the function. This
    is something we need to keep in mind when writing code using `async` and `await`.
    In the next exercise, we will write a complex function calling multiple `async`
    functions and that is able to recover from an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 66: Complex Async Implementation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will build a very complex `async` function and use everything
    we have learned previously to make sure the function is high-performance and resilient
    to errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise66](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise66).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `getPlaylists` function that returns an array of IDs given a playlist
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This function will return an array of song IDs as a playlist. If not found,
    it will simply return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `getSongUrl` function that returns a song URL given a number `id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `playSong` async function that takes the ID of a song and generates
    two outputs – one displaying the song that is being played, and another that informs
    the user that the song is finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `playPlaylist` function that takes a playlist ID and calls `playSong`
    on each song in the playlist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple implementation that doesn't perform error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `playPlaylist` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.36: Running the playPlaylist function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.36: Running the playPlaylist function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We get a very interesting output; it is playing all the songs at the same time.
    Also, it doesn't handle errors gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call `playPlaylist` with no argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.37: Calling playPlaylist with no argument'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.37: Calling playPlaylist with no argument'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The reason we are getting this error is that we are not handling errors when
    `getPlaylist` throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `playPlaylist` to handle errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We aren''t doing anything special here; we simply added a `try…catch` block
    around the `getPlaylist` so that when the promise does get rejected, it will be
    properly handled. After the update, when we run our code again, we will receive
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.38: Modifying playPlaylist for error handling'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.38: Modifying `playPlaylist` for error handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We see that the error is properly handled, but we still get the `finished` message
    at the end. This is something we do not want because when an error has occurred,
    we do not want the promise chain to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `playPlaylist` function and the caller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: When writing `async` code, it is a good idea to keep the promise handling in
    the parent and let the error bubble up. This way, we can have only one error handler
    for this operation and be able to handle multiple errors at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to call a corrupted playlist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.39: Calling a corrupted playlist'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.39: Calling a corrupted playlist'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This code runs fine, and the error is handled, but it is still playing everything
    together. We wanted to show the `finished` message because the `song does not
    exist` error is a minor one and we want to suppress it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `playPlaylist` to play songs sequentially:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.40: Modified playPlaylist to play songs sequentially'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.40: Modifying `playPlaylist` to play songs sequentially'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the modification, we removed `Promise.all` and replaced it with a `for` loop
    with `await` for each song. This makes sure that we wait for each song to complete
    before we go on to the next song.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `playSong` to suppress the `not found` error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.41: Modified playSong to suppress the not found error'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.41: Modifying `playSong` to suppress the not found error'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What we did here is wrapped our logic with a `try`…`catch` block. This allows
    us to suppress any error generated by the code. When `getSongUrl` does throw an
    error, it will not be bubbled up to the parent; it will be caught by the `catch`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we implemented a playlist player using `async` and `await`,
    and used our knowledge about `Promise.all` and `async` concurrency to optimize
    our playlist player to only play one song at a time. This enabled us to have a
    deeper understanding of async and await and implement our own `async` function
    in the future. In the next section, we will go over how we can migrate our existing
    promise- or callback-based code to async and await.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12: Refactor the Bill Calculator Using Async and Await'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your company has updated its Node.js runtime again. In this activity, we will
    refactor the bill calculator we created previously using async and await:'
  prefs: []
  type: TYPE_NORMAL
- en: You are given `clientApi`, implemented using promises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to update `calculate()` to an `async` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to update `calculateAll()` to an `async` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateAll()` needs to get all the results at once using `Promise.all`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the `async.js` file to implement the `calculate` and `calculateAll` function
    using `async` and `await`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson08/Activity12/Activity12.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson08/Activity12/Activity12.js).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `calculate` function that takes an ID as input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `calculate`, use `await` to call `clientApi.getUsers()` to retrieve all
    of the users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `array.find()` to find `currentUser` using the `id` argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `await` to call `getUsage()` to get the usage for that user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `await` to call `getRate` to get the rate for at user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a new object with `id`, `address`, and the total due amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the `calculateAll` function as an `async` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `await` to call `getUsers` to retrieve all of the users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an array map to create a list of promises and use `Promise.all` to wrap
    them. Then, use await on the promise returned by `Promise.all` and return its
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `calculate` on one of the users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `calculateAll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.42: Calling the calculateAll function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/C14587_08_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.42: Calling the calculateAll function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 615.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating Callback- and Promise-Based Code to Async and Await
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working on large-sized projects, it's very common to have to refactor existing
    code using async and await. When we are doing these refactors, we need to keep
    in mind that we should keep the same functionality and type of error handling.
    In this section, we will learn how we can migrate existing callback and promise-based
    code to async and await.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating Callback-Based Code to Async and Await
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we are migrating callback-based code, we need to rewrite the function
    and make sure it returns a promise instead of taking a callback. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code takes a parameter and calls a `request` module, which we
    do not have access to modify, and returns a list of the user IDs. Once it is finished,
    if there is an error, it is simply returned through the callback. When we want
    to refactor this code using async and await, we can first make sure it returns
    a promise. When we do that, we also want to remove the `callback` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to copy our logic in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we need to make modifications. We need to remove all the references to
    `callback` and change them to use `reject` and `resolve`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see here that we are still using the callback style when calling `request`.
    That is because we have no control over that external library. What we can do
    is make sure that each time we call it, we return a promise. Now, we have fully
    converted our legacy code to modern standards. You can now use it in the `async`
    function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Usually, code is much more difficult to refactor. It is recommended to start
    from the most basic level and work your way up as you refactor. When you are dealing
    with nested callbacks, make sure you use `await` to ensure you preserve dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we went over how we can use promises and async and await to
    better manage our async operations in our code. We also talked about the various
    ways in which we can refactor our existing callback code to async and await. Using
    async and await in our applications will not only help to make our code more readable,
    but will also help us to do future testing on our implementation. In the next
    chapter, we will go over how we can use event-based programming in our applications.
  prefs: []
  type: TYPE_NORMAL
