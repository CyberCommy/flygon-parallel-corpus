- en: Using Templates for Generic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn advanced template programming techniques. These
    techniques include the ability to change the implementation of a template class
    based on the type that is provided, how to work different types of arguments including
    how to properly forward them, how to optimize your code both at runtime and compile
    time, and how to use some new features added to C++17\. This is important because
    it provides a better understanding of how template programming works as well as
    how to ensure your templates are performing the way you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Too often, we write template code assuming it is executing one way when, in
    fact, it is executing in another, either generating unreliable code, code with
    unexpected performance penalties, or both. This chapter will explain how to avoid
    these issues and provide the foundation for writing proper generic programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SFINAE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning perfect forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `if constexpr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tuples to work with parameter packs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using traits to vary the behavior of template implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to implement `template<auto>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with explicit template declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SFINAE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use **Substitution Failure Is Not An Error** (**SFINAE**).
    This recipe is important because, often, we create templates without ensuring
    the types passed to a template are what we expect. This can lead to unexpected
    behavior, suboptimal performance, and even buggy, unreliable code.
  prefs: []
  type: TYPE_NORMAL
- en: SFINAE allows us to be explicit about what types we are expecting in our template.
    It also provides us with a means to change the behavior of our templates based
    on the types we are provided. The problem with SFINAE for some is that this concept
    is difficult to understand. Our goal in this recipe is to demystify SFINAE and
    show how you can use this in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to incorporate SFINAE in your own code. To
    start, we must first understand what SFINAE is and how the standard library uses
    it to implement `type` traits. Without knowing how `type` traits are implemented,
    it can be difficult to understand how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, the most important thing to understand with SFINAE is what its name
    says, which is that a *substitution failure is not an error*. What this means
    is that when a template type is being substituted, if a failure occurs, the compiler
    will *not* generate an error as a result. For example, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for each of these are depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have created two versions of the `foo()` function. This
    first version takes a `T` type that has a `type` alias that we use to create the
    function's parameter. The second version just takes the `T` type itself. We then
    use both versions of the `foo()` function, one with an integer and the other with
    a struct that defines the `type` alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'The takeaway from the preceding example is that when we call the `foo<int>()`
    version of the `foo()` function, the compiler doesn''t generate an error when
    it attempts to match the `int` type with the version of the `foo()` function that
    takes a type with the `type` alias. This is what SFINAE is. All it says is that
    when the compiler attempts to take a given type and match it to a template, if
    a failure occurs, the compiler will not generate an error. The only time an error
    would occur is if the compiler cannot find a suitable substitution. For example,
    what happens if we comment out the second version of `foo()`? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84d28ad2-c0bd-49a0-879d-ad42f5add912.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding error output, the compiler is even saying
    that the error is a substitution error. The template that we provide is not a
    valid candidate based on the type that was provided.
  prefs: []
  type: TYPE_NORMAL
- en: The other important takeaway from this example is that the compiler was able
    to pick between the two different versions of our `foo()` function based on the
    type that was provided. We can use this to our advantage. Specifically, this gives
    us the power to do different things based on the type that is provided. All we
    need is a means to write our `foo()` function so that we can enable/disable different
    versions of our templates based on the types that we are provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where `std::enable_if` comes into play. `std::enable_if` takes the
    idea of SFINAE to the next step, allowing us to define a type if its parameter
    is true. Otherwise, it will generate a substitution error, purposely forcing the
    compiler to pick a different version of the template. `std::enable_if` is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This first defines a struct that takes `bool B` and a `T` type that defaults
    to `void`. It then defines a specialization of this `struct` type when `bool`
    is true. Specifically, when the `bool` value is `true`, the type that is provided
    is returned, which, as we stated before, defaults to `void`. To see how this is
    used, let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/395bc1d6-02a2-4609-be80-8855f53d6acc.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we create a function called `is_int()` that always returns
    `false`. We then create a template specialization of this function for `int` that
    returns `true`. Next, we create a function that takes any type, but we add `std::enable_if_t`
    (the added `_t` part is a shorthand that was added to C++17 for `::type`) to the
    template definition that uses our `is_int()` function. If the `T` type that is
    provided is `int`, our `is_int()` function will return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::enable_if` does nothing by default. If it is `true`, however, it returns
    a `type` alias, which, in the preceding example, is the `int` type that we are
    passing as the second parameter of `std::enable_if`. What this is saying is that
    if `std::enable_if` is `true`, it will return an `int` type. We then set this
    `int` type to `0`, which is a valid thing to do. This doesn''t generate a failure;
    our template function becomes a valid substitution and, therefore, is used. In
    summary, if `T` is an `int` type, `std::enable_if` turns into an `int` type itself
    that we then set to `0`, which compiles without an issue. If our `T` type is not `int`,
    `std::enable_if` turns into nothing. Attempting to set nothing to `0` results
    in a compilation error, but since this is SFINAE, the compiler error becomes nothing
    more than a substitution error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the error case. If we set `42` to `42.0`, which is a `double`,
    not `int`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eadc479-fa00-4c25-9a68-b82cb13ee914.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding error, the compiler is saying that there is
    no type named `type` in `enable_if`. If you look at the definition of `std::enable_if`,
    this is expected because `std::enable_if` doesn't do anything if it is false.
    It only creates a type named `type` if it is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how this works, let''s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb55d047-89b4-4e40-815a-273456762831.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we use `std::is_integral_v`, which does the same thing
    as our `is_int()` function, with the difference being that it is provided by the
    standard library and can handle CV types. In fact, the standard library has a
    massive list of different versions of these functions including different types,
    inheritance properties, CV properties, and so on. If you need to check for a `type`
    property of any kind, chances are that the standard library has an `std:is_xxx`
    function that you can use.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is nearly identical to our previous one with the difference
    being that we do not return `int` in our `std::enable_if` method. Instead, we
    use `* = nullptr`. This works because `std::enable_if` returns `void` by default.
    The `*` character turns this void into a void pointer, which we then set to `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we show another twist on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ca6a189-e687-45a2-a8cd-422d3e2f274e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, `void` for our function is created by `std::enable_if`. If
    `T` is not an integer, `void` is not returned and we see this error (instead of
    the code compiling and allowing us to execute it in the first place):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7ec86d0-edec-409d-8dd5-76b3abfa3978.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In summary, `std::enable_if` will create a type named `type`, which is based
    on the type that you provide it. By default, this is `void` but you can pass in
    any type that you want. Not only can this functionality be used to enforce a type
    for our templates, but it can also be used to define different functions based
    on the type that we are provided, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c12f216-9fc9-4b34-9868-9ccf45ae4fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Like our first example in this recipe, we have created two different versions
    of the same function. SFINAE allows the compiler to pick the most suitable version
    based on the type that was provided.
  prefs: []
  type: TYPE_NORMAL
- en: Learning perfect forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use perfect forwarding. This recipe is
    important because, often, when writing templates, we pass template parameters
    to other functions. If we do not use perfect forwarding, we can inadvertently
    convert r-value references into l-value references, resulting in a potential copy
    taking place instead of a move, which, in some cases, could be suboptimal. Perfect
    forwarding also provides the compiler with hints that could be leveraged to improve
    function inlining and unwrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to use perfect forwarding to ensure that,
    when we pass parameters in our templates (that is, forward our parameters), we
    do so in a way that doesn''t erase r-valueness. To better understand the issue,
    let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb4f4cb0-e924-4b6e-af1a-617c8e3183b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we have two different versions of a `foo()` function:
    one that takes an l-value reference and one that takes an r-value reference. We
    then call `foo()` from a template function. This template function takes a forwarding
    reference (also called a universal reference), which is an r-value reference paired
    with either `auto` or a template function. Finally, from our main function, we
    call our template to see which `foo()` function is called. The first time we call
    our template, we pass in an l-value. Since we are given an l-value, the universal
    reference becomes an l-value, and the l-value version of our `foo()` function
    is called. The problem is, the second time we call our template function, we give
    it an r-value, but it calls the l-value version of our `foo()` function, even
    though it was given an r-value.'
  prefs: []
  type: TYPE_NORMAL
- en: The common mistake here is that even though the template function takes a universal
    reference and we have a version of the `foo()` function that also takes an r-value,
    we assume this `foo()` function would be called. Scott Meyers does a great job
    explaining this in many of his lectures on universal references. The problem is
    that the moment you use a universal reference, it becomes an l-value. The very
    act of passing the `names` parameter, which means it must be an l-value. It forces
    the compiler to convert to an l-value because it sees you using it, even though
    all you are doing is passing the parameter. It should be noted that our example
    doesn't compile with optimizations as the compiler is free to optimize the l-value
    out if it can safely determine that the variable is not used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this issue, we need to tell the compiler that we wish to forward
    the parameter. Normally, we would use `std::move()` for this. The problem is,
    if we were originally given an l-value, we cannot use `std::move()` as that would
    convert an l-value into an r-value. This is why the standard library has `std::forward()`,
    which is implemented using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'All `std::forward()` does is cast the parameter back to its original reference
    type. This tells the compiler explicitly to treat the parameter as an r-value
    if it was originally an r-value, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c64d9b68-b5d8-4ce2-ba02-17195ee8906d.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example is identical to the first example with the only difference
    being that we pass the parameter in our template function using `std::forward()`.
    This time, when we call our template function with an r-value, it calls the r-value
    version of our `foo()` function. This is called **perfect forwarding**. It ensures
    that we maintain CV properties and l-/r-value properties when passing parameters.
    It should be noted that perfect forwarding only works when using template functions
    or `auto`. What this means is that perfect forwarding is usually only useful when
    writing wrappers. A good example of a standard library wrapper is `std::make_unique()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One issue with a wrapper such as `std::make_unique()` is that you might not
    know how many parameters need to be passed. That is, you might end up needing
    variadic template arguments in your wrapper. Perfect forwarding supports this
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a2956d6-ac8c-4113-b411-eb131555a556.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example works because the variadic template arguments being passed
    to our `foo()` function are replaced by a comma-separated list of perfect forwards.
  prefs: []
  type: TYPE_NORMAL
- en: Using if constexpr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use a new feature in C++17 called `constexpr
    if`. This recipe is important because it will teach you how to create `if` statements
    that are evaluated at runtime. Specifically, what this means is that the branch
    logic is picked at compile time and not at runtime. This allows you to change
    the behavior of a function at compile time without sacrificing performance, something
    that, in the past, could only be done with macros, which is not useful in template
    programming, as we will show.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we wish to change the behavior of our programs but the code that
    we are creating is always constant, meaning the compiler is capable of determining
    the value of the branch itself, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a common `if` statement used in a lot of code, including the standard
    library. If debugging is enabled, this code evaluates to `true`. We use this by
    adding debug statements to our code, which can be turned off. The compiler is
    smart enough to see that `NDEBUG` is `true` or `false` and will either add the
    code or remove the code completely. In other words, the compiler can make a simple
    optimization and reduce the size of the code as well as remove an unneeded branch
    as it knows the value of this `if` statement will never change at runtime. The
    problem is, this trick relies on the fact that the compiler is smart. The removal
    of the logic is implicitly trusted, which often leads to assumptions about what
    the compiler is doing. C++17 added a `constexpr if` statement that allows us to
    be explicit instead. It allows us to tell the compiler: that the statement I am
    providing should be evaluated at compile time, not at runtime. What makes this
    truly powerful is that we get compile-time errors when this assumption is not
    true, meaning the optimizations we were implicitly trusting the compiler to perform,
    we can now verify at compile time, and if the assumptions are false, we are told
    so that we can fix the issue, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf8bb6b4-07e7-4b3e-a97e-3a558cfc3533.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we create `constexpr` and evaluate it at compile
    time instead of runtime. If we change `constexpr` to an actual variable, `constexpr
    if` will result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9474112b-7528-4649-b754-1e6702247c6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then use this in our template functions to change the behavior of our
    template functions based on the type that we are given, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `std::is_floating_point_v` type trait to
    determine whether the type that we were provided is a floating point or not. If
    the type is not a floating point, this will return `constexpr false`, which the
    compiler can optimize out. Since we are using `constexpr if`, we can ensure that
    our `if` statement is actually `constexpr` and not a runtime conditional.
  prefs: []
  type: TYPE_NORMAL
- en: Using tuples to work with parameter packs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to work with variadic parameter lists using `std::tuple`.
    This is important because a variadic parameter list is meant to be used in wrapper
    functions where the wrapper doesn't know anything about the arguments being passed
    to it but instead will forward these arguments to something that does. There are,
    however, use cases where you will care about the arguments being passed, and you
    must have a way of working with these arguments. This recipe will demonstrate
    how to do that including how to deal with any number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variadic templates provide the programmer with the ability to define a template
    function without needing to define all of the arguments. These are used heavily
    in wrapper functions as they prevent the wrapper from having to have any knowledge
    of the function''s arguments, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we have created a `foo` function that can
    take any number of arguments. In this example, we use the universal reference
    notation, `Args &&...args`, which ensures the CV qualifiers and l-/r-valueness
    is preserved, meaning we can then use `std::forward()` to pass the variable arguments
    list to any other function with as little loss in performance as possible. Functions
    such as `std::make_unique()` make heavy use of variadic parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, however, you might want to access one of the arguments in the list
    that is provided. To do this, we can use `std::tuple`. This is a data structure
    that takes a variable number of arguments and provides an `std::get()` function
    to get any data from `std::tuple`, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3147713-d2d1-4d27-b867-d95407e67851.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we create `std::tuple` and then we output the contents
    of `std::tuple` to `stdout` using the `std:get()` function. If you attempt to
    access data that is out of range, the compiler will know at compile time, and
    give you an error that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0d35dc0-05d0-44ae-9202-1dbc5da6503c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `std::tuple`, we can access the data from a variadic parameter list as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fac54cfd-01a0-4fc8-a4e1-80bb81c1fd5f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we create a function with a variadic parameter list.
    We then pass this list using `std::forward()` to preserve the l-/r-valueness to `std::tuple`.
    Finally, we use `std::tuple` to access the arguments. If we didn't use `std::forward()`,
    we would end up with l-value versions of the data passed to `std::tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The obvious problem with the preceding examples is that we have hardcoded the
    `0` and `1` indexes into `std::tuple`. Variadic parameters are not a runtime,
    dynamic array of parameters. Instead, they are a way of saying *I don''t care
    about the parameters I have been given*, which is why they are normally used by
    wrappers. A wrapper is wrapping something that does care about the parameters.
    In the case of `std::make_unique()`, the function is creating `std::unique_ptr`.
    To do this, `std::make_unique()` will allocate `std::unique_ptr` for you, using
    the variadic parameter list to initialize the newly allocated type and then provide
    the pointer to this type to `std::unique_ptr` for you, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The wrapper doesn't care about the arguments being passed. The constructor for
    `T` does. If you attempt to access the variadic arguments, you are saying *I do
    care about the arguments*, in which case, if you care, you must have some idea
    of the layout of the parameters being passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some tricks that allow you to work with an unknown number of arguments,
    however. The biggest problem with attempting to do this is the library facilities
    for working with variadic parameters are best used during runtime, which doesn''t
    help in most cases, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e437b68-faa5-4a2b-a2e5-1353d8935542.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we attempt to get the total size of the number of
    arguments in the variadic parameter list. We can do this either using the variadic
    version of the `sizeof()` function or we can use the `std::tuple_size` trait.
    The problem is this doesn't help us during compile time as we cannot loop through
    the parameters using this size information (as there is no `for` loop for compile-time
    logic).
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, one trick that we can use is something called compile-time
    recursion. This trick uses templates to create a recursive template function that
    will loop through all of the arguments in a variadic parameter list. Check out
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We start with a template function that performs all of the magic. This first
    template parameter is `I`, which is an integer that starts as `0`. The next is
    a variadic template parameter and the last is a function type. Our template function
    takes `std::tuple`, which we wish to iterate over (in this case, we show a constant
    version, but we could overload this to provide a non-constant version as well),
    and a function that we wish to call for each element in `std::tuple`. In other
    words, this function will loop over each element in `std::tuple` and call the
    provided function with each element iterated over, just like `for_each()`, which we
    are used to using at runtime in other languages or C++ libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this function, we check to see whether we have reached the total size
    of the tuple. If we have not, we get the element in the tuple for the current
    value of `I`, pass it to the provided function, and then call our `for_each()`
    function again with `I++`. To use this `for_each()` function, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have been given a variadic parameter list and we wish to iterate over
    this list and output each argument to `stdout`. To do this, we create `std::tuple`
    as we have previously, but this time, we pass `std::tuple` to our `for_each()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6d45daa-3d12-43cd-b947-93a9aa3990f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like we did in the previous examples, we call our `foo` function with some
    text that we wish to output to `stdout`, hence demonstrating how to work with
    variadic function parameters using `std:tuple`, even if we don't know the total
    number of arguments we will be given.
  prefs: []
  type: TYPE_NORMAL
- en: Using type traits to overload functions and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One issue that C++ had to deal with when C++11 was created was how to handle
    resizing `std::vector`, which is capable of taking any type, including types that
    can throw from `std::move()`. When resizing, new memory is created and the elements
    from the old vector are moved to the new vector. This works great because, if
    `std::move()` cannot throw, the resize can safely be performed as once the resizing
    function starts to move elements from one array to the other, no errors can occur.
  prefs: []
  type: TYPE_NORMAL
- en: If `std::move()` can throw, however, it is possible that part of the way through
    the loop, an error could occur. The `resize()` function, however, would have no
    way to put the old memory back to normal as attempting to move to the old memory
    could also throw an exception. In this case, `resize()` performs a copy instead
    of a move. A copy ensures that the old memory has a valid copy of each object;
    so, if an exception is thrown, the original array is left intact and the exception
    can be thrown as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how this is done by changing the behavior of
    a template class using traits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ added a function called `std::move_if_noexcept()`. This function will cast
    as an r-value if the move constructor/assignment operator cannot throw, and will
    cast as an l-value otherwise. For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To try this, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a class that has a move/copy constructor that cannot
    throw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will provide a class that has a move/copy constructor that can throw.
    Finally, let''s use `std::move_if_noexcept()` to see whether a move or a copy
    occurs when attempting to move an instance of each of these preceding classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0308a282-75f7-42fd-82e6-4debaf2bd0d2.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, in one case, the move constructor is called
    and in the other case, the copy constructor is called based on whether or not
    the type can throw an exception when performing a move.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a simple mock vector with a resize function to demonstrate
    how we can change the behavior of our `template` class using traits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our mock vector has an internal buffer and a size. When the vector is created,
    we allocate the internal buffer using the given size. We then provide a `resize()`
    function that can be used to resize the internal buffer given a new size. The
    first thing we do is create our new internal buffer, and then we loop through
    each element and the element from one buffer to the other. If `T` cannot throw,
    no exception will fire during the execution of the loop, in which case, the new
    buffer will be valid. If `T` can throw, a copy will occur instead. If an exception
    fires, the old buffer has not yet been replaced with the new one. Instead, the
    new buffer is deleted along with all of the elements that were copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this, let''s create a class that can throw in the move constructor/assignment
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add a class that cannot throw from the move constructor/assignment
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will create a vector using both of these classes and attempt to
    resize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9bee1c2-cc4a-4a6b-8b40-d2f08e9c28b8.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding example, when we attempt to resize the class, a move
    is performed when a move cannot throw, and a copy is performed otherwise. In other
    words, the behavior of the class changes depending on the traits of the `T` type.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to implement template<auto>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ has had the ability to create templates for a long time, which allows the
    programmer to create generic implementations of classes and functions, given a
    type. You can also, however, provide non-type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In C++17, you can now use `auto` to provide for generic, non-type template arguments.
    In this recipe, we will explore how to use this feature. This is important because
    it allows you to create more generic templates in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before C++17, you could provide non-type template arguments in a template,
    but you had to state the variable type in the definition, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5ae3433-362c-4d0d-a865-298472d67d5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we create a template argument variable of the `int` type and
    output the value of this variable to `stdout`. In C++17, we can now do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dee00755-5e4b-4fe9-8067-fe5306327929.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding, instead of having to state `int`, we can now state
    `auto`. This allows us to create a single function that can take more than one
    non-type template parameter. We can also use type traits to establish which non-type
    parameters are allowed, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08ad857b-3e01-41e9-885d-ceea78bc65f1.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, our template non-type parameter can only be an integer
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Working with explicit template declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explore how to speed up the compilation of your template
    classes by creating an explicit template declaration. This is important because
    templates require the compiler to create instances of your classes as needed.
    In certain cases, explicit template declaration might provide the programmer with
    a means to speed up compilation by caching the template types that are most likely
    to be used, preventing the need to include the entire definition of a template.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to try this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time the compiler sees the use of a template class with a given type,
    it creates a version of that type implicitly. This, however, can happen multiple
    times, reducing the speed of the compiler. If, however, the types that are expected
    to be used are known upfront, this issue can be solved using explicit template
    specialization. Take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we created a simple structure that outputs to `stdout` during construction.
    Normally, this class would be created by the compiler once the first specialization
    of the class is seen. We can, however, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to a class prototype, and it explicitly creates the specializations
    that we expect to use. These must be stated before they are used in code (which
    means they are usually stated after the definition of the template); however,
    once they are stated, they can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdc10992-381a-45a6-80a6-aff500c8753f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding example, we can create instances of our template
    as normal, but, in this case, we can speed up the compiler in scenarios where
    this class is used a lot. This is because, in the source code, we do not need
    to include the implementation of the template. To demonstrate this, let''s look
    at another, more complicated example. In a header file (called `recipe07.h`),
    we will create our template using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have a `template` class with no implementation for the provided
    functions. We will then provide the implementation of this template using the
    following in its own source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, we added an explicit template declaration.
    This ensures that we generate the implementations for the class that we expect.
    The compiler will create the instances for the class that we expect explicitly,
    just like any other source that we would normally write. The difference is, we
    can explicitly define this class for whatever types we want. Finally, we will
    call this code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30b50ca-8f48-4791-80c2-83b5886b15f3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we can call our class the same way we would if the class were
    defined with explicit types instead of a template class using a normal header
    file that is small and doesn't have the full implementation, allowing the compiler
    to speed up.
  prefs: []
  type: TYPE_NORMAL
