- en: Building the 5.x Linux Kernel from Source - Part 2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter continues where the previous chapter left off. In the previous
    chapter, in the *Steps to build the kernel from source *section*,* we covered
    the first three steps of building our kernel. There, you learned how to download
    and extract the kernel source tree or even `git clone` one (*steps 1* and *2*).
    We then proceeded to understand the kernel source tree layout, and, very importantly,
    the various approaches to correctly arrive at a starting point to configure the
    kernel (*step 3*). We even added a custom menu item to the kernel config menu.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we continue our quest to build the kernel, by, well, covering
    the remaining four steps to actually build it. First, of course, we build it (*step
    4*). You will then see how to properly install the kernel modules that get generated
    as part of the build (*step 5*). Next, we run a simple command that sets up the
    GRUB bootloader and generates the `initramfs` (or `initrd`) image (*step 6*).
    The motivation for using an `initramfs` image and how it's used are discussed
    as well. Some details on configuring the GRUB bootloader (for x86) are then covered
    (*step 7*).
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, we'll boot the system with our new kernel image and
    verify that it's built as expected. We'll then finish off by learning how to *cross-compile*
    a Linux kernel for a foreign architecture (that is, ARM, the board in question
    being the well-known Raspberry Pi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly, these are the areas covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – building the kernel image and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 5 – installing the kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 6 – generating the initramfs image and bootloader setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the initramfs framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 7 – customizing the GRUB bootloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying our new kernel's configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel build for the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous tips on the kernel build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, I assume that you have downloaded, extracted (if required),
    and configured the kernel, thus having a `.config` file ready. If you haven't
    already, please refer to the previous chapter for the details on how exactly this
    is done. We can now proceed to build it.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – building the kernel image and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing the build from the end user point of view is actually quite simple.
    In its simplest form, just ensure you're in the root of the configured kernel
    source tree and type `make`. That's it – the kernel image and any kernel modules
    (and, on an embedded system, possibly a **Device Tree Blob** (**DTB**) binary)
    will get built. Grab a coffee! The first time around, it could take a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are various `Makefile` targets we can pass to `make`. A quick
    `make help` command issued on the command line reveals quite a bit. Remember,
    we used this earlier, in fact, to see all possible configuration targets. Here,
    we use it to see what gets built by default with the `all` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so performing `make all` will get us the preceding three targets, the
    ones prefixed with `*`; what do they mean?
  prefs: []
  type: TYPE_NORMAL
- en: '`vmlinux` actually matches the name of the uncompressed kernel image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `modules` target implies that all kernel config options marked as `m` (for
    module) will be built as kernel modules (`.ko` files) within the kernel source
    tree (details on what exactly a kernel module is and how to program one are the
    subject matter of the following two chapters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bzImage` is architecture-specific. On an x86[-64] system, this is the name
    of the compressed kernel image – the one the bootloader will actually load into
    RAM, uncompress in memory, and boot into; in effect, the kernel image file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, an FAQ: if `bzImage` is the actual kernel that we use to boot and initialize
    the system, then what''s `vmlinux` for? Notice that `vmlinux` is the uncompressed
    kernel image. It can be large (even very large, in the presence of kernel symbols
    generated during a debug build). While we never boot via `vmlinux`, it''s nevertheless
    important. Do keep it around for kernel debugging purposes (which are unfortunately
    beyond the scope of this book).'
  prefs: []
  type: TYPE_NORMAL
- en: With the kbuild system, just running a `make` command equates to `make all`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel code base is enormous. Current estimates are in the region of 20
    million **source lines of code** (**SLOC**), thus, building the kernel is indeed
    *a very memory- and CPU-intensive job.* Indeed, some folks use the kernel build
    as a stress test! The modern `make(1)` utility is powerful and multi-process capable.
    We can request it to spawn multiple processes to handle different (unrelated)
    parts of the build in parallel, leading to higher throughput and thus shorter
    build times. The relevant option is `-j''n''`, where `n` is the upper limit on
    the number of tasks to spawn and run in parallel. A heuristic (rule of thumb)
    used to determine this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `factor` is 2 (or 1.5 on very high-end systems with hundreds of CPU cores).
    Also, technically, we require the cores to be internally "threaded" or using **Simultaneous
    Multi-Threading** (**SMT**) – what Intel calls *Hyper-Threading* – for this heuristic
    to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: More details on parallelized `make` and how it works can be found in the man
    page of `make(1)` (invoked with `man 1 make`) in the `PARALLEL MAKE AND THE JOBSERVER` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another FAQ: how many CPU cores *are* there on your system? There are several
    ways to determine this, an easy one being to use the `nproc(1)` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick word regarding `nproc(1)` and related utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Performing `strace(1)` on `nproc(1)` reveals that it works by essentially
    using the `sched_getaffinity(2)` system call. We shall mention more on this and
    related system calls in [Chapter 9](5391e3c1-30ad-4c75-a106-301259064881.xhtml),
    *The CPU Scheduler – Part 1*, and [Chapter 10](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml),
    *The CPU Scheduler – Part 2*, on CPU scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: b) FYI, the `lscpu(1)` utility yields the number of cores as well as additional
    useful CPU info. For example, it shows whether it's running on a **Virtual Machine**
    (**VM**) (as does the `virt-what` script). Try it out on your Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, our guest VM has been configured with two CPU cores, so let's keep
    `n=2*2=4`. So, off we go and build the kernel. The following output is from our
    trusty x86_64 Ubuntu 18.04 LTS guest system configured to have 2 GB of RAM and
    two CPU cores.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the kernel must first be *configured. *For details, refer to [Chapter
    2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building the 5.x Linux Kernel
    from Source – Part 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, when you begin, it''s entirely possible that the kernel build emits
    a warning, although non-fatal in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to address this, we break off the build with *Ctrl* + *C*, then follow
    the output''s advice and install the `libelf-dev` package. On our Ubuntu box,
    `sudo apt install libelf-dev` is sufficient. If you followed the detailed setup
    in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel Workspace
    Setup*, this will not happen. Retry, and it now works! To give you a feel of this,
    we''ve show the following tiny snippets of the build output. Really though, it''s
    best to just try it out yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Precisely because the kernel build is very CPU- and RAM-intensive, carrying
    this out on a guest VM is going to be a lot slower than on a native Linux system.
    It helps to conserve RAM by at least booting your guest at run-level 3 (multiuser
    with networking, no GUI): [https://www.if-not-true-then-false.com/2012/howto-change-runlevel-on-grub2/](https://www.if-not-true-then-false.com/2012/howto-change-runlevel-on-grub2/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, the kernel image (here, it''s called `bzImage`) and the `vmlinux` file
    have successfully been built by stitching together the various object files generated,
    as can be seen in the preceding output – the last line in the preceding block
    confirms this fact. But hang on, the build isn''t done yet. The kbuild system
    now proceeds to finish building all kernel modules; the last portion of the output
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The entire process seems to have taken a total of around 17.5 minutes. The `time(1)`
    utility gives us a (very) coarse-grained idea of the time taken by the command
    that follows it.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like accurate CPU profiling, learn to use the powerful `perf(1)` utility.
    Here, you can try it out with the `perf stat make -j4` command. I suggest you
    try this out on a distro kernel as otherwise, `perf` itself will have to be manually
    built for your custom kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the previous output, `Kernel: arch/x86/boot/bzImage is ready (#1)`,
    `#1` implies it''s the very first build of this kernel. This number will auto-increment
    on subsequent builds and show up when you boot into the new kernel and then execute `uname
    -a`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we're doing a parallelized build (via `make -j4`, implying four processes
    performing the build in parallel), all the build processes still write to the
    same `stdout` location – the terminal window. Hence, it can happen that the output
    is out of order or mixed up.
  prefs: []
  type: TYPE_NORMAL
- en: The build should run cleanly, without any errors or warnings. Well, at times
    compiler warnings are seen, but we shall blithely ignore them. What if you encounter
    compiler errors and thus a failed build during this step? How can we put this
    politely? Oh well, we cannot – it's very likely your fault, not the kernel community's.
    Please check and re-check every step, redoing it from scratch with a `make mrproper` command
    if all else fails! Very often, a failure to build the kernel implies either kernel
    configuration errors (randomly selected configs that might conflict), outdated
    versions of the toolchain, or incorrect patching, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming it goes off well, as indeed it should, by the time this step terminates,
    three key files (among many) have been generated by the kbuild system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root of the kernel source tree, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The uncompressed kernel image file, `vmlinux` (only for debugging)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The symbol-address mapping file, `System.map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compressed bootable kernel image file, `bzImage` (see the following output)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s check them out! We make the output (specifically the file size) more
    human-readable by passing the `-h` option to `ls(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `vmlinux` file is pretty huge. This is because it contains
    all the kernel symbols as well as extra debug information encoded into it. (FYI,
    the `vmlinux` and `System.map` files are used in the kernel debug context; keep
    them around.) The useful `file(1)` utility shows us more detail regarding this
    image file. The actual kernel image file that the bootloader loads up and boots
    into will always be in the generic location of `arch/<arch>/boot/`; hence, for
    the x86 architecture, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The compressed kernel image version `5.4.0-llkd01` for the x86_64 is a little
    over 8 MB in size. The `file(1)` utility again clearly reveals that indeed it
    is a Linux kernel boot image for the x86 architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel documents several tweaks and switches that can be performed during
    the kernel build by setting various environment variables. This documentation
    can be found within the kernel source tree at `Documentation/kbuild/kbuild.rst`. We
    shall in fact use the `INSTALL_MOD_PATH`,  `ARCH`, and `CROSS_COMPILE` environment
    variables in the material that follows.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Our kernel image and modules are ready! Read on as we install the kernel
    modules as part of our next step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – installing the kernel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous step, all the kernel config options that were marked as `m` have
    actually now been built. As you shall learn, that''s not quite enough: they must
    now be installed into a known location on the system. This section covers these
    details.'
  prefs: []
  type: TYPE_NORMAL
- en: Locating the kernel modules within the kernel source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the kernel modules just generated by the previous step – the kernel
    build – let''s perform a quick `find(1)` command within the kernel source folder.
    Understand the naming convention used, where kernel module filenames end in `.ko`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the preceding output that, in this particular build, a total
    of 59 kernel modules have happened to be built (the actual `find` output is truncated
    in the preceding block for brevity).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, recall the exercise I asked you to work on in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, in the *Sample usage of the make menuconfig
    UI* section. There, in *Table 2.4*, the last column specifies the type of change
    we made. Look for the `n -> m` (or `y -> m`) changes, implying we are configuring
    that particular feature to be built as a kernel module. There, we can see that
    this includes the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox support, `n -> m`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Userspace I/O** (**UIO**) drivers, `n -> m`; and a UIO platform driver with
    generic IRQ handling, `n -> m`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MS-DOS filesystem support, `n -> m`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As these features have been asked to be built as modules, they will not be
    encoded within the `vmlinux` or `bzImage` kernel image files. No, they will exist
    as standalone (well, kind of) *kernel modules*. Let''s hunt for the kernel modules
    for the preceding features within the kernel source tree (showing their pathname
    and sizes with a bit of scripting foo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Okay, great, the binary kernel modules have indeed been generated within the
    kernel source tree. But this alone is not enough. Why? They need to be *installed* into
    a well-known location within the root filesystem so that, at boot, the system
    *can actually find and load them* into kernel memory. This is why we need to *install*
    the kernel modules. The "well-known location within the root filesystem" is **`/lib/modules/$(uname
    -r)/`**, where `$(uname -r)` yields the kernel version number, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the kernel modules installed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Performing the kernel module installation is simple; (after the build step) just
    invoke the `modules_install` Makefile target. Let''s do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we use `sudo(8)` to perform the installation *as root* (superuser).
    This is required as the default install location (under `/lib/modules/`) is only
    root-writeable. Once the kernel modules have been prepared and copied across (the
    work that shows up in the preceding output block as `INSTALL`), the kbuild system
    runs a utility called `depmod(8)`. Its job essentially is to resolve dependencies
    between kernel modules and encode them (if they exist) into some metafiles (refer
    to the man page on `depmod(8)` for more details: [https://linux.die.net/man/8/depmod](https://linux.die.net/man/8/depmod)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the result of the module installation step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that for each (Linux) kernel we can boot
    the system into, there is a folder under `/lib/modules/`, whose name is the kernel
    release, as expected. Let''s look within the folder of interest – our new kernel''s
    (`5.4.0-llkd01`). There, under the `kernel/` sub-directory – within various directories
    – live the just-installed kernel modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Incidentally, the `/lib/modules/<kernel-ver>/modules.builtin` file has the list
    of all installed kernel modules (under `/lib/modules/<kernel-ver>/kernel/`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s search here for the kernel modules that we mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: They all show up. Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: 'A final key point: during the kernel build, we can install the kernel modules
    into a location that *we* specify, overriding the (default) `/lib/modules/<kernel-ver>`
    location. This is done by setting the environment variable of `INSTALL_MOD_PATH` to
    the required location; for example, doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have all our kernel modules installed into the `${STG_MYKMODS}/` folder. Note
    how, perhaps, `sudo` is not required if `INSTALL_MOD_PATH` refers to a location
    that does not require *root *for writing.
  prefs: []
  type: TYPE_NORMAL
- en: This technique – overriding the *kernel modules' install location* – can be
    especially useful when building a Linux kernel and kernel modules for an embedded
    target. Clearly, we must definitely *not* overwrite the host system's kernel modules
    with that of the embedded target's; that could be disastrous!
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to generate the so-called `initramfs` (or `initrd`) image and
    set up the bootloader. We also need to clearly understand what exactly this `initramfs`
    image is and the motivation behind using it. The section after the following one
    delves into these details.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – generating the initramfs image and bootloader setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, please note that this discussion is highly biased toward the x86[_64]
    architecture. For the typical x86 desktop or server kernel build procedure, this
    step is internally divided into two distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating the `initramfs` (formerly called `initrd`) image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (GRUB) bootloader setup for the new kernel image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason it's encapsulated into a single step in this recipe for the kernel
    build process here is that, on the x86 architecture, convenience scripts perform
    both tasks, giving the appearance of a single step.
  prefs: []
  type: TYPE_NORMAL
- en: Wondering what exactly this `initramfs` (or `initrd`) image file is? Please
    see the following *Understanding the initramfs framework* section for details.
    We'll get there soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s just go ahead and generate the **initramfs **(short for **initial
    ram filesystem**) image file as well as update the bootloader. Performing this
    on x86[_64] Ubuntu is easily done in one simple step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, again, we prefix the `make install` command with `sudo(8)`. Quite
    obviously, this is as we require *root* permission to write the concerned files
    and folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that''s it, we are done: a brand new 5.4 kernel, along with all requested
    kernel modules and the `initramfs` image, have been generated, and the (GRUB)
    bootloader has been updated. All that remains is to reboot the system, select
    the new kernel image on boot (from the bootloader menu screen), boot up, log in,
    and verify that all is okay.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating the initramfs image on Fedora 30 and above
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unfortunately, on Fedora 30 and above, generating the `initramfs` image does
    not appear to work as easily as with Ubuntu in the preceding section. Some folks
    suggest explicitly specifying the architecture via the `ARCH` environment variable.
    Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It fails! Want to know why? I won''t go into the details here, but this link
    should help you out: [https://discussion.fedoraproject.org/t/installing-manually-builded-kernel-in-system-with-grub2/1895](https://discussion.fedoraproject.org/t/installing-manually-builded-kernel-in-system-with-grub2/1895).
    To help set this situation right, here''s what I did on my Fedora 31 VM (and,
    yes, it worked!):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Manually create the `initramfs` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the `grubby` package is installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Pressing the *Tab* key twice after typing `grubby-` results in the full package
    name being auto-completed.
  prefs: []
  type: TYPE_NORMAL
- en: '(Re)run the `make install` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Though the `make install` command appears to fail, it has sufficiently succeeded.
    Let''s peek at the content of the `/boot` directory to verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, the `initramfs` image, the `System.map` file, and `vmlinuz` (along with
    the required symbolic links) seem to be set up! Reboot, select the new kernel
    from the GRUB menu, and verify that it works.
  prefs: []
  type: TYPE_NORMAL
- en: In this step, we generated the `initramfs` image. The question is, what did
    the *kbuild* system perform under the hood when we did this? Read on to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the initramfs image – under the hood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall from the previous section what you will first see when the `sudo make
    install` command executes (reproduced as follows for your convenience):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, it''s (`install.sh`) a script being executed. Internally, as part
    of its work, it copies the following files into the `/boot` folder, with the name
    format typically being `<filename>-$(uname -r)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `initramfs` image is built as well. A shell script named `update-initramfs`
    performs this task (which is itself a convenience wrapper over another script
    called `mkinitramfs(8)` that performs the actual work). Once built, the `initramfs`
    image is also copied into the `/boot` directory, seen as `initrd.img-5.4.0-llkd01`
    in the preceding output snippet.
  prefs: []
  type: TYPE_NORMAL
- en: If at all a file being copied into `/boot` already exists, it is backed up as
    `<filename>-$(uname -r).old`. The file named `vmlinuz-<kernel-ver>` is a copy
    of the `arch/x86/boot/bzImage` file. In other words, it is the compressed kernel
    image – the image file that the bootloader will be configured to load into RAM,
    uncompress, and jump to its entry point, thus handing over control to the kernel!
  prefs: []
  type: TYPE_NORMAL
- en: 'Why the names `vmlinux` (recall, this is the uncompressed kernel image file
    stored in the root of the kernel source tree) and `vmlinuz`? It''s an old Unix
    convention that the Linux OS is quite happy to follow: on many Unix flavors, the
    kernel was called `vmunix`, so Linux calls it `vmlinux` and the compressed one
    `vmlinuz`; the `z` in `vmlinuz` is to hint at the (by default) `gzip(1)` compression.'
  prefs: []
  type: TYPE_NORMAL
- en: As well, the GRUB bootloader configuration file located at `/boot/grub/grub.cfg` is
    updated to reflect the fact that a new kernel is now available for boot.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it's worth emphasizing the fact that all this is *very architecture-specific*.
    The preceding discussion is with respect to building the kernel on an Ubuntu Linux
    x86[-64] system. While conceptually similar, the details of the kernel image filenames,
    their locations, and especially the bootloader, vary on different architectures.
  prefs: []
  type: TYPE_NORMAL
- en: You can skip ahead to the *Customizing the GRUB bootloader* section if you wish*.* If
    you are curious (I'm hoping so), read on. In the following section, we describe
    in some more detail the *hows* and *whys* of the `initramfs`*/*`inird` framework.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the initramfs framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A bit of a mystery remains! What exactly *is *this `initramfs` or `initrd` image
    for? Why is it there?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, using this feature is a choice – the config directive is called `CONFIG_BLK_DEV_INITRD`.
    It's on and hence set to `y` by default. In brief, for systems that either do
    not know in advance certain things such as the boot disk host adapter or controller
    type (SCSI, RAID, and so on), the exact filesystem type that the root filesystem
    is formatted as (is it `ext2`, `ext3`, `ext4`, `btrfs`, `reiserfs`, `f2fs`, or
    another?), or for those systems where these functionalities are always built as
    kernel modules, we require the `initramfs` capability. Why exactly will become
    clear in a moment. Also, as mentioned earlier, `initrd` is now considered an older
    term. Nowadays, we more often use the term `initramfs` in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Why the initramfs framework?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `initramfs` framework is essentially a kind of middle-man between the early
    kernel boot and usermode. It allows us to run user space applications (or scripts)
    before the actual root filesystem has been mounted. This is useful in many circumstances,
    a couple of which are detailed in the following list. The key point is that `initramfs`
    allows us to run user mode apps that the kernel cannot normally run during boot
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practically speaking, among various uses, this framework allows us to do things
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a console font.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize keyboard layout settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print a custom welcome message on the console device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept a password (for encrypted disks).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load up kernel modules as required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn a "rescue" shell if something fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many more!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine for a moment that you are in the business of building and maintaining
    a new Linux distribution. Now, at installation time, the end user of your distribution
    might decide to format their SCSI disk with the `reiserfs` filesystem (FYI, it's
    the earliest general-purpose journaled filesystem in the kernel). The thing is,
    you cannot know in advance what choice exactly the end user will make – it could
    be one of any number of filesystems. So, you decide to pre-build and supply a
    large variety of kernel modules that will fulfill almost every possibility. Fine,
    when the installation is complete and the user's system boots up, the kernel will,
    in this scenario, require the `reiserfs.ko` kernel module in order to successfully
    mount the root filesystem and thus proceed with system boot-up.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bafffd2d-09c5-4054-899f-5d44b6e34c76.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The root filesystem's on the disk and yet to be mounted, kernel
    image is in RAM
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait, think about this, we now have a classic *chicken-and-egg problem*:
    in order for the kernel to mount the root filesystem, it requires the `reiserfs.ko`
    kernel module file to be loaded into RAM (as it contains the necessary code to
    be able to work with the filesystem). *But*, that file is itself embedded inside
    the `reiserfs` root filesystem; to be precise, within the `/lib/modules/<kernel-ver>/kernel/fs/reiserfs/`
    directory! (see Figure 3.1). One of the primary purposes of the `initramfs` framework
    is to solve this chicken-and-egg problem.'
  prefs: []
  type: TYPE_NORMAL
- en: The `initramfs` image file is a compressed `cpio` archive (`cpio` is a flat
    file format used by `tar(1)`). As we saw in the previous section, the `update-initramfs`
    script internally invokes the `mkinitramfs` script (on Ubuntu at least, this is
    the case). These scripts build a minimal root filesystem containing the kernel
    modules as well as supporting infrastructure such as the `/etc` and `/lib` folders
    in a simple `cpio` file format, which is then usually gzip-compressed. This now
    forms the so-called `initramfs` (or `initrd`) image file and as we saw earlier,
    it will be placed in `/boot/initrd.img-<kernel-ver>`. Well, so how does that help?
  prefs: []
  type: TYPE_NORMAL
- en: 'At boot, if we are using the `initramfs` feature, the bootloader will, as part
    of its work, load the `initramfs` image file in RAM. Next, when the kernel itself
    runs on the system, it detects the presence of an `initramfs` image, uncompresses
    it, and using its content (via scripts), loads up the required kernel modules
    into RAM (Figure 3.2):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcdd1dc0-1a4f-443d-bd55-47620fdc281e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The initramfs image serves as a middle-man between early kernel
    and actual root filesystem availability
  prefs: []
  type: TYPE_NORMAL
- en: Some more details on both the boot process (on x86) and the initramfs image
    can be found in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of the boot process on the x86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following list, we provide a brief overview of the typical boot process
    on an x86[_64] desktop (or laptop), workstation, or server:'
  prefs: []
  type: TYPE_NORMAL
- en: Early boot, POST, BIOS initialization – the **BIOS** *(*short for **Basic Input
    Output System**; essentially, the *firmware* on the x86) loads up the first sector
    of the first bootable disk into RAM and jumps to its entry point. This forms what
    is often referred to as the *stage one* bootloader, whose main job is to load
    the *stage two (larger) bootloader* code into memory and jump to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the stage two bootloader code takes control. Its main job is to *load the
    actual (stage three) GRUB bootloader* into memory and jump to its entry point
    (GRUB is typically the bootloader employed on x86[-64] systems)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The (GRUB) bootloader will be passed both the compressed kernel image file
    (`/boot/vmlinuz-<kernel-ver>`) as well as the compressed `initramfs` image file
    (`/boot/initrd.img-<kernel-ver>`) as parameters. The bootloader will (simplistically)
    do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform low-level hardware initialization.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Load these images into RAM, uncompressing the kernel image to a certain extent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will *jump to the kernel entry point.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux kernel, now having control of the machine, will initialize the hardware
    and software environment. It makes no assumptions regarding the earlier work performed
    by the bootloader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon completing the majority of hardware and software initialization, it notices
    that the `initramfs` feature is turned on (`CONFIG_BLK_DEV_INITRD=y`). It will
    thus locate (and if required, uncompress) the `initramfs` (`initrd`) image in
    RAM (see Figure 3.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will then *mount it* as a temporary root filesystem in RAM itself, within
    a `RAMdisk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a base, minimal root filesystem set up in memory. Thus, the `initrd`
    startup scripts now run, performing, among other tasks, the loading of the required
    kernel modules into RAM (in effect, loading the root filesystem drivers, including,
    in our scenario, the `reiserfs.ko` kernel module; again, see Figure 3.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel then performs a *pivot-root,* *un-mounting* the temporary `initrd`
    root filesystem, freeing its memory, and *mounting the real root filesystem;*
    it's now possible because the kernel module providing that filesystem support
    is indeed available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the (actual) root filesystem is successfully mounted, system initialization
    can proceed. The kernel continues, ultimately invoking the first user space process,
    typically `/sbin/init` PID `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *SysV **init *framework now proceeds to initialize the system, bringing
    up system services as configured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A couple of things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '(a) On modern Linux systems, the traditional (read: old) SysV *init* framework
    has largely been replaced with a modern optimized framework called **systemd**.
    Thus, on many (if not most) modern Linux systems, including embedded ones, the
    traditional `/sbin/init` has been replaced with `systemd` (or is a symbolic link
    to its executable file). Find out more about *systemd* in the *Further reading*
    section at the end of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: (b) FYI, the generation of the root filesystem itself is not covered in this
    book; as one simple example, I suggest you look at the code of the SEALS project
    (at [https://github.com/kaiwan/seals](https://github.com/kaiwan/seals)) that I
    mentioned in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel
    Workspace Setup*; it has script that generates a very minimal, or "skeleton",
    root filesystem from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the motivation behind `initrd`/`initramfs`, we'll complete
    this section by providing a bit of a deeper look into `initramfs` in the following
    section. Do read on!
  prefs: []
  type: TYPE_NORMAL
- en: More on the initramfs framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another place where the `initramfs` framework helps is in bringing up computers
    whose disks are *encrypted*. Quite early in the boot process, the kernel will
    have to query the user for the password, and if correct, proceed with mounting
    the disks, and so on. But, think about this: how can we run a C program executable
    that is, say, requesting a password without having a C runtime environment in
    place – a root filesystem containing libraries, the loader program, required kernel
    modules (for the crypto support perhaps), and so on?'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the kernel *itself* hasn't yet completed initialization; how can user
    space apps run? Again, the `initramfs` framework solves this issue by indeed setting
    up a temporary user space runtime environment complete with the required root
    filesystem containing libraries, the loader, kernel modules, and so on, in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we verify this? Yes we can! Let''s take a peek into the `initramfs` image
    file. The `lsinitramfs(8)` script on Ubuntu serves exactly this purpose (on Fedora
    the equivalent is called `lsinitrd` instead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s quite a bit in there: we truncate the output to show a few select
    snippets. Clearly, we can see a *minimal* root filesystem with support for the
    required runtime libraries, kernel modules, `/etc`, `/bin`, and `/sbin` directories,
    along with their utilities.'
  prefs: []
  type: TYPE_NORMAL
- en: The details of constructing the `initramfs` (or `initrd`) image goes beyond
    what we wish to cover here. I suggest you peek into these scripts to reveal their
    inner workings (on Ubuntu): `/usr/sbin/update-initramfs`, a wrapper script over
    the `/usr/sbin/mkinitramfs` shell script. Do see the *Further reading *section
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, modern systems feature what is sometimes referred to as hybrid `initramfs`:
    an `initramfs` image that consists of an early `ramfs` image prepended to the
    regular or main `ramfs` image. The reality is that we require special tools to
    unpack/pack (uncompress/compress) these images. Ubuntu provides the `unmkinitramfs(8)`
    and `mkinitramfs(8)` scripts, respectively, to perform these operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick experiment, let''s unpack our brand-new `initramfs` image (the one
    generated in the previous section) into a temporary directory. Again, this has
    been performed on our Ubuntu 18.04 LTS guest VM. View its output truncated for
    readability with `tree(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our (rather lengthy!) discussion on the `initramfs` framework
    and the basics of the boot process on the x86\. The good news is that now, armed
    with this knowledge, you can further customize your product by tweaking the `initramfs`
    image as required – an important skill!
  prefs: []
  type: TYPE_NORMAL
- en: As an example (and as mentioned earlier), with *security* being a key factor
    on modern systems, being able to encrypt a disk at the block level is a powerful
    security feature; doing this very much involves tweaking the `initramfs` image.
    (Again, as this goes beyond the scope of this book, do refer to the *Further reading*
    section at the end of this chapter for useful links to articles on this and other
    aspects.)
  prefs: []
  type: TYPE_NORMAL
- en: Now let's complete the kernel build with some simple customization of the (x86)
    GRUB bootloader's boot script.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 – customizing the GRUB bootloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now completed *steps 1* to *6* as outlined in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, in the *Steps to build the* *kernel
    from source* section). We can reboot the system; of course, do first close all
    your apps and files. By default, though, the modern **GRUB** (**GRand Unified**
    **Bootloader**) bootloader does not even show us any menu on reboot; it will by
    default boot into the newly built kernel (do remember that here, we're describing
    this process *only* for x86[_64] systems running Ubuntu).
  prefs: []
  type: TYPE_NORMAL
- en: On x86[_64] you can always get to the GRUB menu during early system boot. Just
    ensure you keep the *Shift* key pressed down during boot.
  prefs: []
  type: TYPE_NORMAL
- en: What if we would like to see and customize the GRUB menu every time we boot
    the system, thus allowing us to possibly select an alternate kernel/OS to boot
    from? This is often very useful during development, so let's find out how we can
    do this.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing GRUB – the basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Customizing GRUB is quite easy to do. Do note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The following steps are to be carried out on the "target" system itself (not
    on the host); in our case, the Ubuntu 18.04 guest VM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This has been tested and verified on our Ubuntu 18.04 LTS guest system only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a quick series of steps for our customization:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s be safe and keep a backup copy of the GRUB bootloader config file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `/etc/default/grub` file is the user-configuration file in question. Before
    editing it, we make a backup to be safe. This is always a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit it. You can use `vi(1)` or your editor of choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To always show the GRUB prompt at boot, insert this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On some Linux distros, you might instead have the `GRUB_TIMEOUT_STYLE=hidden`
    directive; simply change it to `GRUB_TIMEOUT_STYLE=menu` to achieve the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the timeout to boot the default OS (in seconds) as required; the default
    is `10` seconds; see the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the preceding timeout value to the following values will produce the
    following outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: Boot the system immediately without displaying the menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-1`: Wait indefinitely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, if a `GRUB_HIDDEN_TIMEOUT` directive is present, just comment
    it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the `update-grub(8)` program as *root* to have your changes take
    effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will typically cause the `initramfs` image to be refreshed
    (regenerated). Once done, you're ready to reboot the system. Hang on a second
    though! The following section shows you how you can modify GRUB's configuration
    to boot by default into a kernel of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the default kernel to boot into
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GRUB default kernel is preset to be the number zero (via the `GRUB_DEFAULT=0` directive).
    This will ensure that the "first kernel" – the most recently added one – boots
    by default (upon timeout). This may not be what we want; as a real example, on
    our Ubuntu 18.04.3 LTS guest VM, we set it to the default Ubuntu *distro kernel*
    by, as earlier, editing the `/etc/default/grub` file (as root, of course) like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this implies that if your distro is updated or upgraded, you must
    again manually change the preceding line to reflect the new distro kernel that
    you wish to boot into by default, and then run `sudo update-grub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right, our freshly edited GRUB configuration file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous section, don''t forget: if you make any changes here, run
    the `sudo update-grub` command to have your changes take effect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: a) In addition, you can add "pretty" tweaks, such as changing the background
    image (or color) via the `BACKGROUND_IMAGE="<img_file>"` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'b) On Fedora, the GRUB bootloader config file is a bit different; run this
    command to show the GRUB menu at every boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo grub2-editenv - unset menu_auto_hide` The details can be found in the *Fedora
    wiki: Changes/HiddenGrubMenu*: [https://fedoraproject.org/wiki/Changes/HiddenGrubMenu](https://fedoraproject.org/wiki/Changes/HiddenGrubMenu).'
  prefs: []
  type: TYPE_NORMAL
- en: c) Unfortunately, GRUB2 (the latest version is now 2) seems to be implemented
    differently on pretty much every Linux distro, leading to incompatibilities when
    trying to tune it in one given manner.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's reboot the guest system, get into the GRUB menu, and boot our new
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'All done! Let''s (finally!) reboot the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once the system completes its shutdown procedure and reboots, you should soon
    see the GRUB bootloader menu (the following section shows several screenshots
    too). Be sure to interrupt it by pressing any keyboard key!
  prefs: []
  type: TYPE_NORMAL
- en: 'Though always possible, I recommend you don''t delete the original distro kernel
    image(s) (and associated `initrd`, `System.map` files, and so on). What if your
    brand-new kernel fails to boot? (*If it can happen to the Titanic...*) By keeping
    our original images, we thus have a fallback option: boot from the original distro
    kernel, fix our issue(s), and retry.'
  prefs: []
  type: TYPE_NORMAL
- en: As a worst-case scenario, what if all other kernels/`initrd` images have been
    deleted and your single new kernel fails to boot successfully? Well, you can always
    boot into a *recovery mode* Linux via a USB pen drive; a bit of googling regarding
    this will yield many links and video tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: Booting our VM via the GNU GRUB bootloader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now our guest VM (using the *Oracle VirtualBox hypervisor*) is about to come
    up; once its (emulated) BIOS routines are done, the GNU GRUB bootloader screen
    shows up first. This happens because we quite intentionally changed the `GRUB_HIDDEN_TIMEOUT_QUIET`
    GRUB configuration directive to the value of `false`. See the following screenshot
    (Figure 3.3). The particular styling seen in the screenshot is how it''s customized
    to appear by the Ubuntu distro:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/913f5b6d-b473-4b43-a0c7-0ae382644d81.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The GRUB2 bootloader – paused on system startup
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go straight into booting our VM:'
  prefs: []
  type: TYPE_NORMAL
- en: Press any keyboard key (besides *Enter)* to ensure the default kernel is not
    booted once the timeout (recall, we set it to 3 seconds) expires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not already there, scroll to the `Advanced options for Ubuntu` menu, highlighting
    it, and press *Enter.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you''ll see a menu similar, but likely not identical, to the following
    screenshot (Figure 3.4). For each kernel that GRUB has detected and can boot into,
    there are two lines shown – one for the kernel itself and one for the special
    recovery mode boot option into the same kernel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f422bfa0-21b2-4f03-84d9-7891f9f3a522.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The GRUB2 bootloader showing available kernels to boot from
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the kernel that will boot by default – in our case, the `5.0.0-36-generic` kernel
    – is highlighted by default with an asterisk (`*`).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows a few "extra" line items. This is because, at
    the time of taking this screenshot, I had updated the VM and hence a few newer
    kernels were installed as well. We can spot the `5.0.0-37-generic` and `5.3.0-26-generic`
    kernels. No matter; we ignore them here.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever the case, simply scroll to the entry of interest, that is, the `5.4.0-llkd01`
    kernel entry. Here, it's the very first line of the GRUB menu (as it's the most
    recent addition to the GRUB menu of bootable OSes): `Ubuntu, with Linux 5.4.0-llkd01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have highlighted the preceding menu item, press *Enter *and voilà!
    The bootloader will proceed to do its job, uncompressing and loading the kernel
    image and `initrd` image into RAM, and jumping to the Linux kernel's entry point,
    thus handing over control to Linux!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right, if all goes well, as it should, you will have booted into your brand-new
    freshly built 5.4.0 Linux kernel! Congratulations on a task well done. Then again,
    you could always do more – the following section shows you how you can further
    edit and customize GRUB's config at runtime (boot time). Again, this skill comes
    in handy every now and then – for example, *forgot the root password?* Yes indeed,
    you can actually *bypass it* using this technique! Read on to find out how.
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with the GRUB prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You could experiment further; instead of merely pressing *Enter* while on the
    `Ubuntu, with Linux 5.4.0-llkd01` kernel''s menu entry, ensure that this line
    is highlighted and press the `e` key (for edit). We shall now enter GRUB''s *edit
    screen*, wherein we are free to change any value we like. Here''s a screenshot
    after pressing the *e* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80e582a1-ba49-492a-93b3-b708e8a0cb57.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – The GRUB2 bootloader – detail on the custom 5.4.0-llkd01 kernel
  prefs: []
  type: TYPE_NORMAL
- en: The screenshot has been taken after scrolling down a few lines; look carefully,
    you can spot the cursor (an underscore-like one, "**`_`**") at the very beginning
    of the third line from the bottom of the edit box. This is the crucial line; it
    starts with the suitably indented keyword `linux`. It specifies the list of *kernel
    parameters* being passed via the GRUB bootloader to the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Try experimenting a bit here. As a simple example, delete the words `quiet`
    and `splash` from this entry, then press *Ctrl* + *X* or *F10* to boot. This time,
    the pretty Ubuntu splash screen does not appear; you are directly in the console
    seeing all kernel messages as they flash past.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common question: what if we forget our password and thus cannot log in? Well,
    there are several approaches to tackle this. One is via the bootloader: boot into
    the GRUB menu as we have done, go to the relevant menu entry, press *e* to edit
    it, scroll down to the line beginning with the word `linux`, and append the word
    `single` (or just the number `1`) at the end of this entry, such that it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you boot, the kernel boots into single-user mode and gives you, the
    eternally grateful user, *a shell with root access*. Just run the `passwd <username>`
    command to change your password.
  prefs: []
  type: TYPE_NORMAL
- en: The precise procedure to boot into single-user mode varies with the distro.
    Exactly what to edit in the GRUB2 menu is a bit different on Red Hat/Fedora/CentOS.
    See the *Further reading* section for a link on how to set it for these systems.
  prefs: []
  type: TYPE_NORMAL
- en: This teaches us something regarding *security*, doesn't it? A system is considered
    insecure when access to the bootloader menu (and even to the BIOS) is possible
    without a password! In fact, in highly secured environments, even physical access
    to the console device must be restricted.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned how to customize the GRUB bootloader, and, I expect, have
    booted into your fresh 5.4 Linux kernel! Let's not just assume things; let's verify
    that the kernel is indeed configured as per our plan.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying our new kernel's configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so back to our discussion: we have now booted into our newly built kernel.
    But hang on, let''s not blindly assume things, let''s actually verify that all
    has gone according to plan. The *empirical approach* is always best:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, we are now running Ubuntu 18.04.3 LTS on our just-built **5.4.0** Linux
    kernel!
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall our table of kernel configs to edit from [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 1*, in *Table 2.4*. We should
    check row by row that each configuration we have changed has actually taken effect.
    Let''s list some of them, starting with the concerned `CONFIG_''FOO''` name, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_LOCALVERSION`: The preceding output of `uname -r` clearly shows the
    `localversion` (or `-EXTRAVERSION`) part of the kernel version has been set to
    what we wanted: the `-llkd01` string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_IKCONFIG`: Allows us to see the current kernel configuration details.
    Let''s check. Recall that you are to set the `LLKD_KSRC` environment variable to
    the root location of your 5.4 kernel source tree directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It works! We can see the entire kernel configuration via the `scripts/extract-ikconfig` script. We
    shall use this very script to `grep(1)` the remainder of the config directives
    that we changed in the aforementioned *Table 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Carefully looking through the preceding output, we can see that we got precisely
    what we wanted. Our new kernel's configuration settings match precisely the settings
    expected in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, *Table 2.4*; perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, as we have enabled the `CONFIG_IKCONFIG_PROC` option, we could
    have achieved the same verification by looking up the kernel config via the (compressed)
    `proc` filesystem entry, `/proc/config.gz`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So, the kernel build is done! Fantastic. I urge you to refer back to [Chapter
    2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building the 5.x Linux Kernel
    from Source – Part 1*, in the* Steps to build the kernel from source* section*,* to
    again see the high-level overview of steps for the entire process. We round off
    this chapter with an interesting *cross-compile* of the Raspberry Pi device kernel
    and a few remaining tips.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel build for the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A popular and relatively inexpensive **Single-Board Computer** (**SBC**) to
    experiment and prototype with is the ARM-based Raspberry Pi. Hobbyists and tinkerers
    find it very useful to try out and learn how to work with embedded Linux, especially
    as it has a strong community backing (with many Q&A forums) and good support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dbca72e-6589-4a88-98cc-318889ef8367.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – A Raspberry Pi 3 Model B+ device (note that the USB-to-serial cable
    seen in the photo does not come with it)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which you can build a kernel for the target device:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the kernel on a powerful host system, typically an Intel/AMD x86_64 (or
    Mac) desktop or laptop running a Linux distro.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform the build on the target device itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shall follow the first method – it's a lot faster and is considered the right
    way to perform embedded Linux development.
  prefs: []
  type: TYPE_NORMAL
- en: We shall assume (as usual) that we are running on our Ubuntu 18.04 LTS guest
    VM. So, think about it; now, the host system is actually the guest Linux VM! Also,
    we're targeting building the kernel for ARM 32-bit architecture, not 64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: Performing large downloads and kernel build operations on a guest VM isn't really
    ideal. Depending on the power and RAM of the host and guest, it will take a while.
    It could end up being twice as slow as building on a native Linux box. Nevertheless,
    assuming you have set aside sufficient disk space in the guest (and of course
    the host actually has this space available), this procedure works.
  prefs: []
  type: TYPE_NORMAL
- en: We will have to use an *x86_64-to-ARM (32-bit) cross-compiler* to build the
    kernel, or any component for that matter, for the Raspberry Pi target. This implies
    installing an appropriate **cross-toolchain** as well to perform the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following few sections, we divide the work up into three discrete steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ourselves a kernel source tree appropriate for the device
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learning how to install an appropriate cross toolchain
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring and building the kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – cloning the kernel source tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We arbitrarily select a *staging folder* (the place where the build happens)
    for the kernel source tree and the cross-toolchain, and assign it to an environment
    variable (so as to avoid hard-coding it):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your workspace. We set an environment variable as `RPI_STG` (it''s not
    required to use exactly this name for the environment variable; just pick a reasonable-sounding
    name and stick to it) to the staging folder''s location – the place where we shall
    perform the work. Feel free to use a value appropriate to your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Do ensure you have sufficient disk space available: the kernel source tree
    takes approximately 900 MB, and the toolchain around 1.5 GB. You''ll require at
    least another gigabyte for working space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the Raspberry Pi kernel source tree (we clone it from the official
    source, the Raspberry Pi GitHub repository for the kernel tree, here: [https://github.com/raspberrypi/linux/](https://github.com/raspberrypi/linux/)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel source tree gets cloned under a directory called `linux/` (that
    is, under `${RPI_WORK}/kernel_rpi/linux`). Notice how, in the preceding code,
    we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The particular Raspberry Pi kernel tree branch we have selected is *not* the
    very latest one (at the time of writing, the very latest is the 5.11 series),
    it's the 5.4 kernel; that's perfectly okay (it's an LTS kernel and matches our
    x86 one as well!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass the `--depth` parameter set to `1` to `git clone` to reduce the download
    and uncompress loads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now the Raspberry Pi kernel source is installed. Let''s briefly verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Okay, it's the 5.4.51 Raspberry Pi kernel port (the kernel version we use on
    the x86_64 is the 5.4.0 one; the slight variation is fine).
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – installing a cross-toolchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it's time to install a *cross-toolchain* on your host system that's appropriate
    for performing the actual build. The thing is, there are several working toolchains
    available... Here, I shall show two ways of obtaining and installing a toolchain.
    The first is the simplest and typically sufficient, while the second way installs
    a more elaborate version.
  prefs: []
  type: TYPE_NORMAL
- en: First method – package install via apt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is really simple and works well; do use this method routinely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The tools are typically installed under `/usr/bin/` and are therefore already
    part of your `PATH`; you can simply use them. For example, check out the ARM-32
    `gcc` compiler''s location and version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, do keep in mind: this toolchain is appropriate for building the kernel
    for ARM 32-bit architecture, not for 64-bit. If that''s your intention (building
    for 64-bit, which we don''t cover here), you will need to install a x86_64-to-ARM64
    toolchain with `sudo apt install ​crossbuild-essential-arm64`.'
  prefs: []
  type: TYPE_NORMAL
- en: Second method – installation via the source repo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a more elaborate method. Here, we clone the toolchain from the Raspberry
    Pi''s GitHub repo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the toolchain. Let''s place it under the folder called `rpi_tools` within
    our Raspberry Pi staging directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `PATH` environment variable so that it contains the toolchain binaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `PATH` environment variable (as shown in the preceding code) is
    required. However, it's only valid for the current shell session. Make it permanent
    by putting the preceding line into a startup script (typically your `${HOME}/.bashrc` file
    or equivalent).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, alternate toolchains can be used as well. For example, several
    toolchains for ARM development (for A-profile processors) are available on the
    ARM developer site at [https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – configuring and building the kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s configure the kernel (for the Raspberry Pi 2, Pi 3, and Pi 3[B]+). Before
    we begin, it''s *very important* to keep the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The **`ARCH`** environment variable is to be set to the CPU (architecture) for
    which the software is to be cross-compiled (that is, the compiled code will run
    on that CPU). The value to set `ARCH` to is the name of the directory under the `arch/` directory
    in the kernel source tree. For example, set `ARCH` to `arm` for ARM32, to `arm64`
    for the  ARM64, to `powerpc` for the PowerPC, and to `openrisc` for the OpenRISC
    processor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **`CROSS_COMPILE`** environment variable is to be set to the cross compiler
    (toolchain) prefix. Essentially, it's the first few common letters that precede
    every utility in the toolchain. In our following example, all the toolchain utilities
    (the C compiler `gcc`, linker, C++, `objdump`, and so on) begin with `arm-linux-gnueabihf-`,
    so that's what we set `CROSS_COMPILE` to. The `Makefile` will always invoke the
    utilities as `${CROSS_COMPILE}<utility>`, hence invoking the correct toolchain
    executable. This does imply that the toolchain directory should be within the `PATH` variable
    (as we mentioned in the preceding section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, let''s build the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick explanation regarding the configuration target,`bcm2709_defconfig`:
    this key point was mentioned in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 1*. We must ensure that we use
    an appropriate board-specific kernel config file as a starting point. Here, this
    is the correct kernel config file for the Broadcom SoC on the Raspberry Pi 2,
    Pi 3, Pi 3+ and Compute Module 3 devices. The `bcm2709_defconfig` config target
    specified results in parsing in the content of the `arch/arm/configs/bcm2709_defconfig`
    file. (The Raspberry Pi website documents this as `bcm2709_defconfig` for Raspberry
    Pi 2, Pi 3, Pi 3+, and Compute Module 3 default build configuration. Important:
    if you are building the kernel for another type of Raspberry Pi device, please
    see [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md).)'
  prefs: []
  type: TYPE_NORMAL
- en: FYI, the `kernel7` value is as such because the processor is ARMv7-based (actually,
    from the Raspberry Pi 3 onward, the SoC is a 64-bit ARMv8, which is compatible
    with running in 32-bit ARMv7 mode; here, as we're building a 32-bit kernel for
    ARM32 (AArch32), we specify `KERNEL=kernel7`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The variety of SoCs, their packaging, and their resulting naming creates a
    good deal of confusion; this link might help: [https://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835](https://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If any further customization of the kernel config is required, you could always
    do so with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, just skip this step and proceed. Build (cross-compile) the kernel,
    the kernel modules, and the DTBs with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '(Adjust the `-jn` appropriately for your build host). Once the build is successfully
    completed, we can see the following files have been generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, our purpose is just to show how a Linux kernel can be configured and built
    for an architecture other than the host system it's compiled upon, or in other
    words, cross-compiled. The gory details of placing the kernel image (and DTB file)
    on the microSD card and so on are not delved into. I refer you to the complete
    documentation for the Raspberry Pi kernel build, which can be found here: [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md).
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, here''s a quick tip to try out your new kernel on the Raspberry
    Pi 3[B+]:'
  prefs: []
  type: TYPE_NORMAL
- en: Mount the microSD card. It will typically have a Raspbian distro on it and two
    partitions, `boot` and `rootfs`, corresponding to the `mmcblk0p1` and `mmcblk0p2` partitions respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The bootloader and associated binaries**: It''s key to get the low-level
    startup binaries, which includes the bootloader itself, onto the SD card''s boot
    partition; this includes the `bootcode.bin` (the actual bootloader), `fixup*.dat`,
    and `start*.elf` binaries; the content of the `/boot` folder is explained here: [https://www.raspberrypi.org/documentation/configuration/boot_folder.md](https://www.raspberrypi.org/documentation/configuration/boot_folder.md).
    (If you''re unsure of how to get these binaries, it''s perhaps easiest to simply
    install a stock version of Raspberry Pi OS onto an SD card; these binaries will
    get installed within its boot partition. The stock Raspberry Pi OS images can
    be obtained from [https://www.raspberrypi.org/downloads/](https://www.raspberrypi.org/downloads/);
    also, FYI, the newer Raspberry Pi Imager app (for Windows, macOS, Linux) makes
    it really easy to perform the first-time installation).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it exists, back up and then replace the `kernel7.img` file within the `/boot` partition
    on the microSD card with the `zImage` file that we just built, naming it `kernel7.img`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the just-built kernel modules; ensure you specify the location as the
    microSD card''s root filesystem with the `INSTALL_MOD_PATH` environment variable!
    (Failing to do so means it might overwrite your host''s modules, which would be
    disastrous!) Here, we imagine that the microSD card''s second partition (which
    contains the root filesystem) is mounted under `/media/${USER}/rootfs`; then,
    do the following (all in one line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the DTBs (and overlays) that we just generated on the SD card as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Unmount the SD card, re-insert it into the device, and try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, to ensure it works, please refer to the official documentation (available
    at [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)).
    We have not covered the details regarding the generation and copying of kernel
    modules and DTBs to the microSD card.
  prefs: []
  type: TYPE_NORMAL
- en: Also, FYI, we again discuss kernel configuration and build for the Raspberry
    Pi in [Chapter 11](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml), *The CPU Scheduler
    – Part 2*.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our brief coverage on experimenting with a kernel cross-compilation
    for the Raspberry Pi. We'll end this chapter with a few miscellaneous but nevertheless
    useful tips.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous tips on the kernel build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We complete this chapter on building the Linux kernel from source with a few
    tips. Each of the following subsections encapsulates a tip for you to take note
    of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often a point of confusion for folks new to this: once we configure, build,
    and boot from a new Linux kernel, we notice that the root filesystem and any other
    mounted filesystems remain identical to what was on the original (distro or custom)
    system. Only the kernel itself has changed. This is entirely intentional, due
    to the Unix paradigm of having *a loose coupling* between the kernel and the root
    filesystem. Since it''s the root filesystem that holds all the applications, system
    tools, and utilities, including libraries, in effect, we can have several kernels,
    to suit different product flavors perhaps, for the same base system.'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum version requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To successfully build the kernel, you have to ensure that your build system
    has the documented *bare minimum *versions of the various software pieces of the
    toolchain (and other miscellaneous tools and utilities). This very information
    is clearly within the kernel documentation in the *Minimal requirements to compile
    the kernel* section, available at[ ](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel)[https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel).
  prefs: []
  type: TYPE_NORMAL
- en: For example, as of the time of writing, the recommended minimum version of `gcc`
    is 4.9 and that of `make` is 3.81.
  prefs: []
  type: TYPE_NORMAL
- en: Building a kernel for another site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our kernel build walk-through in this book, we built a Linux kernel on a
    certain system (here, it was an x86_64 guest) and booted the newly built kernel
    off the very same system. What if this isn''t the case, as will often happen when
    you are building a kernel for another site or customer premises? While it''s always
    possible to manually put the pieces in place on the remote system, there''s a
    far easier and more correct way to do it – build the kernel and associated meta-work
    bundled along with it (the `initrd` image, the kernel modules collection, the
    kernel headers, and so on) into a well-known **package format** (Debian''s `deb`,
    Red Hat''s `rpm`, and so on)! A quick `help` command on the kernel''s top-level
    `Makefile` reveals these package targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'So, for example, to build the kernel and its associated files as Debian packages,
    simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual packages are written into the directory immediately above the kernel
    source directory. For example, from the command we just ran, here are the `deb`
    packages that were generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is indeed very convenient! Now, you can literally install the packages
    on any other matching (in terms of CPU and Linux flavor) system with a simple
    `dpkg -i <package-name>` command.
  prefs: []
  type: TYPE_NORMAL
- en: Watching the kernel build run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see details (the `gcc(1)` compiler flags, and so on) while the kernel build
    runs, pass the **`V=1`** verbose option switch to `make(1)`. The following is
    a bit of sample output when building the Raspberry Pi 3 kernel with the verbose
    switch set to *on*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have made the preceding output a bit more human-readable by inserting
    new lines and highlighting some switches. This level of detail can help debug
    situations where the build fails.
  prefs: []
  type: TYPE_NORMAL
- en: A shortcut shell syntax to the build procedure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A shortcut shell (Bash, typically) syntax to the build procedure (assuming
    the kernel configuration step is done) could be something like the following example,
    to be used in non-interactive build scripts, perhaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the **`&&`** and **`||`** elements are the shell''s
    (Bash''s) convenience conditional list syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd1 && cmd2` implies : run `cmd2` only if `cmd1` succeeds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd1 || cmd2` implies : run `cmd2` only if `cmd1` fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with compiler switch issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A while back, in October 2016, when attempting to build an (older 3.x) kernel
    for the x86_64, I got the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that it’s not a kernel issue at all. Rather, it''s a compiler
    switch issue on Ubuntu 16.10: `gcc(1)` insists on using the `-fPIE` (where **PIE** is
    short for **Position Independent Executable**) flag by default. In the Makefile
    of older kernels, we need to turn this off. It''s been fixed since.'
  prefs: []
  type: TYPE_NORMAL
- en: This Q&A on the *AskUbuntu* website, on the topic of *Kernel doesn't support
    PIC mode for compiling?,* describes how this can be done: [https://askubuntu.com/questions/851433/kernel-doesnt-support-pic-mode-for-compiling](https://askubuntu.com/questions/851433/kernel-doesnt-support-pic-mode-for-compiling).
  prefs: []
  type: TYPE_NORMAL
- en: (Interestingly, in the preceding *Watching the kernel build run* section, with
    a recent kernel, notice how the build does use the **`-fno-PIE`** compiler switch.)
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with missing OpenSSL development headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In one instance, the kernel build on x86_64 on an Ubuntu box failed with the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is just a case of missing OpenSSL development headers; this is clearly
    mentioned in the *Minimal requirements to compile the kernel* document here: [https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#openssl](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#openssl).
    Specifically, it mentions that from v4.3 and higher, the `openssl` development
    packages are required.
  prefs: []
  type: TYPE_NORMAL
- en: FYI, this Q&A too shows how the installation of the `openssl-devel` package
    (or equivalent; for example, on the Raspberry Pi, the `libssl-dev` package needs
    to be installed) solves the issue: *OpenSSL missing during ./configure. How to
    fix?*, available at [https://superuser.com/questions/371901/openssl-missing-during-configure-how-to-fix](https://superuser.com/questions/371901/openssl-missing-during-configure-how-to-fix).
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, exactly this error occurred on a vanilla x86_64 *Fedora 29* distro
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, remember an almost guaranteed way to succeed: when you get those build
    and/or boot errors that you *just cannot fix*: copy the exact error message into
    the clipboard, go to Google (or another search engine), and type something akin
    to `linux kernel build <ver ...> fails with <paste-your-error-message-here>`.
    You might be surprised at how often this helps. If not, diligently do your research,
    and if you really cannot find any relevant/correct answers, do post your (well-thought-out)
    question on an appropriate forum.'
  prefs: []
  type: TYPE_NORMAL
- en: Several Linux "builder" projects exist, which are elaborate frameworks for building
    a Linux system or distribution in its entirety (typically used for embedded Linux
    projects). As of the time of writing, ***Yocto*** ([https://www.yoctoproject.org/](https://www.yoctoproject.org/))
    is considered the industry standard Linux-builder project, with ***Buildroot***
    ([https://buildroot.org/](https://buildroot.org/)) being an older but very much
    supported one; they are indeed well worth checking out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter, along with the previous one, covered in a lot of detail how to
    build the Linux kernel from source. We began with the actual kernel (and kernel
    modules') build process. Once built, we showed how the kernel modules are to be
    installed onto the system. We then moved on to both the practicalities of generating
    the `initramfs` (or `initrd`) image and went on to explain the motivation behind
    it. The final step in the kernel build was the (simple) customization of the bootloader
    (here, we focused only on x86 GRUB). We then showed how to boot the system via
    the newly baked kernel and verify that its configuration is as we expect. As a
    useful add-on, we then showed (the basics) of how we can even cross-compile the
    Linux kernel for another processor (ARM, in this instance). Finally, we shared
    some additional tips to help you with the kernel build.
  prefs: []
  type: TYPE_NORMAL
- en: Again, if you haven't done so already, we urge you to carefully review and try
    out the procedures mentioned here and build your own custom Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: So, congratulations on completing a Linux kernel build from scratch! You might
    well find that on an actual project (or product), you may *not* have to actually
    carry out each and every step of the kernel build procedure as we have tried hard
    to carefully show. Why? Well, one reason is that there might be a separate BSP
    team that works on this aspect; another reason – increasingly likely, especially
    on embedded Linux projects – is that a Linux-builder framework such as *Yocto* (or
    *Buildroot*) is being used. Yocto will typically take care of the mechanical aspects
    of the build. *However,* it is really important for you to be able to *configure*
    the kernel as required by the project; that still requires the knowledge and understanding
    gained here.
  prefs: []
  type: TYPE_NORMAL
- en: The next two chapters will take you squarely into the world of Linux kernel
    development, showing you how to write your first kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help you delve deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times, even books)
    in a Further reading document in this book's GitHub repository. The *Further reading*
    document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  prefs: []
  type: TYPE_NORMAL
