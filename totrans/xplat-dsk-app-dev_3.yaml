- en: Creating a Chat System with Electron and React â€“ Planning, Designing, and Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we worked with NW.js. It's a great framework, but
    not the only one on the market. Its counterpart Electron isn't inferior to NW.js
    in feature set and has an even larger community. To make the right choice of what
    fits best, I assume that one has to try both frameworks. So, our next example
    application will be a simple chat system and we will do it with Electron. We made
    the file explorer in plain JavaScript. We had to take care of abstractions consistency,
    data binding, templating, and such. In fact, we can delegate these tasks to a
    JavaScript framework. At the time of writing, the three solutions--React, Vue,
    and Angular--head the short list, where React seems like the most trending. I
    find it as a best fit for our next application. So, we will look into the essentials
    of React. We will set up Electron and webpack for our React-based application.
    We will not write all the CSS styles manually this time, but will use PhotonKit
    markup components. Finally, we will build the chat static prototype using React
    components and get ready to make it functional.
  prefs: []
  type: TYPE_NORMAL
- en: Application blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to describe our application requirements, the same as previously,
    we start with user stories:'
  prefs: []
  type: TYPE_NORMAL
- en: As a user, I can introduce myself to the chat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can see real time the list of chat participants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can enter and submit a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user, I can see messages of chat participants as they are coming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If putting it onto wireframes, the first screen will be a simple prompt for
    a username:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/872ea775-d606-4586-90b1-e152dcea185b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second screen contains a sidebar with participants and the main area with
    the conversation thread and a form to submit a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7617af7f-bbad-4525-840e-ef12a17997bb.png)'
  prefs: []
  type: TYPE_IMG
- en: The second screen shares header and footer with the first one, but the main
    section consists of a participant list (on the left) and chat pane (on the right).
    The chat pane comprises incoming messages and submission form.
  prefs: []
  type: TYPE_NORMAL
- en: Electron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already become acquainted with NW.js. As you likely know, there is an
    alternative to it called Electron ([https://electron.atom.io/](https://electron.atom.io/)).
    By and large, both provide comparable feature sets ([http://bit.ly/28NW0iX](http://bit.ly/28NW0iX)).
    On the other hand, we can observe that Electron has a larger and much more active
    community ([https://electron.atom.io/community/](https://electron.atom.io/community/)).
  prefs: []
  type: TYPE_NORMAL
- en: Electron is also known to be the GUI framework behind notable open source projects,
    such as Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    and Atom IDE ([https://atom.io/](https://atom.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: From a developer perspective, the first difference one faces is that Electron's
    entry point is a JavaScript, unlike HTML in NW.js. As we launch an Electron application,
    the framework runs first the specified script (main process). The script creates
    the application window. Electron provides API split in modules. Some of them are
    available only for the main process, some for renderer processes (any scripts
    requested from web pages originated by the main script).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this into practice. First of all, we will create the `./package.json`
    manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the whole, this manifest doesn't differ much from the one we created in previous
    chapters for NW.js. Yet, we do not need the `window` field here and field `main`
    points at the main process script.
  prefs: []
  type: TYPE_NORMAL
- en: As for dependencies, we obviously need `electron`, and in addition, we will
    use the `electron-debug` package, which activates hotkeys *F12* and *F5* for DevTools
    and reload, respectively ([https://github.com/sindresorhus/electron-debug](https://github.com/sindresorhus/electron-debug)).
    We also include Electron's DevTools Extension, called Devtron ([https://electron.atom.io/devtron](https://electron.atom.io/devtron)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can edit the main process script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/main.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we import `app` and `BrowserWindow` from the `electron` module. The first
    one allows us to subscribe to application lifecycle events. With the second, we
    create and control the browser window. We also obtain references to NPM modules
    `path` and `url`. The first helps to create platform-agnostic paths and the second
    helps in building a valid URL. In the last line, we declare a global reference
    for the browser window instance. Next, we will add a function that creates the
    browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, the function just creates a window instance and loads `index.html`
    in it. When the window is closed, the reference to the window instance gets destroyed.
    Further, we subscribe for application events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The application event `"ready"` is fired when Electron finishes initialization;
    then we create the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: The `window-all-closed` event is emitted when all the windows are closed. For
    any platform but macOS, we quit the application. OS X applications usually stay
    active until the user quit explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The `activate` event gets triggered only on macOS. In particular, it happens
    when we click on the application's dock or taskbar icon. If no window exists at
    that moment, we create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call `electron-debug` to activate the debug hotkeys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we launch Electron now, it will try loading `index.html`, which we have
    to create first:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing exciting is happening here. We just declared several placeholders and
    loaded a renderer process script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/renderer.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the renderer script, we read `package.json` into the `manifest` constant.
    We define a dictionary object to map the `process.platform` keys to meaningful
    platform names. We add a helper function, `write`, which assigns a given text
    to the element matching the given ID. Using this function, we populate the placeholders
    of the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are expected to have the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we install dependencies (`npm i`) and run the (`npm start`) example. We
    will see the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92bb3b20-5293-4618-bea5-fb4a58f4475e.png)'
  prefs: []
  type: TYPE_IMG
- en: React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is gaining momentum. It is the most trending technology, according to
    the 2016 Stack Overflow developer survey ([http://stackoverflow.com/insights/survey/2016#technology](http://stackoverflow.com/insights/survey/2016#technology)).
    It is interesting to note that React is not even a framework. It's a JavaScript
    library for building user interfaces--very clean, concise, and powerful. The library
    implements the component-driven architecture. So, we create components (reusable,
    composable, and stateful units of UI) and then use them like Lego blocks to construct
    the intended UI. React treats the derived structure as an in-memory DOM representation
    (virtual DOM). As we bind it to the real DOM, React keeps both in sync, meaning
    that whenever any of its components change their states, React immediately reflects
    the view changes in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, we can convert virtual DOM in the HTML string ([http://bit.ly/2oVsjVn](http://bit.ly/2oVsjVn))
    on the server side and send it with an HTTP response. The client side will automatically
    bind to the already existing HTML. Thus, we speed up page loading and allow search
    engines to crawl the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, the component is a function that takes in given properties and
    returns an element, where an element is a plain object representing a component
    or a DOM node. Alternatively, one can use a class extending `React.Component`,
    whose `render` method produces the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/677f98bb-ac86-41a2-9d1a-2a304acec881.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create an Element, one can go with the API. Yet, nowadays, as a rule, it''s
    not used directly, but via syntactic sugar known as **JSX**. JSX extends JavaScript
    with a new type that looks like an HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we write HTML straight in JavaScript and JavaScript in HTML. JSX
    can be translated to plain JavaScript using the Babel compiler with preset `react`
    ([https://babeljs.io/docs/plugins/preset-react/](https://babeljs.io/docs/plugins/preset-react/)).
  prefs: []
  type: TYPE_NORMAL
- en: Most of the modern IDEs support JSX syntax from the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a better understanding, we fiddle a bit with React. A function-based
    component might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we declare a `Header` component that generates an element representing
    a header with a heading populated from the `title` property. We can also go with
    a class. Thus, we can encapsulate component-related methods in the class scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This component creates a button and provides it with a minimalistic functionality
    (when the button is clicked, we get an alert box with the Clicked! text).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can attach our components to the DOM, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can note, components imply a unidirectional flow. You can pass properties
    from parent to child, but not otherwise. Properties are immutable. When we need
    to communicate from a child, we lift the state up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `render` method of the `List` component, we have an array of names. Using
    the `map` array prototype method, we iterate through the name list. The method
    results in an array of elements, which JSX accepts gladly. While declaring `Item`,
    we pass in the current `name` and `onItemSelected` handler bound to the list instance
    scope. The `Item` component renders `<li>` and subscribes the passed-in handler
    to click events. Therefore, events of a child component are handled by the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Electron meets React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have an idea about both Electron and React. What about on how to use
    them together? To get a grasp on it, we will start not with our real application,
    but with a simple, similar example. It will include a few components and a form.
    The application will reflect user input in the window title. I suggest cloning
    our last example. We can reuse the manifest and main process script. However we
    have to bring the following changes to the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./package.json`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we add the `react` and `react-dom` modules. The first
    is the library core and the second serves as a glue between React and DOM. The
    `prop-types` module brings us type-checking abilities (till React v.15.5, which
    was a built-in object of the library). We add `webpack` as a dev-dependency in
    addition to electron-specific modules. Webpack is a module bundler that takes
    in varying types (sources, images, markup, and CSS) of assets and produces a bundle(s)
    that can be loaded by the client. We will use webpack to bundle our React/JSX-based
    application.
  prefs: []
  type: TYPE_NORMAL
- en: However, webpack doesn't transpile JSX its own; it uses the Babel compiler (`babel-core`).
    We also include the `babel-loader` module, which bridges between webpack and Babel.
    The `babel-preset-react` module is a so-called Babel preset (a set of plugins)
    that allows Babel to deal with JSX. With the `babel-preset-es2017` preset, we
    make Babel compile our ES2017-compliant code into ES2016, which is greatly supported
    by Electron. What is more, I included the `babel-plugin-transform-class-properties`
    Babel plugin to unlock features of the proposal called ES Class Fields & Static
    Properties ([https://github.com/tc39/proposal-class-public-fields](https://github.com/tc39/proposal-class-public-fields)).
    So, we will be able to define class properties directly without the help of a
    constructor, which did not yet land to the specification.
  prefs: []
  type: TYPE_NORMAL
- en: There are two extra commands in the scripts section. The `build` command bundles
    JavaScript for the client. The `dev` command sets webpack in a watch mode. So,
    whenever we change any of the sources, it automatically bundles the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using webpack, we will need to configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We set `app/renderer.jsx` as the entry point. So, webpack will read it first
    and resolve any met dependencies recursively. The compiled bundle can be found
    then in `app/build/renderer.js`. So far, we have set the only rule for webpack:
    every met `.js` or `.jsx` file with the exception of the `node_modules` directory
    goes to Babel, which is configured for the `es2017` and `react` presets (and the
    `transform-class-properties` plugin, to be precise). So, if we run now, the `npm
    run build` webpack will try compiling `app/renderer.jsx` into `app/build/renderer.js`,
    which we call from the HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `./app/index.html` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The main renderer script may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/renderer.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we import two components--`Header` and `Copycat`--and use them in a composite
    one, which we bind to the DOM custom element, `<app>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the first component we describe with a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/Components/Header.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The function in the preceding code takes one property--`title` (we passed it
    in the parent component, `<Header />`)--and renders it as a heading.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use `PropTypes` to validate the `title` property value. If we happen
    to set a value other than string to `title`, a warning will be shown in the JavaScript
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following second component is presented with a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/Components/Copycat.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This component renders an input field. Whatever one is typing in the field
    gets reflected in the window title. Here, I have set a goal to show a new concept:
    children components/nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember we declared `Copycat` with children nodes in the parent component?
    The code for the `Copycat` element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we receive these list items in `this.props.children` and render them within
    `<ul>`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this, we subscribe a `this.onChange` handler for change events on the
    input element. As it changes, we obtain a current window instance from the remote
    function of electron (`remote.getCurrentWindow()`) and replace its title with
    input contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what we''ve got, we install dependencies using `npm i`, build the project
    using `npm run build`, and launch the application using `npm start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d698f325-f598-4ac2-b005-b6f6e823b971.png)'
  prefs: []
  type: TYPE_IMG
- en: Enabling DevTools extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I believe that you had no problems when running the last example. Yet, when
    we need to trace an issue in a React application, it can be tricky, as DevTools
    shows us what is happening to the real DOM; however, we want to know about the
    virtual one also. Fortunately, Facebook offers an extension for DevTools called
    React Developer Tools ([http://bit.ly/1dGLkxb](http://bit.ly/1dGLkxb)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install this extension with electron-devtools-installer ([https://www.npmjs.com/package/electron-devtools-installer](https://www.npmjs.com/package/electron-devtools-installer)).
    This tool supports a number of DevTools extensions including a few React-related:
    React Developer Tools (`REACT_DEVELOPER_TOOLS`), Redux DevTools Extension (`REDUX_DEVTOOLS`),
    React Perf (`REACT_PERF`). We will pick only the first one for now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add to the main process script the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/main.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported from the package `installExtension` function and `REACT_DEVELOPER_TOOLS`
    constant, which represents React Developer Tools . Now we can call the function
    as soon as application is ready. On this event we already invoke our `createWindow`
    function. So we can extend the function rather than subscribe again for the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when I launch the application and open `DevTools` (*F12*), I can see a
    new tab, `React`, which brings me to the corresponding panel. Now, it is possible
    to navigate through the React component tree, select its nodes, and inspect the
    corresponding components, edit its props, and state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6f12021-9f7e-4068-8e81-0ab6fdbd9a92.png)'
  prefs: []
  type: TYPE_IMG
- en: Static prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we are quite ready to start with the chat application. Yet, it
    will be easier to grasp if we create first a static version and then extend it
    with the intended functionality. Nowadays, developers often do not write CSS from
    scratch, but reuse components of HTML/CSS frameworks such as Bootstrap. There
    is a framework dedicated for the Electron application--**Photonkit** ([http://photonkit.com](http://photonkit.com)).
    This framework provides us with building blocks such as layouts, panes, sidebar,
    lists, buttons, forms, table, and buttons. A UI constructed of these blocks looks
    in the style of macOS, automatically adapted for Electron and responsive to its
    viewport size. Ideally, I would go with ready PhotonKit components built with
    React ([http://react-photonkit.github.io](http://react-photonkit.github.io)),
    but we will do it with HTML. I want to show you how you can incorporate an arbitrary
    third-party CSS framework on the example of PhotonKit.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we install it with NPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What we really need from the package is CSS and fonts files from the `dist`
    subfolder. The only truly reliable way to access the package content from the
    application is the require function ([http://bit.ly/2oGu0Vn](http://bit.ly/2oGu0Vn)).
    It''s clear how to request JavaScript or JSON files, but what about other types,
    for example, CSS? With webpack, we can bundle theoretically any content. We just
    need to specify the corresponding loaders in the webpack configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We extended webpack configuration with a new rule that matches any files with
    extension `css`. Webpack will process such files with `style-loader` and `css-loader`.
    The first one reads the requested file and adds it to the DOM by injecting a style
    block. The second brings to the DOM any assets requested with `@import` and `url()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After enabling this rule, we can load Photon styles directly in a JavaScript
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the custom fonts used in this CSS still won''t be available. We can
    fix it by further extending the webpack configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./webpack.config.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This rule aims for font files and exploits `file-loader`, which takes the requested
    file from the package, stores it locally, and returns the newly created local
    path.
  prefs: []
  type: TYPE_NORMAL
- en: So, given that the styles and fonts are handled by webpack, we can proceed with
    components. We will have two components representing the window header and footer.
    For the main section, we will use `Welcome` when the user has not yet provided
    any name, and `ChatPane` afterward. The second one is a layout for `Participants`
    and `Conversation` components. We will also have a root component, `App`, that
    connects all other components with the future chat services. Actually, this one
    works not like a presentational component, but as a container ([http://redux.js.org/docs/basics/UsageWithReact.html](http://redux.js.org/docs/basics/UsageWithReact.html)).
    So, we are going to keep it separate from others.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are now done with the architecture, we can write down our start script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/renderer.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we add to the DOM the CSS of PhotonKit library (`import "photonkit/dist/css/photon.css"`)
    and bind the `App` container to the `<app>` element. The following container goes
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/js/Containers/App.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, we just lay out other components using PhotonKit application
    layout styles (`.window` and `.window-content`). As we have agreed, we render
    either `ChatPane` or `Welcome` between header and footer, depending on the value
    of the local constant, `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, both the header and footer we build from Photon mark-up component
    ([http://photonkit.com/components/](http://photonkit.com/components/)) are called
    **bar**. Besides a neat styling, it also enables the possibility to drag the application
    window around your desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/js/Components/Header.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can figure out from Photon CSS classes in the `Header` component (`.toolbar`
    and `.toolbar-header`), we render a bar on the top of the window. The bar accepts
    action buttons (`.toolbar-actions`). At the moment, the only button available
    is meant to close the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Footer` component, we render a bar positioned at the bottom (`.toolbar-footer`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/js/Components/Footer.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It includes the project name and version from the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the welcome screen, we a have a simple form with the input field (`input.form-control`)
    for the name and a submit button (`button.btn-primary`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/js/Components/Welcome.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChatPane` component places `Participants` on the left and `Conversation`
    on the right. It''s pretty much everything what it does at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/js/Components/ChatPane.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Participants` component, we use a layout pane of a type sidebar (`.pane.pane-sm.sidebar`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/js/Components/Participants.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It has a list of chat participants. Every name we prefix with the Entype icon
    is provided by Photon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last component--`Conversation`--renders chat messages in a list (`.list-group`)
    and the submission form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/js/Components/Conversation.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first time we need to have a few custom styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/assets/css/custom.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we make the form `(.l-form`) stick to the bottom. It has a fixed height
    (`110px`), and all the available space upward takes the message list (`.l-chat-conversation`).
    In addition, we align message time information (`.media-body__time`) to the right
    and take it out of the flow (`float: right`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This CSS can be loaded in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We make sure that all the dependencies are installed (`npm i`), then build
    (`npm run build`) and launch the application (`npm start`). As it''s done, we
    can see the following intended UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac4a3396-1376-4a31-bf48-356c0a6f1eb8.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the fact that we do not have a functional application yet and just a
    static prototype, we have come a long way. We talked about the Electron GUI framework.
    We compared it to NW.js and went through its peculiarities. We made a simplified
    Electron demo application consisting of a main process script, renderer one, and
    HTML. We had an introduction into React basics. We focused on components and elements,
    JSX and virtual DOM, props, and state. We configured webpack to compile our ES.Next-compliant
    JSX into a JavaScript-acceptable one by Electron. To consolidate our knowledge,
    we made a small demo React application powered by Electron. What is more, we examined
    how to enable a DevTools extension (React Developer Tools) in Electron to trace
    and debug React applications. We have briefly familiarized ourselves with the
    PhotonKit frontend framework and created React components for the chat application
    using PhotonKit styles and markup. Finally, we have bundled our components together
    and rendered the application in Electron.
  prefs: []
  type: TYPE_NORMAL
