- en: Chapter 10. Scripting Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains some practices and techniques that will help the reader
    become a better and more efficient programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will talk about what I consider to be scripting (or programming)
    best practices. Having programmed computers since 1977 I have attained quite a
    bit of experience in this field. I take great pleasure in teaching people about
    computers and hopefully my ideas will be of some benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Backups will be discussed again, including verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'll explain how to pick a text editor you are comfortable with and learn its
    capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'll cover some basic command line items such as using a good prompt, command
    completion, environment variables and aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'll provide some bonus scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying backups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have already spoken about backups at least twice in this book and this will
    be the last time I promise. Create your backup scripts and make sure they run
    when they are supposed to. But one thing I have not talked about yet is verification
    of the backups. You might have 10 teraquads of backups lying around somewhere,
    but do they actually work? When was the last time you checked?
  prefs: []
  type: TYPE_NORMAL
- en: When using the `tar` command it will report at the end of the run if it encountered
    any issues making the archive. In general if it doesn't show anything amiss the
    backup is probably good. Using `tar` with the `-t (tell)` option, or actually
    extracting it on the local or remote machine, is also a good way to determine
    if the archive was made successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: A somewhat common mistake when using tar is to include a file in the
    backup that is currently being updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a rather obvious example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `tar` command might not consider this an error but will usually report it
    so be sure to check for this.
  prefs: []
  type: TYPE_NORMAL
- en: Another common backup mistake is to not copy the file to another computer or
    external device. If you are good at making backups but they are all on the same
    machine eventually the hard drive and/or controller is going to fail. You may
    be able to recover the data but why take the risk? Copy your files to at least
    one external drive and/or computer and be safe.
  prefs: []
  type: TYPE_NORMAL
- en: There is one last thing about backups I will mention. Make sure you have a backup
    sent to an off-site location, preferably in another city, state, continent, or
    planet. You really can't be too careful with your valuable data.
  prefs: []
  type: TYPE_NORMAL
- en: ssh and scp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `scp` to a remote computer is a really good idea too and my backup program
    does that every night as well. Here is how to set up unattended `ssh`/`scp`. In
    this case, the root account on machine 1 (M1) will be able to `scp` files to the
    `guest1` account on machine 2 (M2). I do it this way because I always disable
    root access of `ssh`/`scp` for security reasons on all my machines.
  prefs: []
  type: TYPE_NORMAL
- en: First make sure `ssh` has been run at least once on each machine. This will
    set up some needed directories and files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On M1, under `root`, run the `ssh-keygen -t rsa` command. This will create the
    file `id_rsa.pub` in the `/root/.ssh` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `scp` to copy that file to M2 to the `/tmp` directory (or some other suitable
    location).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On M2 go to the /`home/guest1/.ssh directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is already an `authorized_keys` file edit it, otherwise create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the line in the `/tmp/id_rsa.pub` file into the `authorized_keys` file
    and save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test this by using `scp` to copy a file from M1 to M2\. It should work without
    prompting for a password. If there are any problems remember that this has to
    be set up for each user that wants to perform unattended `ssh`/`scp`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have an **Internet service provider** (**ISP**) that provides SSH with
    your account this method should work on there as well. I use it all the time and
    it is really convenient. Using this approach you can have a script generate an
    HTML file and then copy it right to your website. Dynamic generation of HTML pages
    is something programs are really good at.
  prefs: []
  type: TYPE_NORMAL
- en: Find and use a good text editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you only occasionally write scripts or programs then vi is probably good
    enough for you. However, if you get into some real in depth programming, be it
    in Bash, C, Java, or some other language you should very definitely check out
    some of the other text editors that are available on Linux. You will almost certainly
    become more productive.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, I have been working with computers for a really long
    time. I started out using an editor on DOS called Edlin and it was pretty weak
    (but still better than punch cards). I eventually moved on and started using vi
    on AIX (IBM's version of UNIX). I got pretty good at using vi since we didn't
    have any other options yet. As time went on other choices became available and
    I started using the IBM Personal Editors. These were really easy to use, more
    efficient than vi, and had many more features. As I did more and more programming,
    I found that none of these editors could do everything I wanted and so I wrote
    my own in the C programming language. This was a long time ago under DOS, however,
    my editor has now been modified to run on Xenix, OS/2, AIX, Solaris, UNIX, FreeBSD,
    NetBSD, and of course Linux. It also works well on Windows under the Cygwin environment.
  prefs: []
  type: TYPE_NORMAL
- en: Any text editor should have the standard features such as copy, paste, move,
    insert, delete, split, join, find/replace, and so on. These should be easy to
    use and require not more than two keystrokes. The `save` command should only need
    one keystroke.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, a good editor will also have one, more, or all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to edit more than one file at a time (file ring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to switch to the next or previous file in the ring with a single keystroke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to show which files are in the ring and switch to any file instantly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to insert a file into the current file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to record and play back a remembered key sequence. This is sometimes
    referred to as a macro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An undo/restore feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An auto file save option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A locked files feature, to prevent editing the same file in another instance
    of the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolutely no obvious shortcomings or bugs. This is mandatory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept input via telepathy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, maybe I haven't quite figured out that last one yet. There are of course
    many, many more features that could be listed but I feel those are some of the
    most important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of my editor showing an example of how the `ring` command
    might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Find and use a good text editor](img/B07040_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many more features could be shown but that should be enough to get the point
    across. I will mention that vi is a fine editor and is used with success by probably
    the majority of UNIX/Linux people. However, in my experience if a lot of programming
    is being done the use of a different editor with more features will save you a
    lot of time. It's also quite a bit easier, and that makes the process even more
    fun.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables and aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Environment variables were covered in [Chapter2](ch02.html "Chapter 2. Working
    with Variables"), *Working with Variables*. Here is a cool trick that I learned
    years ago that can really help when using the command line. Most Linux systems
    generally have several standard directories under `$HOME` such as Desktop, Downloads,
    Music, Pictures, and so on. I personally do not like typing the same things over
    and over again and so do this to help use the system more efficiently. Here are
    some of the lines that I have added to my `/home/guest1/.bashrc file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this approach you can cd to any of the above directories by just typing
    the lowercase alias. What''s even better is you can also copy or move files to
    or from the directory by using the uppercase exported environment variable. Check
    out the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Environment variables and aliases](img/B07040_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It took me several years to start doing this and I am still kicking myself for
    not discovering it sooner. Remember to make the alias lowercase and the env var
    uppercase and you should be good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the command I ran in the `Bookmarks` directory. I actually typed `mv
    $DESK/` and then hit the *Tab* key. This caused the line to auto-complete and
    then I added the dot `.` character and pressed *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to use command auto-completion any time you can, it's a great time
    saver.
  prefs: []
  type: TYPE_NORMAL
- en: The line `. $LB/source.lbcur.txt` needs to be explained. You can see I have
    an `lbcur` alias which puts me into the directory where I am currently working
    on this book. Since I use both my root and `guest1` accounts to write a book,
    I can change the chapter number in just the `source.lbcur.txt` file. I then source
    the `.bashrc` files for root and `guest1` and I'm done. Otherwise, I would have
    to make the change in each `.bashrc` file. With just two files maybe it wouldn't
    be that bad, but suppose you had several users? I use this technique quite a bit
    on my systems as I am a very lazy typist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: When using aliases and environment variables you need to source the
    users''s `.bashrc` file before any changes will be picked up in the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: ssh prompt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I run a Linux system I tend to have at least 30 terminal windows open.
    Some of these are logged into the other machines in my house. As of this writing
    I am logged into laptop1, laptop4, and gabi1 (my girlfriend's laptop running Fedora
    20). I found a while back that if the prompt were different on these terminals
    it was harder for me to get mixed up and type the right command but on the wrong
    computer. Needless to say that could be a disaster. For a while I would change
    the prompt manually but that got old very quickly. One day I found almost by accident
    a really cool solution to this problem. I have used this technique on Red Hat
    Enterprise Linux, Fedora, and CentOS and so it should work on your system as well
    (with maybe a little bit of tweaking).
  prefs: []
  type: TYPE_NORMAL
- en: 'These lines are in the `$HOME/.bashrc` file on all my systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So what this does is use the set command to grep for the string `XAUTHORITY`.
    That string is only in the environment on the local machine. So when you open
    a terminal locally on big1 it uses the normal prompt. However, if you `ssh` to
    another system the string is not there and so it uses the long expanded prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of my system showing how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ssh prompt](img/B07040_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing an archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is something that I ran into on several of my computer jobs. I would be
    asked by my manager to take over a project from a fellow worker. He would `zip`
    or `tar` up the files and then give me the archive. I would uncompress it on my
    system and try to begin the work. But there was always a file missing. It would
    often take two, three, or more attempts before I would finally have every file
    needed to compile the project. So, the moral to this story is when making an archive
    to give to someone else make absolutely sure to copy it to another machine and
    test it there. Only then can you be reasonably sure that you have included every
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Progress indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is another cursor movement script that also calculates the low and high
    of the `$RANDOM` Bash variable. It might not look all that cool to everyone but
    it does show some more of the concepts we have covered in this book. I was also
    somewhat curious as to what the range of that random number generator was.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 - Script 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 10 - Script 1](img/B07040_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating new commands from a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since you are reading this book it can be assumed that you are going to be
    writing a good number of scripts. Here is another handy trick I learned over the
    years. When I need to create a new script, instead of doing it from scratch I
    use this simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 – Script 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Be sure that after you create the `mkcmd.template` file that you run `chmod
    755` on it. That way you do not have to remember to do it every time on your new
    commands. In fact, that was the main reason I wrote this script.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to modify this however you want, and of course change `kw` to vi or
    whatever editor you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s nice to have your computer beep when an important task has completed
    and you want to know about it right away. Here''s a script I use to beep the internal
    speaker on my computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 – Script 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will beep the PC speaker if it has one and if the driver has been
    loaded. Note that this command will probably only work on your system when run
    as the root user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter, I showed some of the programming best practices I have
    learned. The features of a good text editor were talked about, and a `$RANDOM`
    testing script was included. I also presented some of the scripts I have written
    over the years to make my systems more efficient and easier to use.
  prefs: []
  type: TYPE_NORMAL
