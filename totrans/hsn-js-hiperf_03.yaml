- en: Vanilla Land - Looking at the Modern Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The landscape of the JavaScript language has changed quite a bit since the release
    of the ECMAScript 2015 standard. There are now many new features that make JavaScript
    a first-class language for all types of development. It has become much easier
    to use the language, and we can even see some syntactic sugar in it now.
  prefs: []
  type: TYPE_NORMAL
- en: From the ECMAScript 2015 standard and beyond, we have received classes, modules,
    more ways of declaring variables, variations of scope, and much more. All of these
    features and more are going to be explained throughout the rest of this chapter.
    This is an excellent chapter to read in full if you are new to the language or
    you may just want to check out the features that may be unfamiliar. We will also
    take a look at some older sections of the web with DOM queries and how we can
    utilize them to replace extraneous libraries that we may be currently using, such
    as jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: A dive into modern JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding classes and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Fetch API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An editor such as VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A system that is set up to use Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A browser, preferably Chrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general understanding of JavaScript and its scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relevant code can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter03).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dive into modern JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the introduction, the language has changed for the better in a
    lot of ways. We now have proper scoping, better handling for `async` operations,
    more collection types, and even metaprogramming features such as reflection and
    proxies. All of these features lead to a more involved language, but they also
    lead to more effective problem-solving. We will be looking at a few of the best
    items to come out of the new standards and what they can be used for in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to also note moving forward is that any JavaScript code that is shown
    can be run in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding it to the developer's console by hitting *F12* on the keyboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Utilizing snippets in the developer's console that can be seen on the Sources
    tab, and in the left panel an option should be called Snippets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing a base level `index.html` that has a script element added to it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let/const and block scoping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before ECMAScript 2015, we only had the use of the `var` keyword for defining
    variables. The lifetime of a `var` keyword was from the function declaration to
    the end of it. This could lead to quite a few problems. The following code showcases
    one of the issues that we could run into with the `var` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What would the console print out? In most languages, we would guess that this
    is an error or that it would print `null`. However, JavaScript''s `var` keyword
    is function scoped, so the variable `i` will be `10`. This has led to many bugs
    popping up by accidentally forgetting to declare it a variable, or even the dreaded
    `switch` statement errors (these still happen with `let` and `const`). An example
    of a `switch` statement error is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding `switch` statement, we would expect `y` to be `null`, but
    because the `var` keyword is not block-scoped, it will be the letter `z`. We always
    had to stay on top of variables and make sure that we were not using something
    that was declared outside our scope and changing it, or we were making sure that
    we were redeclaring variables to stop leaks from happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'With both `let` and `const`, we got block scoping. This means that the curly
    braces tell us how long our variables should live for. An example of this is seen
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we look at the printouts for the variable `x`, we can see that we have first
    declared it as `10` outside of the function. Inside the function, we have created
    a new scope with the curly braces and redeclared `x` as `20`. Inside the block,
    the code will print out `inner scope 20`. But, outside of the block inside of
    `fun2`, we print out `x` and it is `10`. The `let` keyword follows this block
    scope. Had we declared the variable as `var`, it would have stayed as `20` when
    we printed it out the second time. Finally, we add `10` to the outer `x` and we
    should see that `x` is `20`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to getting block scoping, the `const` keyword gave us some immutability.
    If the types that we are working with are value types, we will not be able to
    mutate that value. If we have a reference type, the values inside the reference
    can be changed, but we cannot change the reference itself. This leads to some
    nice capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: A great style of coding is to use `const` as much as possible and only use `let`
    when we need to mutate something at the base level, such as loops. Since an object,
    array, or a function can have its values mutated, we can set them to `const`.
    The only downside that this has is that they cannot be nulled out, but it still
    adds quite a bit of safety on top of possible performance gains that the compiler
    can utilize knowing a value is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another notable change to the language was the addition of arrow functions.
    With this, we have now gotten access to change `this` without having to resort
    to various hacks on the language. An example of this can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a constructor function for a new object. We have two inner functions,
    one being a basic function call and the other being an arrow function. When we
    print this out, we notice that the basic function prints the window's scope. When
    we print the inner arrow function's scope, we get the scope of our parent.
  prefs: []
  type: TYPE_NORMAL
- en: We could solve this in a few ways for the basic inner function. First, we could
    declare a variable in the parent and utilize that for the inner function. Also,
    when we run the function, we could use call or `apply` to actually run the function.
  prefs: []
  type: TYPE_NORMAL
- en: However, neither of these is a good idea, especially when we now have arrow
    functions. A key point to remember is that the arrow function takes the scope
    of the parent, so whatever `this` points to for the parent, we are now going to
    do the same inside the arrow function. Now, we can always change that by utilizing
    `apply` on an arrow function, but it is best to only utilize `apply` and such
    for partial application reasons and not to call functions by changing its `this`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Collection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array and an object have been the two main types that JavaScript developers
    have used for quite some time. But, we now have two other collection types that
    help us do some things that we used to use these other types for. These are set
    and map. A set is an unordered collection of unique items. What this means is
    that if we try to put something in the set that is already there, we will notice
    that we only have a single item. We can easily simulate a set with an array like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we now have the set system, we can just use that API. We also get access
    to the `for of` loop since the set is an iterable item (we can also use the next
    syntax if we get the iterator attached to the set). Sets also have an advantage
    of faster read access over arrays when we get into large datasets. The following
    example illustrates this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While the set takes a bit longer to create, when it comes to looking for items
    or even grabbing them, the set will perform nearly 100 times faster than an array.
    This is mostly due to the way the array has to look items up. Since an array is
    purely linear, it has to go through each element to check, whereas the set is
    a simple constant time check.
  prefs: []
  type: TYPE_NORMAL
- en: A set can be implemented in different ways depending on the engine. A set in
    the V8 engine is built utilizing hash dictionaries for the lookup. We will not
    go over the internals of this, but essentially, the lookup time is considered
    constant, or *O(1)*, for computer science folk, whereas the array lookup time
    is linear, or *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of the set, we also have maps. We can look at these and see them as
    just objects, but they have a couple of nice properties:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we can use any value as the key, even an object. This can be great for
    adding other data that we do not want to tie directly to the object (private values
    come to mind).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to this, maps are also iterable, so we can utilize the `for of`
    loop just like a set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a map can give us performance benefits over a plain old object in the
    cases of large datasets and when the keys are the same types and so are the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example highlights many of the areas where maps are generally
    better than plain objects and where objects used to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On top of these two items, we also have weak versions of them. The weak versions
    have one major limitation: the values have to be objects. This makes sense once
    we understand what `WeakSet` and `WeakMap` do. They *weakly* store the reference
    to the items. This means that while the items they have stored are around, we
    can perform the methods that these interfaces give us. Once the garbage collector
    decides to collect them, the references will be removed from the weak versions.
    We may be wondering, why would we use these?'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `WeakMap`, there are a few use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: First, if we do not have private variables, we can utilize `WeakMap` to store
    values on the object without actually attaching the property to them. Now, when
    the object is eventually garbage collected, so is this private reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also utilize weak maps to attach properties or data to the DOM without
    actually having to add attributes to the DOM. We get all of the benefits of data
    attributes without cluttering up the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if we wanted to store reference data off to the side, but have it disappear
    when the data does, this is another use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All in all, `WeakMap` is used when we want to tie some sort of data to that
    object without having a tight coupling. We will be able to see this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a `WeakMap` to store the data we want against the DOM elements
    that we are creating. Next, we grab our unordered list and add a list element
    to each iteration. We then tie the number that we are on to the DOM element through
    the `WeakMap`. That way, the `onclick` handler can get the item and get back the
    data we stored against it.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we can click on any of the elements and get the data back. This is
    cool since we used to add data attributes to the HTML elements directly in the
    DOM. Now we can just use `WeakMap`. But, we also get one more benefit that has
    been talked about. If we run the `removeHalf` function in the command line and
    garbage collect, we can take a look at how many items are in the `WeakMap`. If
    we do this and we check how many elements are in the `WeakMap`, we will notice
    the number of elements it has stored can range from 25,000 to the full 50,000
    elements we started with. This is for the reason stated above; once a reference
    has been garbage collected, the `WeakMap` will no longer store it. It has a weak
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: The amount to be collected by the garbage collector is going to be up to the
    system that we are running. On some systems, the garbage collector may decide
    to not collect anything from the list. This all depends on how the V8 garbage
    collection has been set up for Chrome or Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily see this if we replace `WeakMap` with a regular one. Let's go
    ahead and make this minor change. With this change, observe the same preceding
    steps. We will notice that the map still has all 50,000 items inside it. This
    is what we mean when we say something either has a strong reference or a weak
    reference. A weak reference will allow the item to be cleaned up by the garbage
    collector, whereas a strong reference will not. *WeakMaps* are great for these
    types of linking in terms of data to another data source. If we want the item
    decoration or the link to be cleaned up when the primary object is cleaned, a
    `WeakMap` is a go-to item.
  prefs: []
  type: TYPE_NORMAL
- en: A `WeakSet` has a more limited use case. One great use case is for checking
    for infinite loops in object properties or graphs. If we store all of the visited
    nodes in a `WeakSet`, we are able to check whether we have the items, but we also
    don't have to clear the set once we are done with the check. This means, once
    the data gets collected, so will all of the references that were stored in the
    `WeakSet`. Overall, a `WeakSet` should be used when we need to tag an object or
    a reference. This means that if we need to see whether we have it or whether it
    has been visited, a `WeakSet` is a likely candidate for this job.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can utilize the deep copy example from the previous chapter. With it, we
    still run into one more use case that we did not think of. What happens if an
    item points to another item in the object and that same item decides to point
    back at the original item? This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With each of these items pointing at one another, we would run into circular
    reference issues. A way to get around this is with a `WeakSet`. We could hold
    all the visited nodes, and if we come to a node that is already visited, we just
    return from the function. This can be seen in the modified version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have added a new `_held` variable that will hold all of our
    references. Then, the `runUpdate` function has been modified to make sure that
    when an item is not a primitive type or a function, we check whether we already
    have it in our `held` list. If we do, then we skip the item, otherwise, we will
    just keep going. Finally, we replace the `_held` variable with a new `WeakSet`
    since the `clear` method is no longer available on *WeakSets*.
  prefs: []
  type: TYPE_NORMAL
- en: This does not keep the circular reference, which may be a problem, but it does
    solve our issue of the system going into an infinite loop because of objects referencing
    one another. Other than this use case, and maybe some more advanced ideas, there
    are not many other needs for a `WeakSet`. The main thing is if we need to track
    the existence of something. If we need to do this, the `WeakSet` is the perfect
    use case for us.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers will not find a need for *WeakSets* or *WeakMaps*. These will
    likely be utilized by library authors. However, the conventions mentioned previously
    may come up in some cases so it is nice to know the reason for these items and
    why they are there. If we do not have a reason to use something, then we should
    most likely not use it, this is definitely the case with these two items since
    they have really specific use cases and one of the major use cases for *WeakMaps*
    is being delivered to us in the ECMAScript standard (private variables).
  prefs: []
  type: TYPE_NORMAL
- en: Reflection and proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the last major pieces of the ECMAScript standard we are going to touch
    on is two metaprogramming objects. Metaprogramming is the technique of having
    code that generates code. This could be for things such as compilers or parsers.
    It could also be for self-changing code. It can even be for runtime evaluation
    of another language (interpreting) and doing something with this. While this is
    probably the main feature that reflection and proxies give us, it also gives us
    the ability to listen to events on an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we talked about listening to events and we created
    a `CustomEvent` to listen for events on our object. Well, we can change that code
    and utilize proxies for that behavior. The following is some basic code to handle
    basic events on an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is add some basic logging for the `get` and `set` methods
    on this object. We have extended the functionality of this object by also making
    the `set` method only take string values. With this, we have created an object
    that can be listened to and we can respond to those events.
  prefs: []
  type: TYPE_NORMAL
- en: Proxies are currently slower than adding a `CustomEvent` to the system. As stated
    previously, even though proxies were in the ECMAScript 2015 standard, their adoption
    has been slow, so browsers need some more time to optimize them. Also, it should
    be noted that we would not want to run the logging directly here. We would, instead,
    opt for the system to queue messages and utilize something called `requestIdleCallback`
    to run our logging code once the browser notices downtime in our application.
    This is still an experimental technology but should be added to all browsers soon.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting property of proxies is revocable methods. This is a proxy
    that we can eventually say is revoked and this will throw a `TypeError` when we
    try to use it after this method call. This can be very useful for anyone trying
    to implement the RAII pattern with objects. Instead of trying to `null` out the
    reference, we can revoke the proxy and we will no longer be able to utilize it.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern of RAII will differ slightly from the null reference. Once we revoke
    a proxy, all references will no longer be able to use it. This may become an issue,
    but it would also give us the added benefit of failing fast, which is always a
    great property to have in code development. This means that when we are in development,
    it will throw a `TypeError` instead of just passing a null value. In this case,
    only try-catch blocks would allow this code to keep going instead of just simple
    null checks. Failing fast is a great way to protect ourselves in development and
    to catch bugs earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is shown here with a modified version of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of just throwing *TypeErrors* on the set, we also will throw a
    `TypeError` once we revoke the proxy. This can be of great use to us when we decide
    to write code that will protect itself. We also no longer need to write a bunch
    of guard clauses in our code when we are utilizing objects. If we utilize proxies
    and revocables instead, we are able to guard our sets.
  prefs: []
  type: TYPE_NORMAL
- en: We did not go into the terminology of the proxy system. Technically, the methods
    we add in the handler for the proxies are called traps, similar to operating system
    traps, but we can really just think of them as simple events. Sometimes, the terminology
    can add a bit of confusion to things and is usually not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides proxies, the Reflect API is a bunch of static methods that mirror the
    proxy handlers. We can utilize them in place of some familiar systems such as
    the `Function.prototype.apply` method. We can instead utilize the `Reflect.apply`
    method, which can be a bit clearer when writing our code. This looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we set a value on our object the first time and it was successful.
    But, the second property was first defined and it was set to non-writable (the
    default when we use `defineProperty` ), and so we were not able to set a value
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: With both of these APIs, we can write some nice functionality for accessing
    objects and even making mutations as safe as possible. We can utilize the RAII
    pattern very easily with these two APIs and we can even do some cool metaprogramming
    along with it.
  prefs: []
  type: TYPE_NORMAL
- en: Other notable changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are plenty of changes that have come with the advancement of the ECMAScript
    standard and we could devote an entire chapter to all of those changes, but we
    will lay out a few more here that can be seen in code written in this book and
    most likely seen elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Spread operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The spread operator allows us to pull apart arrays, iterable collections such
    as sets or maps, and even objects in the latest standard. This gives us a nicer
    syntax for performing some common operations such as the ones here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What used to be `for` loops and other versions of iteration is now a simple
    one-line piece of code. Also, the first item is nice since it shows the reader
    of this code that we are utilizing the function as a variable argument function.
    Instead of needing documentation to lay this out, we can see this with the code.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with arguments, if we are going to mutate them at all in the function,
    create a copy and then mutate. Certain de-optimizations happen if we decide to
    mutate the arguments directly.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Destructuring is the process of taking an array or an object and passing the
    items to the variable we are assigning to in an easier fashion. This can be seen
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Both of these examples showcase some cool properties. First, we can pick and
    choose the items that we want from the object. We can also reassign the value
    to something else if we want to, on the left-hand side. On top of this, we can
    even do nested objects and destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: For the array, we are able to pick and choose all of the items, some of the
    items, or even use the `rest` syntax by putting the rest of the array in a variable.
    In the preceding example, `a` will hold `1`, `b` will hold `3`, and `c` will be
    an array with `4` and `5` inside it. We skipped 2 by making that space empty.
    In other languages, we would use something like `_` to showcase this, but we can
    just skip it here. Again, all of this is just syntactic sugar that enables tighter
    and cleaner code to be written.
  prefs: []
  type: TYPE_NORMAL
- en: Power operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is not much to say here other than the fact that we no longer need to
    utilize the `Math.pow()` function; we now have the power operator or `**`, leading
    to cleaner code and nicer-looking mathematical equations.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These allow us to put in default values if we do not have something for that
    position when calling a function. This may appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note with parameter defaults is that once we start to utilize defaults
    in the chain of arguments, we can't stop using defaults. In the preceding example,
    if we gave argument 2 a default, we would have to give argument 3 a default, even
    if we just pass undefined or `null` to it. Again, this helps with the clarity
    of code and making sure that we no longer have to create default cases where we
    are looking at the arguments of the array.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of code still utilizes the arguments section of a function. There are
    even other properties of a function that we can get at such as the caller. If
    we are in strict mode, a lot of this behavior will break. Strict mode is a way
    to not allow access to certain behaviors in the JavaScript engine. A good description
    of this can be found at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
    In addition to this, we should no longer be using the arguments section of the
    function since we have plenty of helpful alternatives with the new standard.
  prefs: []
  type: TYPE_NORMAL
- en: String templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'String templates allow us to pass in arbitrary code that will evaluate to a
    string or an object that has a `toString` function. This allows us, yet again,
    to write cleaner code instead of having to create a bunch of concatenated strings.
    It also allows us to write multiline strings without having to create escape sequences.
    This can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Just remember that even though we can do something, doing something may not
    be the best idea. Specifically, we may be able to pass arbitrary expressions that
    will evaluate to something, but we should try to keep them as clean and simple
    as possible to make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Typed arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be discussing these at length in future chapters, but typed arrays are
    ways of representing arbitrary bytes in the system. This allows us to work with
    lower-level functionality, such as encoders and decoders, or even working on the
    byte streams of a `fetch` call directly instead of having to work with converting
    blobs to numbers or strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'These usually start out with an `ArrayBuffer` and then we create a view over
    it. This can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we first create an array buffer. Think of this as a low-level
    instance. It just holds raw bytes. We then have to create a view over it. A lot
    of the time, we will be utilizing `Uint8Array` as we need to work with the arbitrary
    bytes, but we can utilize views all the way up to `BigInt`. These are usually
    utilized in low-level systems such as in 3D canvas code, WebAssembly, or raw streams
    from the server.
  prefs: []
  type: TYPE_NORMAL
- en: BigInt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BigInt` is an arbitrarily long integer. Numbers in JavaScript are stored as
    64-bit, floating-point doubles. This means that even if we only have a normal
    integer, we still only get 53 bits of precision. We can only store numbers inside
    variables up to the number 9 quadrillion. Anything bigger than this will usually
    cause the system to go into undefined behavior. To make up for this, we can now
    utilize the `BigInt` feature in JavaScript. This looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will notice that *BigInts* are appended with an `n`. We also need to coerce
    regular numbers to *BigInts* if we want to utilize them in regular operations.
    Now that we have big integers, we can work with very large numbers, which can
    be of great use in 3D, financial, and scientific applications.
  prefs: []
  type: TYPE_NORMAL
- en: Do not try to coerce *BigInts* back to regular numbers. There is some undefined
    behavior here and we may lose precision if we try to do this. The best approach
    is that if we need to use *BigInts*, stay in *BigInts*.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we come to internationalization. Before, we would need to internationalize
    such things as dates, number formats, and even currencies. We would use special
    lookups or converters that would do this for us. With the newer versions of ECMAScript,
    we have gained support for getting these new formats with the built-in `Intl`
    object. Some of the use cases can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can now internationalize our system depending on where someone
    may be located or what language they choose at the start of our application.
  prefs: []
  type: TYPE_NORMAL
- en: This will only perform conversions of the numbers to the stylings for that country
    code; it will not try to convert the actual values since options such as currency
    change within the course of the day. If we need to perform such conversions, we
    will need to use an API. On top of this, if we want to translate something, we
    will still need to have separate lookups for what we need to put in text since
    there is no direct translation between languages.
  prefs: []
  type: TYPE_NORMAL
- en: With these awesome features added in the ECMAScript standard, let's now move
    onto a way to encapsulate functions and data that go together. To do this, we
    will use classes and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding classes and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the new ECMAScript standard, we got the new class syntax for having a form
    of **object-oriented programming** (**OOP**) and, later, we also got modules,
    a way of importing and exporting user-defined collections of functions and objects.
    Both of these systems have enabled us to remove certain hacks that we built into
    the system, and also remove certain libraries that were close to essential for
    modularizing our code bases.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to understand what type of language JavaScript is. JavaScript
    is a multi-paradigm language. This means that we can utilize many of the ideas
    that are out there for different programming styles and incorporate them into
    our code base. One style of programming that we have touched on in previous chapters
    is the functional style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: In pure functional programming, we have pure functions, or functions that perform
    an action and have no side effects (do something outside what the function is
    supposed to do). When we write in this way, we can create generalized functions
    and put them together to create a chain of simple ideas that can work on complex
    ideas. We also treat functions as first-class citizens in the language. This means
    that functions can be assigned to variables and passed to other functions. We
    can also compose these functions, as we have seen in previous chapters. This is
    one way to think about a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular style of programming is object-oriented programming. This style
    states that a program can be described with a hierarchy of classes and objects
    that can be built and used together to create this complex idea. This idea can
    be seen in most of the popular languages that are out there. We build base classes
    that have some general functionality or some definitions that specific versions
    of them need to incorporate. We inherit from this base class and add our own specific
    functionality and then we create these objects. Once we put all of these objects
    together, we can work on the complex idea that we need to.
  prefs: []
  type: TYPE_NORMAL
- en: With JavaScript, we get both of these ideas, but the OOP design in JavaScript
    is a bit different. We have what is known as prototypal inheritance. What this
    means is that there is really no idea of these abstract ideas called *classes*.
    All we have in JavaScript are objects. We inherit an object's prototype that has
    methods and data on it that all objects with the same prototype share, but they
    are all instantiated instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about class syntax in JavaScript, we are talking about syntactic
    sugar for constructor functions and methods/data that we are adding to their prototype.
    Another way to think about this type of inheritance is to note that there are
    not abstract ideas in JavaScript, only concrete objects. If this seems a bit esoteric
    or confusing, the following code should clarify what these statements mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have shown a few things with this example. First, this is the older way of
    creating constructor functions. A constructor function is a function that sets
    up the scope and all of the functions that are directly available to an object
    when it gets instantiated. In this case, we have made `a`, `b`, and `c` as instance
    variables on an `Item` constructor. Second, we have added something to the item's
    prototype. When we declare something on the prototype of a constructor function,
    we are making that available to all instances of that constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we declare two items that are based on the `Item` constructor. This
    means that they will both get separate instances of the `a`, `b`, and `c` variables,
    but they will share the function `d`. We can see this in action with the next
    two statements. This showcases that if we add something directly to the `this`
    scope of a constructor function, it will create a brand-new instance of that item,
    but if we put something on the prototype, the items will all share it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can see that `item3` is a new `Item`, but we got to the constructor
    function in a roundabout way. Some browsers support the `__proto__` property on
    items, but this function should be available in all browsers. We grab the prototype
    and we notice that there is a constructor function. This is the same exact function
    that we declared at the top, so we are able to utilize it to make a new item.
    We can see that it is also on the same prototype as the other items and that the
    constructor function on the prototype is the exact same thing as the `item` variable
    that we declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'What all of this should showcase is the fact that JavaScript is purely made
    of objects. There are no abstract types such as true classes in other languages.
    If we utilize the new syntax, it is best to understand that all we are doing is
    utilizing syntactic sugar to do what we used to be able to do with the prototype.
    That said, the next example will showcase the exact same behavior, but one will
    be old-school prototype-based, and the other will utilize the new class syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see with this example, we get some cleaner syntax while creating the
    same object as what we had before with the prototype version. The constructor
    function is the same thing as when we declared the `Item` as a function. We could
    pass in any parameters and do the setup in here. One interesting thing with classes
    is that we are able to create instance variables inside the class, just like when
    we declared them on `this` in the prototype example. We can also see that the
    declaration of `d` is put on the prototype. We will explore more aspects of the
    class syntax below, but take some time and play with both pieces of code. Understanding
    how JavaScript is prototype-based helps immensely when we are trying to write
    highly performant code.
  prefs: []
  type: TYPE_NORMAL
- en: The public variables being inside the class is rather new (Chrome 72). If we
    do not have access to a newer browser, we will have to utilize Babel to transpile
    our code back down to a version that the browser will understand. We will also
    be taking a look at another feature that is only in Chrome and is experimental,
    but it should come to all browsers within the year.
  prefs: []
  type: TYPE_NORMAL
- en: Other notable features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript classes give us a bunch of nice features that make the code we write
    clean and concise, while also performing at or near the same speed as if we wrote
    directly to the prototype. One nice feature is the inclusion of static member
    variables and static member functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there is not much of a difference, it does allow us to write functions
    that cannot be accessed by the member functions (they can still be accessed, but
    it is a lot harder) and it can provide a good tool for grouping utility functions
    to that specific class. An example of static functions and variables is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The two static definitions were added to the `newItem` class and then we showcase
    what is available. With the function `e` and the static variable `f`, we can see
    that they are not included on the objects we create from `newItem`, but we have
    access to them when we access `newItem` directly. On top of this, we can see that
    the `this` that is inside the static function points to the class. Static members
    and variables are great for creating utility functions or even for creating the
    singleton pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create the same experience in the old style, it would look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have to put these definitions after the first definition of
    `Item`. This means that we have to be relatively careful in trying to group all
    of our code for the definition of our classes in the old style, whereas the class
    syntax allows us to put it all in a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of static variables and functions, we have the shorthand for writing
    the getters and setters for a variable in a class. This can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With this getter and setter, we are able to do various things inside these functions
    when someone or something tries to access this variable. In the same vein that
    we set up a proxy to event on a change, we can do something similar with the getter
    and setter. We can also set up logging inside here. This syntax is quite nice
    when we want to access something as just a property name instead of writing our
    something like `getG` and `setG`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are the new private variables that have come in Chrome 76\.
    While this is still in the candidate recommendation phase, it is still going to
    be discussed since it will most likely come into play. A lot of the time, we want
    to expose as much information as possible. However, there are times when we want
    to utilize internal variables to hold state or just not generally be accessed
    outside of our object. In this vein, the JavaScript community has come up with
    the `_` solution. Anything that has an `_` is considered a private variable. But,
    a user can still get access to these variables and manipulate them. Even worse
    than this, a malicious user could find a vulnerability in these private variables
    and be able to manipulate the system in their favor. One technique of creating
    private variables in the old system is something that looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, no one has access to the `priv` variable except for the implementer.
    This gives us a public-facing system, without access to that private variable.
    However, there is still a catch with this system: if we create another `Public`
    object, we will still be affecting the same `priv` variable. There are other ways
    to make sure that we get new variables as we create new objects, but these are
    all workarounds to the system we are trying to make. Instead, we can now utilize
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: What that pound sign does is say that this is a private variable. If we try
    to get access to it from any one of our instances, it will come back undefined.
    This works great with the getter and setter interface as we will be able to control
    access to variables and even modify them if need be.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final look into classes is the `extend` and `super` keywords. With `extend`,
    we are able to do just that with classes. Let''s take our `newItem` class and
    extend its functionality. This could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have a few interesting behaviors happening in this example. First, if we
    run `Object.getPrototypeOf` on our extended object, we will see that the prototype
    is what we would expect, `extendedNewItem`. Now, if we get the prototype of that,
    we will see that it is `newItem`. We have created a prototype chain just like
    many of the built-in objects.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we have the capability of getting to our parent's methods from inside
    our class with the use of `super`. This is essentially a reference to our parent's
    prototype. We cannot chain these if we want to keep going through all of the prototypes.
    We would have to utilize something like `Object.getPrototypeOf`. We can also see,
    by inspecting our extended object, that we got all of the member variables that
    were held in our parent's system.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us the ability to compose our classes together and create base classes
    or abstract classes that give us some defined behavior and then we can create
    extended classes that give us specific behavior that we want. We will see more
    code later on that utilizes classes and many of the concepts that we have gone
    over here, but remember that classes are just syntactical sugar for the prototype
    system and a good understanding of that will go a long way into understanding
    how JavaScript works as a language.
  prefs: []
  type: TYPE_NORMAL
- en: There are many great things about that class interface with the JavaScript ecosystem
    and there appear to be some other great ideas potentially coming in the future,
    such as decorators. It is always a good idea to keep an eye on the **Mozilla Developer
    Network** (**MDN**) page to see what is new and what is possibly coming out in
    the future. We will now take a look at modules and how they work in our system
    of writing clean and fast code.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is to not extend any class more than one, maybe two levels
    deep. If we go any further, we can start to create a maintenance nightmare, on
    top of potential objects getting heavy with information that they don't need.
    Thinking ahead will always be the best bet when we are creating our systems, and
    trying to minimize the impact of our classes is one way of reducing memory use.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before ECMAScript 2015, we had no concept of loading in code other than utilizing
    the script tag. We came up with many module concepts and libraries, such as **RequireJS** or
    **AMD**, but none of them were built into the language. With the advent of modules,
    we now had a way of creating highly modular code that could easily be packaged
    up and imported into other sections of our code. We also got scope lock on our
    systems where we used to have to utilize IIFEs to get this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, before we can start to work with modules, we will need a static server
    to host all of our content. Even if we get Chrome to allow access to the local
    filesystem, the module system will get upset since it will not serve them as text/JavaScript.
    To get around this, we can install the node package, `node-static`. We are going
    to add this package to a static directory. We can run the following command: `npm
    install node-static`. Once this is finished downloading into the `static` directory,
    we can grab the `app.js` file from the `Chapter03` folder in our repository and
    run `node app.js`. This will start up the static server, along with serving them
    from the `files` directory inside our `static` directory. We can then place any
    files that we want to serve in there and be able to get at them from our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can write a basic module along the lines of the following and save
    it as `lib.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then import this module from an HTML file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With even this basic example, we can get an idea of how modules work in the
    browser. First, the type of script needs to be a module. This tells the browser
    that we are going to load in modules and that we are going to treat this body
    of code as if it were a module. This gives us several benefits. First, we are
    automatically put into strict mode when we are utilizing modules. Second, we are
    automatically scoped with modules. This means that the `lib` that we just imported
    is not available as a global. If we loaded in content as text/JavaScript and put
    variables on the global path, then we would automatically have them; that is why
    we usually have to utilize an IIFE. Finally, we get a nice syntax in which to
    load our JavaScript files. We could still utilize the old way of loading in a
    bunch of scripts, but we can also just import the ones that are module-based.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can see that the module itself uses the `export` and `default` keywords.
    The `export` means that we want this item to be available outside of this scope
    or file. We can now get to this item outside of our current file. The default
    means that if we load in the module without defining what we want, we will get
    this item automatically. This can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we defined an object called `exports`. This is the object that we want
    to add as an exported item. Second, we added this item to an `export` declaration
    and we also renamed it. This is one nice thing about modules. On either the export
    or the import side, we can rename the items that we want to export. Now, in our
    HTML file, we would have a declaration such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If we did not have the brackets around the declaration, we would be trying to
    bring in the default export. Since we have the curly brackets, it is going to
    look for an item called `Item` inside `lib.js`. If it finds it, then it will bring
    in the code that is associated with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just as we renamed the exports from the export list, we can rename the
    import. Let''s go ahead and change that to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can now utilize the item as we normally would, but as the variable `_item`
    instead of `Item`. This is great for name collisions. There are only so many variable
    names that we can come up with so, instead of changing the variables inside the
    separate libraries, we can just change them when they are loaded in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good styling convention is to declare all of our imports at the top. However,
    there are use cases where we may need to dynamically load our modules due to some
    type of user interaction or some other event. If this occurs, we can utilize dynamic
    imports to do this. These appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have added a button that, when clicked, we try to load the module into our
    system. This is not the best way to cache the module in our system and most browsers
    will also do some caching for us, but this way is fairly straightforward and showcases
    the dynamic import system. The import function is based on promises, so we try
    to grab it and, if we succeed, we add it to an imported object. We then call the
    default method. We can get to any of the items that the module exports for us,
    but this is one of the easiest to get to.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing how JavaScript has evolved has been amazing. All of these new features
    give us capabilities that we used to have to rely on from third parties. The same
    can be said regarding the changes to the DOM. We will now look at these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Document Object Model** (**DOM**) has not always been the easiest technology
    to work with. We had old archaic APIs and, most of the time, they never lined
    up between browsers. But, within the last couple of years, we have gotten some
    nice APIs to do the following: grab elements with ease, build in-memory hierarchies
    for fast attachment, and templates with DOM shadowing. All of these have led to
    a rich environment for making changes to the underlying nodes and creating a number
    of rich frontends without the need for libraries such as jQuery. In the following
    sections, we will see how working with these new APIs has helped us.'
  prefs: []
  type: TYPE_NORMAL
- en: Query selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we had this API (or we were trying to be as cross-browser as we could),
    we relied on systems such as `getElementById` or `getElementsByClassName`. Each
    of these provided a way in which we could get DOM elements, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One difference between this older API and the new `querySelector` and `querySelectorAll`
    is that the old API implements a collection of DOM nodes as an `HTMLCollection`
    and the newer API implements them as a `NodeList`. While this may not seem like
    a major difference, the `NodeList` API does give us a `forEach` already built
    into the system. Otherwise, we would have to change both of these collections
    to a regular array of DOM nodes. The preceding example, implemented in the new
    API, appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This becomes much nicer when we want to start adding other features to our selection
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we now have a few inputs and that we want to grab all inputs
    that are of the text type. How would this look inside the old API? We could attach
    a class to all of them if need be, but this would pollute our use of classes and
    is probably not the best way of handling this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way that we could get this data would be to utilize one of the old
    API methods and then check whether those elements have the input attribute set
    to `text`. This could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'But we now have a certain level of verbosity that is not needed. Instead, we
    could grab them by utilizing CSS selectors, utilizing the Selector API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we should be able to get to any DOM node utilizing the CSS syntax,
    just like jQuery does. We can even start from another element so that we do not
    have to parse the entire DOM, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The other nice thing about the Selectors API is that it will throw an error
    if we do not utilize a correct CSS selector. This gives us the added benefit of
    the system running checks for us. While the new Selector API has been around,
    it has not been utilized much because of Internet Explorer needing to be included
    in the supported web browsers. It is highly suggested to start to utilize the
    new Selector API as it is less verbose and we are able to do a lot more with it
    than our old system.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery is a library that gives us a nicer API to utilize than the base system
    had. Most of the changes that jQuery supported have now become obsolete, with
    many of the new web APIs that we have been talking about taking over. For most
    new applications, they will no longer need to utilize jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Document fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen these in previous chapters, but it is nice to touch upon them.
    Document fragments are reusable containers that we can create a DOM hierarchy
    in and attach all of those nodes at once. This leads to faster draw times and
    less repainting when utilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example showcases two ways of attaching a series of list elements
    utilizing straight-to-DOM addition and fragment addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: While the time between these two is tiny, the number of repaints that take place
    is not. In our first example, the document is going to repaint each time we add
    an element directly to it, whereas our second example is only going to repaint
    the DOM once. This is the nice thing about document fragments; it makes adding
    to the DOM simple, while also only utilizing minimal repaints.
  prefs: []
  type: TYPE_NORMAL
- en: Shadow DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shadow DOM is usually paired with templates and web components, but it can
    also be utilized by itself. The shadow DOM allows us to encapsulate our markup
    and styles for a specific section of our application. This is great if we want
    to have a certain styling for a piece of our page, but we do not want that to
    propagate to the rest of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily utilize the shadow DOM by utilizing its API, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First, we attach a shadow DOM to an element, in this case, our `shadowHolder`
    element. There is a mode option that allows us to say whether we can access the
    content through JavaScript outside of the shadow context, but it has been found
    that we can easily circumvent this, so it is recommended just to keep it open.
    Next, we create a few elements, one being a number of styling attributes. We then
    attach these to a document fragment and finally to the shadow root.
  prefs: []
  type: TYPE_NORMAL
- en: With all of that out of the way, we can take a look and notice that our shadow
    DOM gets affected by the styling attributes that were put inside with it instead
    of the ones that were put at the top of our main document. What happens if we
    put a style at the top of our document that our shadow styling does not have?
    It still does not get affected. With this, we are now able to create components
    that can be styled separately without the use of classes. This brings us to one
    of our final topics of the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web Component API allows us to create custom elements that have defined
    behaviors utilizing only the browser APIs. This is different to a framework such
    as Bootstrap or even Vue as we are able to utilize all of the technologies that
    are present in our browser.
  prefs: []
  type: TYPE_NORMAL
- en: Chrome and Firefox have all of these APIs supported. Safari has most of them,
    and if this is a browser that we want to support, we will only be able to utilize
    some of the APIs. Edge does not have support for the Web Component APIs, but with
    it moving to a chromium base, we will see another browser able to utilize this
    technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a basic `tooltip` element. First, we need to extend the base
    `HTMLElement` in our class. We will then need to attach some properties to allow
    us to place the element and to give us the text that we need to use. Finally,
    we will need to register this component with our system to make sure it recognizes
    our custom element. The following code creates this custom element (modified from
    [https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First, we have a list of attributes that we are going to use to style and position
    our `tooltip`. They are called `x`, `y`, `type`, `text`, and `show`, respectively.
    Next, we create a map for some emoji-based text so that we can utilize icons without
    bringing in a full-fledged library for this. We then set up our reusable object
    inside a shadow container. We also put the shadow root on the object so we have
    easy access to it. The `update` method will fire on the first creation of our
    element and on any subsequent changes to our attributes. We can see this in the
    last three functions. `connectedCallback` will fire once we have been attached
    to the DOM. `attributeChangedCallback` will alert us to any attribute changes
    that have occurred. This is very similar to the Proxy API. The last piece lets
    our object know which attributes we specifically care about, in this case, `x`,
    `y`, `type`, `text`, and `show`. Finally, we register our custom component with
    the `customElements.define` method, giving it a name and the class that we want
    to run when one of these objects is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we create our `tooltip`, we can utilize these different properties
    to make a reusable system for `tooltip` or even alerts. The following code demonstrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We should see a floating box with a checkmark and the text Here is our tooltip.
    We can make this `tooltip` a little bit easier to read by utilizing the templating
    system that also comes with the Web Component API.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have a nice reusable `tooltip` element, but we also have quite a bit
    of code along with our style tag that is made up entirely of a templated string.
    What would be best is if we could have this semantic markup put somewhere else
    and have the execution logic in our web component as it is now. This is where
    templates come into play. The `<template>` element will not be displayed on the
    page, but we can still grab it quite easily by giving it an ID. So, one way of
    refactoring our current code would be to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And our JavaScript class constructor should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That is much easier to read and much easier to reason about. We now grab our
    template and get its content. We create a `shadow` object and append our template.
    We need to make sure to clone our template nodes otherwise we will share the same
    reference between all of the elements that we decide to create! One thing you
    will notice is that we cannot now control the text through an attribute. While
    it was interesting to see this behavior, we really want to leave that information
    up to the creator of our `tooltip`. We can do this through the `<slot>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slot gives us an area where we can put HTML in place of that location. We
    can utilize this to allow users of the `tooltip` to put in the markup they want
    for that slot. We could give them a template that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And our implementation may appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the use of the shadow DOM, along with web components and the
    template system in our browser, allows us to create rich elements without the
    need for external libraries such as Bootstrap or Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: We may still need these libraries to provide some base-level styling, but we
    should not need them to the extent we used to. The best-case scenario is that
    we can write all of our own components with styling and not need to utilize external
    libraries. But, seeing as how these systems are relatively new, if we are not
    able to control what our users use, we may be stuck polyfilling.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Fetch API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before the Fetch API, we had to utilize the `XMLHttpRequest` system. To create
    a request for server data, we had to write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, you will notice that the object type is called `XMLHttpRequest`. The
    reason is due to who invented it and the reason behind it. Microsoft had originally
    developed the technique for the Outlook web access product. Originally, they were
    transferring XML documents back and forth, and so they named the object for what
    it was built for. Once other browser vendors, mainly Mozilla, adopted it, they
    decided to keep the name even though its purpose had shifted from just sending
    XML documents to sending any type of response from a server to a client.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we add an event listener to the object. Since this is a plain object
    and not promise-based, we add a listener the old fashioned way with the `addEventListener`
    method. This means we would also clean up the event listener once it has been
    utilized. Next, we open the request, passing in the method we want to send on
    and where we want to send it to. We can then set up a bunch of request headers
    (here specifically, we stipulate that we want application/JSON data and we set
    the `responseType` to `json` so that it will be converted properly by the browser).
    Finally, we send the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we achieve a response, our event will fire and we can retrieve the response
    from the event''s target. Once we get into posting data, it can get even more
    cumbersome. This was the reason for things such as jQuery''s `$.ajax` and such
    methods. It made working with the `XMLHttpRequest` object a lot easier. So what
    does this response look like in terms of the Fetch API? This exact same request
    can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this is quite a bit easier to read and comprehend. First, we
    set up the URL that we want to hit. If we do not pass the action to the `fetch`
    call, it will automatically assume that we are creating a `GET` request. Next,
    we get the response and make sure that we get it in `json`. The responses will
    always come back as a *promise* (more about that in a bit) and so we want to convert
    it to the format that we want, in this case, `json`. From here, we get the final
    object that we are able to set to the `innerHTML` of our content. As we can see
    from this basic example of the two objects, the Fetch API has almost the exact
    same capabilities that we have with `XMLHttpRequest`, but it is in an easier-to-understand
    format and we can easily work with the API.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw with the previous `fetch` example, we utilized something called a
    promise. A simple way to think of a promise is a value that we are going to want
    in the future, and what is returned to us is a contract that states *I will hand
    it to you later*. Promises were based on the concept of callbacks. If we look
    at an example of a callback that we could have wrapped around `XMLHttpRequest`,
    we can see how it functions as a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we get almost the same functionality that we have with a promise
    but utilizing callbacks or functions that we want to run when something happens.
    The problem with a callback system is something known as callback hell. This is
    the idea that highly asynchronous code will always have callbacks and this means
    that if we want to utilize it, we will have a wonderful tree view of callbacks.
    This would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This fake version of `fetch` would be if the API for `fetch` were not promise-based.
    First, we would pass in our URL. We would also need to provide a callback for
    when our response comes back in. We would then need to pass that response to the
    `json` method that would also need a callback to turn the response data into `json`.
    Finally, we would have the result and would put it into our DOM.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, callbacks can lead to quite a few problems. Instead, we have
    the promise. A promise takes a single argument when it is created, a function
    that has two parameters—resolve and reject. With these, we can either give a success
    back to our caller through the `resolve` function, or we can error out with the
    `reject` function. This, in turn, will allow us to chain these promises together
    through `then` calls and the `catch` call, as we can see in our `fetch` example.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, these can also lead to another problem. We can get a giant chain of
    promises that looks a bit better than callbacks, but not by much. We then get
    the `async`/`await` system. Instead of constantly chaining promises with `then`,
    we can use `await` to utilize the response. We can then turn our `fetch` call
    into something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `async` descriptor before the function tells us that this is an `async`
    function. We cannot utilize `await` if we do not have this. Next, instead of chaining
    `then` functions together, we can just `await` the function. The result is what
    would have been wrapped in our `resolve` function. Now, we have something that
    reads quite well.
  prefs: []
  type: TYPE_NORMAL
- en: We do need to be careful with the `async`/`await` system. It does actually wait,
    so if we put this on the main thread or do not have this wrapped in something,
    it can block the main thread, causing us to lock up. Also, if we have a bunch
    of tasks that we want to run at the same time, instead of awaiting them one at
    a time (making our code sequential), we can utilize `Promise.all()`. This allows
    us to put a bunch of promises together and allows them all to run asynchronously.
    Once they all return, we can continue execution.
  prefs: []
  type: TYPE_NORMAL
- en: One nice thing about the `async`/`await` system is that it can actually be faster
    than using generic promises. Many browsers have added optimizations around these
    specific keywords and so we should try to use them at every opportunity we have.
  prefs: []
  type: TYPE_NORMAL
- en: It has been stated before, but browser vendors are constantly making improvements
    to their implementations of the ECMAScript standard. This means that new technologies
    will be slow at first, but once they are in widespread use or they are agreed
    upon by all vendors, they will start to optimize and usually make them faster
    than their counterparts. When possible, utilize the newer technologies that browser
    vendors are giving us!
  prefs: []
  type: TYPE_NORMAL
- en: Back to fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now that we have seen what a `fetch` request looks like, we should take a
    look at grabbing the underlying readable stream. The `fetch` system has been adding
    quite a few features, two of these being piping and streaming. This can be seen
    in a lot of recent web APIs and it can be observed that browser vendors have taken
    notice of how Node.js has gone about utilizing streams.
  prefs: []
  type: TYPE_NORMAL
- en: Streams, as stated in a previous chapter, are a way of handling chunks of data
    at a time. It also makes sure that we do not have to grab the entire payload at
    once, and instead, we can slowly build up the payload. This means that if we have
    to transform the data, we can do it on the fly as the blocks of data are coming
    in. It also means that we can work on data types that are not common, such as
    JSON and plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a basic example of a `TransformStream` that takes our input and
    does a simple ROT13 encoding to it (ROT13 is a very basic encoder that takes the
    thirteenth letter after the one that we get). We will be going into streams in
    much more detail later (these will be the Node.js version, but the concepts are
    relatively similar). The example looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's break this example down into the actual `TransformStream` and then the
    code that utilizes it. First, we create a class that is going to house our rotation
    code. We then need a method called `transform` that takes two parameters, the
    chunk, and the controller. The chunk is the data that we are going to get.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this is not going to get the data all at once so if we needed
    to build objects or the like, we would need to create a possible holding location
    for previous data if the current chunk doesn't give us everything we want. In
    our case, we are simply running a rotation scheme on the underlying bytes so we
    don't need to have a temporary holder.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the controller is the underlying system for both flow control and for
    stating that the data is either ready to be read from (a Readable or Transform
    stream) or written to (a Writable stream). We next await some data and put it
    in a temporary variable. We then run a simple map expression over each of the
    bytes and rotate them 13 to the right and then mod them by 26.
  prefs: []
  type: TYPE_NORMAL
- en: ASCII convention has all the uppercase characters starting at 65\. This is the
    reason for some of the math involved here as we are trying to get the number between
    0 and 26 first, do the operations, and then move it back into the normal ASCII
    range.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have rotated our input, we enqueue it on the controller. This means
    that the data is ready to be read from another stream. Next, we can look at the
    series of promises that occur. First, we get our data. We then grab the underlying
    `ReadableStream` from the `fetch` request by grabbing the body of it. We then
    utilize a method called `pipeThrough`. The piping mechanism automatically handles
    flow control for us so it makes our lives easier when working with streams.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control is vital to making streams work. It essentially tells other streams
    if we are backed up, don't send us any more data, or that we are good to keep
    receiving data. If we did not have this mechanism, we would constantly be having
    to keep our streams in check, which can be a real pain when we just want to focus
    on the logic that we want to incorporate.
  prefs: []
  type: TYPE_NORMAL
- en: We pipe the data into a new `TransformStream` that takes our rotation logic.
    This will now pipe all of the data from the response into our transforming code
    and make sure that it comes out transformed. We then wrap our `ReadableStream`
    in a new `Response` so we can work with it just like any other `Response` object
    from a `fetch` request. We then grab the data as normal text and put it in our
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this example showcases that we can do a lot of cool things with
    the streaming system. While the DOM API is still in flux, these concepts are similar
    to the streaming interface in Node.js. It also showcases how we could possibly
    write decoders for more complicated binary types that may come over the wire such
    as the smile format.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping fetch requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One action that we may want to do when making requests is to stop them. This
    could be for a multitude of reasons, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: First, if we make a request in the background and we let a user update parameters
    for a `POST` request, we may want to stop the current request and let them make
    the new one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, a request could be taking too long and we want to make sure that we
    stop the request instead of hanging the application or getting it into an unknown
    state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we may have a caching mechanism that is set up and, once we are done
    caching a large amount of data, we want to use that. If this happens, we want
    to stop any pending requests and have it switch over to that source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any of these reasons are great for stopping a request and now we have an API
    that can do this. The `AbortController` system allows us to stop these requests.
    What happens is that `AbortController` has a `signal` property. We attach this
    `signal` to the `fetch` request and when we call the `abort` method, it tells
    the `fetch` request that we do not want it to keep going with the request. It
    is very simple and intuitive. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have set up an `AbortController` system and grabbed its `signal`
    property. We then set up a button that, when clicked, will run the `abort` method.
    Next, we see the typical `fetch` request, but inside the options, we pass the
    `signal`. Now, when we click the button, we will see that the request stops with
    a DOM error. We also see a bit of error handling in terms of `async`/`await`.
    `aysnc`/`await` can utilize basic `try-catch` statements to get to an error, just
    another way that the `async`/`await` API makes the code more readable than both
    the callback and the promise-based versions.
  prefs: []
  type: TYPE_NORMAL
- en: This is another API that is experimental and will most likely have changes in
    the future. But, we did have this same type of idea in `XMLHttpRequest` and it
    makes sense that the Fetch API will be getting it also. Just note that the MDN
    website is the best place to get up-to-date information on what browsers support
    and more documentation on any of the experimental APIs that we have discussed
    and will discuss in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch` and promise system is a great way to get data from the server and
    to showcase the new way of handling asynchronous traffic. While we used to have
    to utilize callbacks and some nasty-looking objects, we now have a nice streamlined
    API that is quite easy to use. Even though parts of the API are in flux, just
    note that these systems are most likely going to be in place one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how much of the browser environment has changed
    over the past 5 years. With new APIs that have enhanced the way we code, through
    to the DOM APIs that have allowed us to write rich UIs with built-in controls,
    we are now able to become as vanilla as possible with our applications. This includes
    the use of fetching external data, along with the new asynchronous APIs such as
    promises and the `async`/`await` system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at a library that focuses on outputting
    vanilla JavaScript and giving us a no runtime application environment. We will
    also be incorporating most of the modern APIs into the rest of the book when we
    talk about nodes and workers. Play around with these systems and get comfortable
    with them because we are just getting started.
  prefs: []
  type: TYPE_NORMAL
