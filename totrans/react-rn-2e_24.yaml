- en: Handling Application State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From early on in this book, you've been using state to control your React components.
    State is an important concept in any React application because it controls what
    the user can see and interact with. Without state, you just have a bunch of empty
    React components.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll learn about Flux and how it can serve as the basis of
    your information architecture. Then, you'll learn how to build an architecture
    that best serves web and mobile architectures. You'll also be introduced to the
    Redux library, followed by a discussion on the limitations of React architectures
    and how you might overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: Information architecture and Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be difficult to think of user interfaces as information architectures.
    More often, you get a rough idea of how the UI should look and behave, and then
    you implement it. I do this all the time, and it's a great way to get the ball
    rolling, to discover issues with your approach early, and so on. But then I like
    to take a step back and picture what's happening without any widgets. Inevitably,
    what I've built is flawed in terms of how state flows through the various components.
    This is fine; at least I have something to work with now. I just have to make
    sure that I address the information architecture before building too much.
  prefs: []
  type: TYPE_NORMAL
- en: Flux is a set of patterns created by Facebook that helps developers think about
    their information architecture in a way that fits in naturally with their apps.
    I'll go over the key concepts of Flux next so that you can apply these ideas to
    a unified React architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Unidirectionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this book, I introduced the container pattern for React components.
    The container component has state, but it doesn't actually render any UI elements.
    Instead, it renders other React components and passes in its state as properties.
    Whenever the container state changes, the child components are re-rendered with
    new property values. This is unidirectional data flow.
  prefs: []
  type: TYPE_NORMAL
- en: Flux takes this idea and applies it to something called a store. A **store**
    is an abstract concept that holds application state. As far as I'm concerned,
    a React container is a perfectly valid Flux store. I'll have more to say about
    stores in a moment. First, I want you to understand why unidirectional data flows
    are advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: There's a good chance that you've implemented a UI component that changes state,
    but you're not always sure how it happens. Was it the result of some event in
    another component? Was it a side-effect from some network call completing? When
    that happens, you spend lots of time chasing down where the update came from.
    The effect is often a cascading game of whack-a-mole. When changes can only come
    from one direction, you can eliminate a number of other possibilities, thus, making
    the architecture as a whole more predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous update rounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you change the state of a React container, it will re-render its children,
    who re-render their children, and so on. In Flux terminology, this is called an
    *update round*. From the time state changes to the time that the UI elements reflect
    this change, this is the boundary of the round. It's nice to be able to group
    the dynamic parts of application behavior into larger chunks like this because
    it's easier to reason about cause and effect.
  prefs: []
  type: TYPE_NORMAL
- en: A potential problem with React container components is that they can interweave
    with one another and render in a non-deterministic order. For example, what if
    some API call completes and causes a state update to happen before the rendering
    has completed in another update round? The side effects of asynchronicity can
    accumulate and morph into unsustainable architectures if not taken seriously.
  prefs: []
  type: TYPE_NORMAL
- en: The solution in Flux architectures is to enforce synchronous update rounds,
    and to treat attempts to sidestep the update round order as an error. JavaScript
    is a single-threaded, run-to-completion environment that should be embraced by
    working with it rather than against it. Update the whole UI, and then update the
    whole UI again. It turns out that React is a really good tool for this job.
  prefs: []
  type: TYPE_NORMAL
- en: Predictable state transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a Flux architecture, you havea store used to hold application state. You
    know that, when state changes, it happens synchronously and unidirectionally,
    making the system as a whole more predictable and easy to reason about. However,
    there's still one more thing you can do to ensure that side effects aren't introduced.
  prefs: []
  type: TYPE_NORMAL
- en: You're keeping all your application state in a store, which is great, but you
    can still break things by mutating data in other places. These mutations might
    seem innocent at first glance, but they're toxic to your architecture. For example,
    the callback function that handles a `fetch()` call might manipulate the data
    before passing it to the store. An event handler might generate some structure
    and pass it to the store. There are limitless possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with performing these state transformations outside the store is
    that you don''t necessarily know that they''re happening. Think of mutating data
    as the butterfly effect: one small change has far-reaching consequences that aren''t
    obvious at first. The solution is to only mutate state in the store, without exception.
    It''s predictable and easy to trace the cause and effect of your React architecture
    this way.'
  prefs: []
  type: TYPE_NORMAL
- en: I've been using `Immutable.js` for state in most of the examples throughout
    the book. This will come in handy when you're thinking about state transformations
    in Flux architecture on a large scale. Controlling where state transformations
    take place is important, but so is state immutability. It helps to enforce the
    ideas of Flux architecture, and you'll learn about these ideas in more depth momentarily
    when we look at Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Unified information architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a moment to recap the ingredients of our application architecture
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '**React Web**: Applications that run in web browsers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React Native**: Applications that run natively on mobile platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flux**: Patterns for scalable data in React applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, React is just an abstraction that sits on top of a render target.
    The two main render targets are browsers and mobile native. This list will likely
    grow, so it's up to you to design your architecture in a way that doesn't exclude
    future possibilities. The challenge is that you're not porting a web application
    to a native mobile application; they're different applications, but they serve
    the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, is there a way that you can still have some kind of unified
    information architecture based on ideas from Flux that can be used by these different
    applications? The best answer I can come up with, unfortunately, is: sort of.
    You don''t want to let the different web and mobile user experiences lead to drastically
    different approaches in handling state. If the goals of the applications are the
    same, then there has to be some common information that you can share, using the
    same Flux concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: The difficult part is the fact that web and native mobile are different experiences,
    which means that the shape of your application state will be different. It has
    to be different; otherwise, you would just be porting from one platform to the
    other, which defeats the purpose of using React Native to leverage capabilities
    that don't exist in browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll use a library called Redux to implement a basic application that demonstrates
    the Flux architecture. Redux doesn't strictly follow the patterns set forth by
    Flux. Instead, it borrows key ideas from Flux, and implements a small API to make
    it easy to implement Flux.
  prefs: []
  type: TYPE_NORMAL
- en: The application itself will be a newsreader, a specialized reader for hipsters
    that you probably haven't heard of. It's a simple app, but I want to highlight
    the architectural challenges as I walk through the implementation. Even simple
    apps get complex when you're paying attention to what's going on with the data.
  prefs: []
  type: TYPE_NORMAL
- en: You're going to implement two versions of this app. You'll start with the web
    version, and then you'll implement mobile—native apps for iOS and Android. You'll
    see how you can share architectural concepts between your apps. This lowers the
    conceptual overhead when you need to implement the same application on several
    platforms. You're implementing two apps right now, but this will likely be more
    in the future as React expands its rendering capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I urge you to download the code samples for this book from [https://github.com/PacktPublishing/React-and-React-Native-Second-Edition](https://github.com/PacktPublishing/React-and-React-Native-Second-Edition).
    There are a lot of little details that I simply do not have room to cover in this
    book, especially for these example apps we're about to look at.
  prefs: []
  type: TYPE_NORMAL
- en: Initial application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the initial state of the Flux store. In Redux, the
    entire state of the application is represented by a single store. Here''s what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This module exports an `Immutable.js Map` instance. You'll see why later on.
    But for now, let's look at the organization of this state. In Redux, you divide
    up application state by slices. In this case, it's a simple application, so the
    store only has three slices of state. Each slice of state is mapped to a major
    application feature.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `Home` key represents a state that's used by the `Home` component
    of your app. It's important to initialize any state, even if it's an empty object
    or array, so that your components have initial properties. Now let's use some
    Redux functions to create a  store that's used to get data to your React components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial state is useful when the application first starts. This is enough
    to render components, but that's about it. Once the user starts interacting with
    the UI, you need a way to change the state of the store. In Redux, you assign
    a reducer function to each slice of state in your store. So, for example, your
    app would have a `Home` reducer, an `App` reducer, and an `Article` reducer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key concept of a reducer in Redux is that it''s pure and side-effect free.
    This is where having `Immutable.js` structures as state comes in handy. Let''s
    see how to tie your initial state to the reducer functions that will eventually
    change the state of our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `App`, `Home`, and `Article` functions are named in exactly the same way
    as the slice of state that they manipulate. This makes it easier to add new states
    and reducer functions as the application grows.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a Redux store that's ready to go. But you still haven't hooked
    it up to the React components that actually render state. Let's take a look at
    how to do this now.
  prefs: []
  type: TYPE_NORMAL
- en: Store provider and routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux has a `Provider` component (technically, it's the `react-redux` package
    that provides it) that's used to wrap the top-level components of your application.
    This will ensure that Redux store data is available to every component in your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the hipster newsreader app you''re developing, you''ll wrap the `Router`
    component with a `Provider` component. Then, as you build your components, you
    know that store data will be available. Here''s what the `Root` component looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The store that you created by taking initial state and combining it with reducer
    functions is passed to `<Provider>`. This means that, when your reducers cause
    the Redux store to change, the store data is automatically passed to each application
    component. We'll take a look at the `App` component next.
  prefs: []
  type: TYPE_NORMAL
- en: The App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `App` component includes the page heading and a list of links to various
    article categories. When the user moves around the user interface, the `App` component
    is always rendered, but each `<Route>` element renders different content based
    on the current route. Let''s take a look at the component, and then we''ll break
    down how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This component requires a `title` property and a `links` property. Both of these
    values are actually states that come from the Redux store. Note that it's exporting
    a higher-order component, created using the `connect()` function. This function
    accepts a callback function that transforms the store state into properties that
    the component needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you need the `App` state. Turning this map into a plain JavaScript
    object is done using the `toJS()` method. This is how Redux state is passed to
    components. Here''s what the rendered content of the `App` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/85d4cac5-eed4-49e3-a5d2-3886db1b8c91.png)'
  prefs: []
  type: TYPE_IMG
- en: Ignore the amazing article titles for a moment; we'll return to these briefly.
    The title and the category links are rendered by the `App` component. The article
    titles are rendered by a one of the `<Route>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the All category is bold? This is because it''s the currently selected
    category. If the Local category is selected, the All text will go back to regular
    font, and the Local text will be emboldened. This is all controlled through the
    Redux state. Let''s take a look at the `App` reducer function now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are two points I'd like to make about this reducer logic. First, you can
    now see how having immutable data structures in place makes this code concise
    and easy to follow. Second, a lot of state handling happens here in response to
    simple actions. Take the `FETCHING_ARTICLE` and `FETCHING_ARTICLES` actions, for
    example. You want to change the UI before actually issuing a network request.
    I think this type of explicitness is the real value of Flux and Redux. You know
    exactly why something changes. It's explicit, but not verbose.
  prefs: []
  type: TYPE_NORMAL
- en: The Home component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last major piece of the Redux architecture that's missing from this picture
    is the action creator functions. These are called by components in order to dispatch
    payloads to the Redux store. The end result of dispatching any action is a change
    in state. However, some actions need to go and fetch state before they can be
    dispatched to the store as a payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `Home` component of the `Neckbeard News` app. It''ll show
    you how you can pass along action creator functions when wiring up components
    to the Redux store. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's focus on the `connect()` function, which is used to connect the `Home`
    component to the store. The first argument is a function that takes relevant state
    from the store and returns it as `props` for this component. It's using `ownProps`
    so that you can pass `props` directly to the component and override anything from
    the store. The `filter` property is why we need this capability.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is a function that returns action creator functions as `props`.
    The `dispatch()` function is how these action creator functions are able to deliver
    payloads to the store. For example, the `toggleArticle()` function is a call directly
    to `dispatch()`, and is called in response to the user clicking the article title.
    However, the `fetchingArticles()` call involves asynchronous behavior. This means
    that `dispatch()` isn't called until the `fetch()` promise resolves. It's up to
    you to make sure that nothing unexpected happens in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s wrap things up by looking at the reducer function used with the `Home`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The same technique of using a type map to change state based on the action type
    is used here. Once again, this code is easy to reason about, yet everything that
    can change in the system is explicit.
  prefs: []
  type: TYPE_NORMAL
- en: State in mobile apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What about using Redux in React Native mobile apps? Of course you should, if
    you're developing the same application for the web and for native platforms. In
    fact, I've implemented `Neckbeard News` in React Native for both iOS and Android.
    I encourage you to download the code for this book and get this application running
    for both web and native mobile.
  prefs: []
  type: TYPE_NORMAL
- en: 'There really is no difference in how you actually use Redux in a mobile app.
    The only difference is in the shape of state that''s used. In other words, don''t
    think that you can use the exact same Redux store and reducer functions in the
    web and native versions of your app. Think about React Native components. There''s
    no one-size-fits-all component for many things. You have some components that
    are optimized for the iOS platform while others are optimized for the Android
    platform. It''s the same idea with Redux state. Here''s what the initial state
    looks like for mobile `Neckbeard News`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the same principles that apply in a Web context apply here in
    a mobile context. It's just the state itself that differs, in order to support
    the given components we're using and the unique ways that you're using them to
    implement your application.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you probably have a pretty good hands on Flux concepts, the mechanisms
    of Redux, and how they're used to implement sound information architectures for
    React applications. The question then becomes, How sustainable is this approach,
    and can it handle arbitrarily large and complex applications?
  prefs: []
  type: TYPE_NORMAL
- en: I think Redux is a great way to implement large-scale React applications. You
    can predict what's going to happen as the result of any given action because everything
    is explicit. It's declarative. It's unidirectional and without side effects. But
    it isn't without challenges.
  prefs: []
  type: TYPE_NORMAL
- en: The limiting factor with Redux is also its bread and butter; because everything
    is explicit, applications that need to scale up, in terms of feature count and
    complexity, ultimately end up with more moving parts. There's nothing wrong with
    this; it's just the nature of the game. The unavoidable consequence of scaling
    up is slowing down. You simply cannot grasp enough of the big picture in order
    to implement things quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final two chapters of this book, we''re going to look at a related but
    different approach to Flux: Relay/GraphQL. I think this technology can scale in
    ways that Redux cannot.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Flux, a set of architectural patterns that
    aid in building information architecture for your React application. The key ideas
    with Flux involve unidirectional data flow, synchronous update rounds, and predictable
    state transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I walked through a detailed implementation of a Redux / React application.
    Redux provides a simplified implementation of Flux ideas. The benefit is predictability
    everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned whether or not Redux has what it takes to build scalable architectures
    for our React applications. The answer is yes, for the most part. For the remainder
    of this book, however, you're going to explore Relay and GraphQL to see whether these
    technologies can scale your applications to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following best describes Flux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux is an architectural pattern used to augment the properties of DOM elements,
    making it easier to get API data into your HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux is an architectural pattern used to control the unidirectional flow of
    data in your app, making changes more predictable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux is a library that handles all of your application state for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between Flux and Redux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no difference, they both represent the same architectural pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux is the official way to handle state in React components whereas Redux is
    something to avoid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redux is an opinionated implementation of Flux concepts that you can use to
    help manage data flow in your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you get data from a Redux store into your components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the `connect()` higher-order function to connection your component to
    the store, using a function that translates store data into component properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You extend `Redux.Component` to automatically have state from the Redux store
    set on your component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can access state at any time from the global `store` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between Redux in a web app and a native mobile app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's a specific `redux-react-native` package that you should use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no difference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, check out the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://redux.js.org/](https://redux.js.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/flux/](https://facebook.github.io/flux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
