- en: Chapter 2. Building Microservices with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing microservices is not so tedious anymore thanks to the powerful Spring
    Boot framework. Spring Boot is a framework to develop production-ready microservices
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will move from the microservices theory explained in the previous
    chapter to hands-on practice by reviewing code samples. This chapter will introduce
    the Spring Boot framework and explain how Spring Boot can help build RESTful microservices
    in line with the principles and characteristics discussed in the previous chapter.
    Finally, some of the features offered by Spring Boot to make microservices production-ready
    will be reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the latest Spring development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing RESTful services using the Spring framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Boot to build fully qualified microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful Spring Boot features to build production-ready microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To crystalize microservices concepts, a couple of microservices will be built.
    For this, it is assumed that the following components are installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JDK 1.8**: [http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Tool Suite 3.7.2** (**STS**): [https://spring.io/tools/sts/all](https://spring.io/tools/sts/all)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven 3.3.1**: [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternately, other IDEs such as IntelliJ IDEA, NetBeans, or Eclipse could be
    used. Similarly, alternate build tools such as Gradle can be used. It is assumed
    that the Maven repository, class path, and other path variables are set properly
    to run STS and Maven projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is based on the following versions of Spring libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework `4.2.6.RELEASE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot `1.3.5.RELEASE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Have a look.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Spring-Microservices](https://github.com/PacktPublishing/Spring-Microservices).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  prefs: []
  type: TYPE_NORMAL
- en: Developing a RESTful service – the legacy approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example will review the traditional RESTful service development before
    jumping deep into Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: STS will be used to develop this REST/JSON service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `legacyrest` project
    in the code files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to develop the first RESTful service:'
  prefs: []
  type: TYPE_NORMAL
- en: Start STS and set a workspace of choice for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **File** | **New** | **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Spring Legacy Project** as shown in the following screenshot and click
    on **Next**:![Developing a RESTful service – the legacy approach](img/B05447_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Spring MVC Project** as shown in the following diagram and click on
    **Next**:![Developing a RESTful service – the legacy approach](img/B05447_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a top-level package name of choice. This example uses `org.rvslab.chapter2.legacyrest`
    as the top-level package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a project in the STS workspace with the name `legacyrest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before proceeding further, `pom.xml` needs editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the Spring version to `4.2.6.RELEASE`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Add **Jackson** dependencies in the `pom.xml` file for JSON-to-POJO and POJO-to-JSON
    conversions. Note that the `2.*.*` version is used to ensure compatibility with
    Spring 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Some Java code needs to be added. In **Java Resources**, under **legacyrest**,
    expand the package and open the default **HomeController.java** file:![Developing
    a RESTful service – the legacy approach](img/B05447_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The default implementation is targeted more towards the MVC project. Rewriting
    `HomeController.java` to return a JSON value in response to the REST call will
    do the trick. The resulting `HomeController.java` file will look similar to the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the code, there are now two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Greet`: This is a simple Java class with getters and setters to represent
    a data object. There is only one attribute in the `Greet` class, which is `message`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HomeController.java`: This is nothing but a Spring controller REST endpoint
    to handle HTTP requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the annotation used in `HomeController` is `@RestController`, which
    automatically injects `@Controller` and `@ResponseBody` and has the same effect
    as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The project can now be run by right-clicking on **legacyrest**, navigating to
    **Run As** | **Run On Server**, and then selecting the default server (**Pivotal
    tc Server Developer Edition v3.1**) that comes along with STS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should automatically start the server and deploy the web application on
    the TC server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server started properly, the following message will appear in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If everything is fine, STS will open a browser window to `http://localhost:8080/legacyrest/`
    and display the JSON object as shown in the browser. Right-click on and navigate
    to **legacyrest** | **Properties** | **Web Project Settings** and review **Context
    Root** to identify the context root of the web application:![Developing a RESTful
    service – the legacy approach](img/B05447_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The alternate build option is to use Maven. Right-click on the project and navigate
    to **Run As** | **Maven install**. This will generate `chapter2-1.0.0-BUILD-SNAPSHOT.war`
    under the target folder. This war is deployable in any servlet container such
    as Tomcat, JBoss, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Moving from traditional web applications to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Carefully examining the preceding RESTful service will reveal whether this really
    constitutes a microservice. At first glance, the preceding RESTful service is
    a fully qualified interoperable REST/JSON service. However, it is not fully autonomous
    in nature. This is primarily because the service relies on an underlying application
    server or web container. In the preceding example, a war was explicitly created
    and deployed on a Tomcat server.
  prefs: []
  type: TYPE_NORMAL
- en: This is a traditional approach to developing RESTful services as a web application.
    However, from the microservices point of view, one needs a mechanism to develop
    services as executables, self-contained JAR files with an embedded HTTP listener.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is a tool that allows easy development of such kinds of services.
    Dropwizard and WildFly Swarm are alternate server-less RESTful stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Boot to build RESTful microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot is a utility framework from the Spring team to bootstrap Spring-based
    applications and microservices quickly and easily. The framework uses an opinionated
    approach over configurations for decision making, thereby reducing the effort
    required in writing a lot of boilerplate code and configurations. Using the 80-20
    principle, developers should be able to kickstart a variety of Spring applications
    with many default values. Spring Boot further presents opportunities for the developers
    to customize applications by overriding the autoconfigured values.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot not only increases the speed of development but also provides a
    set of production-ready ops features such as health checks and metrics collection.
    As Spring Boot masks many configuration parameters and abstracts many lower-level
    implementations, it minimizes the chance of error to a certain extent. Spring
    Boot recognizes the nature of the application based on the libraries available
    in the class path and runs the autoconfiguration classes packaged in these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, many developers mistakenly see Spring Boot as a code generator, but
    in reality, it is not. Spring Boot only autoconfigures build files—for example,
    POM files in the case of Maven. It also sets properties, such as data source properties,
    based on certain opinionated defaults. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For instance, in the preceding case, Spring Boot understands that the project
    is set to use the Spring Data JPA and HSQL databases. It automatically configures
    the driver class and other connection parameters.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great outcomes of Spring Boot is that it almost eliminates the need
    to have traditional XML configurations. Spring Boot also enables microservices'
    development by packaging all the required runtime dependencies in a fat executable
    JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different ways that Spring Boot-based application development can
    be started:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Spring Boot CLI as a command-line tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IDEs such as STS to provide Spring Boot, which are supported out of the
    box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Spring Initializr project at [http://start.spring.io](http://start.spring.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these three options will be explored in this chapter, developing a variety
    of sample services.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Spring Boot microservice using the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to develop and demonstrate Spring Boot''s capabilities is using
    the Spring Boot CLI, a command-line tool. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Spring Boot command-line tool by downloading the `spring-boot-cli-1.3.5.RELEASE-bin.zip`
    file from [http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.5.RELEASE/spring-boot-cli-1.3.5.RELEASE-bin.zip](http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.5.RELEASE/spring-boot-cli-1.3.5.RELEASE-bin.zip).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the file into a directory of your choice. Open a terminal window and change
    the terminal prompt to the `bin` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the `bin` folder is added to the system path so that Spring Boot
    can be run from any location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the installation with the following command. If successful, the Spring
    CLI version will be printed in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As the next step, a quick REST service will be developed in Groovy, which is
    supported out of the box in Spring Boot. To do so, copy and paste the following
    code using any editor of choice and save it as `myfirstapp.groovy` in any folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run this Groovy application, go to the folder where `myfirstapp.groovy`
    is saved and execute the following command. The last few lines of the server start-up
    log will be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a browser window and go to `http://localhost:8080`; the browser will display
    the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hello World!**'
  prefs: []
  type: TYPE_NORMAL
- en: There is no war file created, and no Tomcat server was run. Spring Boot automatically
    picked up Tomcat as the webserver and embedded it into the application. This is
    a very basic, minimal microservice. The `@RestController` annotation, used in
    the previous code, will be examined in detail in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Spring Boot Java microservice using STS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, developing another Java-based REST/JSON Spring Boot service
    using STS will be demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.bootrest`
    project in the code files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Open STS, right-click within the **Project Explorer** window, navigate to **New**
    | **Project**, and select **Spring Starter Project**, as shown in the following
    screenshot, and click on **Next**:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Starter Project is a basic template wizard that provides a number of
    other starter libraries to select from.
  prefs: []
  type: TYPE_NORMAL
- en: Type the project name as `chapter2.bootrest` or any other name of your choice.
    It is important to choose the packaging as JAR. In traditional web applications,
    a war file is created and then deployed to a servlet container, whereas Spring
    Boot packages all the dependencies to a self-contained, autonomous JAR file with
    an embedded HTTP listener.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select 1.8 under **Java Version**. Java 1.8 is recommended for Spring 4 applications.
    Change the other Maven properties such as **Group**, **Artifact**, and **Package**,
    as shown in the following screenshot:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once completed, click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The wizard will show the library options. In this case, as the REST service
    is developed, select **Web** under **Web**. This is an interesting step that tells
    Spring Boot that a Spring MVC web application is being developed so that Spring
    Boot can include the necessary libraries, including Tomcat as the HTTP listener
    and other configurations, as required:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will generate a project named `chapter2.bootrest` in **Project Explorer**
    in STS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing the Spring Boot Java microservice using STS](img/B05447_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Take a moment to examine the generated application. Files that are of interest
    are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pom.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationTests.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the POM file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parent element is one of the interesting aspects in the `pom.xml` file.
    Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `spring-boot-starter-parent` pattern is a **bill of materials** (**BOM**),
    a pattern used by Maven's dependency management. BOM is a special kind of POM
    file used to manage different library versions required for a project. The advantage
    of using the `spring-boot-starter-parent` POM file is that developers need not
    worry about finding the right compatible versions of different libraries such
    as Spring, Jersey, JUnit, Logback, Hibernate, Jackson, and so on. For instance,
    in our first legacy example, a specific version of the Jackson library was added
    to work with Spring 4\. In this example, these are taken care of by the `spring-boot-starter-parent`
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The starter POM file has a list of Boot dependencies, sensible resource filtering,
    and sensible plug-in configurations required for the Maven builds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [https://github.com/spring-projects/spring-boot/blob/1.3.x/spring-boot-dependencies/pom.xml](https://github.com/spring-projects/spring-boot/blob/1.3.x/spring-boot-dependencies/pom.xml)
    to take a look at the different dependencies provided in the starter parent (version
    1.3.x). All these dependencies can be overridden if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starter POM file itself does not add JAR dependencies to the project. Instead,
    it will only add library versions. Subsequently, when dependencies are added to
    the POM file, they refer to the library versions from this POM file. A snapshot
    of some of the properties are as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Reviewing the dependency section, one can see that this is a clean and neat
    POM file with only two dependencies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As web is selected, `spring-boot-starter-web` adds all dependencies required
    for a Spring MVC project. It also includes dependencies to Tomcat as an embedded
    HTTP listener. This provides an effective way to get all the dependencies required
    as a single bundle. Individual dependencies could be replaced with other libraries,
    for example replacing Tomcat with Jetty.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to web, Spring Boot comes up with a number of `spring-boot-starter-*`
    libraries, such as `amqp`, `aop`, `batch`, `data-jpa`, `thymeleaf`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to be reviewed in the `pom.xml` file is the Java 8 property.
    By default, the parent POM file adds Java 6\. It is recommended to override the
    Java version to 8 for Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Examining Application.java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Boot, by default, generated a `org.rvslab.chapter2.Application.java`
    class under `src/main/java` to bootstrap, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is only a `main` method in `Application`, which will be invoked at startup
    as per the Java convention. The `main` method bootstraps the Spring Boot application
    by calling the `run` method on `SpringApplication`. `Application.class` is passed
    as a parameter to tell Spring Boot that this is the primary component.
  prefs: []
  type: TYPE_NORMAL
- en: 'More importantly, the magic is done by the `@SpringBootApplication` annotation.
    The `@SpringBootApplication` annotation is a top-level annotation that encapsulates
    three other annotations, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `@Configuration` annotation hints that the contained class declares one
    or more `@Bean` definitions. The `@Configuration` annotation is meta-annotated
    with `@Component`; therefore, it is a candidate for component scanning.
  prefs: []
  type: TYPE_NORMAL
- en: The `@EnableAutoConfiguration` annotation tells Spring Boot to automatically
    configure the Spring application based on the dependencies available in the class
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Examining application.properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A default `application.properties` file is placed under `src/main/resources`.
    It is an important file to configure any required properties for the Spring Boot
    application. At the moment, this file is kept empty and will be revisited with
    some test cases later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Examining ApplicationTests.java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last file to be examined is `ApplicationTests.java` under `src/test/java`.
    This is a placeholder to write test cases against the Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the first RESTful service, add a REST endpoint, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One can edit `Application.java` under `src/main/java` and add a RESTful service
    implementation. The RESTful service is exactly the same as what was done in the
    previous project. Append the following code at the end of the `Application.java`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To run, navigate to **Run As** | **Spring Boot App**. Tomcat will be started
    on the `8080` port:![Examining ApplicationTests.java](img/B05447_02_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can notice from the log that:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot get its own process ID (in this case, it is `41130`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot is automatically started with the Tomcat server at the localhost,
    port `8080`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, open a browser and point to `http://localhost:8080`. This will show the
    JSON response as shown in the following screenshot:![Examining ApplicationTests.java](img/B05447_02_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A key difference between the legacy service and this one is that the Spring
    Boot service is self-contained. To make this clearer, run the Spring Boot application
    outside STS. Open a terminal window, go to the project folder, and run Maven,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a fat JAR file under the target folder of the project. Running
    the application from the command line shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As one can see, `bootrest-0.0.1-SNAPSHOT.jar` is self-contained and could be
    run as a standalone application. At this point, the JAR is as thin as 13 MB. Even
    though the application is no more than just "Hello World", the Spring Boot service
    just developed, practically follows the principles of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Spring Boot microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple ways to test REST/JSON Spring Boot microservices. The easiest
    way is to use a web browser or a curl command pointing to the URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are number of tools available to test RESTful services, such as Postman,
    Advanced REST client, SOAP UI, Paw, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, to test the service, the default test class generated by Spring
    Boot will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new test case to `ApplicatonTests.java` results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that `@WebIntegrationTest` is added and `@WebAppConfiguration` removed
    at the class level. The `@WebIntegrationTest` annotation is a handy annotation
    that ensures that the tests are fired against a fully up-and-running server. Alternately,
    a combination of `@WebAppConfiguration` and `@IntegrationTest` will give the same
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that `RestTemplate` is used to call the RESTful service. `RestTemplate`
    is a utility class that abstracts the lower-level details of the HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: To test this, one can open a terminal window, go to the project folder, and
    run `mvn install`.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Spring Boot microservice using Spring Initializr – the HATEOAS
    example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next example, Spring Initializr will be used to create a Spring Boot
    project. Spring Initializr is a drop-in replacement for the STS project wizard
    and provides a web UI to configure and generate a Spring Boot project. One of
    the advantages of Spring Initializr is that it can generate a project through
    the website that then can be imported into any IDE.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the concept of **HATEOAS** (short for **Hypertext As The Engine
    Of Application State**) for REST-based services and the **HAL** (**Hypertext Application
    Language**) browser will be examined.
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS is a REST service pattern in which navigation links are provided as
    part of the payload metadata. The client application determines the state and
    follows the transition URLs provided as part of the state. This methodology is
    particularly useful in responsive mobile and web applications in which the client
    downloads additional data based on user navigation patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The HAL browser is a handy API browser for `hal+json` data. HAL is a format
    based on JSON that establishes conventions to represent hyperlinks between resources.
    HAL helps APIs be more explorable and discoverable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.boothateoas`
    project in the code files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the concrete steps to develop a HATEOAS sample using Spring Initilizr:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use Spring Initilizr, go to [https://start.spring.io](https://start.spring.io):![Developing
    the Spring Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the details, such as whether it is a Maven project, Spring Boot version,
    group, and artifact ID, as shown earlier, and click on **Switch to the full version**
    link under the **Generate Project** button. Select **Web**, **HATEOAS**, and **Rest
    Repositories HAL Browser**. Make sure that the Java version is 8 and the package
    type is selected as **JAR**:![Developing the Spring Boot microservice using Spring
    Initializr – the HATEOAS example](img/B05447_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once selected, hit the **Generate Project** button. This will generate a Maven
    project and download the project as a ZIP file into the download directory of
    the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the file and save it to a directory of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open STS, go to the **File** menu and click on **Import**:![Developing the Spring
    Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Maven** | **Existing Maven Projects** and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Browse** next to **Root Directory** and select the unzipped folder.
    Click on **Finish**. This will load the generated Maven project into STS' **Project
    Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `Application.java` file to add a new REST endpoint, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is the same `GreetingController` class as in the previous example.
    However, a method was added this time named `greeting`. In this new method, an
    additional optional request parameter is defined and defaulted to `HATEOAS`. The
    following code adds a link to the resulting JSON code. In this case, it adds the
    link to the same API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to do this, we need to extend the `Greet` class from `ResourceSupport`,
    as shown here. The rest of the code remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `add` method is a method in `ResourceSupport`. The `linkTo` and `methodOn`
    methods are static methods of `ControllerLinkBuilder`, a utility class for creating
    links on controller classes. The `methodOn` method will do a dummy method invocation,
    and `linkTo` will create a link to the controller class. In this case, we will
    use `withSelfRel` to point it to itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will essentially produce a link, `/greeting?name=HATEOAS`, by default.
    A client can read the link and initiate another call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run this as a Spring Boot app. Once the server startup is complete, point the
    browser to `http://localhost:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open the HAL browser window. In the **Explorer** field, type `/greeting?name=World!`
    and click on the **Go** button. If everything is fine, the HAL browser will show
    the response details as shown in the following screenshot:![Developing the Spring
    Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the screenshot, the **Response Body** section has the result with
    a link with `href` pointing back to the same service. This is because we pointed
    the reference to itself. Also, review the **Links** section. The little green
    box against **self** is the navigable link.
  prefs: []
  type: TYPE_NORMAL
- en: It does not make much sense in this simple example, but this could be handy
    in larger applications with many related entities. Using the links provided, the
    client can easily navigate back and forth between these entities with ease.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of basic Spring Boot examples have been reviewed so far. The rest of
    this chapter will examine some of the Spring Boot features that are important
    from a microservices development perspective. In the upcoming sections, we will
    take a look at how to work with dynamically configurable properties, change the
    default embedded web server, add security to the microservices, and implement
    cross-origin behavior when dealing with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.boot-advanced`
    project in the code files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Boot configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, the focus will be on the configuration aspects of Spring Boot.
    The `chapter2.bootrest` project, already developed, will be modified in this section
    to showcase configuration capabilities. Copy and paste `chapter2.bootrest` and
    rename the project as `chapter2.boot-advanced`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Spring Boot autoconfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Boot uses convention over configuration by scanning the dependent libraries
    available in the class path. For each `spring-boot-starter-*` dependency in the
    POM file, Spring Boot executes a default `AutoConfiguration` class. `AutoConfiguration`
    classes use the `*AutoConfiguration` lexical pattern, where `*` represents the
    library. For example, the autoconfiguration of JPA repositories is done through
    `JpaRepositoriesAutoConfiguration`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application with `--debug` to see the autoconfiguration report. The
    following command shows the autoconfiguration report for the `chapter2.boot-advanced`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of the autoconfiguration classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ServerPropertiesAutoConfiguration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RepositoryRestMvcAutoConfiguration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JpaRepositoriesAutoConfiguration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JmsAutoConfiguration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to exclude the autoconfiguration of certain libraries if the
    application has special requirements and you want to get full control of the configurations.
    The following is an example of excluding `DataSourceAutoConfiguration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Overriding default configuration values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to override default configuration values using the `application.properties`
    file. STS provides an easy-to-autocomplete, contextual help on `application.properties`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overriding default configuration values](img/B05447_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, `server.port` is edited to be set as `9090`. Running
    this application again will start the server on port `9090`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the location of the configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to align with the Twelve-Factor app, configuration parameters need
    to be externalized from the code. Spring Boot externalizes all configurations
    into `application.properties`. However, it is still part of the application''s
    build. Furthermore, properties can be read from outside the package by setting
    the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, `spring.config.location` could be a local file location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command starts the Spring Boot application with an externally
    provided configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Reading custom properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At startup, `SpringApplication` loads all the properties and adds them to the
    Spring `Environment` class. Add a custom property to the `application.properties`
    file. In this case, the custom property is named `bootrest.customproperty`. Autowire
    the Spring `Environment` class into the `GreetingController` class. Edit the `GreetingController`
    class to read the custom property from `Environment` and add a log statement to
    print the custom property to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property to the `application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the `GreetingController` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the application. The log statement prints the custom variable in the
    console, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using a .yaml file for configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an alternate to `application.properties`, one may use a `.yaml` file. YAML
    provides a JSON-like structured configuration compared to the flat properties
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, simply replace `application.properties` with `application.yaml`
    and add the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Rerun the application to see the port printed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple configuration profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Furthermore, it is possible to have different profiles such as development,
    testing, staging, production, and so on. These are logical names. Using these,
    one can configure different values for the same properties for different environments.
    This is quite handy when running the Spring Boot application against different
    environments. In such cases, there is no rebuild required when moving from one
    environment to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `.yaml` file as follows. The Spring Boot group profiles properties
    based on the dotted separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the Spring Boot application as follows to see the use of profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Active profiles can be specified programmatically using the `@ActiveProfiles`
    annotation, which is especially useful when running test cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Other options to read properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The properties can be loaded in a number of ways, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line parameters `(-Dhost.port =9090`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JNDI (`java:comp/env`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the default embedded web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Embedded HTTP listeners can easily be customized as follows. By default, Spring
    Boot supports Tomcat, Jetty, and Undertow. In the following example, Tomcat is
    replaced with Undertow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Spring Boot security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to secure microservices. In this section, some basic measures
    to secure Spring Boot microservices will be reviewed using `chapter2.bootrest`
    to demonstrate the security features.
  prefs: []
  type: TYPE_NORMAL
- en: Securing microservices with basic security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding basic authentication to Spring Boot is pretty simple. Add the following
    dependency to `pom.xml`. This will include the necessary Spring security library
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Application.java` and add `@EnableGlobalMethodSecurity` to the `Application`
    class. This annotation will enable method-level security:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The default basic authentication assumes the user as being `user`. The default
    password will be printed in the console at startup. Alternately, the username
    and password can be added in `application.properties`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new test case in `ApplicationTests` to test the secure service results,
    as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the code, a new `Authorization` request header with Base64 encoding
    the username-password string is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun the application using Maven. Note that the new test case passed, but
    the old test case failed with an exception. The earlier test case now runs without
    credentials, and as a result, the server rejected the request with the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Securing a microservice with OAuth2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will take a look at the basic Spring Boot configuration
    for OAuth2\. When a client application requires access to a protected resource,
    the client sends a request to an authorization server. The authorization server
    validates the request and provides an access token. This access token is validated
    for every client-to-server request. The request and response sent back and forth
    depends on the grant type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read more about OAuth and grant types at [http://oauth.net](http://oauth.net).
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource owner password credentials grant approach will be used in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing a microservice with OAuth2](img/B05447_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, as shown in the preceding diagram, the resource owner provides
    the client with a username and password. The client then sends a token request
    to the authorization server by providing the credential information. The authorization
    server authorizes the client and returns with an access token. On every subsequent
    request, the server validates the client token.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement OAuth2 in our example, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, update `pom.xml` with the OAuth2 dependency, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Next, add two new annotations, `@EnableAuthorizationServer` and `@EnableResourceServer`,
    to the `Application.java` file. The `@EnableAuthorizationServer` annotation creates
    an authorization server with an in-memory repository to store client tokens and
    provide clients with a username, password, client ID, and secret. The `@EnableResourceServer`
    annotation is used to access the tokens. This enables a spring security filter
    that is authenticated via an incoming OAuth2 token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, both the authorization server and resource server are the same.
    However, in practice, these two will run separately. Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following properties to the `application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add another test case to test OAuth2, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, a special REST template, `OAuth2RestTemplate`,
    is created by passing the resource details encapsulated in a resource details
    object. This REST template handles the OAuth2 processes underneath. The access
    token URI is the endpoint for the token access.
  prefs: []
  type: TYPE_NORMAL
- en: Rerun the application using `mvn install`. The first two test cases will fail,
    and the new one will succeed. This is because the server only accepts OAuth2-enabled
    requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are quick configurations provided by Spring Boot out of the box but are
    not good enough to be production grade. We may need to customize `ResourceServerConfigurer`
    and `AuthorizationServerConfigurer` to make them production-ready. This notwithstanding,
    the approach remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling cross-origin access for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browsers are generally restricted when client-side web applications running
    from one origin request data from another origin. Enabling cross-origin access
    is generally termed as **CORS** (**Cross-Origin Resource Sharing**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling cross-origin access for microservices](img/B05447_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example shows how to enable cross-origin requests. With microservices,
    as each service runs with its own origin, it will easily get into the issue of
    a client-side web application consuming data from multiple origins. For instance,
    a scenario where a browser client accessing Customer from the Customer microservice
    and Order History from the Order microservices is very common in the microservices
    world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot provides a simple declarative approach to enabling cross-origin
    requests. The following example shows how to enable a microservice to enable cross-origin
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, all the origins and headers are accepted. We can further customize
    the cross-origin annotations by giving access to specific origins, as follows.
    The `@CrossOrigin` annotation enables a method or class to accept cross-origin
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Global CORS can be enabled using the `WebMvcConfigurer` bean and customizing
    the `addCorsMappings(CorsRegistry registry)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Spring Boot messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an ideal case, all microservice interactions are expected to happen asynchronously
    using publish-subscribe semantics. Spring Boot provides a hassle-free mechanism
    to configure messaging solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Spring Boot messaging](img/B05447_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we will create a Spring Boot application with a sender and
    receiver, both connected though an external queue. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.bootmessaging`
    project in the code files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using STS to demonstrate this capability. In this example,
    instead of selecting **Web**, select **AMQP** under **I/O**:![Implementing Spring
    Boot messaging](img/B05447_02_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rabbit MQ will also be needed for this example. Download and install the latest
    version of Rabbit MQ from [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rabbit MQ 3.5.6 is used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the installation steps documented on the site. Once ready, start the
    RabbitMQ server via the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the configuration changes to the `application.properties` file to reflect
    the RabbitMQ configuration. The following configuration uses the default port,
    username, and password of RabbitMQ:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a message sender component and a queue named `TestQ` of the `org.springframework.amqp.core.Queue`
    type to the `Application.java` file under `src/main/java`. `RabbitMessagingTemplate`
    is a convenient way to send messages, which will abstract all the messaging semantics.
    Spring Boot provides all boilerplate configurations to send messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To receive the message, all that needs to be used is a `@RabbitListener` annotation.
    Spring Boot autoconfigures all the required boilerplate configurations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of this exercise is to wire the sender to our main application
    and implement the `run` method of `CommandLineRunner` to initiate the message
    sending. When the application is initialized, it invokes the `run` method of `CommandLineRunner`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application as a Spring Boot application and verify the output. The
    following message will be printed in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Developing a comprehensive microservice example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the examples we have considered are no more than just a simple "Hello
    world." Putting together what we have learned, this section demonstrates an end-to-end
    Customer Profile microservice implementation. The Customer Profile microservices
    will demonstrate interaction between different microservices. It also demonstrates
    microservices with business logic and primitive data stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, two microservices, the Customer Profile and Customer Notification
    services, will be developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a comprehensive microservice example](img/B05447_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the diagram, the Customer Profile microservice exposes methods to
    **create, read, update, and delete** (**CRUD**) a customer and a registration
    service to register a customer. The registration process applies certain business
    logic, saves the customer profile, and sends a message to the Customer Notification
    microservice. The Customer Notification microservice accepts the message sent
    by the registration service and sends an e-mail message to the customer using
    an SMTP server. Asynchronous messaging is used to integrate Customer Profile with
    the Customer Notification service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Customer microservices class domain model diagram is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a comprehensive microservice example](img/B05447_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`CustomerController` in the diagram is the REST endpoint, which invokes a component
    class, `CustomerComponent`. The component class/bean handles all the business
    logic. `CustomerRepository` is a Spring data JPA repository defined to handle
    the persistence of the `Customer` entity.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.bootcustomer`
    and `chapter2.bootcustomernotification` projects in the code files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Spring Boot project and call it `chapter2.bootcustomer`, the same
    way as earlier. Select the options as in the following screenshot in the starter
    module selection screen:![Developing a comprehensive microservice example](img/B05447_02_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a web project with JPA, the REST repository, and H2 as a database.
    H2 is a tiny in-memory embedded database with which it is easy to demonstrate
    database features. In the real world, it is recommended to use an appropriate
    enterprise-grade database. This example uses JPA to define persistence entities
    and the REST repository to expose REST-based repository services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure will be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a comprehensive microservice example](img/B05447_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Start building the application by adding an Entity class named `Customer`.
    For simplicity, there are only three fields added to the `Customer` Entity class:
    the autogenerated `id` field, `name`, and `email`. Take a look at the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a repository class to handle the persistence handling of Customer. `CustomerRepository`
    extends the standard JPA repository. This means that all CRUD methods and default
    finder methods are automatically implemented by the Spring Data JPA repository,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we added a new method to the repository class, `findByName`,
    which essentially searches the customer based on the customer name and returns
    a `Customer` object if there is a matching name.
  prefs: []
  type: TYPE_NORMAL
- en: The `@RepositoryRestResource` annotation enables the repository access through
    RESTful services. This will also enable HATEOAS and HAL by default. As for CRUD
    methods there is no additional business logic required, we will leave it as it
    is without controller or component classes. Using HATEOAS will help us navigate
    through Customer Repository methods effortlessly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there is no configuration added anywhere to point to any database.
    As H2 libraries are in the class path, all the configuration is done by default
    by Spring Boot based on the H2 autoconfiguration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Application.java` file by adding `CommandLineRunner` to initialize
    the repository with some customer records, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`CommandLineRunner`, defined as a bean, indicates that it should run when it
    is contained in `SpringApplication`. This will insert six sample customer records
    into the database at startup.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, run the application as Spring Boot App. Open the HAL browser
    and point the browser to `http://localhost:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Explorer** section, point to `http://localhost:8080/customers` and
    click on **Go**. This will list all the customers in the **Response Body** section
    of the HAL browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Explorer** section, enter `http://localhost:8080/customers?size=2&page=1&sort=name`
    and click on **Go**. This will automatically execute paging and sorting on the
    repository and return the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the page size is set to `2` and the first page is requested, it will come
    back with two records in a sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: Review the **Links** section. As shown in the following screenshot, it will
    facilitate navigating **first**, **next**, **prev**, and **last**. These are done
    using the HATEOAS links automatically generated by the repository browser:![Developing
    a comprehensive microservice example](img/B05447_02_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, one can explore the details of a customer by selecting the appropriate
    link, such as `http://localhost:8080/customers/2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the next step, add a controller class, `CustomerController`, to handle service
    endpoints. There is only one endpoint in this class, `/register`, which is used
    to register a customer. If successful, it returns the `Customer` object as the
    response, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A `CustomerRegistrar` component is added to handle the business logic. In this
    case, there is only minimal business logic added to the component. In this component
    class, while registering a customer, we will just check whether the customer name
    already exists in the database or not. If it does not exist, then we will insert
    a new record, and otherwise, we will send an error message back, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Restart the Boot application and test using the HAL browser via the URL `http://localhost:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point the **Explorer** field to `http://localhost:8080/customers`. Review the
    results in the **Links** section:![Developing a comprehensive microservice example](img/B05447_02_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **NON-GET** option against **self**. This will open a form to create
    a new customer:![Developing a comprehensive microservice example](img/B05447_02_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the form and change the **Action** as shown in the diagram. Click on the
    **Make Request** button. This will call the register service and register the
    customer. Try giving a duplicate name to test the negative case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's complete the last part in the example by integrating the Customer Notification
    service to notify the customer. When registration is successful, send an e-mail
    to the customer by asynchronously calling the Customer Notification microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First update `CustomerRegistrar` to call the second service. This is done through
    messaging. In this case, we injected a `Sender` component to send a notification
    to the customer by passing the customer''s e-mail address to the sender, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The sender component will be based on RabbitMQ and AMQP. In this example, `RabbitMessagingTemplate`
    is used as explored in the last messaging example; take a look at the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `@Lazy` annotation is a useful one and it helps to increase the boot startup
    time. These beans will be initialized only when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also update the `application.property` file to include Rabbit MQ-related
    properties, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to send the message. To consume the message and send e-mails, we
    will create a notification service. For this, let's create another Spring Boot
    service, `chapter2.bootcustomernotification`. Make sure that the **AMQP** and
    **Mail** starter libraries are selected when creating the Spring Boot service.
    Both **AMQP** and **Mail** are under **I/O**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package structure of the `chapter2.bootcustomernotification` project is
    as shown here:![Developing a comprehensive microservice example](img/B05447_02_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Receiver` class. The `Receiver` class waits for a message on customer.
    This will receive a message sent by the Customer Profile service. On the arrival
    of a message, it sends an e-mail, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another component to send an e-mail to the customer. We will use `JavaMailSender`
    to send an e-mail via the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, Spring Boot automatically configures all the parameters required
    by `JavaMailSender`.
  prefs: []
  type: TYPE_NORMAL
- en: To test SMTP, a test setup for SMTP is required to ensure that the mails are
    going out. In this example, FakeSMTP will be used. You can download FakeSMTP from
    [http://nilhcem.github.io/FakeSMTP](http://nilhcem.github.io/FakeSMTP).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you download `fakeSMTP-2.0.jar`, run the SMTP server by executing the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This will open a GUI to monitor e-mail messages. Click on the **Start Server**
    button next to the listening port textbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `application.properties` with the following configuration parameters
    to connect to RabbitMQ as well as to the mail server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to test our microservices end to end. Start both the Spring Boot
    apps. Open the browser and repeat the customer creation steps through the HAL
    browser. In this case, immediately after submitting the request, we will be able
    to see the e-mail in the SMTP GUI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Internally, the Customer Profile service asynchronously calls the Customer
    Notification service, which, in turn, sends the e-mail message to the SMTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a comprehensive microservice example](img/B05447_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spring Boot actuators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections explored most of the Spring Boot features required to
    develop a microservice. In this section, some of the production-ready operational
    aspects of Spring Boot will be explored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot actuators provide an excellent out-of-the-box mechanism to monitor
    and manage Spring Boot applications in production:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.bootactuator`
    project in the code files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Create another **Spring Starter Project** and name it `chapter2.bootactuator`.
    This time, select **Web** and **Actuators** under **Ops**. Similar to the `chapter2.bootrest`
    project, add a `GreeterController` endpoint with the `greet` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application as Spring Boot app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point the browser to `localhost:8080/actuator`. This will open the HAL browser.
    Then, review the **Links** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A number of links are available under the **Links** section. These are automatically
    exposed by the Spring Boot actuator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spring Boot actuators](img/B05447_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the important links are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dump`: This performs a thread dump and displays the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mappings`: This lists all the HTTP request mappings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`: This displays information about the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`health`: This displays the application''s health conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoconfig`: This displays the autoconfiguration report'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metrics`: This shows different metrics collected from the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring using JConsole
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternately, we can use the JMX console to see the Spring Boot information.
    Connect to the remote Spring Boot instance from JConsole. The Boot information
    will be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring using JConsole](img/B05447_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring using SSH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Boot provides remote access to the Boot application using SSH. The following
    command connects to the Spring Boot application from a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The password can be customized by adding the `shell.auth.simple.user.password`
    property in the `application.properties` file. The updated `application.properties`
    file will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When connected with the preceding command, similar actuator information can
    be accessed. Here is an example of the metrics information accessed through the
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`help`: This lists out all the options available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dashboard`: This is one interesting feature that shows a lot of system-level
    information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring application information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following properties can be set in `application.properties` to customize
    application-related information. After adding, restart the server and visit the
    `/info` endpoint of the actuator to take a look at the updated information, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Adding a custom health module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a new custom module to the Spring Boot application is not so complex.
    To demonstrate this feature, assume that if a service gets more than two transactions
    in a minute, then the server status will be set as Out of Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to customize this, we have to implement the `HealthIndicator` interface
    and override the `health` method. The following is a quick and dirty implementation
    to do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class is a simple POJO class that maintains the transaction counts
    in the window. The `isWeak` method checks whether the transaction in a particular
    window reached its threshold. The `isExpired` method checks whether the current
    window is expired or not. The `increment` method simply increases the counter
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next step, implement our custom health indicator class, `TPSHealth`.
    This is done by extending `HealthIndicator`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `health` method checks whether the counter is weak or not. A weak counter
    means the service is handling more transactions than it can handle. If it is weak,
    it marks the instance as Out of Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will autowire `TPSHealth` into the `GreetingController` class and
    then call `health.updateTx()` in the `greet` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Go to the `/health` end point in the HAL browser and take a look at the status
    of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open another browser, point to `http://localhost:8080`, and fire the service
    twice or thrice. Go back to the `/health` endpoint and refresh to see the status.
    It should be changed to Out of Service.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, as there is no action taken other than collecting the health
    status, even though the status is Out of Service, new service calls will still
    go through. However, in the real world, a program should read the `/health` endpoint
    and block further requests from going to this instance.
  prefs: []
  type: TYPE_NORMAL
- en: Building custom metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to health, customization of the metrics is also possible. The following
    example shows how to add counter service and gauge service, just for demonstration
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following methods in the greet method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Restart the server and go to `/metrics` to see the new gauge and counter added
    already reflected there.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional approach of API documentation is either by writing service specification
    documents or using static service registries. With a large number of microservices,
    it would be hard to keep the documentation of APIs in sync.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can be documented in many ways. This section will explore how
    microservices can be documented using the popular Swagger framework. The following
    example will use Springfox libraries to generate REST API documentation. Springfox
    is a set of Java- and Spring-friendly libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Spring Starter Project** and select **Web** in the library selection
    window. Name the project `chapter2.swagger`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.swagger`
    project in the code files of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Springfox libraries are not part of the Spring suite, edit `pom.xml` and
    add Springfox Swagger library dependencies. Add the following dependencies to
    the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a REST service similar to the services created earlier, but also add
    the `@EnableSwagger2` annotation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all that''s required for a basic Swagger documentation. Start the application
    and point the browser to `http://localhost:8080/swagger-ui.html`. This will open
    the Swagger API documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting microservices](img/B05447_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the diagram, the Swagger lists out the possible operations on **Greet
    Controller**. Click on the **GET** operation. This expands the **GET** row, which
    provides an option to try out the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Spring Boot and its key features to build
    production-ready applications.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the previous-generation web applications and then how Spring Boot
    makes developers' lives easier to develop fully qualified microservices. We also
    discussed the asynchronous message-based interaction between services. Further,
    we explored how to achieve some of the key capabilities required for microservices,
    such as security, HATEOAS, cross-origin, configurations, and so on with practical
    examples. We also took a look at how Spring Boot actuators help the operations
    teams and also how we can customize it to our needs. Finally, documenting microservices
    APIs was also explored.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deeper look at some of the practical issues
    that may arise when implementing microservices. We will also discuss a capability
    model that essentially helps organizations when dealing with large microservices
    implementations.
  prefs: []
  type: TYPE_NORMAL
