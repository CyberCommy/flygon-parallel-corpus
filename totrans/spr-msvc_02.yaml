- en: Chapter 2. Building Microservices with Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用Spring Boot构建微服务
- en: Developing microservices is not so tedious anymore thanks to the powerful Spring
    Boot framework. Spring Boot is a framework to develop production-ready microservices
    in Java.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发微服务不再那么乏味，这要归功于强大的Spring Boot框架。Spring Boot是一个用于开发Java生产就绪微服务的框架。
- en: This chapter will move from the microservices theory explained in the previous
    chapter to hands-on practice by reviewing code samples. This chapter will introduce
    the Spring Boot framework and explain how Spring Boot can help build RESTful microservices
    in line with the principles and characteristics discussed in the previous chapter.
    Finally, some of the features offered by Spring Boot to make microservices production-ready
    will be reviewed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从上一章中解释的微服务理论转移到实际操作，通过审查代码示例来介绍Spring Boot框架，并解释Spring Boot如何帮助构建符合上一章讨论的原则和特征的RESTful微服务。最后，将回顾Spring
    Boot提供的一些功能，使微服务达到生产就绪状态。
- en: 'By the end of this chapter, you will have learned about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将学到：
- en: Setting up the latest Spring development environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置最新的Spring开发环境
- en: Developing RESTful services using the Spring framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring框架开发RESTful服务
- en: Using Spring Boot to build fully qualified microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot构建完全合格的微服务
- en: Useful Spring Boot features to build production-ready microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot构建生产就绪的微服务的有用功能
- en: Setting up a development environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立开发环境
- en: 'To crystalize microservices concepts, a couple of microservices will be built.
    For this, it is assumed that the following components are installed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确微服务的概念，将构建一对微服务。为此，假定已安装以下组件：
- en: '**JDK 1.8**: [http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDK 1.8**：[http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)'
- en: '**Spring Tool Suite 3.7.2** (**STS**): [https://spring.io/tools/sts/all](https://spring.io/tools/sts/all)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Tool Suite 3.7.2**（**STS**）：[https://spring.io/tools/sts/all](https://spring.io/tools/sts/all)'
- en: '**Maven 3.3.1**: [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven 3.3.1**：[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)'
- en: Alternately, other IDEs such as IntelliJ IDEA, NetBeans, or Eclipse could be
    used. Similarly, alternate build tools such as Gradle can be used. It is assumed
    that the Maven repository, class path, and other path variables are set properly
    to run STS and Maven projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用其他IDE，如IntelliJ IDEA、NetBeans或Eclipse。同样，也可以使用其他构建工具，如Gradle。假设Maven仓库、类路径和其他路径变量已正确设置以运行STS和Maven项目。
- en: 'This chapter is based on the following versions of Spring libraries:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于以下版本的Spring库：
- en: Spring Framework `4.2.6.RELEASE`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring框架`4.2.6.RELEASE`
- en: Spring Boot `1.3.5.RELEASE`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot`1.3.5.RELEASE`
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Have a look.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码包的详细步骤在本书的前言中有提到。看一看。
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Spring-Microservices](https://github.com/PacktPublishing/Spring-Microservices).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/Spring-Microservices](https://github.com/PacktPublishing/Spring-Microservices)。我们还有其他丰富的书籍和视频代码包可供使用，网址为[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)。去看看吧！
- en: Developing a RESTful service – the legacy approach
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发RESTful服务-传统方法
- en: This example will review the traditional RESTful service development before
    jumping deep into Spring Boot.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究Spring Boot之前，本示例将回顾传统的RESTful服务开发。
- en: STS will be used to develop this REST/JSON service.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: STS将用于开发此REST/JSON服务。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `legacyrest` project
    in the code files of this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码可在本书的代码文件中的`legacyrest`项目中找到。
- en: 'The following are the steps to develop the first RESTful service:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开发第一个RESTful服务的步骤：
- en: Start STS and set a workspace of choice for this project.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动STS并为该项目设置一个工作区。
- en: Navigate to **File** | **New** | **Project**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**File** | **New** | **Project**。
- en: Select **Spring Legacy Project** as shown in the following screenshot and click
    on **Next**:![Developing a RESTful service – the legacy approach](img/B05447_02_01.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Spring Legacy Project**，如下截图所示，然后点击**Next**：![开发RESTful服务-传统方法](img/B05447_02_01.jpg)
- en: Select **Spring MVC Project** as shown in the following diagram and click on
    **Next**:![Developing a RESTful service – the legacy approach](img/B05447_02_02.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Spring MVC Project**，如下图所示，然后点击**Next**：![开发RESTful服务-传统方法](img/B05447_02_02.jpg)
- en: Select a top-level package name of choice. This example uses `org.rvslab.chapter2.legacyrest`
    as the top-level package.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个顶级包名称。本示例使用`org.rvslab.chapter2.legacyrest`作为顶级包。
- en: Then, click on **Finish**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**Finish**。
- en: This will create a project in the STS workspace with the name `legacyrest`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在STS工作区中创建一个名为`legacyrest`的项目。
- en: Before proceeding further, `pom.xml` needs editing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，需要编辑`pom.xml`。
- en: 'Change the Spring version to `4.2.6.RELEASE`, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Spring版本更改为`4.2.6.RELEASE`，如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add **Jackson** dependencies in the `pom.xml` file for JSON-to-POJO and POJO-to-JSON
    conversions. Note that the `2.*.*` version is used to ensure compatibility with
    Spring 4.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pom.xml`文件中添加**Jackson**依赖项，用于JSON到POJO和POJO到JSON的转换。请注意，使用`2.*.*`版本以确保与Spring
    4的兼容性。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some Java code needs to be added. In **Java Resources**, under **legacyrest**,
    expand the package and open the default **HomeController.java** file:![Developing
    a RESTful service – the legacy approach](img/B05447_02_03.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要添加一些Java代码。在**Java Resources**下的**legacyrest**中，展开包并打开默认的**HomeController.java**文件：![开发RESTful服务-传统方法](img/B05447_02_03.jpg)
- en: 'The default implementation is targeted more towards the MVC project. Rewriting
    `HomeController.java` to return a JSON value in response to the REST call will
    do the trick. The resulting `HomeController.java` file will look similar to the
    following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认实现更加面向MVC项目。重写`HomeController.java`以响应REST调用返回JSON值将会奏效。生成的`HomeController.java`文件将类似于以下内容：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Examining the code, there are now two classes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 检查代码，现在有两个类：
- en: '`Greet`: This is a simple Java class with getters and setters to represent
    a data object. There is only one attribute in the `Greet` class, which is `message`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Greet`：这是一个简单的Java类，具有用于表示数据对象的getter和setter。`Greet`类中只有一个属性，即`message`。'
- en: '`HomeController.java`: This is nothing but a Spring controller REST endpoint
    to handle HTTP requests.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HomeController.java`：这只是一个Spring控制器REST端点，用于处理HTTP请求。'
- en: 'Note that the annotation used in `HomeController` is `@RestController`, which
    automatically injects `@Controller` and `@ResponseBody` and has the same effect
    as the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`HomeController`中使用的注释是`@RestController`，它会自动注入`@Controller`和`@ResponseBody`，并具有与以下代码相同的效果：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The project can now be run by right-clicking on **legacyrest**, navigating to
    **Run As** | **Run On Server**, and then selecting the default server (**Pivotal
    tc Server Developer Edition v3.1**) that comes along with STS.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目现在可以通过右键单击**legacyrest**，导航到**Run As** | **Run On Server**，然后选择默认服务器（**Pivotal
    tc Server Developer Edition v3.1**）来运行。
- en: This should automatically start the server and deploy the web application on
    the TC server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会自动启动服务器并在TC服务器上部署Web应用程序。
- en: 'If the server started properly, the following message will appear in the console:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器正常启动，控制台将显示以下消息：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If everything is fine, STS will open a browser window to `http://localhost:8080/legacyrest/`
    and display the JSON object as shown in the browser. Right-click on and navigate
    to **legacyrest** | **Properties** | **Web Project Settings** and review **Context
    Root** to identify the context root of the web application:![Developing a RESTful
    service – the legacy approach](img/B05447_02_04.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，STS将打开一个浏览器窗口到`http://localhost:8080/legacyrest/`，并在浏览器中显示JSON对象。右键单击并导航到**legacyrest**
    | **Properties** | **Web Project Settings**，并查看**Context Root**以识别Web应用程序的上下文根：![开发RESTful服务-传统方法](img/B05447_02_04.jpg)
- en: The alternate build option is to use Maven. Right-click on the project and navigate
    to **Run As** | **Maven install**. This will generate `chapter2-1.0.0-BUILD-SNAPSHOT.war`
    under the target folder. This war is deployable in any servlet container such
    as Tomcat, JBoss, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个构建选项是使用Maven。右键单击项目，导航到**Run As** | **Maven install**。这将在目标文件夹下生成`chapter2-1.0.0-BUILD-SNAPSHOT.war`。这个war文件可以部署在任何Servlet容器中，如Tomcat、JBoss等。
- en: Moving from traditional web applications to microservices
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从传统的Web应用程序转向微服务
- en: Carefully examining the preceding RESTful service will reveal whether this really
    constitutes a microservice. At first glance, the preceding RESTful service is
    a fully qualified interoperable REST/JSON service. However, it is not fully autonomous
    in nature. This is primarily because the service relies on an underlying application
    server or web container. In the preceding example, a war was explicitly created
    and deployed on a Tomcat server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查前面的RESTful服务将会揭示这是否真的构成了微服务。乍一看，前面的RESTful服务是一个完全合格的可互操作的REST/JSON服务。然而，它在本质上并不是完全自治的。这主要是因为该服务依赖于底层的应用服务器或Web容器。在前面的例子中，一个war文件被明确创建并部署在Tomcat服务器上。
- en: This is a traditional approach to developing RESTful services as a web application.
    However, from the microservices point of view, one needs a mechanism to develop
    services as executables, self-contained JAR files with an embedded HTTP listener.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种传统的开发RESTful服务的方法，作为Web应用程序。然而，从微服务的角度来看，人们需要一种机制来开发可执行的服务，即带有嵌入式HTTP监听器的自包含JAR文件。
- en: Spring Boot is a tool that allows easy development of such kinds of services.
    Dropwizard and WildFly Swarm are alternate server-less RESTful stacks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot是一个工具，可以方便地开发这种类型的服务。Dropwizard和WildFly Swarm是替代的无服务器RESTful堆栈。
- en: Using Spring Boot to build RESTful microservices
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot构建RESTful微服务
- en: Spring Boot is a utility framework from the Spring team to bootstrap Spring-based
    applications and microservices quickly and easily. The framework uses an opinionated
    approach over configurations for decision making, thereby reducing the effort
    required in writing a lot of boilerplate code and configurations. Using the 80-20
    principle, developers should be able to kickstart a variety of Spring applications
    with many default values. Spring Boot further presents opportunities for the developers
    to customize applications by overriding the autoconfigured values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot是Spring团队的一个实用框架，可以快速轻松地启动基于Spring的应用程序和微服务。该框架在决策制定方面采用了一种有见地的方法，从而减少了编写大量样板代码和配置所需的工作量。使用80-20原则，开发人员应该能够使用许多默认值快速启动各种Spring应用程序。Spring
    Boot进一步为开发人员提供了定制应用程序的机会，通过覆盖自动配置的值。
- en: Spring Boot not only increases the speed of development but also provides a
    set of production-ready ops features such as health checks and metrics collection.
    As Spring Boot masks many configuration parameters and abstracts many lower-level
    implementations, it minimizes the chance of error to a certain extent. Spring
    Boot recognizes the nature of the application based on the libraries available
    in the class path and runs the autoconfiguration classes packaged in these libraries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot不仅提高了开发速度，还提供了一套生产就绪的运维功能，如健康检查和指标收集。由于Spring Boot掩盖了许多配置参数并抽象了许多底层实现，它在一定程度上减少了错误的机会。Spring
    Boot根据类路径中可用的库识别应用程序的性质，并运行打包在这些库中的自动配置类。
- en: 'Often, many developers mistakenly see Spring Boot as a code generator, but
    in reality, it is not. Spring Boot only autoconfigures build files—for example,
    POM files in the case of Maven. It also sets properties, such as data source properties,
    based on certain opinionated defaults. Take a look at the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For instance, in the preceding case, Spring Boot understands that the project
    is set to use the Spring Data JPA and HSQL databases. It automatically configures
    the driver class and other connection parameters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: One of the great outcomes of Spring Boot is that it almost eliminates the need
    to have traditional XML configurations. Spring Boot also enables microservices'
    development by packaging all the required runtime dependencies in a fat executable
    JAR file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Spring Boot
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different ways that Spring Boot-based application development can
    be started:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Using the Spring Boot CLI as a command-line tool
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IDEs such as STS to provide Spring Boot, which are supported out of the
    box
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Spring Initializr project at [http://start.spring.io](http://start.spring.io)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these three options will be explored in this chapter, developing a variety
    of sample services.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Spring Boot microservice using the CLI
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to develop and demonstrate Spring Boot''s capabilities is using
    the Spring Boot CLI, a command-line tool. Perform the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Install the Spring Boot command-line tool by downloading the `spring-boot-cli-1.3.5.RELEASE-bin.zip`
    file from [http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.5.RELEASE/spring-boot-cli-1.3.5.RELEASE-bin.zip](http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.3.5.RELEASE/spring-boot-cli-1.3.5.RELEASE-bin.zip).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the file into a directory of your choice. Open a terminal window and change
    the terminal prompt to the `bin` folder.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the `bin` folder is added to the system path so that Spring Boot
    can be run from any location.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the installation with the following command. If successful, the Spring
    CLI version will be printed in the console:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As the next step, a quick REST service will be developed in Groovy, which is
    supported out of the box in Spring Boot. To do so, copy and paste the following
    code using any editor of choice and save it as `myfirstapp.groovy` in any folder:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to run this Groovy application, go to the folder where `myfirstapp.groovy`
    is saved and execute the following command. The last few lines of the server start-up
    log will be similar to the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open a browser window and go to `http://localhost:8080`; the browser will display
    the following message:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hello World!**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: There is no war file created, and no Tomcat server was run. Spring Boot automatically
    picked up Tomcat as the webserver and embedded it into the application. This is
    a very basic, minimal microservice. The `@RestController` annotation, used in
    the previous code, will be examined in detail in the next example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Spring Boot Java microservice using STS
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, developing another Java-based REST/JSON Spring Boot service
    using STS will be demonstrated.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.bootrest`
    project in the code files of this book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Open STS, right-click within the **Project Explorer** window, navigate to **New**
    | **Project**, and select **Spring Starter Project**, as shown in the following
    screenshot, and click on **Next**:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_05.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Starter Project is a basic template wizard that provides a number of
    other starter libraries to select from.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Type the project name as `chapter2.bootrest` or any other name of your choice.
    It is important to choose the packaging as JAR. In traditional web applications,
    a war file is created and then deployed to a servlet container, whereas Spring
    Boot packages all the dependencies to a self-contained, autonomous JAR file with
    an embedded HTTP listener.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select 1.8 under **Java Version**. Java 1.8 is recommended for Spring 4 applications.
    Change the other Maven properties such as **Group**, **Artifact**, and **Package**,
    as shown in the following screenshot:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_06.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once completed, click on **Next**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The wizard will show the library options. In this case, as the REST service
    is developed, select **Web** under **Web**. This is an interesting step that tells
    Spring Boot that a Spring MVC web application is being developed so that Spring
    Boot can include the necessary libraries, including Tomcat as the HTTP listener
    and other configurations, as required:![Developing the Spring Boot Java microservice
    using STS](img/B05447_02_07.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will generate a project named `chapter2.bootrest` in **Project Explorer**
    in STS:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing the Spring Boot Java microservice using STS](img/B05447_02_08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Take a moment to examine the generated application. Files that are of interest
    are:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pom.xml`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application.java`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application.properties`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationTests.java`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the POM file
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The parent element is one of the interesting aspects in the `pom.xml` file.
    Take a look at the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `spring-boot-starter-parent` pattern is a **bill of materials** (**BOM**),
    a pattern used by Maven's dependency management. BOM is a special kind of POM
    file used to manage different library versions required for a project. The advantage
    of using the `spring-boot-starter-parent` POM file is that developers need not
    worry about finding the right compatible versions of different libraries such
    as Spring, Jersey, JUnit, Logback, Hibernate, Jackson, and so on. For instance,
    in our first legacy example, a specific version of the Jackson library was added
    to work with Spring 4\. In this example, these are taken care of by the `spring-boot-starter-parent`
    pattern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The starter POM file has a list of Boot dependencies, sensible resource filtering,
    and sensible plug-in configurations required for the Maven builds.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [https://github.com/spring-projects/spring-boot/blob/1.3.x/spring-boot-dependencies/pom.xml](https://github.com/spring-projects/spring-boot/blob/1.3.x/spring-boot-dependencies/pom.xml)
    to take a look at the different dependencies provided in the starter parent (version
    1.3.x). All these dependencies can be overridden if required.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The starter POM file itself does not add JAR dependencies to the project. Instead,
    it will only add library versions. Subsequently, when dependencies are added to
    the POM file, they refer to the library versions from this POM file. A snapshot
    of some of the properties are as shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Reviewing the dependency section, one can see that this is a clean and neat
    POM file with only two dependencies, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As web is selected, `spring-boot-starter-web` adds all dependencies required
    for a Spring MVC project. It also includes dependencies to Tomcat as an embedded
    HTTP listener. This provides an effective way to get all the dependencies required
    as a single bundle. Individual dependencies could be replaced with other libraries,
    for example replacing Tomcat with Jetty.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Similar to web, Spring Boot comes up with a number of `spring-boot-starter-*`
    libraries, such as `amqp`, `aop`, `batch`, `data-jpa`, `thymeleaf`, and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to be reviewed in the `pom.xml` file is the Java 8 property.
    By default, the parent POM file adds Java 6\. It is recommended to override the
    Java version to 8 for Spring:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Examining Application.java
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Boot, by default, generated a `org.rvslab.chapter2.Application.java`
    class under `src/main/java` to bootstrap, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot默认在`src/main/java`下生成了一个`org.rvslab.chapter2.Application.java`类来引导，如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is only a `main` method in `Application`, which will be invoked at startup
    as per the Java convention. The `main` method bootstraps the Spring Boot application
    by calling the `run` method on `SpringApplication`. `Application.class` is passed
    as a parameter to tell Spring Boot that this is the primary component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`中只有一个`main`方法，按照Java约定，在启动时将被调用。`main`方法通过在`SpringApplication`上调用`run`方法来引导Spring
    Boot应用程序。将`Application.class`作为参数传递，告诉Spring Boot这是主要组件。'
- en: 'More importantly, the magic is done by the `@SpringBootApplication` annotation.
    The `@SpringBootApplication` annotation is a top-level annotation that encapsulates
    three other annotations, as shown in the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这是由`@SpringBootApplication`注解完成的。`@SpringBootApplication`注解是一个顶级注解，封装了另外三个注解，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `@Configuration` annotation hints that the contained class declares one
    or more `@Bean` definitions. The `@Configuration` annotation is meta-annotated
    with `@Component`; therefore, it is a candidate for component scanning.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration`注解提示包含的类声明一个或多个`@Bean`定义。`@Configuration`注解是元注解`@Component`的提示；因此，它是组件扫描的候选对象。'
- en: The `@EnableAutoConfiguration` annotation tells Spring Boot to automatically
    configure the Spring application based on the dependencies available in the class
    path.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration`注解告诉Spring Boot根据类路径中可用的依赖项自动配置Spring应用程序。'
- en: Examining application.properties
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查application.properties
- en: A default `application.properties` file is placed under `src/main/resources`.
    It is an important file to configure any required properties for the Spring Boot
    application. At the moment, this file is kept empty and will be revisited with
    some test cases later in this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`application.properties`文件放置在`src/main/resources`下。这是一个重要的文件，用于配置Spring Boot应用程序的任何必需属性。目前，这个文件是空的，将在本章的后面一些测试用例中重新访问。
- en: Examining ApplicationTests.java
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查ApplicationTests.java
- en: The last file to be examined is `ApplicationTests.java` under `src/test/java`.
    This is a placeholder to write test cases against the Spring Boot application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的最后一个文件是`src/test/java`下的`ApplicationTests.java`。这是一个占位符，用于针对Spring Boot应用程序编写测试用例。
- en: 'To implement the first RESTful service, add a REST endpoint, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现第一个RESTful服务，添加一个REST端点，如下所示：
- en: 'One can edit `Application.java` under `src/main/java` and add a RESTful service
    implementation. The RESTful service is exactly the same as what was done in the
    previous project. Append the following code at the end of the `Application.java`
    file:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以编辑`src/main/java`下的`Application.java`，并添加一个RESTful服务实现。RESTful服务与之前的项目中所做的完全相同。在`Application.java`文件的末尾添加以下代码：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To run, navigate to **Run As** | **Spring Boot App**. Tomcat will be started
    on the `8080` port:![Examining ApplicationTests.java](img/B05447_02_09.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行，导航到**Run As** | **Spring Boot App**。Tomcat将在`8080`端口上启动：![检查ApplicationTests.java](img/B05447_02_09.jpg)
- en: 'We can notice from the log that:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从日志中注意到：
- en: Spring Boot get its own process ID (in this case, it is `41130`)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot获得了自己的进程ID（在本例中为`41130`）
- en: Spring Boot is automatically started with the Tomcat server at the localhost,
    port `8080`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot会自动在本地主机的Tomcat服务器上启动，端口为`8080`。
- en: Next, open a browser and point to `http://localhost:8080`. This will show the
    JSON response as shown in the following screenshot:![Examining ApplicationTests.java](img/B05447_02_10.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开浏览器，指向`http://localhost:8080`。这将显示JSON响应，如下面的截图所示：![检查ApplicationTests.java](img/B05447_02_10.jpg)
- en: 'A key difference between the legacy service and this one is that the Spring
    Boot service is self-contained. To make this clearer, run the Spring Boot application
    outside STS. Open a terminal window, go to the project folder, and run Maven,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 传统服务和这个服务之间的一个关键区别是，Spring Boot服务是自包含的。为了更清楚地说明这一点，可以在STS之外运行Spring Boot应用程序。打开一个终端窗口，转到项目文件夹，并运行Maven，如下所示：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will generate a fat JAR file under the target folder of the project. Running
    the application from the command line shows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目的目标文件夹下生成一个fat JAR文件。从命令行运行应用程序会显示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As one can see, `bootrest-0.0.1-SNAPSHOT.jar` is self-contained and could be
    run as a standalone application. At this point, the JAR is as thin as 13 MB. Even
    though the application is no more than just "Hello World", the Spring Boot service
    just developed, practically follows the principles of microservices.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如大家所看到的，`bootrest-0.0.1-SNAPSHOT.jar`是自包含的，可以作为独立的应用程序运行。在这一点上，JAR文件只有13MB。尽管应用程序不过是一个简单的“Hello
    World”，但刚刚开发的Spring Boot服务实际上遵循了微服务的原则。
- en: Testing the Spring Boot microservice
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Spring Boot微服务
- en: 'There are multiple ways to test REST/JSON Spring Boot microservices. The easiest
    way is to use a web browser or a curl command pointing to the URL, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以测试REST/JSON Spring Boot微服务。最简单的方法是使用Web浏览器或指向URL的curl命令，如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are number of tools available to test RESTful services, such as Postman,
    Advanced REST client, SOAP UI, Paw, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于测试RESTful服务，例如Postman、Advanced REST client、SOAP UI、Paw等。
- en: In this example, to test the service, the default test class generated by Spring
    Boot will be used.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为了测试服务，将使用Spring Boot生成的默认测试类。
- en: 'Adding a new test case to `ApplicatonTests.java` results in:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ApplicatonTests.java`中添加一个新的测试用例会导致：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `@WebIntegrationTest` is added and `@WebAppConfiguration` removed
    at the class level. The `@WebIntegrationTest` annotation is a handy annotation
    that ensures that the tests are fired against a fully up-and-running server. Alternately,
    a combination of `@WebAppConfiguration` and `@IntegrationTest` will give the same
    result.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在类级别添加了`@WebIntegrationTest`，并删除了`@WebAppConfiguration`。`@WebIntegrationTest`注解是一个方便的注解，可以确保测试针对一个完全运行的服务器。或者，`@WebAppConfiguration`和`@IntegrationTest`的组合将产生相同的结果。
- en: Also note that `RestTemplate` is used to call the RESTful service. `RestTemplate`
    is a utility class that abstracts the lower-level details of the HTTP client.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: To test this, one can open a terminal window, go to the project folder, and
    run `mvn install`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Spring Boot microservice using Spring Initializr – the HATEOAS
    example
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next example, Spring Initializr will be used to create a Spring Boot
    project. Spring Initializr is a drop-in replacement for the STS project wizard
    and provides a web UI to configure and generate a Spring Boot project. One of
    the advantages of Spring Initializr is that it can generate a project through
    the website that then can be imported into any IDE.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the concept of **HATEOAS** (short for **Hypertext As The Engine
    Of Application State**) for REST-based services and the **HAL** (**Hypertext Application
    Language**) browser will be examined.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS is a REST service pattern in which navigation links are provided as
    part of the payload metadata. The client application determines the state and
    follows the transition URLs provided as part of the state. This methodology is
    particularly useful in responsive mobile and web applications in which the client
    downloads additional data based on user navigation patterns.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The HAL browser is a handy API browser for `hal+json` data. HAL is a format
    based on JSON that establishes conventions to represent hyperlinks between resources.
    HAL helps APIs be more explorable and discoverable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.boothateoas`
    project in the code files of this book.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the concrete steps to develop a HATEOAS sample using Spring Initilizr:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: In order to use Spring Initilizr, go to [https://start.spring.io](https://start.spring.io):![Developing
    the Spring Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_11.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the details, such as whether it is a Maven project, Spring Boot version,
    group, and artifact ID, as shown earlier, and click on **Switch to the full version**
    link under the **Generate Project** button. Select **Web**, **HATEOAS**, and **Rest
    Repositories HAL Browser**. Make sure that the Java version is 8 and the package
    type is selected as **JAR**:![Developing the Spring Boot microservice using Spring
    Initializr – the HATEOAS example](img/B05447_02_12.jpg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once selected, hit the **Generate Project** button. This will generate a Maven
    project and download the project as a ZIP file into the download directory of
    the browser.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the file and save it to a directory of your choice.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open STS, go to the **File** menu and click on **Import**:![Developing the Spring
    Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_13.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Maven** | **Existing Maven Projects** and click on **Next**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Browse** next to **Root Directory** and select the unzipped folder.
    Click on **Finish**. This will load the generated Maven project into STS' **Project
    Explorer**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `Application.java` file to add a new REST endpoint, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that this is the same `GreetingController` class as in the previous example.
    However, a method was added this time named `greeting`. In this new method, an
    additional optional request parameter is defined and defaulted to `HATEOAS`. The
    following code adds a link to the resulting JSON code. In this case, it adds the
    link to the same API:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to do this, we need to extend the `Greet` class from `ResourceSupport`,
    as shown here. The rest of the code remains the same:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `add` method is a method in `ResourceSupport`. The `linkTo` and `methodOn`
    methods are static methods of `ControllerLinkBuilder`, a utility class for creating
    links on controller classes. The `methodOn` method will do a dummy method invocation,
    and `linkTo` will create a link to the controller class. In this case, we will
    use `withSelfRel` to point it to itself.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will essentially produce a link, `/greeting?name=HATEOAS`, by default.
    A client can read the link and initiate another call.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将基本上生成一个默认的链接`/greeting?name=HATEOAS`。客户端可以读取链接并发起另一个调用。
- en: Run this as a Spring Boot app. Once the server startup is complete, point the
    browser to `http://localhost:8080`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其作为Spring Boot应用程序运行。一旦服务器启动完成，将浏览器指向`http://localhost:8080`。
- en: This will open the HAL browser window. In the **Explorer** field, type `/greeting?name=World!`
    and click on the **Go** button. If everything is fine, the HAL browser will show
    the response details as shown in the following screenshot:![Developing the Spring
    Boot microservice using Spring Initializr – the HATEOAS example](img/B05447_02_14.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开HAL浏览器窗口。在**Explorer**字段中，输入`/greeting?name=World!`并单击**Go**按钮。如果一切正常，HAL浏览器将显示响应详细信息，如下面的屏幕截图所示：![使用Spring
    Initializr开发Spring Boot微服务 - HATEOAS示例](img/B05447_02_14.jpg)
- en: As shown in the screenshot, the **Response Body** section has the result with
    a link with `href` pointing back to the same service. This is because we pointed
    the reference to itself. Also, review the **Links** section. The little green
    box against **self** is the navigable link.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如屏幕截图所示，**响应主体**部分显示了一个带有`href`指向同一服务的链接。这是因为我们将引用指向自身。还要查看**链接**部分。**self**旁边的小绿色框是可导航链接。
- en: It does not make much sense in this simple example, but this could be handy
    in larger applications with many related entities. Using the links provided, the
    client can easily navigate back and forth between these entities with ease.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中并没有太多意义，但在有许多相关实体的大型应用程序中可能会很方便。使用提供的链接，客户端可以轻松地在这些实体之间来回导航。
- en: What's next?
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: A number of basic Spring Boot examples have been reviewed so far. The rest of
    this chapter will examine some of the Spring Boot features that are important
    from a microservices development perspective. In the upcoming sections, we will
    take a look at how to work with dynamically configurable properties, change the
    default embedded web server, add security to the microservices, and implement
    cross-origin behavior when dealing with microservices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已经审查了许多基本的Spring Boot示例。本章的其余部分将从微服务开发的角度考虑一些重要的Spring Boot功能。在接下来的几节中，我们将看看如何处理动态可配置属性，更改默认的嵌入式Web服务器，为微服务添加安全性，并在处理微服务时实现跨源行为。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full source code of this example is available as the `chapter2.boot-advanced`
    project in the code files of this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整源代码可作为本书的代码文件中的`chapter2.boot-advanced`项目获得。
- en: The Spring Boot configuration
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot配置
- en: In this section, the focus will be on the configuration aspects of Spring Boot.
    The `chapter2.bootrest` project, already developed, will be modified in this section
    to showcase configuration capabilities. Copy and paste `chapter2.bootrest` and
    rename the project as `chapter2.boot-advanced`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，重点将放在Spring Boot的配置方面。已经开发的`chapter2.bootrest`项目将在本节中进行修改，以展示配置功能。复制并粘贴`chapter2.bootrest`并将项目重命名为`chapter2.boot-advanced`。
- en: Understanding the Spring Boot autoconfiguration
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Spring Boot自动配置
- en: Spring Boot uses convention over configuration by scanning the dependent libraries
    available in the class path. For each `spring-boot-starter-*` dependency in the
    POM file, Spring Boot executes a default `AutoConfiguration` class. `AutoConfiguration`
    classes use the `*AutoConfiguration` lexical pattern, where `*` represents the
    library. For example, the autoconfiguration of JPA repositories is done through
    `JpaRepositoriesAutoConfiguration`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot使用约定优于配置，通过扫描类路径中可用的依赖库。对于POM文件中的每个`spring-boot-starter-*`依赖项，Spring
    Boot执行默认的`AutoConfiguration`类。`AutoConfiguration`类使用`*AutoConfiguration`词法模式，其中`*`表示库。例如，JPA存储库的自动配置是通过`JpaRepositoriesAutoConfiguration`完成的。
- en: 'Run the application with `--debug` to see the autoconfiguration report. The
    following command shows the autoconfiguration report for the `chapter2.boot-advanced`
    project:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--debug`运行应用程序以查看自动配置报告。以下命令显示了`chapter2.boot-advanced`项目的自动配置报告：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here are some examples of the autoconfiguration classes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些自动配置类的示例：
- en: '`ServerPropertiesAutoConfiguration`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerPropertiesAutoConfiguration`'
- en: '`RepositoryRestMvcAutoConfiguration`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RepositoryRestMvcAutoConfiguration`'
- en: '`JpaRepositoriesAutoConfiguration`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JpaRepositoriesAutoConfiguration`'
- en: '`JmsAutoConfiguration`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JmsAutoConfiguration`'
- en: 'It is possible to exclude the autoconfiguration of certain libraries if the
    application has special requirements and you want to get full control of the configurations.
    The following is an example of excluding `DataSourceAutoConfiguration`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序有特殊要求，并且您想完全控制配置，可以排除某些库的自动配置。以下是一个排除`DataSourceAutoConfiguration`的示例：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Overriding default configuration values
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖默认配置值
- en: 'It is also possible to override default configuration values using the `application.properties`
    file. STS provides an easy-to-autocomplete, contextual help on `application.properties`,
    as shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`application.properties`文件覆盖默认配置值。STS提供了一个易于自动完成的上下文帮助`application.properties`，如下面的屏幕截图所示：
- en: '![Overriding default configuration values](img/B05447_02_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![覆盖默认配置值](img/B05447_02_15.jpg)'
- en: In the preceding screenshot, `server.port` is edited to be set as `9090`. Running
    this application again will start the server on port `9090`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`server.port`被编辑为设置为`9090`。再次运行此应用程序将在端口`9090`上启动服务器。
- en: Changing the location of the configuration file
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改配置文件的位置
- en: 'In order to align with the Twelve-Factor app, configuration parameters need
    to be externalized from the code. Spring Boot externalizes all configurations
    into `application.properties`. However, it is still part of the application''s
    build. Furthermore, properties can be read from outside the package by setting
    the following properties:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与十二要素应用程序保持一致，配置参数需要从代码中外部化。Spring Boot将所有配置外部化到`application.properties`中。然而，它仍然是应用程序构建的一部分。此外，可以通过设置以下属性从包外部读取属性：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `spring.config.location` could be a local file location.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command starts the Spring Boot application with an externally
    provided configuration file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Reading custom properties
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At startup, `SpringApplication` loads all the properties and adds them to the
    Spring `Environment` class. Add a custom property to the `application.properties`
    file. In this case, the custom property is named `bootrest.customproperty`. Autowire
    the Spring `Environment` class into the `GreetingController` class. Edit the `GreetingController`
    class to read the custom property from `Environment` and add a log statement to
    print the custom property to the console.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property to the `application.properties` file:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, edit the `GreetingController` class as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Rerun the application. The log statement prints the custom variable in the
    console, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using a .yaml file for configuration
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an alternate to `application.properties`, one may use a `.yaml` file. YAML
    provides a JSON-like structured configuration compared to the flat properties
    file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, simply replace `application.properties` with `application.yaml`
    and add the following property:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Rerun the application to see the port printed in the console.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple configuration profiles
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Furthermore, it is possible to have different profiles such as development,
    testing, staging, production, and so on. These are logical names. Using these,
    one can configure different values for the same properties for different environments.
    This is quite handy when running the Spring Boot application against different
    environments. In such cases, there is no rebuild required when moving from one
    environment to another.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `.yaml` file as follows. The Spring Boot group profiles properties
    based on the dotted separator:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the Spring Boot application as follows to see the use of profiles:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Active profiles can be specified programmatically using the `@ActiveProfiles`
    annotation, which is especially useful when running test cases, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Other options to read properties
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The properties can be loaded in a number of ways, such as the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Command-line parameters `(-Dhost.port =9090`)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system environment variables
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JNDI (`java:comp/env`)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the default embedded web server
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Embedded HTTP listeners can easily be customized as follows. By default, Spring
    Boot supports Tomcat, Jetty, and Undertow. In the following example, Tomcat is
    replaced with Undertow:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implementing Spring Boot security
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to secure microservices. In this section, some basic measures
    to secure Spring Boot microservices will be reviewed using `chapter2.bootrest`
    to demonstrate the security features.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Securing microservices with basic security
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding basic authentication to Spring Boot is pretty simple. Add the following
    dependency to `pom.xml`. This will include the necessary Spring security library
    files:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open `Application.java` and add `@EnableGlobalMethodSecurity` to the `Application`
    class. This annotation will enable method-level security:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The default basic authentication assumes the user as being `user`. The default
    password will be printed in the console at startup. Alternately, the username
    and password can be added in `application.properties`, as shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add a new test case in `ApplicationTests` to test the secure service results,
    as in the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As shown in the code, a new `Authorization` request header with Base64 encoding
    the username-password string is created.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun the application using Maven. Note that the new test case passed, but
    the old test case failed with an exception. The earlier test case now runs without
    credentials, and as a result, the server rejected the request with the following
    message:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Securing a microservice with OAuth2
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will take a look at the basic Spring Boot configuration
    for OAuth2\. When a client application requires access to a protected resource,
    the client sends a request to an authorization server. The authorization server
    validates the request and provides an access token. This access token is validated
    for every client-to-server request. The request and response sent back and forth
    depends on the grant type.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read more about OAuth and grant types at [http://oauth.net](http://oauth.net).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource owner password credentials grant approach will be used in this
    example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing a microservice with OAuth2](img/B05447_02_16.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: In this case, as shown in the preceding diagram, the resource owner provides
    the client with a username and password. The client then sends a token request
    to the authorization server by providing the credential information. The authorization
    server authorizes the client and returns with an access token. On every subsequent
    request, the server validates the client token.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement OAuth2 in our example, perform the following steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, update `pom.xml` with the OAuth2 dependency, as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, add two new annotations, `@EnableAuthorizationServer` and `@EnableResourceServer`,
    to the `Application.java` file. The `@EnableAuthorizationServer` annotation creates
    an authorization server with an in-memory repository to store client tokens and
    provide clients with a username, password, client ID, and secret. The `@EnableResourceServer`
    annotation is used to access the tokens. This enables a spring security filter
    that is authenticated via an incoming OAuth2 token.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, both the authorization server and resource server are the same.
    However, in practice, these two will run separately. Take a look at the following
    code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following properties to the `application.properties` file:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, add another test case to test OAuth2, as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As shown in the preceding code, a special REST template, `OAuth2RestTemplate`,
    is created by passing the resource details encapsulated in a resource details
    object. This REST template handles the OAuth2 processes underneath. The access
    token URI is the endpoint for the token access.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Rerun the application using `mvn install`. The first two test cases will fail,
    and the new one will succeed. This is because the server only accepts OAuth2-enabled
    requests.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are quick configurations provided by Spring Boot out of the box but are
    not good enough to be production grade. We may need to customize `ResourceServerConfigurer`
    and `AuthorizationServerConfigurer` to make them production-ready. This notwithstanding,
    the approach remains the same.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Enabling cross-origin access for microservices
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browsers are generally restricted when client-side web applications running
    from one origin request data from another origin. Enabling cross-origin access
    is generally termed as **CORS** (**Cross-Origin Resource Sharing**).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling cross-origin access for microservices](img/B05447_02_17.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: This example shows how to enable cross-origin requests. With microservices,
    as each service runs with its own origin, it will easily get into the issue of
    a client-side web application consuming data from multiple origins. For instance,
    a scenario where a browser client accessing Customer from the Customer microservice
    and Order History from the Order microservices is very common in the microservices
    world.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot provides a simple declarative approach to enabling cross-origin
    requests. The following example shows how to enable a microservice to enable cross-origin
    requests:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By default, all the origins and headers are accepted. We can further customize
    the cross-origin annotations by giving access to specific origins, as follows.
    The `@CrossOrigin` annotation enables a method or class to accept cross-origin
    requests:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Global CORS can be enabled using the `WebMvcConfigurer` bean and customizing
    the `addCorsMappings(CorsRegistry registry)` method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Spring Boot messaging
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an ideal case, all microservice interactions are expected to happen asynchronously
    using publish-subscribe semantics. Spring Boot provides a hassle-free mechanism
    to configure messaging solutions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Spring Boot messaging](img/B05447_02_18.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we will create a Spring Boot application with a sender and
    receiver, both connected though an external queue. Perform the following steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.bootmessaging`
    project in the code files of this book.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project using STS to demonstrate this capability. In this example,
    instead of selecting **Web**, select **AMQP** under **I/O**:![Implementing Spring
    Boot messaging](img/B05447_02_19.jpg)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rabbit MQ will also be needed for this example. Download and install the latest
    version of Rabbit MQ from [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rabbit MQ 3.5.6 is used in this book.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the installation steps documented on the site. Once ready, start the
    RabbitMQ server via the following command:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Make the configuration changes to the `application.properties` file to reflect
    the RabbitMQ configuration. The following configuration uses the default port,
    username, and password of RabbitMQ:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a message sender component and a queue named `TestQ` of the `org.springframework.amqp.core.Queue`
    type to the `Application.java` file under `src/main/java`. `RabbitMessagingTemplate`
    is a convenient way to send messages, which will abstract all the messaging semantics.
    Spring Boot provides all boilerplate configurations to send messages:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To receive the message, all that needs to be used is a `@RabbitListener` annotation.
    Spring Boot autoconfigures all the required boilerplate configurations:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last piece of this exercise is to wire the sender to our main application
    and implement the `run` method of `CommandLineRunner` to initiate the message
    sending. When the application is initialized, it invokes the `run` method of `CommandLineRunner`,
    as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the application as a Spring Boot application and verify the output. The
    following message will be printed in the console:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Developing a comprehensive microservice example
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the examples we have considered are no more than just a simple "Hello
    world." Putting together what we have learned, this section demonstrates an end-to-end
    Customer Profile microservice implementation. The Customer Profile microservices
    will demonstrate interaction between different microservices. It also demonstrates
    microservices with business logic and primitive data stores.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, two microservices, the Customer Profile and Customer Notification
    services, will be developed:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a comprehensive microservice example](img/B05447_02_20.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: As shown in the diagram, the Customer Profile microservice exposes methods to
    **create, read, update, and delete** (**CRUD**) a customer and a registration
    service to register a customer. The registration process applies certain business
    logic, saves the customer profile, and sends a message to the Customer Notification
    microservice. The Customer Notification microservice accepts the message sent
    by the registration service and sends an e-mail message to the customer using
    an SMTP server. Asynchronous messaging is used to integrate Customer Profile with
    the Customer Notification service.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'The Customer microservices class domain model diagram is as shown here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a comprehensive microservice example](img/B05447_02_21.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: '`CustomerController` in the diagram is the REST endpoint, which invokes a component
    class, `CustomerComponent`. The component class/bean handles all the business
    logic. `CustomerRepository` is a Spring data JPA repository defined to handle
    the persistence of the `Customer` entity.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.bootcustomer`
    and `chapter2.bootcustomernotification` projects in the code files of this book.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Spring Boot project and call it `chapter2.bootcustomer`, the same
    way as earlier. Select the options as in the following screenshot in the starter
    module selection screen:![Developing a comprehensive microservice example](img/B05447_02_22.jpg)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a web project with JPA, the REST repository, and H2 as a database.
    H2 is a tiny in-memory embedded database with which it is easy to demonstrate
    database features. In the real world, it is recommended to use an appropriate
    enterprise-grade database. This example uses JPA to define persistence entities
    and the REST repository to expose REST-based repository services.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure will be similar to the following screenshot:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a comprehensive microservice example](img/B05447_02_24.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: 'Start building the application by adding an Entity class named `Customer`.
    For simplicity, there are only three fields added to the `Customer` Entity class:
    the autogenerated `id` field, `name`, and `email`. Take a look at the following
    code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add a repository class to handle the persistence handling of Customer. `CustomerRepository`
    extends the standard JPA repository. This means that all CRUD methods and default
    finder methods are automatically implemented by the Spring Data JPA repository,
    as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we added a new method to the repository class, `findByName`,
    which essentially searches the customer based on the customer name and returns
    a `Customer` object if there is a matching name.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The `@RepositoryRestResource` annotation enables the repository access through
    RESTful services. This will also enable HATEOAS and HAL by default. As for CRUD
    methods there is no additional business logic required, we will leave it as it
    is without controller or component classes. Using HATEOAS will help us navigate
    through Customer Repository methods effortlessly.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there is no configuration added anywhere to point to any database.
    As H2 libraries are in the class path, all the configuration is done by default
    by Spring Boot based on the H2 autoconfiguration.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Application.java` file by adding `CommandLineRunner` to initialize
    the repository with some customer records, as follows:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`CommandLineRunner`, defined as a bean, indicates that it should run when it
    is contained in `SpringApplication`. This will insert six sample customer records
    into the database at startup.'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, run the application as Spring Boot App. Open the HAL browser
    and point the browser to `http://localhost:8080`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Explorer** section, point to `http://localhost:8080/customers` and
    click on **Go**. This will list all the customers in the **Response Body** section
    of the HAL browser.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Explorer** section, enter `http://localhost:8080/customers?size=2&page=1&sort=name`
    and click on **Go**. This will automatically execute paging and sorting on the
    repository and return the result.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the page size is set to `2` and the first page is requested, it will come
    back with two records in a sorted order.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Review the **Links** section. As shown in the following screenshot, it will
    facilitate navigating **first**, **next**, **prev**, and **last**. These are done
    using the HATEOAS links automatically generated by the repository browser:![Developing
    a comprehensive microservice example](img/B05447_02_23.jpg)
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, one can explore the details of a customer by selecting the appropriate
    link, such as `http://localhost:8080/customers/2`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the next step, add a controller class, `CustomerController`, to handle service
    endpoints. There is only one endpoint in this class, `/register`, which is used
    to register a customer. If successful, it returns the `Customer` object as the
    response, as follows:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A `CustomerRegistrar` component is added to handle the business logic. In this
    case, there is only minimal business logic added to the component. In this component
    class, while registering a customer, we will just check whether the customer name
    already exists in the database or not. If it does not exist, then we will insert
    a new record, and otherwise, we will send an error message back, as follows:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Restart the Boot application and test using the HAL browser via the URL `http://localhost:8080`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point the **Explorer** field to `http://localhost:8080/customers`. Review the
    results in the **Links** section:![Developing a comprehensive microservice example](img/B05447_02_25.jpg)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **NON-GET** option against **self**. This will open a form to create
    a new customer:![Developing a comprehensive microservice example](img/B05447_02_26.jpg)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the form and change the **Action** as shown in the diagram. Click on the
    **Make Request** button. This will call the register service and register the
    customer. Try giving a duplicate name to test the negative case.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's complete the last part in the example by integrating the Customer Notification
    service to notify the customer. When registration is successful, send an e-mail
    to the customer by asynchronously calling the Customer Notification microservice.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First update `CustomerRegistrar` to call the second service. This is done through
    messaging. In this case, we injected a `Sender` component to send a notification
    to the customer by passing the customer''s e-mail address to the sender, as follows:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The sender component will be based on RabbitMQ and AMQP. In this example, `RabbitMessagingTemplate`
    is used as explored in the last messaging example; take a look at the following:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `@Lazy` annotation is a useful one and it helps to increase the boot startup
    time. These beans will be initialized only when the need arises.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also update the `application.property` file to include Rabbit MQ-related
    properties, as follows:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We are ready to send the message. To consume the message and send e-mails, we
    will create a notification service. For this, let's create another Spring Boot
    service, `chapter2.bootcustomernotification`. Make sure that the **AMQP** and
    **Mail** starter libraries are selected when creating the Spring Boot service.
    Both **AMQP** and **Mail** are under **I/O**.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The package structure of the `chapter2.bootcustomernotification` project is
    as shown here:![Developing a comprehensive microservice example](img/B05447_02_27.jpg)
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Receiver` class. The `Receiver` class waits for a message on customer.
    This will receive a message sent by the Customer Profile service. On the arrival
    of a message, it sends an e-mail, as follows:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add another component to send an e-mail to the customer. We will use `JavaMailSender`
    to send an e-mail via the following code:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Behind the scenes, Spring Boot automatically configures all the parameters required
    by `JavaMailSender`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: To test SMTP, a test setup for SMTP is required to ensure that the mails are
    going out. In this example, FakeSMTP will be used. You can download FakeSMTP from
    [http://nilhcem.github.io/FakeSMTP](http://nilhcem.github.io/FakeSMTP).
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you download `fakeSMTP-2.0.jar`, run the SMTP server by executing the
    following command:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will open a GUI to monitor e-mail messages. Click on the **Start Server**
    button next to the listening port textbox.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `application.properties` with the following configuration parameters
    to connect to RabbitMQ as well as to the mail server:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We are ready to test our microservices end to end. Start both the Spring Boot
    apps. Open the browser and repeat the customer creation steps through the HAL
    browser. In this case, immediately after submitting the request, we will be able
    to see the e-mail in the SMTP GUI.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Internally, the Customer Profile service asynchronously calls the Customer
    Notification service, which, in turn, sends the e-mail message to the SMTP server:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a comprehensive microservice example](img/B05447_02_28.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: Spring Boot actuators
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections explored most of the Spring Boot features required to
    develop a microservice. In this section, some of the production-ready operational
    aspects of Spring Boot will be explored.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot actuators provide an excellent out-of-the-box mechanism to monitor
    and manage Spring Boot applications in production:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.bootactuator`
    project in the code files of this book.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Create another **Spring Starter Project** and name it `chapter2.bootactuator`.
    This time, select **Web** and **Actuators** under **Ops**. Similar to the `chapter2.bootrest`
    project, add a `GreeterController` endpoint with the `greet` method.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application as Spring Boot app.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point the browser to `localhost:8080/actuator`. This will open the HAL browser.
    Then, review the **Links** section.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A number of links are available under the **Links** section. These are automatically
    exposed by the Spring Boot actuator:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![Spring Boot actuators](img/B05447_02_29.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: 'Some of the important links are listed as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '`dump`: This performs a thread dump and displays the result'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mappings`: This lists all the HTTP request mappings'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`: This displays information about the application'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`health`: This displays the application''s health conditions'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoconfig`: This displays the autoconfiguration report'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metrics`: This shows different metrics collected from the application'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring using JConsole
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternately, we can use the JMX console to see the Spring Boot information.
    Connect to the remote Spring Boot instance from JConsole. The Boot information
    will be shown as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring using JConsole](img/B05447_02_30.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: Monitoring using SSH
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Boot provides remote access to the Boot application using SSH. The following
    command connects to the Spring Boot application from a terminal window:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The password can be customized by adding the `shell.auth.simple.user.password`
    property in the `application.properties` file. The updated `application.properties`
    file will look similar to the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When connected with the preceding command, similar actuator information can
    be accessed. Here is an example of the metrics information accessed through the
    CLI:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '`help`: This lists out all the options available'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dashboard`: This is one interesting feature that shows a lot of system-level
    information'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring application information
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following properties can be set in `application.properties` to customize
    application-related information. After adding, restart the server and visit the
    `/info` endpoint of the actuator to take a look at the updated information, as
    follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Adding a custom health module
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a new custom module to the Spring Boot application is not so complex.
    To demonstrate this feature, assume that if a service gets more than two transactions
    in a minute, then the server status will be set as Out of Service.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to customize this, we have to implement the `HealthIndicator` interface
    and override the `health` method. The following is a quick and dirty implementation
    to do the job:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The preceding class is a simple POJO class that maintains the transaction counts
    in the window. The `isWeak` method checks whether the transaction in a particular
    window reached its threshold. The `isExpired` method checks whether the current
    window is expired or not. The `increment` method simply increases the counter
    value.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next step, implement our custom health indicator class, `TPSHealth`.
    This is done by extending `HealthIndicator`, as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `health` method checks whether the counter is weak or not. A weak counter
    means the service is handling more transactions than it can handle. If it is weak,
    it marks the instance as Out of Service.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will autowire `TPSHealth` into the `GreetingController` class and
    then call `health.updateTx()` in the `greet` method, as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Go to the `/health` end point in the HAL browser and take a look at the status
    of the server.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Now, open another browser, point to `http://localhost:8080`, and fire the service
    twice or thrice. Go back to the `/health` endpoint and refresh to see the status.
    It should be changed to Out of Service.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: In this example, as there is no action taken other than collecting the health
    status, even though the status is Out of Service, new service calls will still
    go through. However, in the real world, a program should read the `/health` endpoint
    and block further requests from going to this instance.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Building custom metrics
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to health, customization of the metrics is also possible. The following
    example shows how to add counter service and gauge service, just for demonstration
    purposes:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add the following methods in the greet method:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Restart the server and go to `/metrics` to see the new gauge and counter added
    already reflected there.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Documenting microservices
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional approach of API documentation is either by writing service specification
    documents or using static service registries. With a large number of microservices,
    it would be hard to keep the documentation of APIs in sync.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can be documented in many ways. This section will explore how
    microservices can be documented using the popular Swagger framework. The following
    example will use Springfox libraries to generate REST API documentation. Springfox
    is a set of Java- and Spring-friendly libraries.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Spring Starter Project** and select **Web** in the library selection
    window. Name the project `chapter2.swagger`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code of this example is available as the `chapter2.swagger`
    project in the code files of this book.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'As Springfox libraries are not part of the Spring suite, edit `pom.xml` and
    add Springfox Swagger library dependencies. Add the following dependencies to
    the project:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a REST service similar to the services created earlier, but also add
    the `@EnableSwagger2` annotation, as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is all that''s required for a basic Swagger documentation. Start the application
    and point the browser to `http://localhost:8080/swagger-ui.html`. This will open
    the Swagger API documentation page:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting microservices](img/B05447_02_31.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
- en: As shown in the diagram, the Swagger lists out the possible operations on **Greet
    Controller**. Click on the **GET** operation. This expands the **GET** row, which
    provides an option to try out the operation.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Spring Boot and its key features to build
    production-ready applications.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: We explored the previous-generation web applications and then how Spring Boot
    makes developers' lives easier to develop fully qualified microservices. We also
    discussed the asynchronous message-based interaction between services. Further,
    we explored how to achieve some of the key capabilities required for microservices,
    such as security, HATEOAS, cross-origin, configurations, and so on with practical
    examples. We also took a look at how Spring Boot actuators help the operations
    teams and also how we can customize it to our needs. Finally, documenting microservices
    APIs was also explored.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deeper look at some of the practical issues
    that may arise when implementing microservices. We will also discuss a capability
    model that essentially helps organizations when dealing with large microservices
    implementations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
