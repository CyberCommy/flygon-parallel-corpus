- en: Using GitOps Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing how to configure a Kubernetes cluster, we will learn how to do
    it using GitOps practices instead of applying manual commands and files. GitOps
    means managing the cluster configuration using a Git repo to store and track the
    YAML files that contain the configuration. We will see how to link a GitHub repo
    with a cluster, so that it gets updated regularly, using Flux.
  prefs: []
  type: TYPE_NORMAL
- en: This method allows us to store the configuration in a deterministic way, describing
    the changes to infrastructure in code. The changes can be reviewed and the cluster
    can be recovered from scratch or duplicated, as we will see in [Chapter 9](6cd790eb-a881-418b-ba9f-b506ff82f924.xhtml),
    *Managing Workflows*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the description of GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Flux to control the Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a Kubernetes cluster change through GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will know how to store the Kubernetes configuration
    in a Git repository and apply automatically any changes that are merged into the
    main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the examples in the chapter is available on GitHub: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install the `fluxctl` tool. We will then use this tool to sync
    manually and to obtain an SSH key to allow Flux to interact with the Git repo.
    See how to install it in its documentation: [https://docs.fluxcd.io/en/stable/tutorials/get-started.html](https://docs.fluxcd.io/en/stable/tutorials/get-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the description of GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big traditional problem in operations has been ensuring that the different
    servers maintain a proper configuration. When you have a fleet of servers, deploying
    a service and keeping them properly configured is not a straightforward task.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will use *configuration* as a way of describing a service
    and all the required configuration to run it in production. This includes the
    particular version of the service, but also things such as the underlying infrastructure
    (OS version, number of servers, and so on) or packages and configuration of the dependent services
    (load balancers, third-party libraries, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '*Configuration management* will, therefore, be the way to make changes to that.'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping configuration on track in all servers is challenging as the infrastructure
    grows. The most common change is to deploy a new version of a service, but there
    are other possibilities. For example, there's a new server being added that needs
    to be added to the load balancer, new configuration tweaks for NGINX to fix a
    security bug, or a new environment variable for the service to enable a feature.
  prefs: []
  type: TYPE_NORMAL
- en: The initial stage is manual configuration, but that gets difficult to do after
    a while.
  prefs: []
  type: TYPE_NORMAL
- en: Managing configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The manual configuration means that someone on the team keeps track of a small
    number of servers, and when a change is required, logs individually on each server
    and makes the required changes.
  prefs: []
  type: TYPE_NORMAL
- en: This way of operating is work-intensive and error prone with multiple servers,
    as they could easily diverge.
  prefs: []
  type: TYPE_NORMAL
- en: So, after some time, it can be improved through some scripts using Fabric ([http://www.fabfile.org/](http://www.fabfile.org/))
    or Capistrano ([https://capistranorb.com/](https://capistranorb.com/)). The basic
    model is to push the configuration and the new code to the servers and perform
    a number of automated tasks, restarting the service at the end. Typically, this
    is done directly from the computers of the team, as a manual step.
  prefs: []
  type: TYPE_NORMAL
- en: The code and configuration are normally present on Git, but the manual process
    makes it possible to change this, as it is detached. If you work this way, ensure
    that only files stored under source control are being deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Some elements for server maintenance, like operating system upgrades or updating
    libraries, may still require to be done manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the code is pushed from the computer of the
    team member that makes the configuration change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb0cae60-9e53-4481-867b-a36d9c12c30b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this stage, new infrastructure can be added manually or by using a tool such
    as Terraform ([https://www.terraform.io/](https://www.terraform.io/)) to interact
    with cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated alternative is to use tools such as Puppet ([https://puppet.com/](https://puppet.com/))
    or Chef ([https://www.chef.io/](https://www.chef.io/)). They work with a client-server
    architecture. They allow us to describe the state of the servers using their own
    declarative language, and when that's changed in the server, all clients will
    update to follow the definition. The server will report any problems or deviations
    and will centralize the configuration definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is summarized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0efcc43d-9cf4-4a97-ba2f-bf652c5e7998.png)'
  prefs: []
  type: TYPE_IMG
- en: In some cases, these tools may be able to allocate resources in cloud services;
    for example, adding a new EC2 instance in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: A configuration management tool also helps in monitoring and performs a number
    of remediation tasks. For example, it can restart services that should be running,
    or retry if there has been a problem changing the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: It also scales better for a higher number of servers.
  prefs: []
  type: TYPE_NORMAL
- en: All these strategies require specialized tools and are normally handled by a
    specific operations team. This makes the configuration out of reach for developers
    requiring coordination between them in  order to make a configuration update.
  prefs: []
  type: TYPE_NORMAL
- en: This division of work creates some friction and, over time, the DevOps movement
    has proposed other ways of structuring this work.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional way of dividing the work was to create an operations team that
    will control the infrastructure and deployments, and a development team that creates
    the service.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that developers normally won't understand
    truly how their code works in production, and, simultaneously, operations won't
    exactly know what a deployment contains. This can lead to situations of *I don't
    know what it is*/*I don't know where it is*, where there is a chasm between the
    two teams. DevOps was eventually created as an approach to fill that gap.
  prefs: []
  type: TYPE_NORMAL
- en: A typical problem is one where a service frequently fails in production and
    is detected by operations, which performs remediation tactics (for example, restarting
    the service).
  prefs: []
  type: TYPE_NORMAL
- en: However, the development team doesn't know exactly what makes it fail and they
    have other pressing priorities, so they won't fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, this may compromise the stability of the system.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps is a set of techniques to improve collaboration between the operation
    side and the development side. It aims to allow quick deployment by making developers
    aware of the whole operation side, and to simplify operations by using automation
    as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The core of it is to empower teams to allow them to control their own infrastructure
    and deployments, speeding up the rate of deployment and understanding the infrastructure
    to help identify problems early. The team should be autonomous in deploying and
    supporting the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: To enable DevOps practices, you need some tools to control the different operations
    in a controlled way. GitOps is an interesting choice for that, especially if you
    use Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of GitOps is simple—we use Git to describe our infrastructure and configuration
    management. Any change to a defined branch will trigger the relevant changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are able to define the whole system through code, Git gives you a lot
    of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Any change to either infrastructure or configuration management is versioned.
    They are explicit and can be rolled back if they have problems. Changes between
    versions can be observed through diffs, which is a normal Git operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Git repo can act as a backup that can enable recovery from scratch if there's
    a catastrophic failure in the underlying hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the most common source control tool. Everyone in the company likely knows
    how it works and can use it. It also easily integrates with existing workflows,
    like reviews.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitOps concept was introduced and named by Weaveworks in a blog post ([https://www.weave.works/blog/gitops-operations-by-pull-request](https://www.weave.works/blog/gitops-operations-by-pull-request)).
    Since then, it has been used more and more in companies.
  prefs: []
  type: TYPE_NORMAL
- en: While GitOps could be applied to other kinds of deployments (and it certainly
    has been), it has good synergy with Kubernetes, which actually was the description
    in the Weaveworks blog post.
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster can be completely configured using YAML files, which encapsulates
    almost the whole definition of the system. As we saw in the previous chapter,
    this may include the definition of elements such as load balancers. The elements
    external to the Kubernetes cluster, such as an external DNS, which are not included
    in the YAML files, are rare to change.
  prefs: []
  type: TYPE_NORMAL
- en: The servers and infrastructure can be automated with other tools, like Terraform,
    or with the automated procedures described in [Chapter 7](92e63376-1c9e-4c63-9f7f-c34fa6848ef3.xhtml),
    *Configuring and Securing the Production System*.
  prefs: []
  type: TYPE_NORMAL
- en: For pragmatic reasons, it is entirely feasible that some infrastructure operations
    are manual. For example, upgrading the Kubernetes version of an EKS cluster is
    an operation that can be done through the AWS console, and it is rare enough that
    it is fine to do so manually.
  prefs: []
  type: TYPE_NORMAL
- en: It is also fine to have these kinds of operations remain manual, since automating
    them probably won't pay dividends.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 6](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml), *Local
    Development with Kubernetes*, the Kubernetes YAML files contain element definitions
    that can be applied with the `kubectl apply -f <file>` commands. Kubernetes is
    quite flexible since a single file can contain multiple elements or a single one.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping all the YAML files under a directory structure and getting them under
    Git control makes a very explicit way of applying changes. This is the way that
    we will operate.
  prefs: []
  type: TYPE_NORMAL
- en: This operation is not complicated, but we will use an existing tool, created
    by Weaveworks, called **Flux**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Flux to control the Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux ([https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)) is a
    tool that ensures that the state of a Kubernetes cluster matches the files stored
    in a Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: It gets deployed inside the Kubernetes cluster, as another deployment. It runs
    every 5 minutes and checks with the Git repo and Docker registry. Then, it applies
    any changes. This helps with access to the Git repo, as there's no need to create
    any push mechanism inside a CI system.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to start a Flux container inside Kubernetes that pulls from
    the GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For simplicity, we will use the local Kubernetes. We will use the images described
    in [Chapter 6](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml), *Local Development
    with Kubernetes*, so be sure to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The basic Kubernetes configuration is stored in the example folder ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08/example](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter08/example))
    subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can deploy the entire system with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This creates the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the `namespace.yaml` file to avoid not being able to deploy elements as
    the namespace is not present, but you can run the `kubectl apply -f . --recursive` command
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the system, it should be deployed now, as shown by running the `kubectl
    get pods` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are four copies of `frontend`. We will change the number of
    pods during this chapter as an example of how to change a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, delete the deployment to start from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For more details about this setup, check the *Deploying the full system locally* section
    in [Chapter 6](e7d90194-85f2-4f11-a573-d69382ef79cf.xhtml), *Local Development
    with Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will prepare a Flux system, which will help us keep track of our Git configuration. We
    prepared one based on the Flux example in this repo ([https://github.com/fluxcd/flux/tree/master/deploy](https://github.com/fluxcd/flux/tree/master/deploy)),
    and it's available in the `Chapter08/flux` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main file is `flux-deployment.yaml`. Most of it is commented boilerplate,
    but take a look at the definition of the repo to pull from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These lines tell Flux the repo to use, the branch, and any path. If the path
    is commented, which it probably is in your case, it uses the whole repo. In the
    next section, we will need to change the repo to use your own one.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use the `flux` namespace to deploy all these elements. You can
    reuse your main namespace or use the default one if it works better for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Flux, create the namespace and then apply the full `flux` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following code, you can check that everything is running as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But, to be able to deploy from a Git repo, we need to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though we can configure any Git repo, typically, we will use GitHub to set it
    up. We will need to set up a valid key to access the Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to do this is to allow Flux to generate its own key, and add
    it to the GitHub repo. But to be able to do so, we need to create our own GitHub
    repo.
  prefs: []
  type: TYPE_NORMAL
- en: Forking the GitHub repo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in configuring the repo is to fork it. Let''s look at the following
    steps for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the page of the GitHub repo for the code ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/))
    and click in Fork on the top-right corner to generate your own copy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have your own copy, it will have a URL similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, you need to replace it in the `Chapter08/flux/flux-deployment.yaml` file for
    the `--git-url` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you change it, reapply the Flux configuration with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, Flux is tracking your own repo under your full control, and you can make
    changes to it. First of all, we need to allow Flux to access the GitHub repo,
    which can be achieved through a deploy key.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a deploy key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow Flux to access GitHub, we need to add its secret key as a valid deploy
    key. Using `fluxctl`, it is easy to get the current `ssh` key; just run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With that information, go to the Settings | Deploy keys section on your forked
    GitHub project. Fill the title with a descriptive name, the Key section with your
    secret key as obtained before, and then select Add key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8ab5d41-bfa3-4964-83e9-88a473e2f7b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Be sure to select the checkbox for Allow write access. Now, Flux will be able
    to contact GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to synchronize the state on GitHub and the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can sync with Flux, so the description in GitHub is applied in the cluster,
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take a bit to sync, and it''s possible that you will get an error stating
    that it is cloning the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a couple of minutes and try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Your Flux deployment and, therefore, the local Kubernetes cluster are now in
    sync with the configuration in Git and will update with any change.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Kubernetes cluster change through GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your local Kubernetes cluster, through Flux, will update to reflect changes
    in the Git repo. Any change in Git will be propagated to the cluster after a few
    minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this with a test updating the number of pods in the frontend deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `Chapter08/example/frontend/deployment.yaml` file in your forked
    repo as described here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This changes the number of replicas from `4` to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Commit the change into the `master` branch and push into the GitHub repo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Monitor the cluster with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You will see how the number of frontend pods will decrease after a few minutes.
    You can speed it up by manually syncing Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Revert the change and see how they'll be added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flux won't delete elements to avoid problems. This means that removing a file
    of a deployment or service won't eliminate it from the repo. To do so, you need
    to remove it manually.
  prefs: []
  type: TYPE_NORMAL
- en: You can disable pods controlled by a deployment by setting the number of replicas
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have a cluster controlled by a GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some ideas on how to use this methodology efficiently in production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Working in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps is mainly aimed at working on production environments, which are bigger
    and more complex than the example local cluster we used in this chapter. In this
    section, we will describe how to use the advantages of Git to improve clarity
    in terms of deployments and changes, and how to be sure that we structure the
    different files under source control to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Creating structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structuring the YAML files is critical for a big deployment. Technically, you
    can join everything in a single file, but that's not the best way of handling
    it when it grows. Kubernetes allows a great deal of flexibility, so try to find
    a structure that works for you.
  prefs: []
  type: TYPE_NORMAL
- en: A simple one is to create subdirectories by namespace and then by microservice.
    This is the way we have structured it in this example. This structure keeps related
    elements together and has a clear path for anyone touching a microservice. If
    deployments affect only one microservice (as they should, as we discussed in [Chapter
    1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making the Move – Design, Plan,
    and Execute*, in the *Parallel deployment and development speed* section), this
    keeps changes in the same subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: But don't feel limited to this structure. If it makes sense for you, you can
    try something different; for example, making a division by element, that is, all
    deployments under a directory, all services under another, and so on. Don't be
    afraid to experiment and move elements, searching for the best structure for your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: All these files are under source control in GitHub, which allows us to use their
    features to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that any merge to the main branch will trigger a change in the cluster,
    this should be reviewed before going live.
  prefs: []
  type: TYPE_NORMAL
- en: You can do it by requiring a pull request that needs approval prior to merging.
    The approval can come from an Ops team dedicated to keeping track of the cluster,
    or by the owner of the microservice; for example, a team lead or manager.
  prefs: []
  type: TYPE_NORMAL
- en: You can enforce code owners natively in GitHub. This means that a change in
    a particular file or directory requires some user or team to approve it. Check
    the GitHub documentation for more info ([https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners)).
  prefs: []
  type: TYPE_NORMAL
- en: A single GitHub repo can also keep track of more than one environment, for example,
    a staging environment to run tests, and a production environment that is available
    to customers. You can divide them either by branch or subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: But GitHub features are not the only ones available, the regular Git tag is
    extremely versatile and allows us to define specific containers to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: Working with tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we've worked with the `latest` tag for the images. This uses
    the most recently built container, which can change each time that an image is
    built. For production, we should use a specific tag linked to an immutable container,
    as we discussed in [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build,
    Run, and Test Your Service Using Docker*, in the *Using a remote registry* section,
    and in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml), *Creating a Pipeline
    and Workflow*, in the *Pushing Docker Images from Travis CI* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means replacing the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is where being able to update the images in a controlled way shines. You
    will use the pipeline (as described in [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml),
    *Creating a Pipeline and Workflow*) to build and push the tagged images to the
    remote registry, and then you can control which specific version is deployed in
    the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it may be needed to stop the syncing. Flux works with the concept
    of workloads, which are updateable elements, in the same way as deployments.
  prefs: []
  type: TYPE_NORMAL
- en: You can stop the automatic updating of them or control how they are updated.
    Refer to the documentation for more information: [https://github.com/fluxcd/flux/blob/master/docs/using/fluxctl.md#workloads](https://github.com/fluxcd/flux/blob/master/docs/using/fluxctl.md#workloads).
  prefs: []
  type: TYPE_NORMAL
- en: Making this version under Git control makes it easy for developers revert to,
    or to come back to, a previous version.
  prefs: []
  type: TYPE_NORMAL
- en: To follow the continuous integration principles, try to make small changes and
    apply them quickly. Git will help you revert a bad change, but small incremental
    changes are easy to test and reduce the risk of breaking the system.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the operations will be simple changes—either change the version of the
    image to be deployed, or tweak parameters, such as the number of replicas or an
    environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with a review of the most common different kinds of
    configuration management strategies, and how they tend to be applied as a project
    grows. We discussed how the DevOps approach makes teams take ownership of their
    deployments and helps to fill the traditional gap between development and operations.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how the latest approach called GitOps works very well with a Kubernetes
    cluster, as the configuration is tightly described as a set of files. We went
    through the advantages of using Git to track the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced Flux, a tool that gets deployed inside your cluster and pulls
    changes from a Git repo branch. We presented an example configuration, deployed
    it in our local Kubernetes cluster, and configured GitHub to be able to work with
    it. This enabled any push to our Git branch in GitHub to be reflected in the local
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter with some strategies for working in production. We looked
    at making sure that the Kubernetes YAML files are properly structured, taking
    advantage of the GitHub features, and we learned how to release and roll back
    tagged images.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will describe the process of a full developing cycle
    for the cluster, from the introduction of a new feature until it gets deployed
    in a production environment. We will describe some useful strategies when working
    in live systems, so that the deployed code works smoothly and is of a high quality.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between using a script to push new code to servers and
    using a configuration management tool such as Puppet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the core idea behind DevOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using GitOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can GitOps only be used in a Kubernetes cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the Flux deployment located?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you need to configure in GitHub in order to allow Flux to access it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For working in production environments, which features does GitHub provide that
    can help ensure control over deployments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can learn more about DevOps practices and ideas in the following books: *Practical
    DevOps – Second Edition* ([https://www.packtpub.com/virtualization-and-cloud/practical-devops-second-edition](https://www.packtpub.com/virtualization-and-cloud/practical-devops-second-edition)),
    and *DevOps Paradox* ([https://www.packtpub.com/web-development/devops-paradox](https://www.packtpub.com/web-development/devops-paradox)).
  prefs: []
  type: TYPE_NORMAL
