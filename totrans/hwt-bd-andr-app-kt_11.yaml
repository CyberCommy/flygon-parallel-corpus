- en: 11\. Persisting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter goes in depth about data persistence in Android, as well as exploring
    the repository pattern. By the end of the chapter, you will be able to build a
    repository that can connect to multiple data sources, and then use this repository
    to download files from an API and save them on a device. You will know multiple
    ways to store (persist) data directly on a device and the frameworks accessible
    to do this. When dealing with a filesystem, you will learn how it's partitioned
    and how you can read and write files in different locations and using different
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned how to structure your code and how to
    save data. In the activity, you also had the opportunity to build a repository
    and use it to access data and save data through Room. You probably asked the question:
    Why do you need this repository? This chapter will seek to answer that. With the
    repository pattern, you will be able to retrieve data from a server and store
    it locally in a centralized way. The pattern is useful in situations where the
    same data is required in multiple places, thereby avoiding code duplication while
    also keeping ViewModels clean of any unnecessary extra logic.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look into the Settings app on your device, or the Settings feature of
    many apps, you will see some similarities. A list of items with toggles that can
    be on or off. This is achieved through `SharedPreferences` and `PreferenceFragments`.
    `SharedPreferences` is a way that allows you to store values in a file in key-value
    pairs. It has specialized mechanisms for reading and writing, thereby removing
    the concerns regarding threading. It's useful for small amounts of data and eliminates
    the need for something such as Room.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will also learn about the Android filesystem and how it's
    structured into external and internal memory. You'll also develop your understanding
    of read and write permissions, how to create `FileProvider` class in order to
    offer other apps access to your files, and how you can save those files without
    requesting permissions on the external drives. You'll also see how to download
    files from the internet and save them on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Another concept that will be explored in this chapter is using the *Camera*
    application to take photos and videos on your application's behalf and save them
    to external storage using FileProviders.
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Repository is a pattern that helps developers keep code for data sources separate
    from activities and ViewModels. It offers centralized access to data that can
    then be unit tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Diagram of repository architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.1: Diagram of repository architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, you can see the central role the repository plays
    in an application''s code. Its responsibilities include:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping all the data sources (SQLite, Network, File System) required by your
    activity or the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining and transforming the data from multiple sources into a single output
    required at your activity level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring data from one data source to another (saving the result of a network
    call to Room)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refreshing expired data (if necessary)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room, network layer, and `FileManager` represent the different types of data
    sources your repository can have. Room may be used to save large amounts of data
    from the network, while the filesystem can be used to store small amounts (`SharedPreferences`)
    or whole files.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel` will have a reference to your repository and will deliver the results
    to the activity, which will display the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Repositories should be organized based on domains, which means your app should
    have different repositories for different domains and not one giant repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Creating a Repository'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create an app in Android Studio that connects to the
    API located at [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
    using Retrofit and retrieves a list of posts that will then be saved using Room.
    The UI will display the title and the body of each post in `RecyclerView`. We
    will implement this using the repository pattern with `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to complete this exercise, we will need to build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A network component responsible for downloading and parsing the JSON file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Room database responsible for storing the data with one entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A repository that manages the data between the components built previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ViewModel` that accesses the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An activity with `RecyclerView` model that displays the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by adding the `app/build.gradle` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will need to group the classes that will deal with the API communication.
    We will do this by creating an `api` package that will contain the classes required
    for networking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we define a `Post` class, which will map the data in the JSON file. Each
    field in the JSON file representing a post will be defined in our new model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a `PostService` interface, which will be responsible for loading
    the data from the server through Retrofit. The class will have one method for
    retrieving the list of posts and will perform an `HTTP GET` call to retrieve the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's set up our Room database, which will contain one entity and one
    data access object. Let's define a `db` package for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `PostEntity` class will have similar fields to the `Post` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`PostDao` should contain methods for storing a list of posts and retrieving
    the list of posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, in the case of the Room configuration, the `Post` database should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It's time to move into the `Repository` territory. So, let's create a repository package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we defined two types of `Post`, one modeled on the JSON and one
    entity. Let''s define a `PostMapper` class that converts from one to the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now define a repository interface that will be responsible for loading
    the data. The repository will load the data from the API and store it using Room
    and will then provide `LiveData` with the `Room` entity that the UI layer will
    then consume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s provide the implementation for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the preceding code, you can see that when the posts are loaded,
    we will make an asynchronous call to the network to load the posts. When the call
    finishes, we update Room with a new list of posts on a separate thread. The method
    will always return what Room returns. This is because when the data eventually
    changes in Room, it will be propagated to the observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now set up our dependencies. Because we have no dependency injection
    framework, we will have to rely on the `Application` class, which means we will
    need a `RepositoryApplication` class in which we will initialize all the services
    that the repository will require and then create the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Add `RepositoryApplication` to `android:name` in the `<application>` tag in
    `AndroidManifest.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add internet permission to the `AndroidManifest.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now define our `ViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `view_post_row.xml` layout file for each row will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `activity_main.xml` layout file for our activity will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PostAdapter` class for the rows will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the `MainActivity` file will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Output of Exercise 11.01'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2: Output of Exercise 11.01'
  prefs: []
  type: TYPE_NORMAL
- en: You can now turn the internet on and off and close and re-open the app to see
    that the data that was initially persisted will continue to be displayed. In the
    current implementation, the error handling is left empty for now. This means that
    in case something goes wrong when retrieving the list of posts, the user will
    not be informed of this. This may become a problem and make users frustrated.
    Most applications have some error message or other displayed on their user interface,
    with one of the most common error messages being `Something went wrong. Please
    try again`, which is used as a generic placeholder when the error is not properly identified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Adding Error Handling'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will modify the previous exercise. In the case of an internet
    error, we will ensure that it will display a toast with the message *Something
    went wrong*. In the process of adding error handling, we will also need to remove
    the dependency between the UI and the entity classes by creating a new model class
    that will hold the relevant data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to handle the error, we will need to build the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A new model class containing just the body and text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sealed class containing three inner classes for success, error, and loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mapping function between our new model and the network post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our new model. This type of model is common when combined
    with the repository pattern and the reason for this is simple. The new models
    may contain data that is specific for this screen that requires some extra logic
    (let''s say you have a user that has `firstName` and `lastName`, but your UI requires
    you to display both in the same `TextView`. By creating a new model with a name
    field, you can solve this issue and also unit test the conversion and avoid moving
    that concatenation on your UI layer):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And now to our new sealed class. The subclasses of this sealed class contain
    all the states of the data loading. The `Loading` state will be emitted when the
    repository starts loading the data, the `Success` state will be emitted when the
    repository has successfully loaded the data and contains the list of posts, and
    the `Error` state will be emitted when an error occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The mapping method in `PostMapper` will look like this. It has an extra method
    that will convert the data extract from the API to the UI model, which will only
    have the fields necessary for the UI to be properly displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s modify `PostRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s modify `PostRepositoryImpl`. Our result will be `MutableLiveData`
    that will begin with the `Loading` value and, based on the status of the HTTP
    request, it will either send a `Success` message with a list of items or an `Error`
    message with the error `Retrofit encountered`. This approach will no longer rely
    on showing the stored values at all times. When the request is successful, the
    output from the HTTP call will be passed instead of the output from Room:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the activity where you observe the live data, the following changes need
    to be implemented. Here, we will check each state and update the UI accordingly.
    If there is an error, we show an error message; if successful, we show the list
    of items; and when it is loading, we show a progress bar, indicating to the user
    that work is being done in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, your adapter should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, you should see the screen presented in *Figure 11.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Output of Exercise 11.02'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.3: Output of Exercise 11.02'
  prefs: []
  type: TYPE_NORMAL
- en: 'From this point on, the repository can be expanded in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding algorithms that will request the data only after a certain time has passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a more complex result class that will be able to store the cached data
    as well as an error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding in-memory caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding swipe-to-refresh functionality that will refresh the data when `RecyclerView`
    is swiped down and connecting the loading widget to the `Loading` state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you are tasked with integrating a third-party API that uses something
    such as OAuth to implement logging in with Facebook, Google, and suchlike. The
    way these mechanisms work is as follows: they give you a token that you have to
    store locally and that can then be used to send other requests to access user
    data. The questions you''re faced with are: How can you store that token? Do you
    use Room just for one token? Do you save the token in a separate file and implement
    methods for writing the file? What if that file has to be accessed in multiple
    places at the same time? `SharedPreferences` is an answer to these questions.
    `SharedPreferences` is a functionality that allows you to save Booleans, integers,
    floats, longs, strings, and sets of strings into an XML file. When you want to
    save new values, you specify what values you want to save for the associated keys,
    and when you are done, you commit the change, which will trigger the save to the
    XML file in an asynchronous way. The `SharedPreferences` mappings are also kept
    in memory, so that when you want to read these values it''s instantaneous, thereby
    removing the need for an asynchronous call to read the XML file.'
  prefs: []
  type: TYPE_NORMAL
- en: The standard way of accessing `SharedPreferences` data is through the `SharedPreferences`
    objects and the more recent `EncryptedSharedPreferences` option (if you wish to
    keep your data encrypted). There is also a specialized implementation through
    `PreferenceFragments`. These are useful in situations where you want to implement
    a settings-like screen where you want to store different configuration data that
    the user wishes to adjust.
  prefs: []
  type: TYPE_NORMAL
- en: SharedPreferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way to access the `SharedPreference` object is through the `Context` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is where you specify the name of your preferences, and the
    second is how you want to expose the file to other apps. Currently, the best mode
    is the private one. All of the others present potential security risks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a specialized implementation for accessing the default `SharedPreferences`
    file, which is used by `PreferenceFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to write data into your preferences file, you first need to get
    access to the Preferences editor. The editor will give you access to writing the
    data. You can then write your data in the editor. Once you finish writing, you
    will have to apply the changes that will trigger persistence to the XML file and
    will change the in-memory values as well. You have two choices for applying the
    changes on your preference file: `apply` or `commit`. `apply` will save your changes
    in memory instantly, but then the writing to the disk will be asynchronous, which
    is good if you want to call this from your app''s main thread. `commit` does everything
    synchronously and gives you a boolean result informing you if the operation was
    successful. In practice, `apply` tends to be favored over `commit`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you want to clear your entire data. The same principle will apply; you''ll
    need the `editor`, `clear`, and `apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you want to read the values you previously saved, you can use the `SharedPreferences`
    object to read the stored values. In case there is no saved value, you can opt
    for a default value to be returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 11.03: Wrapping SharedPreferences'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to build an application that displays `TextView`, `EditText`, and
    a button. `TextView` will display the previous saved value in `SharedPreferences`.
    The user can type new text, and when the button is clicked, the text will be saved
    in `SharedPreferences` and `TextView` will display the updated text. We will need
    to use `ViewModel` and `LiveData` in order to make the code more testable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to complete this exercise, we will need to create a `Wrapper` class,
    which will be responsible for saving the text. This class will return the value
    of the text as `LiveData`. This will be injected into our `ViewModel`, which will
    be bound to the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by adding the appropriate libraries to `app/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make our `Wrapper` class, which will listen for changes in `SharedPreferences`
    and update the value of `LiveData` when the preferences change. The class will
    contain methods to save the new text and to retrieve `LiveData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice the top of the file. We've added a listener so that when our `SharedPreferences`
    values change, we can look up the new value and update our `LiveData` model. This
    will allow us to observe the `LiveData` for any changes and just update the UI.
    The `saveText` method will open the editor, set the new value, and apply the changes.
    The `getText` method will read the last saved value, set it in `LiveData`, and
    return the `LiveData` object. This is helpful in scenarios where the app is opened
    and we want to access the last value prior to the app closing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s set up the `Application` class with the instance of the preferences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the appropriate attributes in the `application` tag to `AndroidManifest.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s build the `ViewModel` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s define our `activity_main.xml` layout file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, in `MainActivity`, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the output presented in *Figure 11.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Output of Exercise 11.03'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.4: Output of Exercise 11.03'
  prefs: []
  type: TYPE_NORMAL
- en: Once you insert a value, try closing the application and re-opening it. The
    app will display the last persisted value.
  prefs: []
  type: TYPE_NORMAL
- en: PreferenceFragment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, `PreferenceFragment` is a specialized implementation
    of a fragment that relies on `SharedPreferences` in order to store user settings.
    Its features include storing Booleans based on on/off toggles, storing text based
    on dialogs displayed to the user, storing string sets based on single and multi-choice
    dialogs, storing integers based on `SeekBars`, and categorizing the sections and
    linking to other `PreferenceFragment` classes.
  prefs: []
  type: TYPE_NORMAL
- en: While `PreferenceFragment` classes are part of the Android framework, they are
    marked as deprecated, which means that the recommended approach for fragments
    is to rely on the Jetpack Preference library, which introduces `PreferenceFragmentCompat`.
    `PreferenceFragmentCompat` is useful for ensuring backward compatibility between
    newer Android frameworks and older ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to build a `PreferenceFragment` class, two things are required:'
  prefs: []
  type: TYPE_NORMAL
- en: A resource in the `res/xml` folder, where the structure of your preferences
    will be structured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class extending `PreferenceFragment`, which will link the XML file with the fragment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to access the values that your `PreferenceFragment` stored from
    non-`PreferenceFragment` resources, you can access the `SharedPreference` object
    using the `PreferenceManager.getDefaultSharedPreferences(context)` method. The
    keys to accessing the values are the keys you defined in the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a preference XML file named settings_preference.xml would look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For every preference, you have the ability to show icons, a title, a summary,
    a current value, and whether it's selectable. An important thing is the key and
    how to link it to your Kotlin code. You can use the `strings.xml` file to declare
    non-translatable strings, which you can then extract in your Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `PreferenceFragment` will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `onCreatePreferences` method is abstract, and you will need to implement
    it in order to specify the XML resource for your preferences through the `setPreferencesFromResource`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also access the preferences programmatically using the `findPreference` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will return an object that will extend from `Preference`. The nature of
    the object should match the type declared in the XML for that particular key.
    You can modify the `Preference` object programmatically and change the desired
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also build a Settings screen programmatically using `createPreferenceScreen(Context)`
    on the `PreferenceManager` class that''s inherited in `PreferenceFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `addPreference(Preference)` method on the `PreferenceScreen`
    container to add a new `Preference` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let's now move on to the next exercise to customize your settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.04: Customized Settings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to build the settings for a VPN app. The product
    requirements for the settings page are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SeekBar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: IP address – Text; Domain – Text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Use mobile data`, with a toggle and a non-selectable option below containing
    the text `Manage your mobile data wisely`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the Jetpack Preference library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In `res/values`, create a file named `preference_keys.xml` and let''s define
    the key for the `More preferences` screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Create the `xml` folder in `res` if it's not available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `preferences_more.xml` file in the `res/xml` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `preferences_more.xml` file, add the following preferences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In `strings.xml`, add the following strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `PreferenceFragment` class called `MorePreferenceFragment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We are done with the `More` section. Let's now create the main section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the keys for the main preference section. In `preference_keys.xml`,
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In `res/xml`, create the `preferences_settings.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, define your preferences according to the specs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In `strings.xml`, make sure you have the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Create a fragment called `SettingsPreferenceFragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add `Fragments` to our activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `activity_main.xml`, define a `FrameLayout` tag to contain the fragments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, in `MainActivity`, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code will produce the following output:![Figure 11.5:
    Output of Exercise 11.04'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_11_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.5: Output of Exercise 11.04'
  prefs: []
  type: TYPE_NORMAL
- en: We can now monitor the changes to preferences and display them in the UI. We
    can apply this functionality to the IP address and domain sections to display
    what the user typed as a summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now modify `SettingsPreferenceFragment` to programmatically set a listener
    for when values change, which will display the new value in the summary. We will
    also need to set the saved values when the screen is first opened. We will need
    to locate preferences we want to modify using `findPreference(key)`. This allows
    us to programmatically modify a preference. We can also register listeners on
    the preference, which will give us access to the new value. In our case, we can
    register a listener for when the IP address changes, so we can update the summary
    of the field based on what was introduced in `EditText` by the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`PreferenceFragment` is a good way of building settings-like functionality
    for any application. Its integration with `SharedPreferences` and built-in UI
    components allow developers to build elements quicker than usual and solve many
    issues with regard to handling the clicks and elements inserted for each setting
    element.'
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve discussed Room and `SharedPreferences` and specified how the data they
    store is written to files. You may ask yourself, where are these files stored?
    These particular files are stored in internal storage. Internal storage is a dedicated
    space for every app that other apps are unable to access (unless the device is
    rooted). There is no limit to the amount of storage your app uses. However, users
    have the ability to delete your app''s files from the Settings menu. Internal
    storage occupies a smaller part of the total available space, which means that
    you should be careful when it comes to storing files in internal storage. There
    is also external storage. The files your app stores are accessible to other apps
    and the files from other apps are accessible to your app:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, you can use the Device File Explorer tool to navigate through
    the files on the device or emulator. Internal storage is located in `/data/data/{packageName}`.
    If you have access to this folder, this means that the device is rooted. Using
    this, you can visualize the database files and the `SharedPreferences` files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Android Device File Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6: Android Device File Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Internal Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Internal storage requires no permissions from the user. To access the internal
    storage directories, you can use one of the following methods from the `Context`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getDataDir()`: Returns the root folder of your application sandbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFilesDir()`: A dedicated folder for application files; recommended for usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCacheDir()`: A dedicated folder where files can be cached. Storing files
    here does not guarantee that you can retrieve them later because the system may
    decide to delete this directory to free memory. This folder is linked to the `Clear
    Cache` option in `Settings`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDir(name, mode)`: Returns a folder that will be created if it does not
    exist based on the name specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When users use the `Clear Data` option from `Settings`, most of these folders
    will be deleted, bringing the app to a similar state as a fresh install. When
    the app is uninstalled, then these files will be deleted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical example of reading a cache file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will read from `my-file.txt`, located in the `Cache` directory,
    and will create `FileInputStream` for that file. Then, a buffer will be used that
    will collect the bytes from the file. The collected bytes will be placed in the
    `bytes` byte array, which will contain all of the data read from that file. Reading
    will stop when the entire length of the file has been read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing to the `my-file.txt` file will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding example does is take the byte array you want to write, create
    a new `File` object, create the file if it doesn't exist, and write the bytes
    into the file through `FileOutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are many alternatives to dealing with files. The readers (`StreamReader`,
    `StreamWriter`, and so on) are better equipped for character-based data. There
    are also third-party libraries that help with disk I/O operations. One of the
    most common third parties that help with I/O operations is called Okio. It started
    life as part of the `OkHttp` library, which is used in combination with Retrofit
    to make API calls. The methods provided by Okio are the same methods it uses to
    write and read data in HTTP communications.
  prefs: []
  type: TYPE_NORMAL
- en: External Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading and writing in external storage requires user permissions for reading
    and writing. If write permission is granted, then your app has the ability to
    read the external storage. Once these permissions are granted, then your app can
    do whatever it pleases on the external storage. That may present a problem because
    users may not choose to grant these permissions. However, there are specialized
    methods that offer you the possibility to write on the external storage in folders
    dedicated to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most common ways of accessing external storage are from the `Context`
    and `Environment` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Context.getExternalFilesDir(mode)`: This method will return the path to the
    directory on the external storage dedicated to your application. Specifying different
    modes (pictures, movies, and so on) will create different subfolders depending
    on how you want your files saved. This method *does not require permissions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context.getExternalCacheDir()`: This will point toward the application''s
    cache directory on the external storage. The same considerations should be applied
    to this `cache` folder as to the internal storage option. This method *does not
    require permissions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Environment` class has access to paths of some of the most common folders
    on the device. However, on newer devices, apps may not have access to those files
    and folders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using hardcoded paths to files and folders. The Android operating system
    may shift the location of folders around depending on the device or operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: FileProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This represents a specialized implementation of `ContentProviders` that is useful
    in organizing the file and folder structure of your application. It allows you
    to specify an XML file in which you define how your files should be split between
    internal and external storage if you choose to do so. It also gives you the ability
    to grant access to other apps to your files by hiding the path and generating
    a unique URI to identify and query your file.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileProvider` gives you the choice to pick between six different folders where
    you can set up your folder hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Context.getFilesDir()` (files-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context.getCacheDir()` (cache-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Environment.getExternalStorageDirectory()` (external-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context.getExternalFilesDir(null)` (external-files-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context.getExternalCacheDir()` (external-cache-path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First result of `Context.getExternalMediaDirs()` (external-media-path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main benefits of `FileProvider` are the abstractions it provides in organizing
    your files since leaving the developer to define the paths in an XML file and,
    more importantly, if you chose to use it to store files on the external storage,
    you do not have to ask for permissions from the user. Another benefit is the fact
    that it makes sharing of internal files easier while giving the developer control
    of what files other apps can access without exposing their real location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us understand better through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will make `FileProvider` use the internal `files` directory
    and create a folder named `my-folder-name`. When the path is converted to a URI,
    then the URI will use `my-visible-name`.
  prefs: []
  type: TYPE_NORMAL
- en: Storage Access Framework (SAF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SAF is a file picker introduced in Android KitKat that apps can use for
    their users to pick files with a view to being processed or uploaded. You can
    use it in your app for the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Your app requires the user to process a file saved on the device by another
    app (photos and videos).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to save a file on the device and give the user the choice of where
    they want the file to be saved and the name of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to offer the files your application uses to other apps for scenarios
    similar to scenario number 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is again useful because your app will avoid read and write permissions
    and still write and access external storage. The way this works is based on intents.
    You can start an activity for a result with `Intent.ACTION_OPEN_DOCUMENT` or `Intent.ACTION_CREATE_DOCUMENT`.
    Then, in `onActivityResult`, the system will give you a URI that grants you temporary
    permissions to that file, allowing you to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of the SAF is the fact that the files don't have to be on a
    device. Apps such as Google Drive expose their content in the SAF and when a Google
    Drive file is selected, it will be downloaded to the device and the URI will be
    sent as a result. Another important thing to mention is the SAF's support for
    virtual files, meaning that it will expose Google docs, which have their own format,
    but when those docs are downloaded through the SAF, their formats will be converted
    to a common format such as PDF.
  prefs: []
  type: TYPE_NORMAL
- en: Asset Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asset files are files you can package as part of your APK. If you've used apps
    that played certain videos or GIFs when the app is launched or as part of a tutorial,
    odds are that the videos were bundled with the APK. To add files to your assets,
    you need the `assets` folder inside your project. You can then group your files
    inside your assets using folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access these files at runtime through the `AssetManager` class, which
    itself can be accessed through the context object. `AssetManager` offers you the
    ability to look up the files and read them, but it does not permit any write operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example lists all files inside the root of the `assets` folder.
    The `open` function returns `inputStream`, which can be used to read the file
    information if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: One common usage of the `assets` folder is for custom fonts. If your application
    uses custom fonts, then you can use the `assets` folder to store font files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.05: Copying Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, you will need an emulator. You can do so by selecting the
    `Tools` | `AVD Manager` in Android Studio. Then, you can create one with the `Create
    Virtual Device` option, selecting the type of emulator, clicking `Next`, and then
    selecting an x86 image. Any image larger than Lollipop should be acceptable for
    this exercise. Next, you can give your image a name and click `Finish`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an app that will keep a file named `my-app-file.txt` in the `assets`
    directory. The app will display two buttons called `FileProvider` and `SAF`. When
    the `FileProvider` button is clicked, the file will be saved on the external storage
    inside the app's external storage dedicated area (`Context.getExternalFilesDir(null)`).
    The `SAF` button will open the SAF and allow the user to indicate where the file
    should be saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this exercise, the following approach will be adopted:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a file provider that will use the `Context.getExternalFilesDir(null)`
    location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy `my-app-file.txt` to the preceding location when the `FileProvider` button
    is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Intent.ACTION_CREATE_DOCUMENT` when the `SAF` button is clicked and copy
    the file to the location provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a separate thread for the file copy to comply with the Android guidelines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Apache IO library to help with the file copy functionality, by providing
    methods that allow us to copy data from an InputStream to an OutputStream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our Gradle configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Create the `my-app-file.txt` file in the `main/assets` folder. Feel free to
    fill it up with the text you want to be read. If the `main/assets` folder doesn't
    exist, then you can create it. In order to create the `assets` folder, you can
    right-click on the `main` folder and select `New` and then select `Directory`
    and name it `assets`. This folder will now be recognized by the build system and
    any file inside it will also be installed on the device along with the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also define a class that will wrap `AssetManager` and define a method
    to access this particular file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s work on the `FileProvider` aspect. Create the `xml` folder in the
    `res` folder. Define `file_provider_paths.xml` inside the new folder. We will
    define `external-files-path`, name it `docs`, and place it in the `docs/` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add `FileProvider` to the `AndroidManifest.xml` file and link
    it with the new path we defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The name will point to the `FileProvider` path that's part of the Android Support
    library. The authorities field represents the domain your application has (usually
    the package name of the application). The exported field indicates if we wish
    to share our provider with other apps, and `grantUriPermissions` indicates if
    we wish to grant other applications access to certain files through the URI. The
    meta-data links the XML file we defined previously with `FileProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `ProviderFileManager` class, which is responsible for accessing
    the `docs` folder and writing data into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FileToUriMapper` class looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now move on to defining our UI for the `activity_main.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define our `MainActivity` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: Output of copy through FileProvider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.7: Output of copy through FileProvider'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the logic for the `SAF` button. We will need to start an activity
    pointing toward the `SAF` with the `CREATE_DOCUMENT` intent in which we specify
    that we want to create a text file. We will then need the result of the `SAF`
    so we can copy the file to the location selected by the user. In `MainActivity`
    in `onCreateMethod`, we can add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding code will do is to create an intent to create a document
    with the name of `Copied.txt` and the `text/plain` MIME (Multipurpose Internet
    Mail Extensions) type (which is suitable for text files). This code will only
    run in Android versions bigger than KitKat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now tell the activity how to handle the result of the document creation.
    We will receive a URI object with an empty file selected by the user. We can now
    copy our file to that location. In `MainActivity`, we add `onActivityResult`,
    which will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the URI. We can add a method to `ProviderFileManager` that will
    copy our file to a location given by `uri`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can invoke this method from the `onActivityResult` method of `MainActivity`
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code and click on the `SAF` button, we will see the
    output presented in *Figure 11.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: Output of copy through the SAF'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.8: Output of copy through the SAF'
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to save the file, the SAF will be closed and our activity's `onActivityResult`
    method will be called, which will trigger the file copy. Afterward, you can navigate
    the Android Device File Manager tool to see whether the file was saved properly.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Android 10 and with further updates in Android 11, the notion of Scoped
    Storage was introduced. The main idea behind this is to allow apps to gain more
    control of their files on the external storage and prevent other apps from accessing
    these files. The consequences of this mean that `READ_EXTERNAL_STORAGE` and `WRITE_EXTERNAL_STORAGE`
    will only apply for files the user interacts with (like media files). This discourages
    apps to create their own directories on the external storage and instead stick
    with the one already provided to them through the `Context.getExternalFilesDir`.
  prefs: []
  type: TYPE_NORMAL
- en: FileProviders and Storage Access Framework are a good way of keeping your app's
    compliance with the scoped storage practices because one allows the app to use
    the `Context.getExternalFilesDir` and the other uses the built-in File Explorer
    app which will now avoid files from other applications in the `Android/data` and
    `Android/obb` folders on the external storage.
  prefs: []
  type: TYPE_NORMAL
- en: Camera and Media Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android offers a variety of ways to interact with media on an Android device,
    from building your own camera application and controlling how users take photos
    and videos to using the existing camera application and instructing it on how
    to take photos and videos. Android also comes with a `MediaStore` content provider,
    allowing applications to extract information about media files that are set on
    the device and shared between applications. This is useful in situations where
    you want a custom display for media files that exist on the device (such as a
    photo or music player application) and in situations where you use the `MediaStore.ACTION_PICK`
    intent to select a photo from the device and want to extract the information about
    the selected media image (this is usually the case for older applications where
    the SAF cannot be used).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use an existing camera application, you will need to use the `MediaStore.ACTION_IMAGE_CAPTURE`
    intent to start a camera application for a result and pass the URI of the image
    you wish to save. The user will then go to the camera activity, take the photo,
    and then you handle the result of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `photoUri` parameter will represent the location of where you want your
    photo to be saved. It should point to an empty file with a JPEG extension. You
    can build this file in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file on the external storage using the `File` object (this requires
    the `WRITE_EXTERNAL_STORAGE` permission) and then use the `Uri.fromFile()` method
    to convert it into a `URI` - no longer applicable on Android 10 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a file in a `FileProvider` location using the `File` object and then
    use the `FileProvider.getUriForFile()` method to obtain the URI and grant it permissions
    if necessary. - the recommended approach for when your app targets Android 10
    and Android 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same mechanism can be applied to videos using `MediaStore.ACTION_VIDEO_CAPTURE`.
  prefs: []
  type: TYPE_NORMAL
- en: If your application relies heavily on the camera features, then you can exclude
    the application from users whose devices don't have cameras by adding the `<uses-feature>`
    tag to the `AndroidManifest.xml` file. You can also specify the camera as non-required
    and query whether the camera is available using the `Context.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to have your file saved in `MediaStore`, there are multiple ways
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send an `ACTION_MEDIA_SCANNER_SCAN_FILE` broadcast with the URI of your media:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the media scanner to scan files directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert the media into `ContentProvider` directly using `ContentResolver`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `MediaScanner` functionality no longer adds files from `Context.getExternalFilesDir`
    in Android 10 and above. Apps should rely on the `insert` method instead if they
    chose to share their media files with the rest of the apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.06: Taking Photos'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to build an application that has two buttons: the first button
    will open the camera app to take a photo, and the second button will open the
    camera app to record a video. We will use `FileProvider` to save the photos to
    the external storage (external-path) in two folders: `pictures` and `movies`.
    The photos will be saved using `img_{timestamp}.jpg`, and the videos will be saved
    using `video_{timestamp}.mp4`. After a photo and video have been saved, you will
    copy the file from the `FileProvider` into the `MediaStore` so it will be visible
    for other apps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the libraries in `app/build.gradle` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We will be targeting Android 11 which means that we need the following configuration
    in `app/build.gradle`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to request the WRITE_EXTERNAL_STORAGE permission for devices that
    have less than Android 10, which means we need the following in `AndroidManifest.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a `FileHelper` class, which will contain methods that are harder
    to test in the `test` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define our `FileProvider` paths in `res/xml/file_provider_paths.xml`.
    Make sure to include the appropriate package name for your application in `FileProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the file provider paths to the `AndroidManifest.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now define a model that will hold both the `Uri` and the associated
    path for a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a `ContentHelper` class which will provide us with data required
    for the `ContentResolver`. We will define two methods for accessing the Photo
    and Video content Uri and two methods that will create the `ContentValues`. We
    do this because of the static methods required to obtain Uris and the `ContentValues`
    creation which makes this functionality hard to test. The code below is truncated
    for space. The full code you need to add can be found via the link below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `ProviderFileManager` class, where we will define methods
    to generate files for photos and videos that will then be used by the camera and
    the methods that will save to the media store. Again, the code has been truncated
    for brevity. Please see the link below for the full code that you need to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we defined the root folders as `context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)`
    and `context.getExternalFilesDir(Environment.DIRECTORY_MOVIES)`. This connects
    to `file_provider_paths.xml` and it will create a set of folders called `Movies`
    and `Pictures` in the application's dedicated folder on the external storage.
    The `insertToStore` method is where the files will be then copied to the `MediaStore`.
    First we will create an entry into that store which will give us a Uri for that
    entry. Next we copy the contents of our files from the Uri generated by the `FileProvider`
    into the `OutputStream` pointing to the `MediaStore` entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the layout for our activity in `res/layout/activity_main.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `MainActivity` class where we will check if we need to request
    the WRITE_STORAGE_PERMISSION, request it if we need to and after it was granted
    open the camera to take a photo or a video. As above, code has been truncated
    for brevity. You can access the full code using the link shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the preceding code, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: Output of Exercise 11.06'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.9: Output of Exercise 11.06'
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on either of the buttons, you will be redirected to the camera
    application where you can take a photo or a video if you are running the example
    on Android 10 and above. If you''re running on lower Android versions then the
    permissions will be asked first. Once you have taken your photo and confirmed
    it, you will be taken back to the application. The photo will be saved in the
    location you defined in `FileProvider`:![Figure 11.10: The location of the captured
    files through the camera app'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_11_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.10: The location of the captured files through the camera app'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see where the files are located with the
    help of the Android Studio Device File Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `MainActivity` and add the `onActivityResult` method to trigger the
    save of the files to the MediaStore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: If you open any file exploring app like the "Files" app or the Gallery or Google
    Photos app, you will be able to see the videos and pictures taken.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11: The files from the app present in the File Explorer app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_11_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.11: The files from the app present in the File Explorer app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Dog Downloader'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are tasked with building an application that will target Android versions
    above API 21 that will display a list of URLs for dog photos. The URL you will
    connect to is `https://dog.ceo/api/breed/hound/images/random/{number}`, where
    `number` will be controlled through a Settings screen where the user can choose
    the number of URLs they want to be displayed. The Settings screen will be opened
    through an option presented on the home screen. When the user clicks on a URL,
    the image will be downloaded locally in the application's external cache path.
    While the image is being downloaded, the user will see an indeterminate progress
    bar. The list of URLs will be persisted locally using Room.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technologies that will be used are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrofit for retrieving the list of URLs and for downloading files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Room for persisting the list of URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SharedPreferences` and `PreferencesFragment` for storing the number of URLs
    to retrieve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileProvider` for storing the files in the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache IO for writing the files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository for combining all the data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiveData` and `ViewModel` for handling the logic from the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecyclerView` for the list of Items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The response JSON will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `api` package that will contain the network-related classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a data class that will model the response JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Retrofit `Service` class that will contain two methods. The first method
    will represent the API call to return a list of breeds, and the second method
    will represent the API call to download the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `storage` package and, inside the `storage` package, create a `room` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `Dog` entity, which will contain an autogenerated ID and a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `DogDao` class, which will contain methods to insert a list of `Dogs`,
    delete all the `Dogs`, and query all `Dogs`. The `delete` method is required because
    the API model does not have any unique identifiers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `storage` package, create a `preference` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `preference` package, create a wrapper class around `SharedPreferences`
    that will return the number of URLs we need to use. The default will be `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `res/xml`, define your folder structure for `FileProvider`. The files should
    be saved in the root folder of the `external-cache-path` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `storage` package, create a `filesystem` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `filesystem` package, define a class that will be responsible for
    writing `InputStream` into a file in `FileProvider`, using `Context.externalCacheDir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `repository` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `repository` package, create a sealed class that will hold the result
    of an API call. The subclasses of the sealed class will be `Success`, `Error`,
    and `Loading`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `Repository` interface that will contain two methods, one to load the
    list of URLs, and the other to download a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `DogUi` model class that will be used in the UI layer of your application
    and that will be created in your repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a mapper class that will convert your API models into entities and entities
    into UI models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an implementation for `Repository` that will implement the preceding
    two methods. The repository will hold references to `DogDao`, the Retrofit `Service`
    class, the `Preferences` wrapper class, the class managing the files, the `Dog`
    mapping class, and an `Executor` class for multithreading. When downloading the
    files, we will be using the filename extracted from the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class that will extend `Application`, which will initialize the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `ViewModel` used by your UI, which will have a reference to `Repository`
    and will call `Repository` to load the URL list and download the images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define your UI, which will be composed of two activities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The activity displays the list of URLs and will have the click action to start
    the downloads. This activity will have a progress bar, which will be displayed
    when the download takes place. The screen will also have a `Settings` option,
    which will open the Settings screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Settings activity, which will display one setting indicating the number
    of URLs to load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've analyzed the different ways of persisting data in Android
    and how to centralize them through the repository pattern. We've started with
    a look at the pattern itself to see how we can organize the data sources by combining
    Room and Retrofit.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we moved on to analyze alternatives to Room when it comes to persisting
    data. We looked first at `SharedPreferences` and how they constitute a handy solution
    for data persistence when it's in a key-value format and the amount of data is
    small. We then looked at how you can use `SharedPreferences` to save data directly
    on the device, and then we examined `PreferenceFragments` and how they can be
    used to take in user input and store it locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we looked over something that was in continuous change when it comes
    to the Android framework. That is the evolution of the abstractions regarding
    the filesystem. We started with an overview of the types of storage Android has
    and then took a more in-depth look at two of the abstractions: `FileProvider`,
    which your app can use to store files on the device and share them with others
    if there is a need to do so, and the SAF, which can be used to save files on the
    device in a location selected by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: We also used the benefits of `FileProvider` to generate URIs for files in order
    to use the camera applications to take photos and record videos and save them
    in the application's files, while also adding them to `MediaStore`.
  prefs: []
  type: TYPE_NORMAL
- en: The activity performed in this chapter combines all the elements discussed above
    to illustrate the point that even though you have to balance multiple sources
    inside an application, you can do it in a more readable way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for the activity and the exercises in this chapter and the previous
    one, we kept having to use the application class to instantiate the data sources.
    In the next chapter, you will learn how to overcome this through dependency injection
    and see how it can benefit an Android application.
  prefs: []
  type: TYPE_NORMAL
