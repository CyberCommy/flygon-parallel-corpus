- en: Beginning Your Microservice Journey
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始您的微服务之旅
- en: Microservices are one of the most tangible solutions in an enterprise to make
    quick, effective, and scalable applications. However, if they are not properly
    designed or understood, incorrect implementations and interpretations can lead
    to disastrous or irrecoverable failures. This chapter will begin our microservices
    journey by getting our hands dirty and diving deep into practical implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是企业中最具体的解决方案之一，可以快速、有效和可扩展地构建应用程序。然而，如果它们没有得到正确的设计或理解，错误的实施和解释可能导致灾难性或无法挽回的失败。本章将通过深入实际实施来开始我们的微服务之旅。
- en: The chapter will start with a description of shopping microservices, which we
    are going to develop throughout our journey. We will learn how to slice and dice
    a system into a connected set of microservices. We will design the overall architecture
    of our shopping cart microservices, define separation layers, add cache levels,
    and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将以对购物微服务的描述开始，这是我们将在整个旅程中开发的微服务。我们将学习如何将系统切分为一组相互连接的微服务。我们将设计购物车微服务的整体架构，定义分层，添加缓存级别等。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of shopping cart microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车微服务概述
- en: Architecture design of shopping cart microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车微服务的架构设计
- en: Implementation plan for shopping cart microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车微服务的实施计划
- en: Schema design and database selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式设计和数据库选择
- en: Microservice predevelopment aspects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务前期开发方面
- en: Developing some microservices for the shopping cart
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为购物车开发一些微服务
- en: Microservice design best practices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计最佳实践
- en: Overview of shopping cart microservices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车微服务概述
- en: The most important aspect while working on a new system is its design. A poor
    initial design is always a leading cause of more challenges ahead. Rather than
    moaning later, solving errors, or applying patches to cover up a poor design,
    it is always wise not to rush through the design process, spend enough time, and
    have a flexible fool-proof design. This can only be achieved by understanding
    the requirements clearly. In this section, we will give a brief overview of shopping
    cart microservices; the problem we need to solve via microservices; and an overview
    of the business process, functional view, and deployment and design views.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理新系统时最重要的方面就是它的设计。一个糟糕的初始设计总是导致更多挑战的主要原因。与其之后抱怨、解决错误或应用补丁来掩盖糟糕的设计，总是明智的不要急于通过设计过程，花足够的时间，并拥有一个灵活的防错设计。这只能通过清楚地理解需求来实现。在本节中，我们将简要概述购物车微服务；我们需要通过微服务解决的问题；以及业务流程、功能视图、部署和设计视图的概述。
- en: Business process overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务流程概述
- en: 'The use case for our scenario is pretty straightforward. The following process
    diagram shows the end-to-end shopping process that we need to convert to microservices.
    The user adds an item to the cart, the inventory is updated, the user pays for
    the item, and then is able to check out. There are several validations involved,
    based on business rules. For example, if the user''s payment fails, then they
    should not be able to check out; if the inventory is not available, then the item
    should not be added to the cart and so on. Take a look at the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的场景用例非常简单明了。以下流程图显示了我们需要转换为微服务的端到端购物流程。用户将商品添加到购物车，更新库存，用户支付商品，然后可以结账。基于业务规则，涉及了几个验证。例如，如果用户的支付失败，那么他们就不应该能够结账；如果库存不可用，那么商品就不应该被添加到购物车等等。看一下以下流程图：
- en: '![](img/72153c1f-f798-4aa4-b08b-7663f60d4e55.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72153c1f-f798-4aa4-b08b-7663f60d4e55.png)'
- en: Business process overview
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 业务流程概述
- en: Functional view
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能视图
- en: 'Each business capability and its sub-capabilities are shown in a row, which
    essentially constitutes the shopping cart microservices. Some sub-capabilities
    are involved in more than one business capability and hence we need to manage
    some cross-cutting concerns. For example, an inventory service is used both as
    a separate process and when a person checks out a product. The following diagram
    shows the functional view of the shopping cart microservices:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个业务能力及其子能力都显示在一行中，这基本上构成了购物车微服务。一些子能力涉及到多个业务能力，因此我们需要管理一些横切关注点。例如，库存服务既用作独立流程，也用于用户结账产品。以下图显示了购物车微服务的功能视图：
- en: '![](img/193b2e4a-8d72-423a-8488-704770f5a066.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/193b2e4a-8d72-423a-8488-704770f5a066.png)'
- en: Functional view
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 功能视图
- en: The diagram combines the business capabilities into one picture. For example,
    the inventory service states there are two sub-functions—add product details and
    add product quantity and inventory items. That summarizes the inventory service's
    objectives. Creating a functional view for our system gives us a clear understanding
    of all the business processes and related things involved in them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该图将业务能力结合成一张图片。例如，库存服务说明有两个子功能——添加产品详情和添加产品数量和库存项目。这总结了库存服务的目标。为我们的系统创建一个功能视图可以让我们清楚地了解所有涉及其中的业务流程和相关事项。
- en: Deployment view
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署视图
- en: 'The requirement for deployment is pretty straightforward. Based on demand,
    we need to add new services to support various business capabilities on the fly.
    Say, for example, right now the payment medium is **PayPal**, but it may happen
    in the future that we also need to support some local payment options, such as
    bank wallets. At that time, we should easily be able to add new microservices
    without disrupting the entire ecosystem. The following diagram shows the deployment
    view. Right now, there are two nodes (one master and one slave), but based on
    demand, the number of nodes may increase or decrease based on the business capabilities,
    a spike in traffic, and other requirements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的要求非常简单。根据需求，我们需要随时添加新的服务来支持各种业务能力。比如，现在支付方式是**PayPal**，但将来可能需要支持一些本地支付选项，比如银行钱包。那时，我们应该能够轻松地添加新的微服务，而不会破坏整个生态系统。以下图表显示了部署视图。现在有两个节点（一个主节点和一个从节点），但根据需求，节点的数量可能会根据业务能力、流量激增和其他要求而增加或减少：
- en: '![](img/35bb0ad2-fda8-42fe-b101-a7b43af015f7.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35bb0ad2-fda8-42fe-b101-a7b43af015f7.png)'
- en: Deployment view
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 部署视图
- en: In this section, we got a brief overview of our shopping cart microservice system.
    We understood its functional, business process, and deployment views. In the next
    section, we will see the architecture design of the shopping cart microservices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们简要概述了我们的购物车微服务系统。我们了解了它的功能、业务流程和部署视图。在下一节中，我们将看到购物车微服务的架构设计。
- en: Architecture design of our system
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们系统的架构设计
- en: In this section, we will look at the architectural aspects involved in distributed
    microservices. We will look at our overall architecture diagram, which we are
    going to make throughout the book, and look at aspects such as separating concerns,
    how to apply reactive patterns, and the microservice efficiency model. So, let's
    get started.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下分布式微服务涉及的架构方面。我们将看一下我们将在整本书中制作的整体架构图，并关注诸如分离关注点、如何应用反应式模式以及微服务效率模型等方面。所以，让我们开始吧。
- en: 'Now that we know our business requirements, let''s design our architecture.
    Based on our knowledge of microservices and other concepts from [Chapter 1](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml), *Debunking
    Microservices*, we have the final overall diagram, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的业务需求，让我们设计我们的架构。根据我们对微服务和其他概念的了解，我们有最终的整体图表，如下所示：
- en: '![](img/71920699-b87a-49d8-a2ca-fd95f8fa8931.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71920699-b87a-49d8-a2ca-fd95f8fa8931.png)'
- en: Microservice architecture
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构
- en: We will study components such as API Gateway, service registry, and discovery
    in much more detail in later chapters. Here, they are just mentioned as part of
    the overall view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地研究API网关、服务注册表和发现等组件。在这里，它们只是作为整体视图的一部分提到。
- en: Let's understand the key components in the preceding diagram to get a better
    idea of our architecture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解前面图表中的关键组件，以更好地了解我们的架构。
- en: Different microservices
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的微服务
- en: 'If we understood our business requirements correctly, we will come up with
    the following business capabilities:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正确理解了我们的业务需求，我们将得出以下业务能力：
- en: Product catalog
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品目录
- en: Price catalog
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格目录
- en: Discounts
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折扣
- en: Invoice
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发票
- en: Payment
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付
- en: Inventory
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存
- en: Based on our business capabilities and single responsibility, we divided our
    microservices briefly into various smaller applications. In our design, we ensured
    that each business capability is implemented by a single microservice and we don't
    overload a microservice with more than one microservice. We briefly divided our
    entire system into various microservices, such as a shopping cart microservice,
    products microservice, payment microservice, consumer microservice, cache microservice,
    price calculations and suggestions microservice, and so on. The overall granular
    flow can be seen in the preceding diagram. Another important thing to notice is
    that each microservice has its separate data store. Different business capabilities
    have different needs. For example, when a person checks out a product, if the
    transaction failed, then all transactions such as adding a product to a customer's
    purchase item, deducting quantity from a product inventory, and so on should be
    rolled back. In this case, we need relational databases that can handle transactions,
    whereas in the case of products, our metadata constantly changes. Some products
    may have more features than other products. In such cases, having a fixed relational
    schema is not wise and we can go for NoSQL data stores.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的业务能力和单一责任，我们将我们的微服务简要地划分为各种较小的应用程序。在我们的设计中，我们确保每个业务能力由一个单独的微服务实现，我们不会将一个微服务过载超过一个微服务。我们将整个系统简要地划分为各种微服务，如购物车微服务、产品微服务、支付微服务、消费者微服务、缓存微服务、价格计算和建议微服务等。整体的细粒度流程可以在前面的图表中看到。另一个重要的事情是，每个微服务都有自己的数据存储。不同的业务能力有不同的需求。例如，当一个人结账时，如果交易失败，那么所有的交易，比如将产品添加到客户的购买项目中，从产品库存中扣除数量等，都应该被回滚。在这种情况下，我们需要能够处理事务的关系型数据库，而在产品的情况下，我们的元数据不断变化。一些产品可能比其他产品具有更多的功能。在这种情况下，拥有固定的关系模式是不明智的，我们可以选择NoSQL数据存储。
- en: At the time of writing this book, MongoDB 4.0 had not yet been introduced. It
    provides the following transactional plus NoSQL benefits in one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，MongoDB 4.0尚未推出。它提供了以下事务加NoSQL的优势。
- en: Cache microservice
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存微服务
- en: The next component that we are going to see is centralized cache storage. This
    microservice directly interacts with all microservices and we may use this service
    to cache our responses when needed. Often it may happen that a service goes down,
    and we may still preserve the application by showing cached data (things such
    as product information and metadata rarely change; we may cache them for a certain
    interval of time, thus preventing an extra database hop). Having a cache increases
    the performance and availability of the system, which ultimately leads to cost
    optimization. It provides a blazing fast user experience. As microservices are
    constantly moving, often they may not be reached. In such cases, it is always
    advantageous to have a cached response when reaching out to availability zones
    fails.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要看的是集中式缓存存储。这个微服务直接与所有微服务进行交互，我们可以使用这个服务在需要时缓存我们的响应。通常情况下，可能会出现一个服务停止运行，但我们仍然可以通过显示缓存数据来保留应用程序（例如产品信息和元数据很少改变；我们可以将它们缓存一段时间，从而避免额外的数据库访问）。拥有缓存可以提高系统的性能和可用性，最终导致成本优化。它提供了极快的用户体验。由于微服务不断移动，通常它们可能无法被访问。在这种情况下，当访问可用性区域失败时，拥有缓存响应总是有利的。
- en: Service registry and discovery
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表和发现
- en: At the start of the diagram, we included the service registry. This is a dynamic
    database maintained on the startup and shutdown events of all microservices. Services
    subscribe to the registry and listen for updates to know whether the service has
    gone down or not. The entire process is done through the service registry and
    discovery. The registrator updates the registry whenever a service goes down or
    goes up. This registry is cached on all clients who subscribe to the registry,
    so whenever a service needs to be interacted with, an address is fetched from
    this registry. We will look in detail at this process in [Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml),
    *Service Registry and Discovery*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表的开始，我们包括了服务注册表。这是一个动态数据库，记录了所有微服务的启动和关闭事件。服务订阅注册表并监听更新，以了解服务是否已经停止。整个过程通过服务注册表和发现完成。当服务停止或启动时，注册器会更新注册表。这个注册表被所有订阅注册表的客户端缓存，所以每当一个服务需要交互时，地址都是从这个注册表中获取的。我们将在《第6章》*服务注册表和发现*中详细讨论这个过程。
- en: Registrator
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Registrator
- en: The next component that we are going to look at, which is available alongside
    the cache, is the **Registrator** ([http://gliderlabs.github.io/registrator/latest/](http://gliderlabs.github.io/registrator/latest/)).
    The Registrator is a third-party service registration tool that basically watches
    for startup and shutdown events of microservices and, based on the output of those
    events, dynamically updates the centralized service registry. Different services
    can then directly communicate with the registry to get updated locations of services.
    The Registrator ensures that registration and deregistration code is not duplicated
    across systems. We will look at this in more detail in [Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml),
    *Service Registry and Discovery*, where we integrate the Registrator with the
    consul.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要看的是与缓存一起提供的**Registrator** ([http://gliderlabs.github.io/registrator/latest/](http://gliderlabs.github.io/registrator/latest/))。Registrator是一个第三方服务注册工具，基本上监视微服务的启动和关闭事件，并根据这些事件的输出动态更新集中式服务注册表。不同的服务可以直接与注册表通信，以获取服务的更新位置。Registrator确保注册和注销代码在系统中不会重复。我们将在《第6章》*服务注册表和发现*中更详细地讨论这个问题，其中我们将Registrator与consul集成。
- en: Logger
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录器
- en: One of the important aspects of any application is the logs. Analyzing any problem
    becomes very easy when appropriate logs are used. Hence, here we have a centralized
    logger microservice that is based on the famous Elastic framework. Logstash watches
    for log files and transforms them into appropriate JSON before pushing to Elasticsearch.
    We can visualize the logs through the Kibana dashboard. Each microservice will
    have its unique UUID or some log pattern configured. We will look at this in much
    more detail in [Chapter 9](90996850-1ced-4678-a297-3e1fee118eb9.xhtml), *Deployment,
    Logging, and Monitoring*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的一个重要方面是日志。当使用适当的日志时，分析任何问题变得非常容易。因此，这里我们有一个基于著名的Elastic框架的集中式日志记录器微服务。Logstash监视日志文件，并在推送到Elasticsearch之前将其转换为适当的JSON格式。我们可以通过Kibana仪表板可视化日志。每个微服务都将有其独特的UUID或一些日志模式配置。我们将在《第9章》*部署、日志记录和监控*中更详细地讨论这个问题。
- en: Gateway
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关
- en: This is the most important part and the starting point of our microservices.
    It is the central point where we will handle cross-cutting concerns, such as authentication,
    authorization, transformation, and so on. While creating different microservices
    on various servers, we usually abstract the information of hosts and ports from
    the client. The client just makes a request to the gateway and the gateway takes
    care of the rest by interacting with the service registry and load balancer and
    redirecting the request to the appropriate service. This is the most important
    part in a microservice and it should be made highly available.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们微服务的最重要部分和起点。这是我们将处理诸如身份验证、授权、转换等横切关注点的中心点。在不同服务器上创建不同的微服务时，我们通常会将主机和端口的信息从客户端中抽象出来。客户端只需向网关发出请求，网关通过与服务注册表和负载均衡器的交互，并将请求重定向到适当的服务，来处理其余的事情。这是微服务中最重要的部分，应该使其高度可用。
- en: After going through the architecture diagram, now let's understand some aspects
    related to the architecture that we will use later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过架构图之后，现在让我们了解一些与架构相关的方面，这些方面我们以后会用到。
- en: Design aspects involved
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涉及的设计方面
- en: 'Before actually coding, we need to understand the *how* and *why*. Let''s say
    if I have to cut down a tree (PS: I am a nature lover and I don''t support this),
    instead of directly chopping it down, I would rather first sharpen the axe. We
    are going to do the same, sharpen our axe first. In this section, we are going
    to look at various aspects involved in designing microservices. We will look at
    what models of communication to go through, what is included in microservices,
    and what areas to take care of in order to achieve efficient microservice development.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Microservice efficiency model
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the various needs and requirements, we have defined a microservice
    efficiency model. Any proper implementation of microservices must adhere to it
    and provide a standard set of functionalities, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Communication over HTTP and HTTP listeners
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message or socket listeners
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage capabilities
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper business/technical capabilities definitions
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service endpoint definitions and communication protocols
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service contacts
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security services
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service documentation through tools such as Swagger
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following diagram, we have summarized our microservice efficiency model:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45ff4392-2534-40b5-9a86-b3c583c80c30.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Microservice efficiency model
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at each of the four sections of the preceding diagram.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Core functionalities
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Core functionalities are part of the microservice itself. They include the
    following functionalities:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**Technical capabilities**: Any technical functionalities needed, such as interacting
    with the service registry, sending out events to an event queue, processing events,
    and so on, are involved here.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business capabilities**: Microservices written to achieve a business capability
    or fulfill a business requirement.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP listeners**: A part of the technical capability; here we define APIs
    for external consumers. While starting the server, an HTTP listener is started,
    eliminating any other needs.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message listeners**: A part of event-based communication where the sender
    doesn''t worry whether the message listeners are implemented.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Gateway**: One point of communication for the end client. The API Gateway
    is the single place for handling any core concerns.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document storage or data storage**: Our data layer for the application. Based
    on our needs, we may use any of the available data stores.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting efficiencies
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are solutions to help in achieving core microservice implementation.
    They include the following components:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**Load balancer**: Anapplication load balancer to redirect based on changes
    in the server topology. It handles dynamic services going up or down.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service registry**: A runtime environment for services if they go up or down
    to publish to. It maintains the active log of all services along with the available
    instances.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**Central logs**: A core centralized logging solution to observe logs all places,
    rather than individually opening containers and seeking logs there.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: Checking authentic client requests through common available mechanisms,
    such as OAuth, token-based, IP-based, and so on.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing**: Testing out the microservices and essentials, such as inter-microservice
    communication, scalability, and so on.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure role
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the infrastructure expectations needed for efficient microservice
    implementation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '**Server layer**: An efficient mechanism to choose for deploying our microservice.
    Well-known options include Amazon EC2 instance, Red Hat OpenShift, or serverless.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container**: Dockerizing the application, so it can run easily on any OS
    without much fuss about installation.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD**: A process to maintain easy deployment cycles.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clustering**: Server load balancers to handle the load or spike in applications
    as required.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Governance
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Processes and reference information to ease up our overall life cycle in application
    development include the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**Contract testing**: Testing out microservice expectations and actual outputs
    to make sure frequent changes don''t break anything'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同测试**：测试微服务的期望和实际输出，以确保频繁的更改不会破坏任何东西'
- en: '**Scalablity**: Spawning new instances and removing those instances on demand
    to handle spikes in load'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：根据需求产生新实例并在需求减少时移除这些实例以处理负载峰值'
- en: '**Documentation**: Generating documentation to easily understand what someone
    is actually doing'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：生成文档以便轻松理解别人实际在做什么'
- en: In the next section, we will carve out an implementation plan for our microservice
    development.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将为我们的微服务开发制定一个实施计划。
- en: Implementation plan for shopping cart microservices
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车微服务的实施计划
- en: 'One of the key challenges in microservice development is fixing the scope of
    a microservice:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发中的一个关键挑战是确定微服务的范围：
- en: If a microservice is too big, you end up in monolithic hell and get stuck in
    a huge turnaround time, with difficulty adding new features and implementing bug
    fixes
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个微服务太大，你最终会陷入单体地狱，难以添加新功能和实施错误修复
- en: If a microservice is too small, either we end up with tight coupling among services
    or too much code duplication and resource consumption
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个微服务太小，要么我们会在服务之间出现紧密耦合，要么会出现过多的代码重复和资源消耗
- en: If a microservice size is right, but the bounded context isn't fixed, such as
    services sharing a database, it leads to higher coupling and dependencies
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果微服务的大小合适，但有界上下文并不固定，比如服务共享数据库，会导致更高的耦合和依赖
- en: In this section, we are going to devise an implementation plan for our shopping
    cart microservices. We will formulate a general workflow or plan and design our
    system according to the plan. We will also see what to do when our scope is not
    clear, and how to proceed in such cases to ultimately reach our microservices
    goal. We will look at how to potentially avoid the aforementioned loop holes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将为我们的购物车微服务制定一个实施计划。我们将制定一个通用的工作流程或计划，并根据计划设计我们的系统。我们还将看看当我们的范围不清晰时该怎么办，以及如何在这种情况下继续，最终达到我们的微服务目标。我们将看看如何潜在地避免上述的漏洞。
- en: What to do when the scope is not clear
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当范围不清晰时该怎么办
- en: 'Until now, we have designed our architectural plan based on scoping microservices,
    but that was when our requirements were pretty clear. We knew exactly what we
    had to make. But in most cases, you won''t have a similar scenario. You will either
    be migrating from a monolithic system to microservices or you will be engulfed
    in constantly changing requirements or business capabilities that are still evolving,
    or it may be that the complexities of technical capabilities could not be estimated
    at the primer stage, making it difficult for you to scope the microservices. The
    following section is for such scenarios where you can perform the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设计了基于微服务范围的架构计划，但那是在我们的需求非常明确的情况下。我们清楚地知道我们需要做什么。但在大多数情况下，你可能不会有类似的情景。你要么是从单体系统迁移到微服务，要么是被不断变化的需求或业务能力所困扰，或者可能是技术能力的复杂性在初期无法估计，使得确定微服务的范围变得困难。接下来的部分是针对这种情况的，你可以执行以下步骤：
- en: '**Dream big and start big**: Deciding the scope of microservices is always
    a huge task, as it defines the overall bounded context. If that is not decided
    clearly, we ultimately get stuck in monolithic hell. However, if the scope is
    narrowed down too much, it has its disadvantages too. You will suffer difficulties,
    as you will end up with data duplication between two microservices, unclear responsibility,
    and difficulty deploying services independently. Carving out microservices from
    existing microservices is much easier than managing too narrowly carved microservices.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**梦想大，从大开始**：决定微服务的范围总是一个巨大的任务，因为它定义了整体的有界上下文。如果这不明确，我们最终会陷入单体地狱。然而，如果范围过于狭窄，也有其缺点。你将遇到困难，因为你最终会在两个微服务之间出现数据重复，责任不清晰，以及难以独立部署服务。从现有微服务中划分出微服务要比管理范围过窄的微服务容易得多。'
- en: '**Separate out microservices from existing microservices**: Once you feel that
    a microservice is too big, you will need to start separating out the service.
    First of all, the scope needs to be decided for both the existing and new microservice
    based on business and technical capabilities. Anything pertaining to a new microservice
    goes into its own module. Then any communication between the existing modules
    is moved to common interfaces, such as HTTP API/event-based communication, and
    so on. Microservices can be planned for later development too; when in doubt,
    always create a separate module, so we can easily move it out.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从现有微服务中分离出微服务**：一旦你觉得一个微服务太大，你需要开始分离服务。首先，需要根据业务和技术能力为现有和新的微服务确定范围。任何与新微服务有关的内容都放入自己的模块。然后，现有模块之间的任何通信都移动到公共接口，比如HTTP
    API/基于事件的通信等等。微服务也可以计划以后开发；如果有疑问，总是创建一个单独的模块，这样我们可以轻松地将其移出去。'
- en: '**Identify technical capabilities**: A technical capability is anything that
    supports other microservices, such as listening to events emitted by event queues,
    registering to the service registry, and so on. Keeping the technical capability
    inside the same microservice can be a huge risk as it will soon lead to tight
    coupling and the same technical capability might be implemented by lots of other
    services too.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定技术能力**：技术能力是支持其他微服务的任何东西，比如监听事件队列发出的事件，注册到服务注册表等等。将技术能力保留在同一个微服务中可能是一个巨大的风险，因为它很快会导致紧密耦合，同样的技术能力可能也会被许多其他服务实现。'
- en: '**Adherence standards for microservices based on business and technical capabilities**: Microservices
    adhere to fixed standards—self-sufficiency, resiliency, transparency, automation,
    and distribution. Each of the points can briefly be stated as:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于业务和技术能力的微服务遵循标准**：微服务遵循固定的标准——自给自足、弹性、透明、自动化和分布。每个点都可以简要陈述为：'
- en: A microservice serves a single business capability (modularity is the key thing).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务提供单一的业务能力（模块化是关键）。
- en: A microservice can be easily deployed individually. Each service would have
    its own build script and CI/CD pipeline. The common point would be the API Gateway
    and service registry.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以很容易地单独部署。每个服务都将有自己的构建脚本和CI/CD流水线。共同点将是API网关和服务注册表。
- en: You can easily find out the owners of microservices. They would be distributed
    and each team can own one microservice.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以很容易地找出微服务的所有者。它们将是分布式的，每个团队可以拥有一个微服务。
- en: A microservice can be replaced without much hassle. We will have common registration
    options via the service registry and discovery. Each of our services can be accessed
    via HTTP.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以很容易地被替换。我们将通过服务注册表和发现有共同的注册选项。我们的每个服务都可以通过HTTP访问。
- en: By following these steps, you will ultimately reach the microservice level,
    where each service will be serving a single business capability.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，最终将达到微服务级别，其中每个服务将提供单一的业务能力。
- en: Schema design and database selection
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式设计和数据库选择
- en: 'The main part of any application is its database selection. In this section,
    we will look at how to design our database for microservices, whether to keep
    it separate, to keep it shared, and which database to go to—SQL or NoSQL? We will
    look at how to categorize data stores based on data types and business capabilities.
    There are lots of options available. Microservices support polyglot persistence.
    The approach of selecting a particular data store based on business capabilities
    and needs is termed polyglot persistence. The following points discuss which database
    to refer to based on use cases:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的主要部分是其数据库选择。在本节中，我们将看看如何为微服务设计我们的数据库，是将其保持独立，还是共享，以及选择哪种数据库——SQL还是NoSQL？我们将根据数据类型和业务能力来分类数据存储。有很多选择。微服务支持多语言持久性。根据业务能力和需求选择特定数据存储的方法称为多语言持久性。以下几点讨论了基于用例选择哪种数据库：
- en: We can leverage Apache Cassandra to support tabular data, such as inventory
    data. It has options such as distributed consistency and lightweight transactions
    to support ACID transactions.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用Apache Cassandra来支持表格数据，例如库存数据。它具有分布式一致性和轻量级事务的选项，以支持ACID事务。
- en: We can leverage Redis to support cache data where the data model is simply a
    key-value pair. Read operations in Redis are super fast.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用Redis来支持缓存数据，其中数据模型只是一个键值对。Redis中的读操作非常快。
- en: We can leverage MongoDB to support product data stored in unstructured form
    with the ability to index on any particular field. A document-oriented database
    such as MongoDB has powerful options, such as an index in specific attributes
    to search faster.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用MongoDB来支持以非结构化形式存储的产品数据，并具有在任何特定字段上建立索引的能力。像MongoDB这样的面向文档的数据库具有强大的选项，比如在特定属性上建立索引以实现更快的搜索。
- en: We can leverage GraphQL to support complex relationships. GraphQL is extremely
    useful for many-to-many relationships, for example, our shopping cart recommendation
    system. Facebook uses GraphQL.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用GraphQL来支持复杂的关系。GraphQL对于多对多关系非常有用，例如我们的购物车推荐系统。Facebook使用GraphQL。
- en: We can use relational databases to support legacy systems or systems that require
    maintaining structured relational data. We use relational data where data doesn't
    change frequently.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用关系数据库来支持传统系统或需要维护结构化关系数据的系统。我们在数据不经常更改的地方使用关系数据。
- en: In this section, we will look into these points in detail and understand things
    such as how should the data layer be in a microservice. Then, we will look into
    types of databases and understand their advantages, disadvantages, and use cases.
    So, let's get started.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细了解这些要点，并了解微服务中数据层应该如何。然后，我们将了解数据库类型及其优缺点和用例。所以，让我们开始吧。
- en: How to segregate data between microservices
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在微服务之间划分数据
- en: The hardest thing about microservices is our data. Each microservice should
    maintain data by owning their individual database. Data must not be shared via
    a database. This rule helps us to eliminate a common case that leads to tight
    coupling between different microservices. If two microservices share the same
    database layer, and if the second service doesn't know about the first service
    changing the database schema, it will fail. Due to this, service owners need to
    be constantly in touch and this differs from our microservice path.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务最困难的是我们的数据。每个微服务都应该通过拥有自己的数据库来维护数据。数据不应通过数据库共享。这条规则有助于消除导致不同微服务之间紧密耦合的常见情况。如果两个微服务共享相同的数据库层，并且第二个服务不知道第一个服务更改了数据库模式，它将失败。由于这个原因，服务所有者需要保持不断联系，这与我们的微服务路径不同。
- en: 'Some of the questions that may come to our mind are how will the database stay
    in the microservice world? Will the services be sharing databases? If yes, then
    what would be the repercussions of shared data? Let''s answer these questions.
    We all know the phrase, *with ownership comes responsibility*. Similarly, if a
    service owns a data store, then it is solely responsible for keeping it up to
    date. Also, for optimal performance, the data that a microservice needs should
    be nearby or local, preferably within the microservice container itself, as microservices
    need to often interact with it. So far, we have learned about two principles for
    how to segregate data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会想到一些问题，比如数据库在微服务世界中如何保持？服务是否会共享数据库？如果是的话，共享数据会有什么后果？让我们回答这些问题。我们都知道这句话，“拥有就意味着责任”。同样，如果一个服务拥有数据存储，那么它就是唯一负责保持其最新的。此外，为了实现最佳性能，微服务需要的数据应该是附近或本地的，最好是在微服务容器内部，因为微服务需要经常与其进行交互。到目前为止，我们已经了解了如何划分数据的两个原则：
- en: Data should be divided so that each microservice (fulfilling a certain business
    capability) should easily ensure that the database is up to date and not allow
    any other services direct access.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据应该被划分，以便每个微服务（满足某种业务能力）可以轻松确保数据库是最新的，并且不允许任何其他服务直接访问。
- en: Data relevant to that microservice should be in a nearby vicinity. Keeping it
    far away increases database costs plus network costs.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与该微服务相关的数据应该在附近。将其放得太远会增加数据库成本和网络成本。
- en: One of the general processes for segregating data is to build up a domain model
    comprising entities, objects, and aggregates. Let's say we have the following
    use cases—allowing a customer to search for a product, allowing a customer to
    buy a particular type of product, and allowing a customer to buy the product. 
    We have three functionalities—search, buy, and inventory. Each functionality has
    its own needs and so the product database is stored in the product catalog service,
    the inventory is stored differently, and the search service queries the product
    catalog service, and these results are cached.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据进行分离的一般过程之一是建立一个包含实体、对象和聚合的领域模型。假设我们有以下用例——允许客户搜索产品，允许客户购买特定类型的产品，以及允许客户购买产品。我们有三个功能——搜索、购买和库存。每个功能都有自己的需求，因此产品数据库存储在产品目录服务中，库存以不同的方式存储，搜索服务查询产品目录服务，这些结果被缓存。
- en: In this section, we will look at these rules in detail with an example, which
    will help us to decide where to keep a data layer and how it should be divided
    to give us maximum advantage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个例子详细讨论这些规则，这将帮助我们决定在哪里保留数据层以及如何划分数据层以获得最大优势。
- en: Postulate 1 – data ownership should be regulated via business capabilities
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设1 - 数据所有权应通过业务能力进行规范
- en: One of the major ideas for deciding where data belongs in a microservice system
    is deciding on the basis of business capabilities. A microservice is just a service
    fulfilling a business capability that cannot be possible without having a data
    store. A business capability defines the contained region of the microservice.
    Everything that belongs to handling that capability should reside inside the microservice.
    For example, only one microservice should have a customer's personal details,
    comprising a delivery address, and email address. Another microservice can have
    a customer's purchase history and a third microservice can have customer preferences.
    The microservice responsible for the business capability is responsible for storing
    the data and keeping it up to date.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定数据在微服务系统中属于哪里的一个主要想法是基于业务能力进行决定。微服务只是满足业务能力的服务，而没有数据存储是不可能的。业务能力定义了微服务的包含区域。属于处理该能力的一切东西都应该驻留在微服务内部。例如，只有一个微服务应该拥有客户的个人详细信息，包括送货地址和电子邮件地址。另一个微服务可以拥有客户的购买历史，第三个微服务可以拥有客户的偏好。负责业务能力的微服务负责存储数据并保持其最新状态。
- en: Postulate 2 – replicate the database for speed and robustness
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设2 - 为了速度和鲁棒性而复制数据库
- en: The second factor at play when selecting where a piece of data should be stored
    in a microservice system is decided based on the scope or locality. There's a
    big change if the data store is in the vicinity of a microservice or far off,
    even though we are talking about the same data. A microservice can query its own
    database for data or a microservice can query another microservice for that same
    data. The latter, of course, will come with cons and tight dependencies. Looking
    in the local neighborhood is much faster than looking at different cities. Once
    you have decided on the scope of the data, you will realize that microservices
    need to talk to one another very often.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择在微服务系统中存储数据的位置时，第二个因素是基于范围或局部性来决定。即使我们谈论的是相同的数据，如果数据存储在微服务附近或远离微服务，都会有很大的变化。微服务可以查询自己的数据库获取数据，或者微服务可以查询另一个微服务获取相同的数据。后者当然会带来缺点和紧密的依赖关系。在本地邻域查找比在不同城市查找要快得多。一旦你决定了数据的范围，你会意识到微服务需要经常彼此交流。
- en: 'This kind of microservice often creates a very tight dependency, meaning we
    are stuck to the same old monolithic stuff. To loosen this, coupling a caching
    database or maintaining a cache store often comes in handy. You can cache responses
    as they are, or you can add a read model to expire cache after a certain time
    interval. The microservice that owns the local data should be in the best position
    to decide when a particular piece of code becomes invalid based on the business
    capability. HTTP cache headers should be used to control caching. Managing a cache
    is simply controlling the cache-control header. For example, the line `cache-control:
    private, max-age:3600` caches the response for 3,600 seconds.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '这种微服务通常会创建非常紧密的依赖关系，这意味着我们被困在同样的旧式单片系统中。为了解除这种依赖，耦合缓存数据库或者维护缓存存储通常会很有用。你可以将响应缓存下来，或者你可以添加一个读取模型来在一定时间间隔后使缓存失效。拥有本地数据的微服务应该处于最佳位置，根据业务能力来决定何时特定的代码变得无效。应该使用HTTP缓存头来控制缓存。管理缓存就是简单地控制缓存控制头。例如，`cache-control:
    private, max-age:3600`这一行将响应缓存3,600秒。'
- en: 'In the next section, we will look into how to select the best database based
    on the following criteria:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将根据以下标准来选择最佳数据库：
- en: How is my data? Is it a bunch of tables, a document, a key-value pair, or a
    graph?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的数据是什么？是一堆表、一个文档、一个键值对还是一个图？
- en: How much is my data write and read frequency? Do my write requests come randomly
    or are they evenly distributed in time? Is there a read-all-at-once scenario?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的数据写入和读取频率有多高？我的写入请求是随机的还是在时间上均匀分布的？是否存在一次性读取所有数据的情况？
- en: Are there more write operations or are there more read operations?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写操作多还是读操作多？
- en: How to choose a data store for your microservice
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何为你的微服务选择数据存储
- en: One of the most fundamental questions that pop up while designing microservices
    is *how does one choose the correct data store?* We will be talking about this
    in much more detail in the *Service* *state* section in [Chapter 7](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml),
    *Service State and Interservice Communication*, but here, let's get our fundamentals
    right.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务时最基本的问题之一是*如何选择正确的数据存储？*我们将在[第7章](162a0f25-2890-4a58-aa41-e9c9b5fc6c2d.xhtml)的*服务状态和服务间通信*部分中更详细地讨论这个问题，但在这里，让我们先搞清楚基本原理。
- en: 'The first and foremost step in selecting any ideal data store is to find out
    the nature of our microservice data. Based on the nature of the data, we can briefly
    define the following categories:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 选择任何理想数据存储的首要步骤是找出我们微服务数据的性质。根据数据的性质，我们可以简要定义以下类别：
- en: '**Ephemeral or short-lived data**: A cache server is a classic example of short-lived
    data. It is a temporary store whose objective is to enhance the user experience
    by serving information in real time, thus avoiding frequent database calls. This
    is especially important where most of the operations are read intensive. Also,
    this store has no extra durability or security concerns as it does not have a
    master copy of the data. However, that being said, this should not be treated
    lightly as it has to be highly available. Failures can cause poor user experience
    and subsequently crash the main database as it won''t be able to handle such frequent
    calls. Examples of such data stores include Redis, Elasticsearch, and so on.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短暂或短暂的数据**：缓存服务器是短暂数据的经典示例。它是一个临时存储，其目标是通过实时提供信息来增强用户体验，从而避免频繁的数据库调用。这在大部分操作都是读取密集的情况下尤为重要。此外，此存储没有额外的耐久性或安全性问题，因为它没有数据的主要副本。然而，这不应被轻视，因为它必须具有高可用性。故障可能导致用户体验不佳，并随后使主数据库崩溃，因为它无法处理如此频繁的调用。此类数据存储的示例包括Redis、Elasticsearch等。'
- en: '**Transient or momentary data**: Data such as logs and messages usually come
    in bulk volume and frequency. Ingestion services process this information before
    passing it to the appropriate destinations. Such data stores need high frequency
    writes. Features such as time series data or JSON format are added advantages.
    The support requirements for transient data are higher as it is mostly used in
    event-based communications.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态或瞬时数据**：例如日志和消息等数据通常以大量和频率出现。摄取服务在将信息传递到适当的目的地之前处理这些信息。这种数据存储需要高频率的写入。时间序列数据或JSON格式等功能是额外的优势。瞬态数据的支持要求更高，因为它主要用于基于事件的通信。'
- en: '**Operational or functional data**: Operational data focuses on any information
    that is gathered from user sessions, such as user profiles, user shopping cart,
    wish lists, and so on. Being the primary data store, this kind of microservice
    provides better user experience with real-time feedback. For business continuity,
    this kinds of data must be retained. Here the durability, consistency, and availability
    requirements are very high. We can have any kind of data store as per our needs,
    providing any of the following structures—JSON, graph, key-value, relational,
    and so on.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运营或功能性数据**：运营数据侧重于从用户会话中收集的任何信息，例如用户配置文件、用户购物车、愿望清单等。作为主要数据存储，这种微服务提供了更好的用户体验和实时反馈。为了业务连续性，这种数据必须被保留。这种数据的耐久性、一致性和可用性要求非常高。根据我们的需求，我们可以根据需要提供以下任何一种结构的数据存储：JSON、图形、键值、关系等。'
- en: '**Transactional data**: Data gathered from a series of processes or transactions,
    such as payment processing, order management, must be stored in a database that
    supports ACID controls to avoid disasters (we will mostly use relational databases
    for transactional data). At the time of writing of this book, MongoDB 4.0, supporting
    transactional data, was still not available. Once generally available NoSQL data
    stores can be used even for transaction management.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务性数据**：从一系列流程或交易中收集的数据，例如支付处理、订单管理，必须存储在支持ACID控制以避免灾难的数据库中（我们将主要使用关系数据库来处理事务性数据）。在撰写本书时，仍然没有支持事务性数据的MongoDB
    4.0。一旦普遍可用，NoSQL数据存储甚至可以用于事务管理。'
- en: Design of product microservices
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品微服务的设计
- en: 'Based on our requirements, we can categorize data into the following various
    segments:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的需求，我们可以将数据分类为以下各种部分：
- en: '| **Microservice** | **Data store type** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **微服务** | **数据存储类型** |'
- en: '| Caching | Ephemeral (example: ELK) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 缓存 | 短暂（例如：ELK） |'
- en: '| User comments, ratings, feedback, and product top sellers | Transient |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 用户评论、评分、反馈和畅销产品 | 瞬态 |'
- en: '| Product catalog | Operational |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 产品目录 | 运营 |'
- en: '| Product search engine | Operational |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 产品搜索引擎 | 运营 |'
- en: '| Order processing | Transactional |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 订单处理 | 事务性 |'
- en: '| Order fulfillment | Transactional |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 订单履行 | 事务性 |'
- en: For our product catalog database, we will proceed with the following design.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的产品目录数据库，我们将按照以下设计进行。
- en: 'In the current chapter, we are going to go with the product catalog service,
    which requires us to use an operational data store. We will go with MongoDB. A
    product will have at least the following items—variant, price, hierarchy, vendor,
    feedback email, configurations, description, and so on. Instead of getting everything
    in a single document, we will use the following schema design:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前章节中，我们将使用产品目录服务，这要求我们使用运营数据存储。我们将使用MongoDB。产品至少包括以下项目：变体、价格、层次结构、供应商、反馈电子邮件、配置、描述等。我们将使用以下模式设计，而不是在单个文档中获取所有内容：
- en: '[PRE0]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some of the advantages of this schema design are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式设计的一些优点包括：
- en: It is easy to have a faceted search which returns results in quick milliseconds
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以进行快速毫秒级的分面搜索
- en: Each index will end with `_id`, making it useful for pagination
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个索引都将以“_id”结尾，使其对分页非常有用
- en: Efficient sorting can be done on various attributes
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对各种属性进行高效的排序
- en: Microservice predevelopment aspects
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务预开发方面
- en: In this section, we are going to look at some common development aspects that
    we will follow throughout the book. We will understand some common aspects, such
    as which HTTP message code to use, how to set up logging, which kinds of logging
    to keep, how to use PM2 options, and how to trace a request or attach a unique
    identifier to a microservice. So, let's get started.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解一些通常的开发方面，这些方面将贯穿整本书。我们将了解一些常见的方面，例如使用哪种HTTP消息代码，如何设置日志记录，保留哪些类型的日志记录，如何使用PM2选项，以及如何跟踪请求或附加唯一标识符到微服务。让我们开始吧。
- en: HTTP code
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP代码
- en: '**HTTP code** dominates standard API communication and are one of the general
    standards across any general-purpose API. It resolves common issues for any request
    that is made to the server, whether it is successful, whether it is producing
    a server error, and so on. HTTP resolves every single request with HTTP code with
    ranges that indicate the nature of the code. HTTP codes are standards ([http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html))
    based on various code and response actions are taken accordingly, so the concept
    of not reinventing the wheel essentially applies here. In this section, we will
    look at some of the standard code ranges along with their meanings.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP代码主导着标准API通信，并且是任何通用API的通用标准之一。它解决了向服务器发出的每个请求的常见问题，无论请求是否成功，是否产生服务器错误等等。HTTP使用代码范围来指示代码的性质。HTTP代码是基于各种代码和响应行为采取相应措施的标准（[http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)），因此在这里基本上适用于不重复造轮子的概念。在本节中，我们将看一些标准代码范围以及它们的含义。
- en: 1xx – informational
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1xx – 信息
- en: The **1xx** code provides primitive functionalities, such as operations happening
    in the background, switching protocols, or the state of the initial request. For
    example, `100 Continue` indicates that the server has received request headers
    and is now awaiting the request body, `101 Switching Protocols` indicates that
    the client has requested a protocol change from the server and the request has
    been approved, and `102` indicates that the operation is happening in the background
    and will take time to complete.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 1xx代码提供原始功能，例如后台操作、切换协议或初始请求的状态。例如，`100 Continue`表示服务器已收到请求头，并正在等待请求体，`101 Switching
    Protocols`表示客户端已请求从服务器更改协议，并且请求已获批准，`102`表示操作正在后台进行，需要一些时间来完成。
- en: 2xx – success
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2xx – 成功
- en: This is to indicate that a certain level of success has been achieved with information
    success code used in HTTP requests. It packages several responses into specific
    code. For example, `200 Ok` means that nothing went wrong and a GET or POST request
    was successful. `201 Created` means that a GET or POST request has been fulfilled
    and a new resource has been created for the client. `202 Accepted` means that
    a request has been accepted and is now being processed. `204 No Content` means
    that there is no content coming back from the server (very similar to `200`).
    `206 Partial Content` is usually used for paginated responses indicating there
    is more data to follow.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了指示在HTTP请求中使用了一定程度的成功信息成功代码。它将多个响应打包成特定代码。例如，`200 Ok`表示一切正常，GET或POST请求成功。`201
    Created`表示GET或POST请求已完成，并为客户端创建了一个新资源。`202 Accepted`表示请求已被接受并正在处理。`204 No Content`表示服务器没有返回内容（与`200`非常相似）。`206
    Partial Content`通常用于分页响应，表示还有更多数据要返回。
- en: 3xx – redirections
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3xx – 重定向
- en: The **3xx** range is all about the status of the resource or the endpoint. It
    indicates what additional actions must be taken to complete that request as the
    server is still accepting communication, but the endpoint contacted is not the
    correct point of entry in the system. The most common codes used are `301 Moved
    Permanently`, which indicates that future requests must be handled by different
    URIs, `302 Found`, which indicates a temporary redirect is needed for some reason,
    `303 See other`, which tells browsers to see another page, and `308 Permanent
    Redirect`, which indicates a permanent redirection for that resource (this is
    the same as `301`, but does not allow the HTTP method to change).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 3xx范围涉及资源或端点的状态。它指示必须采取哪些额外操作才能完成该请求，因为服务器仍然接受通信，但所联系的端点不是系统中的正确入口点。最常用的代码包括`301
    Moved Permanently`，表示未来的请求必须由不同的URI处理，`302 Found`，表示出于某种原因需要临时重定向，`303 See other`，告诉浏览器查看另一个页面，以及`308
    Permanent Redirect`，表示该资源的永久重定向（与`301`相同，但不允许HTTP方法更改）。
- en: 4xx – client errors
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4xx – 客户端错误
- en: This range of codes is the most well known due to the traditional `404 Not found`
    error, which is a well-known placeholder for URLs that are not properly formed.
    This range of codes indicates that there is something wrong with the request.
    Other well-known codes include `400 Bad Request` (a request that is syntactically
    incorrect), `401 Unauthorized` (lack of authentication from the client), and `403
    Forbidden` (the user does not have privileges). Another common code is `429 Too
    Many Requests`, which is used for rate-limiting requests to indicate that traffic
    from the particular client is rejected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这一范围的代码是最为人熟知的，因为传统的`404 Not found`错误是一个众所周知的占位符，用于表示URL格式不正确。这一范围的代码表示请求存在问题。其他众所周知的代码包括`400
    Bad Request`（语法错误的请求），`401 Unauthorized`（客户端缺乏身份验证），以及`403 Forbidden`（用户没有权限）。另一个常见的代码是`429
    Too Many Requests`，用于限制请求速率，表示特定客户端的流量被拒绝。
- en: 5xx – server errors
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5xx – 服务器错误
- en: This range of codes indicates that there has been a processing error on the
    server or there is something wrong in the server. Whenever a **5xx** code is issued,
    it states that there is some sort of problem in the server that cannot be fixed
    by the client and has to be handled accordingly. Some of the widely used codes
    are `500 Internal Server Error` (this indicates that an error has occurred in
    the server's software and no information is disclosed), `501 Not Implemented` (this
    indicates an endpoint that is not yet implemented, but is still being requested
    for), and `503 Service Unavailable` (this states that the server is down for some
    reason and is not able to process any more requests). On receiving `503`, appropriate
    actions must be taken to start the server again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码范围表示服务器上发生了处理错误或服务器出现了问题。每当发出**5xx**代码时，它表示服务器出现了某种问题，客户端无法解决，必须相应地处理。一些广泛使用的代码包括`500
    Internal Server Error`（表示服务器软件发生错误，未披露任何信息），`501 Not Implemented`（表示尚未实现的端点，但仍在请求），以及`503
    Service Unavailable`（表示服务器由于某种原因宕机，无法处理更多请求）。收到`503`时，必须采取适当措施重新启动服务器。
- en: Why HTTP code is vital in microservices?
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么HTTP代码在微服务中至关重要？
- en: Microservices are fully distributed and constantly moving. Therefore, without
    any standard means of communication, we won't be able to trigger the corresponding
    fail-safe measure. For instance, if we implement the circuit breaker pattern,
    the circuit should know that whenever it receives the **5xx** series of code,
    it should keep the circuit open as the server is unavailable. Similarly, if it
    received `429`, then it should block the request from that particular client.
    The complete microservice ecosystem includes proxies, caches, RPCs, and other
    services for which HTTP is the common language. Based on the aforementioned code,
    they can take appropriate action accordingly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是完全分布式且不断移动的。因此，如果没有标准的通信手段，我们将无法触发相应的故障转移措施。例如，如果我们实现了断路器模式，断路器应该知道每当它收到**5xx**系列代码时，它应该保持断路器打开，因为服务器不可用。同样，如果它收到`429`，那么它应该阻止来自该特定客户端的请求。完整的微服务生态系统包括代理、缓存、RPC和其他服务，其中HTTP是共同的语言。根据上述代码，它们可以相应地采取适当的行动。
- en: In the next section, we will learn about logging aspects and how to handle logging
    in microservices.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习有关日志记录方面以及如何处理微服务中的日志记录。
- en: Auditing via logs
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过日志审计
- en: 'Until now, we have heard that microservices are distributed and services are
    constantly in flux. We need to keep track of all the services and the output that
    they throw. Using `console.log()` is a very bad practice as we won''t be able
    to keep track of all the services because `console.log()` doesn''t have a fixed
    format. Also, we need a stack trace whenever there is an error to debug the possible
    problem. To have distributed logging, we will use the `winston` module ([https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)).
    It has various options, such as log levels, log formats, and so on. For each microservice,
    we will be passing a unique microservice ID, which will identify it when we aggregate
    the logs. For aggregation, we will use the famous ELK Stack, described in [Chapter
    9](90996850-1ced-4678-a297-3e1fee118eb9.xhtml), *Deployment, Logging, and Monitoring*.
    The following are various kinds of log, sorted in priority order, which are generally
    used:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们听说微服务是分布式的，服务不断变化。我们需要跟踪所有服务和它们产生的输出。使用`console.log()`是一个非常糟糕的做法，因为我们无法跟踪所有服务，因为`console.log()`没有固定的格式。此外，每当出现错误时，我们需要堆栈跟踪来调试可能的问题。为了进行分布式日志记录，我们将使用`winston`模块（[https://github.com/winstonjs/winston](https://github.com/winstonjs/winston)）。它具有各种选项，如日志级别、日志格式等。对于每个微服务，我们将传递一个唯一的微服务ID，这将在我们聚合日志时对其进行标识。对于聚合，我们将使用著名的ELK
    Stack，详见[第9章](90996850-1ced-4678-a297-3e1fee118eb9.xhtml)，*部署、日志记录和监控*。以下是按优先级排序的各种日志类型，通常使用：
- en: '**Fatal/emergency (0)**: This is the most catastrophic level, used when the
    system won''t be able to recover or function normally. This forces things like
    shutdown or some other heinous errors.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严重/紧急（0）：这是最灾难性的级别，当系统无法恢复或正常运行时使用。这会强制执行关机或其他严重错误。
- en: '**Alert (1)**: Upon receiving this severe log, actions must be taken immediately
    to prevent system shutdowns. The critical difference here is that the system is
    still usable.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报（1）：收到这个严重的日志后，必须立即采取行动以防止系统关闭。这里的关键区别在于系统仍然可用。
- en: '**Critical(2)**: Here, action needs not be taken immediately. This level includes 
    situations such as failure to connect to a socket, failure to get the latest chat
    message, and so on.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键（2）：在这里，不需要立即采取行动。此级别包括诸如无法连接到套接字、无法获取最新聊天消息等情况。
- en: '**Error(3)**: This is a problem that should be investigated. The Sys Admin
    has to be notified about it, but we don''t need to drag him out of bed as this
    is not an emergency. It is generally used to track overall quality.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误（3）：这是一个应该调查的问题。系统管理员必须被通知，但我们不需要把他从床上拽起来，因为这不是紧急情况。通常用于跟踪整体质量。
- en: '**Warning(4)**: This level is used when there might be an error or there might
    not be an error. Warning conditions are close to errors but they are not errors.
    They indicate potentially harmful situations or events that might possibly lead
    to an error.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告（4）：当可能存在错误或可能不存在错误时使用此级别。警告条件接近错误，但它们不是错误。它们指示可能有害的情况或事件，可能会导致错误。
- en: '**Notice(5)**: This level is a normal log, but with some significant conditions.
    As an example, you may get messages such as Caught SIGBUS attempting to dump core
    in ....'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知（5）：这个级别是一个正常的日志，但具有一些重要的条件。例如，您可能会收到诸如在...中捕获到SIGBUS尝试转储核心之类的消息。
- en: '**Info(6)**: This level is used for unnoticeable information, such as the server
    has been running for *x* hours and interesting runtime events. These logs are
    immediately visible on the console, as the purpose of these logs is to be conservative.
    These logs should be kept to the minimum.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Info(6)**: 这个级别用于不可察觉的信息，比如服务器已经运行了 *x* 小时和有趣的运行时事件。这些日志立即在控制台上可见，因为这些日志的目的是保守。这些日志应该保持最少。'
- en: '**Debug(7)**: This is used for detailed information on the flow through the
    system. It includes messages used for the sake of debugging, for example, something
    like Opening file... or Getting products for productId 47.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Debug(7)**: 这用于详细了解系统的流程。它包括用于调试的消息，例如，像“打开文件…”或“获取产品的产品ID 47”。'
- en: Logs need to be enabled. If you enable fatal logs, then all logs will be seen.
    If you enable info logs, then only info and debug logs will be seen. Logs for
    all levels have their custom method in Winston and we can add our own format.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 需要启用日志。如果启用了致命日志，那么所有日志都将被看到。如果启用了信息日志，那么只有信息和调试日志会被看到。所有级别的日志都有自己的 Winston
    自定义方法，我们可以添加我们自己的格式。
- en: PM2 process manager
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PM2 进程管理器
- en: Node.js is single threaded, meaning any use of a JavaScript `throw` statement
    will raise an exception that must be handled using the `try...catch` statements.
    Otherwise, the Node.js process will exit immediately, making it unavailable to
    process any further requests. As Node.js runs on single process uncaught exceptions,
    it needs to be handled carefully. If not, it will crash and bring down the whole
    application. So, the golden rule in Node.js is *if any exception bubbles out to
    the top without being handled, our application dies*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是单线程的，这意味着任何对 JavaScript `throw` 语句的使用都会引发一个必须使用 `try...catch` 语句处理的异常。否则，Node.js
    进程将立即退出，导致无法处理任何进一步的请求。由于 Node.js 运行在单进程未捕获异常上，需要小心处理。如果不处理，它将崩溃并导致整个应用程序崩溃。因此，在
    Node.js 中的黄金法则是 *如果任何异常未经处理冒泡到顶部，我们的应用程序就会死掉*。
- en: '**PM2** is a process manager designed to keep our service alive forever. It
    is a production process manager with a built-in load balancer and is the perfect
    candidate for microservices. PM2 comes in quite handy as it allows us to declare
    the behavior of each microservice with a simple JSON format. PM2 is an advanced
    task runner with built-in monitoring and zero downtime utilities. Scaling a PM2
    command is just a matter of typing the number of instances we want to spawn up
    or down. Starting a new process with PM2 will initiate a fork mode of the process
    and let the load balancer handle the rest. PM2 acts as a round robin between the
    main process and the process workers so that we can cope with the extra load at
    the same time. Some of the standard deployment features provided by PM2 are as
    follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**PM2** 是一个旨在永远保持我们服务运行的进程管理器。它是一个带有内置负载均衡器的生产进程管理器，是微服务的完美候选者。PM2 非常方便，因为它允许我们使用简单的
    JSON 格式声明每个微服务的行为。PM2 是一个带有内置监控和零停机工具的高级任务运行器。扩展 PM2 命令只是简单地输入我们想要生成或减少的实例数量。使用
    PM2 启动一个新进程将启动一个进程的分叉模式，并让负载均衡器处理其余部分。PM2 在主进程和进程工作线程之间进行轮询，以便我们可以同时处理额外的负载。PM2
    提供的一些标准部署功能如下：'
- en: '| `pm2 start <process_name>` | Starts a process in fork mode with auto-restart
    when the server goes down |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 start <process_name>` | 以分叉模式启动进程，并在服务器宕机时自动重启 |'
- en: '| `pm2 stop <process_name>` | Stops the PM2 process |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 stop <process_name>` | 停止 PM2 进程 |'
- en: '| `pm2 restart <process_name>` | Restarts a process with updated code |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 restart <process_name>` | 重新启动一个带有更新代码的进程 |'
- en: '| `pm2 reload <process_name>` | Reloads PM2 process with zero downtime |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 reload <process_name>` | 重新加载 PM2 进程，零停机时间 |'
- en: '| `pm2 start <process_name> -i max` | Starts a PM2 process in the max number
    of fork modes; that is, it will spawn the max number of instances based on the
    number of CPUs available |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 start <process_name> -i max` | 以最大分叉模式启动一个 PM2 进程；也就是说，它将根据可用的 CPU 数量生成最大数量的实例
    |'
- en: '| `pm2 monit` | Monitors a PM2 process |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 monit` | 监控一个 PM2 进程 |'
- en: '| `pm2 start ecosystem.config.js --env staging` | Starts a process, taking
    configurations from `ecosystem.config.js` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `pm2 start ecosystem.config.js --env staging` | 启动一个进程，使用 `ecosystem.config.js`
    中的配置 |'
- en: 'PM2 can also be used as a deployment tool or an advanced means for CI/CD. All
    you need to do is define your deployment script in the `ecosystem.config.js` file,
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: PM2 也可以用作部署工具或高级的 CI/CD 手段。你只需要在 `ecosystem.config.js` 文件中定义你的部署脚本，如下所示：
- en: '[PRE1]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, all we have to do is hit the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要输入以下命令：
- en: '[PRE2]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command acts as a local deployment tool. Adding things such as path, PEM
    file key, and so on are steps where we can connect to the server. Once connected
    to the server using the specified user, the PM2 process starts and we can run
    our application. The latest Git repository will be cloned and then PM2 will start
    the `dist/Index.js` file in the forever option.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令作为一个本地部署工具。添加路径、PEM 文件密钥等步骤是我们可以连接到服务器的步骤。一旦使用指定用户连接到服务器，PM2 进程就会启动，我们可以运行我们的应用程序。最新的
    Git 存储库将被克隆，然后 PM2 将在 forever 选项中启动 `dist/Index.js` 文件。
- en: Tracing requests
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追踪请求
- en: '**Tracing request** origins is very important, as sometimes we need to reconstruct
    the entire journey of the customer in our system. It provides useful information
    on the system, such as sources of latency. It also enables developers to observe
    how an individual request is being handled by searching across all aggregated
    logs with some unique microservice ID, or to find out the overall journey of the
    user by passing in a time frame. The following is a sample log generated through
    Winston:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪请求的来源非常重要，因为有时我们需要重构客户在我们系统中的整个旅程。它提供了有关系统的有用信息，例如延迟的来源。它还使开发人员能够观察如何通过搜索所有聚合日志来处理单个请求，使用一些唯一的微服务
    ID，或者通过传递时间范围来找出用户的整个旅程。以下是通过 Winston 生成的示例日志：
- en: '[PRE3]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All important data can be seen from the log. We will be using the ELK Stack
    for our log. ELK has huge advantages, as it combines the power of the following
    three tools—**Logstash** (configured to read logs or register events from a myriad
    of sources and send log events to multiple sources), **Kibana** (a configurable
    web dashboard that is used to query Elasticsearch for log information and present
    it to the user), and **Elasticsearch** (a search server based on Lucene, used
    to collect logs, parse them, and store them for later purposes, providing a RESTful
    service and schema-free JSON documents). It has the following advantages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有重要数据都可以从日志中看到。我们将使用ELK Stack进行日志记录。ELK具有巨大的优势，因为它结合了以下三个工具的功能——**Logstash**（配置为从各种来源读取日志或注册事件并将日志事件发送到多个来源）、**Kibana**（可配置的Web仪表板，用于查询Elasticsearch的日志信息并呈现给用户）和**Elasticsearch**（基于Lucene的搜索服务器，用于收集日志、解析日志并将其存储以供以后使用，提供RESTful服务和无模式的JSON文档）。它具有以下优势：
- en: Each instance of **Winston** is configured with ELK. Thus, our log service is
    externalized and the storing of our logs is centralized. Hence, there is a single
    data source where requests can be traced.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个**Winston**实例都配置了ELK。因此，我们的日志服务是外部化的，日志的存储是集中的。因此，有一个单一的数据源可以追踪请求。
- en: Due to the auto-schema definition and proper format of Winston, we have log-structured
    data. For example, if I want to query all the logs from `4:40` to `4.43`, I am
    just an Elasticsearch query away as I know that all my logs have a time component
    at a fixed level in JSON.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Winston的自动模式定义和正确格式，我们拥有日志结构化数据。例如，如果我想查询从`4:40`到`4.43`的所有日志，我只需通过Elasticsearch查询，因为我知道我的所有日志在JSON中的固定级别上都有时间组件。
- en: Winston log formats take care of creating and passing a correlational identifier
    across all the requests. Therefore, server-specific logs, if required, can be
    traced easily by querying that specific parameter.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Winston日志格式负责创建和传递跨所有请求的相关标识符。因此，如果需要，可以通过查询特定参数轻松追踪特定服务器的日志。
- en: Our logs are searchable through Elasticsearch. Elasticsearch provides Kibana
    as well as REST APIs, which can be called upon to look at any point in time through
    all the data in the data source. A lucene-based implementation helps to fetch
    results faster.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过Elasticsearch搜索我们的日志。Elasticsearch提供Kibana以及REST API，可以随时调用以查看数据源中的所有数据。基于Lucene的实现有助于更快地获取结果。
- en: The logging level can be changed on the fly in Winston. We can have various
    log levels and based on the priority of logs, the lower level of logs may or may
    not be seen. This is pretty helpful in solving production-level issues.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Winston中的日志级别可以在运行时更改。我们可以有各种日志级别，并根据日志的优先级，可能会或可能不会看到较低级别的日志。这在解决生产级别的问题时非常有帮助。
- en: In this section, we looked at logging and how it solves such problems as understanding
    customer behavior (how much time a customer spends on the page, how much time
    an action on each page took, what are some of the possible problems, and so on).
    In the next section, we will start developing shopping cart microservices.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看了日志记录以及它如何解决了解客户行为（客户在页面上花费多少时间，每个页面上的操作花费多少时间，可能存在的一些问题等）等问题。在下一节中，我们将开始开发购物车微服务。
- en: Developing some microservices for a shopping cart
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为购物车开发一些微服务
- en: 'In this section, we will develop some microservices for a shopping cart, uniquely
    identified by their business capabilities. So, let''s get a quick overview of
    our current problems before getting our hands dirty. The shopping cart monolithic
    was going well, but with the advent of digitalization, there was a huge increase
    in transaction volumes—300-500 times compared the original estimates. The end
    to end architecture was reviewed and it had the following limitations, based on
    which the microservice architecture was introduced:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为购物车开发一些微服务，这些微服务以其业务能力而独特标识。因此，在动手之前，让我们快速概述一下我们当前的问题。购物车单体应用程序进展顺利，但随着数字化的出现，交易量大幅增加——比原始估计增加了300-500倍。端到端架构经过审查，发现了以下限制，基于这些限制引入了微服务架构：
- en: '**Firmness and sturdiness**: The firmness of the system was greatly impacted
    due to errors and stuck threads, which forced the Node.js application server to
    not accept any new transactions and do a forceful restart. Memory allocation issues
    and database lock threads were major problems. Certain resource-intensive operations
    were impacting the entire application and the resource allocation pool was always
    consumed.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坚固性和稳固性**：由于错误和线程阻塞，系统的坚固性受到了很大的影响，这迫使Node.js应用服务器不接受任何新的事务并进行强制重启。内存分配问题和数据库锁线程是主要问题。某些资源密集型操作影响整个应用程序，资源分配池总是被消耗。'
- en: '**Deployment outages**: Due to adding more and more capabilities, the server
    outage window increased largely because of the server startup time. The large
    size of `node_modules` turned out to be the primary culprit. Since the entire
    application was packaged as a monolith, the entire application demanded to install
    the `node` modules again and again and then start our node-HTTP server.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署中断**：由于添加了越来越多的功能，服务器中断窗口大大增加，因为服务器启动时间增加。由于`node_modules`的大小，导致了这个问题。由于整个应用程序被打包为单体应用，整个应用程序需要一遍又一遍地安装`node`模块，然后启动我们的node-HTTP服务器。'
- en: '**Sharpness**: The complexity of code increased exponentially over time and
    so did the distribution of work. A tight coupling dependency was created among
    the teams. As a result, changes were harder to implement and deploy. Impact analysis
    became too complex to perform. As a result, it was like *fix one bug, 13 others
    come up*. Such complexity rose to a situation where the `node_modules` size was
    over 1 GB. Such complications eventually stopped **continuous integration** (**CI**)
    and unit test casing. Eventually, the quality of the product deteriorated.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锐度**：随着时间的推移，代码的复杂性呈指数增长，工作的分布也是如此。团队之间形成了紧密的耦合依赖关系。因此，实施和部署变得更加困难。影响分析变得过于复杂。结果就是，修复一个bug，就会出现13个其他bug。这样的复杂性导致`node_modules`的大小超过1GB。这样的复杂性最终停止了**持续集成**（**CI**）和单元测试。最终，产品的质量下降了。'
- en: Such situations and problems demanded an evolutionary approach. Such situations
    demanded a microservices development approach. In this section, we will look at
    the microservice setup approach, which will give us various advantages, such as
    selective service scaling, technological independence (easy migration to new technologies),
    containing faults, and so on.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的情况和问题需要一种进化的方法。这样的情况需要一种微服务开发方法。在这一部分，我们将看到微服务设置方法，这将给我们带来各种优势，比如选择性服务扩展、技术独立性（易于迁移到新技术）、容错等等。
- en: Itinerary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行程
- en: 'Let''s quickly go through the itinerary that we are going to perform in this
    exercise:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下我们将在本次练习中执行的行程：
- en: '**Development setup and prerequisite modules**: In this section, we will summarize
    the development tools and `npm` modules that we will use in the project. We will
    look at such prerequisites as application properties, custom middleware, dependency
    injection, and so on.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发设置和先决模块**：在这一部分，我们将总结项目中将使用的开发工具和`npm`模块。我们将关注应用程序属性、自定义中间件、依赖注入等先决条件。'
- en: '**Application directory configurations**: We will analyze the structure that
    we will use in other microservices and understand all the files that we will need
    and where to write the logic.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序目录配置**：我们将分析我们将在其他微服务中使用的结构，并了解我们将需要的所有文件以及在哪里编写逻辑。'
- en: '**Configuration files**: We will have a look at all the configuration files
    through which we can specify various settings, such as database hostname, port
    URL, and so on.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：我们将查看所有配置文件，通过这些文件我们可以指定各种设置，比如数据库主机名、端口URL等等。'
- en: '**Processing data**: We will briefly summarize code patterns and how they can
    support optimal developer output and make the developer''s life easier.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理数据**：我们将简要总结代码模式以及它们如何支持最佳开发者产出，并使开发者的生活更轻松。'
- en: '**Ready to serve**: We will analyze `package.json` and Docker files and see
    how we can use these two files to make our microservice ready to serve any service
    requests.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备服务**：我们将分析`package.json`和Docker文件，并看看如何使用这两个文件使我们的微服务准备好为任何服务请求提供服务。'
- en: So, let's get started with our itinerary.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始我们的行程。
- en: Development setup and prerequisite modules
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发设置和先决模块
- en: In this section, we will look at several aspects that we need to take care of
    while developing and creating our **Development Sandbox.** We will get an overview
    of all the node modules that we will use and the core aspects that each `node`
    module will satisfy. So, it's time to get our hands dirty.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到在开发和创建我们的**开发沙盒**时需要注意的几个方面。我们将概述将使用的所有node模块以及每个`node`模块将满足的核心方面。所以，现在是动手的时候了。
- en: 'Note: We saw how to write custom types in [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*, for any node module that is not written in ES6\. We will
    leverage this for any module whose types are not available in the `DefinitelyTyped`
    repository.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们在[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)中看到了如何为任何不是用ES6编写的node模块编写自定义类型，为任何在`DefinitelyTyped`存储库中没有可用类型的模块利用这一点。
- en: Repository pattern
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库模式
- en: In this section, we will understand the repository pattern, which gives us the
    power to have our code in a single place. TypeScript introduced generics (just
    like the feature in Java), which we are going to utilize to the full extent in
    our microservices. The repository pattern is one of the most widely used patterns
    to create an enterprise-level application. It enables us to directly work with
    data in the application by creating a new layer for database operations and business
    logic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将了解存储库模式，它赋予我们将代码放在一个地方的能力。TypeScript引入了泛型（就像Java中的特性），我们将充分利用这一点在我们的微服务中。存储库模式是创建企业级应用程序最广泛使用的模式之一。它使我们能够通过为数据库操作和业务逻辑创建一个新层直接在应用程序中处理数据。
- en: Combining generics and the repository pattern opens up countless advantages.
    Working with the JavaScript application, we need to deal with problems such as
    code sharing between applications and going modular. The generic repository pattern
    solves this by giving us the power to write an abstraction of data when we have
    one abstract class with generics (or many depending on the business capability)
    and reuse the implementation layer independent of the data model, passing only
    the types to someone's classes. When we talk about the repository pattern, it
    is a repository where we can keep all the operations of the database (CRUD) in
    one locality for any generic business entity. When you need to do the operation
    in the database, your application calls the repository methods, thus enabling
    transparency for whoever calls. Combining this with generics leads to one abstraction,
    one base class that has all the common methods. Our `EntityRepository` only extends
    the base class with all the implementations of the database operations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: This pattern follows the open/closed principle, where the base class is open
    for extension but closed for modification.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'It has various advantages, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: It can be used as an extensibility measure where you just need to write one
    class for all common operations, such as CRUDs, when all other entities should
    have similar operations
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic can be unit tested without touching the data access logic
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database layer can be reused
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database access code is centrally managed in order to implement any database
    access policies and, like caching, it is a walk in the park
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring application properties
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the twelve-factor standards (recall the, *Twelve-factor app of microservices*, section
    in [Chapter 1](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml), *Debunking Microservices*),
    one code base should suffice for multiple environments, such as QA, dev, production,
    and so on. Ensure that we have the application properties file in our application,
    where we can specify the environment name and environment-related stuff. Config
    ([https://www.npmjs.com/package/config](https://www.npmjs.com/package/config))
    is one such module, which helps you in organizing all configurations. This module
    just reads configurations files in the `./config` directory (it should be at the
    same level as `package.json`).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Salient features of config are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: It can support formats such as YAML, YML, JSON, CSV, XML.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can create one directory config parallel to `package.json` and inside it
    create one file, `default.ext` (here, `.ext` can be any of the aforementioned
    formats).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To read from config files, just use the following lines of code:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It has support for various config files, where a hierarchy is maintained for
    supporting various environments.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It even has support for multiple node instances; the perfect fit for microservices.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom health module
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, adding new modules to the application causes the application to go
    out of order. We need custom health modules to actually keep watch on the service
    and alert us that the service is out of order (service discovery does exactly
    this, which we will look at in [Chapter 6](0c5e001e-6dca-4805-866c-7be793a91c70.xhtml),
    *Service Registry and Discovery*). We will be using `express-ping` ([https://www.npmjs.com/package/express-ping](https://www.npmjs.com/package/express-ping))
    to find out the health of our node. By introducing this module in our middleware,
    we can expose a simple API that will tell us about its internal health to both
    operators and other applications.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Salient features of `express-ping` are as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: It is a zero configuration module, where just injecting this in the middleware
    will expose a health endpoint.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this module, simply use the following lines of code:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding just the previous LOCs will expose a `<url>/health` endpoint that we
    can use for health check purposes.We can add authorized access or even use middleware
    for our exposed `/ping` API, which is just plain old express:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This endpoint can be used anywhere just to check the health of the application.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection and inversion of control
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to use basic principles such as dependency
    injection and inversion of control. Coming from a Java background, I tend to use
    these principles in any application in order to make my development process smoother.
    Luckily, we have the exact modules matching our requirements. We will use `inversify`
    ([https://www.npmjs.com/package/inversify](https://www.npmjs.com/package/inversify))
    as the inversion of control container and `typedi` ([https://www.npmjs.com/package/typedi](https://www.npmjs.com/package/typedi))
    for dependency injection.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Inversify
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inversion of control** (**IOC**) is about getting freedom, more flexibility,
    and less dependency on others. Say you are using a desktop computer, you are enslaved
    (or let''s say controlled). You have to sit before a screen and look at it, using
    the keyboard to type and mouse to navigate. Badly written software can enslave
    you similarly. If you replace your desktop with a laptop, then you have inverted
    control. You can easily take it and move around. So, now you can control where
    you are with your computer rather than the computer controlling it. IOC in software
    is very similar. Traditionally speaking, IOC is a design principle in which custom-written
    portions of the computer program receive the flow of control from a generic framework.We
    have `inversifyJS` available as an `npm` module. As per their official docs:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <q>*InversifyJS is a lightweight inversion of control container for TypeScript
    and JavaScript applications. An IOC container will use a class constructor to
    identify and inject its dependencies. It has a friendly API and encourages the
    usage of best OOP and IoC practices adhering to SOLID principles.*</q>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Typedi
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is a means by which classes, components, and services specify
    which libraries they depend on. By simply injecting dependencies into a microservice,
    the service is empowered with the ability to reference dependencies directly,
    rather than looking them up in a service registry or using a service locator.
    The power to encapsulate any service, discover it, and distribute load is an extremely
    valuable addition to microservices. **Typedi** is a dependency injection tool
    for JavaScript and TypeScript. Using Typedi is very easy. All you do is create
    a container and start using dependency injection principles on that container.
    Typedi provides various annotations, such as `@Service`, `@Inject`, and more.
    You can even create your own custom decorators.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: TypeORM
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inspired by frameworks such as hibernate and doctrine, the Entity Framework **TypeORM**
    ([https://www.npmjs.com/package/typeorm](https://www.npmjs.com/package/typeorm))
    is an ORM framework supporting active record and data mapper patterns, unlike
    all other JavaScript ORMs. This enables us to write high quality, loosely coupled,
    scalable, and maintainable applications in the most productive way ever. It has
    the following advantages:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Uses multiple database connections
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works with multiple database types
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query caching
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooks, such as subscribers and listeners
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Written in TypeScript
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports both the Data Mapper and Active Record patterns
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection pooling
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming raw results (reactive programming)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eager and lazy relations
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports SQL as well as NoSQL databases
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application directory configurations
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The directory structure of this application focuses on our architectural approach
    based on separation of concerns. Each folder structure will have files specifically
    pertaining to the name of the folder. In the following screenshot, you can see
    the overall structure and detailed structure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2795b24c-b3ae-493a-811d-b583cab39c49.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Configuration structure
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see two folder structures. The first one
    is the high-level and overall folder structure highlighting important folders,
    whereas the second one is a detailed expanded view of the `src` folder. The folder
    structure follows the *separation of concerns* approach to eliminate code duplication
    and share singleton services between controllers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, **separation of concerns** (**SoC**) is a design principle
    for dividing a computer program into distinct sections or capabilities so that
    each section addresses a separate concern and is independent of the other. A concern
    is a set of information that affects the code of any application.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand our folder structure and the files it contains, and what concern
    the folder actually addresses.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: src/data-layer
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This folder is responsible for the overall organization of the data, its storage,
    and accessibility methods. Model definitions and iridium files can be found here.
    It has the following folders:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapters**: This implements the setup of MongoDB connection methods for connecting
    to the MongoDB database and adding events on connected, error, open, disconnected,
    reconnected, and forced exit methods'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-abstracts**: This has both the schemas representing the structure of
    each MongoDB collection and the documents representing each set of data in the
    collection'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-agents**: This has the query transactions against the data store for
    each MongoDB collection'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: This has a TypeScript class representation of the data portrayed
    by the MongoDB document'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: src/business-layer
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This folder has the implementation of business logic and other resources that
    are needed by the service layer or the middleware layer, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: If we want some security or tokens at a particular microservice
    level, this is where we will add our authentication logic (generally, we don''t
    write the authentication layer at the individual service level). Rather, we write
    it at the API Gateway level, which we will see in [Chapter 5](720d1d4e-1795-457c-903e-65c5a5fb5433.xhtml), *Understanding
    API Gateway*. Here, we will write code for the service registration/deregistration,
    verification, internal security, microservices communicating with the service
    registry, the API Gateway, and so on.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validators**: This will have schema and processing logic for validating data
    sent with API requests. We will write our class-validator ([https://www.npmjs.com/package/class-validator](https://www.npmjs.com/package/class-validator))
    schema here, together with some custom validation functions.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: src/service-layer
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This folder includes the processes for establishing API endpoints in the form
    of routes, which will handle all responses to data requests. It has the following
    folders:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`controllers`: This serves as a primer for processing any data requests associated
    with routes. The custom `controllers` are featured by `npm` module `routing-controllers`
    ([https://www.npmjs.com/package/routing-controllers](https://www.npmjs.com/package/routing-controllers))
    using in-built decorators, such as `@Get`, `@Put`, `@Delete`, `@Param`, and so
    on. These functions implement basic GET, POST, DELETE, and PUT methods for transacting
    with the database via the RESTful API. We can even have socket initialization
    code and more. We will use dependency injection to inject some services which
    will be used here.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request`: This has TypeScript interfaces defining and showing the attributes
    that constitute each of the different kinds of request in the controller.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response`: This has TypeScript interfaces defining and showing the attributes
    that constitute each of the different kinds of response in the controller.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: src/middleware
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This contains resources that have any server configuration, as well as a certain
    place to store any utility processes that can be shared across any application.
    We can have centralized configurations, such `aslogger`, `cache`, `elk`, and so
    on:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '`common`: This has an instantiation of the logger module, which can be shared
    across the entire application. This module is based on `winston` ([https://www.npmjs.com/package/winston](https://www.npmjs.com/package/winston)).'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: This has vendor-specific implementations. We will have express configuration
    and express middleware defined here, as well as all the important configurations
    for organizing the REST API endpoints.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`custom-middleware`: This folder will have all our custom-written middleware,
    which we can utilize in any controller class or any particular method.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will look at some of the configuration files that configure
    and define the application and determine how it will run. For example, the port
    on which it will run, the  port the database is connected to, the modules installed,
    the transpilation configuration, and so on.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at some of the configuration files that we will use throughout
    the project, and use them to govern the project in different environments or as
    per the use case:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**`default.json`**: Node.js has an excellent module, `node-config`. You can
    find the `config` file in the `config` folder parallel to `package.json`. Here,
    you can have multiple configuration files that can be picked up based on environments.
    For example, `default.json` would be loaded first, followed by `{deployment}.json`,
    and so on. Here is a sample file:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**`src/Index.ts`**:This initializes our application, by making a new object
    of the application defined in the `middleware`/`config`/`application`. It imports
    reflected metadata that initializes our dependency injection container.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`package.json`**: This serves as the manifest file in all of the Node.js
    application. It delineates the external libraries required for building the application
    in two sections, `dependencies` and `devDependencies`.  This provides a `scripts` tag
    that has external commands for building, running, and packaging the module.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tsconfig.json`: This provides options for TypeScript when it performs the
    task of transpiling to JavaScript. For example, if we have `sourceMaps:true`,
    we will be able to debug TypeScript code via generated sourcemaps.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/data-layer/adapters/MongoAccess.ts`: This will have a connection to the
    MongoDB database and various event handlers attached to various events of MongoDB,
    such as `open`, `connected`, `error`, `disconnected`, `reconnected`, and so on:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`src/middleware/config/Express.ts`:This is where our express middleware resides.
    We will attach standard configurations, such as `helmet`, `bodyparser`, `cookieparser`,
    `cors origin`, and so on, and set up our `controllers` folder with the following:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Processing data
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most web servers that accept and process requests from clients, we
    have a very similar thing here. We just have granularized things at a macro level.
    The overall flow of the process is shown in the following diagram:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cece010-b02d-4e55-916e-51149307de81.png)Processing data'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the process by taking any of the sample endpoints through
    each of the sections in the preceding diagram. You can find the whole sample in
    `chapter-4/products-catalog service`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'An API request to put a specific product based on the attributes of the product
    is sent to the server, `http://localhost:8081/products/add-update-product`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The registered controllers with the `/products` path capture the request based
    on the `URI /products/`.  If a middleware is registered in `Express.ts`, it will
    get triggered first; otherwise, the controller method gets called. Registering
    a middleware is simple. Create a middleware class with the following code:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To use this middleware in any controller, just make use of the `@UseBefore`
    and `@UseAfter` decorators on top of any method/controller.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we want to execute some core logic (such as picking the response from
    the cache or logging), the `middleware` function gets executed first. This resides
    in `middleware/custom-middleware/MyMiddleWare.ts`. Using the `async` capabilities
    of Node.js, the method will do what is necessary and then proceed on to the next
    request with `next()`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the custom middleware, we can have various checks; for example, we may want
    to expose the APIs only if there is a valid `ownerId` or only to authorized sellers.
    If the request does not have a valid `ownerId`, the request will no longer progress
    through the rest of the application, and we can throw an error indicating authenticity
    or an invalid `productId`. However, if the `ownerId` is valid, then the request
    will continue to progress through the routes. This is the role of `MyMiddleWare.ts`.
    The next part will go through the controllers.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next part is the `@JsonControllers` defined by the decorators provided
    by routing controllers. We define our routing controller and post API for adding
    and updating a product:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will create a PUT request for `API <host:url>/products/add-update-product`.
    The `@Body` annotation will convert a cast of the request body to `IProductCreateRequest
    (src/service-layer/request/IProductRequest.ts`) in the variable request (as seen
    in the argument of the `addIpdateProduct` method), which will be available throughout
    the method. The `request` and `responses` folder contains the transformation of
    a various `request` and `response` objects.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the controller is to validate the request. The validation
    and security logic will be inside the `src/business-layer` folder. Inside the
    `validator` folder, we will have `ProductValidationSchema.ts` and `ProductValidatorProcessor.ts`.
    Inside `ProductValidationSchema.ts`, add the validation schema rules (various
    validation messages through which we want to identify whether a request is correct
    or has junk data) using the `class-validator` ([https://www.npmjs.com/package/class-validator](https://www.npmjs.com/package/class-validator))
    inbuilt decorators, (`@MinLength,` `@MaxLength`, `@IsEmail`, and so on):'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will use these messages to validate our request object. In `ProductValidationProcessor.ts`,
    create a validator method that returns a consolidated array of messages:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `ProductsController.ts`, call the method. If there are errors in the request,
    the request will stop there and won''t propagate to the rest of the API. If the
    response is valid, then it will pass through the data agent to push the data to
    MongoDB:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the request is valid, the controller, `ProductController.ts`, calls the
    `ProductDataAgent.ts` method, `createNewProduct(..)`, in the data layer in order
    to put the data into MongoDB. Further more, based on the Mongoose schema definition,
    it will automatically maintain a duplication check entry:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Controllers in the service layer not only provide access to the data layer through
    data agents used for negotiating queries against the data store, but they also
    provide an entry point of access to the business layer to process other business
    rules, such as validating product input. The `ProductDataAgent.ts` method returns
    the object returned by MongoDB. It also has other methods, such as `deleteProduct`,
    `findAllProducts`, `findProductByCategory`, and so on.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing the transaction with the data store in `ProductDataAgent.ts`,
    a promise in the form of a vanilla object is returned to `ProductController.ts`,
    indicating a failure or success. When a successful product is added to a database,
    the object inserted along with MongoDB''s `ObjectID()` is returned. The data associated
    with the product is constructed as `ProductModel` and will be resolved as an `IProductResponse`
    to `ProductController.ts`:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If some mishap occurs in the processing of the query in `ProductDataAgent.ts`,
    such as a broken connection to the data store, a result in the form of an error
    message will be returned. A similar error response will be thrown if an object
    with the same name already exists.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: This completes the example of how data flows through the application. Based
    on many backend applications and cross-cutting factors, this is designed in order
    to have a smooth flow and eliminate redundant code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, this project will have other APIs, as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: GET request to get all products
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GET request to get products by ID
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GET request to get products by product type
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DELETE request to delete a single product
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ready to serve (package.json and Docker)
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how to write scripts in `package.json` and
    then automate the whole thing using Docker.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: package.json
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how data flows, let''s understand how to make it ready to
    serve. Install TypeScript and `rimraf` as dependencies and add the following inside
    the `scripts` tag:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To run the entire process, execute the following command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will first delete the `dist` folder if it exists, and then, based on the
    `src` folder, it will transpile the folder and generate the `dist` folder. Once
    the `dist` is generated, we can run our server with `node ./dist/Index.js` and
    `npm run start` in combination.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'In a later chapter, we will do more things here, including test coverage and
    generating the swagger documentation. Our build script should cover the following
    things:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Generate documentation via `swagger-gen`
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke `Express.ts`, which will have all routes configured along with middleware
    and dependency injection
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tsc` command will transpile the TypeScript files into JavaScript files
    using the `"outputDirectory":"./dist"` attribute in `tsconfig.json` to identify
    where the JavaScript files should be placed
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SwaggerUI will generate the documentation, which will be available on the web
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to test the API, create a product JSON of the following order and hit
    a POST request with the following payload:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will see a successful response with ResponseCode: 200 and MongoDB''s ObjectId.
    It will look something like this: "id": "5acac73b8bd4f146bcff9667".'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: This is the general approach to how we are going to write our microservice.
    It shows us more behavior on separation of control, how it can be achieved using
    TypeScript, and some enterprise design patterns. Thin controllers that lie in
    the service layer rely on references to the business layer and data layer for
    implementing the process with which we can eliminate redundant code and enable
    the sharing of services between controllers. Similarly, you can write countless
    services based on the same approach. Say you want to write a payment microservice,
    you can use the `typeorm` module for SQL operations and have the same code structure.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our application is up and running, let's containerize it, so we can
    push our image to anyone. Containers such as Docker help us to package an entire
    application including the libraries, dependencies, environment, and anything else
    needed by the application to run. Containers are helpful as they isolate the application
    from the infrastructure so we can easily run it on different platforms without
    the need to worry about the system on which we are running.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Our objectives are as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Spin up a working version of our product catalog microservice, Mongo microservice,
    just by running `docker-compose up`
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker workflow should be what we are using the Node.js workflow that includes
    transpiling, and serving the `dist` folder
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use data containers for initializing MongoDB
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, let''s get started. We will create our `container` file and write starting
    scripts inside it by performing the following steps. You can find the source in
    the `Chapter 4/products-catalog -with-docker` folder:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the `.dockerignore` file to ignore things that we don''t want
    in our built container:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we will write our `Dockerfile`. An image is made up of a set of layers
    and instructions that we define in our `Dockerfile`. We will initialize our Node.js
    application code here:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are done with the Node.js part. Now, we need to configure our MongoDB. We
    will use `docker compose`, a tool for running multiple container applications,
    which will spin up our application and run it. Let''s add a `docker-compose.yml`
    file for adding our MongoDB:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running multiple containers inside a single container is not possible as such.
    We would be leveraging the Docker Compose up tool ([https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)) ,which
    can be downloaded by running `sudo curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-$(uname
    -s)-$(uname -m) -o/usr/local/bin/docker-compose`. We will look at `docker compose`
    in [Chapter 9](90996850-1ced-4678-a297-3e1fee118eb9.xhtml), *Deployment, Logging,
    and Monitoring*.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking up this file shows us the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: We have a service called `app`, which adds a container for the product-catalog
    service.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We instruct Docker to restart the container automatically if it fails.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To build the app service (our TypeScript Node.js application), we need to tell
    the location of our `Dockerfile` where it can find build instructions. The `build
    ./` command tells Docker that the `Dockerfile` is at the same level as `docker-compose.yml`.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We map the host and the container port (here we have kept both the same).
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have added another service, Mongo, which pulls the standard Mongo image from
    the Docker Hub registry.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we define a data directory by mounting `/data/db` and the local data directory
    `/data`.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will have an advantage similar to when we start a new container. Docker
    compose will use the volume of previous containers and thus ensure there is no
    data loss.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we link the app container to the Mongo container.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port `3000:8081` is basically telling us that the Node.js service exposed to
    the outside container world can be accessed at port `3000`, whereas internally
    the application runs on port `8081`.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, just open up a terminal at the parent level and hit the following command:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will spin up two containers and aggregate the logs of both containers.
    We have now successfully Dockerized our application.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Running `docker-compose up` will give you an error that it can''t connect
    to MongoDB. What could we have done wrong? We are running multiple containers
    via the `docker-compose` option. Mongo runs inside its own container; hence, it
    is not accessible via `localhost:27017`. We need to change our connection URL
    to point it to the Docker service rather than the localhost. Change the following
    line in `default.json` from:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 6\. Now, run `docker-compose` up and you will be able to successfully get the
    service up and running.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: By dockerizing our microservice, we have completed the development and build
    cycle. In the next section, we will quickly recap what we have done so far, before
    moving on to the next topic, *Microservice best practices*.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Synopsis
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will have a quick look at some of the modules that we used
    and describe their purpose:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '| `routing-controllers` | Has various options and is based on ES6\. It has
    lots of decorators, such as `@GET`, `@POST`, and `@PUT`, which help us to design
    configuration-free services. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| `config` | Config module from which we can write various files based on different
    environments, thus helping us to adhere to the twelve-factor app. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| `typedi` | Used as a dependency injection container. We can then use it to
    inject services (`@Service`) into any controller. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| `winston` | Used for the logging module. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| `typeORM` | Module written in TypeScript for dealing with relational databases.
    |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| `mongoose` | Popular Mongoose ORM module for dealing with MongoDB. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| `cors` | To enable CORS support for our microservices. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| `class-validator` | Used to validate any input requests based on our configured
    rules. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: Similarly, based on this folder structure and modules, we can create any number
    of microservices supporting any databases. Now that we have a clear understanding
    of how to design a microservice, in the next section we will look at some microservice
    design best practices.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Microservice design best practices
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have developed some microservices, it's time to learn about some
    patterns and some design decisions involved around them. To get a broader perspective,
    we will look at what a microservice should handle and what it shouldn't. A number
    of factors need to be considered while designing microservices, keeping best practices
    in mind. Microservices are solely designed on the principle of single responsibility.
    We need to define boundaries and contain our microservices. The following sections
    cover all the factors and design principles that need to be considered for efficiently
    developing microservices.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Setting up proper microservice scope
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important decisions relating to designing microservices is
    the microservice size. Size and scope can have a huge impact on microservice design.
    While comparing to traditional approaches, we can say there should be one REST
    endpoint per any container or any component that performs a single responsibility.
    Our microservices should be domain-driven, where each service is bound to the
    specific context in that domain and will be dealing with a specific business capability.
    A business capability can be defined as something or anything that is being done
    to contribute to achieving business goals. In our shopping cart microservice system,
    payment, adding to the cart, recommending a product, and dispatching a product
    are different business capabilities. Each different business capability should
    be implemented by a separate microservice. If we go with this model, we will end
    up in our microservices list with a product catalog service, price catalog service,
    invoice service, payment service, and so on. Each of the technical capabilities,
    if any, should be bundled as separate microservices. Technical capabilities don''t
    directly contribute to achieving business goals, but rather serve as a simplification
    to support other services. An example includes the integration service. The main
    points that we should adhere to can be summarized as:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Microservices should be responsible for a single capability (be it technical
    or business)
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices should be individually deployable and scalable
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices should be easily maintainable by a small team and should be replaceable
    at any point in time
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-governing functions
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important factor while scoping microservices is deciding when to pull
    out the function. If the function is self-sustaining, that is, it has very few
    dependencies on external functions, it processes a given output and gives out
    some output. It can then be taken as a microservice boundary and kept as a separate
    microservice. Common examples are caching, encryption, authorization, authentication,
    and so on. Our shopping cart has numerous such examples. For example, it can be
    a central log service, or a price calculation microservice that takes in various
    inputs, such as product name, customer discounts, and so on, and then calculates
    the price of the product after applying promotional discounts, if any.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Polyglot architecture
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key requirements that gave birth to microservices is support for
    a polyglot architecture. Various business capabilities need different treatment.
    The principle of "one rule applies everywhere" doesn't work anymore. Different
    technologies, architectures, and approaches are needed to handle all business
    and technological capabilities. When we are scoping microservices, this is another
    key factor to take care of. For example, in our shopping microservice system,
    a product search microservice doesn't need relational databases, but adding to
    the cart and the payment service need ACID compliance, as handling transactions
    there is a very niche requirement.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Size of independent deployable component
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A distributed microservice ecosystem will take full advantage of currently increasing
    CI/CD processes for automation. Automating various steps, such as integration,
    delivery, deployment, unit testing, scaling, and code coverage and then creating
    a deployable unit makes life easier. If we include too many things in a single
    microservices container, it will pose some huge challenge, as there are a lot
    of processes involved, such as installing dependencies, automatic file copying
    or downloading the source from Git, building, deploying, and then starting up.
    With increasing complexity in the microservice, the size of the microservice will
    increase, which soon increases the trouble in managing it. A well-designed microservice
    makes sure that deployment units remain manageable.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Distributing and scaling services whenever required
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While designing microservices, it is important to breakup microservices based
    on various parameters, such as in-depth analysis of which business capabilities
    are most sought after, a division of services based on ownership, loosely coupled
    architecture, and so on. Microservices designed with this division are effective
    in the long run as we can easily scale out any service on demand and isolate our
    failure points. In our product microservices, approximately 60% of the requests
    would be search based. In this case, our search microservice container has to
    run separately so it can scale separately when needed. Elasticsearch or Redis
    can be introduced on top of this microservice, which would give better response
    times. This will have various advantages, such as cost reduction, effective use
    of resources, business benefits, cost optimizations, and so on.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Being Agile
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With dynamically changing requirements, the Agile methodology of development
    has been adopted everywhere. One of the important considerations in scoping out
    microservices is developing in such a way that each team can develop different
    parts of the pie. Each of the team builds different microservices and then we
    construct the full pie. For example, in our shopping cart microservices, we can
    have one recommendation service that specifically targets an audience based on
    their preferences and history. This can be developed keeping users' tracking history,
    browser history, and more in mind, which can result in a complex algorithm. This
    is why it will be developed as a separate microservice, which can be handled by
    separate teams.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Single business capability handler
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drifting away a bit from the traditional single responsibility principle, a
    single microservice should handle a single business capability or technical capability.
    One microservice should not perform multiple responsibilities. Based on the pattern
    of design, a business capability can be divided into more than one microservice.
    For example, in our shopping cart microservices in inventory management, we may
    introduce a CQRS pattern to achieve some quality attributes, where our reads and
    writes would be spread across different service containers. When each service
    is mapped to a bounded context, handling a single business capability, it is much
    easier to manage them. Each service may exist as separate products, targeting
    a specific community. They should be reusable, easily deployable, and so on.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Adapting to shifting needs
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices should be designed so that they can be easily detached from the
    system with the minimum amount of rewrites. This enables us to easily add experimental
    features. For example, in our shopping cart microservices, we may add a product
    ranking service based on the feedback received. If the service doesn't work out
    or the business capability is not achieved, this service can be thrown out or
    easily replaced with another service. Scoping microservices here plays an important
    role, as a minimum viable product can be made and then, on top of it, features
    can be added or removed as per the requirements.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Handling dependencies and coupling
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important factor in scoping out services is dependencies and the coupling
    a service introduces. Dependencies in microservices have to be evaluated to make
    sure that tight coupling is not introduced in the system. To avoid a high-coupled
    system, decompose the system into business/technical/functional capabilities and
    create a functional dependency tree. Having too many request-response calls, cyclical
    dependencies, and so on are some of the factors that may break a microservice.
    Another important aspect in designing robust microservices is to have event-driven
    architecture; that is, instead of waiting for a response, a microservice should
    react upon receiving an event.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Deciding the number of endpoints in a microservice
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this may seem an important point in consideration for designing microservices,
    it is not at all a design consideration. A microservice container may host one
    or many endpoints. A more important consideration is bounding the microservice.
    Based on the business or technical capabilities, there may be only one endpoint,
    whereas in many cases there could be more than one endpoint in a microservice.
    For example, going back to our shopping cart services for our inventory management
    where we introduced a CQRS pattern, we have separate read and write services,
    each containing single endpoints. Another example can be a polyglot architecture,
    where we have multiple endpoints in order to have communication between various
    microservices. We usually break services into containers based on our deployment
    and scaling needs. For our checkout service, all services are connected and use
    the same relational database. In this case, there is no need to separate out these
    into different microservices.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Communication styles between microservices
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important factor to be considered while designing microservices is the
    communication style between microservices. There can be a synchronous mode (sending
    requests, receiving responses) or an asynchronous mode of communication (fire
    and forget). Both modes have their own pros and cons and have their specific use
    cases where they can be used. In order to have a scalable microservice, a combination
    of both approaches is needed. Apart from this, nowadays "being real-time" is the
    new trend. Socket-based communication promotes real-time communication. Yet another
    way of dividing communication styles is based on the number of receivers. For
    a single receiver, we have a command-based pattern (CQRS, as seen in earlier chapters).
    For more than one receiver, we have an event-driven architecture that is based
    on the principle of the publish and subscribe pattern, where in-service buses
    are used.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Specifying and testing the microservices contract
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A contract can be defined as a set of agreements (protocol, request body, address,
    and so on) between the consumer and the provider, which helps to smooth the interactions
    that take place between them. Microservices should be designed so that they can
    be independently deployed, without any dependencies on one another. To achieve
    this complete independence, each microservice should have well written, versioned,
    and defined contracts, which all its clients (other microservices) must adhere
    to. Introducing breaking changes at any time might be a problem as clients may
    require previous versions of the contract. Only after appropriate communication
    should a contract be put out of service or turned down. Some best practices include
    deploying new versions side by side and including versioning in your API. For
    example, `/product-service/v1`, then `/product-service/v2`. Using **consumer-driven
    contracts** (**CDCs**) is one of the modern ways to test microservices, as compared
    to integration tests. Further, in this book, we will be using Pact JS to test
    our contracts ([Chapter 8](a7273aa2-2981-4013-8d5f-dbee87462d35.xhtml), *Testing,
    Debugging, and Documenting*).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Number of microservices in a container
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containerizing your microservice is one of the most recommended ways for deploying
    microservices. Containers provide agility in your system and it streamlines the
    development and testing experience. Containers are portable across any infrastructure
    and can be easily deployed on AWS too. Deciding on the number of microservices
    that a container can contain is vital and is dependent upon various factors such
    as container capacity, memory, selective scaling, resource requirements, traffic
    volume per service, and so on. Based on these facts, we can decide whether deployments
    can be brought together or not. Even if services are brought together, it has
    to be ensured that these services are run independently and they are not sharing
    anything. Selective scaling is also one of the crucial factors in deciding on
    the number of microservices in a container. It should be such that deployments
    are self-managed, an example being AWS Lambda. The following are the available patterns
    and the limitations of each of the patterns:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '**Service instance per virtual machine**:Here, you package each service as
    a virtual machine image (traditional approach), such as an Amazon EC2 EMI. Here,
    each service is a separate VM that is launched in a separate VM image:'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations**:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less efficient resource utilization
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You pay for entire VM; therefore, if you are not utilizing the entire VM, you
    are paying charges for nothing
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a new version on a service is very slow
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing multiple VMs soon becomes a huge pain and a time-consuming activity
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service instance per container**:Here, each service runs on its own container.
    Containers are one portable virtualization technique. They have their own root
    filesystem and portable namespaces. You can limit their CPU resources and memory.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations**:'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container is not as mature as a VM
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling spikes in the load is an extra added task
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the VM infrastructure and container infrastructure is again an added
    task
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless**:One of the latest "worry free trends" is the serverless architecture,
    where you package a microservice, package it as a ZIP, and deploy it to serverless
    platforms, such as AWS Lambda. You are just billed for each request based on the
    time taken and memory consumed. For example, a Lambda function is stateless.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations:**'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach is not feasible for long-term running services. An example can
    be where a service is dependent on another service or a third-party broker.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests must complete in less than 300 seconds.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services must be stateless, as each separate instance is run for each request.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services must start quickly or else they will be timed out.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services must be run in one of the supported languages. For example, AWS Lambda
    supports Java, Node.js, and Python.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data sources and rule engine among microservices
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important factor is applying a rules engine and deciding upon data sources
    in our distributed system. Rules are an essential part of any system as they help
    us to govern the entire system. Many organizations use a centralized rules engine
    or workflow processes following the BPMN standards example, Drools. An embedded
    rule engine can either be placed within the service or can be external to the
    service based on usage. If there are complex rules, a central authoring repository
    with an embedded engine would be the best choice. Since it is centrally distributed,
    there can be technology dependencies, rules running rules within some application
    server boundaries, and so on.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '**Business Process Modeling Notations** (**BPMN**) are standardized notations
    with the objective of creating visual models of any business or any organizational
    process. Often in business capabilities, we need a definitive workflow that may
    change as per requirements. We never hardcode any processes or write our own engine
    and leverage BPMN tools for it.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Just like the rules engine, deciding on data stores among microservices is also
    crucial. Transactional boundaries should be set up within our defined business
    capabilities. For example, in our shopping cart microservices, at the checkout
    we need to maintain transactions and we can go with RDBMS as a data source to
    ensure integrity and follow ACID principles. However, product catalog databases
    don't have any transactions and we can use NoSQL databases for them.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began designing our microservices for the shopping cart
    services. We analyzed our requirements based on technical, functional, and business
    capabilities, which are the primary drivers in scoping microservices. We designed
    our schema, analyzed our microservice structure, and ran it on Docker. Finally,
    we looked at some of the best practices for microservice design and learned how
    to scope microservices based on our business capabilities.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to introduce a gateway to our
    microservices and understand the problem a gateway solves. We are going to see
    how API Gateway solves centralized concerns in distributed systems. We will get
    acquainted with some API Gateway design patterns and design our gateway for the
    shopping cart microservices.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
