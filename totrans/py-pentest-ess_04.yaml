- en: Network Attacks and Prevention
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, you learned about network scanning and network sniffing.
    In this chapter, you will see different types of network attacks and how to prevent
    them. This chapter will be helpful for network admins and network pentesters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the following topics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**DHCP** (**Dynamic Host Configuration Protocol**) starvation attack'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switch MAC flooding attack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway disassociation by RAW socket
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Torrent detection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, you have seen the implementation of ARP spoofing. Now, let's learn about
    an attack called the network disassociation attack. Its concept is the same as
    ARP cache poisoning.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Python 2.7.x installed on a system. Finally, to
    use the Git repository of this book, the user needs to install Git.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter04)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/oWt8A3](https://goo.gl/oWt8A3)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: DHCP starvation attack
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump to the attack, let''s see how the DHCP server works. When you
    connect to a network via a switch (access point), your machine automatically gets
    the IP address of the network. You might be wondering where your machine got the
    IP from. These configurations come from the DHCP server, configured for the network.
    The DHCP server gives four things: the IP address, subnet mask, gateway address,
    and DNS server address. But if you analyze carefully, the DHCP server also gives
    you lease for allocate IP address. Type the `ipconfig/all` command in the Windows
    Command Prompt. Lease obtained and the lease expires are highlighted in the following
    screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5719dcd6-f1df-497f-a46a-0d1fd9a9f27c.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'You can see DHCP lease in the rectangle. In this attack, we will send a fake
    request to the DHCP server. The DHCP server allocates the IPs with a `Lease` to
    the fake request. In this way, we will finish the pool of IPs of the DHCP server
    until the lease expires. In order to perform the attack, we need two machines:
    an attacker machine, which must be Linux with Scapy and Python installed, and
    a Linux machine with DHCP configured. Both must be connected. You can use Kali
    as the attack and CentOS as the DHCP server. You can configure the DHCP server
    from [http://l4wisdom.com/linux-with-networking/dhcp-server.php](http://l4wisdom.com/linux-with-networking/dhcp-server.php).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Before learning the code and attack, you must understand how the DHCP server
    works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: . ![](img/caf7a05d-031f-4e30-9fb9-e85a7d715339.jpg)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can the understand the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The client broadcasts the **DHCP Discover** request asking for DHCP configuration
    information
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **DHCP server** responds with a **DHCP Offer** message containing an IP
    address and configuration information for lease to the client
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client accepts the offer by selecting the offered address. In response,
    the client broadcasts a **DHCP Request** message
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **DHCP server** sends a unicast DHCP ACK/reply message to the client with
    the following IP config and information:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'IP address: `192.168.0.120`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnet mask: `255.255.255.0`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default gateway: `192.168.0.1`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS server: `192.168.0.2`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lease: One day'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more clarification, see the following Wireshark screenshot, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e9fd748-0d6f-4f0b-a15b-4654dc3f36ce.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, Lease is shown as six hours.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code; it''s a little bit difficult to understand, so I have
    broken it into different parts and explained each part:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential library and modules as follows:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a raw socket to receive IP packets as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the while loop to send packets continuously:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create Ethernet and IP packets using Scapy as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create UDP and bootp packets using Scapy as follows:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create DHCP discover and DHCP request packets as follows:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just send the DHCP discover packet using Scapy and receive the response using
    a raw socket as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Form a DHCP request packet by using the parameters obtained from the previous
    steps as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Send the request packet and take a `0.5` second break to send next packets
    as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code name is `dhcp_starvation.py`. The working of the code is divided into
    two parts. First the attacker machine sends the discover packet, then the DHCP
    server sends the DHCP offer packet with the given IP. In the next part, our code
    extracts the given IP and server IP, crafts new packets called DHCP requests with
    the given IP and server IP, and sends them to the DHCP server. Before running
    the program, check the DHCP lease file in the DHCP server, which is located at** `\var\lib\dhcpd\dhcpd.lease`**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc460ca4-3045-4bfc-a507-5483971ed578.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'You can see that the file is empty, which means no IP is allocated. After running
    the program, the file should be filled, as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/756c460a-d41c-411b-843a-e5a277e7f81a.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows the IP obtained means step 2 of DHCP is working
    and has been completed. The program successfully sent the fake DHCP request. See
    the screenshot of the DHCP server lease file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7ecb6df-0bc6-4326-930e-ed2f770b2529.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot indicates that the program is running successfully.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The MAC flooding attack
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MAC flooding entails flooding the switch with a large number of requests. **Content
    Addressable Memory** (**CAM**) separates a switch from a hub. It stores information,
    such as the MAC address of the connected devices with the physical port number.
    Every MAC in a CAM table is assigned a switch port number. With this information,
    the switch knows where to send Ethernet frames. The size of the CAM tables is
    fixed. You might wonder what happens when the CAM tables get a large number of
    requests. In such a case, the switch turns into a hub, and the incoming frames
    are flooded out on all ports, giving the attacker access to network communication.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: How the switch uses the CAM tables
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The switch learns the MAC address of the connected device with its physical
    port, and writes that entry in the CAM table, as shown in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f76d848-e99f-42e0-b0e0-38b7d139b0df.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: CAM table learning activity
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram is divided into two parts. In the first part, the computer
    with **MAC A** sends the **ARP** packet to the computer with** MAC B**. The switch
    learns the packet, arrives from the physical port `1`, and makes an entry in the
    **CAM Table** such that MAC A is associated with port `1`. The switch sends the
    packet to all the connected devices because it does not have the CAM entry of MAC
    B. In the second part of the diagram, the computer with MAC B responds. The switch
    learns that it came from port `2`. Hence, the switch makes an entry stating that
    the MAC B computer is connected to port `2`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The MAC flood logic
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we send a large number of requests, as shown in the preceding diagram,
    if host A sends fake ARP requests with a different MAC, then the switch will make
    a new entry for port `1` each time, such as `A—1`, `X—1`, and `Y—1`. With these
    fake entries, the CAM table will become full, and the switch will start behaving
    like a hub.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the code as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is very easy to understand. First, it asks for the number
    of packets you want to send. Then, for the interface, you can either choose a `WLAN` interface
    or the `eth` interface. The `eth_pkt` statement forms an Ethernet packet with
    a random MAC address. In the `arp_pkt` statement, an `arp` request packet is formed
    with the destination IP and destination MAC address. If you want to see the full
    packet field, you can use the `arp_pkt.show()` command in Scapy.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The Wireshark output of `mac_flood.py` is as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`mac_flood.py`的Wireshark输出如下截图所示：'
- en: '![](img/490deb01-6f40-43dc-ae9e-bed6359bf000.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/490deb01-6f40-43dc-ae9e-bed6359bf000.png)'
- en: Output of a MAC flooding attack
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MAC洪泛攻击的输出
- en: The aim of MAC flooding is to check the security of the switch. If the attack
    is successful, mark it successful in your reports. In order to mitigate the MAC
    flooding attack, use port security. Port security restricts incoming traffic to
    only a select set of MAC addresses or a limited number of MAC addresses and MAC
    flooding attacks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: MAC洪泛的目的是检查交换机的安全性。如果攻击成功，请在报告中标记为成功。为了减轻MAC洪泛攻击，使用端口安全。端口安全将入站流量限制为一组选择的MAC地址或有限数量的MAC地址和MAC洪泛攻击。
- en: Gateway disassociation by RAW socket
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过原始套接字断开网关
- en: In this attack, the victim will remain connected to the gateway but will not
    be able to communicate with the outer network. Put simply, the victim will remain
    connected to the router but will not be able to browse the internet. The principle
    of this attack is the same as ARP cache poisoning. The attack will send the ARP
    reply packet to the victim and that packet will change the MAC address of the
    gateway in the ARP cache of the victim with another MAC. The same thing is done
    in the gateway.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种攻击中，受害者将保持连接到网关，但将无法与外部网络通信。简单地说，受害者将保持连接到路由器，但将无法浏览互联网。这种攻击的原理与ARP缓存中毒相同。攻击将向受害者发送ARP回复数据包，该数据包将使用另一个MAC地址将受害者的ARP缓存中的网关的MAC地址更改为另一个MAC。在网关中也是同样的操作。
- en: 'The code is the same as that of ARP spoofing, except for some changes, which
    are explained as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与ARP欺骗的代码相同，只是有一些更改，如下所述：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run `netdiss.py`. We can see that there is only one change in the code: `sor =
    'x48x41x43x4bx45x52'`. This is a random MAC as this MAC does not exist.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`netdiss.py`。我们可以看到代码中只有一个更改：`sor = 'x48x41x43x4bx45x52'`。这是一个随机的MAC，因为这个MAC不存在。
- en: In order to carry out the ARP cache poisoning attack, the victim should have
    a real entry of the gateway in the ARP cache.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行ARP缓存中毒攻击，受害者应该在ARP缓存中有网关的真实条目。
- en: You may wonder why we used the `'x48x41x43x4bx45x52'` MAC. Convert it into ASCII
    and you'll get your answer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么我们使用了`'x48x41x43x4bx45x52'`MAC。将其转换为ASCII，您将得到答案。
- en: Torrent detection
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种子检测
- en: The major problem for a network admin is to stop the use of torrents on the
    user machine. Sometimes a small organization or start-up don't have enough funds
    to purchase a firewall to stop the use of a torrent. In an organization, a user
    uses the torrent to download movies, songs, and so on, which eats up a lot of
    bandwidth. In this section, we will see how to eradicate this problem using the
    Python program. Our program will detect the torrent when a torrent program is
    running.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理员的主要问题是阻止用户机器上种子的使用。有时，小型组织或初创公司没有足够的资金购买防火墙来阻止种子的使用。在组织中，用户使用种子下载电影、歌曲等，这会占用大量带宽。在本节中，我们将看到如何使用Python程序消除这个问题。我们的程序将在种子程序运行时检测种子。
- en: The concept is based on the client-server architecture. The server code will
    be run on the admin machine and the client code will be run on the user's machine
    in hidden mode. When a user uses the torrent, the client code will notify the
    server machine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该概念基于客户端-服务器架构。服务器代码将在管理员机器上运行，客户端代码将在用户的机器上以隐藏模式运行。当用户使用种子时，客户端代码将通知服务器机器。
- en: 'First, look at the following server code and try to understand the code. The
    code name is `torrent_detection_server.py`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看以下服务器代码，并尝试理解代码。代码名称是`torrent_detection_server.py`：
- en: 'Import the essential libraries as follows:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式导入必要的库：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Print the messages for the admin. Only use *Ctrl* + *C* to stop the program,
    because *Ctrl* + *C* is handled by the program itself and the socket will be automatically
    closed as follows:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为管理员打印消息。只使用*Ctrl* + *C*来停止程序，因为*Ctrl* + *C*由程序本身处理，套接字将自动关闭如下：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a logger which logs the event in a file, as follows:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个记录事件的日志文件，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a list of the detected clients and define the server IP address and
    port on which the server will run as follows:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建检测到的客户端列表，并定义服务器将在其上运行的服务器IP地址和端口，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a UDP socket as follows:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UDP套接字，如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a while loop to listen continuously. The following code block receives
    the message from the client and logs the event in the log file as follows:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个循环以持续监听。以下代码块接收来自客户端的消息，并在日志文件中记录事件，如下所示：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s see the code of the client machine. Open the `service.py` code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看客户机的代码。打开`service.py`代码：
- en: 'Import the essential libraries and modules as follows:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式导入必要的库和模块：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define the server IP and server port in order to make the socket as follows:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义服务器IP和服务器端口，以便创建套接字，如下所示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use an infinite while loop so that the program remains live as follows:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无限循环，使程序保持活动状态，如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Look at the current task list and try to find the torrent in the task list.
    If the torrent is found, send the crafted message to the server as follows:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看当前任务列表，并尝试在任务列表中找到种子。如果找到种子，向服务器发送精心制作的消息如下：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding program, I used `30` seconds for the next iteration to get
    a quick result. You can change the time to your convenience. If traffic is very
    high, you can use 15 minutes (`15*60`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我使用了`30`秒作为下一次迭代的时间，以获得快速结果。您可以根据自己的方便更改时间。如果流量很大，可以使用15分钟（`15*60`）。
- en: In order to run and test our program, we need at least two computers. One program
    will run on the server, handled by the network admin. The second program will
    run on the client machine.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行和测试我们的程序，我们至少需要两台计算机。一个程序将在由网络管理员处理的服务器上运行。第二个程序将在客户机上运行。
- en: 'Let''s run the code one by one and study our test cases: when the torrent is
    running and when the torrent is not running. First, run the server program. You
    can run the server program on any operating system:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af10a557-223e-486c-b19f-66fcef6dbfd0.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'The server program is running; let''s run the client-side code, `service.py`,
    as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a6ecab-3a1e-4c65-b69c-97f55f209717.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'The preceding program shows nothing but running and continuously scanning current
    tasks. As we have defined 30 seconds in the program, it scans the current task
    after 30 seconds. See the following screenshot, which is the torrent service running
    in the Windows Task Manager:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d8ad7ea-1cc7-4257-98ed-7031f50acccb.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'So uTorrent is running on the client machine. If client code finds a task containing
    a torrent name, then it sends the message to the server. So, in the client program,
    we are using the `response = os.popen(''tasklist'')` line, which runs the tasklist
    command in Command Prompt, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20a9f8f5-4473-44a4-b8c8-4f802d5c4647.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that the torrent is running.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the torrent on the client machine, then the server would get the
    following message:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfca23c4-37df-4c17-a613-be7432add28f.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Gotcha! One machine, hostname `Intel`, user `Mohit`, and IP address `192.168.0.129`,
    is using the torrent. The client sends us three messages, but we displayed only
    one. We are using UPD, which is a connectionless protocol. The server, as well
    as the client, will know nothing if the packet gets lost in traffic. That’s why
    the client sends three packets.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Why UDP and not TCP? TCP is a connection-oriented protocol. If the server machine
    goes down, then the program on the client machine will start giving an error.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'If you lost the output on the screen, you can check the output in the log file.
    Open `torrent_dection.log`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4131ffb5-50f9-4131-a52b-aa9857f8669a.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Now you should better understand torrent detection. But our work is not finished
    yet. If a user on a client machine knows some kind of detection program is running,
    they might stop the program. We will have to get the client code to run in hidden
    mode.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Running the program in hidden mode
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we have to change the `service.py` program to a Windows-executable file.
    In order to convert a Python program to Windows-executable, we are going to use
    Pyinstaller.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Let's change the file into a Windows-executable file. Copy the `service.py` code
    file in the `C:\PyInstaller-2.1` folder.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Command Prompt, browse to the `C:\PyInstaller-2.1` folder, and run
    the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'See the following screenshot for more clarification:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a1e0201-d7e3-41bb-840d-2bd1d1055163.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is self-explanatory. Now that the executable file has
    been created, it can be run by clicking on it. As you click, it will open the
    Command Prompt screen.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Now run the executable program in hidden mode.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `service.vbs` file and write the following lines in the file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding file, I used `%WINDIR%`, which means `Windows` folder; as I
    have installed Windows in the `C:` drive, `%WINDIR%` becomes `C:\Windows`. Just
    click on `service.vbs`. The `service.exe` program will be run as a daemon, with
    no graphical screen, just background processing. Put `service.vbs` in the `Windows
    startup` folder so that the next time Windows gets booted, the `service.vbs` file
    will automatically get executed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about network attacks; the DHCP starvation attack
    can be performed efficiently by using our Python code. The Python code can be
    used for illegal DHCP servers. The MAC flooding attack can turn a switch into
    a hub. Port security must be enabled to mitigate the attack. The gateway disassociation
    attack is very easy to perform; the attacker can annoy a user by using this attack.
    The static entries of the gateway in the ARP cache can be a possible solution
    for the attack. Although torrenting is banned, it is still a big problem for small
    organizations. The solution presented in this chapter can be very effective against
    the torrenting. In next chapter, you will learn about the wireless traffic monitoring.
    You will learn Wireless frame, capturing of frames and Wireless attacks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了网络攻击；DHCP饥饿攻击可以通过使用我们的Python代码来高效地执行。Python代码可以用于非法的DHCP服务器。MAC洪泛攻击可以将交换机变成集线器。必须启用端口安全以减轻攻击。网关断开攻击非常容易执行；攻击者可以使用这种攻击来打扰用户。网关在ARP缓存中的静态条目可能是对抗攻击的一个可能解决方案。尽管下载种子被禁止，但对于小型组织来说仍然是一个大问题。本章介绍的解决方案对抗种子下载可能非常有效。在下一章中，您将学习关于无线流量监控的内容。您将学习无线帧、帧捕获和无线攻击。
