- en: Network Attacks and Prevention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, you learned about network scanning and network sniffing.
    In this chapter, you will see different types of network attacks and how to prevent
    them. This chapter will be helpful for network admins and network pentesters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the following topics.
  prefs: []
  type: TYPE_NORMAL
- en: '**DHCP** (**Dynamic Host Configuration Protocol**) starvation attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switch MAC flooding attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateway disassociation by RAW socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Torrent detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, you have seen the implementation of ARP spoofing. Now, let's learn about
    an attack called the network disassociation attack. Its concept is the same as
    ARP cache poisoning.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Python 2.7.x installed on a system. Finally, to
    use the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/oWt8A3](https://goo.gl/oWt8A3)'
  prefs: []
  type: TYPE_NORMAL
- en: DHCP starvation attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump to the attack, let''s see how the DHCP server works. When you
    connect to a network via a switch (access point), your machine automatically gets
    the IP address of the network. You might be wondering where your machine got the
    IP from. These configurations come from the DHCP server, configured for the network.
    The DHCP server gives four things: the IP address, subnet mask, gateway address,
    and DNS server address. But if you analyze carefully, the DHCP server also gives
    you lease for allocate IP address. Type the `ipconfig/all` command in the Windows
    Command Prompt. Lease obtained and the lease expires are highlighted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5719dcd6-f1df-497f-a46a-0d1fd9a9f27c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see DHCP lease in the rectangle. In this attack, we will send a fake
    request to the DHCP server. The DHCP server allocates the IPs with a `Lease` to
    the fake request. In this way, we will finish the pool of IPs of the DHCP server
    until the lease expires. In order to perform the attack, we need two machines:
    an attacker machine, which must be Linux with Scapy and Python installed, and
    a Linux machine with DHCP configured. Both must be connected. You can use Kali
    as the attack and CentOS as the DHCP server. You can configure the DHCP server
    from [http://l4wisdom.com/linux-with-networking/dhcp-server.php](http://l4wisdom.com/linux-with-networking/dhcp-server.php).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before learning the code and attack, you must understand how the DHCP server
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: . ![](img/caf7a05d-031f-4e30-9fb9-e85a7d715339.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can the understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The client broadcasts the **DHCP Discover** request asking for DHCP configuration
    information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **DHCP server** responds with a **DHCP Offer** message containing an IP
    address and configuration information for lease to the client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client accepts the offer by selecting the offered address. In response,
    the client broadcasts a **DHCP Request** message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **DHCP server** sends a unicast DHCP ACK/reply message to the client with
    the following IP config and information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'IP address: `192.168.0.120`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnet mask: `255.255.255.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default gateway: `192.168.0.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS server: `192.168.0.2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lease: One day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more clarification, see the following Wireshark screenshot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e9fd748-0d6f-4f0b-a15b-4654dc3f36ce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, Lease is shown as six hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code; it''s a little bit difficult to understand, so I have
    broken it into different parts and explained each part:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential library and modules as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a raw socket to receive IP packets as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the while loop to send packets continuously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create Ethernet and IP packets using Scapy as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create UDP and bootp packets using Scapy as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create DHCP discover and DHCP request packets as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Just send the DHCP discover packet using Scapy and receive the response using
    a raw socket as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Form a DHCP request packet by using the parameters obtained from the previous
    steps as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the request packet and take a `0.5` second break to send next packets
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code name is `dhcp_starvation.py`. The working of the code is divided into
    two parts. First the attacker machine sends the discover packet, then the DHCP
    server sends the DHCP offer packet with the given IP. In the next part, our code
    extracts the given IP and server IP, crafts new packets called DHCP requests with
    the given IP and server IP, and sends them to the DHCP server. Before running
    the program, check the DHCP lease file in the DHCP server, which is located at** `\var\lib\dhcpd\dhcpd.lease`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc460ca4-3045-4bfc-a507-5483971ed578.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that the file is empty, which means no IP is allocated. After running
    the program, the file should be filled, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/756c460a-d41c-411b-843a-e5a277e7f81a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows the IP obtained means step 2 of DHCP is working
    and has been completed. The program successfully sent the fake DHCP request. See
    the screenshot of the DHCP server lease file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7ecb6df-0bc6-4326-930e-ed2f770b2529.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot indicates that the program is running successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The MAC flooding attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MAC flooding entails flooding the switch with a large number of requests. **Content
    Addressable Memory** (**CAM**) separates a switch from a hub. It stores information,
    such as the MAC address of the connected devices with the physical port number.
    Every MAC in a CAM table is assigned a switch port number. With this information,
    the switch knows where to send Ethernet frames. The size of the CAM tables is
    fixed. You might wonder what happens when the CAM tables get a large number of
    requests. In such a case, the switch turns into a hub, and the incoming frames
    are flooded out on all ports, giving the attacker access to network communication.
  prefs: []
  type: TYPE_NORMAL
- en: How the switch uses the CAM tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The switch learns the MAC address of the connected device with its physical
    port, and writes that entry in the CAM table, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f76d848-e99f-42e0-b0e0-38b7d139b0df.png)'
  prefs: []
  type: TYPE_IMG
- en: CAM table learning activity
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram is divided into two parts. In the first part, the computer
    with **MAC A** sends the **ARP** packet to the computer with** MAC B**. The switch
    learns the packet, arrives from the physical port `1`, and makes an entry in the
    **CAM Table** such that MAC A is associated with port `1`. The switch sends the
    packet to all the connected devices because it does not have the CAM entry of MAC
    B. In the second part of the diagram, the computer with MAC B responds. The switch
    learns that it came from port `2`. Hence, the switch makes an entry stating that
    the MAC B computer is connected to port `2`.
  prefs: []
  type: TYPE_NORMAL
- en: The MAC flood logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we send a large number of requests, as shown in the preceding diagram,
    if host A sends fake ARP requests with a different MAC, then the switch will make
    a new entry for port `1` each time, such as `A—1`, `X—1`, and `Y—1`. With these
    fake entries, the CAM table will become full, and the switch will start behaving
    like a hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very easy to understand. First, it asks for the number
    of packets you want to send. Then, for the interface, you can either choose a `WLAN` interface
    or the `eth` interface. The `eth_pkt` statement forms an Ethernet packet with
    a random MAC address. In the `arp_pkt` statement, an `arp` request packet is formed
    with the destination IP and destination MAC address. If you want to see the full
    packet field, you can use the `arp_pkt.show()` command in Scapy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Wireshark output of `mac_flood.py` is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/490deb01-6f40-43dc-ae9e-bed6359bf000.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of a MAC flooding attack
  prefs: []
  type: TYPE_NORMAL
- en: The aim of MAC flooding is to check the security of the switch. If the attack
    is successful, mark it successful in your reports. In order to mitigate the MAC
    flooding attack, use port security. Port security restricts incoming traffic to
    only a select set of MAC addresses or a limited number of MAC addresses and MAC
    flooding attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Gateway disassociation by RAW socket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this attack, the victim will remain connected to the gateway but will not
    be able to communicate with the outer network. Put simply, the victim will remain
    connected to the router but will not be able to browse the internet. The principle
    of this attack is the same as ARP cache poisoning. The attack will send the ARP
    reply packet to the victim and that packet will change the MAC address of the
    gateway in the ARP cache of the victim with another MAC. The same thing is done
    in the gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is the same as that of ARP spoofing, except for some changes, which
    are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run `netdiss.py`. We can see that there is only one change in the code: `sor =
    'x48x41x43x4bx45x52'`. This is a random MAC as this MAC does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: In order to carry out the ARP cache poisoning attack, the victim should have
    a real entry of the gateway in the ARP cache.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we used the `'x48x41x43x4bx45x52'` MAC. Convert it into ASCII
    and you'll get your answer.
  prefs: []
  type: TYPE_NORMAL
- en: Torrent detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The major problem for a network admin is to stop the use of torrents on the
    user machine. Sometimes a small organization or start-up don't have enough funds
    to purchase a firewall to stop the use of a torrent. In an organization, a user
    uses the torrent to download movies, songs, and so on, which eats up a lot of
    bandwidth. In this section, we will see how to eradicate this problem using the
    Python program. Our program will detect the torrent when a torrent program is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: The concept is based on the client-server architecture. The server code will
    be run on the admin machine and the client code will be run on the user's machine
    in hidden mode. When a user uses the torrent, the client code will notify the
    server machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, look at the following server code and try to understand the code. The
    code name is `torrent_detection_server.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential libraries as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the messages for the admin. Only use *Ctrl* + *C* to stop the program,
    because *Ctrl* + *C* is handled by the program itself and the socket will be automatically
    closed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a logger which logs the event in a file, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list of the detected clients and define the server IP address and
    port on which the server will run as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a UDP socket as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a while loop to listen continuously. The following code block receives
    the message from the client and logs the event in the log file as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see the code of the client machine. Open the `service.py` code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the essential libraries and modules as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the server IP and server port in order to make the socket as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Use an infinite while loop so that the program remains live as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the current task list and try to find the torrent in the task list.
    If the torrent is found, send the crafted message to the server as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, I used `30` seconds for the next iteration to get
    a quick result. You can change the time to your convenience. If traffic is very
    high, you can use 15 minutes (`15*60`).
  prefs: []
  type: TYPE_NORMAL
- en: In order to run and test our program, we need at least two computers. One program
    will run on the server, handled by the network admin. The second program will
    run on the client machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code one by one and study our test cases: when the torrent is
    running and when the torrent is not running. First, run the server program. You
    can run the server program on any operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af10a557-223e-486c-b19f-66fcef6dbfd0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The server program is running; let''s run the client-side code, `service.py`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a6ecab-3a1e-4c65-b69c-97f55f209717.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding program shows nothing but running and continuously scanning current
    tasks. As we have defined 30 seconds in the program, it scans the current task
    after 30 seconds. See the following screenshot, which is the torrent service running
    in the Windows Task Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d8ad7ea-1cc7-4257-98ed-7031f50acccb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So uTorrent is running on the client machine. If client code finds a task containing
    a torrent name, then it sends the message to the server. So, in the client program,
    we are using the `response = os.popen(''tasklist'')` line, which runs the tasklist
    command in Command Prompt, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20a9f8f5-4473-44a4-b8c8-4f802d5c4647.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that the torrent is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the torrent on the client machine, then the server would get the
    following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfca23c4-37df-4c17-a613-be7432add28f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Gotcha! One machine, hostname `Intel`, user `Mohit`, and IP address `192.168.0.129`,
    is using the torrent. The client sends us three messages, but we displayed only
    one. We are using UPD, which is a connectionless protocol. The server, as well
    as the client, will know nothing if the packet gets lost in traffic. That’s why
    the client sends three packets.
  prefs: []
  type: TYPE_NORMAL
- en: Why UDP and not TCP? TCP is a connection-oriented protocol. If the server machine
    goes down, then the program on the client machine will start giving an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you lost the output on the screen, you can check the output in the log file.
    Open `torrent_dection.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4131ffb5-50f9-4131-a52b-aa9857f8669a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you should better understand torrent detection. But our work is not finished
    yet. If a user on a client machine knows some kind of detection program is running,
    they might stop the program. We will have to get the client code to run in hidden
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Running the program in hidden mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we have to change the `service.py` program to a Windows-executable file.
    In order to convert a Python program to Windows-executable, we are going to use
    Pyinstaller.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change the file into a Windows-executable file. Copy the `service.py` code
    file in the `C:\PyInstaller-2.1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Command Prompt, browse to the `C:\PyInstaller-2.1` folder, and run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following screenshot for more clarification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a1e0201-d7e3-41bb-840d-2bd1d1055163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is self-explanatory. Now that the executable file has
    been created, it can be run by clicking on it. As you click, it will open the
    Command Prompt screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the executable program in hidden mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `service.vbs` file and write the following lines in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding file, I used `%WINDIR%`, which means `Windows` folder; as I
    have installed Windows in the `C:` drive, `%WINDIR%` becomes `C:\Windows`. Just
    click on `service.vbs`. The `service.exe` program will be run as a daemon, with
    no graphical screen, just background processing. Put `service.vbs` in the `Windows
    startup` folder so that the next time Windows gets booted, the `service.vbs` file
    will automatically get executed.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about network attacks; the DHCP starvation attack
    can be performed efficiently by using our Python code. The Python code can be
    used for illegal DHCP servers. The MAC flooding attack can turn a switch into
    a hub. Port security must be enabled to mitigate the attack. The gateway disassociation
    attack is very easy to perform; the attacker can annoy a user by using this attack.
    The static entries of the gateway in the ARP cache can be a possible solution
    for the attack. Although torrenting is banned, it is still a big problem for small
    organizations. The solution presented in this chapter can be very effective against
    the torrenting. In next chapter, you will learn about the wireless traffic monitoring.
    You will learn Wireless frame, capturing of frames and Wireless attacks.
  prefs: []
  type: TYPE_NORMAL
