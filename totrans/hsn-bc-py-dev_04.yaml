- en: Implementing Smart Contracts Using Vyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many programmers who are learning how to write a smart contract will learn about
    the Solidity programming language. There are abundant sources of online tutorials
    and books that can teach you about Solidity. When combined with the Truffle framework,
    Solidity forms a killer combo for developing a smart contract. Almost all smart
    contracts that live on the Ethereum blockchain are written in the Solidity programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how to write a smart contract. However, we
    are not going to use the Solidity programming language for this. Instead, we will
    use the Vyper programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Motivations behind Vyper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Vyper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a smart contract using Vyper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a smart contract to Ganache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going deeper into Vyper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with other smart contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling code programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motivations behind Vyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a smart contract is different than developing a normal web application.
    When developing a normal web application, the motto is *move fast and break things*.
    The speed of developing a web application is paramount. If there is a bug in the
    application, you can always upgrade the application later. Alternatively, if the
    bug is catastrophic, you can patch it online or take the application offline before
    introducing a fix. There is a very popular word to describe the ideal mindset
    in developing a normal web application—agile. You need to be flexible in order
    to change the software as the requirements change.
  prefs: []
  type: TYPE_NORMAL
- en: However, writing a smart contract requires a different mindset. The application
    of smart contracts can range from writing a financial application to launching
    a rocket into space. Fixing an error once a smart contract is deployed is very
    difficult. You cannot replace a smart contract because once it is deployed, it
    is deployed. You can destroy a smart contract if you write a function to do so,
    but the only way to fix a faulty smart contract is to deploy a new smart contract
    that has the fix to the error in a new address, and then communicate this situation
    to all concerned parties. But you cannot replace a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: So, the ideal situation would be a smart contract deployed on the blockchain
    with no bugs, or at least without malignant bugs. However, bugs still appear in
    smart contracts that are released in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: So, what kind of bugs can appear in smart contracts? The first kind is the one
    that will make your money disappear. Let’s say you are writing a smart contract
    for an **initial coin offering** (**ICO**). An ICO is the accumulation of capital
    by selling tokens that you have created on top of an Ethereum blockchain. So basically,
    people buy your token with ethers. You can set the price as you like—for example,
    *1 ETH = 100 YOURTOKEN*. This means that people would get 100 of your tokens if
    they pay you 1 ether.
  prefs: []
  type: TYPE_NORMAL
- en: The first bug that you can introduce is that people can send money (ethers)
    to your smart contract, but you cannot withdraw it (either you forgot to implement
    the withdrawal method or the withdrawal method is faulty). This would mean that
    you could check your smart contract’s balance, and the ether balance could well
    be worth $1 million, but it would be stuck there forever and no one would be able
    to claim it.
  prefs: []
  type: TYPE_NORMAL
- en: Another bug could be that you forgot to secure the method to destroy a smart
    contract. In Ethereum, you are incentivized to remove stuff from the blockchain
    because storage is expensive. So if you deploy a smart contract, you will pay
    a gas fee because your smart contract will be kept. You can experiment with it,
    and then if you get bored with your smart contract, you can destroy it. To do
    that, Ethereum will give some gas back to your account. This is to discourage
    spamming the Ethereum blockchain. So, going back to our case of the smart contract’s
    bug, imagine that you have accumulated $1 million worth of ether in your smart
    contract, and then someone destroys your smart contract account by accessing a
    function to destroy it. In this case, your ether balance will be destroyed as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: The last type of bug is one that allows a hacker to steal your ether balance
    and move it to their account. This could occur under many different circumstances.
    For example, maybe you forgot to the set correct permissions in the withdrawal
    function, or maybe the permission in the withdrawal function is too open.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all of these bugs can be traced back to the fault of the programmers.
    To avoid these kinds of bugs, a new kind of job was born—a smart contract auditor,
    who audits your smart contract to make sure it does not have bugs. However, Vitalik
    Buterin (the inventor of Ethereum) then looked at the tool (the programming language,
    in this case) and wondered whether this situation could be mitigated by improving
    the tool itself. The culprit in this case is the Solidity programming language.
    Vitalik argued that Solidity has some features that are powerful, but have the
    potential to create bugs. Although the developers of Solidity had a plan to improve
    the safety of Solidity, Vitalik wanted some freedom to experiment with a fresh
    perspective. From this, Vyper was born.
  prefs: []
  type: TYPE_NORMAL
- en: Say that you created a parent class that has an important function. In your
    current or child class, you use this function without checking its definition.
    Perhaps the parent class was written by someone else in your team. Programmers
    are sometimes too lazy to check function definitions in other files; they will
    scroll up and down in a source code file to read the code, but programmers often
    will not check code in other files enabled by the inheritance feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another Solidity feature that could really make a smart contract complicated
    and hard to read is a modifier, which is like a preliminary function. The following
    code shows how a modifier is used in Solidity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we want to use the `withdraw()` method, the smart contract will execute the `onlyBy()`
    modifier method first. The `require` phrase is used to ensure that `msg.sender`
    (which calls this method) is the same as the `account` variable that was sent
    as a parameter. This example is simple. You can read all of the code in the blink
    of an eye. However, consider the fact that these functions are separated by many
    lines, or even defined in another file. Programmers have a tendency to overlook
    the definition of the `onlyBy()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function overloading is one of the most powerful features in programming languages.
    This is a feature that enables you to send different parameters to get different
    functions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, the function overloading feature can mislead programmers, causing them
    to execute a function with a different intention. A programmer might only remember
    that the `flexible_function` function does this, but could innocently execute
    a different kind of function than `flexible_function`.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, some smart people decided that while all of these features make
    it possible to create a really complex program, these features should be limited
    to developing a smart contract. Perhaps they got this idea from those who write
    programs on spacecraft, where there are rules as to which features of C++ are
    forbidden to be used. Alternatively, they could have been inspired by the reason
    why Java was created to replace C++. In Java, direct manipulation of the memory
    feature was not possible. Bjarne Stroustoup (the creator of C++) said that C++
    is so powerful that with C++, people can shoot themselves in their foot.
  prefs: []
  type: TYPE_NORMAL
- en: These smart people decided to create a new programming language that is simpler
    than Solidity. Python is their main inspiration because the syntax of this programming
    language is derived from Python. This programming language is called **Vyper**.
    In Vyper, features such as inheritance, function overloading, modifiers, and many
    others are removed. The creator of the Vyper programming language argued that
    the removal of these features can make the development of a smart contract easier.
    Importantly, it also makes the code easier to read. Code is read much more than
    it is written. With all of these factors, they hope that programmers could create
    fewer bugs when using the Vyper programming language to create a smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Ubuntu Xenial has Python 3.5 installed. Vyper needs Python 3.6 software,
    and so you will need to install Python 3.6 first if you want to use Ubuntu Xenial.
    A newer version of Ubuntu, such as Bionic Beaver, will have Python 3.6 installed
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you don''t have Python 3.6 software installed, you must install it first
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not just Python 3.6 that is required by Vyper; you need to install the
    development files `python3.6-dev` as well. Then you can create a virtual environment
    for Python 3.6 by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must install the `virtualenv` tool using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a virtual environment for Python 3.6 using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the virtual environment script as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install Vyper using `pip` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t have any errors here, you are set to go. You can test the Vyper
    compiler as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then you are ready to embark on the next step of your journey.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a smart contract with Vyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s create a smart contract with Vyper. First, we will create a file
    with the `.vy` extension and name it `hello.vy`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you come from a Solidity or Python background, you will notice a peculiarity:
    there is no class (as in the Python programming language) and there is no contract
    (as in the Solidity programming language) in a smart contract written with the
    Vyper programming language. However, there is an `initializer` function. The name
    of the `initializer` function is the same as it is in the Python programming language,
    which is `__init__`.'
  prefs: []
  type: TYPE_NORMAL
- en: While using Python, you can create as many classes as you want in one file.
    In Vyper, the rule is one smart contract per one file. There is also no class
    or contract here; the file itself is a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you compile this `vyper` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf57bb9f-bfb3-4540-ae0f-eb6c6c117ecf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the bytecode of the smart contract. Keep in mind that to deploy a smart
    contract, you need bytecode, but to access a smart contract, you need `abi`. So
    how do you get `abi`? You can do this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2405edb-5251-49b3-b660-5c864f862154.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to get both `abi` and `bytecode` together in a single compilation
    process, you could combine both flags in the compilation process as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3233f1d0-a9d1-4265-a371-be4e50b80301.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying a smart contract to Ganache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So how do you deploy this smart contract to the Ethereum blockchain? There
    are few ways to do this, but let’s employ a familiar way using Truffle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory and initialize it with `truffle` `init` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as you did in the previous chapter, set `truffle-config.js` as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `build` directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a `Hello.json` file there, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then fill the `abi` field with `abi` or `json` output from the compilation
    process, and fill the `bytecode` field with the `bytecode` output from the compilation
    process. You need to quote the `bytecode` value with double quote marks . Don''t
    forget to put comma between the `abi` field and the `bytecode` field. This will
    give you something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then create a migration file to deploy this smart contract by creating
    a new file in `migrations/2_deploy_hello.js`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After everything is set up, fire up Ganache!
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside the `hello_project` directory, you could just run the migration
    process, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9b659a2-abd6-4a70-b2b1-86f75a200cca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your smart contract written with Vyper has been deployed to Ganache. Your smart
    contract address is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Interacting with smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we did before, you can use the Truffle console to interact with your
    smart contract, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Your smart contract is always given the name `Contract`. We can access the
    smart contract using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a long output in which you can see `abi`, `bytecode`, and so on,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b9bbe090-30ea-4f29-86ee-6ee4c07f593d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s look at the value of the `name` variable of the smart contract using
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that the cryptic output does not look like Satoshi Nakamoto.
    However, it actually is Satoshi Nakamoto, but written in hexadecimal. Let’s throw
    away `0x` from the cryptic output; this is just an indicator that this string
    is in hexadecimal form. You now have the `5361746f736869204e616b616d6f746f` string.
    Take the first two numbers, which are `53`, and convert them into a decimal number.
    In Python, you can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, the decimal number is `83`. Do you remember the ASCII table? This is a data
    table that holds the relations between decimal numbers and characters. So, the
    decimal number `65` represents the character A (capital A) and the decimal number
    `66` represents the character B (capital B).
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is the character of the decimal number `83`? You can use Python to
    find out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you do this for all other hexadecimal characters on which each hexadecimal
    character takes two number characters, it would spell out Satoshi Nakamoto.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s execute another method in this smart contract using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That cryptic output is just `Hello, Satoshi Nakamoto`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f7951de4-4b6d-4f2a-aa2f-fee83c0dda03.png)'
  prefs: []
  type: TYPE_IMG
- en: The value in the `from` field is taken from one of the accounts in Ganache.
    You can just look at the Ganache window and choose any account you like.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot send a string directly to the `change_name` method; we have to convert
    it to a hexadecimal string with the `web3.utils.fromAscii` method first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now has the name been changed? Let’s find out. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Yup, the name has been changed. If you transform that hexadecimal string to
    an ASCII string, you will get Vitalik Buterin.
  prefs: []
  type: TYPE_NORMAL
- en: Going deeper into Vyper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a look at our smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The array of bytes is basically a string. The variable called `name` has a
    type of array of `bytes` or `string`. Its visibility is `public`. If you want
    to set it to `private`, then just omit the public keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, take a look at the next lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are coming from a Python background, then you will recognize the Python
    decorator function. There are four of these in Vyper:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@public` means you can execute this method as a user (just as you did in the
    Truffle console in the previous chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@private` means that only other methods inside the same smart contract can
    access this method. You cannot call the method as a user (in the Truffle console).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@payable` means that you can send some ethers to this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@const` is an indicator that this method should not modify the state of a
    smart contract. It means that it will not cost ether to execute this method. It’s
    like reading a public variable''s value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Going back to the `__init__()` method, you could pass a parameter to this method
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to send the parameter when you deploy a smart contract. In our
    case, we use migration in Truffle software, so modify your migration file, `2_deploy_hello.js`,
    to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s move on to the following lines of the smart contract to understand the
    `public` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This method modifies the state of the smart contract, which is the `name` variable.
    This would incur gas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to the next lines of the smart contract to learn about returning
    a value inside the `public` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A `concat` is a built-in function that combines the strings. Refer to [https://vyper.readthedocs.io/en/latest/built-in-functions.html](https://vyper.readthedocs.io/en/latest/built-in-functions.html)
    for a complete list of built-in functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must be careful with the return value of the method indicated by the right
    arrow (→). You might set this to an array of bytes that does not have enough length.
    For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it would fail in compilation, although "Hello, Satoshi Nakamoto"
    is definitely less than 28 characters. The string has a length of 23 characters;
    however, you must remember that `self.name` is defined as `bytes[24]`, and `Hello,` 
     has a length of 7 characters. Because 24 + 7 is 31 characters, you must set this
    to a bigger array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this method does not change the state of this smart contract, you can
    add `@const` on top of this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a more complex smart contract and name it `donation.vy`, as follows.
    You can refer to the followng GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Compile and deploy the smart contract as before. Don’t forget to remove all
    of your files in the `build/contracts` directory and restart your Ganache if you
    reuse the project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss the Vyper data types one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Struct**: The first one is called the struct. A struct in Vyper is just like
    a struct in another programming language; it is a container of different data
    types. You can access its members as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Wei**: The second data type that we are going to learn about is a `uint256(wei)`.
    This refers to a specific amount of ether that can be held. As you know, 1 ether
    is 1,000,000,000,000,000,000 wei (18 zeros). To hold that large an amount, a specific
    data type is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp**: The third data type is the `timestamp` data type. This is designed
    to hold time values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Address**: The fourth one is the address data type. This is designed to hold
    the address value (such as `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF`). This
    could be the address of an account or a smart contract. If you want to know what
    an address data type looks like, you can take a look at Ganache in the following
    screenshot. The address of the account is an example of the address data type.
    You could send ethers to the variable with this data type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/b4336a28-859d-43de-95e5-ce9814e2c196.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Map**: The fifth one is the `map` data type. This is like a dictionary. A
    simple map would be look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the key is `address` and the value is `uint256`. Here’s how you fill
    the value to this map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a twist with this map data type if you are accustomed to the dictionary
    data type in Python: you cannot iterate this map. So, don''t expect to iterate
    a variable that has a mapping data type in Vyper, like you did with variables
    using the `dictionary` data type in Python. You can see how this works by looking
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Ethereum virtual machine** (**EVM**) doesn''t keep track of all the keys
    of a variable that has the mapping data type. In Python, you could get all keys
    from a variable that has the dictionary data type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: But you cannot do this in Vyper.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you access a nonexistent key, it will return the default value of the value
    data type. In our case, if we do something like this, we would get `0`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It makes no difference if you never set the value for the `0x1111111111111111111111111111111111111111`
    key or if you set it with a value of `0`. If you want to keep track of the keys,
    you need to keep them in a separate array. The mapping data type is like the default
    dictionary in Python, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'So, going back to our second defined variable, let''s look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This code shows the map of an address to a struct that contains the `wei`, `string`,
    and `timestamp` data types. We want to record a donator's name, the amount of
    the donation, and the time of the donation with this data type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Array**: The fifth data type is the array data type, which does not have
    infinite size. The size of the array must be set in the beginning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is an array of addresses with size `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following lines to learn how to keep the owner''s
    account in the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**Integer**: The sixth data type is integer. It''s something like `uint256`
    or `int128`. Please note that `uint256` and `uint256(wei)` are different. The
    difference between uint256 and int128 is that the int128 data type can hold zero,
    positive numbers, and negative. The uint256 data type can only hold zero and positive
    numbers, but its upper limit is higher than int128.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code will hold the address of someone who launched this smart
    contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is designed to keep track of how many donators have donated. Note that
    it does not have a public modifier. This means that you cannot access the variable
    from the Truffle console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside every method, there are special objects. One of these is `msg`. You
    can access the account that accesses this method with `msg.sender`. You can also
    find the amount of ethers (in `wei`) with `msg.value`. In the following code,
    we want to save the address of the launcher of this smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `@payable` indicates that this method accepts payment in ether. The `assert` phrase
    is like `assert` in the Python programming language. If the condition is `false`,
    then the execution of the method will be aborted. After the `assert` lines, we
    just set the `self.donatur_details` map with the `msg.sender` key to a `DonaturDetail`
    struct. Inside of the struct, you set the property of the time with `block.timestamp`,
    which indicates the current time. The `as_wei_value` phrase is a built-in function.
    Since we must deal with ether payment using the wei unit in this smart contract,
    it is a good idea to use this built-in function. If not, you have to use a lot
    of zeros, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Withdrawing ethers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last lines of the smart contract will be a method to withdraw donation
    to the `donatee` account, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, `self.balance` represents all ethers that are accumulated in this smart
    contract. The `send` phrase is a built-in function to transfer money to the first
    parameter, in this case, the `donatee`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s test this smart contract in the Truffle console. Make sure you change
    the address in the method to the address of your smart contract. You can get it
    with the `truffle migrate` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first account in Ganache, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0ead1b6c-d44f-48b2-95d7-b83b2e772073.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s donate 2 ether from the second account in Ganache, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now donate 3.5 ether from the third account in Ganache, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now take a look at the donator’s donation using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The way you access a property of a struct is by using two underscores after
    the `donatur_details` struct. You put the key of the map inside the `call` function.
    If you are wondering what `30927f74c9de0000` in `<BN: 30927f74c9de0000>` means,
    it''s not the memory''s location—it''s a number in hexadecimal format. Because
    the number is very big (BN is a short for big number), EVM has to display the
    number in hexadecimal format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at Ganache, the second and third accounts have lost some money,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/05dcbb08-d31f-4562-803a-ffe72ee17cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let’s withdraw the donation using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at your Ganache. The first account, in my case, has 105.48 ETH,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/33f1d182-0bdb-42a3-96f0-d4ae5346126b.png)'
  prefs: []
  type: TYPE_IMG
- en: Other data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vyper has other data types that have not been used in the donation smart contract,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`: This data type is like a normal Boolean. It holds true or false values,
    as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`decimal`: This data type is like `float` or `double` in Python, as shown in
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`bytes32`: This data type is like `bytes32`, with a peculiarity. If the length
    of the value is less than 32 bytes, it will be padded with zero bytes. So, if
    you set the `messi` value (5 characters/bytes) to the `bytes32` data type variable
    (as shown in the following code), it will become `messi\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`Constant`: This data type cannot be changed after being declared:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the C++ programming language, where an uninitialized variable can have
    a garbage value, all uninitialized variables in the Vyper programming language
    have default values. The default integer data type value is `0`. The default Boolean
    data type value is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Useful built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have used built-in functions, such as `send`, `assert`, `as_wei_value`,
    `concat`, and `convert`. However, there are other useful functions, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`slice`: The `slice` phrase is the bytes data type. It''s used for tasks such
    as getting a substring from a string, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`len`: This function is used to get the length of values, as shown in the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`selfdestruct`: This function is used to destroy the smart contract, as shown
    in the following code. The argument is the address that this smart contract sends
    its ethers to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '`ceil`: This function is used to round the integer to the upper limit, as shown
    in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`floor`: This function is used to round the integer to the lower limit, as
    shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`sha3`: This is a built-in hashing function, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vyper supports events. You can broadcast an event in your method to any subscriber
    of this event. For example, when people donate ethers with the smart contract,
    you can broadcast a donation event. To declare an event, you can use the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `donate` method, you can broadcast the event after the donation
    transaction has occurred, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We'll talk more about events in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with other smart contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you know that your smart contract doesn't have to be lonely out there? Your
    smart contract can interact with other smart contracts on the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: The address data type is not only used for normal accounts, but it can also
    be used for smart contract accounts. So, a smart contract can donate ethers to
    our donatee via the donation smart contract!
  prefs: []
  type: TYPE_NORMAL
- en: Restart your Ganache; we will start our blockchain anew. Remember your `hello.vy`
    Vyper file? We want to deploy our `Hello` smart contract with a custom name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our migration file, `migrations/2_deploy_hello.js`, is still the same, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your `hello.vy` file again to get the interface and the bytecode. Open
    our contracts JSON file, the `build/contracts/Hello.json` file. Wipe out all the
    content''s and replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: You have to give a name to your smart contract because this time, you are going
    to deploy two smart contracts. If you don't give a name to your smart contract,
    it will have a default name, `Contract`. It's not a problem if you only want to
    deploy one smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for your `donation.vy`, edit it, and add the following lines of code
    (highlighted in bold) to the code file (refer to the code file in the following
    GitLab link for a complete code file of `donation.vy` at [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_03/donation.vy)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note the changes in bold. These changes are how you declare the interface of
    the smart contract you want to interact with; you declare the contract object
    and the methods you want to interact with. You don't need to know the implementation
    of the `say_hello` method, only the interface (that is, the arguments it expects
    and the return value).
  prefs: []
  type: TYPE_NORMAL
- en: Then call the external smart contract's `donation_smart_contract_call_hello_smart_contract_method `method.
    Send the address as the argument for the contract object and call the method as
    usual. If you already know the address of the smart contract you want to interact
    with, you can hardcode it. But I use an arguments because I don't know the address
    of the `Hello` smart contract yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following code, create another migration file for our upgraded `Donation`
    smart contract, `migrations/3_deploy_donation.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Compile your `donation.vy` and get the interface and the bytecode of the smart
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, using the following code, create another contract JSON file for our `Donation`
    smart contract, `build/contracts/Donation.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the migration. You may have to use `--reset` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/95c24c65-26e2-42fb-8d8a-d18bd11372a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the address of the `Donation` smart contract and the address of the `Hello`
    smart contract. The address of the `Donation` smart contract is `0x98Db4235158831BF9133faC1c4e1829021ecEB67`
    and the address of the `Hello` smart contract is `0xBc932d934cfE859F9Dc903fdd5DE135F32EbC20E`.
    Yours could be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Truffle console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our smart contract is not lonely anymore, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: One of the use cases of the interaction between smart contracts is to create
    a decentralized exchange smart contract. Say that your grandma launched a token
    smart contract named power grid token and your uncle launched a token smart contract
    named Wi-Fi access token. You could create a smart contract that interacts with
    power grid token and Wi-Fi access token. In your smart contract, you could create
    a method to enable the trade between these two tokens; you just have to get their
    smart contract's addresses and interfaces. Of course, you also need to write the
    logic of the trade.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling code programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You could create a script to compile Vyper code, instead of using a command-line
    utility. Make sure that you are in the same directory containing `hello.vy` and
    `donation.vy`. Create a script named `compiler.vy`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute this script using the following command, you will get a `Hello.json`
    file that you could use with Truffle, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s study the script bit by bit. First, import the `Vyper` library
    and some Python standard libraries so we can write a JSON file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You need a Vyper file, the name that you want to give to your smart contract,
    and the output JSON file. The following code will do this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following lines of code to get the content of the Vyper file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you create a dictionary object where the key is a path to your Vyper file
    and the value is the content of the Vyper file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the Vyper code, all you need to do is use the `compile_codes` method
    from the `vyper` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument of the `compile_codes` method is a dictionary with the key
    points to the path and the value representing the Vyper code in a string. The
    second argument is `format`, which consists of the interface and the bytecode.
    The third argument is optional. If you use `''dict''`, then you will get a dictionary.
    If you don''t give a third argument, then you will get an array. Let''s look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Because we used `'dict'` as our third argument, we get the result of a dictionary
    object. The key of the result is our path to the Vyper files. Technically speaking,
    you can set it to any string you like. Some developers use the file path to differentiate
    their Vyper files, which are scattered inside a project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last code is used to write the result to an output JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: By compiling Vyper code programmatically, you can build a framework on top of
    Vyper. In the later chapters of this book, you will use a framework called Populus
    to compile and deploy Vyper files. But you may want to build a better framework,
    or you could build a Vyper **integrated development environment** (**IDE**), such
    as the JetBrains IDE, but for the Vyper programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Other tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vyper is not as liberal as Python; there are some limitations that you must
    live with. To overcome these limitations, you need to make peace with them or
    you need to unlock your creativity. Here are some hints as to how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first limitation is that the array must have a fixed size. In Python, you
    might be very accustomed to having a list that you can extend on your whim, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: There is no such thing in Vyper. You have to declare how big your array is.
    Then you must use an integer variable to track how many items you have inserted
    into this fixed-size array. You used this strategy in the `Donation` smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are itching to have an infinite-sized array, there is a way that you
    can achieve this. You can use the mapping data type with an integer as the key.
    You still use an integer variable to track how many items you have inserted into
    this mapping data type variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: But since `infinite_array_of_strings` is a mapping data type, it's your responsibility
    to guard this variable from the noninteger keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second limitation is that the mapping data type cannot accept the composite
    data type as the key. So you cannot put a mapping data type or struct data type
    as the key. But it can accept a mapping data type or struct data type as the value,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use the struct as the key of the mapping data type variable,
    you could serialize them first. For example, if you want to use two strings as
    the key of the mapping data type variable, you can concatenate the strings to
    make the key for your mapping data type variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could use a nested array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Which approach is better depends on the situation and your preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third limitation is that the Vyper programming language cannot access the
    real world. So, don''t imagine something like the following in your smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to write a smart contract using the Vyper programming
    language. First, we installed the Vyper compiler. Then we developed a smart contract.
    By doing this, we learned about most of the features of the Vyper programming
    language, including the function decorator, initialization function, and function
    permission modifier. There are also some data types such as address, integer,
    timestamp, map, array, and array of bytes (string). We learned how to compile
    a Vyper source to a smart contract and then deploy it to Ganache with the Truffle
    tool. We also interacted with that smart contract through the Truffle console.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about `web3.py`. This is the first
    step towards building a decentralized application.
  prefs: []
  type: TYPE_NORMAL
