- en: '15: Security in Docker'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good security is all about layers, and Docker has lots of layers. It supports
    all the major Linux security technologies, as well as having plenty of its own
    — and most of them are simple and easy to configure.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at some of the technologies that make running containers
    on Docker very secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we get to the deep dive part of the chapter, we’ll divide things up into
    two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux security technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker platform security technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large parts of the chapter will be Linux specific. However, the **Docker platform
    security technologies** section is platform agnostic and applies equally to Linux
    and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Security in Docker - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security is all about layers! Generally speaking, the more security layers you
    have, the more secure you are. Well… Docker offers a lot of security layers. Figure
    15.1 shows some of the security technologies that we’ll cover in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1](images/figure15-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1
  prefs: []
  type: TYPE_NORMAL
- en: Docker on Linux leverages most of the common Linux security technologies. These
    include *namespaces*, *control groups (cgroups)*, *capabilities*, *mandatory access
    control (MAC) systems*, and *seccomp*. For each one, Docker implements sensible
    defaults for a seamless and *moderately secure* out-of-the-box experience. However,
    it also allows you to customize each one to your own specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker platform itself offers some excellent native security technologies.
    And one of the best things about these, is that they’re **amazingly simple to
    use!**
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Swarm Mode** is secure by default. You get all of the following with
    zero configuration required; cryptographic node IDs, mutual authentication, automatic
    CA configuration, automatic certificate rotation, encrypted cluster store, encrypted
    networks, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Content Trust (DCT)** lets you sign your images and verify the integrity
    and publisher of images you pull.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Security Scanning** analyses Docker images, detects known vulnerabilities,
    and provides detailed reports.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker secrets** makes secrets first-class citizens in the Docker ecosystem.
    They get stored in the encrypted cluster store, encrypted in-flight when delivered
    to containers, stored in in-memory filesystems when in use, and operate a least-privilege
    model.'
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to know, is that Docker works with the major Linux security
    technologies as well as providing its own extensive and growing set of security
    technologies. While the Linux security technologies can be a bit complicated to
    configure, the Docker platform’s own security technologies are very simple.
  prefs: []
  type: TYPE_NORMAL
- en: Security in Docker - The deep dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We all know that security is important. We also know that security can be complicated
    and boring!
  prefs: []
  type: TYPE_NORMAL
- en: When Docker decided to bake security into its platform, it decided to make it
    simple and easy. They knew that if security was hard to configure, people wouldn’t
    use it. As a result, most of the security technologies offered by the Docker platform
    are simple to use. They also ship with sensible defaults — this means that you
    get a *fairly secure* platform at zero effort. Of course, the defaults are not
    perfect, but they’re usually enough to give you a safe start. If they don’t suit
    your needs, you can always customize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll organize the rest of this chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux security technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control Groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mandatory Access Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: seccomp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker platform security technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swarm Mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Security Scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Content Trust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux security technologies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All *good* container platforms should use *namespaces* and *cgroups* to build
    containers. The *best* container platforms will also integrate with other Linux
    security technologies such as *capabilities*, *Mandatory Access Control systems*
    like SELinux and AppArmor, and *seccomp*. As expected, Docker integrates with
    them all!
  prefs: []
  type: TYPE_NORMAL
- en: In this section of the chapter we’ll take a *brief* look at some of the major
    Linux security technologies used by Docker. We won’t go into detail, as I want
    the main focus of the chapter to be on the Docker platform technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Kernel namespaces are at the very heart of containers! They let us slice up
    an operating system (OS) so that it looks and feels like multiple isolated operating
    systems. This lets us do really cool things like run multiple web servers on the
    same OS without having port conflicts. It also lets us run multiple apps on the
    same OS without them fighting over shared config files and shared libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of quick examples:'
  prefs: []
  type: TYPE_NORMAL
- en: You can run multiple web servers, each on port 443, on a single OS. To do this
    you just run each web server app inside of its own *network namespace*. This works
    because each *network namespace* gets its own IP address and full range of ports.
    You may have to map each one to a separate port on the Docker host, but each can
    run without being re-written or reconfigured to use a different port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can run multiple applications, each requiring their own particular version
    of a shared library or configuration file. To do this you run each application
    inside of its own *mount namespace*. This works because each *mount namespace*
    can have its own isolated copy of any directory on the system (e.g. /etc, /var,
    /dev etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 15.2 shows a high-level example of two web server applications running
    on a single host and both using port 443\. Each web server app is running inside
    of its own network namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2](images/figure15-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker on Linux currently utilizes the following kernel namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Process ID (pid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network (net)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem/mount (mnt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inter-process Communication (ipc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User (user)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTS (uts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll briefly explain what each one does in a moment. But the most important
    thing to understand is that **Docker containers are an organized collection of
    namespaces**. Let me repeat that… ***A Docker container is an organized collection
    of namespaces***.
  prefs: []
  type: TYPE_NORMAL
- en: For example, every container is made up of its own `pid`, `net`, `mnt`, `ipc`,
    `uts`, and potentially `user` namespace. The organized collection of these namespaces
    is what we call a container. Figure 15.3 shows a single Linux host running two
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3](images/figure15-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s briefly look at how Docker uses each namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Process ID namespace:` Docker uses the `pid` namespace to provide isolated
    process trees for each container. Every container gets its own process tree, meaning
    that every container can have its own PID 1\. PID namespaces also mean that a
    container cannot see or access to the process tree of other containers, or the
    host it’s running on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Network namespace:` Docker uses the `net` namespace to provide each container
    its own isolated network stack. This stack includes; interfaces, IP addresses,
    port ranges, and routing tables. For example, every container gets its own `eth0`
    interface with its own unique IP and range of ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mount namespace:` Every container gets its own unique isolated root `/` filesystem.
    This means that every container can have its own `/etc`, `/var`, `/dev` etc. Processes
    inside of a container cannot access the mount namespace of the Linux host or other
    containers — they can only see and access their own isolated mount namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Inter-process Communication namespace:` Docker uses the `ipc` namespace for
    shared memory access within a container. It also isolates the container from shared
    memory outside of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User namespace:` Docker lets you use `user` namespaces to map users inside
    of a container to different users on the Linux host. A common example is mapping
    the `root` user of a container to a non-root user on the Linux host. User namespaces
    are quite new to Docker and currently optional. This may change in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTS namespace:` Docker uses the `uts` namespace to provide each container
    with its own hostname.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember… a container is an organized collection of namespaces!!!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4](images/figure15-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4
  prefs: []
  type: TYPE_NORMAL
- en: Control Groups
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If namespaces are about isolation, *control groups (cgroups)* are about setting
    limits.
  prefs: []
  type: TYPE_NORMAL
- en: Think of containers as similar to rooms in a hotel. Yes, each room is isolated,
    but each room also shares a common set of resources — things like water supply,
    electricity supply, shared swimming pool, shared gym, shared breakfast bar etc.
    Cgroups let us set limits so that (sticking with the hotel analogy) no single
    container can use all of the water or eat everything at the breakfast bar.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, not the silly hotel analogy, containers are isolated from
    each other but all share a common set of OS resources — things like CPU, RAM and
    disk I/O. Cgroups let us set limits on each of these so that a single container
    cannot use all of the CPU, RAM, or storage I/O of the host.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s a bad idea to run containers as root — root is all-powerful and therefore
    very dangerous. But, it’s a pain in the backside running containers as non-root
    — non-root is so powerless it’s practically useless. What we need is a technology
    that lets us pick and choose which root powers our containers need in order to
    run. Enter *capabilities!*
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, the Linux root account is made up of a long list of capabilities.
    Some of these include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_CHOWN` lets you change file ownership'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_NET_BIND_SERVICE` lets you bind a socket to low numbered network ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_SETUID` lets you elevate the privilege level of a process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_SYS_BOOT` lets you reboot the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on.
  prefs: []
  type: TYPE_NORMAL
- en: Docker works with *capabilities* so that you can run containers as root, but
    strip out the root capabilities that you don’t need. For example, if the only
    root privilege your container needs is the ability to bind to low numbered network
    ports, you should start a container and drop all root capabilities, then add back
    the CAP_NET_BIND_SERVICE capability.
  prefs: []
  type: TYPE_NORMAL
- en: Docker also imposes restrictions so that containers cannot re-add the removed
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Mandatory Access Control systems
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Docker works with major Linux MAC technologies such as AppArmor and SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your Linux distribution, Docker applies a default AppArmor profile
    to all new containers. According to the Docker documentation, this default profile
    is “moderately protective while providing wide application compatibility”.
  prefs: []
  type: TYPE_NORMAL
- en: Docker also lets you start containers without a policy applied, as well as giving
    you the ability to customize policies to meet your specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: seccomp
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Docker uses seccomp, in filter mode, to limit the syscalls a container can make
    to the host’s kernel.
  prefs: []
  type: TYPE_NORMAL
- en: As per the Docker security philosophy, all new containers get a default seccomp
    profile configured with sensible defaults. This is intended to provide moderate
    security without impacting application compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: As always, you can customize seccomp profiles, and you can pass a flag to Docker
    so that containers can be started without a seccomp profile.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts on the Linux security technologies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Docker supports most of the important Linux security technologies and ships
    with sensible defaults that add security but aren’t too restrictive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5](images/figure15-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5
  prefs: []
  type: TYPE_NORMAL
- en: Some of these technologies can be complicated to customize, as they require
    deep knowledge of how they work, as well as how the Linux kernel works. Hopefully
    they will get simpler to configure in the future, but for now, the default configurations
    that ship with Docker are a good place to start.
  prefs: []
  type: TYPE_NORMAL
- en: Docker platform security technologies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section of the chapter, we’ll take a look at some of the major security
    technologies offered by the **Docker platform**.
  prefs: []
  type: TYPE_NORMAL
- en: Security in Swarm Mode
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Swarm Mode is the future of Docker. It lets you cluster multiple Docker hosts
    and deploy your applications in a declarative way. Every Swarm is comprised of
    *managers* and *workers* that can be Linux or Windows. Managers make up the control
    plane of the cluster and are responsible for configuring the cluster and dispatching
    work to it. Workers are the nodes that run your application code as containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, Swarm Mode includes many security features that are enabled out-of-the-box
    with sensible defaults. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic node IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutual authentication via TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure join tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CA configuration with automatic certificate rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted cluster store (config DB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s walk through the process of building a secure Swarm and configuring some
    of the security aspects.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, you will need at least three Docker hosts running Docker 1.13
    or higher. The examples cited use three Docker hosts called “mgr1”, “mgr2”, and
    “wrk1”. Each one is running Docker 18.01.0-ce on Ubuntu 16.04\. There is network
    connectivity between all three hosts, and all three can ping each other by name.
    The setup is shown in Figure 15.6.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6](images/figure15-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6
  prefs: []
  type: TYPE_NORMAL
- en: Configure a secure Swarm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Run the following command from the node you want to be the first manager in
    the new Swarm. In the example, we will run it from “mgr1”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`That’s it! That is literally all you need to do to configure a secure Swarm!'
  prefs: []
  type: TYPE_NORMAL
- en: “mgr1” is configured as the first manager of the Swarm and also as the root
    CA. The Swarm has been given a cryptographic Swarm ID, and “mgr1” has issued itself
    with a client certificate that identifies it as a manager in the Swarm. Certificate
    rotation has been configured with the default value of 90 days, and a cluster
    config database has been configured and encrypted. A set of secure tokens have
    also been created so that new managers and new workers can be joined to the Swarm.
    And all of this with a **single command!**
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 shows how the lab looks now.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7](images/figure15-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s join “mgr2” as an additional manager.
  prefs: []
  type: TYPE_NORMAL
- en: Joining new managers to a Swarm is a two-step process. In the first step, you’ll
    extract the token required to join new managers to the Swarm. In the second, you’ll
    run a `docker swarm join` command on “mgr2”. As long as you include the manager
    join token as part of the `docker swarm join` command, “mgr2” will join the Swarm
    as a manager.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command from “mgr1” to extract the manager join token.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`The output of the command gives you the exact command you need to run on nodes
    that you want to join the Swarm as managers. The join token and IP address will
    be different in your lab.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the command and run it on “mgr2”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`“mgr2” has now joined the Swarm as an additional manager.'
  prefs: []
  type: TYPE_NORMAL
- en: The format of the join command is `docker swarm join --token <manager-join-token>
    <ip-of-existing-manager>:<swarm-port>`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can verify the operation by running a `docker node ls` on either of the
    two managers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`The output above shows that “mgr1” and “mgr2” are both part of the Swarm and
    are both Swarm managers. The updated configuration is shown in Figure 15.8.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8](images/figure15-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8
  prefs: []
  type: TYPE_NORMAL
- en: Two managers is possibly the worst number you can have. However, we’re just
    messing about in a demo lab, not building a business critical production environment
    ;-)
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Swarm worker is a similar two-step process. Step 1 is to extract the
    join token for new workers, and step 2 is to run a `docker swarm join` command
    on the node you want to join as a worker.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command on either of the managers to expose the worker join
    token.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Again, you get the exact command you need to run on nodes that you want to
    join as workers. The join token and IP address will be different in your lab.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the command and run it on “wrk1” as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Run another `docker node ls` command from either of the Swarm managers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`You now have a Swarm with two managers and one worker. The managers are configured
    for high availability (HA) and the cluster store is replicated to them both. This
    updated configuration is shown in Figure 15.9.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9](images/figure15-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9
  prefs: []
  type: TYPE_NORMAL
- en: Looking behind the scenes at Swarm security
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we’ve built a secure Swarm let’s take a minute to look behind the scenes
    at some of the security technologies involved.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm join tokens
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The only thing that is needed to join managers and workers to an existing Swarm
    is the relevant join token. For this reason, it is vital that you keep your join-tokens
    safe! No posting them on public GitHub repos!
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Swarm maintains two distinct join tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: One for joining new managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One for joining new workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s worth understanding the format of the Swarm join token. Every join token
    is comprised of 4 distinct fields separated by dashes (`-`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`PREFIX - VERSION - SWARM ID - TOKEN`'
  prefs: []
  type: TYPE_NORMAL
- en: The prefix is always “SWMTKN”, enabling you to pattern match against it and
    prevent people from accidentally posting it publicly. The version field indicates
    the version of the Swarm. The Swarm ID field is a hash of the Swarm’s certificate.
    The token portion is the part that determines if it can be used to join nodes
    as managers or workers.
  prefs: []
  type: TYPE_NORMAL
- en: As the following shows, the manager and worker join tokens for a given Swarm
    are identical except for the final TOKEN field.
  prefs: []
  type: TYPE_NORMAL
- en: 'MANAGER: SWMTKN-1-1dmtwusdc…r17stb-**2axi53zjbs45lqxykaw8p7glz**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WORKER: SWMTKN-1-1dmtwusdc…r17stb-**ehp8gltji64jbl45zl6hw738q**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you suspect that either of your join tokens has been compromised you can
    revoke them and issue new ones with a single command. The following example revokes
    the existing *manager* join token and issues a new one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice that the only difference between the old and new join tokens is the
    last field. The Swarm ID remains the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Join tokens are stored in the cluster config database which is encrypted by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: TLS and mutual authentication
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Every manager and worker that joins a Swarm is issued a client certificate.
    This certificate is used for mutual authentication. It identifies the node, which
    Swarm the node is a member of, and role the node performs in the Swarm (manager
    or worker).
  prefs: []
  type: TYPE_NORMAL
- en: On a Linux host, you can inspect a node’s client certificate with the following
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`The `Subject` data in the output above uses the standard `O`, `OU`, and `CN`
    fields to specify the Swarm ID, the node’s role, and the node ID.'
  prefs: []
  type: TYPE_NORMAL
- en: The Organization `O` field stores the Swarm ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Organizational Unit `OU` field stores the node’s role in the Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Canonical Name `CN` field stores the node’s crypto ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is shown in Figure 15.10.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10](images/figure15-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the certificate rotation period in the `Validity` section directly
    above.
  prefs: []
  type: TYPE_NORMAL
- en: We can match these values to the corresponding values shown in the output of
    a `docker system info` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`###### Configuring some CA settings'
  prefs: []
  type: TYPE_NORMAL
- en: You can configure the certificate rotation period for the Swarm with the `docker
    swarm update` command. The following example changes the certificate rotation
    period to 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Swarm allows nodes to renew certificates early (slightly before they expire)
    so that not all nodes in the Swarm try and update their certificates at the same
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: You can configure an external CA when creating a Swarm by passing the `--external-ca`
    flag to the `docker swarm init` command.
  prefs: []
  type: TYPE_NORMAL
- en: The new `docker swarm ca` sub-command can be used to manage CA related configuration.
    Run the command with the `--help` flag to see a list of things it can do.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`###### The cluster store'
  prefs: []
  type: TYPE_NORMAL
- en: The cluster store is the brains of a Swarm and is the place where cluster config
    and state are stored.
  prefs: []
  type: TYPE_NORMAL
- en: The store is currently based on an implementation of `etcd`, and is automatically
    configured to replicate itself to all managers in the Swarm. It is also encrypted
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster store is becoming a critical component of many Docker platform technologies.
    For example, Docker networking and Docker Secrets both leverage the cluster store.
    This is one of the reasons that Swarm Mode is so important to the future of Docker
    — many parts of the Docker platform already leverage the cluster store, and more
    will leverage it in the future. The moral of the story… if you’re not running
    in Swarm Mode, you’ll be limited in what other Docker features you can use.
  prefs: []
  type: TYPE_NORMAL
- en: The day-to-day maintenance of the cluster store is taken care of automatically
    by Docker. However, in production environments, you should have strong backup
    and recovery solutions in place for it.
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough for now about Swarm Mode security.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting vulnerabilities with Docker Security Scanning
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ability to quickly identify code vulnerabilities is vital. Docker Security
    Scanning makes detecting known vulnerabilities in Docker images simple.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** At the time of writing, Docker Security Scanning is available for
    images in private repositories on Docker Hub. It is also available as part of
    the Docker Trusted Registry on-premises registry solution. Finally, all official
    Docker images are scanned and scan reports are available in their repos.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Docker Security Scanning performs binary-level scans of Docker images and checks
    the software in them against databases of known vulnerabilities (CVE databases).
    After the scan is performed, a detailed report is made available.
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser to https://hub.docker.com and search for the `alpine` repo.
    Figure 15.11 shows the `Tags` tab of the official Alpine repo.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11](images/figure15-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11
  prefs: []
  type: TYPE_NORMAL
- en: The Alpine repo is an official repo. This means it automatically gets scanned
    and scan reports are made available. As you can see, the images tagged as `edge`,
    `latest`, and `3.6` are free from known vulnerabilities. However, the `alpine:3.5`
    image has known vulnerabilities (red).
  prefs: []
  type: TYPE_NORMAL
- en: If you drill into the `alpine:3.5` image you get a more detailed report as shown
    in Figure 15.12.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12](images/figure15-12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple and easy way to get detailed information about known vulnerabilities
    in your software.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Trusted Registry (DTR), which is an on-premises Docker registry included
    as part of Docker Enterprise Edition, provides the same capabilities and gives
    you control over how and when image scans are performed. For example, DTR lets
    you decide if images should be automatically scanned as soon as they are pushed,
    or if scans should only be triggered manually. It also allows you to manually
    upload CVE database updates — this is ideal for situations where your DTR infrastructure
    is air-gapped from the internet and cannot automatically sync updates.
  prefs: []
  type: TYPE_NORMAL
- en: That’s Docker Security Scanning — a great way to deeply inspect your Docker
    images for known vulnerabilities. Beware though, with great knowledge comes great
    responsibility — once you know about vulnerabilities, it’s your responsibility
    to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: Signing and verifying images with Docker Content Trust
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Docker Content Trust (DCT) makes it simple and easy to verify the integrity
    and the publisher of images that you download. This is especially important when
    pulling images over untrusted networks such as the internet.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, DCT allows developers to sign their images when they are pushed
    to Docker Hub or Docker Trusted Registry. It will also automatically verify images
    when they are pulled. This high-level process is shown in Figure 15.13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13](images/figure15-13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13
  prefs: []
  type: TYPE_NORMAL
- en: DCT can also provide important *context*. This includes things like; whether
    or not an image has been signed for use in a production environment, or whether
    an image has been superseded by a newer version and is therefore stale.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the *context* offerings of DTC are in their infancy
    and quite complex to configure.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do, to enable DCT on a Docker host, is export an environment
    variable called `DOCKER_CONTENT_TRUST` with a value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`In the real world, you may want to make this a more permanent feature of your
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Docker Universal Control Plane (part of Docker Enterprise Edition),
    you need to set the `Only run signed images` checkbox as shown in Figure 15.14\.
    This will force all nodes in the UCP cluster to only work with signed images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14](images/figure15-14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14
  prefs: []
  type: TYPE_NORMAL
- en: You can see from Figure 15.14 that Universal Control Plane takes DCT one step
    further by giving the option to list security principals that are required to
    sign an image. For example, you might have a corporate policy that all images
    used in production need to be signed by the `secops` team.
  prefs: []
  type: TYPE_NORMAL
- en: Once DCT has been enabled, you will no longer be able to pull and work with
    unsigned images. Figure 15.15 shows the errors you will get if you attempt to
    pull an unsigned image using the Docker CLI and the Universal Control Plane web
    UI (both examples are attempting to pull an image tagged as “unsigned”)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15](images/figure15-15.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.16 shows how DCT prevents a Docker client from pulling an image that
    has been tampered with. Figure 15.17 shows DCT preventing a client pulling an
    image that is stale.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 Pulling an image that has been tampered with](images/figure15-16.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 Pulling an image that has been tampered with
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17 Pulling a stale image](images/figure15-17.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.17 Pulling a stale image
  prefs: []
  type: TYPE_NORMAL
- en: Docker Content Trust is an important technology for helping you verify the images
    you are pulling from Docker registries. It’s simple to configure in its basic
    form, but more advanced features, such as *context*, are currently more complex
    to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Secrets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many applications need secrets. Things like passwords, TLS certificates, SSH
    keys, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Docker 1.13, there was no standard way of making secrets available
    to apps in a secure way. It was common for developers to insert secrets into apps
    via plain text environment variables (we’ve all done it). This was far from ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Docker 1.13 introduced *Docker Secrets*, effectively making secrets first-class
    citizens in the Docker ecosystem. For example, there is a whole new `docker secret`
    sub-command dedicated to managing secrets. There’s also a page for creating and
    managing secrets in the Docker Universal Control Plane UI. Behind the scenes,
    secrets are encrypted at rest, encrypted in-flight, mounted in in-memory filesystems,
    and operate under a least-privilege model where they are only made available to
    services that have been explicitly granted access to them. It’s quite a comprehensive
    end-to-end solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.18 shows a high-level workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18](images/figure15-18.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.18
  prefs: []
  type: TYPE_NORMAL
- en: The following steps walk through the high-level workflow shown in Figure 15.18.
  prefs: []
  type: TYPE_NORMAL
- en: The blue secret is created and posted to the Swarm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It gets stored in the encrypted cluster store (all managers have access to the
    cluster store)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The blue service is created and the secret is attached to it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The secret is encrypted in-flight while it is delivered to the tasks (containers)
    in the blue service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The secret is mounted into the containers of the blue service as an unencrypted
    file at `/run/secrets/`. This is an in-memory tmpfs filesystem (this step is different
    on Windows Docker hosts as they do not have the notion of an in-memory filesystem
    like tmpfs)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the container (service task) completes, the in-memory filesystem is torn
    down and the secret flushed from the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The red containers in the red service cannot access the secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create and manage secrets with the `docker secret` sub-command, and
    you can attach them to services by specifying the `--secret` flag to the `docker
    service create` command.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker can be configured to be extremely secure. It supports all of the major
    Linux security technologies, including; kernel namespaces, cgroups, capabilities,
    MAC, and seccomp. It ships with sensible defaults for all of these, but you can
    customize them and even disable them.
  prefs: []
  type: TYPE_NORMAL
- en: Over and above the general Linux security technologies, the Docker platform
    includes an extensive set of its own security technologies. Swarm Mode is built
    on TLS and is insanely simple to configure and customize. Security Scanning performs
    binary-level scans of Docker images and provides detailed reports of known vulnerabilities.
    Docker Content Trust lets you sign and verify content, and secrets are now first-class
    citizens in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: The net result is that your Docker environment can be configured to be as secure
    or insecure as you desire — it all depends on how you configure it.[PRE13]
  prefs: []
  type: TYPE_NORMAL
