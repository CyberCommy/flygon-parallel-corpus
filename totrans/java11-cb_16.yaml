- en: GUI Programming Using JavaFX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GUI using JavaFX controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using FXML markup to create a GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CSS to style elements in JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding HTML in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding media in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding effects to controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Robot API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GUI programming has been in Java since JDK 1.0, via the API called the **Abstract
    Window Toolkit** (**AWT**). This was a remarkable thing during those times, but
    it had its own limitations, a few of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It had a limited set of components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You couldn't create custom reusable components because AWT was using native
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The look and feel of the components couldn't be controlled, and they took the
    look and feel of the host OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, in Java 1.2, a new API for GUI development called **Swing** was introduced,
    which worked on the deficiencies of AWT by providing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A richer components library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for creating custom components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A native look and feel, and support for plugging in a different look and feel.
    Some well-known Java looks and feel themes are Nimbus, Metal, Motif, and the system
    default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot of desktop applications that make use of Swing have been built, and a
    lot of them are still being used. However, with time, technology has to evolve;
    otherwise, it will eventually be outdated and seldom used. In 2008, Adobe's **Flex**
    started gaining attention. It was a framework for building **Rich Internet applications**
    (**RIAs**). The desktop applications were always rich component-based UIs, but
    the web applications were not that amazing to use. Adobe introduced a framework
    called Flex, which enabled web developers to create rich, immersive UIs on the
    web. So the web applications were no longer boring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adobe also introduced a rich internet application runtime environment for the
    desktop called **Adobe AIR**, which allowed the running of Flex applications on
    the desktop. This was a major blow to the age-old Swing API. But let''s go back
    to the market: In 2009, Sun Microsystems introduced something called **JavaFX**.
    This framework was inspired by Flex (which used XML for defining the UI) and introduced
    its own scripting language called **JavaFX** **script**, which was somewhat closer
    to JSON and JavaScript. You could invoke Java APIs from the JavaFX script. There
    was a new architecture introduced, which had a new Windowing toolkit and a new
    graphics engine. It was a much better alternative to Swing, but it had a drawback—developers
    had to learn JavaFX script to develop JavaFX-based applications. In addition to
    Sun Microsystems not being able to invest more on JavaFX and the Java platform,
    in general, JavaFX never took off as envisioned.'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle (after acquiring Sun Microsystems) announced a new JavaFX Version 2.0,
    which was an entire rewrite of JavaFX, thereby eliminating the scripting language
    and making JavaFX an API within the Java platform. This has made using the JavaFX
    API similar to using Swing APIs. Also, you can embed JavaFX components within
    Swing, thereby making Swing-based applications more functional. Since then, there
    has been no looking back for JavaFX.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX is no longer being bundled with JDK 11 onward (neither Oracle JDK nor
    OpenJDK builds). And it's also no longer being bundled with the OpenJDK 10 build.
    They have to be downloaded separately from the OpenJFX Project page ([https://wiki.openjdk.java.net/display/OpenJFX/Main](https://wiki.openjdk.java.net/display/OpenJFX/Main)).
    A new community website has been launched for OpenJFX ([https://openjfx.io/](https://openjfx.io/))
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus entirely on the recipes around JavaFX. We will
    try to cover as many recipes as possible to give you all a good experience of
    using JavaFX.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GUI using JavaFX controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at creating a simple GUI application, using JavaFX
    controls. We will build an app that will help you compute your age, after you
    provide your date of birth. Optionally, you can even enter your name, and the
    app will greet you and display your age. It is a pretty simple example that tries
    to show how you can create a GUI by using layouts, components, and event handling.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the modules part of JavaFX:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.base`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.controls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.fxml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.graphics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.media`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.swing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using Oracle JDK 10 and 9, it comes with the previously mentioned
    JavaFX modules as part of the setup; that is to say, you can find them in the
    `JAVA_HOME/jmods` directory. And if you are using OpenJDK 10 onward and JDK 11
    onward, you need to download the JavaFX SDK from [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) [and
    make the JARs at the location `JAVAFX_SDK_PATH/libs` available on your `modulepath`,
    as follows:](https://gluonhq.com/products/javafx/)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In our recipe, we will be using a few modules as and when required from the
    preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a class that extends `javafx.application.Application`. The `Application`
    class manages the life cycle of the JavaFX application. The `Application` class
    has an abstract method, `start(Stage stage)`, which you have to implement. This
    would be the starting point for the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The class can also be the starting point for the application by providing a
    `public static void main(String [] args) {}` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code for the subsequent steps has to be written within the `start(Stage
    stage)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a container layout to properly align the components that we will
    be adding. In this case, we will use `javafx.scene.layout.GridPane` to lay out
    the components in the form of a grid of rows and columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Along with creating the `GridPane` instance, we are setting its layout properties,
    such as the alignment of `GridPane`, the horizontal and vertical spaces between
    the rows and columns, and the padding within each cell of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new label, which will show the name of our application, specifically, `Age
    calculator`, and add it to `gridPane`, which we created in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a label and a text input combination, which will be used for accepting
    the user''s name. Then add these two components to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a label and a date-picker combination, which will be used for accepting
    the user''s date of birth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a button, which will be used by the user to trigger the age calculation,
    and add it to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a component to hold the result of the computed age:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to bind an action to the button created in step 6\. The action
    will be to get the name entered in the name field and the date of birth entered
    in the date-picker field. If the date of birth is provided, then use the Java
    time APIs to compute the period between now and the date of birth. If there is
    a name provided, then prepend a greeting, `Hello, <name>`, to the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the `Scene` class by providing the `gridPane` object
    we created in step 2 and the dimensions, the width, and height of the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An instance of `Scene` holds the graph of the UI components, which is called
    a **scene graph**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen that the `start()` method provides us with a reference to a `Stage`
    object. The `Stage` object is the top-level container in JavaFX, something like
    a JFrame. We set the `Scene` object to the `Stage` object and use its `show()`
    method to render the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to launch this JavaFX UI from the main method. We use the `launch(String[]
    args)` method of the `Application` class to launch the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `Chapter16/1_create_javafx_gui`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two scripts, `run.bat` and `run.sh`, in `Chapter16/1_create_javafx_gui`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the GUI,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f78eab15-9491-41ba-b503-27def3e0c8e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the name and the date of birth and click on `Calculate` to view the age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f52396d1-5c74-462e-b2b4-4e265c7d99b6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going into the other details, let''s give you a brief overview of the
    JavaFX architecture. We have taken the following diagram describing the architecture
    stack from the JavaFX documentation ([http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm#JFXST788)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe62de47-1d02-4f31-afd7-e09bea089b5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start from the top of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The JavaFX APIs and Scene graph**: This is the starting point of the application,
    and most of our focus will be around this part. This provides APIs for different
    components, layout, and other utilities, to facilitate developing a JavaFX-based
    UI. The scene graph holds the visual elements of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prism, Quantum Toolkit, and the other stuff in blue**: These components manage
    the rendering of the UI and provide a bridge between the underlying operating
    system and JavaFX. This layer provides software rendering in cases where the graphics
    hardware is unable to provide hardware-accelerated rendering of rich UI and 3D
    elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Glass Windowing Toolkit**: This is the windowing toolkit, just like the
    AWT used by Swing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The media engine**: This supports media in JavaFX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The web engine**: This supports the web component, which allows complete
    HTML rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The JDK APIs and JVM**: These integrate with the Java API and compile the
    code down to bytecode to run on the JVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s get back to explaining the recipe. The `javafx.application.Application`
    class is the entry point for launching the JavaFX applications. It has the following
    methods that map to the life cycle of the application (in their invocation order):'
  prefs: []
  type: TYPE_NORMAL
- en: '**`init()`**: This method is invoked immediately after the instantiation of `javafx.application.Application`.
    You can override this method to do some initialization before the start of the
    application. By default, this method does nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start(javafx.stage.Stage)`: This method is called immediately after `init()`
    and after the system has done the required initialization to run the application.
    This method is passed with a `javafx.stage.Stage` instance, which is the primary
    stage on which the components are rendered. You can create other `javafx.stage.Stage`
    objects, but the one provided by the application is the primary stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`: This method is called when the application should stop. You can do
    the necessary exit-related operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *stage* is a top-level JavaFX container. The primary stage passed as an argument
    to the `start()` method is created by the platform, and the application can create
    other `Stage` containers as and when required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important method related to `javafx.application.Application` is the
    `launch()` method. There are two variants of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`launch(Class<? extends Application> appClass, String... args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch(String... args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is called from the main method, and should be called only once.
    The first variant takes the name of the class that extends the `javafx.application.Application`
    class along with the arguments passed to the main method, and the second variant
    doesn't take the name of the class and, instead, should be invoked from within
    the class that extends the `javafx.application.Application` class. In our recipe,
    we have made use of the second variant.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a class, `CreateGuiDemo`, extends `javafx.application.Application`.
    This will be the entry point for JavaFX UI, and we also added a main method to
    the class, making it an entry point for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A layout construct determines how your components are laid out. There are multiple
    layouts supported by JavaFX, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.HBox` and `javafx.scene.layout.VBox`: These are used to
    align the components horizontally and vertically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.BorderPane`: This allows the placing of the components
    in the top, right, bottom, left, and center positions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.FlowPane`: This layout allows the placing of the components
    in a flow, that is, besides each other, wrapping at the flow pane''s boundary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.GridPane`: This layout allows the placing of the components
    in a grid of rows and columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.StackPane`: This layout places the components in a back-to-front
    stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.layout.TilePane`: This layout places the components in a grid
    of uniformly sized tiles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our recipe, we have made use of `GridPane` and configured the layout so
    that we can achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The grid placed at the center (`gridPane.setAlignment(Pos.CENTER);`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the gap between the columns to 10 (`gridPane.setHgap(10);`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the gap between the rows to 10 (`gridPane.setVgap(10);`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the padding within the cell of the grid (`gridPane.setPadding(new Insets(25,
    25, 25, 25));`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `javafx.scene.text.Text` component's font can be set using the `javafx.scene.text.Font`
    object as shown here: `appTitle.setFont(Font.font("Arial", FontWeight.NORMAL,
    15));`
  prefs: []
  type: TYPE_NORMAL
- en: While adding the component to `javafx.scene.layout.GridPane`, we have to mention
    the column number, row number, and column span, that is, how many columns the
    component occupies, and the row span, that is, how many rows the component occupies
    in that order. The column span and the row span are optional. In our recipe, we
    have placed `appTitle` in the first row and column, and it occupies two column
    spaces and one-row space, as shown in the code here: `appTitle.setFont(Font.font("Arial",
    FontWeight.NORMAL, 15));`
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important part in this recipe is the setting of the event for the `ageCalculator`
    button. We make use of the `setOnAction()` method of the `javafx.scene.control.Button`
    class to set the action performed when the button is clicked. This accepts an
    implementation of the `javafx.event.EventHandler<ActionEvent>` interface. As `javafx.event.EventHandler`
    is a functional interface, its implementation can be written in the form of a
    lambda expression, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax looks similar to your anonymous inner classes widely used
    during the times of Swing. You can learn more about functional interfaces and
    lambda expressions in the recipes in Chapter 4, *Going Functional*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our event-handling code, we get the values from `nameField` and `dateOfBirthPicker` by
    using the `getText()` and `getValue()` methods respectively. `DatePicker` returns
    the date selected as an instance of `java.time.LocalDate`. This is one of the
    new date-time APIs added to Java 8\. It represents a date, that is, the year,
    the month, and the day, without any timezone-related information. We then make
    use of the `java.time.Period` class to find the duration between the current date
    and the selected date, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Period` represents the date-based duration in terms of years, months, and
    days, for example, three years, two months, and three days. This is exactly what
    we are trying to extract with this line of code: `String.format("Your age is %d
    years %d months %d days",  period.getYears(), period.getMonths(), period.getDays())`.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already mentioned that the UI components in JavaFX are represented in
    the form of a scene graph, and this scene graph is then rendered onto a container,
    called `Stage`*.* The way to create a scene graph is by using the `javafx.scene.Scene`
    class. We create a `javafx.scene.Scene` instance by passing the root of the scene
    graph and also by providing the dimensions of the container in which the scene
    graph is going to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make use of the container provided to the `start()` method, which is nothing
    but an instance of `javafx.stage.Stage`. Setting the scene for the `Stage` object
    and then calling its `show()` methods makes the complete scene graph rendered
    on the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the FXML markup to create a GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first recipe, we looked at using Java APIs to build a UI. It often happens
    that a person who is adept at Java might not be a good UI designer; that is, they
    may be poor at identifying the best user experience for their app. In the world
    of web development, we have developers working on the frontend, based on the designs
    given by the UX designer, and the other set of developers working on the backend,
    to build services that are consumed by the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Both developer parties agree to a set of APIs and a common data interchange
    model. Front-end developers work by using some mock data based on the data interchange
    model and also integrate the UI with the required APIs. On the other hand, backend
    developers work on implementing APIs so that they return the data in the interchange
    model agreed upon. So, both parties work simultaneously, using their expertise
    in their work areas.
  prefs: []
  type: TYPE_NORMAL
- en: It would be amazing if the same could be replicated (at least to some extent)
    on desktop applications. A step in this direction was the introduction of an XML-based
    language, called **FXML**. This enables a declarative method of UI development,
    where the developer can independently develop the UI using the same JavaFX components
    but available as XML tags. The different properties of the JavaFX components are
    available as attributes of the XML tags. Event handlers can be declared and defined
    in the Java code and then referred from FXML.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will guide you through building the UI using FXML and then
    integrating FXML with the Java code for binding the action and for launching the
    UI defined in the FXML.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onwards and Open JDK 10 onwards, we will have to download the JavaFX
    SDK from [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will develop a simple age calculator app. This app will ask for the user's
    name (which is optional) and their date of birth, and calculate the age from the
    given date of birth and display it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the FXML files should end with the `.fxml` extension. Let's create an empty `fxml_age_calc_gui.xml`
    file in the location `src/gui/com/packt`. In the subsequent steps, we will update
    this file with the XML tags for the JavaFX components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `GridPane` layout, which will hold all the components in a grid of
    rows and columns. We will also provide the required spacing between the rows and
    the columns using the `vgap` and `hgap` attributes. Also, we will provide `GridPane`,
    which is our root component, with the reference to the Java class, where we will
    add the required event handling. This Java class will be like the controller for
    the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will provide the padding within each cell of the grid by defining a `padding`
    tag with `Insets` within `GridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to add a `Text` tag, which displays the title of the application—`Age
    Calculator`. We provide the required style information in the `style` attribute
    and the placement of the `Text` component within `GridPane` using the `GridPane.columnIndex`
    and `GridPane.rowIndex` attributes. The cell occupancy information can be provided
    using the `GridPane.columnSpan` and `GridPane.rowSpan` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the `Label` and `TextField` components for accepting the name.
    Note the use of the `fx:id` attribute in `TextField`. This helps in binding this
    component in the Java controller by creating a field with the same name as that
    of the `fx:id` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `Label` and `DatePicker` components for accepting the date of birth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a `Button` object and set its `onAction` attribute to the name
    of the method in the Java controller that handles the click event of this button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add a `Text` component to display the calculated age:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the Java class, which is directly related to
    the XML-based UI components created in the preceding steps. Create a class named `FxmlController`.
    This will contain the code that is relevant to the FXML UI; that is, it will contain
    the references to the components created in the FXML action handlers for the components
    created in the FXML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We need references to the `nameField`, `dateOfBirthPicker`, and `resultText`
    components. We use the first two to get the entered name and date of birth, respectively,
    and the third to display the result of the age calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the `calculateAge` method, which is registered
    as the action event handler for the `Calculate` button. The implementation is
    similar to the one in the previous recipe. The only difference is that it is a
    method, unlike the previous recipe, where it was a lambda expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In both steps 10 and 11, we have used an annotation, `@FXML`. This annotation
    indicates that the class or the member is accessible to the FXML-based UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll create another Java class, `FxmlGuiDemo`, which is responsible
    for rendering the FXML-based UI and which would also be the entry point for launching
    the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create a scene graph from the FXML UI definition by overriding
    the `start(Stage stage)` method of the `javafx.application.Application` class and
    then render the scene graph within the passed `javafx.stage.Stage` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we provide the `main()` method implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at the location `Chapter16/2_fxml_gui`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two-run scripts, `run.bat` and `run.sh`, in `Chapter16/2_fxml_gui`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the GUI as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44729bd6-e935-48d0-bccc-d26e225c8469.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the name and the date of birth and click on `Calculate` to view the age:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7ef594d-c776-4d68-993e-5e94e3c657c2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no XSD defining the schema for the FXML document. So, to know the
    tags to be used, they follow a simple naming convention. The Java class name of
    the component is also the name of the XML tag. For example, the XML tag for the `javafx.scene.layout.GridPane`
    layout is `<GridPane>`, and for `javafx.scene.control.TextField` it is `<TextField>`,
    and for `javafx.scene.control.DatePicke` it is `<DatePicker>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code makes use of an instance of `javafx.fxml.FXMLLoader`
    to read the FXML file and get the Java representation of the UI components. `FXMLLoader`
    uses an event-based SAX parser to parse the FXML file. Instances of the respective
    Java classes for the XML tags are created via reflection, and the values of attributes
    of the XML tags are populated into the respective properties of the Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: As the root of our FXML is `javafx.scene.layout.GridPane`, which extends `javafx.scene.layout.Pane`,
    we can cast the return value from `FXMLoader.load()` to `javafx.scene.layout.Pane`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other interesting thing in this recipe is the `FxmlController` class. This
    class acts as an interface to FXML. We indicate the same in the FXML by using
    the `fx:controller` attribute to the `<GridPane>` tag. We can get hold of the
    UI components defined in FXML by using the `@FXML` annotation against the member
    fields of the `FxmlController` class, as we did in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the member is the same as that of the `fx:id` attribute value in
    FXML, and the type of the member is the same as that of the tag in FXML. For example,
    the first member is bound to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: On similar lines, we created an event handler in `FxmlController` and annotated
    it with `@FXML`, and the same has been referenced in FXML with the `onAction`
    attribute of `<Button>`. Note that we have added `#` to the beginning of the method
    name in the `onAction` attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS to the style elements in JavaFX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those from a web development background will be able to appreciate the usefulness
    of the **Cascading Style Sheets** (**CSS**), and for those who are not, we will
    provide an overview of what they are and how they are useful, before diving into
    CSS application in JavaFX.
  prefs: []
  type: TYPE_NORMAL
- en: The elements or the components that you see on web pages are often styled according
    to the theme of the website. This styling is made possible by using a language
    called **CSS**. CSS consists of a group of `name:value` pairs, separated by semicolons.
    These `name:value` pairs, when associated with an HTML element, say, `<button>`,
    give it the required styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to associate these `name:value` pairs to the element,
    the simplest being when you put this `name:value` pair within the style attribute
    of your HTML element. For example, to give the button a blue background, we can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are predefined names for different styling properties, and these take
    a specific set of values; that is, the property, `background-color`, will only
    take valid color values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other approach is to define these groups of `name:value` pairs in a different
    file with a `.css` extension. Let''s call this group of `name:value` pairs **CSS
    properties**. We can associate these CSS properties with different selectors,
    that is, selectors for choosing the elements on the HTML page to apply the CSS
    properties too. There are three different ways of providing the selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: By directly giving the name of the HTML element, that is, whether it is an anchor
    tag (`<a>`), button, or input. In such cases, the CSS properties are applied to
    all the types of HTML elements in the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By using the `id` attribute of the HTML element. Suppose, we have a button
    with `id="btn1"`, then we can define a selector, `#btn1`, against which we provide
    the CSS properties. Take a look at the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the class attribute of the HTML element. Suppose we have a button
    with `class="blue-btn"`, then we can define a selector, `.blue-btn`, against which
    we provide the CSS properties. Check out the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of using a different CSS file is that we can independently evolve
    the appearance of the web pages without getting tightly coupled to the location
    of the elements. Also, this encourages the reuse of CSS properties across different
    pages, thereby giving them a uniform look across all the pages.
  prefs: []
  type: TYPE_NORMAL
- en: When we apply a similar approach to JavaFX, we can leverage the CSS knowledge
    already available with our web designers to build CSS for JavaFX components, and
    this helps in styling the components more easily than with the use of Java APIs.
    When this CSS is mixed with FXML, then it becomes a known domain for web developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at styling a few JavaFX components using an external
    CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onwards and Open JDK 10 onwards, we will have to download the JavaFX
    SDK from [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There is a small difference in defining the CSS properties for the JavaFX components.
    All the properties must be prefixed with `-fx-`, that is, `background-color` becomes
    `-fx-background-color`. The selectors, that is, `#id` and `.class-name` still
    remain the same in the JavaFX world as well. We can even provide multiple classes
    to the JavaFX components, thereby applying all these CSS properties to the components.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS that I have used in this recipe is based on a popular CSS framework
    called **Bootstrap** ([http://getbootstrap.com/css/](http://getbootstrap.com/css/)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create `GridPane`, which will hold the components in a grid of rows
    and columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will create a button and add two classes, `btn`, and `btn-primary`,
    to it. In the next step, we will define these selectors with the required CSS
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s provide the required CSS properties for the classes, `btn` and `btn-primary`.
    The selector for the classes are of the form `.<class-name>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another button with a different CSS class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define the CSS properties for the `.btn-success` selector as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create yet another button with a different CSS class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the CSS properties for the selector `.btn-danger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some labels with different selectors, namely `badge` and `badge-info`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSS properties for the previous selectors are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add `TextField` with a `big-input` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We define CSS properties so that the content of the textbox is large in size
    and red in color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add some radio buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We define CSS properties so that the labels of the radio buttons are large
    in size and green in color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add `javafx.scene.layout.GridPane` to the scene graph and render
    the scene graph on `javafx.stage.Stage`. We also need to associate the `stylesheet.css`
    with the `Scene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `main()` method to launch the GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found here: `Chapter16/3_css_javafx`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/3_css_javafx`.
    The `run.bat` will be for running the application on Windows, and `run.sh` will
    be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa402889-ce42-4e51-9568-7c90a1ab4cf9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we make use of class names and their corresponding CSS selectors
    to associate components with different styling properties. JavaFX supports a subset
    of CSS properties, and there are different properties applicable to different
    types of JavaFX components. The JavaFX CSS reference guide ([http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html))
    will help you identify the supported CSS properties.
  prefs: []
  type: TYPE_NORMAL
- en: All the scene graph nodes extend from an abstract class, `javax.scene.Node`.
    This abstract class provides an API, `getStyleClass()`, that returns a list of
    class names (which are plain `String`) added to the node or to the JavaFX component.
    As this is a simple list of class names, we can even add more class names to it
    by using `getStyleClass().add("new-class-name")`.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using class names is that it allows us to group similar components
    by a common class name. This technique is widely used in the web development world.
    Suppose I have a list of buttons on the HTML page and I want a similar action
    to be performed on the click of each button. To achieve this, I will assign each
    of the buttons the same class, say, `my-button`, and then use `document.getElementsByClassName('my-button')`
    to get an array of these buttons. Now we can loop through the array of buttons
    obtained and add the required action handlers.
  prefs: []
  type: TYPE_NORMAL
- en: After assigning a class to the component, we need to write the CSS properties
    for the given class name. These properties then get applied to all the components
    with the same class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pick one of the components from our recipe and see how we went about
    styling it. Consider the following component with two classes, `btn` and `btn-primary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the selectors, `.btn` and `.btn-primary`, and we have grouped
    all the CSS properties under these selectors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in CSS, we have a `color` property, and its equivalent in JavaFX
    is `-fx-text-fill`. The rest of the CSS properties, namely `border-radius`, `border`,
    `font-size`, `font-weight`, `text-align`, `background-color`, and `border-color`,
    are prefixed with `-fx-`.
  prefs: []
  type: TYPE_NORMAL
- en: The important part is how you associate the style sheet with the `Scene` component.
  prefs: []
  type: TYPE_NORMAL
- en: The `scene.getStylesheets().add("com/packt/stylesheet.css");` line of code associates
    stylesheets with the scene component. As `getStylesheets()` returns a list of
    strings, we can add multiple strings to it, which means that we can associate
    multiple stylesheets to a Scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation of `getStylesheets()` states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The URL is a hierarchical URI of the form [scheme:][//authority][path]. If
    the URL does not have a [scheme:] component, the URL is considered to be the [path]
    component only. Any leading ''/'' character of the [path] is ignored and the [path]
    is treated as a path relative to the root of the application''s classpath."'
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, we are using the `path` component only, and hence it looks for
    the file in the classpath. This is the reason we have added the stylesheet to
    the same package as that of the scene. This is an easier way of making it available
    on the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bar chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data, when represented in the form of tables, is very hard to understand, but
    when data is represented graphically by using charts, it is comfortable for the
    eyes and easy to understand. We have seen a lot of charting libraries for web
    applications. However, the same support was lacking on the desktop application
    front. Swing didn't have native support for creating charts, and we had to rely
    on third-party applications such as **JFreeChart** ([http://www.jfree.org/jfreechart/](http://www.jfree.org/jfreechart/)).
    With JavaFX, though, we have native support for creating charts, and we are going
    to show you how to represent the data in the form of charts using the JavaFX chart
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaFX supports the following chart types:'
  prefs: []
  type: TYPE_NORMAL
- en: Bar chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next few recipes, we will cover the construction of each chart type.
    The segregation of each chart type into a recipe of its own will help us in explaining
    the recipes in a simpler way and will aid better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe will be all about bar charts. A sample bar chart looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07097a6b-2eb0-4075-a3d1-b4e10a38f206.png)'
  prefs: []
  type: TYPE_IMG
- en: Bar charts can have a single bar or multiple bars (as in the preceding diagram)
    for each value on the *x *axis. Multiple bars help us in comparing multiple value
    points for each value on the *x *axis.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onwards and Open JDK 10 onwards, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We will make use of a subset of data from the student performance machine learning
    repository ([https://archive.ics.uci.edu/ml/datasets/Student+Performance](https://archive.ics.uci.edu/ml/datasets/Student+Performance)).
    The dataset consists of student performance in two subjects, Mathematics and Portuguese,
    along with their social background information, such as their parents'' occupations
    and education, among other information. There are quite a lot of attributes in
    the dataset, but we will pick the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Student's gender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Student's age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Father's education
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Father's occupation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mother's education
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mother's occupation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the student has taken extra classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-term grades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second-term grades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final grades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, there are a lot of attributes captured in the data,
    but we should be good with a few important attributes that will help us plot some
    useful charts. Due to this, we have extracted the information from the dataset
    available in the machine learning repository into a separate file, which can be
    found at `Chapter16/4_bar_charts/src/gui/com/packt/students`, in the code download
    for the book. An excerpt from the students file follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The entries are separated by semicolons (`;`). Each entry has been explained
    for what it represents. The education information (fields 3 and 4) is a numeric
    value, where each number represents the level of education, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: Primary education (fourth grade)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: Fifth to ninth grade'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: Secondary education'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`: Higher education'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created a module for processing the student file. The module name is
    `student.processor` and its code can be found at `Chapter16/101_student_data_processor`.
    So, if you want to change any code there, you can rebuild the JAR by running the
    `build-jar.bat` or `build-jar.sh` file. This will create a modular JAR, `student.processor.jar`,
    in the `mlib` directory. Then, you have to replace this modular JAR with the one
    present in the `mlib` directory of this recipe, that is, `Chapter16/4_bar_charts/mlib`.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you build the `student.processor` modular jar from the source
    available in `Chapter16/101_student_data_processor`. We have provided `build-jar.bat`
    and `build-jar.sh` scripts to help you build the JAR. You just have to run the
    script relevant to your platform and then copy the jar build in `101_student_data_processor/mlib`
    to `4_bar_charts/mlib`.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can reuse this module across all the recipes involving charts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, create `GridPane` and configure it to place the charts that we will
    be creating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `StudentDataProcessor` class from the `student.processor` module to
    parse the student file and load the data into `List` of `Student`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw data, that is, the list of `Student` objects, is not useful for plotting
    a chart, so we need to process the students'' grades by grouping the students
    according to their mothers'' and fathers'' education and computing the average
    of those students'' grades (all three terms). For this, we will write a simple
    method that accepts `List<Student>`, a grouping function, that is, the value on
    which the students need to be grouped, and a mapping function, that is, the value
    that has to be used to compute the average:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method uses the new Stream-based APIs. These APIs are so powerful
    that they group the students by using `Collectors.groupingBy()` and then compute
    the statistics of their grades by using `Collectors.summarizingInt()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data for the bar chart is provided as an instance of `XYChart.Series`.
    Each series results in one *y* value for a given *x* value, which is one bar for
    a given *x* value. We will have multiple series, one for each term, that is, first-term
    grades, second-term grades, and the final grades. Let''s create a method that
    takes in the statistics of each term grades and the `seriesName` and returns a
    `series` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create two bar charts—one for the average grade from the mother''s
    education and the other for the average grade from the father''s education. For
    this, we will create a method that will take `List<Student>` and a classifier,
    that is, a function that will return the value to be used to group the students.
    This method will do the necessary computations and return a `BarChart` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `BarChart` for the average grades from the mother''s education, and
    add it to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `BarChart` for the average grades from the father''s education and add
    it to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a scene graph using `gridPane` and set it to `Stage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `Chapter16/4_bar_charts`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts: `run.bat` and `run.sh`, under `Chapter16/4_bar_charts`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68ae46d4-b460-449d-9774-a2e18a499c33.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first see what it takes to create `BarChart`. `BarChart` is a two axes-based
    chart, where the data is plotted on two axes, namely the *x* axis (horizontal
    axis) and the *y* axis (vertical axis). The other two axes-based charts are area
    chart, bubble chart, and line chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaFX, there are two types of axes supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.scene.chart.CategoryAxis`: This supports string values on the axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.chart.NumberAxis`: This supports numeric values on the axes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our recipe, we created `BarChart` with `CategoryAxis` as the *x* axis, where
    we plot the education, and `NumberAxis` as the *y* axis, where we plot the grade,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the next few paragraphs, we show you how the plotting of `BarChart` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data to be plotted on `BarChart` should be a pair of values, where each
    pair represents *(x, y)* values, that is, a point on the *x* axis and a point
    on the *y* axis. This pair of values is represented by `javafx.scene.chart.XYChart.Data`.
    `Data` is a nested class within `XYChart`, which represents a single data item
    for a two axes-based chart. An `XYChart.Data` object can be created quite simply,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a one-data item. A chart can have multiple data items, that is,
    a series of data items. To represent a series of data items, JavaFX provides a
    class called `javafx.scene.chart.XYChart.Series`. This `XYChart.Series` object
    is a named series of `XYChart.Data` items. Let''s create a simple series, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '`BarChart` can have multiple series of data items. If we provide it with multiple
    series, then there will be multiple bars for each data point on the *x* axis.
    For our demonstration of how this works, we will stick with one series. But the
    `BarChart` class in our recipe uses multiple series. Let''s add the series to
    the `BarChart` and then render it onto the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2a1490f-110f-4139-aac4-6685cced09c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The other interesting part of this recipe is the grouping of students based
    on the education of the mother and father and then computing the average of their
    first-term, second-term, and final grades. The code that does the grouping and
    average computation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a stream from `List<Student>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reduces this stream to the required grouping by using the `collect()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the overloaded versions of `collect()` takes two parameters. The first
    one is the function that returns the value on which the students need to be grouped.
    The second parameter is an additional mapping function, which maps the grouped
    student object into the required format. In our case, the required format is to
    get `IntSummaryStatistics` for the group of students on any of their grade values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding two pieces (setting up the data for a bar chart and creating the
    required objects to populate a `BarChart` instance) are important parts of the
    recipe; understanding them will give you a clearer picture of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pie chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pie charts, as the name suggests, are circular charts with slices (either joined
    or separated), where each slice and its size indicates the magnitude of the item
    that the slice represents. Pie charts are used to compare the magnitudes of different
    classes, categories, products, and the like. This is how a sample pie chart looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e42a09ae-bc16-4a33-909c-6c55a4522f70.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onwards and Open JDK 10 onwards, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) [and
    include the JARs present in the SDK's `lib` folder on the modular path using the
    `-p` option, as shown here:](https://gluonhq.com/products/javafx/)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We will make use of the same student data (taken from the machine learning repository and
    processed at our end) that we had discussed in the recipe, *Creating a bar chart*
    recipe. For this, we have created a module, `student.processor`, which will read
    the student data and provide us with a list of `Student` objects. The source code
    for the module can be found at `Chapter16/101_student_data_processor`. We have
    provided the modular jar for the `student.processor` module at `Chapter16/5_pie_charts/mlib`
    of this recipe's code.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend you to build the `student.processor` modular jar from the source
    available in `Chapter16/101_student_data_processor`. We have provided `build-jar.bat`
    and `build-jar.sh` scripts to help you with building the jar. You just have to
    run the script relevant to your platform and then copy the jar build in `101_student_data_processor/mlib`
    to `4_bar_charts/mlib`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create and configure `GridPane` to hold our pie charts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of `StudentDataProcessor` (which comes from the `student.processor` module)
    and use it to load `List` of `Student`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to get the count of students by their mothers'' and fathers'' professions.
    We will write a method that will take a list of students and a classifier, that
    is, the function that returns the value on which the students need to be grouped.
    The method returns an instance of `PieChart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We will invoke the preceding method twice—one with the mother''s occupation
    as the classifier and the other with the father''s occupation as the classifier.
    We then add the returned `PieChart` instance to `gridPane`. This should be done
    from within the `start()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the scene graph using `gridPane` and add it to `Stage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI can be launched from the main method by invoking the `Application.launch`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `Chapter16/5_pie_charts`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/5_pie_charts`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fcb686c-5890-47b5-8e73-05d663f16210.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important method which does all the work in this recipe is `getStudentCountByOccupation()`.
    It does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It groups the number of students by profession. This can be done in a single
    line of code using the power of the new streaming APIs (added as part of Java
    8):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Build data required for `PieChart`. The `PieChart` instance''s data is `ObservableList`
    of `PieChart.Data`. We first make use of `Map` obtained in the preceding step
    to create `ArrayList` of `PieChart.Data`. Then, we use the `FXCollections.observableList()`
    API to obtain `ObservableList<PieChart.Data>` from `List<PieChart.Data>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The other important thing in the recipe is the classifiers we use: `Student::getMotherJob`
    and `Student::getFatherJob`. These are the two method references that invoke the `getMotherJob`
    and `getFatherJob` methods on the different instances of `Student` in the list
    of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get the `PieChart` instances, we add them to `GridPane` and then construct
    the scene graph using `GridPane`. The scene graph has to be associated with `Stage`
    for it to be rendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The main method launches the UI by invoking the `Application.launch(args);`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaFX provides APIs for creating different types of charts, such as the following
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Area charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these charts are *x* and *y* axis-based charts and can be constructed
    like a bar chart. We have provided some sample implementations to create these
    types of charts, and they can be found at these locations: `Chapter16/5_2_area_charts`,
    `Chapter16/5_3_line_charts`, `Chapter16/5_4_bubble_charts`, and `Chapter16/5_5_scatter_charts`.'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding HTML in an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaFX provides support for managing web pages via the classes defined in the `javafx.scene.web`
    package. It supports loading the web page, either by accepting the web page URL
    or by accepting the web page content. It also manages the document model of the
    web page, applies the relevant CSS, and runs the relevant JavaScript code. It
    also extends support for a two-way communication between JavaScript and the Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will build a very primitive and simple web browser that
    supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through the history of the pages visited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reloading the current page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An address bar for accepting the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button for loading the entered URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the status of loading of the web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onward and Open JDK 10 onward, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We will require an internet connection to test the loading of pages. So, make
    sure you are connected to the internet. Apart from this, there is nothing specific
    required to work with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In the subsequent steps, we will write all our code within the `start(Stage
    stage)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `javafx.scene.web.WebView` component, which will render our
    web page. This has the required `javafx.scene.web.WebEngine` instance, which manages
    the loading of the web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the instance of `javafx.scene.web.WebEngine` used by `webView`. We will
    use this instance of `javafx.scene.web.WebEngine` to navigate through the history
    and load other web pages. Then we will, by default, load the URL, [http://www.google.com](http://www.google.com):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a `javafx.scene.control.TextField` component, which will
    act as our browser''s address bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to change the title of the browser and the web page in the address
    bar, based on the title and URL of the completely loaded web page. This can be
    done by listening to the change in the `stateProperty` of `javafx.concurrent.Worker`
    obtained from the `javafx.scene.web.WebEngine` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, upon clicking,
    will load the web page identified by the URL entered in the address bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, upon clicking,
    will go to the previous web page in the history. To achieve this, we will execute
    the JavaScript code, `history.back()`, from within the action handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `javafx.scene.control.Button` instance, which, upon clicking,
    will go to the next entry in the history maintained by `javafx.scene.web.WebEngine`
    instance. For this, we will make use of the `javafx.scene.web.WebHistory` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the button for reloading the current page. Again, we will make use
    of `javafx.scene.web.WebEngine` to reload the current page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to group all the components created so far, namely, `prevButton`, `nextButton`,
    `reloadButton`, `webAddress`, and `goButton`, so that they align horizontally
    with one another. To achieve this, we will make use of `javafx.scene.layout.HBox`
    with relevant spacing and padding to make the components look well spaced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We would want to know whether the web page is loading and whether it has finished.
    Let''s create a `javafx.scene.layout.Label` field to update the status if the
    web page is loaded. Then, we listen to the updates to `workDoneProperty` of the
    `javafx.concurrent.Worker` instance, which we can get from the `javafx.scene.web.WebEngine`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s align the entire address bar (with its navigation buttons), `webView`,
    and `websiteLoadingStatus` vertically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Scene` object with the `VBox` instance created in the preceding
    step as the root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the `javafx.stage.Stage` instance to occupy the complete screen size;
    for this, we will make use of `Screen.getPrimary().getVisualBounds()`. Then, as
    usual, we will render the scene graph on the stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at the location, `Chapter16/6_embed_html`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/6_embed_html`.
    The `run.bat` script will be for running the application on Windows, and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be7f6c16-0275-4ca8-99b7-b11ec644d75d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The web-related APIs are available in the `javafx.web` module, so we will have
    to require it in `module-info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the important classes in the `javafx.scene.` web package
    when dealing with web pages in JavaFX:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WebView`: This UI component uses `WebEngine` to manage the loading, rendering,
    and interaction with the web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebEngine`: This is the main component that deals with loading and managing
    the web page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebHistory`: This records the web pages visited in the current `WebEngine`
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebEvent`: These are the instances passed to the event handlers of `WebEngine` invoked
    by the JavaScript event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our recipe, we make use of the first three classes.
  prefs: []
  type: TYPE_NORMAL
- en: We don't directly create an instance of `WebEngine`; instead, we make use of
    `WebView` to get a reference to the `WebEngine` instance managed by it. The `WebEngine` instance
    loads the web page asynchronously by submitting the task of loading the page to
    `javafx.concurrent.Worker` instances. Then, we register change listeners on these
    worker instance properties to track the progress of loading the web page. We have
    made use of two such properties in this recipe, namely, `stateProperty` and `workDoneProperty`.
    The former tracks the change of the state of the worker, and the latter tracks
    the percentage of the work done.
  prefs: []
  type: TYPE_NORMAL
- en: 'A worker can go through the following states (as listed in the `javafx.concurrent.Worker.State`
    enum):'
  prefs: []
  type: TYPE_NORMAL
- en: '`CANCELLED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FAILED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNNING`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCHEDULED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUCCEEDED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our recipe, we are only checking for `SUCCEEDED`, but you can enhance it
    to check for `FAILED` as well. This will help us report invalid URLs or even get
    the message from the event object and show it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we add the listeners to track the change in the properties is by using
    the `addListener()` method on `*Property()`, where `*` can be `state`, `workDone`,
    or any other attribute of the worker that has been exposed as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `javafx.scene.web.WebEngine` component also supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reloading the current page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the history of the pages loaded by it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to JavaScript properties, such as showing an alert box or a confirmation
    box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the document model of the web page using the `getDocument()`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we also looked at using `WebHistory` obtained from `WebEngine`.
    `WebHistory` stores the web pages loaded by the given `WebEngine` instance, which
    means one `WebEngine` instance will have one `WebHistory` instance. `WebHistory`
    supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the list of entries by using the `getEntries()` method. This will also
    get us the number of entries in the history. This is required while navigating
    forward and backward in history; otherwise, we will end up with an index out of
    bounds exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting `currentIndex`, that is, its index within the `getEntries()` list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to the specific entry in the entries list of `WebHistory`. This can
    be achieved by using the `go()` method, which accepts an offset. This offset indicates
    which web page to load, relative to the current position. For example, *+1* indicates
    the next entry, and *-1* indicates the previous entry. It's important to check
    for the boundary conditions; otherwise, you will end up going before *0*, that
    is, *-1*, or going past the entry list size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we showed you a basic approach to creating a web browser, using
    the support provided by JavaFX. You can enhance this to support the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Better error handling and user messages, that is, to show whether the web address
    is valid by tracking the state change of the worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bookmarking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the state of the browser locally so that the next time it is run it
    loads all the bookmarks and the history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding media in an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaFX provides a component, `javafx.scene.media.MediaView`, for viewing videos
    and listening to audios. This component is backed by a media engine, `javafx.scene.media.MediaPlayer`,
    which loads and manages the playback of the media.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at playing a sample video and controlling its playback
    by using the methods on the media engine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onward and Open JDK 10 onward, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We will make use of the sample video available at `Chapter16/7_embed_audio_video/sample_video1.mp4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `javafx.scene.media.Media` object for the video located at `Chapter16/7_embed_audio_video/sample_video1.mp4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new media engine,  `javafx.scene.media.MediaPlayer`, using the `javafx.scene.media.Media`
    object created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s track the status of the media player by registering a change listener
    on `statusProperty` of the `javafx.scene.media.MediaPlayer` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a media viewer using the media engine created in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We will restrict the width and height of the media viewer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create three buttons to pause the video playback, resume the playback,
    and stop the playback. We will make use of the relevant methods in the `javafx.scene.media.MediaPlayer`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Align all these buttons horizontally using `javafx.scene.layout.HBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Align the media viewer and the buttons bar vertically using `javafx.scene.layout.VBox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new scene graph using the `VBox` object as the root and set it to
    the stage object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Render the stage on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `Chapter16/7_embed_audio_video`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/7_embed_audio_video`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh`, and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba1e14aa-5eca-4fd3-b6f1-eea3e18edad4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The important classes, in the `javafx.scene.media` package for media playback
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Media`: This represents the source of the media, that is, either video or
    audio. This accepts the source in the form of HTTP/HTTPS/FILE and JAR URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MediaPlayer`: This manages the playback of the media.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MediaView`: This is the UI component that allows viewing the media.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few other classes, but we haven''t covered them in this recipe.
    The media-related classes are in the `javafx.media` module. So, do not forget
    to require a dependency on it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we have a sample video at `Chapter16/7_embed_audio_video/sample_video1.mp4`,
    and we make use of the `java.io.File` API to build `File` URL to locate the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The media playback is managed by using the API exposed by the `javafx.scene.media.MediaPlayer`
    class. In this recipe, we made use of a few of its methods, namely `play()`, `pause()`,
    and `stop()`. The `javafx.scene.media.MediaPlayer` class is initialized by using
    the `javafx.scene.media.Media` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering the media on the UI is managed by the `javafx.scene.media.MediaView` class,
    and it is backed by a `javafx.scene.media.MediaPlayer` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: We can set the height and width of the viewer by using the `setFitWidth()` and
    `setFitHeight()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We gave a basic demo of media support in JavaFX. There's a lot more to explore.
    You can add volume control options, options to seek forward or backward, play
    audios, and audio equalizer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding effects to controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding effects in a controlled way gives a good appearance to the user interface.
    There are multiple effects such as blurring, shadows, reflection, blooming, and
    so on. JavaFX provides a set of classes under the `javafx.scene.effects` package,
    which can be used to add effects to enhance the look of the application. This
    package is available in the `javafx.graphics` module.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at a few effects—blur, shadow, and reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onward and Open JDK 10 onward, we will have to download the JavaFX
    SDK from here [https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/) and
    include the JARs present in the SDK''s `lib` folder on the modular path using
    the `-p` option shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a class with empty methods, which would represent the main
    application for launching the application as well as the JavaFX UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The subsequent code will be written within the `start(Stage stage)` method.
    Create and configure `javafx.scene.layout.GridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Create rectangles required for applying the blur effects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `javafx.scene.effect.BoxBlur` to `Rectangle r1`, `javafx.scene.effect.MotionBlur`
    to `Rectangle r2`, and `javafx.scene.effect.GaussianBlur` to `Rectangle r3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the rectangles to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three circles, required for applying shadows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `javafx.scene.effect.DropShadow` to `c1` and `javafx.scene.effect.InnerShadow`
    to `c2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these circles to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a simple text, `Reflection Sample`, on which we will apply the reflection
    effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `javafx.scene.effect.Reflection` effect and add it to the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the text component to `gridPane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a scene graph using `gridPane` as the root node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the scene graph to the stage and render it on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The complete code can be found at `Chapter16/8_effects_demo`.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided two run scripts, `run.bat` and `run.sh`, under `Chapter16/8_effects_demo`.
    The `run.bat` script will be for running the application on Windows and `run.sh`
    will be for running the application on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `run.bat` or `run.sh` and you will see the following
    GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b86be218-5d25-4a77-ae37-be9a25ee8b56.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we have made use of the following effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.BoxBlur`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.MotionBlur`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.GaussianBlur`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.DropShadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.InnerShadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx.scene.effect.Reflection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `BoxBlur` effect is created by specifying the width and height of the blur
    effect, and also the number of times the effect needs to be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MotionBlur` effect is created by providing the angle of the blur and its
    radius. This gives an effect of something captured while in motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GaussianBlur` effect is created by providing the radius of the effect,
    and the effect uses the Gaussian formula to apply the effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '`DropShadow` adds the shadow behind the object, whereas `InnerShadow` adds
    the shadow within the object. Each of these takes the radius of the shadow, the
    *x* and *y* location of the start of the shadow, and the color of the shadow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '`Reflection` is a pretty simple effect that adds the reflection of the object.
    We can set the fraction of how much of the original object is reflected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are quite a few more effects:'
  prefs: []
  type: TYPE_NORMAL
- en: The blend effect, which blends two different inputs with a predefined blending
    approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bloom effect, which makes the brighter portions appear brighter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The glow effect, which makes the object glow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lighting effect, which simulates a light source on the object, thereby giving
    it a 3D appearance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We would recommend that you try out these effects in the same way as we have
    tried them out.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Robot API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Robot API** is used to simulate keyboard and mouse actions on the screen,
    which means you would instruct the code to type some text in the text field, choose
    an option, and then click on a button. People coming from the Web UI-testing background
    can relate this to the Selenium Testing Library. **Abstract Window Toolkit** (**AWT**),
    which is an older windowing toolkit in JDK, provides Robot API, but using the
    same API on JavaFX is not straightforward and requires some hacks. The JavaFX
    window toolkit called **Glass** has its own Robot APIs ([https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/robot/Robot.html](https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/robot/Robot.html)),
    but these are not public. So, as part of the OpenJFX 11 release, new public APIs
    were introduced for the same.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at using the Robot API to simulate some actions
    on JavaFX UI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know that JavaFX libraries are not shipped in the JDK installation from
    Oracle JDK 11 onward and Open JDK 10 onward, we will have to download the JavaFX
    SDK from here ([https://gluonhq.com/products/javafx/](https://gluonhq.com/products/javafx/))
    and include the JARs present in the SDK''s `lib` folder on the modular path, using
    the `-p` option, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we will create a simple application that accepts a name from
    the user and, on clicking a button, prints a message to the user. This entire
    operation will be simulated using the Robot API, and, finally, before exiting
    the application, we will capture the screen using the Robot API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a simple class, `RobotApplication` that extends `javafx.application.Application`
    and sets up the UI required for testing the Robot API and also creates an instance
    of `javafx.scene.robot.Robot`. This class will be defined as a static inner class
    to the `RobotAPIDemo` main class :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'As the JavaFX UI will be launched in a different JavaFX application thread
    and there will be some delays in rendering the UI completely before we execute
    the commands to interact with the UI, we will make use of `java.util.concurrent.CountDownLatch`
    to indicate different events. To work with `CountDownLatch`, we create a simple
    static helper method with the following definition in the `RobotAPIDemo` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeName()` method is the helper method that types the name of the person
    in the text field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clickButton()` method is the helper method; it clicks on the correct button
    to trigger the greeting message display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The `captureScreen()` method is the helper method to take a screenshot of the
    application and save it to the filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'We will bind the launching of the UI and the created helper methods in the
    `main()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code for this can be found at `Chapter16/9_robot_api`. You can
    run the sample either by using `run.bat` or `run.sh`. Running the application
    will launch the UI, execute the actions, take a screenshot, and exit the app.
    The screenshot will be placed in the folder from which the application was launched,
    and it would follow the naming convention—`screenCapture-yyyy-dd-M-m-H-ss.png`.
    Here is a sample screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e02b304-5a14-4fe8-805f-d3d9265cada7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As JavaFX application is run in a different thread, we need to ensure that
    the operations of the Robot API are ordered correctly and the actions of the Robot
    API are executed only when the complete UI has been displayed. To ensure this,
    we have made use of `java.util.concurrent.CountDownLatch` to communicate about
    events such as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Complete loading of the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completion of the execution of the action defined for the button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The communication about the completion of the loading of the UI is achieved
    by using a `CountDownLatch`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The `countDown()` method is invoked in the `Stage` event handler when the window
    is shown thereby releasing the latch and triggering the execution of the following
    block of code in the main method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The main thread then again gets blocked from waiting for the `btnActionLatch`
    to be released. The `btnActionLatch` is released after the completion of the action
    in the button greeting. Once the `btnActionLatch` is released, the main thread
    continues execution to invoke the `captureScreen()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss some of the methods we have used from the `javafx.scene.robot.Robot`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mouseMove()`: This method is used to move the mouse cursor to a given location
    identified from its *x* and *y* co-ordinates. We have used the following line
    of code to get the bounds of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The bounds of a component contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The upper-left *x* and *y* coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lower-right *x* and *y* coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The width and the height of the component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, for our Robot API use case, we make use of the upper-left *x* and *y* coordinates,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '`mouseClick()`: This method is used to click the buttons on the mouse. The
    mouse buttons are identified by the following `enums` in `javafx.scene.input.MouseButton`
    enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PRIMARY`: Represents the mouse''s left click'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECONDARY`: Represents the mouse''s right click'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MIDDLE`: Represents the mouse''s scroll, or the middle, button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, to be able to use `mouseClick()`, we need to move the location of the component
    on which we need to perform the click operation. In our case, as seen in the implementation
    of the method `typeName()`, we move to the location of the text field using `mouseMove()`
    and then invoke the `mouseClick()`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '`keyType()`: This method is used to type characters into components that accept
    text input. The characters to be typed are represented by the enums in the `javafx.scene.input.KeyCode`
    enum. In our `typeName()` method implementation, we type the string `Sanaulla`, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '`getScreenCapture()`: This method is used to take the screenshot of the application.
    The area for capturing the screenshot is determined by the *x* and *y* coordinates
    and the width and the height information passed to the method. The image captured
    is then converted to `java.awt.image.BufferedImage` and saved onto the file system,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
