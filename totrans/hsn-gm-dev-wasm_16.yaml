- en: Debugging and Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和优化
- en: In this final chapter, we are going to discuss two topics that will be helpful
    as you go on to create games using Emscripten and build in WebAssembly. We are
    going to discuss the topics of debugging and optimization. We will debug before
    optimizing, because building your code to output more debuging information prevents
    optimization. We will start by using some basic debugging techniques, such as
    printing a stack trace and defining debug macros that we can remove by changing
    a compile flag. We will then move on to some more advanced debugging techniques,
    such as compiling with Emscripten flags, which allow us to trace through our code
    in Firefox and Chrome. We will also discuss some of the differences between debugging
    using the Firefox and Chrome developer tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们将讨论两个话题，这些话题将有助于您继续使用Emscripten创建游戏并构建WebAssembly。我们将讨论调试和优化的话题。我们将在优化之前进行调试，因为构建代码以输出更多调试信息会阻止优化。我们将从一些基本的调试技术开始，比如打印堆栈跟踪和定义调试宏，我们可以通过更改编译标志来删除。然后，我们将转向一些更高级的调试技术，比如使用Emscripten标志进行编译，这允许我们在Firefox和Chrome中跟踪代码。我们还将讨论使用Firefox和Chrome开发者工具进行调试的一些区别。
- en: 'You will need to include several images in your build to make this project
    work. Make sure that you include the `/Chapter16/sprites/` folder from this project''s
    GitHub repository. If you haven''t downloaded the GitHub project yet, you can
    get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像才能使此项目正常工作。确保您从该项目的GitHub存储库中包含`/Chapter16/sprites/`文件夹。如果您还没有下载GitHub项目，可以在这里在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: After we have finished discussing debugging, we will move on to optimization.
    We will discuss the optimization flags you can use with Emscripten, as well as
    the use of profilers to determine where your game or app may be having performance
    issues. We will discuss general techniques for optimizing your code for WebAssembly
    deployment. Finally, we will discuss optimizations related to web games and WebGL
    calls made by the WebAssembly module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论调试结束后，我们将转向优化。我们将讨论您可以在Emscripten中使用的优化标志，以及使用性能分析器来确定您的游戏或应用可能存在性能问题的位置。我们将讨论优化代码以进行WebAssembly部署的一般技术。最后，我们将讨论与Web游戏和WebAssembly模块发出的WebGL调用相关的优化。
- en: Debug macro and stack trace
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试宏和堆栈跟踪
- en: 'One way you can start debugging your code is by using `#define` to create a
    debugging macro, which we can activate by passing a flag into the Emscripten compiler.
    However, this will resolve to nothing if we don''t pass that flag. Macros are
    easy to add, and we can create a call that prints a line if we are running with
    our debug flag, but will not slow down performance if we aren''t. If you are not
    familiar with preprocessor commands, they are commands that are issued to the
    compiler that evaluate while the code is compiled instead of at runtime. For instance,
    if I used a `#ifdef PRINT_ME` command, the line of code would only be compiled
    into our source code if the `PRINT_ME` macro is defined either with a `#define
    PRINT_ME` macro on a line earlier in the code, or if we compiled the source with
    the `-DPRINT_ME` flag passed into the compiler when we ran the compiler. Let''s
    say we had the following block of code in our `main` function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 调试代码的一种方法是使用`#define`创建调试宏，我们可以通过将标志传递给Emscripten编译器来激活它。但是，如果我们不传递该标志，这将解析为空。宏很容易添加，我们可以创建一个调用，如果我们使用调试标志运行，它将打印一行，但如果我们不运行，它不会减慢性能。如果您不熟悉预处理器命令，它们是在代码编译时而不是在运行时评估的命令。例如，如果我使用了`#ifdef
    PRINT_ME`命令，只有在我们的源代码中定义了`PRINT_ME`宏时，才会将该行代码编译到我们的源代码中，或者如果我们在运行编译器时传递了`-DPRINT_ME`标志。假设我们在`main`函数中有以下代码块：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we did, we would have compiled and ran that code. The web browser''s console
    prints the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做了，我们将编译并运行该代码。Web浏览器的控制台将打印以下内容：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we compiled it with the `-DPRINT_ME` flag and then ran the code at the command
    line, we would see the following printed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`-DPRINT_ME`标志进行编译，然后在命令行上运行代码，我们将看到以下内容被打印出来：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you disassembled the code into WebAssembly text, then you wouldn't see any
    hint of the original `printf` statement that printed "nothing was defined". At
    compile time, the code is removed. This makes preprocessor macros very useful
    when creating code that we want to include during the development phase.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将代码反汇编为WebAssembly文本，那么您将看不到最初打印“未定义任何内容”的`printf`语句的任何迹象。在编译时，代码被移除。这使得预处理宏在创建我们希望在开发阶段包含的代码时非常有用。
- en: If you are using the `-D` flag to include debug macros in your code, make sure
    that you don't include that flag when you are compiling for release, as that will
    continue to include all of your debug macros when you don't want them. You may
    want to consider having a `-DRELEASE` flag that overrides your `-DDEBUG` flag
    when you compile your code for general release.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用`-D`标志在代码中包含调试宏，请确保在编译发布时不要包含该标志，因为这将在您不想要它们的情况下继续包含所有调试宏。您可能需要考虑在为一般发布编译代码时，使用`-DRELEASE`标志来覆盖您的`-DDEBUG`标志。
- en: 'Keeping all of your `printf` calls confined to a macro is a good way to make
    sure you removed all the calls to `printf` that will slow down your app when you
    publish it. Let''s try this out by starting with the `webgl-redux.c` file as a
    baseline. From the code we created in the previous chapter, copy and paste `webgl-redux.c`
    into a file called `debug.cpp`. We will add our debug macro at the beginning of
    this file. Immediately after the line that includes `emscripten.h`, but before
    the line of code that defines the canvas width, add the following block of code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有的`printf`调用限制在一个宏中是确保在发布应用时删除所有会减慢应用速度的`printf`调用的好方法。让我们通过以`webgl-redux.c`文件作为基准开始尝试一下。从我们在上一章中创建的代码中，将`webgl-redux.c`复制并粘贴到一个名为`debug.cpp`的文件中。我们将在这个文件的开头添加我们的调试宏。在包含`emscripten.h`的行之后，但在定义画布宽度的代码行之前，添加以下代码块：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code will only compile the `run_debug` function if we pass the `-DDEBUG`
    flag to the compiler. The user shouldn''t run the `run_debug` function directly,
    because it will not exist if we don''t use the `-DDEBUG` flag. Instead, we should
    use the `DBG` macro function. This macro exists regardless of whether we use the
    `-DDEBUG` flag. If we use this flag, the function calls the `run_debug` function.
    If we don''t use this flag, the calls to `DBG` magically disappear. The `run_debug`
    function not only uses `printf` to print out a string, but also uses `EM_ASM`
    to dump a stack trace to the JavaScript console. A stack trace logs out every
    function that is currently on the JavaScript stack. Let''s add a few function
    calls that will eventually call our `DBG` macro. These should be added immediately
    before the `main` function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向编译器传递`-DDEBUG`标志，这段代码将只编译`run_debug`函数。用户不应直接运行`run_debug`函数，因为如果我们不使用`-DDEBUG`标志，它将不存在。相反，我们应该使用`DBG`宏函数。无论我们是否使用`-DDEBUG`标志，这个宏都存在。如果我们使用这个标志，该函数调用`run_debug`函数。如果我们不使用这个标志，对`DBG`的调用会神奇地消失。`run_debug`函数不仅使用`printf`打印字符串，还使用`EM_ASM`将堆栈跟踪转储到JavaScript控制台。堆栈跟踪记录当前在JavaScript堆栈上的每个函数。让我们添加一些最终会调用我们的`DBG`宏的函数调用。这些应该在`main`函数之前立即添加：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside our `main` function, we should add a call to `inner_call_3()`, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数内，我们应该添加对`inner_call_3()`的调用，如下所示：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s compile our `debug.cpp` file with the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令编译我们的`debug.cpp`文件：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This compiles the `debug.cpp` file into an `index.html` file. If we serve that
    file from a web server and open it in a browser, we will see the following in
    our JavaScript console:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`debug.cpp`文件编译成一个`index.html`文件。如果我们从Web服务器提供该文件并在浏览器中打开它，我们将在JavaScript控制台中看到以下内容：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will notice that we have a stack trace, followed by our message, `check
    console log for stack trace`, which was the string we passed into the `DBG` macro.
    One thing you may notice if you look carefully is that this stack trace is not
    very helpful. Most of the functions in the stack trace are labeled `wasm-function`,
    which, from a debugging perspective, is kind of useless. This is because we lose
    the function names in the compilation process. To keep these names, we will need
    to pass the `-g4` flag to Emscripten when we compile. The `-g` flag, followed
    by a number, tells the compiler how much debugging information to preserve in
    the compilation process, with `-g0` being the least amount of information and
    `-g4` being the most. If we want to create source maps that map our WebAssembly
    to the C/C++ source code it was created from, we will need to pass in the `-g4`
    command, and if we want to know the functions called by our stack trace, we are
    going to need `-g4` for that as well. Let''s try recompiling with our `-g4` flag.
    Here is the new version of the `emcc` command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们有一个堆栈跟踪，后面是我们的消息，“检查控制台日志以获取堆栈跟踪”，这是我们传递给`DBG`宏的字符串。如果您仔细观察，您可能会注意到的一件事是，这个堆栈跟踪并不是很有用。堆栈跟踪中的大多数函数都标记为`wasm-function`，从调试的角度来看，这有点无用。这是因为我们在编译过程中丢失了函数名称。为了保留这些名称，我们需要在编译时向Emscripten传递`-g4`标志。`-g`标志后面跟着一个数字，告诉编译器在编译过程中保留多少调试信息，`-g0`表示最少的信息，`-g4`表示最多的信息。如果我们想要创建将我们的WebAssembly映射到创建它的C/C++源代码的源映射，我们需要传入`-g4`命令，如果我们想知道堆栈跟踪调用的函数，我们也需要`-g4`。让我们尝试使用`-g4`标志重新编译。这是`emcc`命令的新版本：
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, reload the page and check the console. In the following snippet, we have
    the new stack trace:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新加载页面并检查控制台。在下面的片段中，我们有新的堆栈跟踪：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is much more readable. You can see all of the inner call functions we
    defined, as well as the `main` function. But what happened to `run_debug`? It
    came out looking like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更容易阅读。您可以看到我们定义的所有内部调用函数，以及`main`函数。但`run_debug`发生了什么？它看起来像这样：
- en: '[PRE10]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What''s happening here is called C++ name mangling, and we discussed it briefly
    in earlier chapters. Because C++ allows for function overloading, the compiler
    *mangles* the names of functions so that each version of the function has a different
    name. We were able to prevent this in our calls to `inner_call_1`, `inner_call_2`,
    and `inner_call_3` by placing them in a block labeled `extern "C"`. This tells
    the compiler not to mangle the names of these functions. It isn''t strictly necessary
    for debugging, but I wanted to demonstrate how adding functions to this block
    can allow for easier recognition of our functions inside a stack trace. Here is
    what that same stack trace looks like if I remove the `extern "C"` block:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况被称为C++名称混编，在前几章中我们简要讨论过。因为C++允许函数重载，编译器会对函数的名称进行*混编*，以便每个函数版本都有不同的名称。我们通过将它们放在标记为`extern
    "C"`的块中来防止这种情况发生在对`inner_call_1`、`inner_call_2`和`inner_call_3`的调用中。这告诉编译器不要混编这些函数的名称。这对于调试并不是绝对必要的，但我想演示如何将函数添加到这个块中可以更容易地在堆栈跟踪中识别我们的函数。如果我删除`extern
    "C"`块，那么相同的堆栈跟踪看起来是这样的：
- en: '[PRE11]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, all of our inner call functions are mangled. In the next section,
    we will be discussing source maps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们所有的内部调用函数都被搅乱了。在下一节中，我们将讨论源映射。
- en: Source maps
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源映射
- en: Now, let's briefly discuss source maps. Back in the early days of the web, it
    was decided that users should be able to view all of the source code on every
    web page. Early on, this was always HTML, but later, JavaScript was added and
    became something a user could view in an attempt to understand the workings of
    a given web page. Today, this is not possible in most cases. Some code today,
    such as TypeScript, is transpiled into JavaScript from another language. If you
    are writing JavaScript, you may use Babel to convert the latest JavaScript to
    run on older web browsers. Uglify or Minify may be used to remove white space
    and shorten variable names. If you need to debug the original source code, a source
    map is a tool you can use to map the JavaScript running in your browser back to
    the original source.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要讨论源映射。在Web的早期，人们决定用户应该能够查看每个网页上的所有源代码。早期，这总是HTML，但后来添加了JavaScript，并成为用户可以查看以尝试理解给定网页工作原理的内容。今天，在大多数情况下，这是不可能的。今天的一些代码，如TypeScript，是从另一种语言转译为JavaScript。如果您正在编写JavaScript，可以使用Babel将最新的JavaScript转换为在旧的Web浏览器上运行。Uglify或Minify可用于删除空格并缩短变量名。如果您需要调试原始源代码，源映射是您可以使用的工具，将在浏览器中运行的JavaScript映射回原始源代码。
- en: 'A source map is a JSON file that contains data mapping for the machine-generated
    JavaScript output code and points it back to either the handwritten JavaScript
    or in an alternative language, such as TypeScript or CoffeeScript. There are two
    ways that an application can tell the web browser that there is a source map file
    associated with a given piece of code. We can include a comment with the `sourceMappingURL`
    directive in the code, or we could include a `SourceMap` inside the HTTP header
    for that file. If we are using the `sourceMappingURL` comment method, add the
    following line to the end of the output JavaScript file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射是一个包含数据映射的JSON文件，用于将机器生成的JavaScript输出代码指回手写的JavaScript或另一种语言，如TypeScript或CoffeeScript。应用程序可以通过两种方式告诉Web浏览器给定代码有一个源映射文件。我们可以在代码中包含一个带有`sourceMappingURL`指令的注释，或者我们可以在该文件的HTTP标头中包含一个`SourceMap`。如果我们使用`sourceMappingURL`注释方法，请在输出JavaScript文件的末尾添加以下行：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is usually done programmatically during the build process. The alternative
    method would add the following line to the HTTP header:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是在构建过程中以编程方式完成的。另一种方法是将以下行添加到HTTP标头中：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, we will discuss browser-based WebAssembly debugging tools.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论基于浏览器的WebAssembly调试工具。
- en: Browser debugging
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器调试
- en: Debugging WebAssembly in a web browser is still pretty crude. For example, at
    the time of writing, it is still not possible to directly *watch* a variable using
    the debugger. In both Firefox and Chrome, you must occasionally refresh your browser
    to see the CPP source file. Unlike debugging JavaScript, the WebAssembly debuggers
    feel (ironically) buggy. In Chrome, you frequently have to click the step over
    button several times to advance the line of code. In both browsers, breakpoints
    sometimes fail to work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中调试WebAssembly仍然相当粗糙。例如，在撰写本文时，仍然不可能直接使用调试器*观察*变量。在Firefox和Chrome中，您必须偶尔刷新浏览器才能看到CPP源文件。与调试JavaScript不同，WebAssembly调试器感觉（讽刺地）很有bug。在Chrome中，您经常不得不多次单击步进按钮才能推进代码行。在两个浏览器中，断点有时会失效。
- en: I frequently have to remove and then re-add a break point to get them to work
    again. It is still early days for WebAssembly source maps and in-browser debugging,
    so the hope is that the situation will improve soon. Until it does, try combining
    debugging in the browser with the addition debug statements, as I advised earlier.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常不得不删除然后重新添加断点才能使它们再次工作。WebAssembly源映射和浏览器调试仍处于早期阶段，因此希望情况很快会有所改善。在这之前，尝试将浏览器中的调试与添加调试语句结合使用，正如我之前建议的那样。
- en: Compiling your code for debugging
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为调试编译您的代码
- en: 'As I mentioned earlier, we will need to compile our app to support source maps
    that we can use for in-browser debugging in Firefox and Chrome. Currently, the
    only browsers that support in-browser debugging are Firefox, Chrome, and Safari.
    I will only be covering Firefox and Chrome in this book. You can compile the `debug.cpp`
    file for use with the WebAssembly debugger using the following `emcc` command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我们需要编译我们的应用程序以支持我们可以在Firefox和Chrome中进行浏览器调试的源映射。目前，唯一支持浏览器调试的浏览器是Firefox、Chrome和Safari。在本书中，我只会涵盖Firefox和Chrome。您可以使用以下`emcc`命令编译`debug.cpp`文件以供WebAssembly调试器使用：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first new flag is `-g4`, which instructs the compiler to have the highest
    amount of debugging data and create source map files for our WebAssembly. After
    that comes the `--source-map-base http://localhost:8080/` flag, which tells the
    compiler to add the `sourceMappingURL$http://localhost:8080/debug.wasm.map` string
    to the end of the `debug.wasm` file. This allows the browser to find the source
    map file that is associated with the `debug.wasm` file. The last two new flags
    are `-s MAIN_MODULE=1` and `-s WASM=1`. I'm not sure why either of these flags
    are required to make the source mapping work. Both of these flags are explicitly
    telling the compiler to run the default behavior. However, at the time of writing,
    if you don't include these flags, browser debugging will not work. This feels
    like a bug to me, so it is possible that by the time you are reading this, `emcc`
    will not require those final two flags. Compiling with the preceding command will
    allow you to test using the WebAssembly debugger on Chrome and Firefox. If you
    really want to debug on Opera, Edge, or some other debugger that doesn't support
    WebAssembly debugging yet, you do have an alternative.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Using asm.js as an alternative for debugging
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For whatever reason, you may feel that debugging using Edge or Opera may be
    necessary. If you feel that you must debug in a browser that doesn't have a WebAssembly
    debugger, you could compile for asm.js as an alternative. If so, change the `-s
    WASM=1` flag to `-s WASM=0`, and you will be set. This will create a JavaScript
    file instead of a WASM file, but the two files (in theory) should behave the same.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using Chrome
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chrome has some great tools for debugging JavaScript, but is still pretty raw
    when it comes to debugging WebAssembly. After you have built the app, open it
    up in Chrome, and then open up Chrome Developer Tools:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a11a945-2feb-426c-8ab0-79ce61d0d3ca.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Screenshot of opening Chrome Developer Tools using the menu'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open it up using the menu in the top left of the browser, as seen in
    the preceding screenshot, or you can open the developer tools by pressing *Ctrl*
    + *Shift* + *I* on your keyboard. When you load up your `debug.html` file in Chrome,
    you need to click on the Sources tab in the developer window. This is what this
    should look like if you are on the Sources tab:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d5b7fd9-415c-4edb-a9f4-c2e387054c2f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Screenshot using the sources tab in Chrome Developer Tools'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see `debug.cpp` in the Sources tab, you may need to click the browser's
    reload button next to the URL at the top to reload the page. As I stated earlier,
    the interface feels a little buggy, and sometimes the CPP file doesn't load on
    the first try. Hopefully, this will have changed by the time you read this. Once
    you select the CPP file, you should be able to see the C++ code from our `debug.cpp`
    file in the code window in the center of the Developer Tools window. You can set
    breakpoints in the C++ code by clicking on the line number next to the line of
    code where you would like a breakpoint. You can then step through the code using
    the buttons above the `Watch` variables. Although the watch variables don't work
    at the time of writing, you may want to try it anyway. WebAssembly is improving
    on an almost daily basis, and bug fixes are constantly happening, so by the time
    you read this, things may have changed. If not, you may use the `Local` variables
    to get some idea of what values are changing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'You can watch these variables get populated as you step through the source
    code, and you can frequently determine which variables are updated by watching
    these values change. Take a look at the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2194af80-6559-4c96-85cf-a4aa50496525.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Screenshot of the debug tools in the Chrome browser'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, you need to click the step over button more than once
    to get the line to advance in the C++ code window. In Chrome, the step over button
    is advancing one WebAssembly instruction per click instead of one C++ instruction.
    This may have changed by the time you read this, but don't be surprised if you
    need to click step over more than once to advance through the code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using Firefox
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firefox has a number of advantages and disadvantages compared to Chrome. On
    the plus side, you can click the step over button once in Firefox per line in
    your C++ code. On the minus side, this makes knowing which local variables are
    changing in response to the line you are executing more difficult to track. These
    `Local` variables are a little like registers in a register-based assembly language
    so that the same variable may get moved in and out of a few of them. It can be
    a little easier to follow along with the values if you have to click the button
    once per assembly instruction. However, if you are more interested in tracing
    through the flow of your code than knowing what values change for each WebAssembly
    instruction, Firefox is much better for that.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'To open up your Firefox Developer Tools, click the menu button in the top right
    corner of the browser window and select Web Developer:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/571431e1-1c13-455c-9300-6d5f00ab92f2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Web Developer tools in the Firefox browser'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Once on the Web Developer menu, click the Debugger menu item to open up the
    Debugger window:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee20cca5-4719-4b79-8de6-4dc4ef3b5887.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Screenshot of opening Debugger in Firefox'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of selecting the debugger through the menu system, you can use the
    shortcut keys *Ctrl* + *Shift* + *C* to open up the Inspector, and then select
    the Debugger tab from the Web Developer window. Here is what this looks like when
    you are in the Firefox Debugger:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a40bc212-12a6-460a-b385-3262e7b75831.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Screenshot of using Debugger in the Firefox browser'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Right now, debugging will need to combine the use of debugging macros, as discussed
    in the previous section, with the ability of the browser to fully understand what
    is going on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Firefox Developer Edition
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am briefly going to mention the Firefox Developer Edition. If you prefer
    to use Firefox as your primary WebAssembly development browser, you may want to
    consider using Firefox Developer Edition. The Developer Edition pushes forward
    updates to the web developer tools faster than the standard version of Firefox.
    Because WebAssembly is so new, updates that improve the development experience
    are likely to show up in the Developer Edition weeks or months earlier than they
    will become available in the standard version. At the time of writing, there is
    no significant difference between the two versions, but if you are interested
    in trying it out, it is available at the following web address: [https://www.mozilla.org/en-US/firefox/developer/](https://www.mozilla.org/en-US/firefox/developer/).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for WebAssembly
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing your WebAssembly code is partially about decision making and experimenting.
    It is about discovering what works for your particular game or app. When WebAssembly
    was designed, for instance, a decision was made to have the WebAssembly bytecode
    run on a virtual stack machine. The designers of WebAssembly made this choice
    because they felt that they could justify the small loss of performance with a
    significantly smaller bytecode download size. Every piece of code has a bottleneck
    somewhere. In OpenGL applications that bottleneck will be interfacing with the
    GPU. The bottleneck for your application may be the memory, or it may be CPU-bound.
    Optimizing code, in general, is about determining what the holdup is and deciding
    what trade-off you would like to make to improve things. If you optimize for download
    size, you may lose some runtime performance. If you optimize for runtime performance,
    you may have to increase your memory footprint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Optimization flags
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emscripten provides us with a large selection of flags to optimize for different
    potential bottlenecks. All of the optimization flags will result in varying degrees
    of longer compile times, so using any of these flags should come late in the development
    cycle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for performance
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `-O` flags for general optimization. `-O0`, `-O1`, `-O2`, and
    `-O3` provide different levels of trade-off between compile time and code performance.
    The `-O0` and `-O1` flags provide minimal optimization. The `-O2` flag offers
    most of the optimization you get from the `-O3` flag, but with significantly shorter
    compile times. Finally, `-O3` provides the highest level of optimization, but
    takes substantially longer than any other flag to compile, so it is a good idea
    to wait until you are nearing the end of development to begin using it. In addition
    to the `-O` flags, `-s AGGRESSIVE_VARIABLE_ELIMINATION=1` can be used to increase
    performance, but may result in larger bytecode download sizes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for size
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two other `-O` flags that I didn't mention in the preceding section.
    Those flags are used to optimize for bytecode download size instead of purely
    optimizing for performance. The `-Os` flag takes about as long as `-O3`, and provides
    as much performance optimization as it can, but sacrifices some of the `-O3` optimizations
    in favor of smaller download sizes. `-Oz` is like `-Os`, but prioritizes smaller
    download sizes even further by sacrificing even more performance optimization,
    which results in smaller bytecode. Another way to optimize for size is to include
    the `-s ENVIRONMENT='web'` flag. You should only use this flag if you are compiling
    for the web. It removes any source code that is used to support other environments,
    such as Node.js.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe flags
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the safe optimization flags we have been using up until this
    point, Emscripten also allows for two *unsafe* flags that can improve performance,
    but come at the risk of potentially breaking your code. These flags are high risk/high
    reward optimizations that you should only use before the bulk of testing is complete.
    Using the `--closure 1` flag runs the Closure JavaScript compiler, which performs
    very aggressive optimization on the JavaScript in our app. However, you shouldn't
    use the `--closure 1` flag unless you are already familiar with using the closure
    compiler and the effects that compiler could have on JavaScript. The second *unsafe*
    flag is the `--llvm-lto 1` flag, which enables *Link Time Optimization* during
    the LLVM compile step. This process can break your code, so take extreme care
    when using this flag.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling is the best way to determine what bottlenecks exist in your source
    code. When you are profiling WebAssembly modules, I recommend that you use the
    `--profiling` flag when compiling. You can profile without it, but all of the
    module functions you call will be labeled `wasm-function`, which can make your
    life more difficult than it needs to be. After compiling your code with the `--profile`
    flag, open up a new *Incognito* window in Chrome.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by either pressing the *CTRL + SHIFT + N* keys, or through
    the menu in the top right corner of the browser:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b6fc82e-f25b-4487-87b5-2632a5b32714.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Opening an Incognito window in the Chrome browser'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening an Incognito window will prevent any Chrome extensions from running
    when profiling your app. This will prevent you from having to wade through the
    code in those extensions to get to the code in your app. Once you have opened
    an Incognito window, press *Ctrl* + *Shift* + *I* to inspect the page. This will
    open up Chrome Developer Tools at the bottom of the browser window. Inside Chrome
    Developer Tools, select the Performance tab, as you can see in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed201a26-d861-4f07-91b7-29d544bc9195.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: The Performance tab in the Chrome browser'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click the Record button and let it run for a few seconds. After you have
    recorded for five or six seconds, click the Stop button to stop profiling:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f360963f-d7da-48ee-b60c-4e69981c71d9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Screenshot of recording performance metrics in the Chrome browser'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: After you stop profiling, you will see data within the performance window. This
    is called the Summary tab, and displays data in the form of a pie chart that breaks
    down the number of milliseconds your app is spending on various tasks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the vast majority of the time, our app is idle:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8fea306-0daa-4c78-a71c-a1b49c4397cf.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Performance overview in the Chrome browser'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The summary is interesting. It can tell you where your bottleneck is on a very
    high level, but to evaluate our WebAssembly, we will need to look in the Call
    Tree tab. Click on the Call Tree tab, and you will see the following window:￼
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3aa8cd8-4542-4c9e-bc91-70ecf0f28220.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Screenshot of the Call Tree in the Chrome browser'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Because our `game_loop` function is being called every frame, we can find the
    call inside the `Animation Frame Fired` tree. Drill down, looking for `game_loop`.
    When we find the function, it is mangled because it is a C++ function. So, instead
    of seeing `_game_loop`, we see `_Z9game_loopv`, although you may see something
    mangled differently. If you would like to prevent this mangling, you can wrap
    this function in an `extern "C"` block.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the execution of this function took a total of 3.2% of the
    browser's CPU time. You can also look at each of the OpenGL calls from within
    this function. If you take a look at our game loop, more than half of the CPU
    time is spent in `_glClear`. This is not a problem for this application, because
    the vast majority of the browser CPU time is spent idle. If, however, our game
    loop function was taking up a large percentage of the CPU time, we would need
    to see where in that function we were spending it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Problems with try/catch blocks
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, try/catch blocks are known to cause significant performance
    issues in WebAssembly modules, so only use them if they're absolutely necessary.
    You may want to use them during the development phase, and remove them when building
    for release. Some of the `-O` optimization flags will remove try/catch blocks,
    which you need to be aware of if you plan on using them in production. If you
    want to use try/catch blocks in your production build, you will need to compile
    using the `-s DISABLE_EXCEPTION_CATCHING=0` flag. This will tell the compiler
    not to remove the try/catch blocks from the optimized version of your bytecode.
    If you would like to remove your try/catch blocks from unoptimized development
    code, you can do so by using the `-s DISABLE_EXCEPTION_CATCHING=1` flag.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing OpenGL for WebAssembly
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to remember that any calls to OpenGL from WebAssembly are calling
    WebGL using a function table. Part of the reason this is important is because
    any time you use OpenGL ES and OpenGL functionality that is not available in WebGL,
    Emscripten must perform some very slow software emulation on those functions.
    It is also important to remember that WebGL calls are more expensive than OpenGL
    calls on a native platform because WebGL is sandboxed, and various security checks
    are performed by the browser when it calls WebGL. Emscripten provides you with
    several flags that allow you to emulate OpenGL and OpenGL ES calls that are not
    available in WebGL. For performance reasons, however do not use these functions
    unless you absolutely have to.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Using WebGL 2.0 if possible
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebGL 2.0 is faster than WebGL 1.0, but, at the time of writing, it is supported
    on far fewer browsers. Just compiling your WebGL 1.0 code to WebGL 2.0 will give
    you about a 7% performance improvement. However, before you choose to do this,
    you may want to consult [https://caniuse.com/#search=webgl2](https://caniuse.com/#search=webgl2)
    to see whether the browsers you are targeting support WebGL 2.0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the number of OpenGL calls
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calls to OpenGL from WebAssembly are not as fast as those same calls from a
    natively compiled application. A call to OpenGL from WebAssembly is making a call
    to a WebGL analog. WebGL was built to execute inside a web browser and performs
    some security checks to verify that we are not asking WebGL to do anything malicious.
    This means that we must account for that additional overhead when writing OpenGL
    that's targeting WebAssembly. There are cases where two or three calls to OpenGL
    for a native application would be faster than combining those calls into a single
    OpenGL call. However, that same code in WebAssembly might run faster if you condensed
    it into a single call to OpenGL. When optimizing for WebAssembly, try doing what
    you can to minimize the number of OpenGL calls, and use your profiler to verify
    that the new code is faster.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten OpenGL flags
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several Emscripten linker flags can have a significant effect on performance.
    Some of the flags were created to ease porting of code to WebAssembly, but have
    the potential to create performance problems. Others can improve performance under
    the right conditions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The `-s FULL_ES2=1` and `-s FULL_ES3=1` linker flags emulate the entire OpenGL
    ES 2.0/3.0 API. As I mentioned earlier, by default, the OpenGL ES 2/3 implementations
    in WebAssembly only support subsets of OpenGL ES 2/3 that are compatible with
    WebGL. This is because WebGL is doing the rendering in WebAssembly. There may
    be a reason why you absolutely need a feature of OpenGL ES 2/3 that is not available
    by default. If so, you can use the `-s FULL_ES2=1` or `-s FULL_ES3=1` flags to
    emulate that feature in the software. This will come at a price when it comes
    to performance, so take that into consideration if you decide to use it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The `-s LEGACY_GL_EMULATION=1` flag is used to emulate old versions of OpenGL
    that use the fixed function pipeline. It is also not recommended that you use
    this flag because of the poor performance that will result. This flag exists for
    people who are looking to port old code to WebAssembly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use WebGL 2 to gain the performance increase associated with
    it, use the `-s USE_WEBGL2=1` linker flag. If you have code that was written for
    WebGL 1.0, but would like the performance gains of WebGL 2.0, you can try compiling
    to WebGL 2.0 to see whether you used any code that was not backward compatible
    in WebGL 2.0\. If it doesn't compile with this flag, you can try the `-s WEBGL2_BACKWARDS_COMPATIBILITY_EMULATION=1`
    linker flag, which will allow you to compile your WebGL 1.0 code so that you can
    use it in WebGL 2.0.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about different strategies we can use to debug and
    optimize our WebAssembly code. We discussed writing C macros, which allow us to
    easily remove calls to print to the console when we move from development into
    production. We talked about source maps, what they are, and how they can help
    us to debug our WebAssembly code from within a browser. We discussed using the
    debugger in both Chrome and Firefox to step through WebAssembly's source code.
    Finally, we discussed optimization in WebAssembly, what compiler options are available
    in Emscripten, and how we can go about improving our WebGL performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: This is the end
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! You should be well on your way to developing your own games
    or apps in WebAssembly. I hope that you enjoyed learning how we can use WebGL
    to build games for the web. If you have any questions, comments, or would just
    like to say hi, you can find me on the following platforms:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Twitter**: [https://twitter.com/battagline](https://twitter.com/battagline)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推特**: [https://twitter.com/battagline](https://twitter.com/battagline)'
- en: '**LinkedIn**: [https://www.linkedin.com/in/battagline/](https://www.linkedin.com/in/battagline/)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领英**: [https://www.linkedin.com/in/battagline/](https://www.linkedin.com/in/battagline/)'
- en: '**YouTube**: [https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ](https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YouTube**: [https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ](https://www.youtube.com/channel/UCaJYTBKp0vM1rLT82PcXwKQ)'
