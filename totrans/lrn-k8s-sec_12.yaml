- en: '*Chapter 10*: Real-Time Monitoring and Resource Management of a Kubernetes
    Cluster'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The availability of services is one of the critical components of the **Confidentiality,
    Integrity and Availability** (**CIA**) triad. There have been many instances of
    malicious attackers using different techniques to disrupt the availability of
    services for users. Some of these attacks on critical infrastructure such as the
    electricity grid and banks have resulted in significant losses to the economy.
    One of the most significant attacks was an attack on Amazon AWS Route 53 infrastructure
    that resulted in the disruption of core IT services all over the world. To avoid
    such issues, infrastructure engineers monitor resource usage and application health
    in real time to ensure the availability of services offered by an organization.
    Real-time monitoring is often plugged into an alert system that notifies the stakeholders
    when symptoms of service disruption are observed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how you can ensure that services in the Kubernetes
    cluster are always up and running. We will begin by discussing monitoring and
    resource management in monolith environments. Next, we will discuss resource requests
    and resource limits, two concepts at the heart of resource management in Kubernetes.
    We will then look at tools such as `LimitRanger`, which Kubernetes provides for
    resource management, before shifting our focus to resource monitoring. We will
    look at built-in monitors, such as Kubernetes Dashboard and Metrics Server. Finally,
    we will look at open source tools, such as Prometheus and Grafana, that can be
    used to monitor the state of a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time monitoring and management in monolith environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing resources in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring resources in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time monitoring and management in monolith environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource management and monitoring are important in monolith environments as
    well. In monolith environments, infrastructure engineers often pipe the output
    of Linux tools such as `top`, `ntop`, and `htop` to data visualization tools in
    order to monitor the state of VMs. In managed environments, built-in tools such
    as Amazon CloudWatch and Azure Resource Manager help to monitor resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to resource monitoring, infrastructure engineers proactively allocate
    minimum resource requirements and usage limits for processes and other entities.
    This ensures that sufficient resources are available to services. Furthermore,
    resource management ensures that misbehaving or malicious processes do not hog
    resources and prevent other processes from working. For monolith deployments,
    resources such as CPU, memory, and spawned processes are capped for different
    processes. On Linux, process limits can be capped using `prlimit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command sets the limit of child processes that a parent process can spawn
    to `2`. With this limit set, if a process with a PID of `18065` tries to spawn
    more than `2` child processes, it will be denied.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to monolith environments, a Kubernetes cluster runs multiple pods, deployments,
    and services. If an attacker is able to spawn up Kubernetes objects such as pods
    or deployments, the attacker can cause a denial-of-service attack by depleting
    resources available in the Kubernetes cluster. Without adequate resource monitoring
    and resource management in place, unavailability of the services running in the
    cluster can cause an economic impact to the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Managing resources in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes provides the ability to proactively allocate and limit resources
    available to Kubernetes objects. In this section, we will discuss resource requests
    and limits, which form the basis for resource management in Kubernetes. Next,
    we explore namespace resource quotas and limit ranges. Using these two feature,
    clusters, administrators can cap the compute and storage limits available to different
    Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: Resource requests and limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kube-scheduler`, as we discussed in [*Chapter 1*](B15566_01_Final_ASB_ePub.xhtml#_idTextAnchor020),
    *Kubernetes Architecture*, is the default scheduler and runs on the master node.
    `kube-scheduler` finds the most optimal node for the unscheduled pods to run on.
    It does that by filtering the nodes based on the storage and compute resources
    requested for the pod. If the scheduler is not able to find a node for the pod,
    the pod will remain in a pending state. Additionally, if all the resources of
    the node are being utilized by the pods, `kubelet` on the node will clean up dead
    pods – unused images. If the cleanup does not reduce the stress, `kubelet` will
    start evicting those pods that consume more resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Resource requests specify what a Kubernetes object is guaranteed to get. Different
    Kubernetes variations or cloud providers have different defaults for resource
    requests. Custom resource requests for Kubernetes objects can be specified in
    the workload's specifications. Resource requests can be specified for CPU, memory,
    and HugePages. Let's look at an example of resource requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a pod without a resource request in the `yaml` specification,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The pod will use the default resource request for deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding example, the default resource request is for 0.1 CPU cores
    for the pod. Let''s now add a resource request to the `.yaml` specification and
    see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This specification creates a pod with a resource request of 0.5 CPU cores,
    300 MB, and `hugepages-2Mi` of 100 MB. You can check the resource request for
    a pod using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, the pod uses a custom resource request of 0.5
    CPU cores, 300 MB of `memory`, and 100 MB of 2 MB `hugepages`, instead of the
    default 1 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Limits, on the other hand, are hard limits on the resources that the pod can
    use. Limits specify the maximum resources that a pod should be allowed to use.
    Pods are restricted if more resources are required than are specified in the limit.
    Similar to resource requests, you can specify limits for CPU, memory, and HugePages.
    Let''s look at an example of limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This pod initiates a stress process that tries to allocate memory of `150M`
    at startup. If no limits are specified in the `.yaml` specification, the pod runs
    without any issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Limits are added to the container section of the `yaml` specification for the
    pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The stress process fails to run and the pod runs into `CrashLoopBackOff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the pod was terminated with an `OOMKilled` error when you
    described the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Resource requests and limits are converted, mapped to `docker` arguments – `—cpu-shares`
    and `—memory` flags – and passed to the container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at examples of how resource requests and limits work for pods, but
    the same examples apply to DaemonSet, Deployments, and StatefulSets. Next, we
    look at how namespace resource quotas can help set an upper limit for the resources
    that can be used by namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace resource quotas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Resource quotas for namespaces help define the resource requests and limits
    available to all objects within the namespace. Using resource quotas, you can
    limit the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request.cpu`: The maximum resource request for CPU for all objects in the
    namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request.memory`: The maximum resource request for memory for all objects in
    the namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit.cpu`: The maximum resource limit for CPU for all objects in the namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit.memory`: The maximum resource limit for memory for all objects in the
    namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requests.storage`: The sum of storage requests in a namespace cannot exceed
    this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: Resource quotas can also be used to limit the count of different Kubernetes
    objects in a cluster, including pods, services, PersistentVolumeClaims, and ConfigMaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, cloud providers or different variations have standard limits applied
    to the namespace. On **Google Kubernetes Engine** (**GKE**), the `cpu` request
    is set to 0.1 CPU cores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example of what happens when resource quotas are applied to a
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a namespace demo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a resource quota. In this example, the quota limits the resource request
    CPU to `1` CPU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the quota to the namespace by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check whether the resource quota is applied successfully to the namespace
    by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to create two pods that use `1` CPU, the second request will
    fail with the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Resource quotas ensure quality of service for namespaced Kubernetes objects.
  prefs: []
  type: TYPE_NORMAL
- en: LimitRanger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed the `LimitRanger` admission controller in [*Chapter 7*](B15566_07_Final_ASB_ePub.xhtml#_idTextAnchor186),
    *Authentication, Authorization, and Admission Control*. Cluster administrators
    can leverage limit ranges to ensure that misbehaving pods, containers, or `PersistentVolumeClaims`
    don't consume all available resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use limit ranges, enable the `LimitRanger` admission controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using LimitRanger, we can enforce `default`, `min`, and `max` limits on storage
    and compute resources. Cluster administrators create a limit range for objects
    such as pods, containers, and PersistentVolumeClaims. For any request for object
    creation or update, the LimitRanger admission controller verifies that the request
    does not violate any limit ranges. If the request violates any limit ranges, a
    403 Forbidden response is sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a simple limit range:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a namespace in which a limit range will be applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a `LimitRange` for the namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the `limitrange` was applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a pod that violates the limit range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This request will be denied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If a LimitRanger specifies a CPU or memory, all pods and containers should have
    the CPU or memory request or limits. LimitRanger works when the request to create
    or update the object is received by the API Server but not at runtime. If a pod
    has a violating limit before the limit is applied, it will keep running. Ideally,
    limits should be applied to the namespace when it is created.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at a couple of features that can be used for proactive
    resource management, we switch gears and look at tools that can help us monitor
    the cluster and notify us before matters deteriorate.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring resources in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, resource monitoring is an essential step for ensuring
    the availability of your services in your cluster. Resource monitoring uncovers
    early signs or symptoms of service unavailability in your clusters. Resource monitoring
    is often complemented with alert management to ensure that stakeholders are notified
    as soon as any problems, or symptoms associated with any problems, in the cluster
    are observed.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we first look at some built-in monitors provided by Kubernetes,
    including Kubernetes Dashboard and Metrics Server. We look at how we can set it
    up and discuss how to use these tools efficiently. Next, we look at some open
    source tools that can plug into your Kubernetes cluster and provide far more in-depth
    insight than the built-in tools.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in monitors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at some tools provided by Kubernetes that are used for monitoring
    Kubernetes resources and objects – Metrics Server and Kubernetes Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Dashboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes Dashboard provides a web UI for cluster administrators to create,
    manage, and monitor cluster objects and resources. Cluster administrators can
    also create pods, services, and DaemonSets using the dashboard. The dashboard
    shows the state of the cluster and any errors in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Dashboard provides all the functionality a cluster administrator
    requires in order to manage resources and objects within the cluster. Given the
    functionality of the dashboard, access to the dashboard should be limited to cluster
    administrators. The dashboard has a login functionality starting v1.7.0\. In 2018,
    a privilege escalation vulnerability (CVE-2018-18264) was identified in the dashboard
    that allowed unauthenticated users to log in to the dashboard. There were no known
    in-the-wild exploits for this issue, but this simple vulnerability could have
    wreaked havoc on many Kubernetes distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Current login functionality allows logging in using a service account and `kubeconfig`.
    It is recommended that service account tokens should be used to access Kubernetes
    Dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Kubernetes Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_10_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Kubernetes Dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow a service account to use the Kubernetes dashboard, you need to add
    the `cluster-admin` role to the service account. Let''s look at an example of
    how a service account can be used to access the Kubernetes dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a service account in the default namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Associate the `cluster-admin` role with the service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch the token for the service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to fetch the token for the service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the service account token to log in to the dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Kubernetes dashboard login'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_10_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Kubernetes dashboard login
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Kubernetes Dashboard, administrators have insight into resource availability,
    resource allocation, Kubernetes objects, and event logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Kubernetes Dashboard – resource allocation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_10_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Kubernetes Dashboard – resource allocation
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows resource allocation on a node for resource requests
    and limits. The following screenshot highlights the events for a node on the Kubernetes
    dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Kubernetes Dashboard – event logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_10_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Kubernetes Dashboard – event logs
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes Dashboard runs as a container on the master node. You can see this
    by enumerating the Docker containers on the master node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The dashboard process runs with a set of arguments on the master node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the dashboard container is running with the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disable insecure port**: `--insecure-port` enables Kubernetes Dashboard to
    receive requests over HTTP. Ensure that it is disabled in production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable insecure address**: `--insecure-bind-address` should be disabled
    to avoid a situation where Kubernetes Dashboard is accessible via HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bind address to localhost**: `--bind-address` should be set to `127.0.0.1`
    to prevent hosts from being connected over the internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable TLS**: Use `tls-cert-file` and `tls-key-file` to access the dashboard
    over secure channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensure token authentication mode is enabled**: Authentication mode can be
    specified using the `--authentication-mode` flag. By default, it is set to `token`.
    Ensure that basic authentication is not used with the dashboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable insecure login**: Insecure login is used when the dashboard is available
    via HTTP. This should be disabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable skip login**: Skip login allows unauthenticated users to access the
    Kubernetes dashboard. `--enable-skip-login` enables skip login; this should not
    be present in production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disable settings authorizer**: `--disable-settings-authorizer` allows unauthenticated
    users to access the settings page. This should be disabled in production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metrics Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Metrics Server aggregates cluster usage data using the Summary API exposed by
    each `kubelet` on each node. It is registered with `kube-apiserver` using `kube-aggregator`.
    Metrics Server exposes the collected metrics through the Metrics API, which are
    used by the horizontal pod autoscalar and the vertical pod autoscalar. `kubectl
    top`, which is used to debug clusters, also uses the Metrics API. Metrics Server
    is specifically designed for autoscaling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Metrics Server is enabled by default on some Kubernetes distributions. You
    can enable it on `minikube` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check whether Metrics Server is enabled by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Metrics Server is enabled, it takes some time to query the Summary API
    and co-relate the data. You can see the current metrics by using `kubectl top
    node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Similar to other services and components, Metrics Server also has configuration
    parameters. In production clusters, make sure that Metrics Server does not use
    the `--kubelet-insecure-tls` flag, which allows Metrics Server to skip verification
    of certificates by the CA.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party monitoring tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Third-party monitoring tools integrate in Kubernetes to provide many more features
    and insights into the health of Kubernetes resources. In this section, we will
    discuss Prometheus and Grafana, which are the most popular monitoring tools in
    the open source community.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus and Grafana
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prometheus is an open source instrumentation and data collection framework developed
    by SoundCloud and adopted by CNCF. Prometheus can be used to see time series data
    for different data points. Prometheus uses a pull system. It sends an HTTP request
    called a scrape, which fetches data from the system components, including API
    Server, `node-exporter`, and `kubelet`. The response to the scrape and the metrics
    are stored in a custom database on the Prometheus server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how Prometheus can be set up to monitor a namespace in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a cluster role to read Kubernetes objects such as pods, nodes, and services
    and add the role binding to a service account. In this example, we are using the
    default service account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create a role binding to associate the role with the default service
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Prometheus uses ConfigMap to specify the scrape rule. The following rule-scrapes
    the `kube-apiserver`. Multiple scraps can be defined to fetch metrics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a deployment for Prometheus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once deployment is successful, port forwarding or Kubernetes services can be
    used to access the dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables port forwarding for the Prometheus pod. Now, you can access it
    using the cluster IP on port `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Prometheus Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_10_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Prometheus Dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Queries can be entered as expressions and the results viewed as **Graph** or
    **Console** messages. Using Prometheus queries, cluster administrators can view
    the status of clusters, nodes, and services that are being monitored by Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples of Prometheus queries that will be helpful for
    cluster administrators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes CPU usage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubernetes CPU usage by namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'CPU requests by pod:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at CPU usage by namespace for the demo cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – CPU usage by namespace'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_10_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – CPU usage by namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'Prometheus also allows cluster administrators to set alerts using ConfigMaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This alert triggers an alert with a label severity of `high` when container
    memory usage is greater than `1000` MB for `1` minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Prometheus Alerts'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_10_007_New.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Prometheus Alerts
  prefs: []
  type: TYPE_NORMAL
- en: Using `Alertmanager` with Prometheus helps deduplicate, group, and route alerts
    from applications such as Prometheus and route it to integrated clients, including
    email, OpsGenie, and PagerDuty.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus integrates well with other third-party tools that enhance data visualization
    and alert management. Grafana is one such tool. Grafana allows visualization,
    querying, and alerting on data retrieved from Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at how we set up Grafana with Prometheus:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Grafana needs a data source for ingestion; in this case, it is Prometheus.
    The data source can be added using the UI or can be specified using a ConfigMap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a deployment for Grafana:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Port forwarding or Kubernetes services can then be used to access the dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The dashboard, by default, has `admin` as a username and password. Once logged
    in, you can either set up a new dashboard or import one from Grafana. To import
    one, you can click **+ > Import**, where you will be presented with the following
    screen. Enter `315` in the first textbox to import dashboard 315 from Grafana:![Figure
    10.8 – Importing a dashboard in Grafana
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15566_10_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Importing a dashboard in Grafana
  prefs: []
  type: TYPE_NORMAL
- en: This dashboard was created by Instrumentisto Team. On import, all fields on
    the next screen will be filled up automatically:![Figure 10.9 – Grafana Dashboard
    – 315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15566_10_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Grafana Dashboard – 315
  prefs: []
  type: TYPE_NORMAL
- en: A new dashboard can also be created with custom Prometheus queries:![Figure
    10.10 – Custom dashboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15566_10_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Custom dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to Prometheus, you can set up alerts on each dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – New alerts in Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15566_10_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – New alerts in Grafana
  prefs: []
  type: TYPE_NORMAL
- en: There are other tools that integrate with Prometheus that make it such a valuable
    tool for DevOps and cluster administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed availability as an important part of the CIA triad.
    We discussed the importance of resource management and real-time resource monitoring
    from a security standpoint. We then introduced resource requests and limits, core
    concepts for resource management in Kubernetes. Next, we discussed resource management
    and how cluster administrators can proactively ensure that Kubernetes objects
    can be prevented from misbehaving.
  prefs: []
  type: TYPE_NORMAL
- en: We dived deep into the details of namespace resource quotas and limit ranges
    and looked at examples on how to set it up. We then shifted gears to resource
    monitoring. We looked at some built-in monitors that are available as part of
    Kubernetes, including Dashboard and Metrics Server. Finally, we looked at a number
    of third-party tools – Prometheus and Grafana – that are much more powerful and
    preferred by most cluster administrators and DevOps engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Using resource management, cluster administrators can ensure that services in
    a Kubernetes cluster have sufficient resources available for operation and that
    malicious or misbehaving entities don't hog all the resources. Resource monitoring,
    on the other hand, helps to identify issues and the symptoms in real time. With
    alert management used in conjunction with resource monitoring, stakeholders are
    notified of symptoms, such as reduced disk space or high memory consumption, as
    soon as they occur, ensuring that downtime is minimal.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss Defense in Depth in detail. We will look
    at how cluster administrators and DevOps engineers can supplement secure configuration,
    resource management, and resource monitoring with a layered approach to security.
    Defense in Depth will introduce more toolkits to ensure that attacks are easily
    detected and mitigated in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a resource request and limits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a resource quota that limits the memory limit to 500 mi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does limit-range differ from resource-quotas?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the recommended authentication method for Kubernetes Dashboard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the most widely recommended resource monitoring tool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Denial-of-service attacks on electrical systems: [https://www.cnbc.com/2019/05/02/ddos-attack-caused-interruptions-in-power-system-operations-doe.html](https://www.cnbc.com/2019/05/02/ddos-attack-caused-interruptions-in-power-system-operations-doe.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon Route53 DDoS: [https://www.cpomagazine.com/cyber-security/ddos-attack-on-amazon-web-services-raises-cloud-safety-concerns/](https://www.cpomagazine.com/cyber-security/ddos-attack-on-amazon-web-services-raises-cloud-safety-concerns/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limit Ranger design documentation: [https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/admission_control_limit_range.md](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/admission_control_limit_range.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes Dashboard: [https://github.com/kubernetes/dashboard/blob/master/docs/README.md](https://github.com/kubernetes/dashboard/blob/master/docs/README.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Privilege escalation using Kubernetes Dashboard: [https://sysdig.com/blog/privilege-escalation-kubernetes-dashboard/](https://sysdig.com/blog/privilege-escalation-kubernetes-dashboard/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Metrics Server: [https://github.com/kubernetes-sigs/metrics-server](https://github.com/kubernetes-sigs/metrics-server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aggregated API servers: [https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prometheus queries: [https://prometheus.io/docs/prometheus/latest/querying/examples/](https://prometheus.io/docs/prometheus/latest/querying/examples/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana documentation: [https://grafana.com/docs/grafana/latest/](https://grafana.com/docs/grafana/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
