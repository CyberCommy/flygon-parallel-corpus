- en: Chapter 5. Locks, Blocks, and Better Channels
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're starting to get a good grasp of utilizing goroutines in safe
    and consistent ways, it's time to look a bit more at what causes code blocking
    and deadlocks. Let's also explore the `sync` package and dive into some profiling
    and analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've built some relatively basic goroutines and complementary channels,
    but we now need to utilize some more complex communication channels between our
    goroutines. To do this, we'll implement more custom data types and apply them
    directly to channels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We've not yet looked at some of Go's lower-level tools for synchronization and
    analysis, so we'll explore `sync.atomic`, a package that—along with `sync.Mutex`—allows
    for more granular control over state.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll delve into pprof, a fabulous tool provided by Go that lets us
    analyze our binaries for detailed information about our goroutines, threads, overall
    heap, and blocking profiles.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Armed with some new tools and methods to test and analyze our code, we'll be
    ready to generate a robust, highly-scalable web server that can be used to safely
    and quickly handle any amount of traffic thrown at it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Understanding blocking methods in Go
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've encountered a few pieces of blocking code, intentional and unintentional,
    through our exploration and examples. At this point, it's prudent to look at the
    various ways we can introduce (or inadvertently fall victim to) blocking code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the various ways Go code can be blocked, we can also be better
    prepared to debug cases when concurrency is not operating as expected in our application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Blocking method 1 – a listening, waiting channel
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most concurrently-focused way to block your code is by leaving a serial
    channel listening to one or more goroutines. We''ve seen this a few times by now,
    but the basic concept is shown in the following code snippet:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Despite the fact that all of our looping code is concurrent, we''re waiting
    on a signal for our `blockChannel` to continue linear execution. We can, of course,
    see this in action by sending along the channel, thus continuing code execution
    as shown in the following code snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we've modified our goroutine function to accept our blocking channel and
    deliver an end message to it when we've hit our maximum. These kinds of mechanisms
    are important for long-running processes because we may need to know when and
    how to kill them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Sending more data types via channels
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go's use of channels (structs and functions) as first-class citizens provides
    us with a lot of interesting ways of executing, or at least trying, new approaches
    of communication between channels.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: One such example is to create a channel that handles translation through a function
    itself, and instead of communicating directly through the standard syntax, the
    channel executes its function. You can even do this on a slice/array of functions
    iterating through them in the individual functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Creating a function channel
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we''ve almost exclusively worked in single data type and single value
    channels. So, let''s try sending a function across a channel. With first-class
    channels, we need no abstraction to do this; we can just send almost anything
    directly over a channel as shown in the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is like a callback function. However, it also is intrinsically different,
    as it is not just the method called after the execution of a function, but also
    serves as the mode of communication between functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that there are often alternatives to passing functions across channels,
    so this will likely be something very specific to a use case rather than a general
    practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Since your channel's type can be virtually any available type, this functionality
    opens up a world of possibilities, which can be potentially confusing abstractions.
    A struct or interface as a channel type is pretty self-explanatory, as you can
    make application-related decisions on any of its defined properties.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example of using an interface in this way in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Using an interface channel
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with our function channel, being able to pass an interface (which is a complementary
    data type) across a channel can be incredibly useful. Let''s look at an example
    of sending across an interface:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a very basic example of how to utilize interfaces as channels; in the
    previous example, the interface itself is largely ornamental. In actuality, we're
    passing newly-created message types through the interface's channel rather than
    interacting directly with the interface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Using structs, interfaces, and more complex channels
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating a custom type for our channel allows us to dictate the way our intra-channel
    communication will work while still letting Go dictate the context switching and
    behind-the-scenes scheduling.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, this is mostly a design consideration. In the previous examples,
    we used individual channels for specific pieces of communication in lieu of a
    one-size-fits-all channel that passes a multitude of data. However, you may also
    find it advantageous to use a single channel to handle a large amount of communication
    between goroutines and other channels.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The primary consideration in deciding whether to segregate channels into individual
    bits of communication or a package of communications depends on the aggregate
    mutability of each.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you'll always want to send a counter along with a function or
    string and they will always be paired in terms of data consistency, such a method
    might make sense. If any of those components can lose synchronicity en route,
    it's more logical to keep each piece independent.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Maps in Go**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, maps in Go are like hash tables elsewhere and immediately related
    to slices or arrays.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example we were checking to see if a username/key exists already;
    for this purpose Go provides a simple method for doing so. When attempting to
    retrieve a hash with a nonexistent key, a zero value is returned, as shown in
    the following lines of code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This makes it syntactically simple and clean to test against a map and its keys.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: One of the best features of maps in Go is the ability to make keys out of any
    comparable type, which includes strings, integers, Booleans as well as any map,
    struct, slice, or channel that is comprised exclusively of those types.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: This one-to-many channel can work as a master-slave or broadcaster-subscriber
    model. We'll have a channel that listens for messages and routes them to appropriate
    users and a channel that listens for broadcast messages and queues them to all
    users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: To best demonstrate this, we'll create a simple multiuser chat system that allows
    Twitter style `@user` communication with a single user, with the ability to broadcast
    standard messages to all users and creates a universal broadcast chat note that
    can be read by all users. Both will be simple, custom type struct channels, so
    we can delineate various communication pieces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Structs in Go**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: As a first-class, anonymous, and extensible type, a struct is one of the most
    versatile and useful data constructs available. It's simple to create analogs
    to other data structures such as databases and data stores, and while we hesitate
    to call them objects they can certainly be viewed as such.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule of thumb as it pertains to using structs within functions is to pass
    by reference rather than by value if the struct is particularly complex. Two points
    of clarification are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Reference is in quotations because (and this is validated by Go's FAQ) technically
    everything in Go is passed by value. By that we mean that though a reference to
    a pointer still exists, at some step in the process the value(s) is copied.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Particularly complex" is, understandably, tough to quantify, so personal judgment
    might come into play. However, we can consider a simple struct one with no more
    than five methods or properties.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can think of this in terms of a help desk system, and while in the present
    day we'd be unlikely to create a command-line interface for such a thing, eschewing
    the web portion allows us to gloss over all of the client-side code that isn't
    necessarily relevant to Go.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: You could certainly take such an example and extrapolate it to the Web utilizing
    some frontend libraries for asynchronous functionality (such as `backbone.js`
    or `socket.io`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we'll need to create both a client and a server application,
    and we'll try to keep each as bare bone as possible. You can clearly and simply
    augment this to include any functionality you see fit such as making Git comments
    and updating a website.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the server, which will be the most complicated part. The client
    application will mostly receive messages back through the socket, so much of the
    reading and routing logic will be invisible to the client-side of the process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The net package – a chat server with interfaced channels
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we'll need to introduce a relevant package that will be required to handle
    most of the communication for our application(s). We've touched on the `net` package
    a bit while dabbling in the SVG output generation example to show concurrency—`net`/`http`
    is just a small part of a broader, more complex, and more feature-full package.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The basic components that we'll be using will be a TCP listener (server) and
    a TCP dialer (client). Let's look at the basic setup for these.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Server**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Listening on a TCP port couldn''t be easier. Simply initiate the `net.Listen()`
    method and handle the error as shown in the following lines of code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you get an error starting the server, check your firewall or modify the port—it's
    possible that something is utilizing port 9000 on your system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: As easy as that is, it's just as simple on our client/dialer side.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have everything running on localhost as shown in the following
    lines of code. However, in a real-world application we''d probably have an intranet
    address used here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this application, we demonstrate two different ways to handle byte buffers
    of unknown lengths on `Read()`. The first is a rather crude method of trimming
    a string using `strings.TrimRight()`. This method allows you to define characters
    you aren't interested in counting as part of the input as shown in the following
    line of code. Mostly, it's whitespace characters that we can assume are unused
    parts of the buffer length.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dealing with strings this way is often both inelegant and unreliable. What happens
    if we get something we don't expect here? The string will be the length of the
    buffer, which in this case is 140 bytes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way we deal with this is by using the end of the buffer directly.
    In this case, we assign the `n` variable to the `conn.Read()` function, and then
    can use that as a buffer length in the string to buffer conversion as shown in
    the following lines of code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we're taking the first `n` bytes of the message buffer's received value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: This is more reliable and efficient, but you will certainly run into text ingestion
    cases where you will want to remove certain characters to create cleaner input.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Each connection in this application is a struct and each user is as well. We
    keep track of our users by pushing them to the `Users` slice as they join.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The selected username is a command-line argument as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We do not check to to ensure there is only one user with that name, so that
    logic might be required, particularly if chats with direct messages contain sensitive
    information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Handling direct messages
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the most part, this chat client is a simple echo server, but as mentioned,
    we also include an ability to do non-globally broadcast messages by invoking the
    Twitter style `@` syntax.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: We handle this mainly through regular expressions, wherein if a message matches
    `@user` then only that user will see the message; otherwise, it's broadcasted
    to all. This is somewhat inelegant, because senders of the direct message will
    not see their own direct message if their usernames do not match the intended
    names of the users.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we direct every message through a `evalMessageRecipient()` function
    before broadcasting. As this is relying on user input to create the regular expression
    (in the form of the username), please take note that we should escape this with
    the `regexp.QuoteMeta()` method to prevent regex failures.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first examine our chat server, which is responsible for maintaining
    all connections and passing them to goroutines to listen and receive, as shown
    in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We utilize a maximum character buffer. This restricts our chat messages to
    no more than 140 characters. Let''s look at our `User` struct to see the information
    we might keep about a user that joins, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The initiated variable tells us that `User` is connected after a connection
    and announcement. Let''s examine the following code to understand the way we''d
    listen on a channel for a logged-in user:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the core of our server: each `User` gets its own `Listen()` method,
    which maintains the `User` struct''s channel and sends and receives messages across
    it. Put simply, each user gets a concurrent channel of his or her own. Let''s
    take a look at the `ConnectionManager` struct and the `Initiate()` function that
    creates our server in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `ConnectionManager` struct is initiated just once. This sets some relatively
    ornamental attributes, some of which could be returned on request or on chat login.
    We''ll examine the `evalMessageRecipient` function that attempts to roughly identify
    the intended recipient of any message sent as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is our router of sorts taking the `@` part of the string and using it to
    detect an intended recipient to hide from public consumption. We do not return
    an error if the user doesn't exist or has left the chat.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The format for regular expressions using the `regexp` package relies on the
    `re2` syntax, which is described at [https://code.google.com/p/re2/wiki/Syntax](https://code.google.com/p/re2/wiki/Syntax).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code for the `Listen()` method of the `ConnectionManager`
    struct:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As expected, `main()` primarily handles the connection and error and keeps our
    server open and nonblocked with the `serverClosed` channel.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of methods we could employ to improve the way we route messages.
    The first method would be to invoke a map (or hash table) bound to a username.
    If the map''s key exists, we could return some error functionality if a user already
    exists, as shown in the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Examining our client
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our client application is a bit simpler primarily because we don't care as much
    about blocking code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: While we do have two concurrent operations (wait for the message and wait for
    user input to send the message), this is significantly less complicated than our
    server, which needs to concurrently listen to each created user and distribute
    sent messages, respectively.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now compare our chat client to our chat server. Obviously, the client
    has less overall maintenance of connections and users, and so we do not need to
    use nearly as many channels. Let''s take a look at our chat client''s code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Blocking method 2 – the select statement in a loop
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you noticed yet that the `select` statement itself blocks? Fundamentally,
    the `select` statement is not different from an open listening channel; it's just
    wrapped in conditional code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<- myChannel` channel operates the same way as the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An open listening channel is not a deadlock as long as there are no goroutines
    sleeping. You'll find this on channels that are listening but will never receive
    anything, which is another method of basically waiting.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: These are useful shortcuts for long-running applications you wish to keep alive
    but you may not necessarily need to send anything along that channel.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up goroutines
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any channel that is left waiting and/or left receiving will result in a deadlock.
    Luckily, Go is pretty adept at recognizing these and you will almost without fail
    end up in a panic when running or building the application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Many of our examples so far have utilized the deferred `close()` method of immediately
    and cleanly grouping together similar pieces of code that should execute at different
    points.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: While garbage collection handles a lot of the cleanup, we're largely left to
    take care of open channels to ensure we don't have a process waiting to receive
    and/or something waiting to send, both waiting at the same time for each other.
    Luckily, we'll be unable to compile any such program with a detectable deadlock
    condition, but we also need to manage closing channels that are left waiting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite a few of the examples so far have ended with a generic integer or Boolean
    channel that just waits—this is employed almost exclusively for the channel''s
    blocking effect and allows us to demonstrate the effects and output of concurrent
    code while the application is still running. In many cases, this generic channel
    is an unnecessary bit of syntactical cruft as shown in the following lines of
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The fact that there''s no assignment happening is a good indicator this is
    an example of such cruft. If we had instead modified that to include an assignment,
    the previous code would be changed to the following instead:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It might indicate that the value is useful and not just arbitrary blocking code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Blocking method 3 – network connections and reads
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you run the code from our earlier chat server's client without starting the
    server, you'll notice that the `Dial` function blocks any subsequent goroutine.
    We can test this by imposing a longer-than-normal timeout on the connection or
    by simply closing the client application after logging in, as we did not implement
    a method for closing the TCP connection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: As the network reader we're using for the connection is buffered, we'll always
    have a blocking mechanism while waiting for data via TCP.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Creating channels of channels
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preferred and sanctioned way of managing concurrency and state is exclusively
    through channels.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve demonstrated a few more complex types of channels, but we haven''t looked
    at what can become a daunting but powerful implementation: channels of channels.
    This might at first sound like some unmanageable wormhole, but in some situations
    we want a concurrent action to generate more concurrent actions; thus, our goroutines
    should be capable of spawning their own.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: As always, the way you manage this is through design while the actual code may
    simply be an aesthetic byproduct here. Building an application this way should
    make your code more concise and clean most of the time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit a previous example of an RSS feed reader to demonstrate how
    we could manage this, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we manage `feedChannel` as a custom struct that is itself a channel for
    our `Item` type. This allows us to rely exclusively on channels for synchronization
    handled through a semaphore-esque construct.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: If we want to look at another way of handling a lower-level synchronization,
    `sync.atomic` provides some simple iterative patterns that allow you to manage
    synchronization directly in memory.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: As per Go's documentation, these operations require great care and are prone
    to data consistency errors, but if you need to touch memory directly, this is
    the way to do it. When we talk about advanced concurrency features, we'll utilize
    this package directly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Pprof – yet another awesome tool
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just when you think you've seen the entire spectrum of Go's amazing tool set,
    there's always one more utility that, once you realize it exists, you'll wonder
    how you ever survived without it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Go format is great for cleaning up your code; the `-race` flag is essential
    for detecting possible race conditions, but an even more robust, hands-in-the-dirt
    tool exists that is used to analyze your final application, and that is pprof.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Google created pprof initially to analyze loop structures and memory allocation
    (and related types) for C++ applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: It's particularly useful if you think you have performance issues not uncovered
    by the testing tools provided in the Go runtime. It's also a fantastic way to
    generate a visual representation of the data structures in any application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Some of this functionality also exists as part of the Go testing package and
    its benchmarking tools—we'll explore that more in [Chapter 7](part0060_split_000.html#page
    "Chapter 7. Performance and Scalability"), *Performance and Scalability*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Getting the runtime version of pprof to work requires a few pieces of setup
    first. We'll need to include the `runtime.pprof` package and the `flag` package,
    which allows command-line parsing (in this case, for the output of pprof).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: If we take our chat server code, we can add a couple of lines and have the application
    prepped for performance profiling.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure we include those two packages along with our other packages.
    We can use the underscore syntax to indicate to the compiler that we''re only
    interested in the package''s side effects (meaning we get the package''s initialization
    functions and global variables) as shown in the following lines of code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells our application to generate a CPU profiler if it does not exist,
    start the profiling at the beginning of the execution, and defer the end of the
    profiling until the application exits successfully.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'With this created, we can run our binary with the `cpuprofile` flag, which
    tells the program to generate a profile file as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the sake of variety (and exploiting more resources arbitrarily), we''ll
    abandon the chat server for a moment and create a loop generating scores of goroutines
    before exiting. This should give us a more exciting demonstration of profiling
    data than a simple and long-living chat server would, although we''ll return to
    that briefly:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our example code that generates more detailed and interesting profiling
    data:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we generate a profile file out of this, we can run the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will start the pprof application itself. This gives us a few commands
    that report on the static, generated file as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`topN`: This shows the top *N* samples from the profile file, where *N* represents
    the explicit number you want to see.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web`: This creates a visualization of data, exports it to SVG, and opens it
    in a web browser. To get the SVG output, you''ll need to install Graphviz as well
    ([http://www.graphviz.org/](http://www.graphviz.org/)).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also run pprof with some flags directly to output in several formats
    or launch a browser as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`--text`: This generates a text report'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--web`: This generates an SVG and opens in the browser'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--gv`: This generates the Ghostview postscript'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--pdf`: This generates the PDF to output'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--SVG`: This generates the SVG to output'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--gif`: This generates the GIF to output'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command-line results will be telling enough, but it's especially interesting
    to see the blocking profile of your application presented in a descriptive, visual
    way as shown in the following figure. When you're in the pprof tool, just type
    in `web` and a browser will spawn with the CPU profiling detailed in SVG form.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Pprof – yet another awesome tool](img/00025.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: The idea here is less about the text and more about the complexity
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: And voila, we suddenly have an insight into how our program utilizes the CPU
    time consumption and a general view of how our application executes, loops, and
    exits.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In typical Go fashion, the pprof tool also exists in the `net`/`http` package,
    although it's more data-centric than visual. This means that rather than dealing
    exclusively with a command-line tool, you can output the results directly to the
    Web for analysis.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the command-line tool, you''ll see block, goroutine, heap, and thread
    profiles as well as a full stack outline directly through localhost, as shown
    in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Pprof – yet another awesome tool](img/00026.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: To generate this server, you just need to include a few key lines of code in
    your application, build it, and then run it. For this example, we've included
    the code in our chat server application, which allows us to get the Web view of
    an otherwise command-line-only application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have the `net`/`http` and `log` packages included. You''ll also
    need the `http`/`pprof` package. The code snippet is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then simply include this code somewhere in your application, ideally, near
    the top of the `main()` function, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As always, the port is entirely a matter of preference.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then find a number of profiling tools at `localhost:6060`, including
    the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: All tools can be found at `http://localhost:6060/debug/pprof/`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking profiles cab be found at `http://localhost:6060/debug/pprof/block?debug=1`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A profile of all goroutines can be found at `http://localhost:6060/debug/pprof/goroutine?debug=1`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed profile of the heap can be found at `http://localhost:6060/debug/pprof/heap?debug=1`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A profile of threads created can be found at `http://localhost:6060/debug/pprof/threadcreate?debug=1`
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the blocking profile, you may find a utility to track down inefficiency
    in your concurrent strategy through the thread creation profile. If you find a
    seemingly abnormal amount of threads created, you can toy with the synchronization
    structure as well as runtime parameters to streamline this.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that using pprof this way will also include some analyses and
    profiles that can be attributed to the `http` or `pprof` packages rather than
    your core code. You will find certain lines that are quite obviously not part
    of your application; for example, a thread creation analysis of our chat server
    includes a few telling lines, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given that we specifically eschewed delivering our chat application via HTTP
    or web sockets in this iteration, this should be fairly evident.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, there are even more obvious smoking guns, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Some system and Go core mechanisms we will never be able to reduce out of our
    final compiled binaries are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hexadecimal value represents the address in the memory of the function when
    run.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A note for Windows users: pprof is a breeze to use in *nix environments but
    may take some more arduous tweaking under Windows. Specifically, you may need
    a bash replacement such as Cygwin. You may also find some necessary tweaks to
    pprof itself (in actuality, a Perl script) may be in order. For 64-bit Windows
    users, make sure you install ActivePerl and execute the pprof Perl script directly
    using the 64-bit version of Perl.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: At publish time, there are also some issues running this on 64-bit OSX.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Handling deadlocks and errors
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anytime you encounter a deadlock error upon compilation in your code, you'll
    see the familiar string of semi-cryptic errors explaining which goroutine was
    left holding the bag, so to speak.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'However, keep in mind you always have the ability to invoke your own panic
    using Go''s built-in panic, and this can be incredibly useful for building your
    own error-catching safeguards to ensure data consistency and ideal operation.
    The code is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This can be utilized anywhere you wish to give detailed exit information to
    either developers or end users.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having explored some new ways to examine the way that Go code can block and
    deadlock, we also have some tools at our disposal that can be used to examine
    CPU profiles and resource usage now.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by this point, you can build some complex concurrent systems with
    simple goroutines and channels all the way up to multiplexed channels of structs,
    interfaces, and other channels.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到这一点，你可以用简单的goroutines和通道构建一些复杂的并发系统，一直到结构体、接口和其他通道的复用通道。
- en: We've built some somewhat-functional applications so far, but next we're going
    to utilize everything we've done to build a usable web server that solves a classic
    problem and can be used to design intranets, file storage systems, and more.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一些功能上比较完善的应用程序，但接下来我们将利用我们所做的一切来构建一个可用的Web服务器，解决一个经典问题，并可用于设计内部网络、文件存储系统等。
- en: 'In the next chapter, we''ll take what we''ve done in this chapter with regard
    to extensible channels and apply it to solving one of the oldest challenges the
    Internet has to offer: concurrently serving 10,000 (or more) connections.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把我们在本章中所做的关于可扩展通道的工作应用到解决互联网所面临的最古老的挑战之一：同时为10,000（或更多）个连接提供服务。
