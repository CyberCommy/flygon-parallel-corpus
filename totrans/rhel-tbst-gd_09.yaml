- en: Chapter 9. Using System Tools to Troubleshoot Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered troubleshooting hardware issues. Specifically,
    you learned what to do when hard disks have been removed from a RAID and cannot
    be read.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will get back to troubleshooting applications, but unlike
    earlier examples, we will not be troubleshooting a popular open source application
    such as WordPress. In this chapter, we will focus on a custom application that
    will be much more difficult to troubleshoot than a well-known one.
  prefs: []
  type: TYPE_NORMAL
- en: Open source versus home-grown applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Popular open source projects often have an online community or bug/issue tracker.
    As we experienced in [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    these can be useful resources for troubleshooting application issues. Often, the
    issue has already been reported or asked about in these communities, with the
    majority of these posts also containing a solution for the issue.
  prefs: []
  type: TYPE_NORMAL
- en: These solutions are posted on the Internet in open forums; any errors from the
    application can also simply be searched for on Google. Most of the time, the search
    will show multiple possible answers. It is a pretty rare occurrence when an error
    from a popular open source application produces zero search results on Google.
  prefs: []
  type: TYPE_NORMAL
- en: With custom applications, however, application errors might not always be resolved
    with a quick Google search. Sometimes, an application provides a generic error
    such as **Permission Denied** or **File not found**. On other occasions, however,
    they produce no error or application-specific errors such as the issue we will
    be working with today.
  prefs: []
  type: TYPE_NORMAL
- en: When faced with nondescriptive errors in open source tools, you can always ask
    for help on an online site of some sort. With custom applications, however, you
    might not always have the option of asking a developer what the error means.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is up to the systems administrator to fix the application with
    little to no help from the developer.
  prefs: []
  type: TYPE_NORMAL
- en: When those situations occur, there are a myriad of tools at the administrator's
    disposal. In today's chapter, we will be exploring some of these tools while,
    of course, troubleshooting a custom application.
  prefs: []
  type: TYPE_NORMAL
- en: When the application won't start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter's problem, we will start as we have with most other problems,
    except today, rather than receiving an alert or phone call, we are actually asked
    a question by another systems administrator.
  prefs: []
  type: TYPE_NORMAL
- en: The systems administrator is attempting to start an application on the blog
    web server. When they attempt to start the application, it appears to be starting;
    however, at the end, it simply prints an error message and exits.
  prefs: []
  type: TYPE_NORMAL
- en: Our first response to this scenario is of course the first step in the troubleshooting
    process—duplicate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other systems administrator informs us that they are starting the application
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging into the server as the `vagrant` user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving to the directory `/opt/myapp`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the script `start.sh`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before going any further, let''s attempt those same steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding steps, we follow the same steps as the previous administrator
    and get the same results. The application appears to have failed to start.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `whoami` command was used to show that we were
    logged in as the `vagrant` user. This command is very handy when dealing with
    applications as it can be used to ensure the proper system user is performing
    the start process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see from the preceding startup attempt that the application failed to
    start with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, we need to know why it failed to start and whether the process truly
    failed
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer the question on whether the process truly failed or not is actually
    quite simple. To do this, we can simply check the exit code of the application,
    which is done by printing the `$?` variable after executing the `start.sh` script,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Exit codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Linux and Unix systems, programs have the ability to pass a value to their
    parent process while they terminate. This value is called an **exit code**. Programs
    that are terminating or "exiting" use exit codes to tell the process that invoked
    it whether that program was successful or unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: For POSIX systems (such as Red Hat Enterprise Linux), the standard convention
    is for programs to exit with a 0 status code for success and a non-zero status
    code for failure. Since our preceding example exited with a status code of 1,
    this means the application exited with a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand exit codes a little better, let''s write a quick little script
    that performs a successful task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This quick little shell script performs one task, it runs the `touch` command
    on the file `/var/tmp/file.txt`. If that file exists, the touch command simply
    updates the access time on that file. If the file does not exist, the touch command
    will create it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `/var/tmp` is a temporary directory with open permissions, this script,
    when executed as the vagrant user, should be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After executing the command, we can see the exit code by using the BASH special
    variable `$?`. This variable is a special variable in the BASH shell that can
    only be used to read the exit code of the last program executed. This variable
    is one of a few special variables in the BASH shell that can only be read and
    never written.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the exit status of our script, we can `echo` the value of `$?` to our
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like this script returned a `0` exit status. This means the script
    executed successfully and most likely updated or created the file `/var/tmp/file.txt`.
    We can validate that the file was updated by performing an `ls -la` on the file
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the output of the `ls` command, it appears the file was updated or created
    recently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example shows what happens when a script is successful, but what
    about when the script is unsuccessful? With a modified version of the preceding
    script, we can easily see what happens when a script fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified version will attempt to create a file in a directory that does
    not exist. That script will then fail and exit with an exit code that indicates
    failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the output of the script that the `touch` command failed, but
    what about the exit code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The exit code also shows that the script has failed. The standard for exit
    codes is `0` for a success and anything non-zero is a failure. In general, you
    will see either a `0` or `1` exit code. Some applications, however, will use other
    exit codes to indicate specific failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we were to execute a command that does not exist from the BASH
    shell, the exit code provided will be `127`. This exit code is a convention used
    to indicate that the command was not found. The following is a list of exit codes
    that are used for specific purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: Success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: General failure has occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: Misuse of shell built-ins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`126`: Command invoked could not be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`127`: Command not found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`128`: Invalid argument passed to the `exit` command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`130`: Command stopped with *Ctrl* + *C* keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`255`: Exit code provided is out of the `0 - 255` range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is a good general guide for exit codes. However, since each application
    can provide its own exit codes you might find that a command or application provides
    an exit code that is not within the preceding list. For open source applications,
    you can generally look up what the exit code means. For custom applications, however,
    you may or may not have the ability to look up what the exit codes means.
  prefs: []
  type: TYPE_NORMAL
- en: Is the script failing, or the application?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One interesting thing about shell scripts and exit codes is that when a shell
    script is executed, the exit code for that script will be the exit code of the
    last command executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put this in perspective, we can modify our test script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command should produce an interesting result. The `touch` command
    will fail; however, the echo command will be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that when executed, even though the `touch` command fails,
    the `echo` command is successful so the exit code from the command line should
    show the script as successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command is an example of a script that does not handle errors
    gracefully. If we were to rely on this script to provide us with the correct status
    of the execution solely by the exit code, we would have incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: It is always good for a systems administrator to be a bit skeptical of unknown
    scripts. I have found many occasions (and written a few myself) where scripts
    have no error checking. For this reason, one of the first steps we should perform
    with our issue is to validate that the exit code of 1 is actually coming from
    the application being launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will need to read the start script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From the look of things, the start script is very basic. It looks like the script
    simply sets the `$HOMEDIR` variable to `/opt/myapp` and then runs the application
    by running the command `$HOMEDIR/bin/application`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the value of `$HOMEDIR` is set to `/opt/myapp`, you can assume that any
    future reference to `$HOMEDIR` is actually the value `/opt/myapp`.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding script, we can see that the last command executed is the
    application, meaning the exit code we received was from the application and not
    another command. This proves that we are receiving the true exit status of this
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start script does provide us with a bit more information than just which
    command provides the exit code. If we take a look at the application''s command
    line parameters, we can understand even more about this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is the command that actually starts the application within the `start.sh`
    script. The script is running the command `/opt/myapp/bin/application` with the
    arguments `--daemon` and `--config /opt/myapp/conf/config.yml`. While we might
    not know much about this application, we can make some assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: One assumption we can make is that the `--daemon` flag causes this application
    to daemonize itself. On Unix and Linux systems, a process that runs continuously
    as a background process is referred to as a daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a daemon process is a service that doesn't require user input. A
    few easily recognizable examples of daemons are Apache or MySQL. These processes
    run in the background and perform a service rather than running in a user's desktop
    or shell.
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding flag, we can safely assume that this process is designed
    to run in the background once it is started successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Another assumption we can make based on the command line parameters is that
    the file `/opt/myapp/conf/config.yml` is used as a configuration file for the
    application. This seems pretty straightforward considering the flag is named `--config`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding assumptions are pretty easy to recognize because the flags use
    the long format `--option`. However, not all applications or services use the
    long format for command line flags. Often, these are single character flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'While every application has its own command line flags and might differ from
    application to application, common flags such as `--config` and `--deamon` are
    often shortened to `-c` and `-d` or `-D`. If our application was provided with
    single character flags, it would have looked more like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Even with the shortened options, we can safely identify that `-c` specifies
    a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: A wealth of information in the configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that this application is using the configuration file `/opt/myapp/conf/config.yml`.
    If we read this file, we might find information about the application and what
    task it is trying to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The configuration file for this application is quite short, but there is quite
    a bit of useful information within it. The first configuration item is interesting,
    as it seems to specify port `25` as a port for the application to use. Without
    knowing exactly what this application does, this information is not immediately
    useful but might be useful to us later.
  prefs: []
  type: TYPE_NORMAL
- en: The second item seems to suggest the application is in a debug mode. Often applications
    or services might have a `debug` mode, which causes them to log or output debugging
    information for troubleshooting. In our case, it seems the debug option is enabled,
    as the value of this item is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The third and final item is what appears to be a directory path for logs. Log
    files are always useful for troubleshooting applications. Often, you are able
    to find information about the application issue within log files. This is especially
    true if the application is in a `debug` state, which appears to be the case for
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our application seems to be in the `debug` mode and we know the location
    of the log directory. We can check that log directory for any log files that might
    have been created during the application''s start process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run an `ls -la` in the log directory, we can see a `debug.out` file.
    Based on the name, this file is most likely the debug output from the application
    but not necessarily the application''s primary log file. This file, however, might
    be even more useful than a standard log as it might contain the reason the application
    startup is failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Based on the contents of this file it appears that this file contains logs from
    multiple executions of this application. We can see this based on a repeated pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This seems to be the first item printed each time the application starts. We
    can see these lines a total of four times; most likely, this means this application
    has been started at least four times in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this file, we can see an important log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It seems that the second time this application was started the application startup
    was successful. However, each time it was started afterwards the application failed.
  prefs: []
  type: TYPE_NORMAL
- en: Watching log files during startup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the debug file's contents do not include timestamps, it is somewhat difficult
    to know whether the debug output from this file was written when we started the
    application or during a previous startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we don''t know which lines were written during our last attempt as compared
    to other attempts, we will need to try and identify how many log entries are written
    each time the application is started. To do this, we can use the `tail` command
    with the `-f` or `--follow` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When first starting the `tail` command with the `-f` (follow) flag, the last
    10 lines of the file are printed. This is also the default behavior of tail if
    it is run with no flags.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `-f` flag doesn't simply stop at the last 10 lines. When run with
    the `-f` flag, `tail` will continuously monitor the specified file for new data.
    Once `tail` sees new data written to the specified file, the data will then be
    written to the output of `tail`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running tail `-f` against the `debug.out` file, we will be able to identify
    any new debug logs being written by the application. If we once again execute
    the `start.sh` script we should see any possible debug data being printed by the
    application during startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `start.sh` script''s output is the same as last time, which is not much
    of a surprise at this point. However, now that we are watching the `debug.out`
    file, we might find something useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `tail` command, we can see that the preceding three lines were printed
    during the execution of `start.sh`. While this in itself does not explain why
    the application is unable to start, it does tell us something interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Given that when the application fails to start, "`Failed`" messages from the
    preceding command are printed, and we can see that the last three times the `start.sh`
    script was executed, it failed. However, the instance before that was successful.
  prefs: []
  type: TYPE_NORMAL
- en: So far, I executed the start script twice and the other admin executed the script
    once. This would account for the three failures we see at the end of the `debug.out`
    file. The interesting thing about this is that the instance before those the application
    successfully started.
  prefs: []
  type: TYPE_NORMAL
- en: This is interesting because it indicates a strong possibility that a previous
    instance of the application might be running.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the application is already running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very common cause for this type of problem is simply that the application
    is already running. Some applications should only be started once, and the application
    itself will check whether another instance is running before completing a startup.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if this scenario were the case, we would expect the application
    to print an error to the screen or the `debug.out` file. However, not every application
    has appropriate error handling or messaging. This is especially true for custom
    applications, and it seems to be true for the application we are working with
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, we are making the assumption that our issue is caused by another
    instance of the application. This is an educated guess based on debug messages
    and previous experience. While we do not have any hard facts (yet) that tell us
    whether another instance is running or not; this scenario is quite common.
  prefs: []
  type: TYPE_NORMAL
- en: This situation is a perfect example of an **Educated Guesser** using previous
    experience to build a hypothesis of a root cause. Of course, after forming a hypothesis,
    our next step is to validate whether or not it is correct. Even if our hypothesis
    turns out to be incorrect we at least can eliminate a potential cause of our problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our current hypothesis is that we might already have an instance of the
    application running, we can validate it by executing the ps command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: From this, it appears that our hypothesis might be incorrect. However, the preceding
    command simply performs a process list and searches that output for any instance
    of the word application. While this command might be enough, some applications
    during startup (especially ones that daemonize) will launch another process that
    might not match the string "`application`".
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have been starting the application as the "`vagrant`" user it seems
    likely that even if the application daemonized, the processes would be running
    as the vagrant user. Using the same command we can also search the process list
    for processes running as the `vagrant` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command gave us quite a bit more output, but unfortunately none of these
    processes are the application we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Checking open files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding process list commands did not provide any results that would indicate
    that an instance of our application is running. However, before assuming that
    it is in fact not running we should perform one final check.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that the application we are working with appears to be installed
    into `/opt/myapp` and we can see both configuration files and logs within that
    directory.It is pretty safe to assume that the application in question might open
    one or more of the files located within `/opt/myapp`.
  prefs: []
  type: TYPE_NORMAL
- en: One very useful command is the **lsof** command. With this command, we can list
    all of the open files on the system. While this might not sound very powerful
    at first, let's take a detailed look at this command to understand how much information
    it can actually provide.
  prefs: []
  type: TYPE_NORMAL
- en: When running the `lsof` command, permissions become very critical to understand.
    When executing `lsof` with no parameters, the command will print a list of all
    open files for every process it can identify. If we run this command as an unprivileged
    user such as the "`vagrant`" user, the output will only consist of processes that
    are running as the vagrant user. If we run the command as the root user, however,
    this command will print open files for all processes on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put into perspective just how many files this translates to, we will run
    the `lsof` command and redirect the output to the `wc -l` command, which will
    count the number of lines provided in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From the `wc` command, we can see that there are currently `3840` files open
    on this system. Now some of these files might be duplicated, as it is possible
    for more than one process to open the same file. However, the sheer number of
    open files on this system is quite large. To put it in further perspective, this
    system is also a fairly underutilized system and is not running many applications
    in general. Do not be surprised if after executing the preceding commands on a
    well-utilized system the number of open files is exponentially higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since looking at `3840` open files is not very practical, let''s get a better
    understanding of `lsof` by taking a look at the first 10 files from the `lsof`
    output. We can do this by redirecting the command''s output to the `head` command,
    which, like the `tail` command, will print 10 lines by default. However, where
    the `tail` command prints the last 10 lines, the `head` command prints the first
    10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `lsof` command, when executed as the root, is able to provide
    us with quite a bit of useful information. Let''s just look at the first line
    of output to understand what `lsof` displays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `lsof` command prints 10 columns with each open file.
  prefs: []
  type: TYPE_NORMAL
- en: The first column is the `COMMAND` column. This field contains the name of the
    executable that has the file open. This is very useful when identifying which
    processes have a specific file open.
  prefs: []
  type: TYPE_NORMAL
- en: For our use case, this will tell us which processes have the files we are interested
    in open and might tell us the process name of the application we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: The second column is the `PID` column. This field is just as useful as the first
    as this shows the process ID of the application that has opened the files displayed.
    This value will allow us to narrow down the application to a specific process
    if it is in fact running.
  prefs: []
  type: TYPE_NORMAL
- en: The third column is the `TID` column, which in our output is blank. This column
    contains the thread ID of the process in question. In Linux, multithreaded applications
    are able to spawn threads, which are also known as lightweight processes. These
    threads are similar to a regular process but are able to share resources such
    as file descriptors and memory maps. You might hear these referred to as threads
    or lightweight processes but these are essentially the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: In order to see the `TID` field, we can add the `-K` (show threads) flag to
    the `lsof` command. This will cause `lsof` to print all of the lightweight processes
    as well as the full processes.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth column of the `lsof` output is the `USER` field. This field will
    print the username or `UID` (if a username is not found) of the process that has
    opened the file. It is important to know that this field is the user the process
    is executing and not the owner of the file itself.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a process running as `rotot` had opened a file owned by `vagrant`,
    the USER field in `lsof` will show root. The reason for this is because the `lsof`
    command is used to show which processes have files open and is utilized to display
    information about the process, not necessarily the files.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding file descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fifth column is very interesting as this is the field for **File Descriptor**
    (**FD**); which is a tricky Unix and Linux topic to understand.
  prefs: []
  type: TYPE_NORMAL
- en: File descriptors are part of the POSIX **application programming interface**
    (**API**), which is a standard that all modern Linux and Unix operating systems
    follow. From a program's perspective, the file descriptor is an object that is
    represented by a nonnegative number. This number is used as an identifier for
    a table of open files managed by the kernel on a per-process basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the kernel maintains this on a per-process level, the data is contained
    within the `/proc` file system. We can see this open file table by performing
    an `ls -la` in the `/proc/<process id>/fd` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is a file descriptor table for the `systemd` process. As you can see, there
    is a number and that number is linked to a file/object.
  prefs: []
  type: TYPE_NORMAL
- en: What is not easily represented in this output is that this is ever-changing.
    When a file/object is closed, the file descriptor number then becomes reusable
    for the kernel to assign it to a new open file/object. Depending on how often
    a process is opening and closing files, if we were to repeat the same ls, we might
    see a completely different set of open file in this table.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we would expect the FD field in `lsof` to always show a number. However,
    the FD field in the `lsof` output can actually contain more than just the file
    descriptor number. This is because `lsof` actually shows more open items than
    just files.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executed, the `lsof` command will print many different types of open objects;
    not all of these are files. An example of this can be seen in the first line of
    output from our `lsof` command earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding item is not a file, but rather a directory. Because this is a
    directory the FD field shows `cwd`, which is used to represent the current working
    directory of the open item. This is actually a very different output from what
    would be printed when the open item is a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better show the difference, we can run an `lsof` command against a specific
    file by providing the file as an argument to `lsof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we are able to not only see that many processes have
    `/dev/null` open, but that the `FD` field is quite different for each line. If
    we look at the first line, we can see that the `systemd` process has `/dev/null`
    open and that the `FD` field has a value of `0u`.
  prefs: []
  type: TYPE_NORMAL
- en: When `lsof` is displaying an open item that is a standard file, the `FD` field
    will contain the file descriptor number associated with that open file in the
    kernels table, `0` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look back at the `/proc/1/fd` directory, we can actually see this represented
    in the kernels table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The file descriptor number can potentially be followed by two more values depending
    on how the file is opened and whether it is locked.
  prefs: []
  type: TYPE_NORMAL
- en: The first potential value shows the mode that the file is opened in. From our
    example, this is represented by the `u` in the `0u` value. The lowercase `u` represents
    that the file is opened for both read and write access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of potential modes that `lsof` will display:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: The lowercase `r` represents that the file is opened for read only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: The lowercase `w` represents that the file is opened for writes only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: The lowercase `u` represents that the file is opened for both read and
    writes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<space>: The blank space is used to depict that the mode the file is open in
    is unknown and that there is no lock currently on the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: The hyphen is used to depict that the mode the file is open in is unknown
    and that there is currently a lock on the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two values are actually quite interesting as they bring us to the second
    potential value after the file descriptor number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes on Linux and Unix systems are allowed to request files to be locked
    when they are opened. There are multiple types of locks and this is shown in the
    `lsof` output as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `FD` field contained `10uW`. From the previous
    examples we know that 10 is the file descriptor number and that `u` denotes that
    this file is open for both read and write but the `W` is new. This W shows what
    type of lock the process has on this file; a write lock for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the file open mode, there are many different types of locks that can be
    seen from `lsof`. This is a list of possible locks shown by `lsof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`N`: This is used for Solaris NFS locks of unknown types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`: This is a read lock on part of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R`: This is a read lock on an entire file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: This is a write lock on part of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: This is a write lock on an entire file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: This is a read and write lock of any length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U`: This is a read and write lock of unknown type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`: This is a SCO Openserver Xenix lock of a partial file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X`: This is a SCO Openserver Xenix lock of a full file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might notice that there are several possible locks that are not Linux-specific.
    This is because `lsof` is a tool widely used in both Linux and Unix and supports
    many Unix distributions such as Solaris and SCO.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have covered how `lsof` displays the `FD` field for actual files,
    let''s take a look at how it displays open objects that are not necessarily files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can see quite a few different `FD` values in this list, such
    as `cwd`, `rtd`, `txt`, and `mem`. We already know from an earlier example that
    `cwd` is used to show a `Current Working Directory` but the others are quite new.
    There are actually quite a few possible file types depending on the object that
    is open. The following list contains all of the possible values that can be displayed
    if a file descriptor number is not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cwd`: Current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lnn`: Library reference for AIX systems (`nn` is a number value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err`: File descriptor information error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jld`: FreeBSD jailed directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ltx`: Shared library text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mxx`: Hex memory mapped (xx is a type number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m86`: DOS merged mapped file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mem`: Memory mapped file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mmap`: Memory mapped device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pd`: Parent directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rtd`: Root directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tr`: Kernel trace file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`txt`: Program text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v86`: VP/ix mapped file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see that there are many possible values for the `FD` field. Now that
    we have seen the possible values, let''s take a look at the preceding example
    to better understand what types of open items were shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines are interesting as they are both for the "`/`" directory.
    However, the first line shows the "`/`" directory as `cwd`, which means it is
    the current working directory. The second line shows the "`/`" directory as `rtd`,
    which means this is also the root directory for the `iprupdate` program.
  prefs: []
  type: TYPE_NORMAL
- en: The third line shows that `/usr/sbin/iprupdate` is the program itself as it
    has a `FD` field value of `txt`. This means the open file is the code of the program.
    The fourth line for the open item `/usr/lib64/libc-2.17.so` shows a FD of `mem`.
    This means the file `/usr/lib64/libc-2.17.so` has been read and placed into memory
    for the `iprupdate` process. This means that this file can be accessed as a memory
    object. This is a common practice for library files such as `libc-2.17.so`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to the lsof output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have thoroughly explored the FD field, let's move to the sixth column
    of the `lsof` output, the `TYPE` field. This field shows the type of file that
    is being opened. As there are quite a large number of possible types, it would
    be a bit tricky to list them here; however, you can always find this referenced
    in the `lsof` man page, which is accessible online or via the "`man lsof`" command.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we will not be listing every possible file type, we can take a quick
    look at a few file types captured from our example system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first example item shows a `TYPE` of `REG`. This `TYPE` is very common as
    the item being listed is a `Regular` file. The second example item shows **Character
    special file** (**CHR**). The CHR denotes special files that present themselves
    as files but are actually an interface for a device. The item listed `/dev/null`
    is a perfect example of a character file as it is used as input to nothing. Anything
    that is written to `/dev/null` is nullified and if you were to read this file,
    you would receive no output.
  prefs: []
  type: TYPE_NORMAL
- en: The third item shows `DIR`, it should not be a surprise that `DIR` stands for
    a directory. This is a very common `TYPE` as many processes at some level will
    require a directory to be opened.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth item shows `unix`, which shows that this open item is a Unix socket
    file. Unix socket files are special files that are used as input/output devices
    for process communication. These files should show up quite often in the `lsof`
    output.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding example, on Linux systems, there are several
    different types of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have looked at the sixth column of the output in `lsof`, the `TYPE`
    column, let''s take a quick look at the seventh, the `DEVICE` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the preceding item, we can see the `DEVICE` column has a value
    of `253,1`. These numbers represent the major and minor numbers of the device
    that this item is on. Major and minor numbers in Linux are used by the system
    to determine how a device is accessed. The major number, which in this case is
    `253`, is used to determine which driver the system should use. Once the driver
    is selected, the minor number, 1 in our case, is then used to narrow down how
    exactly this device should be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Major and minor numbers are actually an important part of Linux and how it uses
    devices. While we will not be covering this topic in depth within this book, it
    is something I would suggest learning more about as this information is incredibly
    useful when troubleshooting issues with hardware devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have explored the `DEVICE` column, let's take a look at the eighth
    column of the `lsof` output, `SIZE/OFF`. The `SIZE/OFF` column is used to display
    either the size of the open item or the **offset**. Offsets are generally displayed
    with devices such as socket files and character files. When this column contains
    an offset, it will be preceded with "`0t`". In the above example, we can see the
    character file `/dev/null` has an offset value of `0t0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `SIZE` value is used when referring to open items such as regular files.
    This value is actually the size of the file in bytes. For example, we can see
    that the `SIZE` column for `/usr/lib64/ld-2.17.so` is `160240`. This means this
    file is roughly 160 KB in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ninth column in the `lsof` output is the `NODE` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For regular files, the `NODE` column will show the **inode** number of the file.
    Within a filesystem, every file has an inode, this inode is used as an index that
    contains all of the individual files' metadata. This metadata consists of items
    such as the file's location on disk, file permissions, the creation time, and
    modification time of the file. Like major and minor numbers, I suggest taking
    a deeper dive into inodes and what they contain, as inodes are a core component
    to how files exist on a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: You can see, from the first item in the preceding example, the inode of `/var/log/httpd/error_log`
    is `134812768`.
  prefs: []
  type: TYPE_NORMAL
- en: The second line, however, shows the `NODE` as TCP, which is not an inode. The
    reason it shows TCP is because the open item is a TCP Socket, which is not a file
    on a filesystem. Like the `TYPE` column, the `NODE` column will change based on
    the open item. However, on most systems, you will generally see an inode number,
    TCP or UDP (for UDP Sockets).
  prefs: []
  type: TYPE_NORMAL
- en: 'The tenth and final column in the `lsof` output is pretty self-explanatory,
    as we have referenced it several times already. The tenth column is the `NAME`
    field, which is as simple as it sounds; it lists the name of the open item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using lsof to check whether we have a previously running process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know a lot more about how `lsof` works and how it can help us, let's
    use this command to check whether there are any running instances of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simply ran the `lsof` command as the root user, we would see all of the
    open files on this system. However, that output can be quite overwhelming even
    when we redirect the output to commands such as `less` or `grep`. Luckily, `lsof`
    will allow us to specify files and directories to look for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, by specifying a file in the preceding command, we limited the
    output to processes that have the file open.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we specify a directory, the output is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see that two processes have the `/opt/myapp` directory open.
    Another way we could limit the output of `lsof` is to specify the `+D` (directory
    contents) flag, followed by a directory. This flag will tell `lsof` to look for
    any open items from that directory and below.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we saw that when using `lsof` against the configuration file, the
    `less` process had it opened. We could also see that when used against the `/opt/myapp/`
    directory, two processes had the directory open.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see all of these items with just one command using the `+D` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This would also show us any other items located under the `/opt/myapp` directory.
    Since we are looking to check whether another instance of the application is running
    let''s take a look at the preceding `lsof` output and see what can be learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first open item shows a process of `bash`, running as the `vagrant` user
    with a file descriptor of a current working directory. This line is most likely
    our own `bash` process that is currently in the `/opt/myapp` directory, currently
    executing the less command on the `/opt/myapp/conf/config.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check this by using the `ps` command and `grep` for the string `3474`,
    the process ID of the `bash` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'I opted to use the `grep` command in this case, as we will also be able to
    see any child processes that reference process ID `3474`. The same thing can be
    performed without the `grep` command as well by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Overall, both produce the same results; however, the first method is easier
    to remember.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the process list output, we can see that the `bash` command is
    in fact related to our shell as its child process is the `less` command that we
    know we have running in another window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the process ID of the `less` command: `3509`. The same process
    ID is shown in the `less` command in the `lsof` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Since the output only shows our own processes, it is safe to assume that there
    is not a previous application instance running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out more about the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know that the problem is not that another instance of this application
    is running. At this point, we should try and identify more about this application
    and what it is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do when trying to find out more information about this application
    is to see what type of file the application is. We can do this by using the `file`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `file` command is a very useful command to have in your tool belt, as this
    command will identify the file type of the file being specified. In the preceding
    example, we can see that the "`application`" file is a compiled binary. We can
    see that it is compiled by this particular output: `ELF 64-bit LSB executable`.'
  prefs: []
  type: TYPE_NORMAL
- en: This line also tells us that the application is compiled as a 64-bit application.
    This is interesting as there are quite a few differences between 64-bit and 32-bit
    applications. One very common scenario is due to the amount of resources a 64-bit
    application can consume; 32-bit applications are often much more limited than
    a 64-bit version.
  prefs: []
  type: TYPE_NORMAL
- en: Another common issue is when trying to execute a 64-bit application on a 32-bit
    kernel. We have yet to validate whether we are running on a 64-bit kernel; if
    we are attempting to run a 64-bit executable with a 32-bit kernel, we are bound
    to receive some errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of errors seen by trying to execute a 64-bit application on a 32-bit
    kernel are pretty specific and not very likely to be the cause of our issue. Even
    though it is not a likely cause, we can check whether the kernel is a 64-bit kernel
    or not with the `uname –a` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: From the output of the uname `-a` command, we can see that the kernel is in
    fact a 64-bit kernel by the presence of this string "`x86_64`".
  prefs: []
  type: TYPE_NORMAL
- en: Tracing an application with strace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we know that the application is a compiled binary and we do not have the
    source code, this makes reading the code within the application fairly difficult.
    What we can do, however, is trace the system calls that the application is performing
    to see if we can find any information as to why it is not starting.
  prefs: []
  type: TYPE_NORMAL
- en: What is a system call?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**System calls** are the primary interface between an application and the kernel.
    Simply put, a system call is a method of requesting the kernel to perform an action.'
  prefs: []
  type: TYPE_NORMAL
- en: Most applications do not need to worry about system calls, as system calls are
    generally called by low-level libraries, such as the GNU C Library. While the
    programmer need not worry about system calls, it is important to know that every
    action performed by an application drills down to some sort of system call.
  prefs: []
  type: TYPE_NORMAL
- en: This is important to know because we can trace these system calls to determine
    what exactly an application is doing. Much like we use `tcpdump` to trace network
    traffic on a system, we can use a command called `strace` to trace the system
    calls of a process.
  prefs: []
  type: TYPE_NORMAL
- en: To get the feel of `strace`, let's use `strace` to perform a system call trace
    on our `exitcodes.sh` script from earlier. To do this, we will run the `strace`
    command followed by the `exitcodes.sh` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executed, the `strace` command will start up and then execute the `exitcodes.sh`
    script. While the `exitcodes.sh` script is running, the `strace` command will
    print every system call and the arguments provided to them from the `exitcodes.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only a small portion of the output from `strace`. The full output is
    actually several pages long. However, the `exitcodes.sh` script isn''t very long.
    In fact, it''s a simple three-line script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This script is a good example as to how much heavy lifting higher-level programming
    languages, such as bash, provide. Now that we know what the `exitcodes.sh` script
    does, let's take a look at some of the system calls it performs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the first eight lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As system calls are quite extensive and some of them are complicated to understand.
    We will focus our breakdown on system calls that are common and a bit easier to
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first system call that we will examine is the `access()` system call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Most system calls have a name that roughly explains the function it performs.
    The `access()` system call is no different, as this system call is used to check
    whether the application calling it has sufficient access to open the file specified.
    In the preceding example, the file specified is `/etc/ld.so.preload`.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing about `strace` is not only does it show the system call,
    it also shows the return value. In our preceding example, the `access()` system
    call received a return value of `-1`, which is the typical value for errors. When
    the return value is an error, `strace` will also provide the error string. In
    this case, the `access()` call received the error `-1 ENOENT (No such file or
    directory)`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding error is pretty self-explanatory, as it seems the file `/etc/ld.so.preload`
    simply does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next system call is one that will be seen quite often; it is the `open()`
    system call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `open()` system call performs just what it says, it is used to open (or
    create and open) a file or device. From the preceding example, we can see that
    the file specified is the `/etc/ld.so.cache` file. We can also see that one of
    the arguments passed to this system call is "`O_RDONLY`". This argument tells
    the `open()` call to open the file in the read only mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if we didn''t already know that the `O_RDONLY` argument tells the open
    command to open the file in read only, the name is almost self-descriptive. For
    system calls that are not self-descriptive, the information can be found with
    a fairly quick Google search, as system calls are very well documented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The next system call to look at is the `fstat()` system call. This system call
    will pull the status of a file. The information this system call provides includes
    things such as the inode number, user ownership, and size of the file. By itself,
    the `fstat()` system call might not look very important but when we look at the
    next system call, `mmap()`, the information it provides can be important.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This system call can be used to map or unmap a file into memory. If we look
    at the `fstat()` line and look at the `mmap()` line, we will see two numbers that
    coincide. The fstat() line has `st_size=24646`, which is the second argument provided
    to `mmap()`.
  prefs: []
  type: TYPE_NORMAL
- en: Even without knowing the details of these system calls it is pretty easy to
    build the assumption that the `mmap()` system call mapped the file from the `fstat()`
    call into the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final system call from the preceding example is very simple to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `close()` system call simply closes the open file or device. Given that
    earlier we opened the file `/etc/ld.so.cache`, it only makes sense that this `close()`
    system call was used to close that file. Before we get back to debugging our application,
    let''s take a quick look at the last four lines put together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As we look at these four system calls, we can start to see a pattern. The `open()`
    call is used to open the `/etc/ld.so.cache` file and is given a return value of
    `3`. The `fstat()` command is provided `3` as input and gets `st_size=24646` as
    output. The `mmap()` function is given `24646` and `3` as input and the `close()`
    function is provided with `3` as input.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the output of the `open()` call is `3` and the value `3` has been
    used multiple times in these four system calls, it is safe to conclude that this
    number `3` is the file descriptor number of the open file `/etc/ld.so.cache`.
    With that conclusion, it is also pretty safe to assume that the preceding four
    system calls perform the actions of opening the file `/etc/ld.so.cache`, determining
    the size of the file, mapping that file into memory, and then closing the file
    descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is quite a bit of information from just four simple system
    calls. Let's put what you just learned into practice and use `strace` to trace
    the application process.
  prefs: []
  type: TYPE_NORMAL
- en: Using strace to identify why the application will not start
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, when we ran `strace`, we simply provided it with a command to execute.
    This is one way you can invoke `strace`, but what do you do if the process is
    already running? Well, `strace` can also trace running processes.
  prefs: []
  type: TYPE_NORMAL
- en: When tracing an existing process, we can start `strace` with the `–p` (process)
    flag followed by the process ID to trace. This causes `strace` to bind to that
    process and start tracing it. For tracing our application startup, we are going
    to use this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we are going to execute the `start.sh` script in the background
    and then run `strace` against the process ID of the `start.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding & to the end of the command line, we are telling the start script
    to run in the background. The output provides us with the process ID of the running
    script, `3353`. However, in another window as the root user, we can use `strace`
    to trace this process with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command adds a few more options than just `–p` and the process
    ID. We also add the `–o /var/tmp/app.out` arguments. This option will tell `strace`
    to save the traced data to the output file `/var/tmp/app.out`. The earlier `strace`
    that we ran provided quite a bit of output; by specifying that the data should
    be written to a file, the data will be a bit more manageable to search.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other new option we added is `–f`; this argument tells `strace` to follow
    child processes. Since the start script starts the application, the application
    itself is considered a child process of the start script. In the preceding example
    we can see that `strace` was attached to two processes. We can assume that the
    second process received the process ID of `3360`, this is important to know, as
    we will need to reference that process ID while looking through the trace output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get started reading the `strace` output and attempt to identify what
    is happening. While going through this output, we will limit it to only sections
    that are useful for identifying our issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first system call that appears interesting is the `execve()` system call.
    This particular call of `execve()` appears to be executing the `/opt/myapp/bin/application`
    binary.
  prefs: []
  type: TYPE_NORMAL
- en: One important item to point out is that, with this output, we can see a number
    before the system call. This number, `3360`, is the process ID of the process
    that executed the system call. The process ID will only be shown when the strace
    command is tracing multiple processes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding group, we can see that the application is opening the `config.yml`
    file in read only and did not receive an error. We can also see that the `read()`
    system call (which appears to be reading from file descriptor 3) is reading the
    `config.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears further down the file that this file descriptor is closed using
    the `close()` system call. This information is useful as it tells us that we are
    able to read the `config.yml` file and that our issue is not related to permissions
    on the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If we continue, we can see that our configuration is taking effect as well,
    as the process has opened the `debug.out` file for writing using the `open()`
    call and written to it with the `write()` call.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that have many log files, system calls such as the above can
    be useful for identifying log messages that might not have been obvious.
  prefs: []
  type: TYPE_NORMAL
- en: When looking through system calls, you can roughly understand the context of
    when the message was generated and possibly why. This context can be extremely
    useful depending on the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Speaking of context, the preceding system calls explain our problem specifically,
    one system call. While the `strace` file contained many system calls that returned
    errors, the majority of them were like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fairly common, as it simply means the process attempted to access a
    file that is not present. In the trace file, however, there is one error that
    sticks out more than the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding system call `bind()` is a system call that binds a socket. The
    preceding example appears to binding a network socket. If we think back to our
    configuration file, we know that port `25` is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the system call, we can see the string `sin_port=htons(25)`, which might
    mean this bind system call is trying to bind to port `25`. From the return value
    provided, we can see that the `bind()` call received an error. The message of
    that error suggests "`Address is already in use`".
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that the application is configured to utilize port `25` in some
    way and we can see a `bind()` system call, it stands to reason that this application
    might not be starting simply because port `25` is already being used by another
    process, which at this point, is our new hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving the conflict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you learned in the networking chapter, we can verify that a process has
    port `25` in use with a quick `netstat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When we run `netstat` as the root user and add the `–p` flag, the command will
    include the process ID and name of process for each LISTEN-ing socket. From this,
    we can see that port `25` is in fact being used and the process 1588 is the one
    listening.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better understanding of what process this is, we can once again utilize
    the `ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: It appears that the `postfix` service is the one listening on port `25`, which
    is not very surprising since this port is generally used for SMTP communication
    and postfix is an e-mail service.
  prefs: []
  type: TYPE_NORMAL
- en: The question now is, should postfix be listening on this port or should the
    application? Unfortunately, there is no easy answer to that question, as it truly
    depends on the systems and what they are doing.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of this exercise, we will assume the answer is that the custom
    application should be using port `25`, and postfix should not be running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop postfix from listening on port `25`, we will first stop postfix using
    the `systemctl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This stops the postfix service where the next command will disable it from
    starting up again on the next reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Disabling the postfix service is an important step to resolving this issue.
    Currently, we believe the issue is caused by a port conflict between the custom
    application and postfix. If we do not disable the postfix service, the next time
    the system reboots it will be started again. This will then prevent the custom
    application from being started as well.
  prefs: []
  type: TYPE_NORMAL
- en: While this might seem basic, I want to stress the importance of this step as,
    on numerous occasions, I've seen an issue happen repeatedly, simply because the
    person who resolved it the first time didn't disable a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the `systemctl` status command, we can now see that the postfix service
    is stopped and disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: With the `postfix` service stopped, we can now once again start the application
    to see if the issue is resolved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears the issue was in fact resolved by stopping the `postfix` service.
    We can see this by the "`[Success]`" message printed from the startup process.
    We can also see this if we run the `lsof` command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the application is running, we can see several processes have open
    items in the `/opt/myapp` directory. We can also see that one of those processes
    is the application command with a process ID of `3588`. To get a better look at
    what the application is doing we can once again run `lsof`, but this time we will
    search only for files open by the process ID `3588`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `–p` (process) flag will filter the `lsof` output to a specific process.
    In this case, we limited the output to the custom application we just started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the last line, we can see that the application has a TCP socket open. Given
    the status messages from the application and the results from `lsof`, it is pretty
    safe to say the application has started and started correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We took an application issue and used common Linux tools such as `lsof` and
    `strace` to find the root cause, a port conflict. What is even more important
    is that we did this with no prior knowledge of the application or the tasks it
    was attempting to perform.
  prefs: []
  type: TYPE_NORMAL
- en: With the example from this chapter, we can easily see how having access to and
    knowledge of basic Linux tools, together with an understanding of the troubleshooting
    process, can enable you to solve almost any issue, whether that issue is an application
    issue or a systems issue.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the Linux user and kernel limits, and how
    they can sometimes cause issues.
  prefs: []
  type: TYPE_NORMAL
