- en: The React VR Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about the layout of the React VR library; the objects and components
    in it. Many of the concepts in this chapter will be referenced in later chapters,
    so if you are reading an electronic version of this book, it will be heavily hyperlinked
    for your enjoyment and pleasure.
  prefs: []
  type: TYPE_NORMAL
- en: 'React VR has six basic elements within it and is coded with a new, yet familiar,
    paradigm called JSX (JavaScript eXtension). If you already know React, you are
    already familiar with React VR, although there are important differences. We will
    cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSX, the language and syntax of React VR:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences between React VR and React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Components and VR components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Details of all components and keywords:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects-visible and invisible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multimedia - sound and video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cameras and viewing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have not covered all of the APIs available, as that is mostly a long, dictionary-like
    recitation, and it would be better if you used the documentation on the website
    to explore the APIs. We will, in later chapters, use critical APIs to add life
    to our world and navigate in it. For a full, up-to-date list of APIs, check the
    documentation ([https://facebook.github.io/react-vr/docs/getting-started.html](https://facebook.github.io/react-vr/docs/getting-started.html)).
  prefs: []
  type: TYPE_NORMAL
- en: JSX - the syntax of React VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React VR will look familiar to HTML; this makes it easy to read, edit, and deploy.
    Behind the scenes, the UI syntactical glue that React and React VR use will be
    compiled into JSX or JavaScript eXtension. JSX is a React grammar extension to
    allow coding in a blend of HTML and JavaScript. You can also code JSX directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of React JSX is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is not a string, as it's not in quotes, and it's also not JavaScript. It's
    much more readable and easier to use than coding in JavaScript directly. JSX makes
    programming faster and more declarative.
  prefs: []
  type: TYPE_NORMAL
- en: It is useful, but all of this readability and easy-to-program nature comes with
    a few pitfalls. One of them is that semicolons will automatically get entered.
    Just like with HTML, you can include extra lines, but your code may get extra
    semicolons that you didn't intend.
  prefs: []
  type: TYPE_NORMAL
- en: Put parentheses around your code to avoid this--I also highly recommend reading
    up on the JavaScript syntax. A few of the things in this book took me longer than
    they should have, as I'm a C++ programmer, not a native JavaScript programmer.
  prefs: []
  type: TYPE_NORMAL
- en: After your React VR is compiled, JSX is converted automatically into JavaScript.
    An implication of this is that you can include JSX anywhere you would use JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between React VR and React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, most of your thinking is around the **Document Object Model **(**DOM**)
    that has both captivated and infuriated us since the beginning of JavaScript.
    With React VR, you need to forget about the DOM; in this way, React VR is more
    similar to React Native. Even then, there are concepts that you need to forget
    about.
  prefs: []
  type: TYPE_NORMAL
- en: Forget about pixels as a dimension; the concept is meaningless with VR.
  prefs: []
  type: TYPE_NORMAL
- en: You can have a huge photo spread across so much of the world that it looks grainy,
    and a small photo on the side of a small physical object that looks very sharp.
    You can move closer or further away from objects (assuming you've programmed movement),
    which will dramatically change how many "pixels" wide something is. Instead, everything
    is referred to in real-world units of meters (if you are from a country that clings
    to outmoded units of "feet," you can pretend the units are in Yards. Close enough
    for VR work).
  prefs: []
  type: TYPE_NORMAL
- en: Another concept that might seem slightly strange with React VR is the speed
    of rendering**.** With React, your page is loaded, then displayed, then elements
    of the page can be interacted with (clicked on), but the whole page is rarely
    re-rendered unless someone clicks on *Refresh*. The `render` method of an object
    is called when the properties change. This does not mean you have to have a timer
    to "tickle" the rendering of your page in VR.
  prefs: []
  type: TYPE_NORMAL
- en: With React VR, the entire page is rendered in less (hopefully) than 16 milliseconds
    to make the 60 frames per second that is now consider essential for VR. The entire
    page is not reparsed. This is, sort of, the opposite of regular HTML. In particular,
    with active, alive web pages, individual VR components will be rendered (displayed)
    at 60 frames per second, and when their properties change, they are rendered (to
    the three.js code) to update that representation.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the object is not the same thing as page rendering. This may be slightly
    confusing. Your page will be rendered as soon as it starts loading, even if the
    `render()` method for various objects, to turn them into three.js code, has not
    run yet.
  prefs: []
  type: TYPE_NORMAL
- en: The net result is that without any extra programming, when properties update
    in your world, the objects will display as appropriate for those property changes.
    This is a cornerstone of how React works, and it is just as applicable with React
    VR. This adds multiple frame rates per second rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered what React VR is not, let's cover what React VR is.
  prefs: []
  type: TYPE_NORMAL
- en: Core Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React VR has reusable UI elements that you can use in a variety of places.
    These are called **components**. There are two built-in components:'
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also build your own components by extending `React.Component`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Components are real things, not just labels or placeholders, as they have been
    built in ways to present themselves through the world via a `render()` function.
    This is not just a function; like everything with React VR, `render()` generally
    has a set of child components that render or describe it''s contents. An example
    of a component could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This would be a text component, a built-in type.
  prefs: []
  type: TYPE_NORMAL
- en: VR Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VR objects, what you would commonly think of components, are covered later.
    The React VR documentation doesn''t mention them under the section Core Components,
    which is a bit confusing. You''re probably thinking *"just text and images? What
    about objects?"* VR components are my terminology for the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VR physical components**: These are objects that you can "see" in the world:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D primitives, including boxes, cylinders, planes, spheres, and imported objects
    (which can be very detailed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI elements, such as panels and buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lights**: These illuminate the preceding objects and can be of several types.
    Note that in React VR, currently lighting does not cast shadows for real-time
    speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multimedia**: This includes video and sound. In this way, you can both create
    moving backgrounds for 360 video as well as have "TVs" inside the the world you
    are creating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cameras and scenes**: Cameras control the rendering and the scene contains
    all of the objects you are placing in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover each of these keywords later in the *The next level - the details*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components would be boring if they didn''t have properties. An example of a
    property for our salutation might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`name` and other values such as this are referred to as **props**. The prop
    is name and has a value, which I set to a humorous string. They can be programmatically
    accessed, for example, `{this.props.name}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Many of the 3D objects also have properties; these vary from object to object.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps we're in a state of confusion, but React VR state is very important
    as it affects the display of all components, and thus, the various props of those
    components. If a component's props (external) or state (internal) changes, the
    component will re-render itself.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering does not necessarily refer to "creating an image for the eyeball",
    although it can. Rendering, in this case, can refer to building code through the
    React VR/JSX compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'React VR is encapsulated, per object orientation philosophy/coding paradigm,
    so that the modifiable state is inside a `this.state` object within the component.
    It should only be modified through a "set" function, specifically as follows:
    `this.setState({myStateVariableBeers: 99 })`'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while at first this might seem like it's stretching the HTML/JSX format,
    this is what makes React VR so powerful and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Events** aren''t just fun things to go to in your neighborhood, they are
    also ways to make your VR world really come alive. Events are generated when the
    user does certain things through the **user interface** (**UI**). A `View` component
    sends `onEnter` and `onExit` events when you move the cursor in and out of the
    view area.'
  prefs: []
  type: TYPE_NORMAL
- en: The astute reader should be confused--we are talking about VR and I just mentioned
    area. Why is a 2D concept being discussed as a fundamental component of a 3D language?
  prefs: []
  type: TYPE_NORMAL
- en: Events and layout (covered next) follow the 2D paradigm and are one example
    of an easy bridge between what you're used to working with (HTML, CSS, and JavaScript,
    and the VR world). There are differences, however, and the one that states "pixels"
    are not considered at all in any of the props and keywords may seem fundamentally
    weird. This is because with a true 3D world, the idea of using pixels as a unit
    of measurement is essentially useless. An object one meter in front of you is
    going to have a much wider screen representation than one ten meters behind you.
    Dimensions are therefore given in units of world space; one is a meter (a bit
    more than a yard).
  prefs: []
  type: TYPE_NORMAL
- en: The point of React VR is to quickly and declaratively build great 3D worlds.
    It is a declarative programming approach. If you want to build worlds with more
    complexity, the power of React VR is that you can use React Native and other Node.js
    programming methods to add to React VR.
  prefs: []
  type: TYPE_NORMAL
- en: Layout and style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aspects of WebVR and React VR still follow the browser paradigm. Cursors are
    viewed as 2D interactions, and UI elements are generally described in terms of
    2D flex boxes and layout rules to lay those components out in 2D. This does not
    mean we are not developing a VR environment; although most of the UI is in a 2D
    format, these are fully present within a VR environment.
  prefs: []
  type: TYPE_NORMAL
- en: Layout and style naturally move into 3D. Instead of having to describe what
    your 3D objects are for every item (inline), you can set up something similar
    to a style sheet or CSS. It's not actually similar to a style sheet, it is a style
    sheet, so all of your skills will transfer over.
  prefs: []
  type: TYPE_NORMAL
- en: Style sheets can be messy, so React VR makes it even easier to lay out UI elements.
    It uses Flexbox, via YogaLayout (at [https://github.com/facebook/yoga](https://github.com/facebook/yoga)).
    React VR is all about creating reality quickly. React is all about user interfaces,
    so it's natural that the UI elements in React VR are so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The next level - the details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the React VR library is simple, to really learn what it's all about,
    you need to learn a lot of syntax. You could skim it, but there is a danger to
    knowing a little bit without being somewhat familiar with everything.
  prefs: []
  type: TYPE_NORMAL
- en: '"A little Learning is a dang''rous Thing;'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drink deep, or taste not the Pierian Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: There shallow Draughts intoxicate the Brain,
  prefs: []
  type: TYPE_NORMAL
- en: And drinking largely sobers us again."-An Essay on Criticism, by Alexander Pope.
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking *"OK, but where's all the VR stuff? You know, tables, chairs,
    lamps, people ...* *and so forth."* These are going to be a deep drink indeed--there
    are quite a number of components.
  prefs: []
  type: TYPE_NORMAL
- en: The best reference is the online documentation, although they can be a tad sparse
    at times. Remember that the online documentation is *live*, meaning you can file
    an issue or even modify it, if you see a typo or need clarification.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend that you view the next section as a reference section. Of
    course, you could need help going to sleep at night, in which case read on! After
    having said that, this section is very important as you'll need to use many or
    all of these components to actually build your VR world. I will attempt to make
    this section funny. It is a good thing I am writing a book, and not trying to
    make a living on stage.
  prefs: []
  type: TYPE_NORMAL
- en: Stuff (objects, whether visible or not)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the interesting things in the world are visible objects or objects
    that you can interact with. Roughly, in the order of complexity, these are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cylinder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sphere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CylindricalPanel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pano
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VideoControl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VrButton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Box, Cylinder, Plane, and Sphere are 3D primitives. They have `lit`, `texture`,
    and `wireframe` props. Lit objects will be affected by the lights in the scene.
    If texture is specified (usually an image file), your browser will look up (fetch
    or render) this image and use it to wrap around the 3D primitive. UV mapping we
    will discuss in [Chapter 6](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml), *Working
    with Poly and the Gon family *and [Chapter 7](55c8c8f8-c349-43ad-b690-2d6de861b8b9.xhtml), *Sitting
    Down with a (Virtual) Teapot*, but most of the 3D primitives are mapped the way
    you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the texture can be a `string` (referring to an image file), an `asset()`
    call, or a `require()`.
  prefs: []
  type: TYPE_NORMAL
- en: Box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Box` is a basic cube. It's dimensions will default to one (unit) if not specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This would be the Monolith from 2001, a Space Odyssey; the dimensions being
    the squares of the first three primes. For more information, see [https://facebook.github.io/react-vr/docs/box.html](https://facebook.github.io/react-vr/docs/box.html).
  prefs: []
  type: TYPE_NORMAL
- en: Cylinder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Cylinder` is a basic capped cylinder. It can also be used to make cones by
    making the top a radius of zero (or bottom for a closed funnel).
  prefs: []
  type: TYPE_NORMAL
- en: The `Cylinder` uses radius, not diameter. Don't make your cylinders twice as
    large as they need to be!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note the creative use of the number of sides to make the cone a pyramid. For
    more information, see [https://facebook.github.io/react-vr/docs/cylinder.html](https://facebook.github.io/react-vr/docs/cylinder.html).
  prefs: []
  type: TYPE_NORMAL
- en: As with all 3D primitives, the `Cylinder` has `lit`, `texture`, and `wireframe`
    props.
  prefs: []
  type: TYPE_NORMAL
- en: Plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is not an Airbus, but rather a flat surface. While it is called a **plane**,
    it is more like a flat, square 2D slab. It is not a cubic slab, that would be
    a `Box`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One thing about a plane that can be tough to work with; they are visible only
    from their primary side. They are quick, lightweight objects, but can only have
    one texture map on them so may look repetitious if you use a large plane. If you
    rotate a plane the wrong way, you may see nothing at all; you could be looking
    at the back side. Be careful with transforms or use a `Box` instead of a `Plane`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see [https://facebook.github.io/react-vr/docs/plane.html](https://facebook.github.io/react-vr/docs/plane.html).
  prefs: []
  type: TYPE_NORMAL
- en: As with all 3D primitives, the `Cylinder` has `lit`, `texture`, and `wireframe`
    props.
  prefs: []
  type: TYPE_NORMAL
- en: Sphere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the bouncing ball, although animation is covered later. As with the
    `Cylinder`, the `Sphere` has a prop that will change its resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the way we did the pyramid, putting in a really low number of segments
    for the width and height could make the `Sphere` look like different types of
    solids. For more information, see [https://facebook.github.io/react-vr/docs/sphere.html](https://facebook.github.io/react-vr/docs/sphere.html)
  prefs: []
  type: TYPE_NORMAL
- en: As with all 3D primitives, the `Sphere` has `lit`, `texture`, and `wireframe`
    props.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Model` component allows us to do really interesting things. Until now,
    the VR objects have been fairly simple, but Model allows you to import CAD models
    of arbitrary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful with `Model`:'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily import objects that are more complex than your platform can handle.
    Remember, you still maintain the smooth frame rates that are required for Virtual
    Reality to seem real.
  prefs: []
  type: TYPE_NORMAL
- en: 'In  [Chapter 6](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml), *Working with
    Poly and the Gon Family*, we will explore the details of using `Model` effectively.
    The basic method of showing `Model` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Model` with a material file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Model` without a material file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As of the time of writing this book, `Model` imports the Wavefront OBJ file
    format, as well as **GL Transmission Format** (**glTF**). OBJ is the most common
    3D model format. One would wonder why React doesn't import X3D, which is the WebVR
    format of choice. This is one of the things that frustrated me into putting so
    much effort, way back when, into VRML and X3D.
  prefs: []
  type: TYPE_NORMAL
- en: In any event, OBJ files consist generally of two files; the `filename.obj` contains
    the geometry of the object, and a companion `.MTL` file (material) contains the
    colors, materials, and references to external textures (image files). Note that
    the implication is that you may need far more than just these two files, if the
    OBJ file has many textures loaded in the material file.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover this in more depth in [Chapter 6](3b913e8b-342f-4ffb-b938-c996b41c1ab8.xhtml),
    *Working with Poly and the the Gon Family*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Model` has `lit`, `texture`, and `wireframe` props. The texture prop
    applies to the whole model, which could have multiple UV mappings. It is usually
    better to assign textures through the `.MTL` file, which may be done automatically
    from your modeling program.
  prefs: []
  type: TYPE_NORMAL
- en: Don't plan on the texture keyword to apply to a `Model` that you have imported.
    It's far better to texture and map the model in the CAD program you are using,
    than to try to override it in React VR.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you may need to hand edit the `.MTL` file; my experience is that most
    exporters can't handle all of the complexity of a nodal-based shader that even
    real-time engines make dramatic use of; as a result, your `.MTL` file is almost
    certainly not going to have all of the different baked-in maps.
  prefs: []
  type: TYPE_NORMAL
- en: CylindricalPanel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CylindricalPanel` is a bit of a transitional object. It is intended to have
    child objects and provides an ability to draw these on an invisible cylinder centered
    on the current viewpoint. Its main purpose is to allow familiar 2D elements to
    be placed in a 3D world. To be able to do this requires a few anachronistic elements.'
  prefs: []
  type: TYPE_NORMAL
- en: When you work with HTML, to do precise layouts of HTML elements, you may have
    to think and code with pixels; for example, a certain element may be 200 pixels
    wide. This allows you to precisely lay out graphics.
  prefs: []
  type: TYPE_NORMAL
- en: In 3D, none of this is applicable. Is the moon one, two, or 10 pixels wide?
    The world does not have *dots per inch*. As a result, most of the VR primitives
    established their actual size, well, their *virtual* size, in meters. Your VR
    display method will then show the right amount of pixels. If you move your head
    right up to that cube, it could be 2,000 pixels; if you see it at the end of a
    hallway, it might be 10 pixels wide. So you normally do not use pixels for sizes
    with React VR.
  prefs: []
  type: TYPE_NORMAL
- en: The `CylindricalPanel` object, however, *does* need a property for the amount
    of pixels. This is not for the object itself (well, sort of), it's for an off-screen
    buffer to hold the visible rendering of any child objects. Like many things in
    the web, it has reasonable defaults. The defaults are quite large, but that is
    to make it look less grainy if you get up close.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend not using `CylindricalPanel`, but rather recode your UI into
    actual 3D objects. The resolution and system resource use (RAM mainly) could actually
    be lower this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Child components` line is very important--here is where you put the actual
    2D objects that will show up spread across `CylindricalPanel`. It is not literal
    code.
  prefs: []
  type: TYPE_NORMAL
- en: VideoControl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`VideoControl` is a physical object with the normal `VideoPlayer` functions,
    in other words, start, pause, and so forth. As it is intended to be used in playing
    videos, the example here (straight from the documentation) will show it embedded
    with an animation object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Don't feel limited to its intended use. You can also experiment with it--maybe
    it's a good train controller!
  prefs: []
  type: TYPE_NORMAL
- en: VrButton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `VrButton` isn't actually a real button (well, it's all virtual, right?),
    meaning it doesn't have any geometry, but is an object that you may, nay, will,
    find very useful to include in the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VrButton` is mainly used for gaze detection. We discuss this and other
    VR movement (locomotion) techniques in [Chapter 11](707dc6f5-9666-4f49-952b-fbcf20fc8afc.xhtml),
    *Take a Walk on the Wild Side*[.](707dc6f5-9666-4f49-952b-fbcf20fc8afc.xhtml) For
    now, let''s just discuss what the `VrButton` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This `VrButton` wraps an image and plays a sound. We'll discuss sound further
    on in [Chapter 8](c3188254-ca3b-4b7d-af85-97b2c11439a0.xhtml), *Breath Life in
    Your World*, but briefly here, the file format allows the browser to decide which
    sound will play in your chosen browser.
  prefs: []
  type: TYPE_NORMAL
- en: Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The world would be a pretty dark place and full of vampires if we didn''t have
    lights. Let''s chase those undead things away. There are four principal lights:'
  prefs: []
  type: TYPE_NORMAL
- en: AmbientLight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DirectionalLight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PointLight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SpotLight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common light properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All lights have two common properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`intensity`:  This is how bright the light is in the scene. The default is
    `{1.0}`, but you can go higher. In practice, higher settings make the shadows
    on the curved edge of objects (spheres for example) more sharp and look brighter
    (washed out), but can''t actually get whiter than white (RGB 255, 255, 255) on
    the most lit faces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`:  Color is not listed under light properties, but it is a style prop
    that all lights have. This is an RGB property. You can even have colored ambient
    lights, which could be used for sepia tones and the like, as well as simulating
    background illumination from brightly colored environments. In a forest, for example,
    maybe a light green ambient color. The default is white.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other lights have properties specific for the type of illumination they represent.
  prefs: []
  type: TYPE_NORMAL
- en: AmbientLight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AmbientLight` is the simplest way to make your scene visible. It isn''t actually
    a light, really, but it does light up everything in the scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Lighting in the real world is very complex. Photons bounce all around, reflect
    off of objects, penetrate into them, and even make some objects glow (fluorescence
    and luminescence). A useful trick is to make objects light up even if there are
    no lights or to add a light fill to the room that can help simulate background
    light scattering, without the overhead of calculating this.
  prefs: []
  type: TYPE_NORMAL
- en: This is called ambient light. Many CAD systems have ambient as a value in materials.
    `AmbientLight` lets you light up the whole room. For you disco, festival-loving
    people, it even lets you change the color from white to whatever color you want.
    Now, you can make a scene that looks like the hallways at the W hotel chain.
  prefs: []
  type: TYPE_NORMAL
- en: Oddly, not a single sample in the React VR download shows how to use `AmbientLight`;
    although it's not that hard, it's important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of a sphere with an ambient of `.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/45b254bb-6a90-4877-bf7e-6328b13b4b47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice a few things--we also have a directional light in the last photo, so
    you can see the differences. The sphere is white from the directional light, yet
    the underside is dark, but not pitch dark. `AmbientLight` can fake a little global
    illumination or radiosity in real time. GI is the amount of light that bounces
    off other objects and creates "fill light" in the real, non-virtual world. Three.js
    also has a `THREE.HemisphereLight` for this*, *and you can add it to React VR
    through the Native Views or Native Bridge.
  prefs: []
  type: TYPE_NORMAL
- en: DirectionalLight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From `AmbientLight` to `DirectionalLight`, we are moving from the abstract to
    the slightly less abstract. A `DirectionalLight` is really there to take the place
    of the Sun. The sun's rays are always parallel to each other; in the same way,
    the `DirectionalLight` doesn't spread out like a light that's located closer would.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `DirectionalLight` and no `AmbientLight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a2b8bce2-366e-4911-8b04-a71482102329.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the picture, we've rotated the `DirectionalLight` to the side slightly; the
    sphere looks interesting, but not quite right compared to the rest of the scene.
    This is because the lighting for the Pano background is substantially different
    than the scene. You would want to try to match the two up with the appropriate
    transform statement for your `<DirectionalLight>`.
  prefs: []
  type: TYPE_NORMAL
- en: PointLight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Pointlight` is like an old-school light bulb; light spreads out in every
    direction from the point. One interesting thing about Point and Spot lights is
    again a simplification to make our VR look real. To avoid very slow rendering,
    the atmosphere is not strictly modeled. This means that a light that would normally
    fade out due to the atmosphere would instead shine for miles (atmospheric effects
    might be more of an issue where I live than where you live, unless you live on
    the moon. If you do, give me a ticket, and I'll come and personally read this
    book out loud to you).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid modeling atmospheric effects such as extinction (fading), fog, clouds,
    and so forth, `PointLight` and `SpotLight` both take decay and distance props.
  prefs: []
  type: TYPE_NORMAL
- en: '`distance` is how far the light shines. If it is non-zero, the light intensity
    will be zero at that distance.'
  prefs: []
  type: TYPE_NORMAL
- en: '`decay` is how often if fades away. It''s sort of a generic (dimensionless)
    number; `2` is physically realistic light falloff. `0.1` makes a much sharper
    fade and is useful for artistic effects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To better visualize the preceding, I've constructed a demo scene three times;
    the first with a distance of 10, the second with a distance of four, and the third
    with a distance of four and a decay of `0.1` instead of 2\. You can see the third
    scene looks very unnatural. Note that all three scenes have an intensity of exactly
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/22675a67-ad9c-4ec2-b46e-69cf89bfa6f6.png)If your point lights seem
    dim, check the distance parameter. I recommend leaving decay at two.'
  prefs: []
  type: TYPE_NORMAL
- en: SpotLight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `SpotLight` is like those lampshade things they shine in a bad guys faces
    in bad film noir or a flashlight. Like `PointLight`, it also has decay and distance
    props (as seen earlier).
  prefs: []
  type: TYPE_NORMAL
- en: The `distance` and `decay` props are the same as the `PointLight`. The `SpotLight`
    also has a `penumbra` and `angle` props; the two are how far the light spreads
    out. Angle is the maximum outside `angle`,while `penumbra` is a number from one
    to 100 that defines how soft the  `SpotLight` is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Currently, the position of the SpotLight defines where the light is shining
    "from." The target of the light, in other words what it is pointed at, is currently
    not exposed in React VR. At the time of the writing of this book, this issue is
    not resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Using a View to wrap the SpotLight doesn't seem to change the target either.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend not using SpotLight, unless you can arrange your scene to have the
    object of interest located at [0,0,0].
  prefs: []
  type: TYPE_NORMAL
- en: Multimedia - sound and video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world would be a boring place if you couldn't hear anything. Video is normally
    part of dynamic web pages, although in VR, we have a bit of a challenge — video
    itself might not be engaging unless it's 360 video, which some people call VR
    (it can't give you more than disembodied ghost feeling, so from my viewpoint,
    it's not really VR as you can't be totally immersed, but other people may feel
    it is VR. At this point in VR/AR/XR, we really need to all just get along!).
  prefs: []
  type: TYPE_NORMAL
- en: Video in a VR world can be an important part of providing atmosphere. If you
    walk into a room and a video is playing, it's going to seem more like most homes.
  prefs: []
  type: TYPE_NORMAL
- en: Sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Sound` in VR is much more complicated than it initially sounds (pun intended).
    The `Sound` node allows an audio source to be placed into your VR world. `Sound`
    will make your world come alive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the React VR manual, consider the example of a `waterfall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how easy it is to add things by declaring them in React VR.
    The `waterfall` sound is simply attached to the location of the image of the `waterfall`.
    If you are walking around inside the 3D world, you will *hear* the waterfall as
    if it is located where the image is; this is all done by simply adding the `Sound`
    component as a leaf node (child of image in this case). The `Sound` node should
    not have any child components itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `Sound` node is not attached to an object with a position, it will default
    to being at position absolute, for example of position: absolute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Sound` node has a number of props. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`autoPlay`: Boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the audio starts playing automatically when a component is loaded. The
    default is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '`loop`: Boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the audio repeats automatically when finished playing. The default is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '`muted`: Boolean When the audio is muted. The default is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDurationChange`: (callback function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function is called when the sound duration changed, with a parameter for
    the duration of the sound.
  prefs: []
  type: TYPE_NORMAL
- en: '`onEnded`: (callback function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function `onEnded` is called when audio is done playing.
  prefs: []
  type: TYPE_NORMAL
- en: '`onPlayStatusChange`: (callback function) This function is called when the
    play status changed. `event.nativeEvent.playStatus`: This is the play status of
    the sound; one of the strings `''closed''`, `''loading''`, `''error''` , `''ended''`
    , `''paused''` , `''playing''` , or `''ready''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onTimeUpdate`: (`callback` function) This function is called when `currentTime`
    of sound is changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.nativeEvent.currentTime`: The `currentTime` of the sound file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playControl`: *play*, *pause*, or *stop*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This variable controls the playback status. If not set, the value of `autoPlay`
    determines whether the audio plays when the component is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '`playerState`: (object)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playerState` is a `MediaPlayerState` that controls video playback with its
    inner state. When `playerState` is set, the value of `autoPlay`, muted volume
    and `playControl` properties are ignored as they will be set by `playerState`
    instead. See `MediaPlayerState`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`source`: (object)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The object source audio in the form of {uri: http}.'
  prefs: []
  type: TYPE_NORMAL
- en: '`volume`: 0-1.0 (not actually limited)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value of the audio volume. The minimum is zero, which mutes the sound, and the
    suggested maximum is 1.0, which is also the default value. Values greater than
    one are allowed; this may cause clipping/distortion, depending on the audio hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example: To lower the volume by 50% set `volume={0.5}`. As different platforms
    may have differing audio capabilities (sigh), the source can be of several different
    file formats, and the browser will pick the appropriate format that it can read.'
  prefs: []
  type: TYPE_NORMAL
- en: It appears that mono files work best; not all browsers seem to support stereo
    sound files. This is because the browser will convert the sound to a stereo sound
    and try to replicate 3D audio (which can be done with only two speakers through
    a Head Related Transfer Function).
  prefs: []
  type: TYPE_NORMAL
- en: Use mono files for the best compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a `Video` is only a two dimensional (2D) object, it takes a width and height.
    This is not, as you are probably used to, in pixels, but instead in world units
    for the reasons discussed earlier. If people move their point of view closer or
    further away from your 2D video, it will change resolution from a dots per inch
    standpoint. You may need to experiment with sizes and video compression/storage
    to find the ideal balance of quality, download speed, and resolution (graininess).
  prefs: []
  type: TYPE_NORMAL
- en: '`Video` is best when used with the `VideoControl` (described earlier in this
    chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example showing a `Video` as well as a `VideoController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `VideoControl` is not a child of `Video`; it is an independent
    object with its own location. In this example, presumably playing a 4:3 ratio
    video, it coordinates their stop/start/pause activity through `this.state.playerState`.
    In effect, you could think of the `VideoControl`'s `playerState` as being an output
    and the `Video`'s `playerState` as being an input.
  prefs: []
  type: TYPE_NORMAL
- en: Cameras and viewing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a camera object, called `LiveEnvCamera`, although it is not what you
    would normally expect.
  prefs: []
  type: TYPE_NORMAL
- en: In most CAD systems, the camera sets up basic statistics such as focal length,
    focus, what direction the camera is looking at, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: With React VR, instead, we have a `<View>` at the top level in the `index.vr.js`;
    this is what constructs the VR view.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of visibility of the view are really controlled by your physical
    viewing device. If your HMD has a 110 degree horizontal field of view, you will
    be seeing a 110 degree horizontal field of view.
  prefs: []
  type: TYPE_NORMAL
- en: This is something that traditional 3D artists have to get used to--VR is different.
  prefs: []
  type: TYPE_NORMAL
- en: Along the same lines, lens flares and other effects, although they look great
    in movies, look terrible in VR. Your eyes don't have lens flares.
  prefs: []
  type: TYPE_NORMAL
- en: Don't try to add them with React Native.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder, how do we move the camera? The answer is that you transform
    the `<View>` . If you want to move say five meters forward, you transform the
    view five meters backwards, and the point of view will move into the scene. Note
    that this does not work for the `SpotLight`.
  prefs: []
  type: TYPE_NORMAL
- en: LiveEnvCamera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This object displays the environment–facing camera. This may or may not be part
    of your viewer's hardware. GearVR, for example, may have an environment–facing
    camera; the Vive does, a Google Cardboard probably does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the camera is position: absolute `<LiveEnvCamera />`. The camera
    image is displayed on geometry that is 1000m away from the viewer.'
  prefs: []
  type: TYPE_NORMAL
- en: The LiveEnvCamera is probably intended for **Augmented Reality** (**AR**) applications;
    its use in React VR is experimental at best.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `View` object is both the initial scene or camera in the world; it is also
    useful to aggregate objects in the world. In this way, it is very similar to a
    group node in traditional CAD programs. It really is essential to effective React
    VR software as a grouping node, not just the main rendering loop.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we mention that view is a camera is that it has layout props and
    transforms. If, in your main `render()` loop, you transform the `<View>` you are
    essentially moving where the camera, your current point of view, is looking.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `<View>` as a grouping node, then the transforms apply to all
    of its children. You could build articulated models in this way, by properly exposing
    their properties and transforms, although it's more likely to do this through
    a glTF file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of the React VR library, what components
    are in it, and the APIs and coding techniques they will be using to build your
    app. Enough background! Now that we have done this, in the next chapter, let's
    create an actual VR app.
  prefs: []
  type: TYPE_NORMAL
