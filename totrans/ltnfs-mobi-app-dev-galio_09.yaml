- en: '*Chapter 9*: Debugging and Reaching out for Help'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been through so much already. We've learned how to create different types
    of components; we've learned about props and state and how each has an important
    role in our component creation. We've also learned about life cycle functions.
    We have gained a lot of knowledge so far, but we still haven't got a way of testing
    our components to see whether they have the behavior we expect.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to learn about debugging and we'll go through the
    most popular debugging options, such as React DevTools and React Native Debugger.
    We're also going to learn about some other debugging alternatives so that we can
    be on the safe side and make sure we use the right tool for the job when needed.
  prefs: []
  type: TYPE_NORMAL
- en: We'll go through interesting concepts such as type checking and linting. We'll
    also learn about the **Developer** menu and some of the features React Native
    has for us to quickly find out if our app is having any type of problem.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we should have some knowledge about debugging so
    we are ready whenever something's not working the way we expect it to work. This
    will be the last step before creating more complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Different ways of debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Native Debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where you can reach out for help when you need it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different ways of debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we all know, developers are human beings and human beings make mistakes.
    To be completely honest, I feel like software developers make a lot more mistakes
    than just your average normal human being, so of course, there have to be some
    ways of solving the bugs that came into existence because of our mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: The process of finding and resolving bugs in computer programming is called
    *debugging*. There are lots of debugging tactics you can use while solving bugs,
    so we'll try and get through some of them in this section. Understanding them
    will surely unlock a new achievement on our React Native journey.
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin this interesting quest of finding out how to make sure there are
    fewer and fewer errors while we're in the development phase with different formatting
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Linting, type checking, and formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As developers, we'll mostly want to focus our attention on stuff such as business
    logic, code patterns, and best practices. You don't usually want to spend time
    making sure each line is correctly indented or checking what type of argument
    a certain function needs to receive. To simplify our life and our code writing
    process, we can make sure all the automation stuff is delegated to our code editor.
    I'm personally a big **Visual Studio Code** fan, but we've discussed in previous
    chapters that you may use whatever code editor you want to.
  prefs: []
  type: TYPE_NORMAL
- en: Type checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of verifying and enforcing the constraints of a type is called type
    checking. This is all to make sure that the possibility of type errors is kept
    as low as possible. With JavaScript, we don't have to specify what type of information
    will be stored in a variable and that's all because JavaScript is a loosely typed
    language. But putting constraints or limitations on our code will make us write
    more thoughtful code, making us more careful about how we think about the code
    we're writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two cool tools when it comes to type checking: **TypeScript** and
    **Flow**. The main difference between these two is that Flow is just a type checker
    while TypeScript is a superset of JavaScript, which basically means it will include
    more next-gen features of JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Linting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linting is the process of executing a program to analyze the potential program
    syntax errors. The most famous linting plugins for JavaScript are **ESLint**,
    **JSHint**, and **JSLint**. I personally use ESLint, which now even has an official
    plugin for TypeScript linting.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see that most people go for ESLint, but that doesn't mean it's the best;
    you need to figure out what exactly works for you, so try and take a few minutes
    to google them all. I usually go for the tools with the biggest community just
    because it's easier to find out how to fix certain errors if they pop up.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of your time as a programmer will be spent reading code, so you'll have
    to make sure the code you're reading is legible. Let's pretend we want to quickly
    write a class component; we already know how to do that so maybe we're not even
    looking at the screen anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of that, we''re not really paying attention to the way the code looks,
    but it''s irrelevant since we''re already good programmers and we know it works.
    This is how unformatted code looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Unformatted class component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.01_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Unformatted class component
  prefs: []
  type: TYPE_NORMAL
- en: 'I mean… yeah. This doesn''t look that good. It works but… where do we even
    begin understanding what''s going on in this big sausage? Now let''s see what
    will happen to our code once we save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Formatted class component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.02_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Formatted class component
  prefs: []
  type: TYPE_NORMAL
- en: Phew! It looks 10 times better, right? We can easily follow the code written
    here. It's a lot easier to read code and understand it when it looks well formatted.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple different code formatters, but one of the most used ones
    and also the one that I enjoy using the most is **Prettier**. This is really easy
    to integrate and configure with your favorite code editor.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, you can even configure your linter to use it for formatting the
    code so maybe, if you don't really like Prettier, you might actually configure
    ESLint to do that for you.
  prefs: []
  type: TYPE_NORMAL
- en: In-app Developer menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a bunch of different tools we have access to from inside of our simulator
    that React Native makes available for us. These are really cool so let's see how
    to access the in-app Developer menu whenever we're testing our app in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: The first method of accessing the Developer menu is by shaking the device or
    selecting **Shake Gesture** inside the **Hardware** menu in the iOS Simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method is a keyboard shortcut. For Mac on iOS, the shortcut is *Cmd
    + D* and for Android it''s *Cmd + M*. For Windows, the shortcut is *Ctrl + M*
    for the Android Simulator. Alternatively, for Android, we can run the following
    command to open the dev menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve used one of the preceding methods, the following menu will open
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Developer menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.03_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Developer menu
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are a bunch of options right here, so let's talk about
    each one of them. First of all, the ones that are actually interesting to us for
    debugging purposes are **Debug Remote JS**, **Show Performance Monitor**, and
    **Show Element Inspector**. Let's begin with the first one.
  prefs: []
  type: TYPE_NORMAL
- en: Debug Remote JS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clicking this button will open up a new tab in our Chrome browser with the
    following URL: [http://localhost:8081/debugger-ui](http://localhost:8081/debugger-ui).'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Tools** | **Developer Tools** from the Chrome menu to open the Developer
    Tools. React Native also recommends enabling **Pause on Caught Exceptions** for
    a better debugging experience. You can do that by going to the **Sources** tab
    and you'll find this checkbox somewhere on the right, next to the usual buttons
    used for breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Show Performance Monitor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This one is actually pretty cool. Once you click on this button, it''ll enable
    a performance overlay to help you debug performance problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Performance overlay'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.04_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Performance overlay
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we''re seeing in the preceding screenshot. We''ll begin from
    left to right, explaining each and every column:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RAM** – The amount of RAM your app is using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSC** – The size of the JavaScript code managed heap. It will only get updated
    as garbage collection occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views** – The top number is the number of views on the screen and the bottom
    number is the total number of views in the component. The bottom number is typically
    larger but usually indicates that you have something that could be improved/refactored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI** – Main frames per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JS** – JavaScript frames per second. This is the JavaScript thread where
    all the business logic lives. If the JavaScript thread is unresponsive for a frame,
    it will be considered a dropped frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show Element Inspector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here it is! The last option in our Developer menu. Let''s click it and see
    what happens. Our screen has kind of changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Element Inspector once we enable it'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.05_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Element Inspector once we enable it
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've clicked it, we can see that it asks us to tap on something so
    it can inspect it. At the same time, we also can see there are four different
    tabs down there called **Inspect**, **Perf**, **Network**, and **Touchables**.
  prefs: []
  type: TYPE_NORMAL
- en: 'These can all be used just like you''d use the Chrome Developer Tools, but
    with more limitations, so you''d probably prefer using the Developer Tools. Let''s
    at least tap on an element and see how it appears once we click it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Our Element Inspector once we have clicked the commerce card'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.06_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Our Element Inspector once we have clicked the commerce card
  prefs: []
  type: TYPE_NORMAL
- en: Once we click the commerce card, we can see it has a blueish overlay on top
    of it with a green border. That green border represents the padding. But let's
    focus our attention on the upper part of the screen where our inspector has now
    moved.
  prefs: []
  type: TYPE_NORMAL
- en: In the upper part of the inspector, we can see the component tree, which basically
    tells us what component exactly we have clicked. So, we've clicked a `View` component
    inside a `Block` component, which lies in a `Context.Consumer` component. I guess
    we can read even further than that and see that this is all part of the `CommerceCard`
    we created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath the component tree, we have the styling applied on the View we've
    clicked. Toward its right, we have information about the *size*, *padding*, and
    *margin*.
  prefs: []
  type: TYPE_NORMAL
- en: The best way of actually learning how to use all these internal tools that are
    provided to us by the React and Expo team is to actually play around with them.
    You probably won't use these as much as the following tool, but I'm pretty sure
    you'll want to experiment with them. The following tool is one of the most commonly
    used for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: React Native Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native Debugger includes almost all the tools necessary for debugging
    a React Native application. That's why I totally recommend using this one as it
    has everything you need inside it.
  prefs: []
  type: TYPE_NORMAL
- en: This is basically a standalone app based on the official **Remote Debugger**
    but with more features implemented. It also includes **React Inspector**, **Redux
    DevTools**, and **Apollo Client DevTools**. We're not really interested in Redux
    and Apollo right now, but you'll most probably stumble upon *Redux* as it's one
    of the most used libraries for state management.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install React Native Debugger on macOS via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If this command doesn't work, you should make sure you have **Homebrew** installed.
    Homebrew is a module manager and you'll for sure keep on using it with different
    programming tools. To install Homebrew, visit [https://brew.sh](https://brew.sh).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install React Native Debugger on Windows, we have to go to the following
    URL: [https://github.com/jhen0409/react-native-debugger/releases](https://github.com/jhen0409/react-native-debugger/releases).
    Download the `.exe` file and open it up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the software is opened up, press *Ctrl + T* on Windows or *Cmd + T*
    if you''re on a Mac. This will open up a new window where you''ll be prompted
    to specify the port. Write `19000` there and click **Confirm**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Window opened for changing the port'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.07_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Window opened for changing the port
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run our project with `expo start` or `expo r -c`. After that, open
    up the **Developer** menu and select **Debug Remote JS**. The debugger should
    automatically connect now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you should be able to see the element tree as well as the props state and
    children of whatever element you''ve selected. On the right, you''ll see the Chrome
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – React Native Debugger connected to our simulator'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.08_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – React Native Debugger connected to our simulator
  prefs: []
  type: TYPE_NORMAL
- en: If you right-click anywhere in the React Native Debugger, you'll see we have
    some cool little shortcuts that we can use to reload our app, enable the element
    inspector or network inspector, while also clearing our **AsyncStorage** content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even use this one to inspect our network traffic so right-click anywhere
    and select **Enable Network Inspect**. This will enable the **Network** tab and
    allow us to inspect `fetch` or `XMLHttpRequest` requests. Because there are some
    limitations to inspecting networks using React Native Debugger, you might want
    to look for some alternatives. All of them require a proxy but here are some alternatives
    you might want to look into: *Charles Proxy*, *mitmproxy*, and *Fiddler*.'
  prefs: []
  type: TYPE_NORMAL
- en: As we know, React Native Debugger has React DevTools implemented inside of it,
    so maybe you don't want to mess with all the tools at once and you'd really love
    seeing the component tree with some properties.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we've installed React Native Debugger, I'd really recommend at least
    keeping in mind that we can also use each tool included in it but separately.
  prefs: []
  type: TYPE_NORMAL
- en: React DevTools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This tool is really great for checking out the component tree and each component''s
    props and state. First, if we want to install it, we need to do it via `npm` with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install React DevTools globally on your computer but you might want
    to just install it as a project dependency. If that''s the case, you can do that
    via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have React DevTools installed on our computer or project, let''s
    start up our project with the usual `expo start` command. After we''ve opened
    up our project, let''s open a new terminal window and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open up a new window. Now we need to open the Developer menu inside
    our simulator and click **Debug Remote JS**. It''s the same process as before
    but we don''t need to set up the port with React DevTools because it will automatically
    connect to our project. We can see how the app looks by looking at the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – DevTools standalone app for Debug Remote JS'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_9.09_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – DevTools standalone app for Debug Remote JS
  prefs: []
  type: TYPE_NORMAL
- en: As far as we can see, this is identical to our bottom-left window in React Native
    Debugger. I'll mostly use this because it makes it easier for me to check out
    my component but as the app gets bigger, you'll probably catch me switching to
    React Native Debugger.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, this is a great tool to have under your belt and I highly recommend
    playing around with it if you don't really have too much experience with Chrome's
    Developer Tools as these tools are really similar to what a web developer is used
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have found out about some tools used for debugging React Native
    applications, let's see what else can we do if an issue can't really be debugged
    with these tools. Or, maybe some of you might even see these tools as too much
    work so let's check out other solutions to some of the problems we might encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Where you can reach out for help when you need it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know for a fact that almost all programmers get stuck at some point while
    developing a product or a feature for an already existing product. So, we should
    know what to do when an error pops up.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you can tell exactly what's wrong just by the **stacktrace**, but
    other errors might be a bit more difficult to understand at first glance. The
    stacktrace is the big red error message that pops up on your simulator whenever
    there's a problem with your code.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, I think you should know that because we're on React Native and
    the community is so big, almost all error messages can be searched on Google.
    There's always going to be someone out there with a solution for your error.
  prefs: []
  type: TYPE_NORMAL
- en: Another good solution would be to isolate the code that's throwing the error.
    You can do that by discovering which line exactly threw the error and then commenting
    out that section. By isolating the code, we can start experimenting with that
    part alone and by trial and error, we can get to a working solution.
  prefs: []
  type: TYPE_NORMAL
- en: A really good habit that you should start developing is the use of `console.log`.
    You can use this to discover how your code works. For example, by using it before
    and after we do something with a state variable, we can see how exactly the variable
    changes by constantly following it inside our code. The only issue with using
    `console.log` instead of breakpoints with a debugger is the fact that when we
    have any type of `async` code, we might not realize that some code is changing
    at different points that might be out of our control.
  prefs: []
  type: TYPE_NORMAL
- en: If you can simplify your code as much as possible, you might be able to track
    down errors much more easily than you normally would be able to. Because of that,
    you'll see that some repositories on GitHub ask for a *minimal reproducible demo*
    in their bug reports. This allows them to see that you correctly identified the
    issue and isolated it. So, if the app you're working on is a bit too large and
    complex, extract the functionality and try to identify the specific error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you might also get into some production errors. Some errors and
    bugs might show up only in production mode. So, it''s a good thing to test your
    app once in a while in production mode by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The best first step in understanding a production error is to reproduce it locally.
    After that, just isolate the issue and find a good solution for it.
  prefs: []
  type: TYPE_NORMAL
- en: The Expo team recommends an automated error logging system such as Sentry. This
    tool will help you in tracking, identifying, and resolving JavaScript errors in
    your production app. It even provides you with *sourcemaps* so you will have stacktraces
    of your errors. This tool is free for up to 5,000 events a month.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think of what we would do if our production app was crashing. What could
    be the cause of that? This is one of those really frustrating scenarios at first
    glance. The truth is this is pretty easy to understand and solve.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you should do is to access the *native device logs*. You can
    do that by following the instructions for whatever platform you're using. We will
    see how to check logs on each of these platforms in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Logs for iPhone/iPad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to check your iPhone logs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your terminal and use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that this package has been installed, plug in your iOS device and run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Click the **Accept** button on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to the computer and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! Now you can check out your iPhone logs.
  prefs: []
  type: TYPE_NORMAL
- en: Logs for Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure your Android SDK is installed. Make sure that USB debugging is enabled
    for your device. If it isn't enabled, you should be able to find out how to do
    that at [https://developer.android.com](https://developer.android.com). The information
    you're looking for should be under **User Guide** | **Build and run your app**
    | **Run apps on a hardware device**.
  prefs: []
  type: TYPE_NORMAL
- en: Now plug in your device and run `adb logcat` inside the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Now you're able to check out your Android logs.
  prefs: []
  type: TYPE_NORMAL
- en: This is great! We've found out how to check our logs and this should point you
    in the right direction in your bug-solving adventure. Search the logs with the
    words "fatal exception," and this should quickly point you to errors. Now reproduce
    the errors! By reproducing them, we're making sure that our assumption of how
    exactly they behave will be proven.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, but what if my app only crashes on a specific or older device? This has
    a 90% likelihood of being an indication of performance issues. The best thing
    you could do in this situation is to run your app through a profiler to see what
    exactly is killing your app. Hmm, do we know a good profiler? Yes, React DevTools
    or React Native Debugger both have a profiler included. I'd honestly recommend
    you read [https://reactnative.dev/docs/profiling](https://reactnative.dev/docs/profiling)
    because there's a ton of information about how exactly to identify which processes
    take high amounts of memory and could potentially kill your app.
  prefs: []
  type: TYPE_NORMAL
- en: Still can't figure out what's wrong with your app?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the perfect moment to seriously consider taking a break. I know it might
    sound weird but a 10-minute break is a lifesaver in certain situations. I sometimes
    even sleep on the issue until the next day and once I open up Visual Studio Code,
    the solution kind of comes to me.
  prefs: []
  type: TYPE_NORMAL
- en: You could also just try a Google search again. The best places to find solutions
    are the **Issues** section on GitHub, Stack Overflow, Reddit, and Expo forums.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter wasn't as expansive as the others but I hope you were able to find
    all the information necessary for a jumpstart into how exactly to solve all the
    issues you might encounter while developing with React Native and Galio.
  prefs: []
  type: TYPE_NORMAL
- en: We've been through certain tools to prevent mistakes in our code writing. I
    highly recommend going over all of them and doing more research because, as we
    all know, knowledge is power. The more tools you learn about, the better you'll
    feel once you find the perfect match for you.
  prefs: []
  type: TYPE_NORMAL
- en: After going through those tools, we learned about React Native's built-in tools
    for debugging and profiling. We learned how to use the features found in the Developer
    menu and I hope you understand the fact that even though the information presented
    here is brief, the most important thing is for you to experiment with all these
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: We've also learned about React DevTools and React Native Debugger. Now that
    we know how to install and start up these tools, it should be fairly easy to experiment
    with our apps to understand more about how exactly React Native works.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned some ways and tactics for finding out where an error's coming
    from. I really do hope I've done a good job of explaining these topics as they
    usually come packed with your programming experience. Even though I understand
    debugging is not the most exciting experience, it is part of the job and it's
    really cool to learn about it when you get to the point where you actually need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move forward because it's time for some practical challenges! We'll
    start by building the Onboarding screen for the Stopwatch app that we're going
    to create further down the road in this book. I really hope you're ready for some
    neat tricks as the Onboarding screen is going to teach us a lot about `FlatList`
    and how to use a reference to control a component via another component. Now,
    get ready, set, go!
  prefs: []
  type: TYPE_NORMAL
