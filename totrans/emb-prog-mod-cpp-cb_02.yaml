- en: Setting Up the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start working with an embedded system, we need to set up an environment.
    Unlike the environment we use for desktop development, the environment for embedded programming
    requires two systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A build system**: The system you use to write the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A target system**: The system your code is going to be run on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to set up these two systems and connect them
    together. Configurations of build systems may vary significantly— there may be
    different operating systems, compilers, and IDEs. The variance in target system
    configurations is even greater since each embedded system is unique. Moreover,
    while you can use your laptop or desktop as a build system, you do need some sort
    of embedded board as a target system.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be impossible to cover all the possible combinations of build and
    target systems. Instead, we will just learn how to use one popular configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 18.04 as the build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi as the target system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use Docker to run Ubuntu in a virtual environment on your laptop or
    desktop. Docker supports Windows, macOS, and Linux, but, if you already use Linux,
    you can use it directly without running a container on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: We will use **Quick EMUlator** (**QEMU**)to emulate the Raspberry Pi board.
    This will teach us how to build applications for embedded boards even without
    access to the real hardware. Carrying out the initial phases of development in
    an emulated environment is common and, in many cases, the only possible practical
    solution, given that the target hardware may not be available when the software
    development starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the build system in a Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with emulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to an embedded system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging embedded applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gdbserver for remote debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CMake as a build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the build system in a Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will set up a Docker container to run Ubuntu 18.04 on your
    desktop or laptop. It does not matter what operating system runs on your machine,
    as Docker supports Windows, macOS, and Linux. As a result of this recipe, you
    will have a unified, virtualized Ubuntu Linux build system running within your
    host operating system.
  prefs: []
  type: TYPE_NORMAL
- en: If your operating system already runs Ubuntu Linux, feel free to skip to the
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to install the Docker application on our laptop or desktop and
    then use a ready-made image of Ubuntu to run this operating system in a virtual
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your web browser, open the following link and follow the instructions to
    set up Docker for your operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Windows: [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For macOS: [https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal window (Command Prompt in Windows, the Terminal app in macOS)
    and run the following command to check that it has been installed correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this command to use an Ubuntu image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a working directory. In either macOS, Linux shell, or Windows PowerShell,
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the downloaded image in the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the `uname -a` command to get information about the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You are now in a virtual Linux environment, which we will use for the subsequent
    recipes in this book.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first step, we install Docker—a virtualization environment that allows
    an isolated Linux operating system to run on Windows, macOS, or Linux. This is
    a convenient way of distributing and deploying containers that uniformly encapsulate
    all of the libraries and programs required for any operating system you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Docker, run a quick command to check whether it has been installed
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79bd5436-f274-476e-b093-973afff3e233.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After checking the installation, we need to fetch the ready-made Ubuntu image
    from the Docker repository. Docker images have tags; we can use the `bionic` tag
    to find Ubuntu version 18.04:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d3e8e8d-05b8-4ae5-b232-5a85936edf50.png)'
  prefs: []
  type: TYPE_IMG
- en: It takes time for the image to download. Once the image is fetched, we can create
    a directory, which we will use for development. The directory content will be
    shared between your operating system and Linux, running in Docker. This way, you
    can use your favorite text editor to work on code but still use the Linux build
    tools to compile the code into the binary executable files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can start a Docker container using the Ubuntu image fetched in step
    4\. The `option -v $HOME/test:/mnt` command line makes the folder created in step
    5 visible to Ubuntu as the `/mnt` directory. This means that all of the files
    you create in the `~/test` directory automatically appear in `/mnt`. The `-ti` option
    makes the container interactive, giving you access to the Linux shell environment
    (bash):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4702bc3f-9e14-4604-9fd1-aa4c28db0b03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we run a quick sanity check of the `. uname` container, which displays
    information about the Linux kernel, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d836a658-c6fa-4c21-bfd5-ce05d6bb5e53.png)'
  prefs: []
  type: TYPE_IMG
- en: Although the exact version of your kernel may differ, we can see that we are
    running Linux and our architecture is `x86`. This means we have set up our build
    environment, where we will be able to compile our code in a unified way, whatever
    operating system is running on our computer. However, we are still not able to
    run the compiled code because our target architecture is **Acorn RISC Machines** (**ARM**), not
    `x86`. We will learn how to set up an emulated ARM environment in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is a powerful and flexible system. Moreover, its repository contains
    lots of ready-made images that contain tools that are useful to most developers.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://hub.docker.com/search?q=&type=image](https://hub.docker.com/search?q=&type=image) and
    browse through the most popular images. You can also search for images using keywords,
    such as *embedded*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with emulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a real embedded board is not always possible or practical—hardware is
    not yet ready, or the number of boards is limited. Emulators help developers use
    an environment that's as close to the target system as possible, yet do not depend
    on hardware availability. It is also the best way to start learning embedded development.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to set up QEMU (a hardware emulator) and configure
    it to emulate an ARM-based embedded system running Debian Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a virtual environment that, unlike Docker, can emulate processors with
    architectures that differ from the architecture of our computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://www.qemu.org/download/](https://www.qemu.org/download/)
    and click on the tab that matches your operating system—Linux, macOS, or Windows—and
    follow the installation instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a test directory, unless one already exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the following files and copy them over to the `~/raspberry` directory
    you created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Raspbian Lite zip-archive**: [http://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2019-07-12/2019-07-10-raspbian-buster-lite.zip](http://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2019-07-12/2019-07-10-raspbian-buster-lite.zip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel imag**e: [https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/kernel-qemu-4.14.79-stretch](https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/kernel-qemu-4.14.79-stretch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device tree blob**: [https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/versatile-pb.dtb](https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/versatile-pb.dtb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the directory to `~/raspberry` and extract the Raspbian Lite zip archive
    downloaded in the previous step. It contains a single file named ` 2019-07-10-raspbian-buster-lite.img`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal window and run QEMU. For Windows and Linux, the command line
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A new window should show up, displaying the Linux boot process. In a few seconds,
    a login prompt will be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in using `pi` as the username and `raspberry` as the password. Then, type
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Check the output of the command. It indicates that our system architecture is
    `ARM`, not `x86`. Now we can use this environment to test applications built for
    the ARM platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first step, we install the QEMU emulator. Without the loadable code
    images, this virtual machine doesn''t have much use. Then, we can fetch the three
    images required to run a Linux operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Linux root filesystem**: Contains a snapshot of Raspbian Linux, used
    on Raspberry Pi devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Linux kernel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Device tree blob**: Contains a description of the hardware components
    of a system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once all the images are fetched and put into the `~/raspberry` directory, we
    run QEMU, providing paths to the images as command-line parameters. Additionally,
    we configure the virtual network, which allows us to connect to the Linux system
    running in the virtual environment from our native environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'After QEMU starts, we can see a window with a Linux login prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1681dd1f-e0a3-43b8-a1aa-dbc92d5a9f73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After logging into the system, we can run a quick sanity check by running the
    `uname` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23196296-b663-4e7f-9a88-e4f588196eb3.png)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the sanity check we ran in the previous recipe, *Setting up the build
    system in a Docker container*, this shows that we are running a Linux operating
    system, but, in this case, we can see that the target architecture is `ARM`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QEMU is a powerful processor emulator that supports other multiple architectures
    aside from x86 and ARM, such as PowerPC, SPARC64, SPARC32, and **Microprocessor
    without Interlocked Pipelined Stages** (**MIPS**). One aspect that makes it so
    powerful is its flexibility, due to its many configuration options. Go to [https://qemu.weilnetz.de/doc/qemu-doc.html](https://qemu.weilnetz.de/doc/qemu-doc.html)
    to configure QEMU to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Microcontroller vendors also often provide emulators and simulators. When starting
    development for particular hardware, check for the available emulation options,
    as it might significantly affect the development time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned that the environment for embedded development consists
    of two systems: the build system, where you write and build code, and the host
    system, which runs the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have two virtualized environments set up:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Linux in a Docker container, which will be our build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QEMU running Raspbian Linux, which will be our host system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will set up the cross-compilation tools required to build
    Linux applications for the ARM platform and build a simple *Hello, world!* application
    to test the setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up the cross-compilation toolkit, we will need to use Ubuntu Linux, which
    we set up in the *Setting up the build system in a Docker container* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We also need the `~/test` directory to exchange our source code between our
    operating system and the Ubuntu container.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a simple C++ program, which we want to compile for
    our target platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `hello.cpp` in the `~/test` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your favorite text editor to add the following code snippet to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the code for the `Hello, world!` program, we need to compile
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the Ubuntu (our build system) console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the up-to-date list of packages available for the installation by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take some time to fetch the package descriptions from the Ubuntu servers. Run
    the following command to install the cross-compilation tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a long list of packages to install. Press *Y* to confirm the installation.As
    a sanity check, run a cross-compiler with no parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Change the directory to `/mnt`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hello.cpp` file that we created in step 1 is located here. Let''s now
    build it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command generates an executable file named `hello`. You may be wondering
    why it doesn't have any extensions. In Unix systems, extensions are completely
    optional and binary executable files usually do not have any extensions. Try to
    run the file. It should fail with an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's generate the details about the executable binary using the `file` tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first step, we created a simple *Hello, World!* C++ program. We put this
    into the `~/test` directory, which makes it accessible from the Docker container
    running Linux.
  prefs: []
  type: TYPE_NORMAL
- en: To build the source code, we switched to the Ubuntu shell.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to run a standard Linux  g++ compiler to build it, we will get an
    executable for the build platform, which is x86\. However, we need an executable
    for the ARM platform. To build it, we need a version of the compiler that can
    run on x86, building the ARM code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a preliminary step, we need to update the information about the packages
    available in the Ubuntu packages distributive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1973b89b-07cc-4125-a9fe-000c0969f05d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can install this compiler, along with a set of related tools, by running
    `apt-get install crossbuild-essential-armel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc1bdb2c-8f41-4ec3-9073-ffd6ff23487d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The quick sanity check carried out in step 9 shows that it was properly installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d99fc73-58e6-4651-8d87-e5bfe30c77e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we need to build `hello.cpp` using the cross-compiler. It generates the
    executable for the ARM platform, which is why our attempt to run it in the build
    system in step 12 fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure it is really an ARM executable, we need to run the `file` command.
    Its output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fbe1b85-47b4-4f1c-aada-898888a43b66.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the binary is built for the ARM platform, which is why it fails
    to run on a build system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many cross-compilation toolkits exist for various architectures. Some of them
    are readily available in the Ubuntu repository; some may require manual installation.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the embedded system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After an embedded application is built on a build system using a cross-compiler,
    it should be transferred to the target system. The best way to do this on Linux-based
    embedded systems is by using networking connectivity and a remote shell. **Secure
    Shell** (**SSH**) is widely used due to its security and versatility. It allows
    you to not only run shell commands on a remote host but also copy files from one
    machine to another using cryptographic encryption and key-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to copy the application binary to the emulated
    ARM system using secure copy, connect to it using SSH, and run the executable
    in SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the Raspberry Pi emulator we set up in the *Working with emulators*
    recipe as our target system. Also, we need our Ubuntu build system and the executable
    `hello` file we built in the *Cross-compilation* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to access our target system via the network. QEMU provides a virtual
    network interface for the emulated machine, and we can use it without connecting
    to a real network. In order to do so, we need to figure out an IP address to use
    and make sure that the SSH server is running in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: In your native operating system environment, work out the IP address of your
    machine. Open a Terminal window or PowerShell. Run `ifconfig` on macOS, or Linux,
    or `ipconfig` for Windows, and check its output.
  prefs: []
  type: TYPE_NORMAL
- en: In the next steps, we will use `192.168.1.5` as a template IP address; you will
    need to replace it with your actual IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the Raspberry Pi emulator and enable SSH services by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the Ubuntu window and install the SSH client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can copy the `hello` executable to the target system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When asked for a password, type `raspberry`. Switch back to the Raspberry Pi
    emulator window. Check that the executable we just copied is there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the program is now running as expected.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we set up a data exchange between two virtual environments—Docker
    and QEMU—using SSH. To do this, we need an SSH server to be running and accepting
    connections on the target system (QEMU), and an SSH client initiating connections
    on the build system.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we set up the SSH client on our build system. Our target system,
    running in QEMU, already had an SSH server up and running. During the *Working
    with emulators* recipe, we configured QEMU to forward connections from our host
    port, `22023`, to our virtual machine port, `22`, which is SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use `scp` to copy a file from the build system to the target system
    using a secure network connection. We can specify our system IP address (discovered
    in step 1) and port `22023`, configured for QEMU forwarding, as parameters for `scp`
    to connect to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc75eea7-7ccb-43ea-9e30-f3f3857a007a.png)'
  prefs: []
  type: TYPE_IMG
- en: After we have copied the file, we can log in to the target system with SSH using
    the same IP address, port, and username as we used for `scp`. It opens a login
    prompt similar to the local console and, after authorization, we get the same
    command shell as the local terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The `hello` application we copied in the previous step should be available in
    the `home` directory. We checked this in step 5 by running the `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/087a7c0c-6ec1-4a7f-bcba-097249ccd47a.png)'
  prefs: []
  type: TYPE_IMG
- en: When we tried to run it on our build system, we received an error. Now, the
    output is `Hello, world!`. This is what we would expect, since our application
    is built for the ARM platform and being run on the ARM platform.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we ran the recipe to connect to the emulated system, the same steps
    are applicable for real embedded systems. Even if a target system does not have
    a display, you can set up SSH using the serial console connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we only copied files to our target system. Besides copying,
    it is a common practice to open an interactive SSH session to the embedded system.
    Usually, it is more efficient and convenient to use than a serial console. It
    is established in a similar way to `scp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: SSH provides various authentication mechanisms. Once you enable and set up public
    key authentication, there is no need to type in your password for every copy or
    login. This makes the development process faster and more convenient for developers.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about ss keys, go to [https://www.ssh.com/ssh/key/](https://www.ssh.com/ssh/key/).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging embedded applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging embedded applications depends significantly on the type of the target
    embedded systems. Microcontroller manufacturers often provide specialized debuggers
    for their **microcontroller units** (**MCUs**) as well as hardware support for
    remote debugging using a **Joint Test Action Group** (**JTAG**) protocol. It allows
    developers to debug the microcontroller code immediately after the MCU starts
    executing instructions.
  prefs: []
  type: TYPE_NORMAL
- en: If the target board runs Linux, the most practical method of debugging is to
    use an extensive debug output and to use GDB as an interactive debugger.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to run our application in a command-line debugger: GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how to transfer executable files to the target system.
    We will use the *Connecting to the embedded system* recipe as a starting point
    to learn how to use a debugger on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to copy an application to the target system and run it
    there. Now, let''s learn how to start debugging an application on a target system
    using GDB. In this recipe, we will only learn how to invoke the debugger and run
    applications in the debugger environment. It will be used as a foundation for
    more advanced and practical debugging techniques later:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the `QEMU` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not done so already, log in using `pi` as the username and `raspberry`
    as the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will open the `gdb` command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `run` to run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should see `Hello, world` in the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the `quit` command, or just `q`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This terminates the debugging session and returns us back to the Linux shell.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi image we use for emulation comes with a pre-installed GNU debugger,
    so we can use it right away.
  prefs: []
  type: TYPE_NORMAL
- en: In the `home` user directory, we should find the `hello` executable file, which
    we copied from our build system as part of the *Connecting to the embedded system*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We run `gdb`, passing the path to the `hello` executable as a parameter. This
    command opens the `gdb` shell but does not run the application itself. To run
    it, we type in the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7730a5e6-f9ba-4ae2-99c8-d775757b5df3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application runs, printing the  `Hello world!` message on the screen, and
    then terminates. However, we are still in the debugger. To exit the debugger,
    we type the `quit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c14581e-4665-4e97-9cc1-b58a262cd717.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the command-line prompt has changed. It is an indication that
    we are not in the `gdb` environment anymore. We have returned to the default shell
    environment of Raspberry Pi Linux, which we were using before running GDB.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A GNU debugger is pre-installed in this case, but it may not be in your real
    target system. If it is Debian-based, you can install it by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In other Linux-based systems, different commands to install GDB are required.
    In many cases, you will need to build it from source code and install it manually,
    similarly to the `hello` application we have built and tested as part of the recipes
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we only learned how to run an application using GDB, which is
    a complex tool with lots of commands, techniques, and best practices. We will
    discuss some of them in the [Chapter 5](345afa8f-ca7a-48f8-a941-1f34c08e4844.xhtml), *Debugging,
    Logging, and Profiling*.
  prefs: []
  type: TYPE_NORMAL
- en: Using gdbserver for remote debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed, the environment for embedded development usually involves
    two systems—a build system and a target system (or emulator). Sometimes, interactive
    debugging on the target system is impractical because of the high latency of remote
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: In such situations, developers can use remote debugging support provided by
    GDB. In this setup, an embedded application is launched on the target system using
    **gdbserver**. Developers run GDB on a build system and connect to gdbserver over
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to start debugging an application using GDB
    and gdbserver.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Connecting to the embedded system* recipe, we learned how to make our
    application available on the target system. We will use that recipe as a starting
    point to learn a remote debugging technique.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to install and run the gdbserver application, which will allow
    us to run GDB on our build system and forward all commands to the target system. Switch
    to the Raspberry Pi emulator window.
  prefs: []
  type: TYPE_NORMAL
- en: Log in as `pi` using the `raspberry` password, unless you're already logged
    in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To install gdbserver, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `hello` application under `gdbserver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the build system terminal and change the directory to `/mnt/hello`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `gdb-multiarch` package, which provides the necessary support for
    the ARM platform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run `gdb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the remote connection by typing the following command in the `gdb`
    command line (make sure you replace `192.168.1.5` with your actual IP address):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The program will now run.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Raspberry Pi image we used, `gdbserver` is not installed by default.
    So, as a first step, we install `gdbserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09463e0a-5205-4696-9876-eccdbfae92b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the installation is complete, we run `gdbserver`, passing the name of
    the application that needs to be debugged, the IP address, and the port to listen
    out for incoming connections as its parameters. We use `0.0.0.0` as the IP address
    to indicate that we want to accept connections on any IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dbebcae-bc8b-4787-8b91-684276dde525.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we switch to our build system and run `gdb` there. But, instead of running
    the application in GDB directly, we instruct `gdb` to initiate a connection to
    a remote host using the IP address and port provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a3f076e-ed50-4130-8ebf-c13b191c319b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, all the commands you type at the `gdb` prompt will be transferred
    to gdbserver and executed there. When we run the application, we will see the
    resulting output in the `gdb` console of the build system, even if we run the
    ARM executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6f43a8b-2667-4422-ad15-e67e910f560f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An explanation is simple—the binary runs on a remote ARM system: our Raspberry
    Pi emulator. This is a convenient way of debugging applications on a target platform,
    allowing you to remain in the more comfortable environment of your build system.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure that the versions of GDB and gdbserver that you are using match, otherwise
    there can be issues with communication between them.
  prefs: []
  type: TYPE_NORMAL
- en: Using CMake as a build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we learned how to compile a program that consists of
    one C++ file. Real applications, however, usually have a more complex structure.
    They can contain multiple source files, depend on other libraries, and be split
    into independent projects.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to conveniently define build rules for any type of application.
    CMake is one of the most well-known and widely used tools that allow developers
    to define high-level rules and translate them into a lower-level build system,
    such as a Unix make.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to set up CMake and create a simple project
    definition for our *Hello, world!* application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed earlier, a common embedded development workflow includes two environments:
    a build system and a target system. CMake is part of the build system. We are
    going to use the Ubuntu build system, created as a result of the *Setting up the
    build system in a Docker container* recipe, as a starting point.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our build system does not have CMake installed yet. To install it, run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Switch back to your native operating system environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `~/test` directory, create a subdirectory, `hello`. Use your favorite
    text editor to create a file, called `CMakeLists.txt`, in the `hello` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and switch to the Ubuntu console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the `hello` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run CMake:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build the application by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Get information about the resulting executable binary using the `file` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the build is native to the x86 platform. We need to add cross-compilation
    support. Switch back to the text editor, open `CMakeLists.txt`, and add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Save it and switch to the Ubuntu terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `cmake` command again to re-generate the build files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the code by running `make`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the type of the resulting output file again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have an executable file built for our target system using CMake.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we install CMake to our build system. Once the installation is complete,
    we switch to the native environment to create `CMakeLists.txt`. This file contains
    high-level build instructions about the project's composition and properties.
  prefs: []
  type: TYPE_NORMAL
- en: We name our project *hello*, which creates an executable, called `hello`, from
    a source file named `hello.cpp`*.* Additionally, we specify the minimal version
    of CMake required to build our application.
  prefs: []
  type: TYPE_NORMAL
- en: After we have created the project definition, we can switch back to the build
    system shell and generate low-level build instructions by running `make`.
  prefs: []
  type: TYPE_NORMAL
- en: It is common practice to create a dedicated build directory to keep all our
    build artifacts. By doing this, the object files generated by a compiler or files
    generated by CMake do not pollute the source code directories.
  prefs: []
  type: TYPE_NORMAL
- en: In a single command line, we create a `build` directory, change to the newly-created
    directory, and run CMake.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the parent directory as a parameter to let CMake know where to look
    for `CMakeListst.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14a5bf44-2185-478b-a144-94f6030053c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, CMake generates the `Makefile` files for the traditional Unix `make`
    utility. We run `make `to actually build the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5983eee-a06d-4d26-9441-8274013cf7be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It works, but results in an executable binary built for the x86 platform, while
    our target system is ARM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f2aedf6-d441-4e80-a11a-4778c32d273e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To solve this, we add several options to our `CMakeLists.txt` file to configure
    cross-compilation. Repeating the build steps again, we get a new `hello` binary,
    now for the ARM platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfdf7699-32f3-41bf-a3fe-54adbf11e341.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the output of the `file` command, we have built the executable
    file for the ARM platform, not x86, which we used as a build platform. This means
    that this program will not run on the build machine, but can be successfully copied
    to our target platform and run there.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to configure cross-compilation for CMake is by using the so-called
    **toolchain** files. Toolchain files define all the settings and parameters of
    the build rules specific to the particular target platform, such as a compiler
    prefix, compilation flags, and the location of the libraries pre-built on the
    target platform. An application can be rebuilt for different target platforms
    by using different toolchain files. See the CMake toolchains documentation at
    [https://cmake.org/cmake/help/v3.6/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/v3.6/manual/cmake-toolchains.7.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
