- en: Introduction to Penetration Testing and Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application uses the HTTP protocol for client-server communication and
    requires a web browser as the client interface. It is probably the most ubiquitous
    type of application in modern companies, from Human Resources' organizational
    climate surveys to IT technical services for a company's website. Even thick and
    mobile applications and many **Internet of Things** (**IoT**) devices make use
    of web components through web services and the web interfaces that are embedded
    into them.
  prefs: []
  type: TYPE_NORMAL
- en: Not long ago, it was thought that security was necessary only at the organization's
    perimeter and only at network level, so companies spent considerable amount of
    money on physical and network security. With that, however, came a somewhat false
    sense of security because of their reliance on web technologies both inside and
    outside of the organization. In recent years and months, we have seen news of
    spectacular data leaks and breaches of millions of records including information
    such as credit card numbers, health histories, home addresses, and the **Social
    Security Numbers** (**SSNs**) of people from all over the world. Many of these
    attacks were started by exploiting a web vulnerability or design failure.
  prefs: []
  type: TYPE_NORMAL
- en: Modern organizations acknowledge that they depend on web applications and web
    technologies, and that they are as prone to attack as their network and operating
    systems—if not more so. This has resulted in an increase in the number of companies
    who provide protection or defense services against web attacks, as well as the
    appearance or growth of technologies such as **Web Application Firewall** (**WAF**),
    **Runtime Application Self-Protection** (**RASP**), web vulnerability scanners,
    and source code scanners. Also, there has been an increase in the number of organizations
    that find it valuable to test the security of their applications before releasing
    them to end users, providing an opportunity for talented hackers and security
    professionals to use their skills to find flaws and provide advice on how to fix
    them, thereby helping companies, hospitals, schools, and governments to have more
    secure applications and increasingly improved software development practices.
  prefs: []
  type: TYPE_NORMAL
- en: Proactive security testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Penetration testing** and **ethical hacking** are proactive ways of testing
    web applications by performing attacks that are similar to a real attack that
    could occur on any given day. They are executed in a controlled way with the objective
    of finding as many security flaws as possible and to provide feedback on how to
    mitigate the risks posed by such flaws.'
  prefs: []
  type: TYPE_NORMAL
- en: It is very beneficial for companies to perform security testing on applications
    before releasing them to end users. In fact, there are security-conscious corporations
    that have nearly completely integrated penetration testing, vulnerability assessments,
    and source code reviews in their software development cycle. Thus, when they release
    a new application, it has already been through various stages of testing and remediation.
  prefs: []
  type: TYPE_NORMAL
- en: Different testing methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'People are often confused by the following terms, using them interchangeably
    without understanding that, although some aspects of these terms overlap, there
    are also subtle differences that require your attention:'
  prefs: []
  type: TYPE_NORMAL
- en: Ethical hacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Penetration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security audits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethical hacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very few people realize that hacking is a misunderstood term; it means different
    things to different people, and more often than not a hacker is thought of as
    a person sitting in a dark enclosure with no social life and malicious intent.
    Thus, the word ethical is prefixed here to the term, hacking. The term, **ethical
    hacker** is used to refer to professionals who work to identify loopholes and
    vulnerabilities in systems, report it to the vendor or owner of the system, and,
    at times, help them fix the system. The tools and techniques used by an ethical
    hacker are similar to the ones used by a cracker or a black hat hacker, but the
    aim is different as it is used in a more professional way. Ethical hackers are
    also known as *security researchers*.
  prefs: []
  type: TYPE_NORMAL
- en: Penetration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Penetration testing is a term that we will use very often in this book, and
    it is a subset of ethical hacking. It is a more professional term used to describe
    what an ethical hacker does. If you are planning a career in ethical hacking or
    security testing, then you would often see job postings with the title, Penetration
    Tester. Although penetration testing is a subset of ethical hacking, it differs
    in many ways. It's a more streamlined way of identifying vulnerabilities in systems
    and finding out if the vulnerability is exploitable or not. Penetration testing
    is governed by a contract between the tester and owner of the systems to be tested.
    You need to define the scope of the test in order to identify the systems to be
    tested. Rules of Engagement need to be defined, which determines the way in which
    the testing is to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, organizations might want only to identify the vulnerabilities that
    exist in their systems without actually exploiting them and gaining access. Vulnerability
    assessments are broader than penetration tests. The end result of **vulnerability
    assessment** is a report prioritizing the vulnerabilities found, with the most
    severe ones listed at the top and the ones posing a lesser risk appearing lower
    in the report. This report is very helpful for clients who know that they have
    security issues and who need to identify and prioritize the most critical ones.
  prefs: []
  type: TYPE_NORMAL
- en: Security audits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Auditing** is a systematic procedure that is used to measure the state of
    a system against a predetermined set of standards. These standards can be industry
    best practices or an in-house checklist. The primary objective of an audit is
    to measure and report on conformance. If you are auditing a web server, some of
    the initial things to look out for are the open ports on the server, harmful HTTP
    methods, such as `TRACE`, enabled on the server, the encryption standard used,
    and the key length.'
  prefs: []
  type: TYPE_NORMAL
- en: Considerations when performing penetration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When planning to execute a penetration testing project, be it for a client as
    a professional penetration tester or as part of a company's internal security
    team, there are aspects that always need to be considered before starting the
    engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of Engagement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rules of Engagement** (**RoE**) is a document that deals with the manner
    in which the penetration test is to be conducted. Some of the directives that
    should be clearly spelled out in RoE before you start the penetration test are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The type and scope of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client contact details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client IT team notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive data handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status meeting and reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type and scope of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type of testing can be black box, white box, or an intermediate gray box,
    depending on how the engagement is performed and the amount of information shared
    with the testing team.
  prefs: []
  type: TYPE_NORMAL
- en: There are things that can and cannot be done in each type of testing. With **black
    box testing**, the testing team works from the view of an attacker who is external
    to the organization, as the penetration tester starts from scratch and tries to
    identify the network map, the defense mechanisms implemented, the internet-facing
    websites and services, and so on. Even though this approach may be more realistic
    in simulating an external attacker, you need to consider that such information
    may be easily gathered from public sources or that the attacker may be a disgruntled
    employee or ex-employee who already possess it. Thus, it may be a waste of time
    and money to take a black box approach if, for example, the target is an internal
    application meant to be used by employees only.
  prefs: []
  type: TYPE_NORMAL
- en: '**White box testing** is where the testing team is provided with all of the
    available information about the targets, sometimes even including the source code
    of the applications, so that little or no time is spent on reconnaissance and
    scanning. A gray box test then would be when partial information, such as URLs
    of applications, user-level documentation, and/or user accounts are provided to
    the testing team.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gray box testing** is especially useful when testing web applications, as
    the main objective is to find vulnerabilities within the application itself, not
    in the hosting server or network. Penetration testers can work with user accounts
    to adopt the point of view of a malicious user or an attacker that gained access
    through social engineering.'
  prefs: []
  type: TYPE_NORMAL
- en: When deciding on the scope of testing, the client along with the testing team
    need to evaluate what information is valuable and necessary to be protected, and
    based on that, determine which applications/networks need to be tested and with
    what degree of access to the information.
  prefs: []
  type: TYPE_NORMAL
- en: Client contact details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can agree that even when we take all of the necessary precautions when conducting
    tests, at times the testing can go wrong because it involves making computers
    do nasty stuff. Having the right contact information on the client-side really
    helps. A penetration test is often seen turning into a **Denial-of-Service** (**DoS**)
    attack. The technical team on the client side should be available 24/7 in case
    a computer goes down and a hard reset is needed to bring it back online.
  prefs: []
  type: TYPE_NORMAL
- en: Penetration testing web applications has the advantage that it can be done in
    an environment that has been specially built for that purpose, allowing the testers
    to reduce the risk of negatively affecting the client's productive assets.
  prefs: []
  type: TYPE_NORMAL
- en: Client IT team notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Penetration tests are also used as a means to check the readiness of the support
    staff in responding to incidents and intrusion attempts. You should discuss this
    with the client whether it is an announced or unannounced test. If it's an announced
    test, make sure that you inform the client of the time and date, as well as the
    source IP addresses from where the testing (attack) will be done, in order to
    avoid any real intrusion attempts being missed by their IT security team. If it's
    an unannounced test, discuss with the client what will happen if the test is blocked
    by an automated system or network administrator. Does the test end there, or do
    you continue testing? It all depends on the aim of the test, whether it's conducted
    to test the security of the infrastructure or to check the response of the network
    security and incident handling team. Even if you are conducting an unannounced
    test, make sure that someone in the escalation matrix knows about the time and
    date of the test. Web application penetration tests are usually announced.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During test preparation and execution, the testing team will be provided with
    and may also find sensitive information about the company, the system, and/or
    its users. Sensitive data handling needs special attention in the RoE and proper
    storage and communication measures should be taken (for example, full disk encryption
    on the testers' computers, encrypting reports if they are sent by email, and so
    on). If your client is covered under the various regulatory laws such as the **Health
    Insurance Portability and Accountability Act** (**HIPAA**), the **Gramm-Leach-Bliley
    Act** (**GLBA**), or the European data privacy laws, only authorized personnel
    should be able to view personal user data.
  prefs: []
  type: TYPE_NORMAL
- en: Status meeting and reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication is key for a successful penetration test. Regular meetings should
    be scheduled between the testing team and the client organization and routine
    status reports issued by the testing team. The testing team should present how
    far they have reached and what vulnerabilities have been found up to that point.
    The client organization should also confirm whether their detection systems have
    triggered any alerts resulting from the penetration attempt. If a web server is
    being tested and a WAF was deployed, it should have logged and blocked attack
    attempts. As a best practice, the testing team should also document the time when
    the test was conducted. This will help the security team in correlating the logs
    with the penetration tests.
  prefs: []
  type: TYPE_NORMAL
- en: WAFs work by analyzing the HTTP/HTTPS traffic between clients and servers, and
    they are capable of detecting and blocking the most common attacks on web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The limitations of penetration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although penetration tests are recommended and should be conducted on a regular
    basis, there are certain limitations to penetration testing. The quality of the
    test and its results will directly depend on the skills of the testing team. Penetration
    tests cannot find all of the vulnerabilities due to the limitation of scope, limitation
    of access of penetration testers to the testing environment, and limitations of
    tools used by the tester. The following are some of the limitations of a penetration
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limitation of skills**: As mentioned earlier, the success and quality of
    the test will directly depend on the skills and experience of the penetration
    testing team. Penetration tests can be classified into three broad categories:
    network, system, and web application penetration testing. You will not get correct
    results if you make a person skilled in network penetration testing work on a
    project that involves testing a web application. With the huge number of technologies
    deployed on the internet today, it is hard to find a person skillful in all three.
    A tester may have in-depth knowledge of Apache web servers, but might be encountering
    an IIS server for the first time. Past experience also plays a significant role
    in the success of the test; mapping a low-risk vulnerability to a system that
    has a high level of threat is a skill that is only acquired through experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitation of time**: Penetration testing is often a short-term project that
    has to be completed in a predefined time period. The testing team is required
    to produce results and identify vulnerabilities within that period. Attackers,
    on the other hand, have much more time to work on their attacks and can plan them
    carefully. Penetration testers also have to produce a report at the end of the
    test, describing the methodology, vulnerabilities identified, and an executive
    summary. Screenshots have to be taken at regular intervals, which are then added
    to the report. Clearly, an attacker will not be writing any reports and can therefore
    dedicate more time to the actual attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitation of custom exploits**: In some highly secure environments, normal
    penetration testing frameworks and tools are of little use and the team is required
    to think outside of the box, such as by creating a custom exploit and manually
    writing scripts to reach the target. Creating exploits is extremely time consuming,
    and it affects the overall budget and time for the test. In any case, writing
    custom exploits should be part of the portfolio of any self-respecting penetration
    tester.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoiding DoS attack**: Hacking and penetration testing is the art of making
    a computer or application do things that it was not designed to do. Thus, at times,
    a test may lead to a DoS attack rather than gaining access to the system. Many
    testers do not run such tests in order to avoid inadvertently causing downtime
    on the system. Since systems are not tested for DoS attacks, they are more prone
    to attacks by script kiddies, who are just out there looking for such internet-accessible
    systems in order to seek fame by taking them offline. **Script kiddies** are unskilled
    individuals who exploit easy-to-find and well-known weaknesses in computer systems
    in order to gain notoriety without understanding, or caring about, the potential
    harmful consequences. Educating the client about the pros and cons of a DoS test
    should be done, as this will help them to make the right decision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitation of access**: Networks are divided into different segments, and
    the testing team will often have access and rights to test only those segments
    that have servers and are accessible from the internet in order to simulate a
    real-world attack. However, such a test will not detect configuration issues and
    vulnerabilities on the internal network where the clients are located.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limitations of tools used**: Sometimes, the penetration testing team is only
    allowed to use a client-approved list of tools and exploitation frameworks. No
    one tool is complete irrespective of it being a free version or a commercial one.
    The testing team needs to be knowledgeable about these tools, and they will have
    to find alternatives when features are missing from them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to overcome these limitations, large organizations have a dedicated
    penetration testing team that researches new vulnerabilities and performs tests
    regularly. Other organizations perform regular configuration reviews in addition
    to penetration tests.
  prefs: []
  type: TYPE_NORMAL
- en: The need for testing web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the huge number of internet-facing websites and the increase in the number
    of organizations doing business online, web applications and web servers make
    an attractive target for attackers. Web applications are everywhere across public
    and private networks, so attackers don't need to worry about a lack of targets.
    Only a web browser is required to interact with a web application. Some of the
    defects in web applications, such as logic flaws, can be exploited even by a layman.
    For example, due to bad implementation of logic, if a company has an e-commerce
    website that allows the user to add items to their cart after the checkout process
    and a malicious user finds this out through trial and error, they would then be
    able to exploit this easily without needing any special tools.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerabilities in web applications also provide a means for spreading malware
    and viruses, and these can spread across the globe in a matter of minutes. Cybercriminals
    realize considerable financial gains by exploiting web applications and installing
    malware that will then be passed on to the application's users.
  prefs: []
  type: TYPE_NORMAL
- en: Firewalls at the edge are more permissive to inbound HTTP traffic flowing towards
    the web server, so the attacker does not require any special ports to be open.
    The HTTP protocol, which was designed many years ago, does not provide any built-in
    security features; it's a cleartext protocol, and it requires the additional layering
    of using the HTTPS protocol in order to secure communication. It also does not
    provide individual session identification, and it leaves it to the developer to
    design it in. Many developers are hired directly out of college, and they have
    only theoretical knowledge of programming languages and no prior experience with
    the security aspects of web application programming. Even when the vulnerability
    is reported to the developers, they take a long time to fix it as they are busier
    with the feature creation and enhancement portion of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Secure coding starts with the architecture and designing phase of web applications,
    so it needs to be integrated early into the development cycle. Integrating security
    later will prove to be difficult, and it requires a lot of rework. Identifying
    risks and threats early in the development phase using threat modeling really
    helps in minimizing vulnerabilities in the production-ready code of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Investing resources in writing secure code is an effective method for minimizing
    web application vulnerabilities. However, writing secure code is easy to say but
    difficult to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons to guard against attacks on web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the most compelling reasons to guard against attacks on web applications
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Protecting customer data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compliance with law and regulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loss of reputation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revenue loss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protection against business disruption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the web application interacts with and stores credit card information, then
    it needs to be in compliance with the rules and regulations laid out by **Payment
    Card Industry** (**PCI**). PCI has specific guidelines, such as reviewing all
    code for vulnerabilities in the web application or installing a WAF in order to
    mitigate the risk.
  prefs: []
  type: TYPE_NORMAL
- en: When the web application is not tested for vulnerabilities and an attacker gains
    access to customer data, it can severely affect the brand of the company if a
    customer files a lawsuit against the company for not adequately protecting their
    data. It may also lead to revenue losses, since many customers will move to competitors
    who might assure better security.
  prefs: []
  type: TYPE_NORMAL
- en: Attacks on web applications may also result in severe disruption of service
    if it's a DoS attack, if the server is taken offline to clean up the exposed data,
    or for a forensics investigation. This might be reflected negatively in the financial
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: These reasons should be enough to convince the senior management of your organization
    to invest resources in terms of money, manpower, and skills in order to improve
    the security of your web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we will use the tools provided by Kali Linux to accomplish our
    testing. Kali Linux is a Debian-based GNU/Linux distribution. Kali Linux is used
    by security professionals to perform offensive security tasks, and it is maintained
    by a company known as Offensive Security. The predecessor of Kali Linux is BackTrack,
    which was one of the primary tools used by penetration testers for more than six
    years until 2013, when it was replaced by Kali Linux. In August 2015, the second
    version of Kali Linux was released with the code name Kali Sana, and in January
    2016, it switched to a *rolling release*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the software is continuously updated without the need to change
    the operating system version. Kali Linux comes with a large set of popular hacking
    tools, which are ready to use with all of the prerequisites installed. We will
    take a deep dive into the tools and use them to test web applications that are
    vulnerable to major flaws which are found in real-world web applications.
  prefs: []
  type: TYPE_NORMAL
- en: A web application overview for penetration testers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications involve much more than just HTML code and web servers. If you
    are not a programmer who is actively involved in the development of web applications,
    then chances are that you are unfamiliar with the inner workings of the HTTP protocol,
    the different ways web applications interact with the database, and what exactly
    happens when a user clicks a link or enters the URL of a website into their web
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a penetration tester, understanding how the information flows from the client
    to the server and database and then back to the client is very important. This
    section will include information that will help an individual who has no prior
    knowledge of web application penetration testing to make use of the tools provided
    in Kali Linux to conduct an end-to-end web penetration test. You will get a broad
    overview of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headers in HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session tracking using cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture of web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The underlying protocol that carries web application traffic between the web
    server and the client is known as the **Hypertext Transport Protocol** (**HTTP**).
    HTTP/1.1, the most common implementation of the protocol, is defined in RFCs 7230-7237,
    which replaced the older version defined in RFC 2616\. The latest version, known
    as HTTP/2, was published in May 2015, and it is defined in RFC 7540\. The first
    release, HTTP/1.0, is now considered obsolete and is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: As the internet evolved, new features were added to the subsequent releases
    of the HTTP protocol. In HTTP/1.1, features such as persistent connections, `OPTIONS`
    method, and several other improvements in the way HTTP supports caching were added.
  prefs: []
  type: TYPE_NORMAL
- en: RFC is a detailed technical document describing internet standards and protocols
    created by the **Internet Engineering Task Force** (**IETF**). The final version
    of the RFC document becomes a standard that can be followed when implementing
    the protocol in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a client-server protocol, wherein the client (web browser) makes a request
    to the server and in return the server responds to the request. The response by
    the server is mostly in the form of HTML-formatted pages. By default, HTTP protocol
    uses port `80`, but the web server and the client can be configured to use a different
    port.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a cleartext protocol, which means that all of the information between
    the client and server travels unencrypted, and it can be seen and understood by
    any intermediary in the communication chain. To tackle this deficiency in HTTP's
    design, a new implementation was released that establishes an encrypted communication
    channel with the **Secure Sockets Layer** (**SSL**) protocol and then sends HTTP
    packets through it. This was called HTTPS or HTTP over SSL. In recent years, SSL
    has been increasingly replaced by a newer protocol called **Transport Layer Security**
    (**TLS**), currently in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing an HTTP request and response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An HTTP request is the message a client sends to the server in order to get
    some information or execute some action. It has two parts separated by a blank
    line: the header and body. The header contains all of the information related
    to the request itself, response expected, cookies, and other relevant control
    information, and the body contains the data exchanged. An HTTP response has the
    same structure, changing the content and use of the information contained within
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: The request header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an HTTP request captured using a web application proxy when browsing
    to `www.bing.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line in this header indicates the method of the request: `GET`, the
    resource requested: `/` (that is, the root directory) and the protocol version:
    `HTTP 1.1`. There are several other fields that can be in an HTTP header. We will
    discuss the most relevant fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Host**: This specifies the host and port number of the resource being requested.
    A web server may contain more than one site, or it may contain technologies such
    as shared hosting or load balancing. This parameter is used to distinguish between
    different sites/applications served by the same infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-Agent**: This field is used by the server to identify the type of client
    (that is, web browser) which will receive the information. It is useful for developers
    in that the response can be adapted according to the user''s configuration, as
    not all features in the HTTP protocol and in web development languages will be
    compatible with all browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie**: Cookies are temporary values exchanged between the client and server
    and used, among other reasons, to keep session information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content-Type**: This indicates to the server the media type contained within
    the request''s body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: HTTP allows for per-request client authentication through
    this parameter. There are multiple modes of authenticating, with the most common
    being `Basic`, `Digest`, `NTLM`, and `Bearer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upon receiving a request and processing its contents, the server may respond
    with a message such as the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line of the response header contains the status code (`200`), which
    is a three-digit code. This helps the browser understand the status of operation.
    The following are the details of a few important fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status code**: There is no field named status code, but the value is passed
    in the header. The `2xx` series of status codes are used to communicate a successful
    operation back to the web browser. The `3xx` series is used to indicate redirection
    when a server wants the client to connect to another URL when a web page is moved.
    The `4xx` series is used to indicate an error in the client request and that the
    user will have to modify the request before resending. The `5xx` series indicates
    an error on the server side, as the server was unable to complete the operation.
    In the preceding header, the status code is `200`, which means that the operation
    was successful. A full list of HTTP status codes can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set-Cookie**: This field, if defined, will establish a cookie value in the
    client that can be used by the server to identify the client and store temporary
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache-Control**: This indicates whether or not the contents of the response
    (images, script code, or HTML) should be stored in the browser''s cache to reduce
    page loading times and how this should be done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server**: This field indicates the server type and version. As this information
    may be of interest for potential attackers, it is good practice to configure servers
    to omit its responses, as is the case in the header shown in the preceding screenshot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content-Length**: This field will contain a value indicating the number of
    bytes in the body of the response. It is used so that the other party can know
    when the current request/response has finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exhaustive list of all of the header fields and their usage can be found
    at the following URL: [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html).
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a client sends a request to the server, it should also inform the server
    what action is to be performed on the desired resource. For example, if a user
    only wants to view the contents of a web page, it will invoke the `GET` method,
    which informs the servers to send the contents of the web page to the client web
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Several methods are described in this section. They are of interest to a penetration
    tester, as they indicate what type of data exchange is happening between the two
    endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The GET method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GET` method is used to retrieve whatever information is identified by
    the URL or generated by a process identified by it. A `GET` request can take parameters
    from the client, which are then passed to the web application via the URL itself
    by appending a question mark `?` followed by the parameters'' names and values.
    As shown in the following header, when you send a search query for `web penetration
    testing` in the Bing search engine, it is sent via the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The POST method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `POST` method is similar to the `GET` method. It is used to retrieve data
    from the server, but it passes the content via the body of the request. Since
    the data is now passed in the body of the request, it becomes more difficult for
    an attacker to detect and attack the underlying operation. As shown in the following
    `POST` request, the username (`login`) and password (`pwd`) are not sent in the
    URL but rather in the body, which is separated from the header by a blank line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The HEAD method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HEAD` method is identical to `GET`, except that the server does not include
    a message body in the response; that is, the response of a `HEAD` request is just
    the header of the response to a `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: The TRACE method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a `TRACE` method is used, the receiving server bounces back the `TRACE`
    response with the original request message in the body of the response. The `TRACE`
    method is used to identify any alterations to the request by intermediary devices
    such as proxy servers and firewalls. Some proxy servers edit the HTTP header when
    the packets pass through it, and this can be identified using the `TRACE` method.
    It is used for testing purposes, as it lets you track what has been received by
    the other side.
  prefs: []
  type: TYPE_NORMAL
- en: The PUT and DELETE methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `PUT` and `DELETE` methods are part of WebDAV, which is an extension of
    the HTTP protocol and allows for the management of documents and files on a web
    server. It is used by developers to upload production-ready web pages onto the
    web server. `PUT` is used to upload data to the server whereas `DELETE` is used
    to remove it. In modern day applications, `PUT` and `DELETE` are also used in
    web services to perform specific operations on the database. `PUT` is used for
    insertion or modification of records and `DELETE` is used to delete, disable,
    or prevent future reading of pieces of information.
  prefs: []
  type: TYPE_NORMAL
- en: The OPTIONS method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `OPTIONS` method is used to query the server for the communication options
    available to the requested URL. In the following header, we can see the response
    to an `OPTIONS` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the layout of the HTTP packet is really important, as it contains
    useful information and several of the fields can be controlled from the user end,
    giving the attacker a chance to inject malicious data or manipulate certain behavior
    of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping sessions in HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is a stateless client-server protocol, where a client makes a request and
    the server responds with the data. The next request that comes is treated as an
    entirely new request, unrelated to the previous one. The design of HTTP requests
    is such that they are all independent of each other. When you add an item to your
    shopping cart while shopping online, the application needs a mechanism to tie
    the items to your account. Each application may use a different way to identify
    each session.
  prefs: []
  type: TYPE_NORMAL
- en: The most widely used technique to track sessions is through a session ID (identifier)
    set by the server. As soon as a user authenticates with a valid username and password,
    a unique random session ID is assigned to that user. On each request sent by the
    client, the unique session ID is included to tie the request to the authenticated
    user. The ID could be shared using the `GET` or `POST` method. When using the
    `GET` method, the session ID would become a part of the URL; when using the `POST`
    method, the ID is shared in the body of the HTTP message. The server maintains
    a table mapping usernames to the assigned session ID. The biggest advantage of
    assigning a session ID is that even though HTTP is stateless, the user is not
    required to authenticate every request; the browser would present the session
    ID and the server would accept it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Session ID also has a drawback: anyone who gains access to the session ID could
    impersonate the user without requiring a username and password. Furthermore, the
    strength of the session ID depends on the degree of randomness used to generate
    it, which could help defeat brute force attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In HTTP communication, a **cookie** is a single piece of information with name,
    value, and some behavior parameters stored by the server in the client's filesystem
    or web browser's memory. Cookies are the de facto standard mechanism through which
    the session ID is passed back and forth between the client and the web server.
    When using cookies, the server assigns the client a unique ID by setting the `Set-Cookie`
    field in the HTTP response header. When the client receives the header, it will
    store the value of the cookie; that is, the session ID within a local file or
    the browser's memory, and it will associate it with the website URL that sent
    it. When a user revisits the original website, the browser will send the cookie
    value across, identifying the user.
  prefs: []
  type: TYPE_NORMAL
- en: Besides session tracking, cookies can also be used to store preferences information
    for the end client, such as language and other configuration options that will
    persist among sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Cookie flow between server and client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cookies are always set and controlled by the server. The web browser is only
    responsible for sending them across to the server with every request. In the following
    diagram, you can see that a `GET` request is made to the server, and the web application
    on the server chooses to set some cookies to identify the user and the language
    selected by the user in previous requests. In subsequent requests made by the
    client, the cookie becomes part of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Persistent and nonpersistent cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies are divided into two main categories. Persistent cookies are stored
    on the client device's internal storage as text files. Since the cookie is stored
    on the hard drive, it would survive a browser crash or persist through various
    sessions. Different browsers will store persistent cookies differently. Internet
    Explorer, for example, saves cookies in text files inside the user's folder, `AppData\Roaming\Microsoft\Windows\Cookie`,
    while Google Chrome uses a SQLite3 database also stored in the user's folder,
    `AppData\Local\Google\Chrome\User Data\Default\cookies`. A cookie, as mentioned
    previously, can be used to pass sensitive information in the form of session ID,
    preferences, and shopping data among other types. If it's stored on the hard drive,
    it cannot be protected from modification by a malicious user.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the security issues faced by persistent cookies, programmers came up
    with another kind of cookie that is used more often today, known as a **nonpersistent
    cookie**, which is stored in the memory of the web browser, leaves no traces on
    the hard drive, and is passed between the web browser and server via the request
    and response header. A nonpersistent cookie is only valid for a predefined time
    specified by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Cookie parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the name and value of the cookie, there are several other parameters
    set by the web server that defines the reach and availability of the cookie, as
    shown in the following response header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are details of some of the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain**: This specifies the domain to which the cookie would be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: To lock down the cookie further, the `Path` parameter can be specified.
    If the domain specified is `email.com` and the path is set to `/mail`, the cookie
    would only be sent to the pages inside `email.com/mail`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HttpOnly**: This is a parameter that is set to mitigate the risk posed by
    **Cross-site Scripting** (**XSS**) attacks, as JavaScript won''t be able to access
    the cookie.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure**: If this is set, the cookie must only be sent over secure communication
    channels, namely SSL and TLS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expires**: The cookie will be stored until the time specified in this parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML data in HTTP response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data in the body of the response is the information that is of use to the
    end user. It usually contains HTML-formatted data, but it can also be **JavaScript
    Object Notation** (**JSON**) or **eXtensible Markup Language** (**XML**) data,
    script code, or binary files such as images and videos. Only plaintext information
    was originally stored on the web, formatted in a way that was more appropriate
    for reading while being capable of including tables, images, and links to other
    documents. This was called **Hypertext Markup Language** (**HTML**), and the web
    browser was the tool meant to interpret it. HTML text is formatted using tags.
  prefs: []
  type: TYPE_NORMAL
- en: HTML is not a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The server-side code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Script code and HTML formatting are interpreted and presented by the web browser.
    This is called **client-side code**. The processes involved in retrieving the
    information requested by the client, session tracking, and most of the application's
    logic are executed in the server through the **server-side code**, written in
    languages such as PHP, ASP.NET, Java, Python, Ruby, and JSP. This code produces
    an output that can then be formatted using HTML. When you see a URL ending with
    a `.php` extension, it indicates that the page may contain PHP code. It then must
    run through the server's PHP engine, which allows dynamic content to be generated
    when the web page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Multilayer web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As more complex web applications are being used today, the traditional means
    of deploying web applications on a single system is a story from the past. Placing
    all of your eggs in one basket is not a clever way to deploy a business-critical
    application, as it severely affects the performance, security, and availability
    of the application. The simple design of a single server hosting the application,
    as well as data, works well only for small web applications with not much traffic.
    The three-layer method of designing web application is the way forward.
  prefs: []
  type: TYPE_NORMAL
- en: Three-layer web application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a three-layer web application, there is physical separation between the
    presentation, application, and data layer, which is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation layer**: This is the server that receives the client connections
    and is the exit point through which the response is sent back to the client. It
    is the frontend of the application. The **presentation layer** is critical to
    the web application, as it is the interface between the user and the rest of the
    application. The data received at the presentation layer is passed to the components
    in the application layer for processing. The output received is formatted using
    HTML, and it is displayed on the web client of the user. Apache and nginx are
    open source software programs, and Microsoft IIS is commercial software that is
    deployed in the presentation layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer**: The processor-intensive processing and the main application''s
    logic is taken care of in the **application layer**. Once the presentation layer
    collects the required data from the client and passes it to the application layer,
    the components working at this layer can apply business logic to the data. The
    output is then returned to the presentation layer to be sent back to the client.
    If the client requests data, it is extracted from the data layer, processed into
    a useful form for the client, and passed to the presentation layer. Java, Python,
    PHP, and ASP.NET are programming languages that work at the application layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data access layer**: The actual storage and the data repository works at
    the **data access layer.** When a client requires data or sends data for storage,
    it is passed down by the application layer to the data access layer for persistent
    storage. The components working at this layer are responsible for maintaining
    the data and keeping its integrity and availability. They are also responsible
    for managing concurrent connections from the application layer. MySQL and Microsoft
    SQL are two of the most commonly used technologies that work at this layer. **Structured
    Query Language** (**SQL**) relational databases are the most commonly used nowadays
    in web applications, although NoSQL databases, such as MongoDB, CouchDB, and other
    NoSQL databases, which store information in a form different than the traditional
    row-column table format of relational databases, are also widely used, especially
    in Big Data Analysis applications. SQL is a data definition and query language
    that many database products support as a standard for retrieving and updating
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how the presentation, application, and data access
    layers work together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web services can be viewed as web applications that don't include a presentation
    layer. Service-oriented architecture allows a web service provider to integrate
    easily with the consumer of that service. Web services enable different applications
    to share data and functionality among themselves. They allow consumers to access
    data over the internet without the application knowing the format or the location
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes extremely critical when you don't want to expose the data model
    or the logic used to access the data, but you still want the data readily available
    for its consumers. An example would be a web service exposed by a stock exchange.
    Online brokers can use this web service to get real-time information about stocks
    and display it on their own websites, with their own presentation style and branding
    for purchase by end users. The broker's website only needs to call the service
    and request the data for a company. When the service replies back with the data,
    the web application can parse the information and display it.
  prefs: []
  type: TYPE_NORMAL
- en: Web services are platform independent. The stock exchange application can be
    written in any language, and the service can still be called regardless of the
    underlying technology used to build the application. The only thing the service
    provider and the consumer need to agree on are the rules for the exchange of the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently two different ways to develop web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Object Access Protocol** (**SOAP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**), also known as RESTful web services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing SOAP and REST web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOAP has been the traditional method for developing a web service, but it has
    many drawbacks, and applications are now moving over to REST or RESTful web service.
    XML is the only data exchange format available when using a SOAP web service,
    whereas REST web services can work with JSON and other data formats. Although
    SOAP-based web services are still recommended in some cases due to the extra security
    specifications, the lightweight REST web service is the preferred method of many
    web service developers due to its simplicity. SOAP is a protocol, whereas REST
    is an architectural style. Amazon, Facebook, Google, and Yahoo! have already moved
    over to REST web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the features of REST web services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They work really well with CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have better performance and scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can handle multiple input and output formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smaller learning curve for developers connecting to web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The REST design philosophy is similar to web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD stands for create, read, update, and delete; it describes the four basic
    functions of persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: The major advantage that SOAP has over REST is that SOAP is transport independent,
    whereas REST works only over HTTP. REST is based on HTTP, and therefore the same
    vulnerabilities that affect a standard web application could be used against it.
    Fortunately, the same security best practices can be applied to secure the REST
    web service.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity inherent in developing SOAP services where the XML data is wrapped
    in a SOAP request and then sent using HTTP forced many organizations to move to
    REST services. It also needed a **Web Service Definition Language** (**WSDL**)
    file, which provided information related to the service. A UDDI directory had
    to be maintained where the WSDL file is published.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea of a REST service is, rather than using a complicated mechanism
    such as SOAP, it directly communicates with the service provider over HTTP without
    the need for any additional protocol. It uses HTTP to create, read, update, and
    delete data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A request sent by the consumer of a SOAP-based web service is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, a request sent to a REST web service could be as simple
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The application uses a `GET` request to read data from the web service, which
    has low overhead and, unlike a long and complicated SOAP request, is easy for
    developers to code. While REST web services can also return data using XML, it
    is the rarely used-JSON that is the preferred method for returning data.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods in web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST web services may treat HTTP methods differently than in a standard web
    application. This behavior depends on the developer''s preferences, but it''s
    becoming increasingly popular to correlate `POST`, `GET`, `PUT`, and `DELETE`
    methods to CRUD operations. The most common approach is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create: `POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update: `PUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delete: `DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some **Application Programming Interface** (**API**) implementations swap the `PUT`
    and `POST` functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: XML and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both XML and JSON are used by web services to represent structured sets of data
    or objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in previous sections, XML uses a syntax based on tags and properties,
    and values for those tags; for example, the File menu of an application, can be
    represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON, on the contrary, uses a more economic syntax resembling that of C and
    Java programming languages. The same menu in JSON format will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous JavaScript and XML** (**AJAX**) is the combination of multiple
    existing web technologies, which let the client send requests and process responses
    in the background without a user''s direct intervention. It also lets you relieve
    the server of some part of the application''s logic processing tasks. AJAX allows
    you to communicate with the web server without the user explicitly making a new
    request in the web browser. This results in a faster response from the server,
    as parts of the web page can be updated separately and this improves the user
    experience. AJAX makes use of JavaScript to connect and retrieve information from
    the server without reloading the entire web page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the benefits of using AJAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased speed**: The goal of using AJAX is to improve the performance of
    the web application. By updating individual form elements, minimum processing
    is required on the server, thereby improving performance. The responsiveness on
    the client side is also drastically improved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User friendly**: In an AJAX-based application, the user is not required to
    reload the entire page to refresh specific parts of the website. This makes the
    application more interactive and user friendly. It can also be used to perform
    real-time validation and autocompletion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous calls**: AJAX-based applications are designed to make asynchronous
    calls to the web server, hence the name Asynchronous JavaScript and XML. This
    lets the user interact with the web page while a section of it is updated behind
    the scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced network utilization**: By not performing a full-page refresh every
    time, network utilization is reduced. In a web application where large images,
    videos or dynamic content such as Java applets or Adobe Flash programs are loaded,
    use of AJAX can optimize network utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building blocks of AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, AJAX is a mixture of the common web technologies that
    are used to build a web application. The way the application is designed using
    these web technologies results in an AJAX-based application. The following are
    the components of AJAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**: The most important component of an AJAX-based application is
    the client-side JavaScript code. The JavaScript interacts with the web server
    in the background and processes the information before being displayed to the
    user. It uses the **XMLHttpRequest** (**XHR**) API to transfer data between the
    server and the client. XHR exists in the background, and the user is unaware of
    its existence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic HTML (DHTML)**: Once the data is retrieved from the server and processed
    by the JavaScript, the elements of the web page need to be updated to reflect
    the response from the server. A perfect example would be when you enter a username
    while filling out an online form. The form is dynamically updated to reflect and
    inform the user if the username is already registered on the website. Using DHTML
    and JavaScript, you can update the page contents on the fly. DHTML was in existence
    long before AJAX. The major drawback of only using DHTML is that it is heavily
    dependent on the client-side code to update the page. Most of the time, you do
    not have everything loaded on the client side and you need to interact with the
    server-side code. This is where AJAX comes into play by creating a connection
    between the client-side code and the server-side code via the XHR objects. Before
    AJAX, you had to use JavaScript applets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document Object Model (DOM)**: A DOM is a framework used to organize elements
    in an HTML or XML document. It is a convention for representing and interacting
    with HTML objects. Logically, imagine that an HTML document is parsed as a tree,
    where each element is seen as a tree node and each node of the tree has its own
    attributes and events. For example, the body object of the HTML document will
    have a specific set of attributes such as `text`, `link`, `bgcolor`, and so on.
    Each object also has events. This model allows an interface for JavaScript to
    access and update the contents of the page dynamically using DHTML. DHTML is a
    browser function, and DOM acts as an interface to achieve it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AJAX workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following image illustrates the interaction between the various components
    of an AJAX-based application. When compared against a traditional web application,
    the AJAX engine is the major addition. The additional layer of the AJAX engine
    acts as an intermediary for all of the requests and responses made through AJAX.
    The AJAX engine is the JavaScript interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the workflow of a user interacting with an AJAX-based application.
    The user interface and the AJAX engine are the components on the client''s web
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: The user types in the URL of the web page, and the browser sends a HTTP request
    to the server. The server processes the request and responds back with the HTML
    content, which is displayed by the browser through the web-rendering engine. In
    HTML, a web page is embedded in JavaScript code which is executed by the JavaScript
    interpreter when an event is encountered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When interacting with the web page, the user encounters an element that uses
    the embedded JavaScript code and triggers an event. An example would be the Google
    search page. As soon as the user starts entering a search query, the underlying
    AJAX engine intercepts the user's request. The AJAX engine forwards the request
    to the server via an HTTP request. This request is transparent to the user, and
    the user is not required to click explicitly on the submit button or refresh the
    entire page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the server side, the application layer processes the request and returns
    the data back to the AJAX engine in JSON, HTML, or XML form. The AJAX engine forwards
    this data to the web-rendering engine to be displayed by the browser. The web
    browser uses DHTML to update only the selected section of the web page in order
    to reflect the new data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember the following additional points when you encounter an AJAX-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: The XMLHttpRequest API does the magic behind the scenes. It is commonly referred
    to as XHR due to its long name. A JavaScript object named `xmlhttp` is first instantiated,
    and it is used to send and capture the response from the server. Browser support
    for XHR is required for AJAX to work. All of the recent versions of leading web
    browsers support this API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The XML part of AJAX is a bit misleading. The application can use any format
    besides XML, such as JSON, plaintext, HTTP, or even images when exchanging data
    between the AJAX engine and the web server. JSON is the preferred format, as it
    is lightweight and can be turned into a JavaScript object, which further allows
    the script to access and manipulate the data easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple asynchronous requests can happen concurrently without waiting for one
    request to finish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many developers use AJAX frameworks, which simplifies the task of designing
    the application. JQuery, Dojo Toolkit, **Google Web Toolkit** (**GWT**), and Microsoft
    AJAX library (.NET applications) are well-known frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example for an AJAX request is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The function `loadfile()` first instantiates the `xmlhttp` object. It then uses
    this object to pull a text file from the server. When the text file is returned
    by the server, it displays the contents of the file. The file and its contents
    are loaded without user involvement, as shown in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fifth version of the HTML specification was first published in October 2014\.
    This new version specifies APIs for media playback, drag and drop, web storage,
    editable content, geolocation, local SQL databases, cryptography, web sockets,
    and many others, which may become interesting from the security testing perspective
    as they open new paths for attacks or attempt to tackle some of the security concerns
    in previous HTML versions.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is a **stateless** protocol as noted previously. This means that a new
    connection is established for every request and closed after every response. An
    HTML5 **WebSocket** is a communication interface that allows for a permanent bidirectional
    connection between client and server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A WebSocket is opened by the client through a `GET` request such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the server understands the request and accepts the connection, its response
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP connection is then replaced by the WebSocket connection, and it becomes
    a bidirectional binary protocol not necessarily compatible with HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter served as an introduction to ethical hacking and penetration testing
    of web applications. We started by identifying different ways of testing web applications.
    We also discussed the important rules of engagements to be defined before starting
    a test. Next, we examined the importance of testing web applications in today's
    world, and the risks of not doing regular testing. We then briefly presented Kali
    Linux as a testing platform and finished with a quick review of the concepts and
    technologies in use by modern web applications.
  prefs: []
  type: TYPE_NORMAL
