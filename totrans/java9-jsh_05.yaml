- en: Chapter 5. Mutable and Immutable Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about mutable and immutable classes. We will
    understand their differences and their advantages and disadvantages when building
    object-oriented code. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create mutable classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with mutable objects in JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build immutable classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with immutable objects in JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the difference between mutating and non-mutating objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the advantages of non-mutating objects when writing concurrent code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with instances of the immutable `String` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating mutable classes in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we declare instance fields without the `final` keyword, we create a mutable
    instance field, which means that we can change their values for each new instance
    we create after the field is initialized. When we create an instance of a class
    that defines at least one mutable field, we create a mutable object, which is
    an object that can change its state after its initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A mutable object is also known as a mutating object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that we have to develop a Web Service that renders elements
    in the 3D world and returns a high-resolution rendered scene. Such a task requires
    us to work with 3D vectors. First, we will work with a mutable 3D vector with
    three mutable fields: `x`, `y`, and `z`. The mutable 3D vector must provide the
    following features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three mutable instance fields of type `double`: `x`, `y`, and `z`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that creates an instance by providing the initial values for the
    `x`, `y`, and `z` fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that creates an instance with all the values initialized to `0`,
    that is, `x = 0`, `y = 0`, and `z = 0`. A 3D vector with these values is known
    as an **origin vector**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that creates an instance with all the values initialized to a
    common value. For example, if we specify `3.0` as the common value, the constructor
    must generate an instance with `x = 3.0`, `y = 3.0`, and `z = 3.0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `absolute` method that sets each component of the 3D vector to its absolute
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `negate` method that negates each component of the 3D vector in place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `add` method that sets the value of the 3D vector to the sum of itself and
    the 3D vector received as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `sub` method that sets the value of the 3D vector to the difference of itself
    and the 3D vector received as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An implementation of the `toString` method that prints the values of the three
    components of the 3D vector: `x`, `y`, and `z`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines declare the `Vector3d` class that represents the mutable
    version of a 3D vector in Java. The code file for the sample is included in the
    `java_9_oop_chapter_05_01` folder, in the `example05_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The new `Vector3d` class declares three constructors whose lines are highlighted
    in the previous code listing. The first constructor receives three `double` arguments,
    `x`, `y`, and `z`, and initializes the fields with the same names and types with
    the values received in these arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The second constructor receives a single `double` argument, `valueForXYZ`, and
    uses the `this` keyword to call the previously explained constructor with the
    received argument as the value for the three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the `this` keyword within a constructor to call other constructors
    with different arguments defined in our class.
  prefs: []
  type: TYPE_NORMAL
- en: The third constructor is a parameterless one and uses the `this` keyword to
    call the previously explained constructor with `0.0` as the value for the `valueForXYZ`
    argument. This way, the constructor allows us to build an origin vector.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we call the `absolute`, `negate`, `add`, or `sub` methods, we will
    mutate the instance, that is, we will change the state for the object. These methods
    change the values for the `x`, `y`, and `z` fields for the instance from which
    we call them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with mutable objects in JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following lines create a new `Vector3d` instance named `vector1` with `10.0`,
    `20.0`, and `30.0` for the initial values of `x`, `y`, and `z`. The second lines
    create a new `Vector3d` instance named `vector2` with `1.0`, `2.0`, and `3.0`
    for the initial values of `x`, `y`, and `z`. Then, the code calls the `System.out.println`
    method with `vector1` and then with `vector2` as an argument. Both calls to the
    `println` method will execute the `toString` method for each `Vector3d` instance
    to display the `String` representation of the mutable 3D vector. Then, the code
    calls the `add` method for `vector1` with `vector2` as an argument. The last line
    calls the `println` method again with `vector1` as an argument to print the new
    values of `x`, `y` and `z` after the object mutated with the call to the `add`
    method. The code file for the sample is included in the `java_9_oop_chapter_05_01`
    folder, in the `example05_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with mutable objects in JShell](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The initial values for the `vector1` fields are `10.0` for `x`, `20.0` for
    `y`, and `30.0` for `z`. The `add` method changes the values of the three fields.
    Hence, the object state mutates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector1.x` mutates from `10.0` to *10.0 + 1.0 = 11.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector1.y` mutates from `20.0` to *20.0 + 2.0 = 22.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector1.z` mutates from `30.0` to *30.0 + 3.0 = 33.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values for the `vector1` fields after the call to the `add` method are `11.0`
    for `x`, `22.0` for `y`, and `33.0` for `z`. We can say that the method mutated
    the object's state. Thus, `vector1` is a mutable object and an instance of a mutable
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines use the three available constructors to create three instances
    of the `Vector3d` class named `vector3`, `vector4`, and `vector5`. Then, the next
    lines call the `System.out.println` method to print the values of `x`, `y`, and
    `z` after the objects were created. The code file for the sample is included in
    the `java_9_oop_chapter_05_01` folder, in the `example05_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with mutable objects in JShell](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next lines call many methods for the previously created instances. The code
    file for the sample is included in the `java_9_oop_chapter_05_01` folder, in the
    `example05_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The initial value for the three `vector4` fields (`x`, `y`, and `z`) is `5.0`.
    The call to the `vector4.negate` method changes the values of the three fields
    to `-5.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial value for the three `vector3` fields (`x`, `y`, and `z`) is `0.0`.
    The call to the `vector3.add` method changes the values of the three fields by
    the results of the sum of each component of `vector3` and `vector4`. Hence, the
    object state mutates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector3.x` mutates from `0.0` to *0.0 + (-5.0) = -5.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector3.y` mutates from `0.0` to *0.0 + (-5.0) = -5.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector3.z` mutates from `0.0` to *0.0 + (-5.0) = -5.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three fields for `vector3` fields are set to `-5.0` after the call to the
    `add` method. The call to the `vector4.absolute` method changes the values of
    the three fields from `-5.0` to `5.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial values for the `vector5` fields are `-15.5` for `x`, `-11.1` for
    `y`, and `-8.8` for `z`. The call to the `vector5.sub` method changes the values
    of the three fields by the results of the subtraction of each component of `vector5`
    and `vector4`. Hence, the object state mutates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector5.x` mutates from `-15.5` to *-15.5 - 5.0 = -20.5*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector5.y` mutates from `-11.1` to *-11.1 - 5.0 = -16.1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector5.z` mutates from `-8.8` to *-8.8 - 5.0 = -13.8*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with mutable objects in JShell](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building immutable classes in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working with mutable classes and mutating objects. Whenever
    we expose mutable fields, we create a class that will generate mutable instances.
    In certain scenarios, we might prefer an object that cannot change its state after
    it has been initialized. We can design classes to be immutable and to generate
    immutable instances that cannot change their state after they were created and
    initialized.
  prefs: []
  type: TYPE_NORMAL
- en: A typical scenario where immutable objects are extremely useful is when we work
    with concurrent code. Objects that cannot change their state solve many typical
    concurrency problems and avoid potential bugs that might be difficult to detect
    and solve. Because immutable objects cannot change their state, it is not possible
    to end up with an object with a corrupted or inconsistent state when many different
    threads modify it without the appropriate synchronization mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An immutable object is also known as a non-mutating object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an immutable version of the previously coded `Vector3d` class
    to represent an immutable 3D vector. This way, we will notice the difference between
    a mutable class and its immutable version. The immutable 3D vector must provide
    the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three immutable instance fields of type `double`: `x`, `y`, and `z`. The value
    for these fields cannot be changed after the instance is initialized or constructed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that creates an instance by providing the initial values for the
    `x`, `y`, and `z` immutable fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that creates an instance with all the values set to `0`, that
    is, `x = 0`, `y = 0`, and `z = 0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that creates an instance with all the values initialized to a
    common value. For example, if we specify `3.0` as the common value, the constructor
    must generate an immutable instance with `x = 3.0`, `y = 3.0`, and `z = 3.0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `absolute` method that returns a new instance with each component of the
    new immutable 3D vector set to the absolute value of each component of the instance
    in which we call the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `negate` method that returns a new instance with each component of the new
    immutable 3D vector set to the negated value of each component of the instance
    in which we call the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `add` method that returns a new instance with each component of the new immutable
    3D vector set to the sum of each component of the instance in which we call the
    method and each component of the immutable 3D vector received as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `sub` method that returns a new instance with each component of the new immutable
    3D vector set to the subtraction of each component of the instance in which we
    call the method and each component of the immutable 3D vector received as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An implementation of the `toString` method that prints the values of the three
    components of the 3D vector: `x`, `y`, and `z`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines declare the `ImmutableVector3d` class that represents the
    immutable version of a 3D vector in Java. The code file for the sample is included
    in the `java_9_oop_chapter_05_01` folder, in the `example05_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `ImmutableVector3d` class declares three immutable instance fields
    by using the `final` keyword: `x`, `y`, and `z`. The lines for the three constructors
    declared for this class are highlighted in the previous code listing. These constructors
    have the same code that we analyzed for the `Vector3d` class. The only difference
    is in the execution, because the constructors are initializing immutable instance
    fields that won''t change their values after the initialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we call the `absolute`, `negate`, `add`, or `sub` methods, their code
    will return a new instance of the `ImmutableVector3d` class with the result of
    each operation. We will never mutate our instance; that is, we won't change the
    state for the object.
  prefs: []
  type: TYPE_NORMAL
- en: Working with immutable objects in JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following lines create a new `ImmutableVector3d` instance named `vector10`
    with `100.0`, `200.0`, and `300.0` for the initial values of `x`, `y`, and `z`.
    The second lines create a new `ImmutableVector3d` instance named `vector20` with
    `11.0`, `12.0`, and `13.0` for the initial values of `x`, `y`, and `z`. Then,
    the code calls the `System.out.println` method with `vector10` and then with `vector20`
    as an argument. Both calls to the `println` method will execute the `toString`
    method for each `ImmutableVector3d` instance to display the `String` representation
    of the immutable 3D vector. Then, the code calls the `add` method for `vector10`
    with `vector20` as an argument and saves the returned `ImmutableVector3d` instance
    in `vector30`.
  prefs: []
  type: TYPE_NORMAL
- en: The last line calls the `println` method with `vector30` as an argument to print
    the values of `x`, `y`, and `z` for this instance that has the results of the
    addition operation between `vector10` and `vector20`. Enter the lines after the
    code that declares the `ImmutableVector3d` class. The code file for the sample
    is included in the `java_9_oop_chapter_05_01` folder, in the `example05_03.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with immutable objects in JShell](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As a result of the `add` method, we have another immutable instance named `vector30`
    whose field values are `111.0` for `x`, `212.0` for `y`, and `313.0` for `z`.
    As a result of calling each method that computes an operation, we will have another
    immutable instance.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines use the three available constructors to create three instances
    of the `ImmutableVector3d` class named `vector40`, `vector50`, and `vector60`.
    Then, the next lines call the `System.out.println` method to print the values
    of `x`, `y`, and `z` after the objects were created. The code file for the sample
    is included in the `java_9_oop_chapter_05_01` folder, in the `example05_03.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with immutable objects in JShell](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next lines call many methods for the previously created instances and generate
    new instances of the `ImmutableVector3d` class. The code file for the sample is
    included in the `java_9_oop_chapter_05_01` folder, in the `example05_03.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The initial value for the three `vector50` fields (`x`, `y`, and `z`) is `-5.0`.
    The call to the `vector50.negate` method returns a new `ImmutableVector3d` instance
    that the code saves in `vector70`. The new instance has `5.0` as the value for
    the three fields (`x`, `y`, and `z`).
  prefs: []
  type: TYPE_NORMAL
- en: The initial value for the three `vector40` fields (`x`, `y`, and `z`) is `0`.
    The call to the `vector40.add` method, with `vector70` as an argument, returns
    a new `ImmutableVector3d` instance that the code saves in `vector80`. The new
    instance has `5.0` as the value for the three fields (`x`, `y`, and `z`).
  prefs: []
  type: TYPE_NORMAL
- en: The call to the `vector70.absolute` method returns a new `ImmutableVector3d`
    instance that the code saves in `vector90`. The new instance has `5.0` as the
    value for the three fields (`x`, `y`, and `z`). The absolute values for the fields
    were the same as the original values, but the code still generated a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: The initial values for the `vector60` fields are `8.0` for `x`, `9.0` for `y`,
    and `10.0` for `z`. The call to the `vector60.sub` method with `vector90` as an
    argument returns a new `ImmutableVector3d` instance that the code saves in `vector100`.
    The values for the `vector100` fields are `3.0` for `x`, `4.0` for `y`, and `5.0`
    for `z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with immutable objects in JShell](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the differences between mutating and non-mutating objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The immutable version adds an overhead compared with the mutable version because
    it is necessary to create a new instance of the class as a result of calling the
    `absolute`, `negate`, `add`, or `sub` methods. The previously analyzed mutable
    class named `Vector3D` just changed the values for the fields, and it wasn't necessary
    to generate a new instance. Hence, the memory footprint for the immutable version
    is higher than the mutable version.
  prefs: []
  type: TYPE_NORMAL
- en: The immutable class named `ImmutableVector3d` has both a memory and performance
    overhead compared with the mutable version. It is more expensive to create a new
    instance than to change the values of a few fields. However, as previously explained,
    when we work with concurrent code, it makes sense to pay for the extra overhead
    to avoid potential issues caused by mutable objects. We just have to make sure
    we analyze the advantages and tradeoffs in order to decide which is the most convenient
    way to code our specific classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will write a few lines that work with the mutable version and we will
    generate the equivalent code for the immutable version. This way, we will be able
    to make a simple yet illustrative comparison of the differences between the two
    pieces of code.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create a new `Vector3d` instance named `mutableVector3d1`
    with `-30.5`, `-15.5`, and `-12.5` for the initial values of `x`, `y`, and `z`.
    Then, the code prints the `String` representation for the new instance, calls
    the `absolute` method, and prints the `String` representation of the mutated object.
    The code file for the sample is included in the `java_9_oop_chapter_05_01` folder,
    in the `example05_04.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the differences between mutating and non-mutating objects](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines create a new `ImmutableVector3d` instance named `immutableVector3d1`
    with `-30.5`, `-15.5`, and `-12.5` for the initial values of `x`, `y`, and `z`.
    Then, the code prints the `String` representation for the new instance, calls
    the `absolute` method that generates a new `ImmutableVector3d` instance named
    `immutableVector3d2`, and prints the `String` representation of the new object.
    The code file for the sample is included in the `java_9_oop_chapter_05_01` folder,
    in the `example05_04.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the differences between mutating and non-mutating objects](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The mutable version works with a single `Vector3d` instance. The constructor
    for the `Vector3d` class is executed only once. The original instance mutates
    its state when we called the `absolute` method.
  prefs: []
  type: TYPE_NORMAL
- en: The immutable version works with two `ImmutableVector3d` instances, and therefore,
    the memory footprint is higher than the mutable version. The constructor for the
    `ImmutableVector3d` class is executed twice. The first instance didn't mutate
    its state when we called the `absolute` method.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the advantages of non-mutating objects when writing concurrent code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's imagine we are writing concurrent code that has to access the fields
    of the previously created instances. First, we will analyze the problems with
    the mutable version and then we will understand the advantage of working with
    the non-mutating object.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have two threads in which the code has a reference to the instance
    saved in `mutableVector3d1`. The first thread calls the `absolute` method for
    this mutating object. The first line of code for the `absolute` method assigns
    the result of `Math.abs` with the actual value of `x` as an argument to the `x`
    mutable field.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the method didn't finish its execution and the next line of code
    won't be able to access the values. However, concurrent code running in another
    thread that has a reference to this instance might access the values for the `x`,
    `y` and `z` fields before the `absolute` method finishes the execution. The object
    is in a corrupt state because the values for the fields are `30.5` for `x`, `-15.5`
    for `y`, and `-12.5` for `z`. These values do not represent the 3D vector that
    we will have when the `absolute` method finishes its execution. The fact that
    there are many pieces of code running concurrently and have access to the same
    instance without any kind of synchronization mechanism generates the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent programming and threaded programming are complex topics that deserve
    an entire book. There are synchronization mechanisms to avoid the previously mentioned
    issue and make the class thread-safe. However, another solution is the usage of
    immutable classes that generate non-mutating objects.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the immutable version, the two threads can have the reference to the
    same initial instance. However, when one of the threads calls the `absolute` method,
    the original 3D vector won't mutate, and therefore the previous problem will never
    happen. The other thread will continue working with its reference to the original
    3D vector, with its original state. The thread that called the `absolute` method
    will generate a new instance that is completely independent of the original one.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it is very important to understand that this topic deserves an entire
    book. However, it is important to understand why immutable classes might be a
    special requirement in specific scenarios where the instance will participate
    in concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with instances of the immutable String class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `String` class, specifically the `java.lang.String` class, represents character
    strings and is an immutable class that generates non-mutating objects. Hence,
    the methods provided by the `String` class do not mutate the object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following lines create a new `String`, that is, a new instance
    of the `java.lang.String` class named `welcomeMessage` with an initial value of
    `"Welcome to Virtual Creatures Land"`. Then, the code makes many calls to `System.out.println`
    with `welcomeMessage` followed by a different method as an argument. First, we
    call the `toUpperCase` method to generate a new `String` with all the characters
    converted to uppercase. Then, we call the `toLowerCase` method to generate a new
    `String` with all the characters converted to lowercase. Then, we call the `replaceAll`
    method to generate a new `String` in which the spaces were replaced by a hyphen
    (`-`). Finally, we call the `System.out.println` method again with `welcomeMessage`
    as an argument to check the value of the original `String`. The code file for
    the sample is included in the `java_9_oop_chapter_05_01` folder, in the `example05_05.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with instances of the immutable String class](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `welcomeMessage` string never changed its value. The calls to the `toUpperCase`,
    `toLowerCase`, and `replaceAll` methods generated and returned a new `String`
    instance for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No matter which method we call for a `String` instance, it won't mutate the
    object. Thus, we can say `String` is an immutable class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the immutable version of an existing mutable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a mutable class named `VirtualCreature`.
    We provided setter methods to change the values for the `hat`, `visibilityLevel`,
    and `birthYear` fields. We were able to change the `birthYear` by calling the
    `setAge` method.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual creatures change their age, hat, and visibility level after they evolve.
    When they evolve, they become a different creature, and therefore, it would make
    sense to generate a new instance after this evolution happens. Thus, we will create
    the immutable version of the `VirtualCreature` class and we will call it `ImmutableVirtualCreature`.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the new `ImmutableVirtualCreature` class.
    The code file for the sample is included in the `java_9_oop_chapter_05_01` folder,
    in the `example05_06.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ImmutableVirtualCreature` class declares four public immutable instance
    fields with the `final` keyword: `name`, `birthYear`, `hat`, and `visibilityLevel`.
    We won''t be able to change the values for any of these fields after the instance
    has been initialized or constructed.'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor generates an uppercased `String` from the `String` received
    in the `hat` argument and stores it in the public `hat` immutable field. We had
    a specific validation for the visibility level, and therefore, the constructor
    calls a new private method named `getValidVisibilityLevel,` with the value received
    in the `visibilityLevel` argument, to assign a valid value to the immutable field
    with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t have setter methods anymore because we aren''t able to change the
    values for the immutable fields after they were initialized. The class declares
    the following two new public methods that return a new `ImmutableVirtualCreature`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`evolveToAge`: This method receives the desired age for the evolved virtual
    creature in the `age` argument. The code calculates the birth year based on the
    received age and the current year, and returns a new `ImmutableVirtualCreature`
    instance with the new initialization values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`evolveToVisibilityLevel`: This method receives the desired visibility level
    for the evolved virtual creature in the `visibilityLevel` argument. The code calls
    the `getValidVisibilityLevel` method to generate a valid visibility level based
    on the received value, and returns a new `ImmutableVirtualCreature` instance with
    the new initialization values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following lines create an instance of the `ImmutableVirtualCreature` class
    named `meowth1`. Then the code calls the `meowth1.evolveToAge` method with `3`
    as the value for the `age` argument and saves the new `ImmutableVirtualCreature`
    instance returned by this method in the `meowth2` variable. The code prints the
    value returned by the `meowth2.getAge` method. Finally, the code calls the `meowth2.evolveToVisibilityLevel`
    method with `25` as the value for the `invisibilityLevel` argument and saves the
    new `ImmutableVirtualCreature` instance returned by this method in the `meowth3`
    variable. Then, the code prints the value stored in the `meowth3.visibilityLevel`
    immutable field. The code file for the sample is included in the `java_9_oop_chapter_05_01`
    folder, in the `example05_06.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the immutable version of an existing mutable class](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class that exposes mutable fields will:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate immutable instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate mutable instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate mutable classes but immutable instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following keywords, used within a constructor, allows us to call
    other constructors with different arguments defined in our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`constructor`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`this`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An object that cannot change its state after it has been initialized is known
    as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A mutable object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An immutable object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Java 9, `java.lang.String` generates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An immutable object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A mutable object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we call the `toUpperCase` method for a `java.lang.String`, the method will:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the existing `String` to uppercase characters and change its state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a new `String` with the contents of the original `String` converted to
    uppercase characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a new `String` with the contents of the original `String`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the differences between mutable and immutable classes
    and the mutating and non-mutating instances that they generate. We declared mutable
    and immutable versions of a 3D vector class in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we took advantage of JShell to easily work with the mutating and non-mutating
    instances of these classes and we analyzed the difference between changing the
    state of an object and returning a new object whenever we have to change its state.
    We analyzed the advantages and disadvantages of mutable and immutable classes
    and we understood why the latter are useful when working with concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about mutable and immutable classes, you are ready
    to work with inheritance, abstraction, extension, and specialization, which are
    the topics we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
