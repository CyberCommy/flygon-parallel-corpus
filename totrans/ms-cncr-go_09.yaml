- en: Chapter 9. Logging and Testing Concurrency in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, you should be fairly comfortable with concurrency in Go and should
    be able to implement basic goroutines and concurrent mechanisms with ease.
  prefs: []
  type: TYPE_NORMAL
- en: We have also dabbled in some distributed concurrency patterns that are managed
    not only through the application itself, but also through third-party data stores
    for networked applications that operate concurrently in congress.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this book, we examined some preliminary and basic testing and logging.
    We looked at the simpler implementations of Go's internal test tool, performed
    some race condition testing using the race tool, and performed some rudimentary
    load and performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: However, there's much more to be looked at here, particularly as it relates
    to the potential black hole of concurrent code—we've seen unexpected behavior
    among code that runs in goroutines and is non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll further investigate load and performance testing, look
    at unit testing in Go, and experiment with more advanced tests and debugging.
    We'll also look at best practices for logging and reporting, as well as take a
    closer look at panicking and recovering.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we'll want to see how all of these things can be applied not just to
    our standalone concurrent code, but also to distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we'll introduce a couple of frameworks for unit testing in a
    variety of different styles.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors and logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though we haven't specifically mentioned it, the idiomatic nature of error handling
    in Go makes debugging naturally easier by mandate.
  prefs: []
  type: TYPE_NORMAL
- en: One good practice for any large-scale function inside Go code is to return an
    error as a return value—for many smaller methods and functions, this is potentially
    burdensome and unnecessary. Still, it's a matter for consideration whenever we're
    building something that involves a lot of moving pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a simple `Add()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish to follow the general rule of "always return an error value", we
    may be tempted to convert this function to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we're (very poorly) reinventing the wheel. Go's internal compiler
    kills this long before we ever see it. So, we should focus on things that the
    compiler may not catch and that can cause unexpected behavior in our applications,
    particularly when it comes to channels and listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'The takeaway is to let Go handle the errors that the compiler would handle,
    unless you wish to handle the exceptions yourself, without causing the compiler
    specific grief. In the absence of true polymorphism, this is often cumbersome
    and requires the invocation of interfaces, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recall that creating interfaces and structs allows us to route our
    function calls separately based on type. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This still reports what will eventually be caught by the compiler, but also
    handles some form of error on what the compiler cannot see: external input. We''re
    routing our `Add()` function through an interface, which provides some additional
    standardization by directing the struct''s parameters and methods more explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: If, for example, we take user input for our values and need to evaluate the
    type of that input, we may wish to report an error in this way as the compiler
    will never know that our code can accept the wrong type.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking out goroutine logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of handling messaging and logging that keeps a focus on concurrency
    and isolation is to shackle our goroutine with its own logger that will keep everything
    separate from the other goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should note that this may not scale—that is, it may at some
    point become expensive to create thousands or tens of thousands of goroutines
    that have their own loggers, but at a minimal size, this is totally doable and
    manageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this logging individually, we''ll want to tie a `Logger` instance to
    each goroutine, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create a generic `Worker` struct that will ironically do no work (at
    least not in this example) other than hold onto its own `Logger` object. The code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Each goroutine is saddled with its own log routine through `Worker`. While
    we''re spitting our output straight to the console, this is largely unnecessary.
    However, if we want to siphon each to its own logfile, we could do so by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the LiteIDE for richer and easier debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the earlier chapters of this book, we briefly addressed IDEs and gave a few
    examples of IDEs that have a tight integration with Go.
  prefs: []
  type: TYPE_NORMAL
- en: As we're examining logging and debugging, there's one IDE we previously and
    specifically didn't mention before, primarily because it's intended for a very
    small selection of languages—namely, Go and Lua. However, if you end up working
    primarily or exclusively in Go, you'll find it absolutely essential, primarily
    as it relates to debugging, logging, and feedback capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**LiteIDE** is cross-platform and works well on OS X, Linux, and Windows. The
    number of debugging and testing benefits it presents in a GUI form are invaluable,
    particularly if you''re already very comfortable with Go. That last part is important
    because developers often benefit most from "learning the hard way" before diving
    in with tools that simplify the programming process. It''s almost always better
    to know how and why something works or doesn''t work at the core before being
    presented with pretty icons, menus, and pop-up windows. Having said that, LiteIDE
    is a fantastic, free tool for the advanced Go programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: By formalizing a lot of the tools and error reporting from Go, we can easily
    plow through some of the more vexing debugging tasks by seeing them onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: 'LiteIDE also brings context awareness, code completion, `go fmt`, and more
    into our workspace. You can imagine how an IDE tuned specifically for Go can help
    you keep your code clean and bug free. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the LiteIDE for richer and easier debugging](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: LiteIDE showing output and automatic code completion on Windows
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LiteIDE for Linux, OS X, and Windows can be found at [https://code.google.com/p/liteide/](https://code.google.com/p/liteide/).
  prefs: []
  type: TYPE_NORMAL
- en: Sending errors to screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we have usually handled soft errors, warnings, and general
    messages with the `fmt.Println` syntax by sending a message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: While this is quick and easy for demonstration purposes, it's probably ideal
    to use the `log` package to handle these sorts of things. This is because we have
    more versatility, as `log` relates to where we want our messages to end up.
  prefs: []
  type: TYPE_NORMAL
- en: As for our purposes so far, the messages are ethereal. Switching out a simple
    `Println` statement to `Logger` is extremely simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve been relaying messages before using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice the change to `Logger` proves pretty similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is especially useful for goroutines, as we can create either a global `Logger`
    interface that can be accessed anywhere or pass the logger's reference to individual
    goroutines and ensure our logging is handled concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: One consideration for having a single logger for use across our entire application
    is the possibility that we may want to log individual processes separately for
    clarity in analysis. We'll talk a bit more about that later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replicate passing messages to the command line, we can simply use the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With defaults to `stdout` as its `io.writer`—recall that we can set any `io.writer`
    as the log's destination.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will also want to be able to log to file quickly and easily. After
    all, any application running in the background or as a daemon will need to have
    something a little more permanent.
  prefs: []
  type: TYPE_NORMAL
- en: Logging errors to file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of ways to send an error to a logfile—we can, after all, handle
    this with built-in file operation OS calls. In fact, this is what many people
    do.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `log` package offers some standardization and potential symbiosis
    between the command-line feedback and more permanent storage of errors, warnings,
    and general information.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to do this is to open a file using the `os.OpenFile()` method
    (and not the `os.Open()` method) and pass that reference to our log instantiation
    as `io.Writer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at such functionality in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In our preceding goroutine package, we could assign each goroutine its own
    file and pass a file reference as an io Writer (we''ll need to have write access
    to the destination folder). The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Logging errors to memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about logging errors to memory, we're really referring to a data
    store, although there's certainly no reason other than volatility and limited
    resources to reject logging to memory as a viable option.
  prefs: []
  type: TYPE_NORMAL
- en: While we'll look at a more direct way to handle networked logging through another
    package in the next section, let's delineate our various application errors in
    a concurrent, distributed system without a lot of hassle. The idea is to use shared
    memory (such as Memcached or a shared memory data store) to pass our log messages.
  prefs: []
  type: TYPE_NORMAL
- en: While these will technically still be logfiles (most data stores keep individual
    records or documents as JSON-encoded hard files), it has a distinctively different
    feel than traditional logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our old friend from the previous chapter—CouchDB—passing our
    logging messages to a central server can be done almost effortlessly, and it allows
    us to track not just individual machines, but their individual concurrent goroutines.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what will eventually become our JSON document that will be sent to
    our Couchbase server. We''ll use the `Page`, `Timestamp`, and `ServerID` as a
    combined, hashed key to allow multiple, concurrent requests to the same document
    against separate servers to be logged separately, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we reset `currentGoroutine` to `0`, we use an intentional race condition
    to allow goroutines to report themselves by numeric ID while executing concurrently.
    This allows us to debug an application that appears to work correctly until it
    invokes some form of concurrent architecture. Since goroutines will be self-identified
    by an ID, it allows us to add more granular routing of our messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'By designating a different log location by goroutine `ID`, `timestamp`, and
    `serverID`, any concurrency issues that arise can be quickly plucked from logfiles.
    This is done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the log4go package for robust logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most things in Go, where there's something satisfactory and extensible
    in the core page, it can be taken to the next level by a third party—Go's wonderful
    logging package is truly brought to life with **log4go**.
  prefs: []
  type: TYPE_NORMAL
- en: Using log4go greatly simplifies the process of file logging, console logging,
    and logging via TCP/UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on log4go, visit [https://code.google.com/p/log4go/](https://code.google.com/p/log4go/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each instance of a `log4go Logger` interface can be configured by an XML configuration
    file and can have filters applied to it to dictate where messaging goes. Let''s
    look at a simple HTTP server to show how we can direct specific logs to location,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created four distinct log objects—one that writes
    errors to a logfile, one that writes accesses (page requests) to a separate file,
    one that sends directly to console (for important notices), and one that passes
    a log message across the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two obviously do not need `FileLogWriter`, although it''s entirely
    possible to replicate the network logging using a shared drive if we can mitigate
    issues with concurrent access, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Any request to a valid page goes here, sending the message to the `web-access.log`
    file `accessLog`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `accessLog` file, we''ll take any `404 / page not found` request
    and route it directly to the `notFound()` method, which saves a fairly generic
    error message along with the invalid `/` missing URL requested. Let''s look at
    what we''ll do with extremely important errors and messages in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `restricted()` function and corresponding `screenLog` represents a message
    we deem as *critical* and worthy of going to not only the error and the access
    logs, but also to screen and passed across the wire as a `networkLog` item. In
    other words, it's a message so important that everybody gets it.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're detecting attempts to get at our `.git` folder, which is
    a fairly common accidental security vulnerability that people have been known
    to commit in automatic file uploads and updates. Since we have cleartext passwords
    represented in files and may expose that to the outside world, we'll catch this
    on request and pass to our critical and noncritical logging mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might also look at this as a more open-ended bad request notifier—one worthy
    of immediate attention from a network developer. In the following code, we''ll
    start creating a few loggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since log4go opens up a bevy of additional logging options, we can play a bit
    with how our logs rotate and are formatted without having to draw that out specifically
    with `Sprintf` or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options here are simple and expressive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetFormat`: This allows us to specify how our individual log lines will look.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetRotate`: This permits automatic rotation based on the size of the file
    and/or the number of lines in `log`. The `SetRotateSize()` option sets rotation
    on bytes in the message and `SetRotateLines()` sets the maximum number of `lines`.The
    `SetRotateDaily()` function lets us create new logfiles based on the day regardless
    of our settings in the previous functions. This is a fairly common logging technique
    and can generally be burdensome to code by hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of our logging format ends up looking like the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%S` part is the source, and that gives us the line number and our method
    trace for the part of our application that invoked the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our network log sends JSON-encoded messages via TCP to the address we provide.
    We''ll show a very simple handling server for this in the next section of code
    that translates the log messages into a centralized logfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `accessLogWriter` is similar to the `errorLogWriter` except that instead
    of rotating daily, we rotate it every 500 lines. The idea here is that access
    logs would of course be more frequently touched than an error log—hopefully. The
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we used the Gorilla Mux package for routing. This gives
    us easier access to the `404` handler, which is less than simplistic to modify
    in the basic `http` package built directly into Go. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Building the receiving end of a network logging system like this is also incredibly
    simple in Go, as we're building nothing more than another TCP client that can
    handle the JSON-encoded messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with a receiving server that looks remarkably similar to our
    TCP chat server from an earlier chapter. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As with our chat server, we bind our listener to a `Connection` struct, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we receive log messages delivered via JSON. At this point,
    we're not unmarshalling the JSON, but we've shown how to do that in an earlier
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Any message sent will be pushed into the buffer—for this reason, it may make
    sense to expand the buffer's size depending on how detailed the information is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can imagine how network logging can be useful, particularly in server clusters
    where you might have a selection of, say, web servers and you don't want to reconcile
    individual logfiles into a single log.
  prefs: []
  type: TYPE_NORMAL
- en: Panicking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all the discussion of capturing errors and logging them, we should probably
    consider the `panic()` and `recover()` functionality in Go.
  prefs: []
  type: TYPE_NORMAL
- en: As briefly discussed earlier, `panic()` and `recover()` operate as a more basic,
    immediate, and explicit error detection methodology than, say, `try`/`catch`/`finally`
    or even Go's built-in error return value convention. As designed, `panic()` unwinds
    the stack and leads to program exit unless `recover()` is invoked. This means
    that unless you explicitly recover, your application will end.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how is this useful other than for stopping execution? After all, we can
    catch an error and simply end the application manually through something similar
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: However, while this function does sanity checking and enacts a permanent, irreversible
    application exit, `panic()` and `recover()` allow us to reflect errors from a
    specific package and/or method, save those, and then resume gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful when we're dealing with methods that are called from other
    methods that are called from other methods, and so on. The types of deeply embedded
    or recursive functions that make it hard to discern a specific error are where
    `panic()` and `recover()` are most advantageous. You can also imagine how well
    this functionality can play with logging.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `panic()` function on its own is fairly simple, and it really becomes useful
    when paired with `recover()` and `defer()`.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, an application that returns meta information about a file
    from the command line. The main part of the application will listen for user input,
    pass this into a function that will open the file, and then pass that file reference
    to another function that will get the file's details.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can obviously stack errors as return elements straight through the process,
    or we can panic along the way, recover back down the steps, and gather our errors
    at the bottom for logging and/or reporting directly to console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoiding spaghetti code is a welcomed side effect of this approach versus the
    former one. Think of this in a general sense (this is pseudo code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With a single error, it''s entirely manageable to approach our application
    in this way. However, when each individual function has one or more points of
    failure, we will require more and more return values and a way of reconciling
    them all into a single overall error message or messages. Check the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our general recovery function, which is called before every method
    on which we wish to capture any panic. Let''s look at a function to deduce the
    file''s details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The two functions from the preceding code are merely an attempt to open a file
    and panic if the file does not exist. The second method, `getFileDetails()`, is
    called from the `main()` function such that it will always execute, regardless
    of a blocking error in `openFile()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real world, we will often develop applications where a nonfatal error
    stops just a portion of the application from working, but will not cause the application
    as a whole to break. Check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If we were to remove the `recover()` code from our `gatherPanics()` method,
    the application would crash if/when the file didn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem ideal, but imagine a scenario where a user selects a nonexistent
    file for a directory that they lack the rights to view. When they solve the first
    problem, they will be presented with the second instead of seeing all potential
    issues at one time.
  prefs: []
  type: TYPE_NORMAL
- en: The value of expressive errors can't be overstated from a user experience standpoint.
    Gathering and presenting expressive errors is made easier through this methodology—even
    a `try`/`catch`/`finally` requires that we (as developers) explicitly do something
    with the returned error in the catch clause.
  prefs: []
  type: TYPE_NORMAL
- en: Logging our panics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code, we can integrate a logging mechanism pretty simply in
    addition to catching our panics.
  prefs: []
  type: TYPE_NORMAL
- en: One consideration about logging that we haven't discussed is the notion of when
    to log. As our previous examples illustrate, we can sometimes run into problems
    that should be logged but may be mitigated by future user action. As such, we
    can choose to log our errors immediately or save it until the end of execution
    or a greater function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary benefit of logging immediately is that we''re not susceptible to
    an actual crash preventing our log from being saved. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created a log `struct` and a slice of `LogItems` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This, ostensibly, is where all of our captured `LogItems` will be turned into
    a good collection of line items in a logfile. There is a problem, however, as
    illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Executed in a goroutine, this function is non-blocking and allows the main
    thread''s execution to continue. The problem is with the following code that runs
    after the goroutine, which causes us to log nothing at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether invoked manually or by the binary itself, the application quitting
    prematurely precludes our logfiles from being written, as that method is deferred
    until the end of the `main()` method. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The tradeoff here, however, is performance. If we execute a file operation every
    time we want to log something, we're potentially introducing a bottleneck into
    our application. In the preceding code, errors are sent via goroutine but written
    in blocking code—if we introduce the log writing directly into `registerError()`,
    it can slow down our final application.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, one opportunity to mitigate these issues and allow
    the application to still save all of our log entries is to utilize either memory
    logging or network logging.
  prefs: []
  type: TYPE_NORMAL
- en: Catching stack traces with concurrent code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In earlier Go releases, the ability to properly execute a stack trace from our
    source was a daunting task, which is emblematic of some of the many complaints
    and concerns users had early on about general error handling in Go.
  prefs: []
  type: TYPE_NORMAL
- en: While the Go team has remained vigilant about the *right* way to do this (as
    they have with several other key language features such as a lack of generics),
    stack traces and stack info have been tweaked a bit as the language has grown.
  prefs: []
  type: TYPE_NORMAL
- en: Using the runtime package for granular stack traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an effort to capture stack traces directly, we can glean some helpful pieces
    of information from the built-in runtime package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, Go provides a couple of tools to give us insight into the invocation
    and/or breakpoints of a goroutine. The following are the functions within the
    runtime package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`runtime.Caller()`: This returns information about the parent function of a
    goroutine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime.Stack()`: This allocates a buffer for the amount of data in a stack
    trace and then fills that with the trace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime.NumGoroutine()`: This returns the total number of open goroutines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can utilize all three preceding tools to better describe the inner workings
    of any given goroutine and related errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following code, we''ll spawn some random goroutines doing random
    things and log not only the goroutine''s log message, but also the stack trace
    and the goroutine''s caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `saveLogs()` function merely takes our map of `LogItems` and applies them
    to file per log4go, as we did earlier in the chapter. Next, we''ll look at the
    function that supplies details on our goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where we gather more details about a goroutine. The `runtime.Caller()`
    function provides a few returned values: its pointer, the filename of the caller,
    the line of the caller. The last return value indicates whether the caller could
    be found.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, `runtime.NumGoroutine()` gives us the number of extant
    goroutines that have not yet been closed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in `runtime.Stack(stackBuf, false)`, we fill our buffer with the stack
    trace. Note that we're not trimming this byte array to length.
  prefs: []
  type: TYPE_NORMAL
- en: 'All three are passed into `LogItem.Message` for later use. Let''s look at the
    setup in the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we loop through some goroutines that are doing loops themselves and
    exit upon completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we examine our logfile, we''re given far more verbose details on our goroutines
    than we have previously, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the runtime package, go to [http://golang.org/pkg/runtime/](http://golang.org/pkg/runtime/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging, testing, and logging concurrent code can be particularly cumbersome,
    often when concurrent goroutines fail in a seemingly silent fashion or fail to
    execute whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at various methods of logging, from file to console to memory to network
    logging, and examined how concurrent application pieces can fit into these various
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be comfortable and natural in creating robust and expressive
    logs that rotate automatically, impose no latency or bottlenecks, and assist in
    debugging your applications.
  prefs: []
  type: TYPE_NORMAL
- en: You should feel comfortable with the basics of the runtime package. We'll dive
    into the testing package, controlling goroutines more explicitly, and unit testing
    as we dig deeper in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to further examining the testing and runtime packages, in our final
    chapter, we'll also broach the topic of more advanced concurrency topics in Go
    as well as review some overall best practices as they relate to programming in
    the Go language.
  prefs: []
  type: TYPE_NORMAL
