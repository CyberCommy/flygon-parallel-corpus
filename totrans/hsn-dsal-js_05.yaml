- en: Simplify Complex Applications Using Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to define a graph would be anything that is a collection of
    nodes in which the nodes are connected by edges. Graphs are one of the most popular
    mathematical concepts that are used in computer science. Popular examples of graph
    implementations would be any social media website these days. Facebook use *friends*
    as nodes and *friendship* as edges; Twitter, on the other hand, defines *followers*
    as nodes and *following* as an edge, and so on. Take a look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d8be5138-4d0c-4624-9c82-e933197e3fd2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, you can see a typical graph with *nodes* and *edges*.
    As you can note, there are no directions listed out to our edges, and there are
    no details mentioned on our nodes. This is because there are different types of
    graphs, and the nodes and edges vary slightly between these different types of
    graphs, which we will see in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will first go over the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a reference generator for a job portal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a friend recommendation system
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Types of graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the preceding description, we can speculate on the types of graphs. There
    are way too many to cover in this chapter or even in this book. However, let''s
    take a look at some of the most important and popular graphs, which we will be
    exploring with examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple graphs**: A simple graph is an undirected, unweighted graph that contains
    no loops or multi-edge (that is multiple edges between the two nodes also known
    as parallel edges) nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/c6c9cd6b-d1fe-4904-bc9d-15317644dfc0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Undirected graphs**: This is a graph in which the edge definitions are interchangeable.
    For example, in the following image, the edge between nodes **1** and **2** can
    be represented as (1,2) or (2,1). The nodes are thus joined by a line without
    the arrows pointing towards any of the nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/6f480d4b-8a1a-4a4c-937a-589b08501a32.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Directed graphs**: This is a graph in which the edges are given predefined
    direction based on a functional or logical condition. The edges are drawn with
    arrows, indicating the direction of the flow, for example, one user following
    another user on Twitter. Take a look at the following image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/bf89bad9-4cda-460f-a26a-d7fe494e145d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Cyclic graphs**: This is a graph in which the edges form a circular connection
    between nodes, that is, the start and end nodes are the same. For example, in
    the following image, we can note that the nodes **1** >> **5** >> **6** >> **7**
    >> **3** >> **1** form the cycle within the graph:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/bf89bad9-4cda-460f-a26a-d7fe494e145d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Directed acyclic graphs**: This is a directed graph with no cycles. These
    are the most common kind of graphs. In the following example, nodes are **1**,
    **2**, **3**, **4**, **5**, **6**, **7** and edges are {(1, 2), (1, 3), (1, 5),
    (2, 4), (4, 3), (4, 6), (5, 4), (5, 6), (6, 7), (7, 3)}:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/46f3b2e7-694f-4ce4-a7b9-f6550d0016d6.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Weighted graphs**: This is a graph in which the edges are assigned numeric
    weights based on how expensive or inexpensive it can be to traverse that edge.
    The usage of the weight of each edge can vary based on the use cases. In the following
    example, you can note that the graphs are assigned weights (**0**, **1**, **3**,
    or **5**) based on the edges between them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/c6e00e40-2786-46eb-b85d-43d2ac14d9d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Fortunately, or unfortunately, the problems that we face in our day-to-day challenges
    do not directly tell us whether we can solve them with a graph, and if so, what
    kind of graph it needs to be or what kind of parsing algorithm we will need to
    employ. This is something that we take upon a case-by-case basis, which is what
    we will be doing with the following use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a graph is similar to that of trees; there is no set way of creating
    one. However, based on your use case, you can structure your graphs as directed,
    cyclic, or any other form as explained earlier. Doing this can make their traversal
    easier, which would, in turn, make data retrieval easier and faster.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some examples for which we will be needing a base application
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Node.js web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a web server using Node.js, which we will use to create
    endpoints later on to access our graph-based applications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create your application''s project folder; to do so, run
    the following command from the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to initialize a Node.js project, run the `init` command in the root folder
    of your project. This will prompt a series of questions to generate the `package.json`file.
    You can fill out the answers you want or just click on `return`to accept default
    values for the prompts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, since we want to create a web server, we will use `express`*, *which
    is a very powerful and popular framework available for Node.js. We will also use
    another library called `body-parser`, which helps us parse the incoming JSON body
    requests with ease. Lastly, we will also use `lodash` to help out with some complex
    data manipulations. To install `lodash`, `express`, and `body-parser`, run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the application setup done, we will need to start the application
    server using express and include our `body-parser` middleware. So, we can now
    create a `server.js` file at the root and then add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the app is ready to be launched. Under the `scripts` tag of your `package.json`
    file, add the following and then run `npm start` from the terminal to bring your
    server up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating a reference generator for a job portal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will create a reference generator for a job portal. For
    instance, we have a few users who are friends with each other, we will create
    nodes for each of the users and associate each of the nodes with data, such as
    their name and the company at which they work.
  prefs: []
  type: TYPE_NORMAL
- en: Once we create all these nodes, we will join them based on some predefined relationships
    between the nodes. Then, we will use these predefined relationships to determine
    who a user would have to talk to to get referred for a job interview at a company
    of their choice. For example, A who works at company X and B who works at company
    Y are friends, B and C who works at company Z are friends. So, if A wants to get
    referred to company Z, then A talks to B, who can introduce them to C for a referral
    to company Z.
  prefs: []
  type: TYPE_NORMAL
- en: In most production-level apps, you will not be creating the graphs in such a
    fashion. You can simply use a graph database, which can perform a lot of features
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our example, in more technical terms, we have an undirected graph
    (think of users as nodes and friendship as edges between them), and we want to
    determine the shortest path from one node to another.
  prefs: []
  type: TYPE_NORMAL
- en: To do what we have described so far, we will be using a technique known as **Breadth
    First Search**(**BFS**)*. *BFS is a graph traversal mechanism in which the neighboring
    nodes are examined or evaluated first before moving on to the next level. This
    helps to ensure that the number of links found in the resulting chain is always
    minimum, hence we always get the shortest possible path from node A to node B.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are other algorithms, such as **Dijkstra**, to achieve similar
    results, we will go with BFS because Dijkstra is a more complex algorithm that
    is well suited when each edge has an associated cost with it. For example, in
    our case, we would go with Dijkstraif our user's friendships have a weight associated
    with it such as *acquaintance*, *friend*, and *close friend*, which would help
    us associate weights with each of those paths.
  prefs: []
  type: TYPE_NORMAL
- en: A good use case to consider Dijkstra would be for something such as a Maps application,
    which would give you directions from point A to B based on the traffic (that is,
    the weight or cost associated with each edge) in between.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bidirectional graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can start with logic for our graph by creating a new file under `utils/graph.js`,
    which will hold the edges and then provide a simple `shortestPath`method to access
    the Graph and apply the BFS algorithm on the graph that is generated, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we add the edges to our graph, it has nodes (user IDs), and edges are
    defined as the relationship between each user ID and friend in the `friends` array,
    which is available for each user. Forming the graph was an easy task, thanks to
    the way our data is structured. In our example dataset, each user has a set of
    friends list, which is listed in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can note in the preceding code, we did not really have to establish a
    bidirectional edge exclusively here because if user `1` is a friend of user `2`
    then user `2` is also a friend of user `1.`
  prefs: []
  type: TYPE_NORMAL
- en: Generating a pseudocode  for the shortest path generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before its implementation, let''s quickly jot down what we are about to do
    so that the actual implementation becomes a lot easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the shortest path generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create our customized BFS algorithm to parse the graph and generate
    the shortest possible path for our user to get referred to company A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part of the code is when the match is found, as shown in
    the following code block from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are employing a technique called backtracking, which helps us retrace
    our steps when the result is found. The idea here is that we add the current state
    of the iteration to a map whenever the result is not found—the key as the node
    being visited currently, and the value as the node from which we are visiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, if we visited node 1 from node 3, then the map would contain
    { 1: 3 } until we visit node 1 from some other node, and when that happens, our
    map will update to point to the new node from which we got to node 1, such as
    { 1: newNode }. Once we set up these previous paths, we can easily trace our steps
    back by looking at this map. By adding some log statements (available only in
    the GitHub code to avoid confusion), we can easily take a look at the long but
    simple flow of the data. Let us take an example of the data set that we defined
    earlier, so when Bill tries to look for friends who can refer him to Toyota, we
    see the following log statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What we basically have here is an iterative process using BFS to traverse the
    tree and backtracking the result. This forms the core of our functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now add a route to access this graph and its corresponding `shortestPath`
    method.  Let''s first create the route under `routes/references` and add it as
    a middleware to the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the route as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running the reference generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test this, simply start the web server by running the `npm start` command
    from the root of the project as shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the server is up and running, you can use any tool you wish to post the
    request to your web server, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/986cd6f5-bb76-4a38-87cc-86cbe6efd012.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, we get the response back as expected.
    This can, of course, be changed in a way to return all the user objects instead
    of just the names. That could be a fun extension of the example for you to try
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a friend recommendation system for social media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You cannot simply deny the fact that social networking sites are all about the
    data. This is why a majority of the features built in these websites rely on the
    data that you provide to them. One such example of these is a *people you might
    know* or a *who to follow* component that you can find on many of the websites.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous example, we know that the data can be grouped into `nodes`
    and `edges`, in which the nodes are the people and the edges are the relationships
    that you want to establish between the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We could simply form a bidirected graph and then apply a BFS algorithm to determine
    the connected nodes at *n*th degree, which we can then de-duplicate to show the
    friend or node recommendations. However, considering that we already did this
    in the preceding example, and also that the actual list of users and friends of
    each of these users is huge in a production application, we will take a different
    approach. We will go with the assumption that our dataset is stored in a graph
    database, such as **neo4j***, *and then we will use an algorithm called **Personalized
    PageRank**, that is a BFS and PageRank combination which we will explore in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PageRank algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point in our lives, we must have come across this term, PageRank. PageRank
    is one of the many ways in which Google ranks the web pages for searching and
    indexing. A simple Google search (pun totally intended) will return results that
    tell you how it basically involves a collection of nodes from which we can walk
    in a random direction. However, what does that really mean?
  prefs: []
  type: TYPE_NORMAL
- en: Given that the control is dropped on any node within a graph, we are saying
    that the control can jump to any node on the graph unbiased with a probability
    of `alpha`,and when it does land on any node, it shares a portion of its rank
    equally with all of its connected nodes before traversing along one of these nodes
    edges randomly with a probability of `(1 - alpha)`.
  prefs: []
  type: TYPE_NORMAL
- en: How and why does this matter? It's just jumping from one node to another and
    then randomly traversing to some other connected node, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do this for long enough, you would land on all the nodes and some of
    the nodes more times than the other. You see where I am going with this? This
    would end up telling you which nodes are more frequented compared to others, which
    could happen for the following two reasons :'
  prefs: []
  type: TYPE_NORMAL
- en: We just happened to jump to the same node multiple times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That node is connected to multiple nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first scenario can happen, but, since we know that our jumps are unbiased
    and the Law of Large Numbers dictates that this would yield the normalized value
    when done for long enough, we can safely rule it out.
  prefs: []
  type: TYPE_NORMAL
- en: The second scenario, on the other hand, is not only possible but also very important
    to PageRank. Once you land on one of these nodes, that's when we calculate the
    PageRank for that node-based on alpha and on the rank inherited from the preceding
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We were talking in abstract terms of nodes and edges; however, for a brief
    time, let''s take a look at a statement made in the very first publication of
    PageRank by Sergey Brin and Lawrence Page ([http://infolab.stanford.edu/~backrub/google.html](http://infolab.stanford.edu/~backrub/google.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assume page A has pages T1...Tn which point to it (i.e., are citations).
    The parameter d is a damping factor which can be set between 0 and 1\. We usually
    set d to 0.85. There are more details about d in the next section. Also, C(A)
    is defined as the number of links going out of page A. The PageRank of page A
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: PR(A) = (1-d) + d (PR(T1)/C(T1) + ... + PR(Tn)/C(Tn))
  prefs: []
  type: TYPE_NORMAL
- en: Note that the PageRanks form a probability distribution over web pages, so the
    sum of all web pages' PageRanks will be one.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding statement, we can see that the PageRank *(PR*) of a given
    page/node is derived from the *PR* of its citations (*T1...Tn*), but how does
    one know where to start since we need to know its citations to calculate the PR
    for *T1*. The simple answer is that we do not need to know the value of the *PR(T1)*
    or any other citation as a matter of fact. What we can do instead is to simply
    guess a value for *PR(T1)* and recursively apply the values that are derived from
    the preceding step.
  prefs: []
  type: TYPE_NORMAL
- en: However, why on earth would that work, you ask? The answer is simple, remember
    the Law of Large Numbers? If you repeat an action for long enough, the result
    of the said action will converge to the median value. Then, there are questions
    about how you can do it for the millions and billions of web pages and be effective?
    There are ways and means, which are beyond the scope of this chapter and book;
    however, for those interested, this book that explains Google's Page Rank is a
    great read, available at [https://press.princeton.edu/titles/8216.html](https://press.princeton.edu/titles/8216.html).
    I hope that this book sheds some light on the basic principle involved.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Personalized PageRank (PPR) Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a brief understanding of PageRank, what is Personalized PageRank?
    It's quite simple actually, instead of jumping to a random node every time, we
    jump to a predefined node and then recursively accumulate the probability of hitting
    each node while traversing using BFS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a few friends who are structured as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1ae23c87-a88e-4087-8b5b-0b8f5f37b003.png)'
  prefs: []
  type: TYPE_IMG
- en: This is straightforward; we have bidirectional edges between the nodes, indicating
    a friendship between them. In this problem, we can assume that we want to suggest
    new friends to User **A**.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest part is also the important thing that we need to talk about before
    moving onto the code for PPR. We will always be starting out from our target node,
    that is, the jumps are no longer started at random. We start at our target node,
    assume that the control traverses all edges equally, and then come back to the
    parent. Then, we recursively repeat this process while expanding the degree by
    one edge at a time until we meet our target degree.
  prefs: []
  type: TYPE_NORMAL
- en: Also, every time we increase our search by one degree from the target node,
    we are sharing the probability of the node with the neighbors, but if we share
    all of it, the node becomes 0 so what we would do instead is to apply a damping
    factor (alpha).
  prefs: []
  type: TYPE_NORMAL
- en: For example, assume that we are at the node *X*, which has a probability of
    1 (that is, it is the target node), and that this node *X* has two neighbors, *Y*,
    and *Z*. The alpha that we set (for example, 0.5) will be applied here, so after
    the first iteration, *X* would have the probability as 0.5, and then *Y* and *Z*
    would have an equal probability of 0.25\. Then, the process would be repeated
    recursively to the next degree with this new map of probabilities that we have
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudocode for personalized PageRank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s convert what we discussed in the earlier section into the pseudocode
    for an easier implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that was not scary, was it? Implementing the PPR algorithm now is going
    to be easy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we write any code for our Personalized PageRank, let's first create a
    Node.js application, as explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the application is ready, let''s create a route that will be serving us
    our user suggestions. Similar to the example from the preceding example, we can
    quickly piece together the following route under `routes/suggestions.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also quickly piece together our express server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Personalized PageRank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s move over to creating our **Personalized PageRank** (**PPR**) algorithm.
    We will be creating an `ES6` class, which will handle all of the logic to generate
    the suggestions once we provide the graph and target node to it. Note that in
    the preceding code, I have already shown you what the graph looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have established a bidirectional relationship by specifying two nodes as
    each other''s neighbors.  Now, we can start with the code for PPR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will first accept the graph as the input to our `constructor`. Next, we
    will define our `getSuggestions` method, which will accept the input `nodeId`
    and then pass it to calculate the PPR. This is also the first step of our preceding
    pseudo code, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since our control is defined to start from a fixed node, we are setting it the
    probability of `1`. We will be iterating three times simply because we want to
    go only three levels out to get the suggestions. Level 1 is the target node, level
    2 is the neighbors of the target node (that is, current friends) and then level
    3 is the neighbors of neighbors (that is, friends of friends).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we get to the fun part. We will recursively calculate the probability
    of us jumping on to each of the neighboring nodes, starting from the target node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That was not half as bad as you thought, right? Once we have the PPR algorithm
    ready to go, we can now import this class into our `suggestions` route and can
    use it to generate the recommendations for any input user, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Results and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to test this, let''s start off our web server by running the `npm start`
    command from the root folder. Once your application starts, you will see the following
    message on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the message appears, you can either open Postman or anything else of your
    choice to make the API calls for suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3a99d1de-2e5a-4c3e-bbfd-86262553501b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that user `C` has received more score than user `E`. This is because
    we can see from the input dataset that the users `A` and `C` have more common
    friends than user `A` and `E`. This is why, as per our deduction earlier, the
    chances of our control landing on node `C` are higher than that of node `E`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the interesting thing to note is that the actual value of the score is
    immaterial here. You only need to look at the comparison of the scores to determine
    which one is more likely to happen. You can change alpha as you wish to decide
    how much probability each node is going to split between its neighbors, and that
    would ultimately change the score of each of the resultant nodes, for example,
    the results which shows the name and the score as we saw preceding are with the
    alpha value of 0.5; we will now change it to `0.33`, that is, the parent node
    keeps one-third and splits the rest with the neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0c1ffd35-abd0-4486-b64c-ca37e5574010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Few log statements are added before each recursive call for some additional
    clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding log statements yield the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/09b6cd98-6333-4725-b931-03af662e5509.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, you can note that at the end of the first iteration,
    the total probability of 1, which we assigned to target node `A`, has been split
    into three parts after our logic determined by BFS traversal that neighbors of
    node `A` are nodes `B` and `D`. Now, this became the input of iteration 2, where
    we repeated the process until the last iteration, at the end of which we remove
    the current target node `A` and its immediate neighbor nodes `B` and `D` (since
    they are already friends) and return the remaining, that is, nodes `C` and `E`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took some real-world challenges head-on and created some
    custom solutions based on the problem at hand. This is one of the most important
    takeaways from this chapter. Rarely would you find a scenario where an ideal solution
    is readily available. We took up one of the graph theories algorithms, known as
    BFS, and leveraged it to our advantage in generating the recommendations for our
    job portal and user suggestions. We also briefly discussed PageRank algorithm,
    which any developer should be familiar with. That brings the question of why and
    when to use one algorithm over the other. What are the pros and cons of choosing
    an algorithm? This will be the topic for our next chapter, where we will do an
    analysis of the different types of algorithms and where we can apply them.
  prefs: []
  type: TYPE_NORMAL
