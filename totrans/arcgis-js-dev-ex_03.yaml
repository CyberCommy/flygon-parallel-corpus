- en: Chapter 3. Writing Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"The art and science of asking questions is the source of all knowledge."*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Thomas Berger* |'
  prefs: []
  type: TYPE_TB
- en: 'Queries are the gateways to asking questions to the map through the API. They
    are considered as a *task* in the API terminology because the process of forming
    queries and getting the answers is a sequence of operations that must be carried
    out properly. In this chapter, we will be developing a Wildfire Location app to
    understand the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Building and executing the Query task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and executing the Identify task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and executing the Find task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises, deferred, and the result objects for the Query, Find, and Identify
    tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `FeatureTable dijit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Infotemplates`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the Wildfire application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be developing an app that will display Active Wildfire
    Locations in the United States with a background map showing the Wildfire Potential
    for any location. We will also try to provide search/query functionalities by
    harnessing the components provided by the API. The following screenshot provides
    a rough rendition of our final application that we will have developed by the
    end of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing the Wildfire application](graphics/B04959_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The application will have the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Dark gray basemap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two operational map services, one displaying the Wildfire potential for the
    United States (raster data) and the other displaying Active Wildfire Locations
    (point data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A legend dijit (dojo widget) displaying the symbology of the layers added to
    the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A report widget that shows all the records of the Active Wildfire Locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A query widget where you can query Active Wildfire Locations based on the areal
    extent of Wildfire (this information is available in a field in the data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Find widget where you can enter any text, and all the States or Fire Names
    matching the search text will be fetched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A map click event that will identify and conspicuously display Wildfire Potential
    at the map click location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two operational data sources; one is the Wildfire Hazard Potential
    map service available at [http://maps7.arcgisonline.com/arcgis/rest/services/USDA_USFS_2014_Wildfire_Hazard_Potential/MapServer](http://maps7.arcgisonline.com/arcgis/rest/services/USDA_USFS_2014_Wildfire_Hazard_Potential/MapServer)
    and the other is Active Wildfire Data available at [http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/Wildfire_Activity/MapServer](http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/Wildfire_Activity/MapServer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latter map service is a *secured* map service, meaning that we need an
    ArcGIS Online account or an ArcGIS Developer account to use it. Apart from the
    preceding data sources, to access the vast pool of ArcGIS Online Data and the
    ones published in the Living Atlas of the World ([http://doc.arcgis.com/en/living-atlas/](http://doc.arcgis.com/en/living-atlas/)),
    we need to do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the app in ArcGIS Developer Portal and get a token for the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate ArcGIS Proxy Code in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering the application in the developer portal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using our ArcGIS Developer credentials (which we created as part of the *Setting
    up the development environment* section in [Chapter 1](ch01.html "Chapter 1. Foundation
    for the API"), *Foundation for the API*), sign into the ArcGIS Developer portal
    ([https://developers.arcgis.com/](https://developers.arcgis.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Next, navigate to the **Applications** page of the developer portal by clicking
    the appropriate icon as highlighted in the following screenshot. You can even
    do so by visiting [https://developers.arcgis.com/applications/](https://developers.arcgis.com/applications/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering the application in the developer portal](graphics/B04959_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we click on the **Register New Application** button, we will be prompted
    to enter the details about our application, as shown in the following screenshot.
    After providing the required details, if we click on the **Register New Application**
    button again, we will be led to another screen that displays the token for the
    app. This short-lived token can be used to access any secured ArcGIS Online map
    services. For example, try accessing the this in your browser—[http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/Wildfire_Activity/MapServer](http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/Wildfire_Activity/MapServer).
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll be redirected to a page that requires you to enter a token. When you
    provide the token that you got in the previous screen, you can see Service Catalog
    for the map service that we intend to see. The following screenshot explains this
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering the application in the developer portal](graphics/B04959_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using a proxy in the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, we need to use an Esri resource proxy to access secure ArcGIS
    Online data sources. The resource proxy is the server-side code that handles the
    request from the client to ArcGIS Server and forwards the response back from ArcGIS
    Server to the client. Esri has provided a proxy implementation that is specifically
    suitable for ArcGIS Server and ArcGIS Online. The Github code can be found at
    [https://github.com/Esri/resource-proxy](https://github.com/Esri/resource-proxy).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will only be using the ASP.NET variant of the resource proxy that contains
    the following important files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`proxy.ashx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy.config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Web.config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `proxy.ashx` file contains the server-side code logic for making the request
    and forwarding the response back to the client. We need to configure `proxy.config`
    and include our ArcGIS Developer credentials in it. A sample `proxy.config` page
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a proxy in the application](graphics/B04959_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To configure the `proxy.config` file, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `proxy.config` file, modify the property values for `url`, `username`,
    and `password` in the `serverUrl` tag. For the `tokenServiceUri` property, the
    value should always be `https://www.arcgis.com/sharing/generateToken`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `url` property, the value will be the location of the ArcGIS Server
    service. Specify either the specific URL (in this case, you will set `matchAll="false"`)
    or just the root URL (as shown in the preceding screenshot; in this case, the
    `matchAll` value will be `"true"`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on configuring the `proxy.config` file, refer to [https://github.com/Esri/resource-proxy/blob/master/README.md#proxy-configuration-settings](https://github.com/Esri/resource-proxy/blob/master/README.md#proxy-configuration-settings).
  prefs: []
  type: TYPE_NORMAL
- en: 'After configuring the proxy pages, we need to add a few more lines of code
    to our application. We need to load the `esri/config` module and use the following
    lines in our app code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In our application, the `proxy.ashx` page is located in the `proxy` folder
    at the application root. If the proxy pages are at a different application, we
    need to change the value for the `esriConfig.defaults.io.proxyUrl` variable. When
    we set the `esriConfig.defaults.io.alwaysUseProxy` value as `true`, all requests
    are handled by the proxy. If we need only specific URLs to be handled by the proxy,
    we may need to add a few more lines of code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `urlUtils` function is provided by the `esri/urlUtils` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the flow of a HTTP REST request from the client
    to a secure ArcGIS Server service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a proxy in the application](graphics/B04959_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bootstrapping the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the applications throughout this book are styled and bootstrapped using
    Bootstrap map libraries. The source code for these libraries can be found at [https://github.com/Esri/bootstrap-map-js](https://github.com/Esri/bootstrap-map-js).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you download the required libraries, we will need to add the following
    CSS and JavaScript libraries to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once these libraries are added, we need to add one more JavaScript file as a
    dojo module and not as a script reference. In our application, the JavaScript
    library under discussion is located at `/js/lib/bootstrapmap.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding this library as a module in the require function, we need to omit
    the file extension. The following screenshot illustrates this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrapping the application](graphics/B04959_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, instead of using the `esri/map` module, we will be using the `bootstrapmap`
    module to create the map. The `bootstrapmap` module accepts all the properties
    and methods that the `esri/map` provides, since the `bootstrapmap` module is just
    a wrap around the `esri/map` module.
  prefs: []
  type: TYPE_NORMAL
- en: Types of querying operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Various types of querying operations are possible on the ArcGIS Server provided
    data. We will be dealing with the three most important querying operations provided
    by the API in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Query task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query task lets us operate just one layer, so the constructor for a Query task
    requires us to provide the URL of a feature layer. Query task lets us query the
    data using the attributes (field values; for example, query cities whose population
    is greater than 2 million) or using the location (for example, find all the gas
    stations that are within the current extent of the map or a custom-drawn extent).
    When the number of features satisfying the query conditions is greater than the
    limit set by the server (the `maxRecordCount` setting in ArcGIS Server), we can
    use a feature named *paging* to retrieve all the features on a batch mode.
  prefs: []
  type: TYPE_NORMAL
- en: Find task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find task can operate on multiple layers in a map service and multiple fields.
    Find task basically searches for a given text in all the fields throughout all
    the layers in a given map service. When we don't know which field we are searching
    for and thus can't construct a proper SQL `where` clause to query the data, this
    is an ideal operation to rely upon.
  prefs: []
  type: TYPE_NORMAL
- en: Identify task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Identify task is predominantly a location-based search operation that returns
    all the data from all the layers in a given map service that intersect with a
    given geometry (such as a map-click point).
  prefs: []
  type: TYPE_NORMAL
- en: 'In all the preceding tasks, we can restrict the fields or layers upon which
    the search operation is being performed. The following matrix summarizes all the
    options available with the three different types of query operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identify task](graphics/B04959_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building and executing a Query task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Query tasks** are designed to query `featureLayer`. Thus, to instantiate
    `querytask`, we need to provide the URL of `featurelayer`. In version 3.15 of
    the API, the module is named `esri/tasks/QueryTask`.'
  prefs: []
  type: TYPE_NORMAL
- en: The QueryTask constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for the `QueryTask` constructor is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The example for the `QueryTask` constructor is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Constructor parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The URL of a feature layer that has query functionality is enabled, to verify
    that the query functionality on a feature layer is enabled, we have to visit the
    Service Catalog of the map service and check that `Query` is among the supported
    operations for the feature layer we'd like to query upon.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the Active Wildfire map service that we were dealing with, we'd
    like to query the layer containing data about Active Wildfire layers. There's
    just one layer in the map service, hence the layer index for the feature layer
    is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The URL of the feature layer is [http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/Wildfire_Activity/MapServer/0](http://livefeeds.arcgis.com/arcgis/rest/services/LiveFeeds/Wildfire_Activity/MapServer/0).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we visit this link and scroll down to the bottom of the page where the
    **Supported Operations** section is found, we will see the Query operation being
    listed there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructor parameters](graphics/B04959_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Executing a query using a Query task involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructor parameters](graphics/B04959_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Instantiating the QueryTask object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Query task is based on the Active Wildfire feature layer. Hence, we will
    be using the feature layer''s URL to instantiate the `QueryTask` object. The following
    lines of code explain how to instantiate `QueryTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Building the Query object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `QueryTask` object just defines which layer or data you want to query, but
    we need to use the `Query` object to define what the actual query is. The Query
    object is provided by the `esri/tasks/Query` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Query object does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It forms a SQL `where` clause to query by attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a spatial geometry to perform the query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It indicates the spatial relationship with which the query has to be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requests an array of feature fields from the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It indicates whether the query result needs to return geometric information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Query object has a property named `where`. This property accepts SQL's `where`
    clauses and fetches the data that satisfies the `where` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the `where` clause is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Where `Query Expression` is `"<FieldName><operator><value>";`. And `<FieldName>`
    is the name of the field in the feature that we would like to query.
  prefs: []
  type: TYPE_NORMAL
- en: '`<operator>` is a kind of SQL operator, such as `LIKE`, `=`, `>`, `<`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates the use of the `where` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we would like to retrieve all the features from the `feature` class, the
    `where` clause needs to be set to a **truthy** expression, such as `1=1`. A truthy
    expression is something that evaluates to `true` under all circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a truthy expression to retrieve all features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practice, the number of features returned using this expression is determined
    by the server setting known as `MaxRecordCount`, as shown in the following screenshot.
    The default value is `1000`. This limit can be changed in the ArcGIS server settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'When evaluating strings, do remember to enclose the string value within single
    quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields required in the output feature set can be passed as an array of
    field names to the `query` object parameter called `outFields`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can indicate whether we need the geometric information of the features by
    passing the value `true` or `false` to the `query` object parameter called `returnGeometry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how to construct a complete `Query` object that
    can retrieve all the features from the feature layer set in the `Query` task object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Query object](graphics/B04959_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Querying by spatial geometry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can fetch features from a feature layer that has a spatial relationship with
    another input geometry. We need to define what the spatial relationship between
    the input geometry and the features to be retrieved are. When not defined, the
    default spatial relationship becomes an intersection. This means that we are trying
    to fetch features that intersect with an input geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '![Querying by spatial geometry](graphics/B04959_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are other types of spatial relationship provided by the Query object
    as constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Query.SPATIAL_REL_CONTAINS`: This retrieves all the features that are entirely
    contained by the input geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Query.SPATIAL_REL_INTERSECTS`: This is the default spatial relationship where
    all features that intersect with the input feature are fetched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Query.SPATIAL_REL_TOUCHES`: Here, all the features that touch the input geometry
    are fetched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Normally, the input geometry maybe a selected feature from another feature,
    class, or geometry from the `draw` object, or in our case, the current map''s
    extent, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Executing the query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we need to execute a query and retrieve the results, we need to invoke
    the query execution methods in the Query task object. A Query task can be executed
    for getting the actual features that satisfy the query. In some cases, we may
    only need the count of features that satisfy the query or the spatial extent of
    the query result. There are five types of query operation that can be performed
    on the query task object:'
  prefs: []
  type: TYPE_NORMAL
- en: Query for Features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query for Count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query for Extent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query for Object IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query for Relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All operations accepts the Query object as the first argument and return a
    deferred object. Let''s understand the use of the three most important query task
    operations: Query for Count, Query for Extent and Query for Features.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying for Count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we just want the count of the features that satisfy the query condition,
    we can use this operation. The following screenshot shows the Query for Count
    operation on a set of Query Features, given a Query object (with a Query Extent).
    The result will be the count of features that satisfy the Query object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Querying for Count](graphics/B04959_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Diagram illustrating Feature Querying by Count
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `executeForCount()` method of the query task, we still use the
    query object as the method argument. This can be an attribute query, a spatial
    query, or a combination of both. The main purpose of this method is to quickly
    assess the number of features a query operation returns. Sometimes, this may be
    the only information you need to display to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and create a UI to fetch the count of features that satisfy our
    query condition. The following screenshot shows a bootstrap panel with a text
    box to input the query text and the **Get Count** button. We have also provided
    another `div`, which is hidden. The `div` contains a label that shows the count
    of features.
  prefs: []
  type: TYPE_NORMAL
- en: '![Querying for Count](graphics/B04959_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Query execution should happen on clicking the **Get Count** button. When no
    input is provided in the query text box, the query will evaluate to a truthy expression;
    that is, the count of all the features within the map extent will be returned.
    The following code accomplishes just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, `on` is the event handler module provided by
    dojo (`dojo/on`). The `byId()` method of the `dom` module is used to get the reference
    of the `dom` element with the ID—`queryBtn`. We are executing the preceding piece
    of code on the `click` event of `queryBtn`. Notice that in the highlighted code,
    we handle the situation when we receive no input from the query textbox. The `executeForCount()`
    method returns a deferred. When the `Deferred` object is resolved, the `.then()`
    method is used to trigger the callback. Within the `.then` method, we have defined
    two functions; the first function is fired when the operation is successful, and
    the second function is fired when the operation throws an error. We can also use
    the `execute-for-count-complete` event on the `queryTask` object to retrieve the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: The `result` object just returns the count number.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the following API documentation to get more information on the result
    object returned by this method—[https://developers.arcgis.com/javascript/jsapi/querytask-amd.html#event-execute-for-count-complete](https://developers.arcgis.com/javascript/jsapi/querytask-amd.html#event-execute-for-count-complete).
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of our operation on the map will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Querying for Count](graphics/B04959_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have also introduced the **Get Features** button in the UI to retrieve the
    actual feature records that satisfy the query condition and display them in an
    HTML table. We will be executing the `execute()` method on the `queryTask` object
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Query for Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method provides the maximum information about the features being queried.
  prefs: []
  type: TYPE_NORMAL
- en: 'A figure illustrating the Query for Features operation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Query for Features](graphics/B04959_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `execute()` method in the `QueryTask` object is used to Query for Features.
    This method returns a `Deferred` object. This success event handler returns a
    `Featureset` object. The `Featureset` object returns an array of features along
    with other ancillary information regarding the geometry type and the spatial reference
    of the features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature set contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**features**: The graphic array. Each item in the graphic array has the following
    properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**attributes**: Name value pairs of fields and field values associated with
    the graphic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**geometry**: The geometry that defines the graphic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**geometryType**: The geometry type of the features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**spatialReference**: The Spatial Reference of the features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our application, we will try to call the `execute` method on the click of
    a button, and we will construct an HTML string that will use the result called
    `FeatureSet` to display it as an HTML table. The following screenshot demonstrates
    how to iterate through the result feature set and create the HTML table string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Query for Features](graphics/B04959_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking on the **Get Features** button, the Query object that was used
    to get the count of the features is used to execute this query operation too.
    So ideally, every time we change the query text or the map extent, the **Get Features**
    button and the HTML query results will be hidden, and we need to click on the
    **Get Count** button before clicking on the **Get Features** button. We have written
    a function that hides the div that shows the feature count as well as clear the
    HTML table. The code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates our code in action on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Query for Features](graphics/B04959_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Query for Extent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we would like to know the extent of the features satisfying a query, we
    can use this method. This will help us in many ways:'
  prefs: []
  type: TYPE_NORMAL
- en: We can get an idea about the spatial extent of the phenomena
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can zoom the map to the extent of the features without actually receiving
    the features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the Query for the `Extent` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Query for Extent](graphics/B04959_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building and executing IdentifyTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IdentifyTask` can operate on multiple layers in a map service and fetch information
    from all the features intersecting with a given geometry. We will use IdentifyTask
    to click on the map and get the value of the wildfire potential at the clicked
    location. To execute `IdentifyTask`, we need to follow three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate IdentifyTask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct the Identify parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute IdentifyTask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiating IdentifyTask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instantiating IdentifyTask involves loading the required module and instantiating
    it with a map service URL. The modules required for executing `IdentifyTask` are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`esri/tasks/IdentifyTask`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`esri/tasks/IdentifyParameters`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be operating IdentifyTask on the Wildfire Potential Map service. The
    map service contains a single raster layer and pixel values representing wildfire
    potential levels. The following snippet shows how IdentifyTask is instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Constructing the identify parameters object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Identify parameters provides a lot of properties to define the identify operation
    being performed. While dealing with multiple layers, we can restrict the layers
    upon which identify can be performed by using the `layerIds` property. The `geometry`
    property lets us set the geometry that is used to select features in the map service
    upon which identify operates. In our application, we are using the map `click`
    point as the input geometry for the IdentifyParameter. When using a point geometry,
    we also need to define the value for the tolerance property in the IdentifyParameters.
    The tolerance value refers to the number of pixels around the input point geometry
    that can be considered as part of the input geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we construct an identify parameter object, which
    is wrapped around by the map `click` event handler. The `mapPoint` property of
    the map `click` event handler provides the input geometry for the identify operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing the identify parameters object](graphics/B04959_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Executing IdentifyTask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `execute()` method of IdentifyTask can be used to execute the task. The
    `execute()` method returns the `Deferred` object, and the success callback of
    the `Deferred` object returns the `IdentifyResult` array object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An identify result represents a single identified feature from one of the layers
    in the map service. The object has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`displayFieldName`: This is the name of the layer''s primary display field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`feature`: A `feature` object contains an array object and a geometry object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layerId`: This is the unique ID of the layer that contains the feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layerName`: This is the name of the layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the identify result is an array object, and we are only showing one value,
    we will be taking only the first value from the identify result object (`result[0]`),
    as shown in the following screenshot. The value that we need to show is in an
    attribute field named `CLASS_DESC`. Since this value is prefixed by a class code
    separated from the class description by a colon (`:`) (for example, `5`: Very
    High), we will be separating the string based on the colon and use the description
    part alone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the code that is used to perform the identify
    operation as well as showing the identify result as a label for the `map` click
    location, which is represented by a pointer cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing IdentifyTask](graphics/B04959_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building and executing a Find task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Find task is pretty much an attribute-based search on all the fields in a
    map service. Find task results are identical to IdentifyTask results with an extra
    value for `foundFieldName`, which indicates the field name in which the search
    text was found. Similar to Query task and IdentifyTask, the three steps to execute
    Find task are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate a Find task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build Find parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing a Find task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's discuss these three steps one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating a Find task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform a Find task, the following modules need to be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '`esri/tasks/FindTask`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`esri/tasks/FindParameters`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to provide the URL of a map service to instantiate a Find task. The
    following snippet shows how we will do this in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Building the Find parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To construct the Find parameters, we need to use the `esri/task/FindParameters`
    module. The Find parameter module has properties such as `searchText`, `layerIds`,
    and `seachFields`, which let us define the Find task. The `searchText` property
    is the text that needs to be searched. This needs to come from a UI textbox. `layerIds`
    lets us define the `layerIds` upon which the Find task should operate. We can
    also restrict the fields upon which the search is performed. The following screenshot
    shows how we built the UI for the Find task and constructed the Find parameter
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Find parameters](graphics/B04959_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Executing a Find task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `execute()` method of `Find` task can be used to execute it. Calling this
    method will return a `Deferred` object, which will return a Find results object
    in its success callback function. We will try to build an HTML table, as we did
    for the Query task result, and display it in `FindTbl div`. The following lines
    of code were used to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see that the search text has fetched that
    from two different fields, **Fire Name** and **State** when we inserted the search
    text `W`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing a Find task](graphics/B04959_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building a feature table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A feature table constructs a table, displays all the information of a given
    feature layer, and places it in a given `dom` element. A feature table is an Esri
    widget can be used by loading the `esri/dijit/FeatureTable` module. The module
    lets us choose the fields to display. The following screenshot shows how a feature
    table should be constructed and how it appears in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a feature table](graphics/B04959_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building popups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When users of your web application click on a feature of interest, they should
    be shown a bundle of useful information about the feature that they clicked on.
    Popups are the medium through which context-specific attribute information is
    shown to users. Popups complement the map's spatial information.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest popups just show all or selected attribute values. More advanced
    and intuitive popups make use of charts and images in the pop-up window.
  prefs: []
  type: TYPE_NORMAL
- en: The modules that help to create popups are `esri/InfoTemplate`, `esri/dijit/PopupTemplate`,
    `esri/dijit/InfoWindow`, and `esri/dijit/Popup`.
  prefs: []
  type: TYPE_NORMAL
- en: '`esri/dijit/PopupTemplate` extends `esri/InfoTemplate`, and `esri/dijit/Popup`
    extends `esri/dijit/InfoWindow`. So, let''s deal with `InfoTemplate` briefly and
    move on to the `Popup` templates.'
  prefs: []
  type: TYPE_NORMAL
- en: Building InfoTemplates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `InfoTemplate` object can be created using placeholders. A placeholder is
    usually the attribute field name, starting off with a dollar (`$`) sign and surrounded
    by curly braces (`{}`), for example, `${Fieldname}`.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to retrieve all the fields provided by the feature of interest,
    the fieldname can be substituted by `*`, for example, `${*}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature layers and Graphics object have the `InfoTemplate` property. `infotemplate`
    created could be set to these layers. The `InfoTemplate` constructor takes two
    arguments, title and content:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Modules | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Module name | `esri/InfoTemplate` |'
  prefs: []
  type: TYPE_TB
- en: '| Parent object | Feature layer, Graphic object, dynamic layer, and the Info
    window of the map |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor | `new InfoTemplate (title, content)` |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot creates `infotemplate` for the `Active wildfire` feature
    layer, and it displays fields such as state name, fire name, and the areal extent
    of the wildfire feature being clicked in a popup. The title of `Infotemplate`
    is also created by the placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building InfoTemplates](graphics/B04959_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code listings for this chapter can be found in the code folder named `B04959_03_CODE`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained the different methods for searching and querying data.
    We built an application that could perform a Query task, a Find task, as well
    as Identify task. We also discovered the utility of the feature table called `dijit`
    along with `Infotemplates`. In the next chapter, we will see how to organize all
    the code into modularized widgets and use it in our application. We will also
    be discussing how to construct spatial queries that involve using the draw toolbar,
    and we will create input geometries that are defined by the user of the app.
  prefs: []
  type: TYPE_NORMAL
