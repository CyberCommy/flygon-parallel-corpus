- en: Chapter 10. Logging On and Maintaining Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most creative part of the enterprise application lifecycle revolves around
    the user interface design. Your goal as an enterprise application developer is
    to create a user interface that is intuitive, consistent, and easy to use. User
    interface design requires a thorough understanding of the tools you have available.
    Thankfully, Ext JS 4 has a comprehensive range of widgets that cover the core
    functionality required for any enterprise application. If you have not already
    visited the examples page, then take some time now to become familiar with the
    full range of Ext JS 4 components at [http://docs.sencha.com/extjs/4.2.2/#!/example](http://docs.sencha.com/extjs/4.2.2/#!/example).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will focus on building the logon and user administration interfaces.
    We will develop a set of view components and wire them together with controllers
    to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Log on to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the main application viewport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a user maintenance interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user maintenance interface will introduce model persistence and validation
    properties that are used for CRUD operations. We have quite a bit to do, so let's
    start by examining the application layouts and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts, screens, and workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application starts by displaying the logon window. Without a successful
    logon you will be unable to reach the main application viewport. The logon window
    has a very simple design as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts, screens, and workflows](img/5457_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A successful logon will be displayed on the welcome screen as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts, screens, and workflows](img/5457_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The welcome screen has a number of buttons in the header dependent on your permissions.
    A normal user will only see the **Task Logs** button and the **Logoff** button.
    An admin user will see the additional **3T Admin** and **Users** buttons. We will
    leave the **3T Admin** and **Task Log** modules for the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user administration interface is based on the most common design pattern
    in modern enterprise applications. This layout displays a list of users in the
    left-hand side panel and the user details in the right-hand side panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts, screens, and workflows](img/5457_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each of these screen designs has icons and a logo that are not part of the Ext
    JS framework. The code in the following sections will define the appropriate styles
    but you will need to include the required resources to achieve the same look and
    feel. The full source code including resources can be downloaded from this book's
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Defining view components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the hardest decisions to make when implementing wireframes and UI mockups
    is how to split up the view. Consider our user maintenance screen as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining view components](img/5457_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'How many separate views should we create? If we create too many views, they
    become difficult to manage. If there are too few views, we lose flexibility. Striking
    the right balance comes only with experience. We tend to encourage a middle-road
    approach based on logical regions within the layout itself. The previous design,
    for example, could be split into the following view components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining view components](img/5457_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the structure we will be implementing. However, we could easily implement
    the following design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining view components](img/5457_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The second version would use a single view to encapsulate the user grid, form,
    and toolbar. The resulting `ManageUsers.js` file would be approximately 200 lines
    long; not a large file by any stretch of the imagination. From a functional perspective
    there would be no difference between the two designs. However, the first approach
    gives us more flexibility. We can easily rearrange the views on the page or refactor
    the interface without much effort (for example, moving `UserForm` to a pop-up
    window and allowing the user list to fill the entire width of the screen). This
    would not be as easy with the second design version.
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, you should err on the side of simplicity. Complex views with
    many hundreds or even thousands of lines of code should be avoided at all costs.
    Think of your views as discrete objects with specific purposes and keep them simple.
  prefs: []
  type: TYPE_NORMAL
- en: Building our views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some practical guidelines to building views, it is time to
    create our application interface. A user must be able to log on successfully to
    work with the application, so let's start with the logon window.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Logon window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Task Time Tracker Logon** window is the first thing a user will see,
    which is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the Logon window](img/5457_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The logon window definition follows the given code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This window definition extends the `Ext.window.Window` and adds the two text
    fields and logon button. The `LogonWindow` class is namespaced to `view` and will
    hence reside in the `app/view` directory. The defined `xtype` property is the
    lowercase version of the class name and will be used in the controller to reference
    the `LogonWindow` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `xtype` property is a symbolic name (alias or shortcut) for a class. The
    xtype property is a powerful concept in Ext JS that allows components to be configured,
    but not rendered, until the owning container deems it necessary. A full explanation
    of components' lazy initialization by `xtype` can be found here [http://docs.sencha.com/extjs/4.2.2/#!/guide/components](http://docs.sencha.com/extjs/4.2.2/#!/guide/components).
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern encourages Ext JS 4 developers to implement business
    logic in the controller layer, leaving the views as dumb objects. The only meta
    logic we are applying in this window is the `allowBlank:false` property combined
    with `validateOnBlur:true`. This will give the user a visual clue if moving off
    the field without entering text.
  prefs: []
  type: TYPE_NORMAL
- en: Using the initComponent() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `initComponent` function is a template function that is invoked by the
    constructor during object creation. The template design pattern allows subclasses
    to define specific behavior without changing the semantics of the base class processing
    algorithm. A detailed explanation of this pattern can be found here: [http://en.wikipedia.org/wiki/Template_method_design_pattern](http://en.wikipedia.org/wiki/Template_method_design_pattern).
    Ext JS uses the template design pattern to allow developers to specify logic during
    certain well-defined phases in the component''s lifecycle. The `initComponent`
    function is probably the most used but there are many other template hooks that
    can be implemented. A full list of component template functions can be found here:
    [http://docs.sencha.com/extjs/4.2.2/#!/guide/components](http://docs.sencha.com/extjs/4.2.2/#!/guide/components).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `initComponent` function is used to initialize data, set up configurations,
    and attach event handlers to the component. The recommended usage pattern for
    this function (or any template function) includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference the current scope as a local closured variable using `var me = this`.
    Use the `me` reference everywhere in the function when referring to the object
    instance. This will help with correct JavaScript closure for complex objects by
    ensuring `me` and `this` refer to the correct object scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Ext.applyIf` to add class-specific properties to the configuration. Note
    that we are not using `Ext.apply`, which will override properties that are already
    defined; only new properties that do not exist in `me` will be copied. This ensures
    that xtype-based configuration properties take precedence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete the `initComponent` function by calling the parent function with the
    supplied arguments using `me.callParent(arguments)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three points outline some advanced concepts that may be a bit beyond the
    intermediate reader. Don't despair if some of this doesn't make sense yet; follow
    the design pattern and things will become clearer with experience!
  prefs: []
  type: TYPE_NORMAL
- en: Defining the viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Viewport` view uses a `vbox` layout to split the view into two regions,
    the header and the main content areas, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the viewport](img/5457_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could have used a `border` layout to achieve the same visual result but the
    `vbox` layout is a lighter weight component. Only use the `border` layout if your
    application needs additional functionality such as expandable/collapsible regions
    or resizable split views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Viewport` definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two views that now need to be defined: one for the main header, the
    second for the main region card layout.'
  prefs: []
  type: TYPE_NORMAL
- en: The MainHeader.js view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `MainHeader` defines and positions the 3T logo and buttons as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each button defines an `itemId` property to help uniquely identify the button
    when using selectors in the controller. The two administrative buttons use the
    `hidden` property to hide the button if the user is not an administrator. The
    `TTT.getApplication().isAdmin()` function has not been defined as yet but this
    will be added to the `Application.js` function in the section ahead.
  prefs: []
  type: TYPE_NORMAL
- en: The MainCards.js file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `MainCards` component is a card layout container that holds all the components
    that will be rendered in the main content area as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will be adding items to the `MainCards` as we build our functionality. For
    this chapter we will focus on the `Welcome` and `ManageUsers` components.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Welcome panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Welcome` panel uses an `XTemplate` to render a simple welcome message based
    on the logged-on user. The user data is retrieved from the application using the
    `TTT.getApplication().getUser()` function that will be added to the `Application.js`
    function after a successful logon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Defining the user management components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The user management interface consists of three view files as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the user management components](img/5457_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the views we will also need to define a user store that manages
    the data displayed in the user listing.
  prefs: []
  type: TYPE_NORMAL
- en: The ManageUsers.js file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ManageUsers` file is a simple `hbox` layout that displays the `UserList`
    and `UserForm`. The toolbar contains the single **Add User** button. This file
    has a very simple definition, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The UserForm.js file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This `UserForm.js` file displays the user details as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each button has an `itemId` property defined to allow us to uniquely identify
    them in the controller. Each field name in the form exactly matches the field
    name in the `User` model defined in the previous chapter. This will allow us to
    easily load a user model instance into the form.
  prefs: []
  type: TYPE_NORMAL
- en: The UserList.js file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `UserList` file is a grid panel with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The grid columns use the `flex` config property to define the relative width
    of each column. The `email` column will hence be twice the width of the other
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `markDirty:false` in the `viewConfig` is used to remove the dirty cell
    indicator when a cell value is modified. Without this property the grid would
    render changed cell values as shown, even after the record has been successfully
    saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The UserList.js file](img/5457_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `User` store is yet to be defined, so let's add it now.
  prefs: []
  type: TYPE_NORMAL
- en: The User store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `User` store loads users from the `ttt/user/findAll.json` URL. which is
    mapped to the `UserHandler.findAll` method. Readers should recall that the `ttt/
    prefix` URL corresponds to the servlet mapping specified in the `com.gieman.tttracker.web.WebApp.getServletMappings()`
    method in [Chapter 7](ch07.html "Chapter 7. The Web Request Handling Layer"),
    *The Web Request Handling Layer*. Each user record in the JSON array will result
    in the creation of a `TTT.model.User` model instance. The store definition is
    explained in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` model was defined in the previous chapter and currently looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Ext JS 4 models are a key part of the MVC framework and we will now spend some
    time learning about these important objects.
  prefs: []
  type: TYPE_NORMAL
- en: Models and persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ext JS 4 models are similar to JPA entities in that they define data fields
    that represent columns in the underlying database tables. Each model instance
    represents a row in the table. The primary key field is defined using the `idProperty`
    of the model, which must match one of the field names. The `User` model can now
    be updated as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Defining the proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each model can be made persistent aware by configuring an appropriate proxy.
    All loading and saving of data is then handled by the proxy when the `load`, `save`,
    or `destroy` method on the model is called. There are several different types
    of proxies but the most widely used is the `Ext.data.ajax.Proxy` (alternate name
    `Ext.data.AjaxProxy`). The `AjaxProxy` uses AJAX requests to read and write data
    from the server. Requests are sent as `GET` or `POST` methods depending on the
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: A second useful proxy is `Ajax.data.RestProxy`. The `RestProxy` is a specialization
    of the `AjaxProxy` that maps the four `CRUD` actions to the appropriate RESTful
    HTTP methods (`GET`, `POST`, `PUT`, and `DELETE`). The `RestProxy` would be used
    when connecting to RESTful web services. Our application will use `AjaxProxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `User` model definition including proxy follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The proxy is defined as type `ajax` and specifies the primary key field in
    the model with the `idParam` property. The `idParam` is used when generating the
    URL for the `read` operation. For example, if trying to load the user record with
    username `bjones`, the proxy would generate a URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ttt/user/find.json?username=bjones`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `idParam` property was omitted, the URL generated would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ttt/user/find.json?id=bjones`'
  prefs: []
  type: TYPE_NORMAL
- en: The `api` properties define the URLs to call on CRUD action methods. Each URL
    maps to an appropriate handler method in `UserHandler`. Note that the `update`
    and `create` URLs are the same as both actions are handled by the `UserHandler.store`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `AjaxProxy` read operation uses a `GET` request
    while all other operations use `POST` requests. This is different from the `RestProxy`
    method, which uses a different request method for each operation.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing AJAX and REST proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our request handling layer has been designed to consume AJAX requests in a format
    submitted by Ext JS 4 clients. Each handler that processes an update action is
    configured with `RequestMethod.POST` and expects a `data` parameter that holds
    the JSON object applicable to the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have implemented the request handling layer as a RESTful API where
    each method is mapped to an appropriate request method type (`GET`, `POST`, `PUT`,
    or `DELETE`). Implementing a delete action would then encode the `id` of the item
    in the URL of a `DELETE` submitted request. Deleting the `bjones` user, for example,
    could be achieved by submitting a DELETE request method URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user/bjones`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UserHandler.remove` method could then be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `@PathVariable` extracts the `username` (in our sample URL this is `bjones`)
    from the URL, which is then used in the call to the `userService.remove` method.
    The `@RequestMapping method` of `RequestMethod.DELETE` ensures the method is only
    executed when a DELETE request matching the URL path of `/user/{username}` is
    submitted.
  prefs: []
  type: TYPE_NORMAL
- en: The RESTful API is a specific style of using HTTP that encodes the item you
    want to retrieve or manipulate in the URL itself (via its ID) and encodes what
    action you want to perform on it in the HTTP method used (`GET` for retrieving,
    `POST` for changing, `PUT` for creating, `DELETE` for deleting). The `Rest` proxy
    in Ext JS is a specialization of the `AjaxProxy` that simply maps the four CRUD
    actions to their RESTful HTTP equivalent method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no significant difference in implementing either the AJAX or REST
    alternative in Ext JS 4\. Configuring the proxy with `type:''ajax''` or `type:''rest''`
    is all that is required. The request handling layer, however, would need to be
    implemented in a very different way to process the `@PathVariable` parameters.
    We prefer the AJAX implementation for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: REST has traditionally been used for server-to-server communication, most notably
    in web services, and not for browser-server interactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URLs for CRUD AJAX requests are unique and become self-documenting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 3T application is not a web service and is based on HTML 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML 5 specification no longer supports `PUT` and `DELETE` as HTTP methods
    for `form` elements (see [http://www.w3.org/TR/2010/WD-html5-diff-20101019/#changes-2010-06-24](http://www.w3.org/TR/2010/WD-html5-diff-20101019/#changes-2010-06-24)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST is not a flexible solution and is usually based around atomic actions (one
    item processed per request). AJAX and Ext JS combine to allow more complex interactions
    with bulk updating possible (many updates in a single request are possible for
    all create, update, and destroy URLs. This will be explained later in the *Defining
    the writer* section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` and `DELETE` requests are often considered a security risk (in addition
    to `OPTIONS`, `TRACE`, and `CONNECT` methods) and are often disabled in enterprise
    web application environments. Applications that specifically require these methods
    (for example, web services) usually expose these URLs to a limited number of trusted
    users under secure conditions (usually with SSL certificates).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no definitive or compelling reason to use AJAX over REST or vice versa.
    In fact the online discussions around when to use REST over AJAX are quite extensive,
    and often very confusing. We have chosen what we believe to be is the simplest
    and most flexible implementation by using AJAX without the need for REST.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `reader` with type `json` instantiates a `Ext.data.reader.Json` instance
    to decode the server''s response to an operation. It reads the JSON `data` node
    (identified by the `root` property of the reader) and populates the field values
    in the model. Executing a read operation for the `User` model using `ttt/user/find.json?username=bjones`
    will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The reader will then parse the JSON file and set the corresponding field values
    on the model.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the writer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `writer` with type `json` instantiates an `Ext.data.writer.Json` instance
    to encode any request sent to the server in the JSON format. The `encode:true`
    property combines with the `root` property to define the HTTP request parameter
    that holds the JSON data. This combination ensures that a single request parameter
    with name `data` will hold the JSON representation of the model. For example,
    saving the previous `bjones` user record will result in a request being submitted
    with one parameter named `data` holding the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be noted that this representation is formatted for readability; the
    actual data will be a string of characters on one line. This representation is
    then parsed into a `JsonObject` in the `UserHandler.store` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The appropriate `jsonObject` values are then extracted as required.
  prefs: []
  type: TYPE_NORMAL
- en: The `writeAllFields` property will ensure that all fields in the model are sent
    in the request, not just the modified fields. Our handler methods require all
    model fields to be present. However, note that we have added the `persist:false`
    property to the `fullName` field. This field is not required as it is not a persistent
    field in the `User` domain object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final `writer` property that needs explanation is `allowSingle:true`. This
    is the default value and ensures a single record is sent without a wrapping array.
    If your application performs bulk updates (multiple records are sent in the same
    single request) then you will need to set this property to `false`. This would
    result in single records being sent within an array, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The 3T application does not implement bulk updates and always expects a single
    JSON record to be sent in each request.
  prefs: []
  type: TYPE_NORMAL
- en: Defining validations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each model has built-in support for validating field data. The core validation
    functions include checks for `presence`, `length`, `inclusion`, `exclusion`, `format`
    (using regular expressions), and `email`. A model instance can be validated by
    calling the `validate` function, which returns an `Ext.data.Errors` object. The
    `errors` object can then be tested to see if there are any validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `User` model validations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `presence` validation ensures that a value is present for the field. The
    `length` validation checks for field size. Our validations require a minimum `password`
    size of six characters and a minimum `username` of four characters. First and
    last names have a minimum size of two characters. The `inclusion` validation tests
    to ensure the field value is one of the entries in the defined list. As a result,
    our `adminRole` value must be either a `Y` or `N`. The `email` validation ensures
    the e-mail field has a valid e-mail format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code listing for our `User` model can now be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the Logon and Viewport actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to define the `MainController` that will be used to process
    the core application actions. These include logging on, logging off, and clicking
    on the header buttons to display the different management panels in the main content
    area.
  prefs: []
  type: TYPE_NORMAL
- en: The MainController.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MainController.js` definition is as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainController` is responsible for managing three views as defined in
    the views configuration array: `MainHeader`, `MainCards`, and `LogonWindow`. Each
    `ref` defines a component that is needed by the controller to perform an action.
    The `ref` value is used during initialization of the controller to automatically
    create a `getter` function that can be used to access the component. In our `MainController`
    the ref value `mainCards` will result in a `getMainCards` function being created.
    This function is used in the `doHeaderButtonClick` function to access the `MainCards`
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of a function should identify the core purpose of the code it defines.
    We will prefix all functions that perform actions with `do`. In our example, it
    should be clear to any developer what the purpose of the `doHeaderButtonClick`
    function is.
  prefs: []
  type: TYPE_NORMAL
- en: The `MainController.init()` function calls the `control()` function to configure
    event handling in the views. The `control()` function is a convenient method to
    assign a set of event listeners in one action. The `mainheader` button selector
    configures the `click` event on all button objects in the `MainHeader`. Whenever
    a button in the header is clicked the `doHeaderButtonClick` function is called.
    This function will then determine which button has been clicked by examining the
    `itemId` of the `button` argument. The appropriate card in the `MainCards` is
    then activated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note we have added code to display the `manageTasksCard` and `taskLogCard` even
    though they are not currently available. These user interfaces will be developed
    in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `logonwindow` button selector configures the `click` event on the **Logon**
    button of the `LogonWindow`. The `doLogon` function is called when the button
    is clicked to trigger the logon process. This function validates the `username`
    and `password` fields and, if both are valid, submits an AJAX request to authenticate
    the user. A successful logon will then call the `TTT.getApplication().doAfterLogon()`
    function passing the user JSON data as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `doLogoff` function is triggered when the user clicks on the **Logout**
    button in the header. A prompt is presented to the user and if confirmed the `logout`
    action is processed. This will clear the session in the backend before reloading
    the browser window and presenting the user with the `LogonWindow` once again.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling our user views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The glue that links the three user views together is the `UserController`.
    It is here that we place all logic for managing user maintenance. You have seen
    that each view defined earlier is dumb in that there is only presentation logic
    defined. Actions, validations, and selections are all handled within the `UserController`
    and are explained in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserController` is defined with a single view to manage users as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to define a set of references using the component query language
    starting with the `manageusers` root selector. We can hence reference the save
    button on the `UserForm` by the selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `#saveBtn` refers to the component with `itemId saveBtn` on the `userform`
    within the `manageusers` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only define references that are used by the controller to process business logic.
    Do not create a reference for components that are never accessed within your code.
    Keep your code simple and clean!
  prefs: []
  type: TYPE_NORMAL
- en: The `init` function defines the listeners that should be processed in the interface.
    Each button click is matched to an appropriate `handler` function. The user list
    `itemclick` event is handled by the `doSelectUser` function. The `viewready` event
    on the `userlist` triggers the initial load of the grid's store. Each listener
    event is handled by a single function with a clear purpose. Let's now examine
    the core functions in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The doAddUser function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `doAddUser` function is called when the **Add User** button is clicked.
    We set the title on the form `fieldset` to display **Add New User** and then enable
    the `username` field as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We only enable the `username` field when adding a new user; the `username`
    field is not editable for existing users as it represents the primary key. We
    then create a new User model and load the record into the user form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage the user form would look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The doAddUser function](img/5457_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Delete** button serves no useful purpose for adding a new user and hence
    we disable it as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following **Add New User** interface as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The doAddUser function](img/5457_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could just as easily have hidden the delete button instead of disabling it;
    your approach will depend on your client specifications.
  prefs: []
  type: TYPE_NORMAL
- en: The form is now ready for entering a new user.
  prefs: []
  type: TYPE_NORMAL
- en: The doSelectUser function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `doSelectUser` function handles the `itemclick` event on the `userlist`
    grid panel. The arguments to this function are the grid itself and the selected
    record. This makes loading the form with the selected user record a simple task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fieldset` title is changed to reflect the user being edited and the `username`
    field is disabled. We also ensure the **Delete** button is enabled as we require
    the option to delete an existing record. Clicking on the **Betty Jones** record
    in the user list would then display the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The doSelectUser function](img/5457_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Readers will note that the **Password** field is empty. This means that saving
    a user record via the form will require a password to be set. The backend handler
    method and service layer also require a valid password when saving a user. In
    the real world this would not be the case; you do not want an administrator changing
    the password every time they save user details! A **Change Password** form, perhaps
    in a pop-up window, would normally trigger a separate AJAX request to change the
    user's password.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to code the **Save** button action.
  prefs: []
  type: TYPE_NORMAL
- en: The doSaveUser function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `doSaveUser` function processes the saving of a user record. In most applications
    the `save` function will contain the most code as validations and user feedback
    are important steps in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to retrieve the user record instance that was loaded in the
    form as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If valid, the record is updated with the values entered in the form text fields
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage the user record will be in sync with the fields entered in the
    form. This means all fields in the form will have been copied to the model instance.
    We can now validate the user record as given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no validation errors, the record is saved using the `save()` function
    on the record itself. There are two possible callbacks depending on the returned
    JSON response. A successful save will trigger the success handler as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `success` callback will check if the record exists in the store. If not,
    the record is added to the `User` store and selected in the user list. The **Delete**
    button will then be enabled and the `fieldset` title set appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `failure` action will simply inform the user of the cause as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are errors encountered during validation, we mark the invalid fields
    and display a generic error message as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to save a user record without a valid e-mail or password would then
    display a message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The doSaveUser function](img/5457_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The doDeleteUser function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final handler processes the delete action. The `doDeleteUser` function
    prompts the user for confirmation before triggering the `destroy` function on
    the record if required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` store will automatically remove the successfully destroyed user
    model from the store itself. Any failure will inform the user of the reason. Attempting
    to delete the record for **John Smith** will result in the message shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The doDeleteUser function](img/5457_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Where is this message coming from? It is generated in the service layer `UserServiceImpl.remove`
    method that was coded when implementing the business logic for the delete action.
    What about trying to delete the currently logged-on user? This will result in
    the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The doDeleteUser function](img/5457_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once again this is coming from the service layer business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Let's log on!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is now time to enable our controllers and test the functionality. Update
    the `Application.js` file as displayed in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `Application.js` represents the entire application and defines all components
    bundled in the application (models, stores, and controllers). Note that views
    are not listed here as they are managed by the controllers directly.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined a `requires` array containing the `TTT.view.LogonWindow` and
    `TTT.view.Viewport` classes. Although this is strictly not essential, as these
    definitions also reside in the appropriate controllers, it is considered best
    practice to always include `requires` entries for all `Ext.create()` function
    calls in the class. We create both the `TTT.view.LogonWindow` and `TTT.view.Viewport`
    using `Ext.create()`, so have included these in the `requires` list.
  prefs: []
  type: TYPE_NORMAL
- en: Our `controllers` array contains the `MainController` and `UserController` as
    expected. We have also added the `User` model as this is the only model we currently
    need. Likewise the `User` store has been added to the `stores` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init` function is a template method that is called when the application
    boots. We have added code to the `Ext.Ajax beforerequest` event to prefix all
    URLs with the servlet path configured in the `com.gieman.tttracker.web.WebApp.getServletMappings()`
    method; this is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ttt/` prefix is added to each `Ext.Ajax` request URL to ensure the correct
    mapping to the request handling layer. Without this `beforerequest` event code
    each URL would need to be prefixed with `ttt` as we have already coded in the
    `User` model `api`, the `User` store URL, and the `Ajax.request` URLs for logon
    actions in the `MainController`. We can now omit the `ttt/` prefix in all URLs
    that access servlet resources. The `User` model `api` can now be changed to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In a similar way we can now remove the `ttt/` prefix from the `User` store and
    `MainController.doLogon/Logoff` URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This technique of using the `beforerequest` event to prefix all Ajax URLs may
    only be used for simple projects that consume resources from a single mapped servlet.
    If multiple mappings are used, a different strategy would need to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The `launch` function is another template method called when the page is ready
    and all JavaScript has been loaded. The `TTT.console` function defines a lightweight
    logger that sends the output to the browser console, if available. It is not a
    replacement for the `Ext.log()` function but is simpler to use. We encourage you
    to use the `TTT.console` function liberally to analyze your code and debug processing.
  prefs: []
  type: TYPE_NORMAL
- en: The final step in the `launch` function creates and assigns the `LogonWindow`
    instance to the application scoped variable `logonWindow`. This will display the
    logon window when the application is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doAfterLogon` function is used to postprocess the successful logon and
    initialises the application environment. The `doAfterLogon` argument is the JSON
    data object returned after a successful logon and has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This function will create two helper functions that can be called by any component
    to retrieve user details and to test if the user is an administrator. An example
    of calling these functions in code has already been shown in the `MainHeader.js`.
    The `TTT` namespace is used to access the application functions via `TTT.getApplication().isAdmin()`
    and `TTT.getApplication().getUser()`.
  prefs: []
  type: TYPE_NORMAL
- en: The final step in the `doAfterLogon` process is to create the application viewport
    and hide the logon window. We will be calling the `doAfterLogon` function, strangely
    enough, after we have successfully logged on!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and test the logon screen with username `bjones` and password
    `admin`. You should see the interface with all header buttons enabled, as **Betty
    Jones** is an admin user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s log on!](img/5457_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Test the logon screen with username `jsmith` and password `admin`. You should
    see the interface without the admin buttons, as **John Smith** is a normal user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s log on!](img/5457_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Try clicking on the **Logoff** button. You should be prompted with a confirmation
    window as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s log on!](img/5457_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the **Yes** option will trigger the `MainController.doLogoff` function
    to log out the user and reload the browser to display the `LogonWindow` again.
  prefs: []
  type: TYPE_NORMAL
- en: Let's maintain users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Log on as the **bjones** user and click on the **Users** button. The following
    screen will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s maintain users](img/5457_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the letter `A` in all fields and click the **Save** button. The **Invalid
    Fields** message will then be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s maintain users](img/5457_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter valid entries (remembering the validation rules!) and click the **Save**
    button. The new user record should then be added to the user list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s maintain users](img/5457_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now try to delete and update users to test the different functions
    you have written. There is a lot of activity hidden from view when you are performing
    such tests. You can open the JavaScript console appropriate for your browser (Safari
    Web Inspector, Firefox Firebug, Chrome Developer Tools, or the generic Fiddler
    [http://fiddler2.com/get-fiddler](http://fiddler2.com/get-fiddler)) to inspect
    the requests being sent. Try logging on again as `bjones`, clicking on the **Users**
    button, adding a new user, and then deleting this new user. You will see the following
    requests being sent to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s maintain users](img/5457_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Liberal use of `TTT.console()` in your functions will also help in debugging
    properties and application state. Adding the statement `TTT.console(userObj);`
    to the first line of the `Application.js doAfterLogon(userObj)` function will
    output the following to the console after a successful logon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s maintain users](img/5457_10_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Take your time to test and experiment with the different functions you have
    written. We have covered a lot of concepts in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced Ext JS 4 view and controller concepts, building
    the logon window, and user maintenance interfaces. We have also introduced key
    model concepts including persistence and validations. The pieces of the puzzle
    have finally fallen into place, with our frontend actions interacting with backend
    business logic. [Chapter 11](ch11.html "Chapter 11. Building the Task Log User
    Interface"), *Building the Task Log User Interface*, will continue to enhance
    our understanding of Ext JS 4 components as we implement the Task Log user interface.
  prefs: []
  type: TYPE_NORMAL
