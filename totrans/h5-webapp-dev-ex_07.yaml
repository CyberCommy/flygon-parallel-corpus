- en: Chapter 7. Piano Hero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"One good thing about music, when it hits you, you feel no pain."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: – Bob Marley
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In this chapter we will turn the piano application from the previous chapter
    into a game where the player must play the notes of a song at the correct time
    as they fall down the screen. We will create a splash page that keeps track of
    image loading and allows the player to choose game options. We will create an
    audio sequencer to play the songs from music data. During the game we will collect
    piano keyboard input and validate it to determine the player''s score.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use an HTML5 progress bar element to track the loading of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use JavaScript timers to control playback of audio to play songs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to animate DOM elements to move them around the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to transition between game states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get user input and verify it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Piano Hero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Piano Hero game will start with the HTML5 piano application we built in
    the previous chapter. We will add an audio sequencer to it to play prerecorded
    songs. To score points, the player will need to follow along and play the notes
    of the song at the correct time. There will also be a practice mode that just
    plays the song so the player can hear it.
  prefs: []
  type: TYPE_NORMAL
- en: Our game will have two different main panels. The first will be the splash panel,
    which is the starting point of the game. When the application first starts, it
    will display a progress bar as the audio loads. When loading is complete, it will
    show the options for playing the game. When the player clicks on the play button
    they will transition to the game panel.
  prefs: []
  type: TYPE_NORMAL
- en: The game panel contains the piano keyboard and an area that shows the notes
    to play dropping down from above it. If the user plays the correct note at the
    correct time, they get points. At the end of the song, the player's score and
    some statistics are displayed. When the game is done, the application will transition
    back to the splash panel where the user can select options and play again.
  prefs: []
  type: TYPE_NORMAL
- en: It's often helpful to draw a flowchart that shows how the game transitions from
    one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Piano Hero](img/5947OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – creating the splash panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by copying the piano application that we created in the previous
    chapter, and renaming the files to `pinaoHero.html`, `pianoHero.js`, and `pianoHero.css`.
    We will also rename the main application object to `PianoHeroApp`. You can find
    the code for this section in `Chapter 7/example7.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the splash panel. First we''ll define the HTML in `pianoHero.html`.
    We will add a new `<div>` element above the keyboard element to hold the splash
    panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First we add a section with a class of `"loading"` that displays the status
    of loading the audio when the application first starts up. Notice that we are
    using the new HTML5 `<progress>` element. This element is used to implement a
    progress bar in your application. It has a `max` attribute that defines the maximum
    value, and a `value` attribute to set the current value. Since we are showing
    percent complete we set the `max` to `100`. We will update the `value` attribute
    from JavaScript as audio files are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we add a section with a class of `"error"` that will show an error message
    if there is an error loading the audio. Otherwise it will be hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add a section that shows the game options and buttons. This panel
    is shown after all audio has been loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here the user selects the song and difficulty from the drop-down lists. The
    difficulty is expressed in terms of the rate of speed that the song plays. A value
    of one is the default speed of 120 beats per minute. A value less than one is
    slower, and more than one is faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to style the splash panel. Please see the source code for all of
    the styles. The one noteworthy piece of styling is for the **PIANO HERO** title,
    which we placed inside an `<h1>` header element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the color for the text to dark blue. Then we use `text-shadow` to produce
    an interesting block text effect. When using `text-shadow,` you may specify any
    number of shadows separated by commas. The shadows will be drawn in order from
    last to first. So in this case, we first draw a dark blue shadow with an offset
    of 5 pixels, then a white shadow with an offset of 3 pixels, and finally the dark
    blue text will be drawn on top of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating the splash panel](img/5947OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s create a new JavaScript file named `splashPanel.js`, and define
    a new object called `SplashPanel` in it that will contain all of the code to control
    the splash panel. The constructor will take one parameter, a reference to `audioManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a `$div` object to hold a reference to the splash panel''s root `<div>`
    element, and an `error` variable to set if there was an error loading the audio.
    Next we define the public `show()` and `hide()` methods. These will be called
    by the main application object to show or hide the panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will move the `loadAudio()` method from `PianoHeroApp` to `SplashPanel`.
    In this method we need to make a couple of minor changes to the call to `audioManager.getAudio()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our function that gets called each time an audio file is loaded, we first
    check if there was an error, and if so get it out. Then we check if all of the
    audio files have been loaded (`loaded == count`), and if so call the `showOptions()`
    method. Otherwise we call the `updateProgress()` method to update the progress
    bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `updateProgress()` method takes the loaded count and total count as parameters.
    We compute the percent complete and use that to update the value of the `<progress>`
    element. We also set the inner text of the `<progress>` element. This will only
    show for browsers that don't support the `<progress>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `showOptions()` method is called after all audio has been loaded. First
    we hide the element with the `"loading"` class, and then fade in the element with
    the `"options"` class. This hides the progress section and shows the section that
    contains the game options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our error handler function calls `showError()`, passing it the audio element
    that failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `showError()` method we set the `error` flag to `true` so we know not
    to continue in the `getAudio()` call. First we hide the loading section, then
    we append the name of the file that failed to the error message, and show the
    error section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need in our splash panel is to hook up event handlers to
    the buttons. There are two buttons, **Start Game** and **Play Song**. The only
    difference between them is that the **Play Song** button plays the song without
    scoring, so the user can hear the song and practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the same event handler for both buttons. First we get the options that
    the user selected, including the song and playback rate. You can find the selected
    `<option>` element in jQuery using the `:selected` selector. We determine which
    button the user pressed by looking at the button's `id` attribute. Then we call
    the `startGame()` method on the global `app` object passing in the selected options.
    We will write that method later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating the splash panel](img/5947OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a splash panel that shows the loading progress of the audio files
    using an HTML5 `<progress>` element. When it is finished it shows the game options,
    and then waits for the user to select options and start the game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the game panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we will create is the game panel. We already have the piano
    keyboard, which will be part of it. We also need an area above it to show the
    notes dropping down, and a place to show the results when the game has finished.
    Let''s add these to our HTML file inside the `game` element and above the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `<div id="notes-panel">` element will be used to hold the elements that
    represent the notes to play. It is empty for now. The `note` elements will be
    added dynamically to this element while the game is playing. It has a `<div>`
    element with the title in it that will show up behind the notes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `<div id="results-panel">` element will be shown when the game is completed.
    We add the `<span>` placeholders to show a score, the total number of notes along
    with the number of correct ones, and some accuracy statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We also added some buttons to the `<div class="controls">` element below the
    keyboard. The **Stop** button will stop the game, **Restart** will start the current
    song over from the beginning, and **Quit** will take the player back to the splash
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a `GamePanel` object in a file named `gamePanel.js` to contain
    all of the code needed to implement the game. The constructor will take a reference
    to the `audioManager` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a few variables to keep track of the game state. The `practiceMode`
    variable determines if we are playing the game or practicing. `noteCount`, `notesCorrect`
    and `score` are used to keep track of how the player is doing.
  prefs: []
  type: TYPE_NORMAL
- en: We move all of the code to support the keyboard from the `PianoHeroApp` object
    to the `GamePanel` object. This includes the `keyCodesToNotes`, `sustain`, and
    `volume` variables. We also move the `initKeyboard()` , `keyDown()`, `keyUp()`,
    `pressPianoKey()`, `releasePianoKey()`, `getPianoKeyElement()` , and `isInputTypeSupported()`
    methods. Finally, we move the `onKeyDown()` and `onKeyUp()` event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add some public methods for the application to interact with the
    game panel. Like the splash panel, we need methods to show and hide it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `show()` public method fades the game panel in. We pass in a reference to
    the `startGame()` method, which we will write in the next section, to be called
    when the fade in has completed.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the game panel by adding markup for an area to hold animated `note`
    elements, and an area to show the score. These are in addition to our keyboard
    we created in the previous chapter. Then, we created a JavaScript object to hold
    all of the code for the game panel, including all of the code we wrote previously
    for the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point there's not much left in our main application object, `PianoHeroApp`.
    We moved all of the code to load the audio to the `SplashPanel` object, and all
    of the code to make the keyboard work to the `GamePanel` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PianoHeroApp` object will now only act as a state controller to hide and
    show the correct panels. First we need to add some variables to hold references
    to the panels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We define variables to hold the audio manager, the splash panel, and the game
    panel objects. We also have a `curPanel` variable, which will be set to the current
    panel that is showing. To start with we will set it to `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a private `showPanel()` method that will hide the currently
    showing panel, if there is one, and show a different one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the panel to show as a parameter. This will be a reference
    to either `SplashPanel` or `GamePanel`. First we check to see if a panel is showing,
    and if so we call its `hide()` method. Then we set `curPanel` to the new panel
    and call its `show()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we define the public `startGame()` method. If you remember from the code
    we wrote for the `SplashPanel` object, this will get called from the event handler
    when the user clicks either on the **Play Game** or **Play Song** button. It passes
    in the game options the player selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `startGame()` method takes three parameters; the name of the song to play,
    the playback rate (which controls how fast the game progresses), and a Boolean
    value (which determines if the user clicked on the **Play Game** button).
  prefs: []
  type: TYPE_NORMAL
- en: First we call the `setOptions()` method of the `GamePanel` object, which we
    will write later. We pass through the same parameters we got from the splash panel.
    Then we call the `showPanel()` method passing in the `GamePanel` object. This
    is what will start the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will define the public `quitGame()` method. This will be called from
    the game panel when the user clicks on the **Quit** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All we do in this method is call `showPanel()`, passing it the `SplashPanel`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing we need to define is the `start()` method of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First we set up keyboard event handlers on the document, just as we did when
    creating the piano application. However, in this application we will forward the
    keyboard event to the current panel. By centralizing the keyboard event handlers
    in the application object, we don't have to write a bunch of code in each panel
    to subscribe and unsubscribe keyboard event handlers from the document when the
    panel is shown or hidden.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing we do is show the splash panel, and then call its `loadAudio()`
    method to kickstart the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our splash and game panels implement `show()`, `hide()`, `keydown()`, and `keyup()`
    methods. Since JavaScript is untyped we can't enforce this with interfaces. So
    we program by convention instead, assuming that all panels will implement those
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added code to the main application object to control the state of the game.
    When the player clicks on one of the buttons from the splash panel it starts the
    game, and when they click on **Quit** from the game, it shows the splash panel.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an audio sequencer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can play the game, we need some way to play songs on the piano by
    playing back notes in a certain order, at the correct time, and at the correct
    speed. We will create an object called `AudioSequencer` that takes an array of
    musical event objects and turns them into music.
  prefs: []
  type: TYPE_NORMAL
- en: To implement our audio sequencer we need to define a format for our music events.
    We will roughly follow the MIDI format, but much more simplified. MIDI is the
    standard to record and play back music events. Each event contains information
    about how and when to play notes, or turn notes off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our event object will contain three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deltaTime`: The amount of time to wait before executing the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event`: This is an integer event code that determines what the event does.
    It can be one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn a note on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn a note off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cue point will be at the beginning of a song
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End of track will signal that the song is over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`note`: This is the note to play. It contains the octave and note, and matches
    our audio file names, for example, 3C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The audio sequencer will work by looking at the `deltaTime` field in each event
    to determine how long to wait before firing the event. The client will pass in
    an event handler function that will be called when the event is fired. The client
    will then look at the event data and determine which note to play. This loop continues
    until there are no more events left.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an audio sequencer](img/5947OT_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – creating AudioSequencer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our `AudioSequencer` object in a file called `audioSequencer.js`.
    We''ll start by defining a few variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First we define an `_events` array to hold all of the music events to play.
    The `_playbackRate` variable controls how fast the song plays. A value of `1`
    will be at normal speed, less than `1` slower, and more than `1` faster. The `_playing`
    variable is set to `true` while a song is playing. `eventHandler` will be set
    to a function that gets called when an event is fired, and `timeoutID` will contain
    the handle returned from `setTimeout()` in case the user stops the game and we
    need to cancel the timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s define some public property methods. The first is `events()`. It
    is used to get or set the `_events` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next is `playbackRate()`. It is used to get or set `_playbackRate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we have `isPlaying()`, which is used to determine if a song is currently
    playing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will code the public `startPlayback()` method. This method takes two
    parameters; the event handler function and optionally the starting position, which
    is an index into the `_events` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is default the `startPos` parameter to `0,` if it was
    not provided. Next we check that a song isn't already playing, and make sure we
    actually have some events to play. If so we set the `_playing` flag to `true`,
    store the event handler reference, and then call `playEvent()` for the first event.
    We return `true` if playback was successfully started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write the `playEvent()` method. It takes one parameter, the index
    of the next event to fire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is get the event at the specified index in the `_events`
    array. Then we immediately call the event handler's callback function that was
    provided in the `startPlayback()` method, passing it the event code, the note
    to play, and the event index.
  prefs: []
  type: TYPE_NORMAL
- en: Next we increment the index to get the next event. If there is another event
    we call `setTimeout()` to wait for the amount of time specified in the event's
    `deltaTime` field before calling `playEvent()`, again passing it the index of
    the next event. We compute the amount of time to wait by multiplying `deltaTime`
    by the inverse of the playback rate. For example, if the playback rate is 0.5
    then the wait time will be 1 , 0.5 or 2 times the normal rate. This loop continues
    in this fashion until there are no more events to play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need is a public `stopPlayback()` method. This method is
    called to stop the event loop, and therefore stop the playback of the audio events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First we check the `_playing` flag to make sure a song is actually playing.
    If so, we set the flag to `false`, and then we call `clearTimeout()` to stop the
    timeout. This will stop `playEvent()` from being called again, which will stop
    the playback loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need is to define the playback event codes, so we don''t
    have to remember the event code numbers. We will define a pseudo enumeration using
    an object on `AudioSequencer` called `eventCodes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an audio sequencer object that takes an array of music events, similar
    to MIDI events, and calls them at the correct time using the `setTimeout()` function.
    When an event is fired it calls the event handler function, passed in by the game
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we have written this code to play music, you could use the same technique
    anywhere you need things to happen at predetermined intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Playing a song
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an audio sequencer, we can go into the game panel and add some
    code to play a song in practice mode. As the song plays it will press the correct
    keys on the screen, just like a player piano. Later we will add code to check
    for player interaction to see how good they follow along with the song.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the audio sequencer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the audio sequencer to the game panel. We will go into the `GamePanel`
    object and add an instance of `AudioSequencer` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s write the public `setOptions()` method, which is called from the
    `startGame()` method of `PianoHeroApp`. It takes three parameters; the song name,
    playback rate, and whether to play the game or the song in practice mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is set the `events()` property of the audio sequencer
    to the data for the song to play. We get the song data from the `musicData` object,
    which is defined in `musicData.js`. Then, we set the audio sequencer's `playbackRate()`
    property. Lastly we set the `practiceMode` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `musicData` object contains event data that the sequencer can play for
    all of the songs that the user can select on the splash page. Each song is defined
    as an array of music event objects. Here''s an example of what the data looks
    like for the rhyme *Twinkle, Twinkle Little Star*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts with a cue point event (`event: 3`), and then turns on note 3C (`event:
    1`). After 500 milliseconds it turns off note 3C (`event: 2`). It continues on
    until the last event, which is end of track (`event: 4`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next let''s write the `startGame()` method, which is called from the `show()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is hide the results panel and show the notes panel. Then
    we reset the score and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start an interval timer by calling the JavaScript `setInterval()` function
    and setting the `intervalId` variable to the handle that is returned. We will
    use that later to stop the interval when the game has finished, or the player
    stops the game. This interval is used to animate the elements in the notes panel
    that fall down from the top of the page. We set the interval to fire at a constant
    rate by dividing 1000 milliseconds by the number of frames per second. We will
    use a frame rate of 30 frames per second, which is enough to produce a relatively
    smooth animation and not bog down the game. At every interval of the timer we
    call the `updateNotes()` method, which we'll write in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing we do in this method is call the `startPlayback()` method of
    the audio sequencer, passing it a reference to our audio event handler method,
    `onAudioEvent()`, and a start position of zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This method accepts two parameters: the audio event code and the note to play.
    We use a `switch` statement along with our `eventCodes` enumeration to determine
    how to handle the event. If the event code is `noteOn`, we call the `addNote()`
    method to add a `note` element to the notes panel. If it''s an `endOfTrack` event,
    we call `stopPlayback()` on the audio sequencer. We can ignore all of the other
    events for now.'
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added the audio sequencer to our game panel and hooked up a function to handle
    when note events are fired. We added a `startGame()` method that starts the animation
    interval for animating the `note` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animated notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are going to implement the code for the notes panel. This is where the
    animation of notes dropping from the top of the page happens. It works something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The audio sequencer sends an event that a note should be played (see `onAudioEvent()`
    in the previous section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The note is not actually played at that time. Instead a rectangular element
    that represents the note is added to the top of the notes panel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time our animation interval timer fires, the y-position of the `note`
    element is incremented so that it moves down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the element hits the bottom edge of the notes panel (and the top edge of
    the keyboard), it plays the audio clip associated with the note.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the element completely leaves the notes panel, it is removed from the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Creating animated notes](img/5947OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – adding notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write the `addNote()` method that was referenced by `onAudioEvent()`
    in the previous section. This method takes one parameter, the name of the note
    to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First we update the `noteCount` variable to keep track of statistics. Then we
    create a new note `<div>` element using jQuery, and give it a class of `"note"`.
    We set the `data-note` custom attribute to the name of the note. We will need
    that later when it reaches the bottom of the panel to know which note to play.
    Lastly, we add it to the notes panel using jQuery's `append()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we do is position the `note` element over the piano key that
    it represents. We get the piano key element that is associated with the note by
    calling our existing `getPianoKeyElement()` method. We extract the left position
    and width of the piano key, and set the `note` element to the same values so that
    it lines up.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing we do is check if the piano key is a black or white key, by
    checking if it has the `"black"` class defined on it. If so, we give the `note`
    element a `"black"` class too. This will make the element appear in a different
    color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the styling for the `note` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the `position` to `absolute` because we need to move them around and
    place them wherever we want. We give them a linear gradient from left to right,
    fading from white to cyan. We also give it a white shadow with no offset. This
    will make it look like it''s glowing against the black background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The notes with the `"black"` class will override the background color to fade
    from white to magenta.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a method that adds elements that represent notes to the notes panel.
    We positioned those notes so that they are directly over the top of the piano
    key they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – animating the notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we started an interval using `setInterval()` in the `startGame()`
    method. The `updateNotes()` method gets called every time the interval expires.
    This method is responsible for updating the position of all of the `note` elements,
    so they appear to move down the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First we select all of the `note` elements in the notes panel and iterate over
    them. For each one we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the top position and check if it is less than 200, which is the height of
    the notes panel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the element is still inside the notes panel, we move the element down the
    number of pixels defined by the `pixelsPerFrame` variable. At 30 frames per second
    this is 2 pixels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we check if the bottom of the `note` element hit the bottom of the notes
    panel by checking if the bottom is more than 200.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, we set the `currentNote` object's `note` variable to the note, so we
    can check if the user played the correct note later. We also get the exact time
    the note hit the bottom, to determine how close the player was to playing it on
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are in practice mode, we also play the note by calling `pressPianoKey()`
    and passing it the `note` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `note` element is outside of the notes panel, then we call `releasePianoKey()`
    and remove it from the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final thing we do is check if there are any more note elements left in the
    notes panel. If not, the game is over and we call `showScore()` to show the results
    panel. Then we call `endGame()`, which stops the animation interval.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We animated the `note` elements so that they appear to fall down the screen
    over the keys of the keyboard that they represent. When the notes hit the bottom
    of the notes panel, we play the note if in practice mode. When the `note` element
    moves out of the panel, we remove it from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try playing around with the frame rate and see how it affects the quality of
    the animation. What is the lowest frame rate that is acceptable? What is the highest
    frame rate that is perceptible?
  prefs: []
  type: TYPE_NORMAL
- en: Handling user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user has started the game and notes are falling down the screen. Now we
    need to check if the player presses the correct piano key at the correct time.
    When they do, we will give them some points based on how accurate they were.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – checking the notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add a call to the `checkNote()` method in the `keyDown()` method. The
    `checkNote()` method takes the name of the note as a parameter, and checks if
    there is a `note` element at the bottom of the notes panel that matches it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First we check the `currentNote` object that was set previously in `updateNotes()`
    . If its note is the same as the one the user played, then they might get some
    points for playing it at the correct time. To find out if they get points, we
    first find the time difference in milliseconds between the time the note hit the
    bottom of the panel and the current time. If it's within the allowable grace period,
    which we set to 200 milliseconds, then we compute the score.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first increment the number of correct notes. Then, we determine the score
    by computing the percentage of time they were off by and multiplying it by 10\.
    This way the number of points per note is between 1 and 10\. Finally, to give
    the user some indication that they got it right, we change the background color
    of the element to green and call `addHitEffect()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `addHitEffect()` method flashes the **PIANO HERO** title in the background
    of the notes panel by changing its color, waiting for 100 milliseconds using a
    `setTimeout()` call, and then changing it back to black.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – checking the notes](img/5947OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a method to check if the correct piano key was pressed at the correct
    time for a `note` element. If so, we add points depending on how well timed the
    note was played, and change the color of the note to indicate success.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now the player can play the game and we can keep track of the score and the
    number of notes they got correct. When the game ends, we need to display the results
    panel that shows the score and some statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the results panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After all of the notes have been played for the song, the `updateNotes()` method
    calls `showScore()`, where we will show the player''s score and some statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First we hide the notes panel and fade in the score panel in its place. Then,
    we fill in the score and statistics into the placeholders in the DOM. We show
    the score, number of notes correct, and total number of notes. In addition, we
    compute the percentage of notes they got correct using the `notesCorrect` and
    `noteCount` variables.
  prefs: []
  type: TYPE_NORMAL
- en: We get the timing accuracy percentage by factoring it from the score and number
    of notes correct. Remember that there are a total of 10 points possible per note,
    so if they got 17 notes correct the total number of possible points is 170\. If
    the score was 154 that would be 154 / 170 ≈ 91%.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating the results panel](img/5947OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We showed the results panel when the game is over, and populated it with the
    player's score and statistics. Our game is now finished. Go ahead and give it
    a try and become a piano hero!
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try writing an audio recorder class that records when the user plays a note
    on the keyboard, and saves it to an array of data objects that can be played by
    the audio sequencer.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Which JavaScript function can be used to create a timer that fires at regular
    intervals until cleared?
  prefs: []
  type: TYPE_NORMAL
- en: '`setTimeout()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setRate()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setInterval()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wait()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which attributes of a `<progress>` element control the percentage of the
    progress bar that is marked complete?
  prefs: []
  type: TYPE_NORMAL
- en: '`value` and `max`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`currentValue` and `maxValue`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`start` and `end`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`min` and `max`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a game based on the piano application we wrote in the previous chapter.
    We used JavaScript timers to implement an audio sequencer to play back songs and
    create an animation loop. We created splash and game panels and learned how to
    transition game states between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a splash panel and use text shadows to produce interesting text
    effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use an HTML5 progress bar element to show the progress of loading dynamic
    resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JavaScript timer functions to create an audio sequencer, to control playback
    of audio to play songs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to animate DOM elements using a JavaScript timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to transition between game states and panels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to collect user input, verify it, and show the results at the end of the
    game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn all about using Ajax to dynamically load
    resources and call web services by building a weather widget.
  prefs: []
  type: TYPE_NORMAL
