- en: Chapter 6. Testing and Documenting Node.js Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, all that we have done is develop microservices and discuss the frameworks
    around the process of building software components. Now it is time to test all
    of them. Testing is the activity of validating the software that has been built.
    Validating is a very broad term. In this chapter, we are going to learn how to
    test microservices, not only from the functional point of view, but we will also
    learn how to test the performance of our applications, as well as other aspects
    such as integration with different modules. We will also build a proxy using Node.js
    to help us to inspect the inputs and outputs of our services so that we can validate
    that what we have designed is actually happening and, once again, reassure the
    versatility of a language, such as JavaScript, to quickly prototype features.
  prefs: []
  type: TYPE_NORMAL
- en: It is also nowadays a trend to release features with an A/B test, where we only
    enable the features for certain type of users, and then we collect metrics to
    see how the changes to our system are performing. In this chapter, we will build
    a microservice that is going to give us the capability of rolling out features
    in a controlled way.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we are going to document our application, which unfortunately,
    is a forgotten activity in traditional software development: I haven''t found
    a single company where the documentation captures 100% the information needed
    by new developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional testing**: In this section, we will learn how to test microservices
    and what a good testing strategy is. We will also get to study a tool called Postman
    to manually test our APIs, as well as build a proxy with Node.js to spy our connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documenting microservices**: We will learn how to use Swagger to document
    our microservices using the open API standard. We will also generate the code
    from the YAML definition using an open source tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is usually a time-consuming activity that does not get all the required
    attention while building a software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about how a company evolves:'
  prefs: []
  type: TYPE_NORMAL
- en: Someone comes up with an idea.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A few engineers/product people build the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The company goes to market.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no time to test more than the minimal required manual testing. Especially,
    when someone reads on the Internet that testing done right could take up to 40%
    of your development time, and once again, the common sense fails.
  prefs: []
  type: TYPE_NORMAL
- en: Automation is good and unit, integration, and end-to-end tests are a form of
    automation. By letting a computer test our software, we are drastically cutting
    down the human effort required to validate our software.
  prefs: []
  type: TYPE_NORMAL
- en: Think about how the software is developed. Even though our company likes to
    claim that *we are agile*, the truth is that every single software project has
    some level of iterative development, and testing is a part of every cycle, but
    generally, it is overlooked in favour of delivering new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'By automating the majority (or a big chunk) of the testing, we are saving money,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional testing](img/B04889_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Costs and Iterations
  prefs: []
  type: TYPE_NORMAL
- en: Testing is actually a cost saver if is done right, and the key is doing it right,
    which is not always easy. How much testing is too much testing? Should we cover
    every single corner of our application? Do we really need deep performance testing?
  prefs: []
  type: TYPE_NORMAL
- en: These questions usually lead to a different stream of opinions, and the interesting
    thing is that there is not a single source of truth. It depends on the nature
    of your system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn a set of extensive testing techniques,
    which does not mean that we should be including all of them in our test plan,
    but at least we will be aware of the testing methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: In the past seven years, Ruby on Rails has created a massive trend towards a
    new paradigm, called **Test-driven development** (**TDD**), up to a point that,
    nowadays, majority of the new development platforms are built with TDD in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I am not a fierce adopter of TDD, but I like to take the good parts.
    Planning the test before the development helps to create modules with the right
    level of cohesion and define a clear and easy-to-test interface. In this chapter,
    we won't cover the TDD in depth, but we will mention it a few times and explain
    how to apply the exposed techniques to a TDD test plan.
  prefs: []
  type: TYPE_NORMAL
- en: The pyramid of automated testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to lay down your testing plan is a tricky question. No matter what you do,
    you will always end up with the sensation that *this is completely wrong*.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the deep, let's define the different type of tests that we
    are going to be dealing with from the functional point of view, and what should
    they be designed for.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **unit test** is a test that covers individual parts of the application without
    taking into account the integration with different modules. It is also called
    **white box testing** as the aim is to cover and verify as many branches as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the way to measure the quality of our tests is the test coverage
    and it is measured in percentage. If our code spans over ten branches and our
    tests cover seven branches, our code coverage is 70%. This is a good indication
    of how reliable our test coverage is. However, it could be misleading as the tests
    could be flawed, or even though all the branches are tested, a different input
    would cause a different output that wasn't captured by a test.
  prefs: []
  type: TYPE_NORMAL
- en: In unit tests, as we don't interact with other modules, we will be making a
    heavy use of mocks and stubs in order to simulate responses from third-party systems
    and control the flow to hit the desired branch.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Integration tests**, as the name suggests, are the tests designed to verify
    the integration of our module in the application environment. They are not designed
    to test the branches of our code, but business units, where we will be saving
    the data into databases, calling third-party web services or other microservices
    of our architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: These tests are the perfect tool for checking whether our service is behaving
    as expected, and sometimes, could be hard to maintain (more often than not).
  prefs: []
  type: TYPE_NORMAL
- en: 'During my years of experience, I haven''t found a company where the integration
    testing is done right and there are a number of reasons for this, as stated in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Some companies think that integration testing is expensive (and it is true)
    as it requires extra resources (such as databases and extra machines)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other companies try to cover all the business cases just with unit testing,
    which depending on the business cases, could work, but it is far from ideal as
    unit tests make assumptions (mocks) that could give us a false confidence in our
    test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, integration tests are used to verify the code branches as if they
    were unit tests, which is time consuming as you need to work out the environment
    to make the integration test to hit the required branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter how smart you want to be, integration testing is something that you
    want to do right, as it is the first real barrier in our software to prevent integration
    bugs from being released into production.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will demonstrate that our application actually works. In an integration
    test, we are invoking the services at code level. This means that we need to build
    the context of the service and then issue the call.
  prefs: []
  type: TYPE_NORMAL
- en: The difference with end-to-end testing is that, in end-to-end testing, we actually
    fully deploy our application and issue the required calls to execute the target
    code. However, many times, the engineers can decide to bundle both type of tests
    (integration and end-to-end tests) together, as the modern frameworks allow us
    to quickly run E2E tests as if they were integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: As the integration tests, the target of the end-to-end tests is not to test
    all the paths of the application but test the use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In end-to-end tests, we can find a few different modalities (paradigms) of
    testing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can test our API issuing JSON requests (or other type of requests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can test our UI using Selenium to emulate clicks on the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a new paradigm called **behavior-driven development** (**BDD**) testing,
    where the use cases are mapped into actions in our application (clicks on the
    UI, requests in the API, and so on) and execute the use cases for which the application
    was built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end tests are usually very fragile and they get broken fairly easy. Depending
    on our application, we might get relaxed about these tests as the cost-value ratio
    is pretty low, but still, I would recommend having some of them covering at least
    the most basic and essential flows.
  prefs: []
  type: TYPE_NORMAL
- en: How much testing is too much?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Questions such as the following are not easy to answer, especially in fast
    paced businesses, like startups:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we have too many integration tests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should we aim for 100% unit test coverage?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why bother with Selenium tests if they break every second day for no reason?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is always a compromise. Test coverage versus time consumed, and also,
    there is no simple and single answer to these questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only useful guideline that I''ve found along the years is what the testing
    world calls the **pyramid of testing**, which is shown in the following figure.
    If you think for a moment, in the projects where you worked before, how many tests
    did you have in total? What percentage of these were integration tests and unit
    tests? What about end-to-end tests?:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How much testing is too much?](img/B04889_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The pyramid of testing
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding pyramid shows the answers for these questions. In a healthy test
    plan, we should have a lot of unit tests: some integration tests and very few
    E2E tests.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is very simple, majority of the problems can be caught within
    unit testing. Hitting the different branches of our code will verify the functionality
    of pretty much every functional case in our application, so it makes sense to
    have plenty of them in our test plan. Based on my experience, in a balanced test
    plan, around 70% of our tests should be unit tests. However, in a microservices-oriented
    architecture, especially with a dynamic language such as Node.js, this figure
    can easily go down and still be effective with our testing. The reasoning behind
    it is that Node.js allows you to write integration tests very quickly so that
    we can replace some unit tests by integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing is a very well-documented, complex process. Trying to outsmart the existing
    methodologies could result in a hard-to-maintain and difficult-to-trust test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration tests are responsible for catching integration problems, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Can our code call the SMS gateway?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Would the connection to the database be OK?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the HTTP headers being sent from our service?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, around 20% of our tests, based on my experience, should be integration
    tests; focus on the positive flows and some of the negative that depend on third-party
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes down to E2E tests, they should be very limited and only test
    the main flows of the applications without going into too much detail. These details
    should be already captured by the unit and integration tests that are easy to
    fix in an event of failure. However, there is a catch here: when testing microservices
    in Node.js, 90% of the time, integration and E2E tests can be the same thing.
    Due to the dynamic nature of Node.js, we can test the rest API from the integration
    point of view (the full server running), but in reality, we will also be testing
    how our code behaves when integrated with other modules. We will see an example
    later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing microservices in Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is an impressive language. The amount of libraries around any single
    aspect of the development is amazing. No matter how bizarre the task that you
    want to achieve in Node.js is, there will be always an npm module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the testing, Node.js has a very powerful set of libraries, but two
    of them are especially popular: **Mocha** and **Chai**.'
  prefs: []
  type: TYPE_NORMAL
- en: They are pretty much the industry standard for app testing and are very well
    maintained and upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting library is called **Sinon.JS**, and it is used for mocking,
    spying and stubbing methods. We will come back to these concepts in the following
    sections, but this library is basically used to simulate integrations with third
    parties without interacting with them.
  prefs: []
  type: TYPE_NORMAL
- en: Chai
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This library is a BDD/TDD assertions library that can be used in conjunction
    with any other library to create high quality tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'An assertion is a code statement that will either be fulfilled or throw an
    error, stopping the test and marking it as a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement will be correct when the variable `A` contains the
    value `5`. This is a very powerful tool to write easy-to-understand tests, and
    especially with Chai, we have access to assertions making use of the following
    three different interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`should`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the day, every single condition can be checked using a single
    interface, but the fact that the library provides us with such a rich interface
    facilitates the verbosity of the tests in order to write clean, easy, and maintainable
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chai](img/B04889_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means that Chai depends on `assertion-error`, `type-detect`, and `deep-eql`.
    As you can see, this is a good indication that we will be able to check, with
    simple instructions, complex statements such as deep equality in objects or type
    matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing libraries such as Chai are not a direct dependency of our application,
    but a development dependency. We need them to develop applications, but they should
    not be shipped to production. This is a good reason to restructure our `package.json`
    and add Chai in the `devDependencies` dependency tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will prevent our software to ship into production libraries such as Chai,
    which has nothing to do with the operation of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have installed Chai, we can start playing around with the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: BDD-style interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Chai comes with two flavors of BDD interfaces. It is a matter of preference
    which one to use, but my personal recommendation is to use the one that makes
    you feel more comfortable in any situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `should` Interface. This one is a BDD-style interface,
    using something similar to the natural language, we can create assertions that
    will decide whether our test succeeds or fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to build sentences like the one before, we need to import
    the `should` module in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it looks like a bit of dark magic, it is really convenient when testing
    our code as we use something similar to the natural language to ensure that our
    code is meeting some criteria: *foo should be equal to ''Hello world''* has a
    direct translation to our test.'
  prefs: []
  type: TYPE_NORMAL
- en: The second BDD-style interface provided by Chai is `expect`. Although it is
    very similar to `should`, it changes a bit of syntax in order to set expectations
    that the results have to meet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the style is very similar: a fluent interface that allows us
    to check whether the conditions for the test to succeed are met, but what happens
    if the conditions are not met?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute a simple Node.js program that fails in one of the conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute the previous script, assuming that you have already installed
    Chai:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: An exception is thrown and the test fails. If all the conditions were validated,
    no exception would have been raised and the test would have succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are a number of natural language words that we can use
    for our tests using both `expect` and `should` interfaces. The full list can be
    found in the Chai documentation ([http://chaijs.com/api/bdd/#-include-value-](http://chaijs.com/api/bdd/#-include-value-)),
    but let''s explain some of the most interesting ones in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`not`: This word is used to negate the assertions following in the chain. For
    example, `expect("some string").to.not.equal("Other String")` will pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deep`: This word is one of the most interesting of all the collection. It
    is used to deep-compare objects, which is the quickest way to carry on a full
    equal comparison. For example, `expect(foo).to.deep.equal({name: "David"})` will
    succeed if `foo` is a JavaScript object with one property called `name` with the
    `"David"` string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any`/`all`: This is used to check whether the dictionary or object contains
    any of the keys in the given list so that `expect(foo).to.have.any.keys("name",
    "surname")` will succeed if `foo` contains any of the given keys, and `expect(foo).to.have.all.keys("name",
    "surname")` will only succeed if it has all of the keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ok`: This is an interesting one. As you probably know, JavaScript has a few
    pitfalls, and one of them is the true/false evaluation of expressions. With `ok`,
    we can abstract all the mess and do something similar to the following list of
    expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(''everything'').to.be.ok`: `''everything''` is a string and it will
    be evaluated to `ok`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(undefined).to.not.be.ok`: Undefined is not ok in the JavaScript world,
    so this assertion will succeed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`above`: This is a very useful word to check whether an array or collection
    contains a number of elements above a certain threshold, as follows: `expect([1,2,3]).to.have.length.above(2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the Chai API for fluent assertions is quite rich and enables
    us to write very descriptive tests that are easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may be asking yourself, why have two flavors of the same interface
    that pretty much work the same? Well, they functionally do the same, however,
    take a look at the detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expect` provides a starting point in your chainable language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should` extends the `Object.prototype` signature to add the chainable language
    to every single object in JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From Node.js' point of view, both of them are fine, although the fact that `should`
    is instrumenting the prototype of `Object` could be a reason to be a bit paranoid
    about using it as it is intrusive.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **assertions** interface matches the most common old-fashioned tests assertion
    library. In this flavor, we need to be specific about what we want to test, and
    there is no such thing as fluent chaining of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is really nothing more to go in depth if you have already used any of
    the existing test libraries in any language.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mocha is, in my opinion, one of the most convenient testing frameworks that
    I have ever used in my professional life. It follows the principles of **behavior-driven**
    **development testing** (**BDDT**), where the test describes a use case of the
    application and uses the assertions from another library to verify the outcome
    of the executed code.
  prefs: []
  type: TYPE_NORMAL
- en: Although it sounds a bit complicated, it is really convenient to ensure that
    our code is covered from the functional and technical point of view, as we will
    be mirroring the requirements used to build the application into automated tests
    that verifies them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a simple example. Mocha is a bit different from any other library,
    as it defines its own **domain-specific language** (**DSL**) that needs to be
    executed with Mocha instead of Node.js. It is an extension of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to install Mocha in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocha](img/B04889_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From now on, we have a new command in our system: `mocha`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to write a test using Mocha:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is simple. A function that rolls a dice and returns an
    integer number from `1` to `6`. Now we need to think a bit about the use cases
    and the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The number has to be an integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This integer has to be below 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to be above 0, dice don't have negative numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function cannot return `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function cannot return `undefined`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This covers pretty much every corner case about rolling a dice in Node.js. What
    we are doing is describing situations that we certainly want to test, in order
    to safely make changes to the software without breaking the existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'These five use cases are an exact map to the tests written earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '**We describe the situation**: *When a customer rolls a dice*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conditions get verified**: *It should return an integer number*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s run the previous test and check the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocha](img/B04889_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, Mocha returns a comprehensive report on what is going on in
    the tests. In this case, all of them pass, so we don't need to be worried about
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s force some of the tests to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Accidentally, someone has bumped a code fragment into the `rollDice()` function,
    which makes the function return a number that does not meet some of the requirements.
    Let''s run Mocha again, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocha](img/B04889_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can see the report returning one error: the method is returning `-4`,
    where it should always return a number bigger than `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, one of the benefits of this type of testing in Node.js using Mocha and
    Chai is the time. Tests run very fast so that it is easy to receive feedback if
    we have broken something. The preceding suite ran in `10ms`.
  prefs: []
  type: TYPE_NORMAL
- en: Sinon.JS – a mocking framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous two chapters have been focused on asserting conditions on return
    values of functions, but what happens when our function does not return any value?
    The only correct measurement is to check whether the method was called or not.
    Also, what if one of our modules is calling a third-party web service, but we
    don't want our tests to call the remote server?
  prefs: []
  type: TYPE_NORMAL
- en: 'For answering these questions, we have two conceptual tools called mocks and
    spies, and Node.js has the perfect library to implement them: Sinon.JS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First install it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sinon.JS – a mocking framework](img/B04889_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s explain how it works through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple script calculates the hypotenuse of a triangle, given the length
    of the other two sides of the triangle. One of the tests that we want to carry
    on is the fact that the callback is executed with the right list of arguments
    supplied. What we need to accomplish such task is what Sinon.JS calls a spy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we are using Mocha to run the script and Chai to verify the results
    in the test through the `should` interface, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sinon.JS – a mocking framework](img/B04889_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The important line in the preceding script is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating the spy and injecting it into the function as a callback.
    This function created by Sinon.JS is actually not only a function, but a full
    object with a few interesting points of information. Sinon.JS does that, taking
    advantage of the dynamic nature of JavaScript. You can actually see what is in
    this object by dumping it into the console with `console.log()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very powerful tool in Sinon.JS are the stubs. **Stubs** are very similar
    to mocks (identical at practical effects in JavaScript) and allow us to fake functions
    to simulate the required return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have stubbed the `Math#random` method, which causes the method
    to be some sort of overloaded empty function (it does not issue the get call)
    that records stats on what or how it was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one catch in the preceding code: we never restored the `random()`
    method back and this is quite dangerous. It has a massive side effect, as other
    tests will see the `Math#random` method as a stub, not as the original one, and
    it can lead to us coding our tests according to invalid information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent this, we need to make use of the `before()` and `after()`
    methods from Mocha:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you pay attention to the highlighted code, we are telling Sinon.JS to restore
    the original method that was stubbed inside one of the `it` blocks, so that if
    another `describe` block makes use of `http.get`, we won't see the stub, but the
    original method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `before()` and `after()` methods are very helpful to set up and wind down
    the context for the tests. However, you need to be careful with the scope where
    they are executed as it could lead to test interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocha has a few flavors of before and after:'
  prefs: []
  type: TYPE_NORMAL
- en: '`before(callback)`: This is executed before the current scope (at the beginning
    of the `describe` block in the preceding code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after(callback)`: This is executed after the current scope (at the end of
    the `describe` block in the preceding code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach(callback)`: This is executed at the beginning of every element
    in the current scope (before each `it` in the preceding example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterEach(callback)`: This is executed at the end of every element in the
    current scope (after every `it` in the preceding example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another interesting feature in Sinon.JS is the time manipulation. Some of the
    tests need to execute periodic tasks or respond after a certain time of an event''s
    occurrence. With Sinon.JS, we can dictate time as one of the parameters of our
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can now control the time in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a real microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, it is time to test a real microservice in order to get a general picture
    of the full test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our microservice is going to use Express, and it will filter an input text
    to remove what the search engines call **stop words**: *words with less than three
    characters and words that are banned*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the service is pretty small, so it is the perfect example for
    explaining how to write unit, integration, and E2E tests. In this case, as we
    stated before, E2E and integration tests are going to be the exact same as testing
    the service through the REST API will be equivalent to testing the system from
    the end-to-end point of view, but also how our component is integrated within
    the system. Given that, if we were to add a UI, we would have to split integration
    tests from E2E in order to ensure the quality.
  prefs: []
  type: TYPE_NORMAL
- en: TDD – Test-driven development
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our service is done and working. However, now we want to unit test it, but
    we find some problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The function that we want to unit test is not visible outside the main `.js`
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server code is tightly coupled to the functional code and has bad cohesion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here TDD comes to the rescue; we should always ask ourselves "how am I going
    to test this function when writing software?" It does not mean that we should
    modify our software with the specific purpose of testing, but if you are having
    problems while testing a part of your program, more than likely, you should look
    into cohesion and coupling, as it is a good indication of problems. Let''s take
    a look at the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This file is a module that, in my opinion, is highly reusable and has good
    cohesion:'
  prefs: []
  type: TYPE_NORMAL
- en: We can import it everywhere (even in a browser)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The banned words can be injected when creating the module (very useful for testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not tangled with the application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Laying down the code this way, our application module will look similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have clearly separated the business unit (the function that
    captures the business logic) from the operational unit (the setup of the server).
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, I am not a big fan of writing the tests prior to the
    code, but they should be written (in my opinion) alongside the code, but always
    having in mind the question mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: There seem to be a push in companies to adopt a TDD methodology, but it could
    lead to a significant inefficiency, especially if the business requirements are
    unclear (as they are 90% of the time) and we face changes along the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that our code is in a better shape, we are going to unit test our function.
    We will use Mocha and Chai to accomplish such task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have covered pretty much every single case and branch inside
    our application, but how is our code coverage looking?
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have mentioned it, but never actually measured it. We are going
    to use one tool, called **Istanbul**, to measure the test coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This should install Istanbul. Now we need to run the coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output similar to the one shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unit testing](img/B04889_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will also generate a coverage report in HTML, pointing out which lines,
    functions, branches, and statements are not being covered, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unit testing](img/B04889_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we are looking pretty well. Our code (not the tests) is actually
    well covered, especially if we look into the detailed report for our code file,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unit testing](img/B04889_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that only one branch (the `or` operator in line **7**) is not covered
    and the `if` operator in line **6** never diverted to the `else` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also got information about the number of times a line is executed: it is
    showing in the vertical bar beside the line number. This information is also very
    useful to spot the hot areas of our application where an optimization will benefit
    the most.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the right level of coverage, in this example, it is fairly easy to
    go up to 90%+, but unfortunately, it is not that easy in production systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Code is a lot more complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time is always a constraint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing might not be seen as productive time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, you should exercise caution when working with a dynamic language. In
    Java or C#, calling a function that does not exist results in a compilation time
    error; whereas in JavaScript, it will result in a runtime error. The only real
    barrier is the testing (manual or automated), so it is a good practice to ensure
    that at least every line is executed once. In general code coverage, over 75%
    should be good enough for the majority of cases.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to test our application end to end, we are going to need a server running
    it. Usually, end-to-end tests are executed against a controlled environment, such
    as a QA box or a pre-production machine, to verify that our about-to-be-deployed
    software is behaving as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, our application is an API, so we are going to create the end-to-end
    tests, which at the same time, are going to be used as integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: However, in a full application, we might want to have a clear separation between
    the integration and end-to-end tests and use something like Selenium to test our
    application from the UI point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selenium is a framework that allows our code to send instructions to the browser,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the button with the `button1` ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hover over the `div` element with the CSS class `highlighted`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, we can ensure that our app flows work as expected, end to end,
    and our next release is not going to break the key flows of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on the end-to-end tests for our microservice. We have been using
    Chai and Mocha with their corresponding assertion interfaces to unit test our
    software, and Sinon.JS to mock services functions and other elements to avoid
    the calls being propagated to third-party web services or get a controlled response
    from one method.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in our end-to-end test plan, we actually want to issue the calls to our
    service and get the response to validate the results.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is run our microservice somewhere. We are going
    to use our local machine just for convenience, but we can execute these tests
    in a continuous development environment against a QA machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I call my script `stop-words.js` for convenience. Once the server is running,
    we are ready to start testing. In some situations, we might want our test to start
    and stop the server so that everything is self-contained. Let''s see a small example
    about how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Express provides a handler to operate the server programmatically,
    so it is as simple as making use of the `before()` and `after()` functions to
    do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are going to assume that the server is running. In order
    to issue the requests, we are going to use a library called `request` to issue
    the calls to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to install it, as usual, is to execute `npm install request`. Once
    it is finished, we can make use of this amazing library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With the simple test from earlier, we managed to test our server in a way that
    ensures that every single mobile part of the application has been executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a particularity here that we didn''t have before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look at the highlighted code, you can see a new callback called
    `done`. This callback has one mission: prevent the test from finishing until it
    is called, so that the HTTP request has time to be executed and return the appropriated
    value. Remember, Node.js is asynchronous, there is no such thing as a thread being
    blocked until one operation finishes.'
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, we are using a new DSL introduced by `chai-http` to build get
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This language allows us to build a large range of combinations, consider the
    following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding request, we are submitting a form that looks like a login,
    so that in the `end()` function, we can assert the return from the server.
  prefs: []
  type: TYPE_NORMAL
- en: There are an endless number of combinations to test our APIs with `chai-http`.
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing – the necessary evil
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No matter how much effort we put in to our automated testing, there will always
    be a number of manual tests executed.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to do it just when we are developing our API, as we want
    to see the messages going from our client to the server, but some other times,
    we just want to hit our endpoints with a pre-forged request to cause the software
    to execute as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, we are going to take the advantage of Node.js and its dynamic
    nature to build a proxy that will sniff all the requests and log them to a terminal
    so that we can debug what is going on. This technique can be used to leverage
    the communication between two microservices and see what is going on without interrupting
    the flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we are going to use software called Postman to issue requests
    against our server in a controlled way.
  prefs: []
  type: TYPE_NORMAL
- en: Building a proxy to debug our microservices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'My first contact with Node.js was exactly due to this problem: two servers
    sending messages to each other, causing misbehavior without an apparent cause.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a very common problem that has many already-working solutions (man-in-the-middle
    proxies basically), but we are going to demonstrate how powerful Node.js is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you remember from the previous section, our `stop-words.js` program was running
    on the port `3000`. What we have done with this code is create a proxy using `http-proxy`,
    that tunnels all the requests made on the port `4000` into the port `3000` after
    logging the headers into the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the program after installing all the dependencies with the `npm install`
    command in the root of the project, we can see how effectively the proxy is logging
    the requests and tunneling them into the target host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a proxy to debug our microservices](img/B04889_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example is very simplistic, but this small proxy could virtually be deployed
    anywhere in between our microservices and give us very valuable information about
    what is going on in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Out of all the software that we can find on the Internet for testing APIs, Postman
    is my favorite. It started as a extension for Google Chrome, but nowadays, has
    taken the form of a standalone app built on the Chrome runtime.
  prefs: []
  type: TYPE_NORMAL
- en: It can be found in the Chrome web store, and it is free (so you don't need to
    pay for it), although it has a version for teams with more advanced features that
    is paid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface is very concise and simple, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Postman](img/B04889_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the left-hand side, we can see the **History** of requests, as well as the
    **Collections** of requests, which will be very handy for when we are working
    on a long-term project and we have some complicated requests to be built.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use again our `stop-words.js` microservice to show how powerful
    Postman can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the first thing is to make sure that our microservice is running.
    Once it is, let''s issue a request from Postman, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Postman](img/B04889_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As simple as that, we have issued the request for our service (using the **GET**
    verb) and it has replied with the text filtered: very simple and effective.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine that we want to execute that call over Node.js. Postman comes with
    a very interesting feature, which is generating the code for the requests that
    we issue from the interface. If you click on the icon under the save button on
    the right-hand side of the window, the appearing screen will do the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Postman](img/B04889_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It is quite an easy code to understand, especially if you are familiar with
    the HTTP library.
  prefs: []
  type: TYPE_NORMAL
- en: With Postman, we can also send cookies, headers, and forms to the servers in
    order to mimic the authentication that an application will fulfill by sending
    the authentication token or cookie across.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s redirect our request to the proxy that we created in the preceding section,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Postman](img/B04889_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have the proxy and the `stop-words.js` microservice running, you should
    see something similar to the following output in the proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Postman](img/B04889_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The header that we sent over with Postman, **my-awesome-header**, will show
    up in the list of raw headers.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to use Swagger to document APIs.
    Swagger is an API manager that follows the **Open API standard**, so that it is
    a *common language* for all the API creators. We will discuss how to write definitions
    and why it is so important to agree on how to describe resources.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting APIs with Swagger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation is always a problem. No matter how hard you try, it will always
    eventually go out of date. Luckily, in the past few years, there has been a push
    into producing a high quality documentation for REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: API managers have played a key role in it, and Swagger is particularly an interesting
    platform to look at. More than a module for documentation, Swagger manages your
    API in a such way that gives you a holistic view of your work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start installing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install Swagger system-wide, so it will be another command in our
    system. Now, we need to create a project using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will allow you to choose different web frameworks. We are going
    to choose Express, as it is the one that we have already been using. The output
    of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting APIs with Swagger](img/B04889_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot is showing how to start a project with Swagger
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can find a new folder, called `my-project`, that looks like the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting APIs with Swagger](img/B04889_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The structure is self-explanatory and it is the common layout of a Node.js
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`: Here, our API code will lay down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: All the configuration sits in here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules`: This is a folder with all the dependencies required to run
    our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: This is where Swagger has generated some dummy tests and where we could
    add our own tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swagger comes with an impressive feature: an embedded editor that allows you
    to model the endpoints of your API. In order to run it, from within the generated
    folder, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It will open Swagger Editor in the default browser, with a window similar to
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting APIs with Swagger](img/B04889_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Swagger makes use of **Yet Another Markup Language** (**YAML**). It is a language
    that is very similar to **JSON**, but with a different syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this document, we can customize a number of things, such as paths (routes
    in our application). Let''s take a look at the path generated by Swagger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition is self-documented. Basically, we will configure the parameters
    used by our endpoint, but in a declarative way. This endpoint is mapping the incoming
    actions into the `hello_world` controller, and specifically into the `hello` method,
    which is defined by the `id` operation. Let''s see what Swagger has generated
    for us in this controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This code can be found in the `api/controllers` folder of the project. As you
    can see, it is a pretty standard Express controller packed as a module (well-cohesioned).
    The only strange line is the first one in the `hello` function, where we pick
    up the parameters from Swagger. We will come back to this later, once we run the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the endpoint is the responses. As we can see, we are referencing
    two definitions: `HelloWorldResponse` for `http code 200` and `ErrorResponse`
    for the rest of the codes. These objects are defined in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is something really interesting, although we are using a dynamic language,
    the contract is being defined by Swagger so that we have a language-agnostic definition
    that can be consumed by a number of different technologies, respecting the principle
    of technology heterogeneity that we were talking about earlier in [Chapter 1](ch01.html
    "Chapter 1. Microservices Architecture"), *Microservices Architecture*, and [Chapter
    2](ch02.html "Chapter 2. Microservices in Node.js – Seneca and PM2 Alternatives"),
    *Microservices in Node.js – Seneca and PM2 Alternatives*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After explaining how the definition works, it is time to start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce an output that is very similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we follow the instructions of the output and execute the curl command,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Swagger is binding the `name` query parameter to the Swagger parameter specified
    in the YAML definition. This may sound bad, as we are coupling our software to
    Swagger, but it gives you an immense benefit: Swagger allows you to test the endpoint
    through the editor. Let''s see how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side of the editor, you can see a button with the **Try this
    operation** label, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting APIs with Swagger](img/B04889_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click it, it will present you a form that allows you to test the endpoint,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting APIs with Swagger](img/B04889_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a warning message on this form about cross-origin requests. We don't
    need to worry about it when developing in our local machine; however, we could
    have problems when testing other hosts using the Swagger Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information, visit the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a value for the **name** parameter, and after that, click on **Send Request**,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documenting APIs with Swagger](img/B04889_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a response example using Swagger Editor to test the endpoint
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that, for this test to work, our app server has to be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a project from the Swagger definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, we have been playing with Swagger and the generated project, but
    we are now going to generate the project from the `swagger.yaml` file. We will
    use the already generated project as a starting point, but we will add a new endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This endpoint might sound very familiar to you, as we unit tested it earlier
    in this chapter. As you probably know by now, the Swagger Editor is quite cool:
    it provides feedback as you type on, about what is going on in the YAML file,
    as well as saves the changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to download the Swagger code generator from [https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen).
    It is a Java project, so we are going to need the Java SDK and Maven to build
    it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Codegen is a tool that allow us to read the API definition from the Swagger
    YAML and build the basic structure for a project in a language of our choice,
    in this case, Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command in the root of the project should build all the submodules.
    Now, it is as easy as executing the following command in the root of the `swagger-codegen`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The Swagger code generator supports a number of languages. Here, the trick is
    that when using it for microservices, we can define the interface and then use
    the most appropriate technology to build our service.
  prefs: []
  type: TYPE_NORMAL
- en: If you go to the `my-project` folder, you should find the full structure of
    the project in there, ready to start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to test and document microservices. It is usually
    the forgotten activity in software development, due to the pressures to deliver
    new functionalities, but in my opinion, it is a risky decision. We have to find
    the balance between too much and very little testing. In general, we will always
    try to find the right proportion for unit, integration and end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about manual testing and the tools to efficiently test our
    software manually (there is always a component of manual testing).
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting point is the documentation and API management. In this case,
    we got to know Swagger, which is probably the most popular API manager that led
    to the creation of the Open API standard.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to go deeper in to the API world (there is a lot to learn in order
    to build a practical and efficient API), you should probably browse [http://apigee.com](http://apigee.com).
    Apigee are a company expert on building APIs and providing tools for developers
    and enterprises that could help you to build a better API.
  prefs: []
  type: TYPE_NORMAL
