- en: Code Analyzers in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will take a look at code analyzers and how they can assist
    developers to write better code. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding and installing analyzers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a code analyzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom code analyzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying your code analyzer within your organization only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With effect from Visual Studio 2015, developers have had the ability to create
    custom code analyzers that are specific to their project or their development
    team. Some development teams have a set of standards that they need to adhere
    to. Perhaps you are an indie developer and you would like to make your code conform
    to certain best practices. It doesn't really matter what your reason is; code
    analyzers open doors for developers.
  prefs: []
  type: TYPE_NORMAL
- en: You can be sure that the code you or your team ships measures up to your specific
    set of code quality standards. There are several code analyzers that can be downloaded
    from GitHub. We will be looking at one of those called CodeCracker for C#.
  prefs: []
  type: TYPE_NORMAL
- en: Finding and installing analyzers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are quite a few code analyzers on GitHub. A quick search returns 28 possible
    C# code analyzers out of 72 repository results. A few of these seem to be student
    projects. Check those out too; there is some very clever code in some of them.
    As for this recipe, we will be working with CodeCracker for C# to demonstrate
    how to install an analyzer from a NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_04_23.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All that you will be doing is downloading a NuGet package for your project.
    Other than that, there is nothing you specifically need to do in order to get
    ready.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start off by creating a new console application. You can call it whatever you
    like. In my example, I simply called it `DiagAnalyzerDemo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: From the Tools menu, select NuGet Package Manager and then Manage NuGet Packages
    for Solution....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Browse tab, search for `Code-Cracker`. The results should return the
    codecracker.CSharp NuGet package. Check the project you want to apply the NuGet
    package to and click on the Install button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual Studio will allow you to review the changes that are about to be made.
    Click on the OK button to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on I Accept when the license terms are displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the NuGet package is installed, the results will be displayed in the Output
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looking at your project you will notice that the CodeCracker.CSharp analyzer
    has been added under the Analyzers node in your Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: If you expand the CodeCracker.CSharp analyzer, you will see all the individual
    analyzers included in the NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: There is however a better place to review these analyzers from. From the Project
    menu, go to the `[project name]` properties menu item. In my case this is DiagAnalyzerDemo
    Properties....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Open button to open the rule set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: Here you will see a collection of all the analyzers available; from this screen,
    you can modify the action of specific analyzers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: In your code, add the following class. You can call it whatever you like, but
    for simplicity's sake use the following example. You will see that I have a constructor
    that sets a property called `DimensionWHL`. This property just returns an array
    with the `width`, `height`, and `length` values. Not very nice code indeed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Return back to the analyzers screen and search for the word `properties`. You
    will see an analyzer returned called CA1819, which specifies that a property should
    never return an array. The Action is changed to Warning, but you can change this
    to Error should you wish by clicking on the word Warning under the Action column
    and selecting Error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_12-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the changes and go and build your console application. You will see that
    the warning for the code analyzer CA1819 is displayed in the Error List. If you
    had changed the action to Error, the build would have broken with that error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_13.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code analyzers can provide you with a lot of functionality and assist developers
    in writing good code by avoiding common bad coding practices and enforcing specific
    team guidelines. Each code analyzer can be set to a different severity, with the
    most severe actually breaking the build. Keeping code analyzers under the references
    in your projects allows you to check it in to source control; this is evaluated
    whenever you build your project. You can however also store analyzers on a per-machine
    basis. These analyzers will be for personal code improvement, prompts, and personal
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Code analyzers are perfect for modern day developers because they are under
    the control of the developer and integrate easily into Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a code analyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of you might already see the benefit of creating your own code analyzer.
    Being able to control certain design implementations and coding standards specific
    to your team is invaluable. This is especially true for new developers joining
    your team. I remember when I started working for a company a couple of years back;
    the development manager gave me a document of code standards that I needed to
    adhere to. At the time this was great. It showed me that they cared about code
    standards. Back then, of course, developers didn't have code analyzers. It was
    however quite a challenge keeping track of all the standards that I needed to
    implement. This was especially true for the specific code standards that the company
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can create your own code analyzer, you need to ensure that you have
    installed the .NET Compiler Platform SDK. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new project to your solution and click on Extensibility. Select Download
    the .NET Compiler Platform SDK and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_14.png)'
  prefs: []
  type: TYPE_IMG
- en: This will actually create a project with an index file. The page that opens
    will provide a download to the .NET Compiler Platform SDK. Click on that to start
    the download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_15.png)'
  prefs: []
  type: TYPE_IMG
- en: Just save the downloaded file to a directory on your hard drive. Then you should
    close down Visual Studio before clicking on the VSIX file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_16.png)'
  prefs: []
  type: TYPE_IMG
- en: The .NET Compiler Platform SDK installer will now start and allow you to select
    the instance of Visual Studio to install to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the installation is complete, restart Visual Studio again.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_04_18.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a new project to your Visual Studio solution and click on Extensibility
    and select the Analyzer with Code Fix (NuGet + VSIX) template. Give it a suitable
    name and click on OK to create the Analyzer project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_19.png)'
  prefs: []
  type: TYPE_IMG
- en: You will see that Visual Studio has created three projects for you: `Portable`,
    `.Test` and `.Vsix` . Ensure that the `.Vsix` project is set as the default startup
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_20.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `Portable` class, take a look at the `DiagnosticAnalyzer.cs` file. You
    will see a method called `AnalyzeSymbol()`. All that this code analyzer does is
    simply check for the existence of lowercase letters on the `namedTypeSymbol` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Build your project and click on *F5* to start debugging. This will start a new
    instance of Visual Studio with its own settings. This means anything you change
    in this experimental instance of Visual Studio will not affect your current Visual
    Studio installation. You can open an existing project or create a new one. I simply
    created a console application. From the start, you will see that the `Program`
    class name is underlined. Hovering your cursor over this will display the Visual
    Studio lightbulb and tell you that the type name contains lowercase letters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_21.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on *Ctrl* + *.* or on the Show potential fixes link in the tooltip
    will display the fixes you can apply to correct the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_22.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code analyzers will check managed assemblies and report any information relevant.
    This can be any code that violates the programming and design rules in the .NET
    *Framework Design Guidelines*. The code analyzer will display the checks it performs
    as warning messages and if possible suggest a fix like we saw in the aforementioned
    recipe. To do this, code analyzers use rule sets created by Microsoft or a custom
    rule set you define to meet a specific need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom code analyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real magic of code analyzers come to the fore when you create one to suit
    a specific need. What would qualify as a specific need? Well anything that is
    specific to your own business requirements that is not covered in the out-of-the-box
    analyzers. Don't get me wrong; the existing analyzers that are available to developers
    really cover a lot of good programming practices. Just take a look on GitHub by
    searching for C# code analyzers.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, you might have a case where something is more suited to
    your workflow or the way your company does business.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is could be to ensure that comments on all public methods
    include more information than just the standard `<summary></summary>` and parameter
    information (if any). You might want to include an additional tag with the internal
    task ID, for example (think Jira here). Another example is making sure that a
    created class conforms to a certain XML structure. Are you developing software
    that writes warehouse stock information to a database? Do you use non-stocked
    parts? How do you validate non-stocked from stocked parts in code? Code analyzers
    can provide a solution here.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples are perhaps rather unique and not applicable to you or
    your needs at all, but that is the beauty of code analyzers. You can create them
    to suit your requirements. Let's take a look at a very simple example. Assume
    that developers in your organization need to use a specific code library. This
    code library is a collection of frequently used code and is well maintained. It
    is included in a Visual Studio template that developers use when creating new
    projects. We need to ensure that, if a developer creates a specific class (for
    purchase orders or sales orders), it implements a specific interface. The interfaces
    exist in the template, but the classes do not. This is because the applications
    will not always be using sales or purchase orders. The interface is to enable
    the receipt of sales and purchase orders and is called IReceivable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Visual Studio project and call it `PurchaseOrderAnalyzer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_24.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure that the following projects are created by default in your solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_25-1.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expand the `PurchaseOrderAnalyzer (Portable)` project and open the `DiagnosticAnalyzer.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen earlier, you will see your diagnostic analyzer class. It should read
    `public class PurchaseOrderAnalyzerAnalyzer : DiagnosticAnalyzer`. Add the following
    code to the top of this class, replacing the code for the `DiagnosticId`, `Title`,
    `MessageFormat`, `Description`, `Category`, and `Rule` variables. Note that I
    have added two enumerators called `ClassTypesToCheck` and `MandatoryInterfaces`
    to the class. I only want this analyzer to act on a class if it is called `PurchaseOrder`
    or `SalesOrder`. I also only want the `IReceiptable` interface to be mandatory
    on the classes defined in the `ClassTypesToCheck` enum.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the `Initialize` method contains the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Create the `AnalyzeSymbol` method. You can call this method anything you like.
    Just ensure that, whatever you call this method, it matches the method name in
    the `RegisterSymbolAction()` method inside `Initialize`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Add to that a Boolean called `blnInterfaceImplemented` that will store a `true`
    or `false` if the interface is implemented or not. The next check we do is to
    ignore abstract classes. In reality, you would probably want to check an abstract
    class too, but I want to exclude it to show the flexibility of code analyzers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You now need to get the name of the symbol you are checking. To do this, create an
    object called `namedTypeSymbol` on which you can call the `Name` method to return
    the symbol name. On a class called `PurchaseOrder`, this should return `PurchaseOrder`
    as the name. Return the `ClassTypesToCheck` enum as a `List<string>` object called
    `classesToCheck`. Then, do a check on the class name and see if it is contained
    in the `classesToCheck` list. It is important to ignore the case by adding `StringComparison.OrdinalIgnoreCase`
    to the `Equals` check. This will ensure that the analyzer will analyze classes
    called `purchaseorder`, `PURCHASEORDER`, `PurchaseOrder`, `Purchaseorder`, or
    `purchaseOrder`. Add the code inside the `if` condition excluding abstract classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The capitalization style recommended for class names is PascalCase. PascalCase
    consists of capitalizing the first letter of an identifier and each subsequent
    concatenated word. This is applied if the identifier has three or more characters.
    This means that the concatenated words purchase and order must we written in PascalCase
    when used in class names. This results in **P**urchase**O**rder. Refer to the Capitalization
    Styles article in the MSDN at [https://msdn.microsoft.com/en-us/library/x2dbyw72(v=vs.71).aspx](https://msdn.microsoft.com/en-us/library/x2dbyw72(v=vs.71).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `if` condition, to check if the class name is `PurchaseOrder` or
    `SalesOrder`, add the following code. Here we are going to check the interfaces
    defined on the matched `PurchaseOrder` or `SalesOrder` class. We do this by calling
    the `AllInterfaces()` method and checking to see if it matches the `nameof` the
    `IReceiptable` enumerator. In reality, we would probably want to check more than
    one interface, but for our purposes we're only checking for the implementation
    of the `IReceiptable` interface. If we find the interface as implemented on the
    class name that was matched in the earlier check, we set `blnInterfaceImplemented
    = true;` (it is currently initialized to `false`). This means that, if the interface
    is not matched, then we will produce a diagnostic for the omission of the `IReceiptable`
    interface. This is done by creating and reporting the diagnostic that contains
    the `Rule` defined earlier and the location of the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If all the code is added to `AnalyzeSymbol()` the method should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create a fix for the code analyzer. If we see that the class
    does not implement our interface, we want to provide a quick fix for the developer
    with the lightbulb feature. Open the file called `CodeFixProvider.cs`. You will
    see that it contains a class called `public class PurchaseOrderAnalyzerCodeFixProvider
    : CodeFixProvider`. The first thing to do is locate the `title` string constant
    and change it to a more suitable title. This is the menu flyout displayed when
    you click on the lightbulb in Visual Studio.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I have left most of the code-fix code the same except for the code that does
    the actual fix. Locate the method called `RegisterCodeFixesAsync()`. I renamed
    the method to call in the `RegisterCodeFix()` method to `ImplementRequiredInterfaceAsync()`.
    The code should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that I have re-purposed the fix used to make the symbol an uppercase
    to implement the interface. The rest of the code is left as-is. In reality, you
    would most likely want to check if any other interfaces are implemented on the
    class and maintain those implementations. For this demonstration, we're just assuming
    a new class being created called `PurchaseOrder` or `SalesOrder` without existing
    interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the `PurchaseOrderAnalyzer.Vsix` project is set as the start-up
    project and click on Debug. A new instance of Visual Studio will be launched.
    Create a new console application in this Visual Studio instance and call it `PurchaseOrderConsole`.
    To this project, add a new interface called `IReceiptable` and add the following
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, add a new class called `PurchaseOrder` to the project with the following
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After you have done this, your project might look as follows if you added separate
    files for `IReceiptable` and `PurchaseOrder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_27.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewing the `PurchaseOrder` class, you will notice a squiggly line under the
    class name `PurchaseOrder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_28.png)'
  prefs: []
  type: TYPE_IMG
- en: Hovering the mouse over the squiggly line, you will see the lightbulb displayed
    notifying you that the `IReceiptable` interface is not implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_29.png)'
  prefs: []
  type: TYPE_IMG
- en: When you view potential fixes, you will see that the `title` we changed earlier
    in the `CodeFixProvider.cs` file to read `private const string title = "Implement
    IReceiptable";` is displayed as the flyout menu text. The suggested code is then
    shown as implementing the correct interface `IReceiptable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on this modifies our `PurchaseOrder` class to produce the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once the code fix has been applied, you will see that the squiggly line under
    the class name has disappeared. As expected, Visual Studio is now telling us that
    we need to implement the interface member `IReceiptable.MarkAsReceipted(int)`
    by underlining the interface name `IReceiptable` with a red squiggly line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_31.png)'
  prefs: []
  type: TYPE_IMG
- en: Hovering over the `IReceiptable` interface name, you will see the lightbulb
     the code fix. This is the standard Visual Studio analyzer at work here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_32.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the fix to be applied implements the `IReceiptable` member and the
    `PurchaseOrder` class is correctly defined in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_33.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example in this recipe does not even begin to scratch the surface of what
    is possible with code analyzers. A great way to learn what is possible is to have
    a look at some of the code analyzers on GitHub. View the code and start writing
    your own code analyzers. As with most concepts in programming, the only way to
    learn this is to write the code. There is a wealth of information available on
    the Internet. A word of advice, though: before you start writing your code analyzers,
    take a look to see if there isn''t an analyzer that already does what you need
    (or is close to doing what you need).'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you need to ensure method comments include additional information,
    try to find an analyzer that already does something similar. If you find an analyzer
    that checks to see if public methods have comments, for example, you could easily
    retrofit this analyzer to suit your own needs. The best way to learn is to do,
    but everybody needs a starting point. Standing on the shoulders of others is part
    of learning new programming concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your code analyzer within your organization only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code analyzers are a fantastic method to check and correct code automatically.
    Sometimes, however, the analyzers you create will not be suitable for public consumption
    as they might contain proprietary information. With NuGet, you can create private
    repositories and share these with colleagues. You can use a shared location on
    a company server, for example, and easily manage NuGet packages from there.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you have a shared location accessible to all developers in your
    organization. This can be anywhere your network administrator has provided for
    shared file access. You will probably want to restrict the access of these packages
    to developers only. A nice solution is to create a storage account on Azure to
    share the NuGet packages to. This is the approach I followed here using a fictitious
    company I have called Acme Corporation.
  prefs: []
  type: TYPE_NORMAL
- en: I will not go through setting up a storage account on Azure, but I will talk
    about accessing it from your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you and your organization to consider using Azure. I will not expand
    much on the benefits of using Azure other than to say that it is an incredible
    time-saver. If I want to test a specific feature of an application on a particular
    OS, within minutes I am able to spin up a VM and connect to it via a remote desktop.
    It is immediately ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: After you have created your storage account on Azure, you will find the access
    keys on the Access keys tab.
  prefs: []
  type: TYPE_NORMAL
- en: Make a note of the keys and the Storage account name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_35.png)'
  prefs: []
  type: TYPE_IMG
- en: I also just created a File service called packages. To get here, click on Overview.
    Then, under the Services heading, click on Files. On the File service window,
    select packages and view the property information for the file share.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your storage account might differ from the examples in this book, depending
    on what you called it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_04_36.png)'
  prefs: []
  type: TYPE_IMG
- en: Make a note of the URL specified in the properties. Using the URL, map a network
    drive by changing the `https://` part to `\\` and any subsequent `/` to `\` in
    the path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_37.png)'
  prefs: []
  type: TYPE_IMG
- en: Add this path to the Folder textbox and ensure that you have checked Connect
    using different credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_38.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the storage account name as the username and one of the keys as the password.
    You now have a network drive mapped to your Azure Storage account.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a look at the `PurchaseOrderAnalyzer` project we created. You will see
    that there is a `tools` folder containing two PowerShell scripts called `install.ps1`
    and `uninstall.ps1`. It is here that you can specify any installation-specific
    resources or actions to take when uninstalling the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_34.png)'
  prefs: []
  type: TYPE_IMG
- en: Opening the `Diagnostic.nuspec` file, you will note that this contains information
    regarding the NuGet package you are about to deploy. Make a point of modifying
    this file accordingly as it contains information important to developers consuming
    your NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and build your code analyzer. You will see that a file called `PurchaseOrderAnalyzer.1.1.1.1.nupkg`
    has been created in the `bin` folder for your project. Copy that file to the mapped
    drive you created earlier in the Azure Storage account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside Visual Studio, add a new WinForms application. You can call this anything
    you like. You can now add the Storage account as a NuGet location. Go to Tools,
    NuGet Package Manager and click on Manage NuGet Packages for Solution.... You
    will notice that, next to the Package source, which is currently set to nuget.org,
    there is a small gear icon. Click on this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I created the Visual Studio WinForms application on a separate machine for this
    example, but if you do not have access to a separate machine, try using a VM to
    test this. If you do not have access to Azure, you can use VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_04_39.png)'
  prefs: []
  type: TYPE_IMG
- en: The Options screen allows you to add an additional source for NuGet packages
    by clicking on the green plus icon under Available package sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_40-1.png)'
  prefs: []
  type: TYPE_IMG
- en: At the bottom of the Options window, enter a suitable name for the location
    and enter the path to the Azure Storage account. This is the same path you entered
    when you mapped the network drive. Before clicking on OK, click on the Update
    button. Then click on the OK button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_41.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now change the Package source to set it to the Azure Storage account
    location you mapped to. Doing this and clicking on the Browse tab of the NuGet
    package manager will display all the packages on this file share. The information
    under the Options section to the right is the information you defined in the `Diagnostic.nuspec`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_42.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now go ahead and install the code analyzer NuGet package. When you have
    completed the installation, the code analyzer will be visible under the `Analyzers`
    node under `References` in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_43.png)'
  prefs: []
  type: TYPE_IMG
- en: The code analyzer also works exactly as expected. Create a class called `PurchaseOrder`
    and see the analyzer in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_04_44.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NuGet package is the easiest way to deploy code to a large audience or even
    a few developers. It takes all the heavy lifting out of sharing code and templates.
    It therefore makes perfect sense to use NuGet to deploy your code analyzers. Setting
    up a private repository using NuGet for sharing code within your organization
    is really simple.
  prefs: []
  type: TYPE_NORMAL
