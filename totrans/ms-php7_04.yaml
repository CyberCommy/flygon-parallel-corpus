- en: Magic Behind Magic Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP language allows for both, a procedural and an **object-oriented** (**OO**)
    way of writing code. Whereas the procedural way is more of a remnant of initial
    versions of PHP, nothing really stops us from writing fully procedural applications
    even today. While both approaches have their advantages and disadvantages, the
    OO way is by far the most dominant one nowadays, the advantages of which are more
    evident in robust and modular applications, which are nearly impossible to work
    on with the procedural style.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the individual features of the PHP OO model is vital to understand,
    write, and debug modern applications. The **magic methods** are one of the more
    interesting and often mystic features of the PHP language. They are the predefined
    class methods that the PHP compiler executes under some event, such as object
    initialized, object destroyed, object converted to string, object method accessed,
    object property accessed, object serialized, object deserialized, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the use of each of the magic methods available
    in PHP, as per the following list of sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Using __construct()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __destruct()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __call()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __callStatic()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __set()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __get()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __isset()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __unset()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __sleep()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __wakeup()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __toString()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __invoke()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __set_state()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __clone()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using __debugInfo()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage statistic across popular platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP language reserves all function names starting with `__` as magical.
  prefs: []
  type: TYPE_NORMAL
- en: Using __construct()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `__construct()` magic method represents a PHP constructor concept similar
    to that of other OO languages. It allows developers to tap into the object creation
    process. Classes that have the `__construct()` method declared, call it on each
    newly-created object. This allows us to deal with any initialization that the
    object may need before it is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the simplest possible use of the `__construct()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `User` instances will yield the same `string(11) "__construct"` output to
    the screen. The more complex example might include constructor parameters. Consider
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see a `__construct()` method that accepts the two parameters--`$name`
    and `$age`. Right after the `User` class definition, we have four different object
    initialization attempts. Attempt `#3` is the only valid initialization attempt.
    Attempts `#1` and `#2` trigger the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Attempt `#4`, even though invalid, does not trigger the error. PHP does not generate
    an error message, unlike with other methods, when `__construct()` is overridden
    with extra parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting case for the `__construct()` method is with the parent
    classes. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that parent constructors are not called implicitly if
    the child class defines a constructor. To trigger the parent constructor, we need
    to run `parent::__construct()` within the child constructor. Let''s amend our `Employee`
    class to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the output now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a simple `User` class with a magic `__construct()` and a static
    `hello()` method. Right after the class definition, we have a call towards the
    static `hello()` method. This does not trigger the `__construct()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only output from the preceding example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `__construct()` method only triggers when an object is being initiated via
    the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: We would want to keep our `__construct()` method, as well as other magic methods,
    under `public` access modifier only. However, if the situation demands it, we
    are free to throw in the `finally` access modifier in the mix as
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 's, the initialization attempts `#1` and `#2` would operate even with the `final`
    access modifier. This is because `#1` instantiates the original `User` class that
    defines the final `__construct()` method, and `#2` instantiates the empty `Director`
    class that does not try to implement its own `__construct()` method. The initialization
    attempt `#3` would fail, resulting in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is really the basis of access modifiers and overrides, not specific to
    the `__construct()` magic method itself. However, it is worth knowing that it
    is possible to use the `final` modifier with the constructor, as it might come
    in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from instantiating simple objects, the practical use of the `__construct()`
    method in OOP comes in the form of **dependency injection**. Nowadays, it is generally
    accepted that injecting dependencies is a for dealing with dependencies. While
    dependencies can be injected into an object through various setter methods, the
    use of the `__construct()` method prevails as a dominant approach with some of
    the leading PHP platforms, such as Magento.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block demonstrates the `__construct()` method of Magento''s
    `vendor/magento/module-gift-message/Model/Save.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are several dependencies being passed here via the `__construct()` method,
    which seems quite a step up from previous examples. Even so, the majority of Magento's `__construct()`
    methods are much more robust than this, passing on tens of parameters to the object.
  prefs: []
  type: TYPE_NORMAL
- en: We could easily summarize the role of the `__construct()` method as sort of
    a class signature that represents how a consumer should fully instantiate a particular
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Using __destruct()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alongside the constructor, the destructor is a common feature of the OO language.
    The `__destruct()` magic method represents this concept. The method gets triggered
    as soon as there are no other references to a particular object. This can happen
    either when PHP decides to explicitly free the object, or when we force it using
    the `unset()`  language construct.
  prefs: []
  type: TYPE_NORMAL
- en: As with constructors, parent destructors don't get called implicitly by PHP.
    In order to run a parent destructor, we need to explicitly call `parent::__destruct()`.
    Furthermore, the child class inherits the parent's destructor if it does not implement
    one for itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a following simple `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `User` class in place, let''s go ahead and look through instance creation examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new User();` expression here instantiates an instance of the `User` class
    into *thin air *as it does not assign the newly instantiated object into the variable.
    This is a trigger for PHP to explicitly call the `__destruct()` method right there
    on the same line, resulting in the `A__destructB` string :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `new User();` expression here instantiates an instance of `User` class into
    the `$user` variable. This prevents PHP from triggering instantly, as the script
    might use the `$user` variable further down the path. Still, PHP explicitly calls
    the `__destruct()` method when it concludes that the `$user` variable is not being
    referenced, resulting in the `AB__destruct` string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are extending the previous example a little bit. We are using the `unset()`
    language construct to force the destruction of the `$user` variable in between
    expressions. The call to `unset()` is basically an implicit trigger for PHP to
    execute the object's `__destruct()` method, resulting in the `AB__destructC` string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calling the `exit()` language construct right before the `C` string
    output. This serves as an implicit trigger for PHP that there are no more references
    towards the `$user` variable, and, therefore, the object's `__destruct()` method
    can be executed. The resulting output is the `AB__destruct` string.
  prefs: []
  type: TYPE_NORMAL
- en: Certain situations might tempt us to call the `exit()` constructor from within
    the `__destruct()` method itself. , because calling `exit()` within `__destruct()`
    prevents the remaining shutdown routines from executing. Likewise, throwing an
    exception from the `__destruct()` method will trigger a fatal error, but only
    if thrown at the time of script termination. This is, by no means, a way to handle
    our application states.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, destructors are not something we will want or need to implement
    on our own. Chances are that a great majority of our classes won't have a need
    for it, as PHP itself does a pretty good job of cleaning up. There are, however,
    cases where we might want to instantly release the resource consumed by the object
    after the object is not being referenced anymore. The `__destruct()` method allows
    certain follow-up actions during the object's termination.
  prefs: []
  type: TYPE_NORMAL
- en: Using __call()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overloading is a familiar term in OOP. However, not all programming languages
    interpret it in the same way. The PHP notion of overloading is quite different
    than that of other OO languages. Where traditionally overloading provides the
    ability to have multiple methods with the same name but different arguments, in
    PHP overloading means to dynamically create methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: unfortunate misuse of the term overloading adds a layer of confusion for some developers,
    as the more proper term for this type of functionality might have been *interpreter
    hooks*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two magic methods in PHP supporting method overloading: `__call()`
    and `__callStatic()`. Throughout this section, we will take a closer look at the
    `__call()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__call()` magic method is triggered when invoking inaccessible methods
    in an *object context*. This method accepts two parameters, as per the following
    synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However the `__call()` method parameters have the following meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$name`: This is the name of the method being called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$arguments`: This is an enumerated array containing the parameters passed
    to the `$name` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates the use of the `__call()` method in the
    object context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` class itself declared only the `__call()` and `bonus()` methods.
    The `$user` object tries to call the `hello()`, `bonus()`, and `salary()` methods.
    This effectively means the object is trying to call two missing methods: `hello()`
    and `salary()`. The `__call()` method kicks in for the missing two methods, thus
    yielding the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find a nice use case example of the `__call()` method in the Magento
    platform, as per the following entry taken from the `vendor/magento/framework/DataObject.php`
    class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Without getting into the details of Magneto itself, it''s suffice to say that
    their `DataObject` class serves as a root data object throughout the entire framework. The
    code within the `__call()` method enables it to magically *get*, *set*, *unset*,
    and *check* for the existence of the property on the object instance. This is
    used later in expressions, such as the following entry taken from the `vendor/magento/module-checkout/Controller/Cart/Configure.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit is that we have easily empowered instances of `DataObject` here
    with magical methods that might and might not exist. For example, `setCategoryId()`
    is a method that does not exist on the `DataObject` class. Since it does not exist,
    calling it triggers the `__call()` method. This might not be that obvious at first,
    so let''s consider another imaginary example where our custom class extends from
    `DataObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice the *beauty and simplicity* of *setters* and *getters* we have achieved
    here with the help of the `__call()` magic method. Even though our `User` class
    is basically empty, we have inherited the magic behind the parent's `__call()`
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `__call()` method empowers us with some truly interesting possibilities,
    most of which will fit right in as a part of frameworks or libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Using __callStatic()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `__callStatic()` magic is nearly identical to the `__call()` method. Where
    the `__call()` method is bound to the *object context*, the `__callStatic()` method
    is bound to the *static context,* which means this method is triggered when invoking
    inaccessible methods via the scope resolution operator (`::`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The method accepts two parameters as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the static access modifier in the method declaration that
    is required by the static context upon which this method operates. The following
    example demonstrates the use of the `__callStatic()` method in the static context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'code will yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` class itself declared only the `__callStatic()` and `bonus()` methods.
    The `User` class tries to call static `hello()`, `bonus()`, and `salary()` methods.
    This effectively means that the class is trying to call two missing methods: `hello()`
    and `salary()`. The `__callStatic()` method kicks in for the missing two methods,
    thus yielding the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In OO programming, the static context is less frequent than the object context, which
    makes the `__callStatic()` method less frequently used than the `__call()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using __set()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aside from *method overloading*, *property overloading* is another aspect of
    the PHP overloading capabilities. There are four magic methods in PHP that support
    the property overloading: `__set()`, `__get()`, `__isset()`, and `__unset()`.
    Throughout this section, we will take a closer look at the `__set()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The `__set()` magic method is triggered when trying to write data to inaccessible
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method accepts two parameters, as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas, the `__set()` method parameters have the following meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$name`: This is the name of the property being interacted with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$value`: This is the value that the `$name` property should be set to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following object context example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` class declares four properties with various access modifiers. It
    further declares the `__set()` method that intercepts all the property write attempts
    on the object context.  Attempting to set a non-existing (`$message`) or inaccessible (`$name`,
    `$age`) property triggers the `__set()` method. The inner workings of the  `__set()`
    method push the inaccessible data into the `$data` property array, which is visible
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: One practical use of the `__set()` method might be allowing the setting of a
    property was set to `true` during object construction; otherwise, throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to use any of the four property overloading methods (`__set()`, `__get()`,
    `__isset()`, and `__unset()`) in a static context would result in the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using __get()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__get()` magic method is triggered when trying to read the data from an
    inaccessible property. The method accepts a single parameter, as per the following
    synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `$name` argument is the name of the property being interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following object context example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` class defines four different properties, across three different
    visibility access modifiers. Since we don''t have getter methods to access all
    of the individual properties, the only directly accessible property is `public
    $salary`.  This is where the `__get()` method comes in handy, as it kicks in as
    soon as we try to access a nonexistent or otherwise inaccessible property. The
    resulting output of the preceding code comes down to the following four lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `age` and the `name` values are fetched from within the `$data` property
    as a result of the `__get()` method's inner workings.
  prefs: []
  type: TYPE_NORMAL
- en: Using __isset()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__isset()` magic method is triggered by calling the `isset()` or `empty()` language
    constructs on inaccessible properties. The method accepts a single parameter,
    as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `$name` argument is the name of the property being interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following object context example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `User` class defines a single protected array property called `$data`, and
    a magic `__isset()` method. The current method's inner workings simply do a name
    lookup against the `$data` array key names and return `true` if the key is found
    in the array, otherwise, `false`. The resulting output of the example is `bool(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Magento platform provides an interesting and practical use case for the `__isset()`
    method as part of its `vendor/magento/framework/HTTP/PhpEnvironment/Request.php`
    class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Magento\Framework\HTTP\PhpEnvironment\Request` class here represents the
    PHP environment and all of its possible request data. The request data can come
    from many sources: a query string, `$_GET`, `$_POST`, and others. The `switch`
    case traverses through several of these source data variables (`$params`, `$queryParams`,
    `$postParams`, `$serverParams`, `$envParams`, `$_COOKIE`) in order to find and
    confirm the existence of the request parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Using __unset()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__unset()` magic method is triggered by calling the `unset()` language
    constructs on inaccessible properties. The method accepts a single parameter,
    as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `$name` argument is the name of the property being interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following object context example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` class declares a single private `$data` array property, alongside
    the `__unset()` magic method. The method itself is quite simple; it merely calls
    for the `unset()` passing it the value at a given array key. We are trying to
    unset to the `$age` and `$salary` properties here. The `$salary` property does
    not really exist, neither as a class property nor as a `data` array key. Luckily,
    `unset()` won''t throw an `Undefined index` notice type of error, so we do not
    need additional `array_key_exists()` checks. The following resulting output shows
    the `$age` property being removed from the object instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We should not confuse the use of the `unset()` construct with the `(unset)`
    casting. These two are different operations, and as such the `(unset)` casting
    will not trigger the `__unset()` magic
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using __sleep()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object serialization is another important aspect of OOP. PHP provides a `serialize()`
    function that allows us to serialize a value passed to it. The result is a string
    containing a byte-stream representation of any value that can be stored in PHP.
    Serializing the scalar data types and simple objects is pretty straightforward,
    as per the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Even a simple custom class can be easily :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The issue occurs when our classes are either significant in size, or contain resource-type
    references. The `__sleep()` magic method addresses these challenges in a way.
    Its intended use is to commit pending data or perform related cleanup tasks. The
    function is useful when we have large objects that do not need to be serialized
    completely.
  prefs: []
  type: TYPE_NORMAL
- en: The  `serialize()` function triggers the object's `__sleep()` method if it exists.
    The actual triggering is done before the serialization process starts. This empowers
    the object to specifically list the fields it wants to allow for serialization.
    The return value of the `__sleep()` method must be an array with the names of
    all the object properties that we want to serialize. If the method doesn't return
    a serializable property name array, then `NULL` is serialized and `E_NOTICE` is
    issued.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a simple `User` class with a simple `__sleep()`
    method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `__sleep()` method clearly states that the only two
    serializable properties of a `User` class are `name` and `salary`. Notice how
    the actual names are provided as a string, without a `$` sign, which results in
    an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Serializing objects in order to store them in a database is a dangerous practice,
    and should be avoided by any means possible. Rare are the cases that require complex
    object serialization. Even those are likely a mark of improper application design.
  prefs: []
  type: TYPE_NORMAL
- en: Using __wakeup()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of serializable objects would not be complete without the `serialize()`
    method counterpart--the  `unserialize()` method. If the `serialize()` method call
    triggers the object's `__sleep()` magic method, it is logical to expect there
    is a similar behavior for deserialization. Rightfully so, calling the `unserialize()` method
    upon a given object triggers its `__wakeup()` magic method.
  prefs: []
  type: TYPE_NORMAL
- en: The intended use of `__wakeup()` is to reestablish any resources that might have
    been lost during serialization and perform other reinitialization tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Backup` class accepts host, username, and password information through
    its constructor. Internally, it sets the core PHP `ftp_connect()` function to
    establish a connection towards the FTP server. A successfully established connection
    returns a resource we store into a protected `$ftpClient` property of a class.
    Since resources are not serializable, we made sure to exclude it from the `__sleep()`
    method return array. This ensures that our serialized string does not contain
    the `$ftpHost` property. We have further set a `$this->connect();` call within
    the `__wakeup()` method to reinitialize the `$ftpHost` resource. The overall example
    results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `__wakeup()` method sort of takes on the role of constructor during the `unserialize()`
    function call. Because the object's `__construct()` method is not called during
    deserialization, we need to be careful to implement the necessary `__wakeup()`
    method logic so that the object can reconstruct any resources it might need.
  prefs: []
  type: TYPE_NORMAL
- en: Using __toString()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `__toString()` magic method triggers when we use an object in a string context.
    It allows us to decide how the object will react when it is treated like a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a simple `User` class that accepts the `$name` and `$age` parameters
    through its constructor method. Other than that, there is nothing else to indicate
    how the class should respond to the attempt of using it in the string context,
    which is exactly what we are doing right after the class declaration, as we are
    trying to `echo` the object instance itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its current form, the resulting output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__toString()` magic method allows us to circumvent this error in a simple
    and elegant :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `__toString()` magic method, we were able to tailor the resulting
    string representation of our object into the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The Guzzle HTTP client provides a practical use case example of the `__toString()`
    method through its PSR7 HTTP messaging interface implementations; whereas, some
    of the implementations make use of the  `__toString()` method. The following code
    snippet is a partial extract of Guzzle''s `vendor/guzzlehttp/psr7/src/Stream.php` class
    file that implements the `Psr\Http\Message\StreamInterface` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `try...catch` block is pretty much a norm in the case of any logic-rich
    `__toString()` implementations. This is because we cannot throw an exception from
    within a `__toString()` method. Therefore, we need to make sure no error escapes.
  prefs: []
  type: TYPE_NORMAL
- en: Using __invoke()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__invoke()` magic method gets triggered when the object is being called
    as a function. The method accepts an optional number of parameters and is is able
    to return various types of data, or no data at all, as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If an object class implements the `__invoke()` method, we can call the method by
    specifying parentheses `()` right after the object's name. This type of object
    is known as a functor or function object.
  prefs: []
  type: TYPE_NORMAL
- en: The Wikipedia page ([https://en.wikipedia.org/wiki/Functor](https://en.wikipedia.org/wiki/Functor))
    provides more information on the functor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code illustrates the simple `__invoke()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `__invoke()` method can be triggered either by using the object instance
    as a function or by calling `call_user_func()`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Using the `__invoke()` method, we *masquerade* our classes as .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: One of the benefits of using `__invoke()` is that it makes it possible to create
    a standard callback type across the language. This is much more convenient than using
    combinations of strings, objects, and arrays when referencing a function, object
    instance method, or class static method via the `call_user_func()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `__invoke()` method makes for powerful language additions as we perceive
    opportunities for new development patterns; although, its misuse can lead towards
    an unclear and messy code.
  prefs: []
  type: TYPE_NORMAL
- en: Using __set_state()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__set_state()` magic method is triggered (not really) for classes exported
    by the `var_export()` function. The method accepts a single array type parameter
    and returns an object, as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `var_export()` function outputs or returns a parsable string representation
    of a given variable. It is somewhat similar to the `var_dump()` function, except
    that the returned representation is a valid PHP
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Using the `var_export()` function does not actually trigger the `__set_state()`
    method of our `User` class. It merely yields a string representation of the `User::__set_state(array(...))` expression
    that we can either log, output, or pass through the `eval()` language construct
    for execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code is a more robust example demonstrating the use
    of `eval()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Knowing how the `eval()` language construct is very dangerous as it allows execution
    of arbitrary PHP code, its use is discouraged. Therefore, the use of `__set_state()` itself becomes
    questionable for anything other than debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Using __clone()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__clone()` magic method is triggered on newly cloned objects, where cloning
    is done using the `clone` keyword. The method does not accept any parameters nor
    does it return any values, as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to object cloning, we tend to differentiate deep copy and shallow
    copy. Deep copy copies everything--all of the objects an object might point to.
    Shallow copy copies as little as possible, leaving the object references as references
    where possible. While shallow copy might come in handy as a protection against
    circular references, replicating all properties whether they are references or
    values is not always the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the implementation of the `__clone()` method
    and the use of the `clone` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The important takeaway when it comes to the `__clone()` method is that it is not an
    override of the cloning process. The normal cloning process always occurs. The `__clone()`
    method merely takes on the responsibility of amending the wrong doing, where we
    might not normally be satisfied with the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Using __debugInfo()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__debugInfo()` magic method gets triggered when the `var_dump()` function
    is called. By default, the `var_dump()` function shows all public, protected,
    and private properties of an object. However, if an object class implements the
    `__debugInfo()` magic method, we get to control the output of the `var_dump()` function.
    The method does not accept any parameters, and returns an array of key-values to
    be shown, as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates the `__debugInfo()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: While the `__debugInfo()` method is useful for tailoring our own `var_dump()`
    output, this might not be something we will necessarily be doing in day-to-day
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Usage statistics across popular platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PHP ecosystem is massive to say the least. There are dozens of free and
    open source CMS, CRM, shopping cart, blog, and other platforms and libraries out
    there. WordPress, Drupal, and Magento are probably among the most popular ones
    when it comes to blogs, content management, and shopping cart solutions. They
    are all available for download from their respective websites:'
  prefs: []
  type: TYPE_NORMAL
- en: WordPress: [https://wordpress.org](https://wordpress.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drupal: [https://www.drupal.org](https://www.drupal.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magento: [https://magento.com/](https://magento.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Considering these popular platforms, the following table puts some perspective
    around the magic method use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Magic method** | **WordPress 4.7****(702 .php files)** | **Drupal 8.2.4****(8199
    .php files)** | **Magento CE 2.1.3****(29649 .php files)** |'
  prefs: []
  type: TYPE_TB
- en: '| `__construct()` | 343 | 2547 | 12218 |'
  prefs: []
  type: TYPE_TB
- en: '| `__destruct()` | 19 | 19 | 77 |'
  prefs: []
  type: TYPE_TB
- en: '| `__call()` | 10 | 35 | 152 |'
  prefs: []
  type: TYPE_TB
- en: '| `__callStatic()` | 1 | 2 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `__get()` | 23 | 31 | 125 |'
  prefs: []
  type: TYPE_TB
- en: '| `__set()` | 15 | 24 | 86 |'
  prefs: []
  type: TYPE_TB
- en: '| `__isset()` | 21 | 15 | 57 |'
  prefs: []
  type: TYPE_TB
- en: '| `__unset()` | 11 | 13 | 34 |'
  prefs: []
  type: TYPE_TB
- en: '| `__sleep()` | 0 | 46 | 103 |'
  prefs: []
  type: TYPE_TB
- en: '| `__wakeup()` | 0 | 10 | 94 |'
  prefs: []
  type: TYPE_TB
- en: '| `__toString()` | 15 | 181 | 460 |'
  prefs: []
  type: TYPE_TB
- en: '| `__invoke()` | 0 | 27 | 112 |'
  prefs: []
  type: TYPE_TB
- en: '| `__set_state()` | 0 | 3 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| `__clone()` | 0 | 32 | 68 |'
  prefs: []
  type: TYPE_TB
- en: '| `__debugInfo()` | 0 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: The table is a result of a crude `function __[magic-method-name]` search across
    an entire codebase of individual platforms. It's hard to draw any conclusions
    on top of it, as platforms differ significantly in number of `.php` files. One
    thing we can say for sure--not all magic methods are equally popular. WordPress,
    for example, does not even seem to use the `__sleep()`, `__wakeup()`, and `__invoke()` methods,
    which are of importance in OOP. This might be because WordPress does not handle
    as many OO components as Magento, for example, which is much more of an OOP platform
    in architectural sense. Drupal sort of sits in the middle here, in terms of total
    `.php` file numbers and the magic methods it uses. Inconclusive or not, the preceding
    table outlines the active use of pretty much every magic method PHP has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we took a detailed look into each and every magic method
    PHP has to offer. The ease of their use is equally impressive as the power they
    bring to the language. Simply naming our class methods appropriately, we were
    able to tap into pretty much every aspect of an object state and behavior. While
    most of these magic methods are not something we will be using on a day-to-day
    basis, their existence empowers us with some nifty architectural styles and solutions
    that are not that easily possible with other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will step into the realm of CLI and the more elusive use
    of PHP.
  prefs: []
  type: TYPE_NORMAL
