- en: Network Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](b108b814-40ec-42d5-ab03-cc3cd6400641.xhtml), *Pipes, First-In
    First-Out (FIFO), Message Queues, and Shared Memory*, we learned different IPC
    techniques to allow processes running on the same machine to communicate with
    each other. In this chapter, (which compliments what was covered in [Chapter 6](b108b814-40ec-42d5-ab03-cc3cd6400641.xhtml),
    *Pipes, First-In First-Out (FIFO), Message Queues, and Shared Memory*, you'll
    learn how two processes running on two different computers can achieve the same
    result. The topics presented here are the foundation of how the internet today
    works. You'll learn, hands-on, the difference between connection-oriented and
    connectionless-oriented communication, the characteristics that define an endpoint,
    and finally two recipes that will teach you how to use TCP/IP and UDP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of connection-oriented communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of connectionless-oriented communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning what a communication endpoint is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to use TCP/IP to communicate with processes on another machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to use UDP/IP to communicate with processes on another machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with endianness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let you start using the programs immediately, we've set up a Docker
    image that has all the tools and libraries that we'll need throughout the book.
    It is based on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Docker Engine from [www.docker.com](https://www.docker.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the image from Docker Hub using `docker pull kasperondocker/system_programming_cookbook:latest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should now be available. Type in `docker images` to view the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should have at least `kasperondocker/system_programming_cookbook` now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell by using `docker run -it --cap-add
    sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Use `root@39a5a8934370/#
    cd /BOOK/` to get all the programs, listed by chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is needed to allow **GNU Project Debugger** (**GDB**)
    in the Docker container to set breakpoints, which by default Docker does not allow.
    To launch a second shell on the same container, run the `docker exec -it container-name
    bash` command. You can get the container name from the `docker ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of connection-oriented communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you sit at your desk and you browse the internet, it is likely that you're
    using a connection-oriented type of communication. When you request a page via
    HTTP or HTTPS, under the hood, a connection between your machine and the server
    you're trying to contact is established before the actual communication takes
    place. The *de facto* standard for internet communications is the **Transport
    Control Protocol** (**TCP**). In this chapter, you will learn what it is and why
    it is important, and you will also learn (on the command line) what a connection
    is.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll explore use of the command line to understand what
    happens when we make a connection with a remote machine. Specifically, we''ll
    learn the internal aspects of a TCP/IP connection. Let''s go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Docker image running, open a shell, type the following command, and
    press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another shell, type the following command, and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first shell, you''ll see an output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5a48ff38-c4f1-4ee1-934f-f71da9db0be1.png)'
  prefs: []
  type: TYPE_IMG
- en: All of this might seem cryptic, but it's actually simple. The next section will
    explain to you, in great detail, how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A connection-oriented communication is based on the assumption that a connection
    between two entities is made. In this section, we'll explore what exactly a connection
    is.
  prefs: []
  type: TYPE_NORMAL
- en: The first step uses `tcpdump` (`man tcpdump`), which is a command-line tool
    that dumps all the traffic on a network. In our case, it writes all the TCP traffic
    from port `80` on the standard output showing the data in a hexadecimal representation.
    Once *Enter* is pressed, `tcpdump` will switch to listening mode.
  prefs: []
  type: TYPE_NORMAL
- en: The second step uses `telnet` to establish a connection with a remote service
    running on port `80` at `amazon.com`. Once *Enter* is pressed, after a few moments,
    the connection will be established.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third step, we see the output of the connection between the local machine
    through the `telnet` (or `man telnet` , to give it its full name) service and
    a remote machine at `amazon.com` (translated to the IP). The first thing to keep
    in mind is that a connection in TCP is a three-step process called a **three-way
    handshake**. The client sends *SYN*, the server replies *SYN+ACK*, and the client
    replies *ACK*. The following diagram represents the TCP header specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a90e0c44-8eec-4e64-b1de-f2cb80cfd1ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What data do the client and the server exchange in the *SYN* | *SYN+ACK* |
    *ACK* phase in order to successfully establish a connection? Let''s go through
    it, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client sends *SYN* to the server (`amazon.com`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/40eb9534-c86f-4741-9bba-1c40ba1910ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start from `0xe8f4` and `0x050` (the Ethernet header is before this, which
    is beyond the scope of this chapter). As we can see from the preceding TCP header,
    the first two bytes represent the source port (`0xe8f4` = `59636`) and the second
    two bytes represent the destination port (`0x0050` = `80`). In the next four bytes, the
    client sets a random number called the sequence number: `0x9bd0 | 0xb114`. The
    acknowledgment number is not set in this case. In order to mark this packet as
    *SYN*, the client has to set the *SYN *bit to `1` and indeed the value of the
    next two bytes is `0xa002`, which in binary is `1010 0000 0000 0010`. We can see
    that the second to last bit is set to 1 (compare this with the TCP header, as
    seen in the preceding screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: 'The server sends *SYN+ACK* to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e30cbd29-ea67-47fc-92dd-8dad6943277d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The server, which has received the *SYN* from the client, has to respond with
    *SYN+ACK*. Leaving out the first 16 bytes, the Ethernet header, we can see the
    following content: 2 bytes represent the source port (`0x0050` = `80`) and the
    second 2 bytes represent the destination port (`0xe8f4` = `59636`). Then we start
    to see a few interesting things: the server puts a random number in the sequence
    number, which in this case is `0x1afe = | 0x5e1e`, and in the acknowledgment number,
    the sequence number received from the client + 1 = `0x9bd0 | 0xb11**5**`. As we
    learned, the server must set the flag to *SYN+ACK* and, according to the TCP header,
    the specification is correctly implemented by setting the two bytes to `0x7012`
    = `0111 0000 000**1** 00**1**0`. The highlighted parts are *ACK* and *SYN* respectively.
    The TCP packet is then sent back to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client sends *ACK* to the server (`amazon.com`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/626f2c3e-2a7b-4b54-9cb3-a082f5324929.png)'
  prefs: []
  type: TYPE_IMG
- en: The last step of the three-way handshake algorithm is the reception of the ACK
    packet sent by the client to the server. The message consists of two bytes representing
    the source port (`0xe8f4` = `59636`) and the destination port (`0x050` = `80`);
    the sequence number this time contains the value the server originally received from
    the client, `0x9bd0 | 0xb115`; and the acknowledgement number contains the random
    value received from the server + 1: `0x1afe = | 0x5e1**f**`. Finally, the *ACK*
    is sent by setting the value `0x5010` = `0101 0000 000**1** 0000` (the part of
    the value that is highlighted is the *ACK*; compare it to the previous TCP header
    picture).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The protocol you have learned so far is described in the RFC 793 ([https://tools.ietf.org/html/rfc793](https://tools.ietf.org/html/rfc793)).
    If the internet works, it is because all the network vendors, device driver implementations,
    and many programs implement this RFC (and other related standards) perfectly.
    The TCP RFC defines much more than what we've learned in this recipe, which was
    strictly focused on the connectivity. It defines the flow control (through the
    concept of a window) and reliability (through the concept of a sequence number
    and the *ACK* in it).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning to use TCP/IP to communicate with processes on another machine* recipe shows
    programmatically how two processes on two machines can communicate. The connection
    part is hidden in a system call, as we'll see.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*, for a refresher on processes and threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of connectionless-oriented communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Learning the basics of connection-oriented communication* recipe, we
    learned that a connection-oriented communication with flow control is reliable. To
    make two processes in communication, we must establish a connection first. This
    obviously comes at a cost in terms of performance, which we cannot always pay—for
    example, when you watch an online movie, the available bandwidth might not be
    enough to support all the features that TCP takes with it.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it is likely that the underlying communication mechanism is connectionless.
    The *de facto* standard protocol for connectionless communication is the **User
    Data Protocol** (**UDP**), which is on the same logical level as TCP. In this
    recipe, we'll learn what UDP looks like on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll use `tcpdump` and `netcast` (`nc`) to analyze a connectionless
    link over UDP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Docker image running, open a shell, type the following command, and
    press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open another shell, type the following command, and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first shell, you''ll see an output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e671d1fb-07cb-4c1a-a09e-5187ebd9b0e9.png)'
  prefs: []
  type: TYPE_IMG
- en: This seems cryptic too, but it's actually simple. The next section will explain
    the steps in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a UDP connection, there is no concept of connection. In this case, a packet
    is sent to a receiver. There is no flow control and the link is not reliable.
    The UDP header is indeed very simple, as you can see from the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a29b794e-a166-43b2-96de-6adc69398346.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Step 1* uses `tcpdump` to listen on port `45998` using the `UDP` protocol
    on the `loopback` interface (`-i lo`) by printing the data of each packet in `hex`
    and `ASCII`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* uses the `netcast` command `nc` (`man nc`) to send a UDP packet (`-u`)
    containing the string `welcome` to the localhost.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* shows the details of the UDP protocol. We can see that the source
    port (randomly picked by the sender) is `0xdb255` = `56101` and the destination
    port is correctly set to `0xb3ae` = `459998`. Next, we set the length to `0x000f`
    = `15` and the checksum to `0xfe22` = `65058`. The length is `15` bytes, as `7`
    bytes is the length of the data received and `8` bytes is the length of the UDP
    header (source port + destination port + length + checksum).'
  prefs: []
  type: TYPE_NORMAL
- en: No retransmission, no control flow, no connection. A connectionless link is
    really just a message the sender sends to the receiver knowing that it might not
    receive it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've talked about connections and we've seen the concepts of the source port
    and destination port in the UDP header. The address of the sender and receiver
    is stored somewhere else, in the **IP** (short for **Internet** **Protocol**)
    layer, logically right below the UDP layer. The IP layer has the information of
    the sender and receiver addresses (the IP addresses), which are used to route
    the UDP packet from the client to the server and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The UDP is elaborately defined in RFC 768, at [https://www.ietf.org/rfc/rfc768.txt](https://www.ietf.org/rfc/rfc768.txt).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting Started with
    System Programming*, for a review of the pipe of commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning the basics of a connectionless-oriented communication* recipe for
    a comparison with the TCP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning what a communication endpoint is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When two entities communicate with each other they essentially exchange information.
    In order to make this happen, each entity must be clear as to where to send the
    information. From the programmer's point of view, each entity involved in the
    communication must have a clear endpoint. This recipe will teach you what an endpoint
    is and will show, on the command line, how to identify them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll be using the `netstat` command-line utility to inspect
    and learn what an endpoint is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Docker image running, open a shell, type the following command, and
    press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a second shell and type this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next section will explain these two steps.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 1*, we used the `telnet` utility to connect to the local machine,
    with the `amazon.com` remote host on port `443` (HTTP). The output of this command
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62b15a2f-680e-4b7e-af13-a937e1bc9e0a.png)'
  prefs: []
  type: TYPE_IMG
- en: It is waiting for commands, which we won't send, as what we really care about
    is the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 2*, we want to know the details of the connection that we established between
    our local machine (`localhost`) and the remote host (`amazon.com` port `443`).
    For this, we executed the command in *step 2*. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/027525f4-3f59-4b27-b3c6-6ef58b76f388.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What information can we retrieve from the output in this command line? Well,
    we can retrieve a few very useful pieces of information. Let''s go through what
    we can learn from the preceding screenshot, reading the code from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tcp` represents the type of connection. It is a connection-oriented connection,
    which means that the local and remote hosts went through the three-way handshake
    that we saw in the *Learning the basics of connection-oriented communication*
    recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Recv-Q` is a queue containing the data to be processed by the current process
    on localhost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Send-Q` is a queue containing the data to be sent by the current process on
    localhost to a remote process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Local Address` is a combination of the IP address and port number, which really
    represent the first endpoint of our communication, the local endpoint. Such an
    endpoint is often called, from a programming perspective, `Socket`, which is an
    integer representing, in its essence, `IP` and `PORT`. In this case, the endpoint
    is `172.17.0.2:40850`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Foreign Address`, like the `Local Address`, is a combination of `IP` and `PORT`,
    and represents the remote endpoint, in this case, `176.32.98.166:443`. Note that
    `443` is a well-known port and represents the `https` service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`State` represents the state of the connection between the two endpoints, `ESTABLISHED` in
    this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PID/Program Name`, or in our case, `65`/`telnet`, represents the local process
    using both the endpoints to communicate with the remote host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When programmers talk about `socket`, they are talking about `IP` and `PORT`
    for each endpoint of the communication. As we've seen, Linux makes it easy to
    analyze both the endpoints of the communication and the process they are attached
    to.
  prefs: []
  type: TYPE_NORMAL
- en: One important aspect to highlight is that a `PORT` represents a service. In
    our example, the local process telnet was connected with the remote host using
    IP `176.32.98.166` at port `80`, where we know an HTTP daemon is running. But
    how do we know the port number for a specific service? There is a list of well-known
    ports ([https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)) maintained
    by the **IANA** (short for the **Internet Assigned Numbers Authority**), which
    assigns `PORTS` to services. For example, the HTTPS service is expected to run
    at `PORT 443`, the `sftp` (short for **Secure File Transfer Protocol**) runs at
    `PORT 22`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `port` info is a 16 bits unsigned integer value (that is, `unsigned int`),
    is maintained by the IANA ([https://www.iana.org/](https://www.iana.org/)) and
    is split into these ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '0-1023: Well-known ports. Ports that are well known, for example, HTTP, SFTP,
    and HTTPS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1024-49151: Registered ports. Ports that organizations can ask to register
    for their purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 49152-65535: Dynamic, private, or ephemeral ports. Free to be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning the basics of connectionless-oriented communication* recipe to
    learn how communication without a connection works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning the basics of connection-oriented communication* recipe to learn
    how communication with a connection works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning to use TCP/IP to communicate with processes on another machine* recipe
    to learn how to develop a connection-oriented program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning to use UDP/IP to communicate with processes on another machine*
    recipe to learn how to develop a connectionless-oriented program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to use TCP/IP to communicate with processes on another machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to connect two programs by using a connection-oriented
    mechanism. This recipe will use TCP/IP, which is the *de facto* standard on the
    internet. So far, we've learned that TCP/IP is a reliable form of communication,
    and its connection is made in three phases. It is time now to write a program
    to learn how to make two programs communicate with each other. Although the language
    used will be C++, the communication part will be written using the Linux system
    calls, as it is not supported by the C++ standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll develop two programs, a client and a server. The server will start and
    `listen` on a specific port that is ready to accept an incoming connection. The
    client will start and connect to the server identified by an IP and a port number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Docker image running, open a shell and create a new file, `clientTCP.cpp`.
    Let''s add some headers and constants that we''ll need later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start writing the `main` method now. We start by initializing `socket`
    and getting the information that is related to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to `connect` to the server, but we need the correct information,
    namely the `serv_addr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will reply with a connection `ack`, so we call the `read` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now send the data to the server by just calling the `write` system call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s go through the cleaning part, where we have to close the socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now develop the server program. In a second shell, we create the `serverTCP.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On a second shell, first of all, we need a `socket` descriptor that will identify
    our connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to bind the `socket` to a port and `serv_addr` on the local machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to wait for and accept any incoming connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we get a connection, we log who connected to the standard output (using
    their IP and port) and send a confirmation *ACK*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We made the connection (a three-way handshake, remember?), so now we can read
    any data coming from the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we close both the sockets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've written quite a lot of code, so it is time to explain how all of this
    works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both the client and the server have a very common algorithm, which we have
    to describe in order for you to understand and generalize this concept. The client''s
    algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, `connect()` and `receive()` are blocking calls (that is, the calling program
    will wait for their completion). The `connect` phrase specifically initiates the
    three-way handshake that we described in detail in the *Learning the basics of
    connection-oriented communication* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server''s algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, `accept` and `receive` are blocking the call. Let's now analyze in detail
    both the client's and server's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client code analysis is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step just contains the necessary includes that are needed to correctly
    use the four APIs that we listed in the preceding client's algorithm section.
    Just note that the constants, in pure C++ style, are not defined using the `#define`
    macro, but by using `constexpr`. The difference is that the latter is managed
    by the compiler, whereas the former is managed by the preprocessor. As a rule
    of thumb, you should always try to rely on the compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `socket()` system call creates a socket descriptor that we named `sockfd`,
    which will be used to send and receive information to/from the server. The two
    parameters indicate that the socket will be a TCP (`SOCK_STREAM`)/IP (`PF_INET`)
    socket type. Once we have a valid socket descriptor, and before calling the `connect`
    method, we need to know the server's details; for this, we use the `gethostbyname()` method,
    which, given a string like `localhost`, will return a pointer to `struct hostent
    *` with information about the host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're now ready to call the `connect()` method, which will take care of the
    three-way-handshake process. By looking at its prototype (`man connect`), we can
    see that as well as the socket, it needs a `const struct sockaddr *address` struct,
    so we need to copy the respective information into it and pass it to the `connect()`;
    that's why we use the `utility` method `bcopy()` (`bzero()` is just a helper method
    to reset the `sockaddr` struct before using it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to send and receive data. Once the connection is established,
    the server will send an acknowledgment message (`You are connected!`). Have you
    noticed that we're using the `read()` method to receive information from the server
    through a socket? This is the beauty and simplicity of programming in a Linux
    environment. One method can support multiple interfaces—indeed, we're able to
    work with the same method to read files, receive data with sockets, and do many
    other things.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can send a message to the server. The method used is, as you may have guessed,
    `write()`. We pass `socket` to it, which identifies the connection, the message
    we want the server to receive, and the length of the message so that Linux will
    know when to stop reading from the buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, we need to close, clean, and free any resource used. In this case,
    we have to close the socket by just using the `close()` method, passing the socket
    descriptor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server code analysis is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We use a similar code to the one we used for the client, but include some headers
    and three defined constants, which we will use and explain later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to define a socket descriptor by calling the `socket()` API. Note that
    there is no difference between the client and the server. We just need a socket
    that is able to manage a TCP/IP type of a connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to bind the socket descriptor created in the previous step to the network
    interface and port it on the local machine. We do this with the `bind()` method,
    which assigns an address (`const struct sockaddr *address` passed as the second
    parameter) to the socket descriptor passed as the first parameter. The call to
    the `setsockopt()` method is just to avoid the bind error, `Address already in
    use`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start listening for any incoming connection by calling the `listen()` API.
    The `listen()` system call is pretty simple: it gets the `socket` descriptor on
    which we are listening and the maximum number of connections to keep in the queue
    of pending connections, which in our case we set to `5`. Then we call `accept()`
    on the socket descriptor. The `accept` method is a blocking call: it means that
    it''ll block until a new incoming connection is available, and then it''ll return an
    integer representing the socket descriptor. The `cli_addr` structure is filled
    in with the connection''s information, which we use to log who connected (`IP`
    and `port`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This step is just a logical continuation of step 10. Once the server accepts
    a connection, we log on the standard output who connected (in terms of their `IP` and `port`).
    We do this by querying the information that was filled in the `cli_addr` struct
    by the `accept` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this step, we receive information from the connected client through the `read()`
    system call. We pass in the input, the socket descriptor of the incoming connection,
    the `buffer` where the data will be saved, and the maximum length of the data
    that we want to read (`MAX_BUFFER-1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then clean up and free any eventual resource that is used and/or allocated.
    In this case, we have to close the two sockets' descriptors that were used (`sockfd`
    for the server and `incomingSock` for the incoming connection).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By building and running both the server and the client (in this order), we
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server build and output are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6cb2d008-c48a-4572-95b5-c20f08518f1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The client build and output are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/56ff6da3-b779-438d-95c5-6821223a16ac.png)'
  prefs: []
  type: TYPE_IMG
- en: This proves what we learned in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How can we improve the server application to manage multiple concurrent incoming
    connections? The server''s algorithm that we implemented is sequential; after
    `listen()`, we just wait on `accept()` until the end, where we close the connections.
    You should go through the following steps as an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Run an infinite loop over `accept()` so that a server is always up and ready
    to serve clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spin off a new thread for each accepted connection. You can do this by using
    `std::thread` or `std::async`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another important practice is to pay attention to the data that the client and
    server exchange with each other. Usually, they agree to use a protocol that they
    both know. It might be a web server, which in that case will involve the exchange
    of HTML, files, resources, and so on between the client and the server. If it
    is a supervision and control system, it might be a protocol defined by a specific
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*, to refresh your memory as to how processes and threads work to improve
    the server solution described here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning the basics of connection-oriented communication* recipe to learn
    how the TCP connection works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning what a communication endpoint* recipe to learn what an endpoint
    is and how it is related to a socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to use UDP/IP to communicate with processes on another machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a process communicates with another, reliability is not always the main
    criterion to use when deciding the communication mechanism. Sometimes, what we
    need is fast communication without the burden or the connection, flow control,
    and all the other controls that the TCP protocol implemented to make it reliable.
    This is the case for video streaming, **Voice over Internet Protocol** (**VoIP**)
    calls, and many others. In this recipe, we'll learn how to program UDP code that
    makes two (or more) processes communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll develop two programs, a client and a server. The server will start,
    bind the socket to a local address, and then will just receive data from the clients:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Docker image running, open a shell, create a new file, `serverUDP.cpp`,
    and add some headers and constants that we''ll need later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we have to instantiate the socket of the `DATAGRAM `type and
    set the option to reuse the address each time the server is rerun:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to bind the socket we''ve created with a local address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to receive packets from the clients, this time using the `recvfrom`
    API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to send an *ACK* message to the client with the `sendto` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can close the socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create the client program. On another shell, create the file `clientUDP.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to instantiate the socket of the `datagram` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to get the host information to be able to identify the server that
    we want to send the packet to, and we do this by calling the `gethostbyname` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s copy the host information into the `sockaddr_in` struct to identify
    the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can finally send a message to the server using the socket descriptor, the
    message from the user, and the server address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the server will reply with an *ACK*, so let''s receive it with
    the `recvfrom` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as usual, we take care of closing and freeing all the structures used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's go deeper into the code and see how all of this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Learning to use TCP/IP to communicate with processes on another machine*
    recipe, we learned the client''s and server''s TCP algorithms. The UDP algorithms
    are simpler and, as you can see, the connection part is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The UDP client''s algorithm:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**The UDP server''s algorithm:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note how much simpler they are now—for example, the server, in this case, does
    not `listen` for and `accept` incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server-side code analysis is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We just defined some headers and two constants that represent the port where
    the server will expose the service (`SERVER_PORT`) and the maximum size of the
    data (`MAX_BUFFER`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this step, we defined the socket (`sockfd`), just like we did in the TCP
    code, but this time we use the `SOCK_DGRAM` (UDP) type. In order to avoid the
    bind issue of `Address already in use`, we set the option to allow the socket
    to reuse the address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next is the `bind` call. It accepts the parameters of `int socket`, `const struct
    sockaddr *address`, and `socklen_t address_len`, which are basically the socket,
    the address to bind the socket at, and the length of the address struct. In the
    `address` variable, we specify that we are listening to all the available local
    network interfaces (`INADDR_ANY`) and we will use the Internet Protocol version
    4 (`AF_INET`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now start receiving data by using the `recvfrom` method. The method takes
    as input the socket descriptor (`sockfd`), the buffer to store the data in (`buffer`),
    the maximum size of data we can store, a flag (`0`, in this case) to set the specific
    properties on the received message, the address of the sender of the datagram
    (`cli_addr`), and the length of the address (`len`). These last two parameters
    are returned filled in, so we'd know who sent the datagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now send an *ACK* to the client. We use the `sendto` method. As the UDP
    is a connectionless protocol, we don't have a client connected, so we need to
    pass this information somehow. We do this by passing the `cli_addr`, which is returned
    filled in by the `recvfrom` method along with the length (`len`), to the `sendto`
    method. Other than this, we need to pass the socket descriptor (`sockfd`), the
    buffer to send (`outBuffer`), the length of the buffer (`outBuffer.length()`),
    and the flag (`0`, in this case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we just need to clean up at the end of the program. We have to close the
    socket descriptor with the `close()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The client-side code analysis is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In this step, we find the same headers that we have on the `serverUDP.cpp` source
    file with `SERVER_PORT` and `MAX_BUFFER`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to define the socket of the datagram type by calling the `socket` method,
    passing again as input `AF_INET` and `SOCK_DGRAM`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we need to know who to send the datagram to, the client application takes
    as input on the command line the address of the server (for example, `localhost`)
    that we pass as input to the `gethostbyname`, which returns the host address (`server`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `server` variable to fill the `serv_addr` structure used to identify
    the address of the server that we want to send the datagram to (`serv_addr.sin_addr.s_addr`),
    the port (`serv_addr.sin_port`), and the family of the protocol (`AF_INET`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then use the `sendto` method to send the user message to the server by
    passing the parameters of `sockfd`, `outBuffer`, `MAX_BUFFER`, the flag set to `0`,
    the address of the server `serv_addr`, and its length (`len`). Again, the client
    does not know at this stage who is the receiver of the message as it is not connected
    to anybody, and that is why the `serv_addr` structure must be properly filled
    in so that it contains a valid address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We know that the server will send back an application *ACK*, so we have to receive
    it. We call the `recvfrom` method that is passing the socket descriptor (`sockfd`)
    as input, the buffer to store the returned data in (`buffer`), the maximum size
    of the data we can get, and a flag set to `0`. `recvfrom` returns the address
    of the sender of the message with its length, which we store in `cli_addr` and
    `len` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's run the server, then the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdbbe7da-c8df-4197-912f-246ee3751e02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a159ad9-61df-452c-91f6-b98de7bbfb2a.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows how UDP works.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way of using the UDP protocol, as a type of connectionless communication,
    is to send a datagram in multicast or broadcast format. A multicast is a communication
    technique that is used to send the same datagram to multiple hosts. The code does
    not change; we just have to set the IP of the multicast group so it knows where
    to send the message. It is a convenient and efficient way of communicating *one-to-many*,
    saving a lot of bandwidth. Another alternative is to send a datagram in broadcast
    mode. We have to set the IP of the receiver with a subnet mask in the form of `172.30.255.255`.
    The message will be sent to all the hosts in the same subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re invited to improve the server code by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up an infinite loop over `recvfrom()` so that you always have a server up
    and ready to serve clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new thread for each accepted connection. You can do this by using `std::thread` or `std::async`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*, to refresh how processes and threads work to improve the server
    solution described here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning the basics of connectionless-oriented communication* recipe to
    learn how the UDP connection works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning what a communication endpoint is* recipe to learn what an endpoint
    is and how it is related to a socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with endianness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code at system level might mean dealing with different processors' architectures.
    When doing this, there is one thing that programmers had to take care of by themselves
    before C++20, which is **endianness**. Endianness refers to the byte's order in
    the binary representation of a number. Fortunately, the last C++ standard helps
    us to enter endian information at compile time. This recipe will teach you how
    to be aware of endianness and write code that can run on both little- and big-endian
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll develop a program that will query the machine at compile time, so that
    we can make a conscious decision as to how to deal with numbers represented in
    different formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the `<bit>` headers file; then we can use the `std::endian`
    enumerations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a closer look at what implications this has in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Big-endian and little-endian are the two dominant types of data representation.
    The little-endian ordering format means that the least significant byte (also
    known as **LSB**) is placed in the highest address, while in a big-endian machine,
    the most significant byte (also known as **MSB**) is placed in the lowest address.
    An example of the representation for the hexadecimal value `0x1234` would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Address** | **Address+1 (byte)** |'
  prefs: []
  type: TYPE_TB
- en: '| **Big-endian** | `12` | `34` |'
  prefs: []
  type: TYPE_TB
- en: '| **Little-endian** | `34` | `12` |'
  prefs: []
  type: TYPE_TB
- en: 'The main goal of the code snippet in step 1 is to answer the question: how
    do I know what machine architecture I''m dealing with? The new C++20 enumeration
    `std::endian` helps us solve this problem perfectly. How? Well, first in terms
    of *endian awareness.* Having `std::endian` as part of the C++ standard library
    helps the programmer to query at any time the endian architecture of the underlying
    machine. Second: for shared resources, the two programs have to agree on a format
    (like the TCP protocol does, that is, sending the info in *network order*) so
    that the reader (or receiver, if exchanging data over the network) can make the
    appropriate conversions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other question is: what should I do? There are two things that you should
    do: one is related to the application point of view and the second is related
    to networking. In both cases, if your application exchanges data with another
    machine with a different endian format (a file exchanged, or a filesystem shared,
    among many others) or sends data over the internet to a machine with a different
    architecture, then you have to make sure that your data will be understood. To
    do this, you can use the `hton`, `ntoh` macro and friends; this makes sure that
    the number is converted from host to network (for `hton`) and from network to
    host (for `ntoh`). We have to mention that most of the internet protocols use
    the big-endian format, which is the reason why, if you call `hton` from a big-endian
    machine, the function will not perform any conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: The Intel x86 family and the AMD64 series of processors use all the little-endian
    format, while the IBM z/Architecture, Freescale, and all the Motorola 68000 heritage
    processers use the big-endian format. There are some processors (such as the PowerPC)
    that can switch endianness.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In theory, data representation formats other than little- and big-endian do
    exist. An example is the middle-endian format used by the Honeywell 316 minicomputer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning to use TCP/IP to communicate with processes on another machine*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning to use UDP/IP to communicate with processes on another machine*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
