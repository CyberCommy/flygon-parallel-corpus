- en: Gathering Platform and Compiler Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Detecting an OS and compiler
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting int128 support
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and bypassing disabled RTTI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing metafunctions using simpler methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing code size and increasing the performance of user-defined types (UDTs)
    in C++11
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The portable way to export and import functions and classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the Boost version and getting latest features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different projects and companies have different coding requirements. Some of
    them forbid exceptions or RTTI, while some forbid C++11\. If you are willing to
    write portable code that can be used by a wide range of projects, this chapter
    is for you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Want to make your code as fast as possible and use the latest C++ features?
    You'll definitely need a tool for detecting compiler features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers have unique features that may greatly simplify your life. If
    you are targeting a single compiler, you can save many hours and use those features.
    No need to implement their analogs from scratch!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is devoted to different helper macros used to detect compiler,
    platform, and Boost features. These macro are widely used across Boost libraries
    and are essential for writing portable code that is able to work with any compiler
    flags.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Detecting an OS and compiler
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m guessing you''ve seen a bunch of ugly macros to detect the compiler on
    which the code is compiled. Something like this is a typical practice in C word:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, try to come up with a good macro to detect the GCC compiler. Try to make
    that macro usage as short as possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the following recipe to verify your guess.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ is required.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe is simple and consists of a single a header and a single macro.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The header:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The macro:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The header `<boost/predef/compiler.h>` knows all the possible compilers and
    has a macro for each of those. So if the current compiler is GCC, then macro `BOOST_COMP_GNUC`
    is defined to `1` and all the other macros for other compilers are defined to
    `0`. If we are not on a GCC compiler, then the `BOOST_COMP_GNUC` macro is defined
    to `0`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to this approach, you do not need to check for the macro itself being
    defined:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Macros of the `Boost.Predef` library are always defined, and that saves you
    from typing `defined()` or `def` in `#ifdef`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Predef` library also has macros for detecting OS, architecture,
    standard library implementation, and some hardware abilities. Approach with macros
    that are always defined; this allows you to write complex expressions much shorter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, the best part. The `Boost.Predef` library is usable on C, C++, and Objective-C
    compilers. If you like it, use it in your non C++ projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: C++17 has no `Boost.Predef` library functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Predef` for more information about
    its abilities at [http://boost.org/libs/predef](http://boost.org/libs/predef)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next recipe will introduce you to the `Boost.Config` library, that is much
    order, slightly less beautiful, but much more functional
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting int128 support
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some compilers have support for extended arithmetic types such as 128-bit floats
    or integers. Let's take a quick glance at how to use them using Boost.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: We'll be creating a method that accepts three parameters and returns the multiplied
    value of those methods. If compiler supports 128-bit integers, then we use them.
    If compiler supports `long long`, then we use it; otherwise, we need to issue
    a compile-time error.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only the basic knowledge of C++ is required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we need to work with 128-bit integers? Macros that show that they are
    available and a few `typedefs` to have portable type names across platforms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Include a header:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we need to detect int128 support:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add some `typedefs` and implement the method as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For compilers that do not support the int128 type and have no `long long`,
    we may produce compile time error:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we need to provide some implementation for compilers without int128 support
    using `int64`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The header `<boost/config.hpp>` contains a lot of macros to describe compiler
    and platform features. In this example, we used `BOOST_HAS_INT128` to detect support
    of 128-bit integers and `BOOST_NO_LONG_LONG` to detect support of 64-bit integers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'As we may see from the example, Boost has `typedefs` for 64-bit signed and
    unsigned integers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It also has `typedefs` for 128-bit signed and unsigned integers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 has support of 64-bit types via the `long long int` and `unsigned long
    long int` built-in types. Unfortunately, not all compilers support C++11, so `BOOST_NO_LONG_LONG`
    may be useful for you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 128-bit integers are not a part of C++17, so `typedefs` and macros from Boost
    are one of the ways to write portable code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: There's an ongoing work in C++ standardization committee on adding integers
    of compile-time specified width. When that work will be finished, you would be
    able to create 128-bit, 512-bit, and even 8388608-bit (1 MB big) integers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the recipe *Detecting and bypassing disabled RTTI *for more information
    about `Boost.Config`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config) for
    more information about its abilities.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a library in Boost that allows constructing types of unlimited precision.
    Follow the link [http://boost.org/libs/multiprecision](http://boost.org/libs/multiprecision) and
    take a look at the `Boost.Multiprecision` library.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and bypassing disabled RTTI
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some companies and libraries have specific requirements for their C++ code,
    such as successful compilation without RTTI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In this small recipe, we'll not just detect disabled RTTI, but also write a
    Boost like library from scratch that stores information about types, and compares
    types at runtime, even without `typeid`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ RTTI usage is required for this recipe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detecting disabled RTTI, storing information about types, and comparing types
    at runtime are tricks that are widely used across Boost libraries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first need to include the following header:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s first look at the situation where RTTI is enabled and the C++11 `std::type_index`
    class is available:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Otherwise, we need to construct our own `type_index` class:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The final step is to define the `type_id` function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can compare types:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The macro `BOOST_NO_RTTI` is be defined if RTTI is disabled, and the macro `BOOST_NO_CXX11_HDR_TYPEINDEX`
    is be defined when the compiler has no `<typeindex>` header and no `std::type_index`
    class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The handwritten `type_index` structure from *step 3* of the previous section
    only holds the pointer to some string; nothing really interesting here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the `BOOST_CURRENT_FUNCTION` macro. It returns the full name
    of the current function, including template parameters, arguments, and the return
    type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `type_id<double>()` is represented as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, for any other type, `BOOST_CURRENT_FUNCTION` returns a different string,
    and that's why the `type_index` variable from the example does not compare equal
    to it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! We''ve just reinvented most of the `Boost.TypeIndex` library
    functionality. Remove all the code from *steps 1 to 4* and slightly change the
    code in *step 5* to use the `Boost.TypeIndex` library:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course `Boost.TypeIndex` is slightly more than that; it allows you to get
    human readable type name in a platform independent way, works around platform-related
    issues, allows to invent your own RTTI implementation, to have a constexpr RTTI,
    and other stuff.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Different compilers have different macros for getting a full function name.
    Using macros from Boost is the most portable solution. The `BOOST_CURRENT_FUNCTION`
    macro returns the name at compile time, so it implies minimal runtime penalty.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has a `__func__` magic identifier that is evaluated to the name of the
    current function. However, result of `__func__` is only the function name, while
    `BOOST_CURRENT_FUNCTION` tries hard to also show function parameters, including
    template ones.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the upcoming recipes for more information on `Boost.Config`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse to [http://github.com/boostorg/type_index](http://github.com/boostorg/type_index)
    to view the source codes of the `Boost.TypeIndex` library
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of the `Boost.TypeIndex` library at [http://boost.org/libs/type_index](http://boost.org/libs/type_index)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recipe *Getting human readable type name* in [Chapter 01](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application* will introduce you to some of the other capabilities
    of the `Boost.TypeIndex`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing metafunctions using simpler methods
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks*, and [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming*, were devoted to metaprogramming. If you were trying to use
    techniques from those chapters, you may have noticed that writing a metafunction
    can take a lot of time. So, it may be a good idea to experiment with metafunctions
    using more user-friendly methods, such as C++11 `constexpr`, before writing a
    portable implementation.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take a look at how to detect `constexpr` support.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `constexpr` functions are functions that can be evaluated at compile-time.
    That is all we need to know for this recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can detect compiler support for the `constexpr` feature:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in other recipes from this chapter, we start with the following header:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Write the `constexpr` function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s print an error if C++11 features are missing:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it. Now, we are free to write code such as the following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BOOST_NO_CXX11_CONSTEXPR` macro is defined when C++11 `constexpr` is available.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The `constexpr` keyword tells the compiler that the function can be evaluated
    at compile time if all the inputs for that function are compile-time constants.
    C++11 imposes a lot of limitations on what a `constexpr` function can do. C++14
    removed some of the limitations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOST_NO_CXX11_HDR_ARRAY` macro is defined when the C++11 `std::array`
    class and the `<array>` header are available.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, there are other usable and interesting macros for `constexpr` too,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOST_CONSTEXPR` macro expands to `constexpr` or does not expand
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BOOST_CONSTEXPR_OR_CONST` macro expands to `constexpr` or `const`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BOOST_STATIC_CONSTEXPR` macro is the same as `static BOOST_CONSTEXPR_OR_CONST`
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using those macros, it is possible to write code that takes advantage of C++11
    constant expression features if they are available:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can use `integral_constant` as shown in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the example, `BOOST_CONSTEXPR operator T()` is called to get the array size.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The C++11 constant expressions may improve compilation speed and diagnostic
    information in case of error. It's a good feature to use. If your function requires
    **relaxed constexpr** from C++14, then you may use `BOOST_CXX14_CONSTEXPR` macro.
    It expands to `constexpr` only if relaxed constexpr is available and expands to
    nothing otherwise.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about `constexpr` usage can be read at [http://en.cppreference.com/w/cpp/language/constexpr](http://en.cppreference.com/w/cpp/language/constexpr)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` for more information about
    macros at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing code size and increasing performance of user-defined types (UDTs) in
    C++11
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 has very specific logic when **user-defined types** (**UDTs**) are used
    in standard library containers. Some containers use move assignment and move construction
    only if the move constructor does not throw exceptions or there is no copy constructor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can ensure the compiler that the out class `move_nothrow` 
    has a non-throwing `move` assignment operator and a non-throwing `move` constructor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++11 rvalue references is required for this recipe. Knowledge
    of standard library containers will also serve you well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at how we can improve our C++ classes using Boost.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is mark the `move_nothrow` assignment operator and `move_nothrow`
    constructor with the `BOOST_NOEXCEPT` macro:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we may use the class with `std::vector` in C++11 without any modifications:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we remove `BOOST_NOEXCEPT` from the `move` constructor, we''ll get the following
    error because we provided no definition for the copy constructor:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BOOST_NOEXCEPT` macro expands to `noexcept` on compilers that support it.
    The standard library containers use type traits to detect if the constructor throws
    an exception or not. Type traits make their decision mainly based on `noexcept`
    specifiers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Why do we get an error without `BOOST_NOEXCEPT`? Compiler's type trait returns
    that `move_nothrow` throws, so `std::vector` tries to use the copy constructor
    of `move_nothrow`, which is not defined.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BOOST_NOEXCEPT` macro also reduces binary size irrespective of whether
    the definition of the `noexcept` function or method is in a separate source file
    or not.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That's because in the latter case, the compiler knows that the function does
    not throw exceptions and so there is no need to generate code that handles them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: If a function marked as `noexcept` does throw an exception, your program will
    terminate without calling destructors for the constructed objects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A document describing why `move` constructors are allowed to throw exceptions
    and how containers must move objects is available at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` for more examples of `BOOST_NOEXCEPT`
    such as macros existing in Boost at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The portable way to export and import functions and classes
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost all modern languages have the ability to make libraries, a collection
    of classes, and methods that have a well-defined interface. C++ is no exception
    to this rule. We have two types of libraries: runtime (also called shared or dynamic)
    and static. But, writing libraries is not a simple task in C++. Different platforms
    have different methods for describing which symbols must be exported from the
    shared library.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how to manage symbol visibility in a portable way using
    Boost.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Experience in creating dynamic and static libraries may be useful in this recipe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this recipe consists of two parts. The first part is the library
    itself. The second part is the code that uses that library. Both parts use the
    same header, in which the library methods are declared. Managing symbol visibility
    in a portable way using Boost is simple and can be done using the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header file, we need definitions from the following header file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code must also be added to the header file:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, all the declarations must use the `MY_LIBRARY_API` macro:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Exceptions must be declared with `BOOST_SYMBOL_VISIBLE`; otherwise, they can
    be caught only using `catch(...)` in the code that uses the library:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Library source files must include the header file:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Definitions of methods must also be in the source files of the library:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can use the library as shown in the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the work is done in *step 2*. There, we are defining the macro `MY_LIBRARY_API`,
    which we apply to classes and methods that we wish to export from our library.
    In *step 2*, we check for `MY_LIBRARY_LINK_DYNAMIC`. If it is not defined, we
    are building a static library and there is no need to define `MY_LIBRARY_API`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The developer must take care of `MY_LIBRARY_LINK_DYNAMIC`! It will not define
    itself. If we are making a dynamic library, we need to make our build system to
    define it,
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'If `MY_LIBRARY_LINK_DYNAMIC` is defined, we are building a runtime library,
    and that''s where the workarounds start. You, as the developer, must tell the
    compiler that we are now exporting function to the user. The user must tell the
    compiler that he/she is importing methods from the library. To have a single header
    file for both the import and export library, we use the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When exporting the library (or, in other words, compiling it), we must define
    `MY_LIBRARY_COMPILATION`. This leads to `MY_LIBRARY_API` being defined to `BOOST_SYMBOL_EXPORT`.
    For example, see *step 5*, where we defined `MY_LIBRARY_COMPILATION` before including
    `my_library.hpp`. If `MY_LIBRARY_COMPILATION` is not defined, the header is included
    by the user, who doesn't know anything about that macro. And, if the header is
    included by the user, the symbols must be imported from the library.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOST_SYMBOL_VISIBLE` macro must be used only for those classes that are
    not exported but are used by RTTI. Examples of such classes are exceptions and
    classes being cast using `dynamic_cast`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some compilers export all the symbols by default but provide flags to disable
    such behavior. For example, GCC and Clang on Linux provide `-fvisibility=hidden`.
    It is highly recommended to use those flags because it leads to smaller binary
    size, faster loading of dynamic libraries, and better logical structuring of binary.
    Some inter-procedural optimizations can perform better when fewer symbols are
    exported. C++17 has no standard way for describing visibilities. Hopefully someday,
    a portable way to work with visibility will appear in C++, but until then, we
    have to use macros from Boost.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this chapter from the beginning to get more examples of `Boost.Config`
    usage
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider reading the official documentation of `Boost.Config` for the full list
    of the `Boost.Config` macro and their description at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the Boost version and getting latest features
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost is being actively developed, so each release contains new features and
    libraries. Some people wish to have libraries that compile for different versions
    of Boost and also want to use some of the features of the new versions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the `boost::lexical_cast` change log. According to it,
    Boost 1.53 has a `lexical_cast(const CharType* chars, std::size_t count)` function
    overload. Our task for this recipe will be to use that function overload for new
    versions of Boost and work around that missing function overload for older versions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ and the `Boost.LexicalCast` library is required.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, all we need to do is get info about the version of Boost and use it to
    write optimal code. This can be done as shown in the following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the headers containing the Boost version and `boost::lexical_cast`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We use the new feature of `Boost.LexicalCast` if it is available:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Otherwise, we are required to copy data to `std::string` first:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can use the code as shown here:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BOOST_VERSION` macro contains the Boost version written in the following
    format: a single number for the major version, followed by three numbers for the
    minor version, and then two numbers for the patch level. For example, Boost 1.73.1
    will contain the `107301` number in the `BOOST_VERSION` macro.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_VERSION`宏包含Boost版本，格式如下：主版本号为一个数字，次版本号为三个数字，修订级别为两个数字。例如，Boost 1.73.1将在`BOOST_VERSION`宏中包含`107301`数字。'
- en: So, we check the Boost version in *step 2* and choose the correct implementation
    of the `to_int` function according to the abilities of `Boost.LexicalCast`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在*步骤2*中，我们检查Boost版本，并根据`Boost.LexicalCast`的能力选择`to_int`函数的正确实现。
- en: There's more...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Having a version macro is a common practice for big libraries. Some of the Boost
    libraries allow you to specify the version of the library to use; see `Boost.Thread`
    and its `BOOST_THREAD_VERSION` macro for an example.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有版本宏是大型库的常见做法。一些Boost库允许您指定要使用的库的版本；请参阅`Boost.Thread`及其`BOOST_THREAD_VERSION`宏以获取示例。
- en: 'By the way, C++ has a version macro too. Value of the `__cplusplus` macro allows
    you to distinguish pre-C++11 from C++11, C++11 from C++14, or C++17\. Currently
    it can be defined to one of the following values: `199711L`, `201103L`, `201402L`,
    or `201703L`. Macro value stands for year and month when the committee approved
    the standard.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，C++也有一个版本宏。`__cplusplus`宏的值允许您区分C++11之前的版本和C++11，C++11和C++14，或C++17。目前，它可以定义为以下值之一：`199711L`，`201103L`，`201402L`或`201703L`。宏值代表委员会批准标准的年份和月份。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read the recipe *Creating an execution thread* in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, for more information about `BOOST_THREAD_VERSION` and how it
    affects the `Boost.Thread` library, or read the documentation at [http://boost.org/libs/thread](http://boost.org/libs/thread)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)中的*创建执行线程*配方，了解有关`BOOST_THREAD_VERSION`及其对`Boost.Thread`库的影响的更多信息，或阅读[http://boost.org/libs/thread](http://boost.org/libs/thread)的文档。
- en: Read this chapter from the beginning or consider reading the official documentation
    of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读本章，或考虑阅读[Boost.Config](http://boost.org/libs/config)的官方文档
