- en: Gathering Platform and Compiler Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting an OS and compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting int128 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and bypassing disabled RTTI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing metafunctions using simpler methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing code size and increasing the performance of user-defined types (UDTs)
    in C++11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The portable way to export and import functions and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the Boost version and getting latest features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different projects and companies have different coding requirements. Some of
    them forbid exceptions or RTTI, while some forbid C++11\. If you are willing to
    write portable code that can be used by a wide range of projects, this chapter
    is for you.
  prefs: []
  type: TYPE_NORMAL
- en: Want to make your code as fast as possible and use the latest C++ features?
    You'll definitely need a tool for detecting compiler features.
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers have unique features that may greatly simplify your life. If
    you are targeting a single compiler, you can save many hours and use those features.
    No need to implement their analogs from scratch!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is devoted to different helper macros used to detect compiler,
    platform, and Boost features. These macro are widely used across Boost libraries
    and are essential for writing portable code that is able to work with any compiler
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting an OS and compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m guessing you''ve seen a bunch of ugly macros to detect the compiler on
    which the code is compiled. Something like this is a typical practice in C word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, try to come up with a good macro to detect the GCC compiler. Try to make
    that macro usage as short as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the following recipe to verify your guess.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe is simple and consists of a single a header and a single macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The header `<boost/predef/compiler.h>` knows all the possible compilers and
    has a macro for each of those. So if the current compiler is GCC, then macro `BOOST_COMP_GNUC`
    is defined to `1` and all the other macros for other compilers are defined to
    `0`. If we are not on a GCC compiler, then the `BOOST_COMP_GNUC` macro is defined
    to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to this approach, you do not need to check for the macro itself being
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Macros of the `Boost.Predef` library are always defined, and that saves you
    from typing `defined()` or `def` in `#ifdef`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Predef` library also has macros for detecting OS, architecture,
    standard library implementation, and some hardware abilities. Approach with macros
    that are always defined; this allows you to write complex expressions much shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, the best part. The `Boost.Predef` library is usable on C, C++, and Objective-C
    compilers. If you like it, use it in your non C++ projects.
  prefs: []
  type: TYPE_NORMAL
- en: C++17 has no `Boost.Predef` library functionality.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Predef` for more information about
    its abilities at [http://boost.org/libs/predef](http://boost.org/libs/predef)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next recipe will introduce you to the `Boost.Config` library, that is much
    order, slightly less beautiful, but much more functional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting int128 support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some compilers have support for extended arithmetic types such as 128-bit floats
    or integers. Let's take a quick glance at how to use them using Boost.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be creating a method that accepts three parameters and returns the multiplied
    value of those methods. If compiler supports 128-bit integers, then we use them.
    If compiler supports `long long`, then we use it; otherwise, we need to issue
    a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only the basic knowledge of C++ is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we need to work with 128-bit integers? Macros that show that they are
    available and a few `typedefs` to have portable type names across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include a header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to detect int128 support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some `typedefs` and implement the method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For compilers that do not support the int128 type and have no `long long`,
    we may produce compile time error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to provide some implementation for compilers without int128 support
    using `int64`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The header `<boost/config.hpp>` contains a lot of macros to describe compiler
    and platform features. In this example, we used `BOOST_HAS_INT128` to detect support
    of 128-bit integers and `BOOST_NO_LONG_LONG` to detect support of 64-bit integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we may see from the example, Boost has `typedefs` for 64-bit signed and
    unsigned integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It also has `typedefs` for 128-bit signed and unsigned integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 has support of 64-bit types via the `long long int` and `unsigned long
    long int` built-in types. Unfortunately, not all compilers support C++11, so `BOOST_NO_LONG_LONG`
    may be useful for you.
  prefs: []
  type: TYPE_NORMAL
- en: 128-bit integers are not a part of C++17, so `typedefs` and macros from Boost
    are one of the ways to write portable code.
  prefs: []
  type: TYPE_NORMAL
- en: There's an ongoing work in C++ standardization committee on adding integers
    of compile-time specified width. When that work will be finished, you would be
    able to create 128-bit, 512-bit, and even 8388608-bit (1 MB big) integers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the recipe *Detecting and bypassing disabled RTTI *for more information
    about `Boost.Config`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config) for
    more information about its abilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a library in Boost that allows constructing types of unlimited precision.
    Follow the link [http://boost.org/libs/multiprecision](http://boost.org/libs/multiprecision) and
    take a look at the `Boost.Multiprecision` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and bypassing disabled RTTI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some companies and libraries have specific requirements for their C++ code,
    such as successful compilation without RTTI.
  prefs: []
  type: TYPE_NORMAL
- en: In this small recipe, we'll not just detect disabled RTTI, but also write a
    Boost like library from scratch that stores information about types, and compares
    types at runtime, even without `typeid`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ RTTI usage is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detecting disabled RTTI, storing information about types, and comparing types
    at runtime are tricks that are widely used across Boost libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first need to include the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first look at the situation where RTTI is enabled and the C++11 `std::type_index`
    class is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we need to construct our own `type_index` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to define the `type_id` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can compare types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The macro `BOOST_NO_RTTI` is be defined if RTTI is disabled, and the macro `BOOST_NO_CXX11_HDR_TYPEINDEX`
    is be defined when the compiler has no `<typeindex>` header and no `std::type_index`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The handwritten `type_index` structure from *step 3* of the previous section
    only holds the pointer to some string; nothing really interesting here.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the `BOOST_CURRENT_FUNCTION` macro. It returns the full name
    of the current function, including template parameters, arguments, and the return
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `type_id<double>()` is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So, for any other type, `BOOST_CURRENT_FUNCTION` returns a different string,
    and that's why the `type_index` variable from the example does not compare equal
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! We''ve just reinvented most of the `Boost.TypeIndex` library
    functionality. Remove all the code from *steps 1 to 4* and slightly change the
    code in *step 5* to use the `Boost.TypeIndex` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course `Boost.TypeIndex` is slightly more than that; it allows you to get
    human readable type name in a platform independent way, works around platform-related
    issues, allows to invent your own RTTI implementation, to have a constexpr RTTI,
    and other stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Different compilers have different macros for getting a full function name.
    Using macros from Boost is the most portable solution. The `BOOST_CURRENT_FUNCTION`
    macro returns the name at compile time, so it implies minimal runtime penalty.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has a `__func__` magic identifier that is evaluated to the name of the
    current function. However, result of `__func__` is only the function name, while
    `BOOST_CURRENT_FUNCTION` tries hard to also show function parameters, including
    template ones.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the upcoming recipes for more information on `Boost.Config`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse to [http://github.com/boostorg/type_index](http://github.com/boostorg/type_index)
    to view the source codes of the `Boost.TypeIndex` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of the `Boost.TypeIndex` library at [http://boost.org/libs/type_index](http://boost.org/libs/type_index)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recipe *Getting human readable type name* in [Chapter 01](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application* will introduce you to some of the other capabilities
    of the `Boost.TypeIndex`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing metafunctions using simpler methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks*, and [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming*, were devoted to metaprogramming. If you were trying to use
    techniques from those chapters, you may have noticed that writing a metafunction
    can take a lot of time. So, it may be a good idea to experiment with metafunctions
    using more user-friendly methods, such as C++11 `constexpr`, before writing a
    portable implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take a look at how to detect `constexpr` support.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `constexpr` functions are functions that can be evaluated at compile-time.
    That is all we need to know for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can detect compiler support for the `constexpr` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in other recipes from this chapter, we start with the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the `constexpr` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print an error if C++11 features are missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now, we are free to write code such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BOOST_NO_CXX11_CONSTEXPR` macro is defined when C++11 `constexpr` is available.
  prefs: []
  type: TYPE_NORMAL
- en: The `constexpr` keyword tells the compiler that the function can be evaluated
    at compile time if all the inputs for that function are compile-time constants.
    C++11 imposes a lot of limitations on what a `constexpr` function can do. C++14
    removed some of the limitations.
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOST_NO_CXX11_HDR_ARRAY` macro is defined when the C++11 `std::array`
    class and the `<array>` header are available.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, there are other usable and interesting macros for `constexpr` too,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOST_CONSTEXPR` macro expands to `constexpr` or does not expand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BOOST_CONSTEXPR_OR_CONST` macro expands to `constexpr` or `const`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BOOST_STATIC_CONSTEXPR` macro is the same as `static BOOST_CONSTEXPR_OR_CONST`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using those macros, it is possible to write code that takes advantage of C++11
    constant expression features if they are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use `integral_constant` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the example, `BOOST_CONSTEXPR operator T()` is called to get the array size.
  prefs: []
  type: TYPE_NORMAL
- en: The C++11 constant expressions may improve compilation speed and diagnostic
    information in case of error. It's a good feature to use. If your function requires
    **relaxed constexpr** from C++14, then you may use `BOOST_CXX14_CONSTEXPR` macro.
    It expands to `constexpr` only if relaxed constexpr is available and expands to
    nothing otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about `constexpr` usage can be read at [http://en.cppreference.com/w/cpp/language/constexpr](http://en.cppreference.com/w/cpp/language/constexpr)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` for more information about
    macros at [http://boost.org/libs/config](http://boost.org/libs/config)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing code size and increasing performance of user-defined types (UDTs) in
    C++11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 has very specific logic when **user-defined types** (**UDTs**) are used
    in standard library containers. Some containers use move assignment and move construction
    only if the move constructor does not throw exceptions or there is no copy constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can ensure the compiler that the out class `move_nothrow` 
    has a non-throwing `move` assignment operator and a non-throwing `move` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++11 rvalue references is required for this recipe. Knowledge
    of standard library containers will also serve you well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at how we can improve our C++ classes using Boost.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is mark the `move_nothrow` assignment operator and `move_nothrow`
    constructor with the `BOOST_NOEXCEPT` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we may use the class with `std::vector` in C++11 without any modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we remove `BOOST_NOEXCEPT` from the `move` constructor, we''ll get the following
    error because we provided no definition for the copy constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BOOST_NOEXCEPT` macro expands to `noexcept` on compilers that support it.
    The standard library containers use type traits to detect if the constructor throws
    an exception or not. Type traits make their decision mainly based on `noexcept`
    specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we get an error without `BOOST_NOEXCEPT`? Compiler's type trait returns
    that `move_nothrow` throws, so `std::vector` tries to use the copy constructor
    of `move_nothrow`, which is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BOOST_NOEXCEPT` macro also reduces binary size irrespective of whether
    the definition of the `noexcept` function or method is in a separate source file
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That's because in the latter case, the compiler knows that the function does
    not throw exceptions and so there is no need to generate code that handles them.
  prefs: []
  type: TYPE_NORMAL
- en: If a function marked as `noexcept` does throw an exception, your program will
    terminate without calling destructors for the constructed objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A document describing why `move` constructors are allowed to throw exceptions
    and how containers must move objects is available at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the official documentation of `Boost.Config` for more examples of `BOOST_NOEXCEPT`
    such as macros existing in Boost at [http://boost.org/libs/config](http://boost.org/libs/config)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The portable way to export and import functions and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost all modern languages have the ability to make libraries, a collection
    of classes, and methods that have a well-defined interface. C++ is no exception
    to this rule. We have two types of libraries: runtime (also called shared or dynamic)
    and static. But, writing libraries is not a simple task in C++. Different platforms
    have different methods for describing which symbols must be exported from the
    shared library.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how to manage symbol visibility in a portable way using
    Boost.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Experience in creating dynamic and static libraries may be useful in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this recipe consists of two parts. The first part is the library
    itself. The second part is the code that uses that library. Both parts use the
    same header, in which the library methods are declared. Managing symbol visibility
    in a portable way using Boost is simple and can be done using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header file, we need definitions from the following header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code must also be added to the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all the declarations must use the `MY_LIBRARY_API` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Exceptions must be declared with `BOOST_SYMBOL_VISIBLE`; otherwise, they can
    be caught only using `catch(...)` in the code that uses the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Library source files must include the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Definitions of methods must also be in the source files of the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the library as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the work is done in *step 2*. There, we are defining the macro `MY_LIBRARY_API`,
    which we apply to classes and methods that we wish to export from our library.
    In *step 2*, we check for `MY_LIBRARY_LINK_DYNAMIC`. If it is not defined, we
    are building a static library and there is no need to define `MY_LIBRARY_API`.
  prefs: []
  type: TYPE_NORMAL
- en: The developer must take care of `MY_LIBRARY_LINK_DYNAMIC`! It will not define
    itself. If we are making a dynamic library, we need to make our build system to
    define it,
  prefs: []
  type: TYPE_NORMAL
- en: 'If `MY_LIBRARY_LINK_DYNAMIC` is defined, we are building a runtime library,
    and that''s where the workarounds start. You, as the developer, must tell the
    compiler that we are now exporting function to the user. The user must tell the
    compiler that he/she is importing methods from the library. To have a single header
    file for both the import and export library, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When exporting the library (or, in other words, compiling it), we must define
    `MY_LIBRARY_COMPILATION`. This leads to `MY_LIBRARY_API` being defined to `BOOST_SYMBOL_EXPORT`.
    For example, see *step 5*, where we defined `MY_LIBRARY_COMPILATION` before including
    `my_library.hpp`. If `MY_LIBRARY_COMPILATION` is not defined, the header is included
    by the user, who doesn't know anything about that macro. And, if the header is
    included by the user, the symbols must be imported from the library.
  prefs: []
  type: TYPE_NORMAL
- en: The `BOOST_SYMBOL_VISIBLE` macro must be used only for those classes that are
    not exported but are used by RTTI. Examples of such classes are exceptions and
    classes being cast using `dynamic_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some compilers export all the symbols by default but provide flags to disable
    such behavior. For example, GCC and Clang on Linux provide `-fvisibility=hidden`.
    It is highly recommended to use those flags because it leads to smaller binary
    size, faster loading of dynamic libraries, and better logical structuring of binary.
    Some inter-procedural optimizations can perform better when fewer symbols are
    exported. C++17 has no standard way for describing visibilities. Hopefully someday,
    a portable way to work with visibility will appear in C++, but until then, we
    have to use macros from Boost.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this chapter from the beginning to get more examples of `Boost.Config`
    usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider reading the official documentation of `Boost.Config` for the full list
    of the `Boost.Config` macro and their description at [http://boost.org/libs/config](http://boost.org/libs/config)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the Boost version and getting latest features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost is being actively developed, so each release contains new features and
    libraries. Some people wish to have libraries that compile for different versions
    of Boost and also want to use some of the features of the new versions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the `boost::lexical_cast` change log. According to it,
    Boost 1.53 has a `lexical_cast(const CharType* chars, std::size_t count)` function
    overload. Our task for this recipe will be to use that function overload for new
    versions of Boost and work around that missing function overload for older versions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ and the `Boost.LexicalCast` library is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, all we need to do is get info about the version of Boost and use it to
    write optimal code. This can be done as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include the headers containing the Boost version and `boost::lexical_cast`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the new feature of `Boost.LexicalCast` if it is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we are required to copy data to `std::string` first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the code as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BOOST_VERSION` macro contains the Boost version written in the following
    format: a single number for the major version, followed by three numbers for the
    minor version, and then two numbers for the patch level. For example, Boost 1.73.1
    will contain the `107301` number in the `BOOST_VERSION` macro.'
  prefs: []
  type: TYPE_NORMAL
- en: So, we check the Boost version in *step 2* and choose the correct implementation
    of the `to_int` function according to the abilities of `Boost.LexicalCast`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a version macro is a common practice for big libraries. Some of the Boost
    libraries allow you to specify the version of the library to use; see `Boost.Thread`
    and its `BOOST_THREAD_VERSION` macro for an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, C++ has a version macro too. Value of the `__cplusplus` macro allows
    you to distinguish pre-C++11 from C++11, C++11 from C++14, or C++17\. Currently
    it can be defined to one of the following values: `199711L`, `201103L`, `201402L`,
    or `201703L`. Macro value stands for year and month when the committee approved
    the standard.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the recipe *Creating an execution thread* in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, for more information about `BOOST_THREAD_VERSION` and how it
    affects the `Boost.Thread` library, or read the documentation at [http://boost.org/libs/thread](http://boost.org/libs/thread)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read this chapter from the beginning or consider reading the official documentation
    of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
