- en: 'Chapter 9: Container Virtualization in Azure'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：Azure中的容器虚拟化
- en: 'In *Chapter 2*, *Getting Started with the Azure Cloud*, we started our journey
    in Azure with the creation of our first workload in Azure: the deployment of a
    Linux VM. After that, we covered many aspects of the Linux operating system.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*“开始使用Azure云”中，我们开始了在Azure中的旅程，首先在Azure中部署了我们的第一个工作负载：Linux虚拟机的部署。之后，我们涵盖了Linux操作系统的许多方面。
- en: In *Chapter 7*, *Deploying Your Virtual Machines*, we explored several options
    to deploy your VMs, and *Chapter 8*, *Exploring Continuous Configuration Automation*,
    was all about what to do afterward in terms of configuration management using
    orchestration tooling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7章*“部署您的虚拟机”中，我们探讨了部署虚拟机的几种选项，而*第8章*“探索持续配置自动化”则是关于使用编排工具进行配置管理之后要做的事情。
- en: Orchestration is a growing part of a movement called DevOps. DevOps is about
    breaking down the classic silos in an organization. The different teams involved
    in developing, testing, and deploying products must communicate and work together.
    DevOps is a combination of cultural philosophies, practices, and tools. And DevOps
    is a way to make deployments incremental, frequent, and routine events while constraining
    the impact of failure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编排是DevOps运动的一个不断增长的部分。DevOps是打破组织中经典隔离的一部分。参与开发、测试和部署产品的不同团队必须进行沟通和合作。DevOps是文化哲学、实践和工具的结合。DevOps是一种使部署增量、频繁和常规事件的方式，同时限制失败影响的方法。
- en: 'VMs are not the only way to deploy workloads: you can also deploy your workload
    in containers. It makes it possible, together with orchestration, to fulfill DevOps
    requirements.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机不是部署工作负载的唯一方式：您还可以在容器中部署工作负载。它使得与编排一起，可以满足DevOps的要求。
- en: 'So, before we actually learn about and implement containers in Azure, let''s
    quickly have a look at what this chapter has to offer. By the end of this chapter,
    you will:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们实际学习和在Azure中实现容器之前，让我们快速看一下本章提供了什么。在本章结束时，您将：
- en: Understand the history of containers and know the early adoptions of containerization.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解容器的历史，并了解容器化的早期采用情况。
- en: Be familiar with container tools such as `systemd-nspawn` and Docker.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉诸如`systemd-nspawn`和Docker之类的容器工具。
- en: Be able to work with Docker Machine and Docker Compose.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用Docker Machine和Docker Compose。
- en: Be able to use Azure Container Instances and Azure Container Registry.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用Azure容器实例和Azure容器注册表。
- en: Know about the new generation container tools such as Buildah, Podman, and Skopeo.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解新一代容器工具，如Buildah、Podman和Skopeo。
- en: Now, we'll first understand what a container is and how it has evolved.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们首先要了解容器是什么，以及它是如何发展的。
- en: Introduction to Container Technology
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器技术简介
- en: 'In *Chapter 1*, *Exploring the Azure Cloud*, we had a short introduction to
    containers. So, let''s go ahead and cover containers in more detail. We know that
    VMs are run on a hypervisor, and for each purpose, in most cases you have to create
    a separate VM to isolate the environments. VMs will have a guest OS, such as Linux,
    and on top of that we will install the software we require. There will be scenarios
    where you have to deploy a large number of VMs for testing. If you are using an
    on-premises infrastructure running Hyper-V, you have to think about resource utilization—that
    is, how much memory, CPU, and so on you will use for each VM. If you are deploying
    in Azure, you have to think about the cost as well. You might need some VMs only
    for a couple of hours just to test something, but the footprints of these VMs
    are large; they''re complete computers that are running virtually. Another problem
    is compatibility issues. Let''s assume you have an app that requires a dependency
    package such as Python 2.2\. Now think about another app running in the same VM
    that has compatibility issues with Python 2.2 and can only work with Python 2.1\.
    You would end up creating a new VM for the second app with Python 2.1\. To overcome
    this, containers were introduced. Here is a pictorial representation of how containers
    differ from VMs:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*“探索Azure云”中，我们简要介绍了容器。因此，让我们继续更详细地介绍容器。我们知道虚拟机是在hypervisor上运行的，并且在大多数情况下，您必须为每个目的创建一个单独的虚拟机来隔离环境。虚拟机将有一个类似Linux的客户操作系统，然后我们将安装所需的软件。在某些情况下，您必须部署大量的虚拟机进行测试。如果您正在使用运行Hyper-V的本地基础设施，您必须考虑资源利用率，即每个虚拟机将使用多少内存、CPU等。如果您在Azure中部署，您还必须考虑成本。您可能只需要一些虚拟机来测试某些东西，但这些虚拟机的占用空间很大；它们实际上是在虚拟运行的完整计算机。另一个问题是兼容性问题。假设您有一个应用程序需要一个依赖包，比如Python
    2.2。现在想象一下在同一个虚拟机中运行另一个应用程序，它与Python 2.2存在兼容性问题，只能使用Python 2.1。您最终将不得不为第二个应用程序创建一个新的虚拟机，其中安装了Python
    2.1。为了克服这个问题，引入了容器。以下是容器与虚拟机有何不同的图示表示：
- en: '![Pictorial representation of VMs differs from Containers](img/B15455_09_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![VMs与容器的图示表示不同](img/B15455_09_01.jpg)'
- en: 'Figure 9.1: Representation of VMs and Containers'
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.1：虚拟机和容器的表示
- en: Like VMs, containers allow you to package your application along with all the
    dependencies and libraries. They are isolated environments like VMs and can be
    used to test and run applications without needing to create multiple VMs. Containers
    are also lightweight.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机一样，容器允许您将应用程序与所有依赖项和库打包在一起。它们像虚拟机一样是隔离的环境，可以用于测试和运行应用程序，而无需创建多个虚拟机。容器也很轻量级。
- en: Instead of virtualizing each hardware component as with the VMs, containers
    virtualize at the OS level. This means that the containers have a smaller footprint
    than VMs. For example, an Ubuntu ISO image will have a size close to 2.4 GB; on
    the other hand, an Ubuntu container image is less than 200 MB. Let's consider
    the previous example, where we had dependency issues with Python 2.2 and ended
    up creating two VMs. With containers, we can have two containers with a much smaller
    footprint than two VMs. Also, the cost and resource utilization of the host OS
    is far less than that of two VMs. Containers are deployed using a container runtime;
    there are different runtimes available. In this chapter, we will take a look at
    the popular container runtimes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机不同，容器是在操作系统级别进行虚拟化的，而不是每个硬件组件都进行虚拟化。这意味着容器的占用空间比虚拟机小。例如，Ubuntu ISO镜像的大小接近2.4
    GB；另一方面，Ubuntu容器镜像小于200 MB。考虑之前的例子，我们在Python 2.2上有依赖问题，最终创建了两个虚拟机。使用容器，我们可以有两个占用空间比两个虚拟机小得多的容器。此外，主机操作系统的成本和资源利用远远低于两个虚拟机。容器使用容器运行时部署；有不同的运行时可用。在本章中，我们将看一下流行的容器运行时。
- en: 'A container is not the Holy Grail. It doesn''t fix all your problems. However,
    you can consider the following scenarios, and if any of them match your requirements,
    you might want to containerize your application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器不是圣杯。它不能解决您所有的问题。但是，您可以考虑以下情景，如果它们中的任何一个符合您的要求，您可能希望将应用程序容器化：
- en: There is a need for applications that often need updates with new features,
    preferably without downtime, driven by business needs.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序经常需要更新新功能，最好无需停机，这是由业务需求驱动的。
- en: System engineers and developers can work together to address the business needs
    and have enough understanding and knowledge of each other's domains (without being
    a specialist in both), and have a culture of continual experimentation and learning.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统工程师和开发人员可以共同解决业务需求，并对彼此的领域有足够的理解和知识（而不必成为两者的专家），并且具有持续实验和学习的文化。
- en: There is room for failure in order to make the application better.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使应用程序更好，需要有失败的空间。
- en: The application is not a single point of failure.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序不是单点故障。
- en: The application is not a critical application in terms of availability and security.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序在可用性和安全性方面不是关键应用程序。
- en: 'One other little thing: if you have many different types of applications and
    there is almost no code shared between those applications, container technology
    is still an option, but it''s possible that VMs are a better solution in this
    scenario.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件小事：如果您有许多不同类型的应用程序，并且这些应用程序之间几乎没有共享的代码，容器技术仍然是一个选择，但在这种情况下，虚拟机可能是更好的解决方案。
- en: 'We''ll cover a little bit of the history of container technology to give you
    a better understanding of where it comes from. We''ll explore some of the solutions
    available today: systemd-nspawn and Docker. There are more container virtualization
    implementations available, even some of the earliest implementations, such as
    LXC. In fact, it doesn''t matter which containerization tool you''re using: if
    you understand the ideas and concepts behind containers, it''s easy to implement
    the same ideas and concepts with other tools. The only thing that changes is the
    command; the underlying concepts for all these tools are the same.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍容器技术的历史，以便让您更好地了解其来源。我们将探讨当今提供的一些解决方案：systemd-nspawn和Docker。甚至有更多的容器虚拟化实现可用，甚至一些最早的实现，比如LXC。实际上，无论您使用哪种容器化工具：如果您了解容器背后的思想和概念，就很容易使用其他工具实现相同的思想和概念。唯一改变的是命令；所有这些工具的基本概念都是相同的。
- en: History of Containers
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的历史
- en: Containers are very popular nowadays. But they are not new; they didn't come
    out of the blue. It's not easy to point to an exact time when they started. We
    don't want to give you a history lesson, but history can give you an understanding
    of the technology and even give you a clue as to why or when you should use containers
    in your organization.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 容器现在非常流行。但它们并不新；它们不是突然出现的。很难指出它们开始的确切时间。我们不想给您历史课，但历史可以让您了解技术，甚至可以让您了解为什么或何时应该在组织中使用容器。
- en: 'So, instead of focusing on an exact timeline, we''ll only cover the important
    steps: the implementation of technologies that are important if you want to understand
    container technology as it is today.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会专注于确切的时间轴，我们只会涵盖重要的步骤：实施如果您想了解当今容器技术的重要技术。
- en: '**The chroot Environment**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**chroot环境**'
- en: In Linux, there is a root filesystem, as covered in *Chapter 5*, *Advanced Linux
    Administration*, and everything is mounted to that filesystem, which will be visible
    to the currently running processes and their children.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，有一个根文件系统，如*第5章* *高级Linux管理*中所述，一切都挂载到该文件系统上，这将对当前运行的进程及其子进程可见。
- en: 'A process running in `chroot` has its own root filesystem, fully separated
    from the system-wide root, known as `fs.chroot`. It is often used in development
    as the program running in `chroot` cannot access files or commands outside its
    root filesystem. To start a chroot jail from a directory, execute the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chroot`中运行的进程有自己的根文件系统，与系统范围的根完全分离，称为`fs.chroot`。它经常用于开发，因为在`chroot`中运行的程序无法访问其根文件系统之外的文件或命令。要从目录启动chroot监狱，请执行以下操作：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In 1979, the `chroot` system call was introduced in version 7 of Unix, and in
    1982, it was introduced in BSD Unix. Linux has implemented this system call since
    the early days of its existence.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 1979年，在Unix的第7版中引入了`chroot`系统调用，并在1982年引入了BSD Unix。Linux自其存在的早期就实现了这个系统调用。
- en: '**OpenVZ**'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**OpenVZ**'
- en: In 2005, almost at the same time that Solaris started its container technology,
    a company called Virtuozzo started the OpenVZ project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，几乎与Solaris启动其容器技术同时，一家名为Virtuozzo的公司启动了OpenVZ项目。
- en: 'They took the principle of the chroot environment and applied it to other resources.
    A chroot process will have the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 他们采用了chroot环境的原则，并将其应用于其他资源。chroot进程将具有以下内容：
- en: A root filesystem
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统
- en: Users and groups
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和组
- en: Devices
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备
- en: A process tree
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进程树
- en: A network
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络
- en: Interprocess communication objects
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信对象
- en: At that time, OpenVZ was seen as a lightweight alternative to virtualization
    based on a hypervisor, and also as a solid platform for developers. It still exists,
    and you can use it on top of every Linux operating system, running in the cloud
    or not.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，OpenVZ被视为基于hypervisor的虚拟化的轻量级替代方案，也被视为开发人员的坚实平台。它仍然存在，并且您可以在任何Linux操作系统上使用它，无论是在云中还是不在云中。
- en: 'Using OpenVZ is similar to using a VM: you create an image with a base installation
    of your favorite distribution and, if you want, after that you can use orchestration
    to install the application and maintain everything.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenVZ类似于使用虚拟机：您可以创建一个带有您喜欢的发行版基本安装的映像，之后您可以使用编排来安装应用程序并维护一切。
- en: '**LXC**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**LXC**'
- en: In 2006, engineers at Google started working on a feature in the Linux kernel
    called **cgroups** (**control groups**) to enable resource control on resources
    such as CPU, memory, disk I/O, and the network for collections of processes (resource
    groups).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年，Google的工程师开始在Linux内核中开发一个名为**cgroups**（**控制组**）的功能，以便对进程集合（资源组）上的CPU、内存、磁盘I/O和网络等资源进行资源控制。
- en: A related feature of the Linux kernel is the concept of `cgroups` became a namespace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核的一个相关特性是`cgroups`的概念成为了一个命名空间。
- en: 'In 2008, `cgroups` was merged into the Linux kernel and a new namespace was
    introduced, the `user` namespace. Both technologies were then enabled for a new
    step forward for containers: LXC.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，`cgroups`被合并到Linux内核中，并引入了一个新的命名空间，即`user`命名空间。然后，这两种技术为容器的新步骤——LXC启用了。
- en: Other available namespaces are `pid`, `mount`, `network`, `uts` (own domain
    name), and `ipc`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的命名空间包括`pid`、`mount`、`network`、`uts`（自己的域名）和`ipc`。
- en: 'There is no longer any need to keep up to date with Linux kernel development:
    every component needed is available, and there is much better resource management.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要跟踪Linux内核的开发情况：每个所需的组件都可用，并且资源管理更加出色。
- en: 'Recently, Canonical developed a new container manager called the LXD, which
    has LXC in its backend and aims to provide an improved user experience for managing
    containers. Technically, LXD uses LXC through liblxc and its Go binding to achieve
    this aim. Some advantages of LXD are listed here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Canonical开发了一个名为LXD的新容器管理器，它在其后端使用LXC，并旨在提供改进的用户体验来管理容器。从技术上讲，LXD使用LXC通过liblxc和其Go绑定来实现这一目标。以下列出了LXD的一些优点：
- en: Secure
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Highly scalable
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可扩展
- en: Simplifies resource sharing
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化资源共享
- en: systemd-nspawn
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: systemd-nspawn
- en: systemd comes with a container solution. It started as an experiment, and then
    Lennart Poettering considered it ready for production. It is, in fact, the base
    for another solution, Rkt. At the time of writing this book, Rkt development has
    stopped. However, you can still access the Rkt GitHub repository ([https://github.com/rkt/rkt](https://github.com/rkt/rkt)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: systemd带有一个容器解决方案。它起初是一个实验，然后Lennart Poettering认为它已经准备好投入生产。实际上，它是另一个解决方案Rkt的基础。在撰写本书时，Rkt的开发已经停止。但是，您仍然可以访问Rkt
    GitHub存储库（[https://github.com/rkt/rkt](https://github.com/rkt/rkt)）。
- en: systemd-nspawn is not very well known, but it is a powerful solution that is
    available on every modern Linux system. It is built on top of the kernel namespaces
    and systemd for management. It's a sort of chroot on steroids.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: systemd-nspawn并不是很出名，但它是一种强大的解决方案，可在每个现代Linux系统上使用。它建立在内核命名空间和systemd之上进行管理。这是一种类似于增强版的chroot。
- en: 'If you want to learn more about the underlying technologies of containers,
    systemd-nspawn is a good start. Here, every component is visible and can be configured
    manually if you want. The downside of systemd-nspawn is that you have to do everything
    on your own, from creating the image, to orchestration, to high availability:
    it''s all possible, but you have to build it.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于容器底层技术的知识，systemd-nspawn是一个很好的起点。在这里，每个组件都是可见的，如果您愿意，可以手动配置。systemd-nspawn的缺点是您必须自己完成所有工作，从创建映像到编排再到高可用性：这一切都是可能的，但您必须自己构建。
- en: Containers can also be created using package managers such as `yum` and by extracting
    raw cloud images (several distributions provide such images, such as [https://cloud.centos.org/centos/7/images](https://cloud.centos.org/centos/7/images)
    and [https://cloud-images.ubuntu.com/](https://cloud-images.ubuntu.com/)). You
    can even use Docker images!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 容器也可以使用诸如`yum`之类的软件包管理器创建，并通过提取原始云映像（几个发行版提供此类映像，例如[https://cloud.centos.org/centos/7/images](https://cloud.centos.org/centos/7/images)和[https://cloud-images.ubuntu.com/](https://cloud-images.ubuntu.com/)）。您甚至可以使用Docker映像！
- en: 'As stated, there are multiple ways to create a container. As an example, we''ll
    cover two of them: `debootstrap` and `yum`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有多种方法可以创建容器。例如，我们将介绍其中的两种：`debootstrap`和`yum`。
- en: Creating a Container with debootstrap
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用debootstrap创建容器
- en: The `debootstrap` utility is a tool that will install a Debian- or Ubuntu-based
    system into a subdirectory of another already installed system. It is available
    in the repositories of SUSE, Debian, and Ubuntu; on CentOS or other Red Hat–based
    distributions, you'll need to pull it from the **Extra Packages for Enterprise
    Linux** (**EPEL**) repository.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`debootstrap`实用程序是一个工具，可以将基于Debian或Ubuntu的系统安装到已安装系统的子目录中。它在SUSE、Debian和Ubuntu的存储库中可用；在CentOS或其他基于Red
    Hat的发行版上，您需要从**企业Linux的额外软件包**（**EPEL**）存储库中获取它。'
- en: As an example, let's bootstrap Debian on a CentOS machine to create a template
    for our systemd containers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们在CentOS机器上引导Debian，以创建我们的systemd容器的模板。
- en: 'For the purposes of this chapter, if you are running on CentOS, you have to
    change the security label for systemd-nspawn:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果您正在运行CentOS，您必须更改systemd-nspawn的安全标签：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, install debootstrap:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装debootstrap：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a subdirectory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个子目录：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And bootstrap, for instance, from the US mirror of Debian:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从Debian的美国镜像引导：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a Container with yum
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用yum创建容器
- en: The `yum` utility is available in every repository and can be used to create
    a container with a Red Hat–based distribution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`yum`实用程序在每个存储库中都可用，并且可用于创建具有基于Red Hat的发行版的容器。'
- en: 'Let''s go through the steps to create a CentOS 7 container:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看创建CentOS 7容器的步骤：
- en: 'Create a directory in which we''re going to install CentOS, and that will be
    used for our template:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录，我们将在其中安装CentOS，并将其用作我们的模板：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, you have to download the `centos-release rpm` package at [http://mirror.centos.org/centos-7/7/os/x86_64/Packages/](http://mirror.centos.org/centos-7/7/os/x86_64/Packages/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须在[http://mirror.centos.org/centos-7/7/os/x86_64/Packages/](http://mirror.centos.org/centos-7/7/os/x86_64/Packages/)下载`centos-release
    rpm`软件包。
- en: 'Initialize the `rpm` database and install this package:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`rpm`数据库并安装此软件包：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you are ready to install at least the bare minimum:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经准备好至少安装最低限度的内容了：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the installation of the packages, a complete root filesystem is available,
    providing everything that is needed to boot the container. You can also use this
    root filesystem as a template; in that scenario, you need to modify the template
    to make sure that every container is unique.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件包后，将可用完整的根文件系统，提供启动容器所需的一切。您还可以使用此根文件系统作为模板；在这种情况下，您需要修改模板以确保每个容器都是唯一的。
- en: systemd-firstboot
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: systemd-firstboot
- en: 'systemd-firstboot is a nice way to configure a few things if you start the
    container for the first time. You can configure the following parameters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: systemd-firstboot是在首次启动容器时配置一些内容的好方法。您可以配置以下参数：
- en: System locale (`--locale=`)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统区域设置（`--locale=`）
- en: System keyboard map (`--keymap=`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统键盘映射（`--keymap=`）
- en: System time zone (`--timezone=`)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统时区（`--timezone=`）
- en: System hostname `(--hostname=`)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统主机名（`--hostname=`）
- en: Machine ID of the system (`--machine-id=`)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的机器ID（`--machine-id=`）
- en: Root user's password (`--root-password=`)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Root用户的密码（`--root-password=`）
- en: You can also use the `-prompt` parameter to ask for these parameters at first
    boot.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`-prompt`参数在首次启动时请求这些参数。
- en: In the following example, we will be modifying the systemd-firstboot unit to
    pass a configuration that is going to be executed when the container is run for
    the first time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将修改`systemd-firstboot`单元，以传递在首次运行容器时将执行的配置。
- en: 'Execute `chroot` in the container directory. Let''s take our CentOS image as
    an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器目录中执行`chroot`。让我们以我们的CentOS镜像为例：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Fire up the image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 启动镜像：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open the systemd-firstboot unit, `/usr/lib/systemd/system/systemd-firstboot.service`,
    and modify it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`systemd-firstboot`单元，`/usr/lib/systemd/system/systemd-firstboot.service`，并对其进行修改：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Enable the service:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 启用服务：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Clean up the settings:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清理设置：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exit the chroot environment with *Ctrl* + *D*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *D*退出chroot环境。
- en: Deploying the First Container
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署第一个容器
- en: 'If you are using the BTRFS filesystem template directory as a subvolume, you
    can use the `--template` parameter of systemd-nspawn. Otherwise, it will create
    a new subvolume:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用BTRFS文件系统模板目录作为子卷，可以使用`systemd-nspawn`的`--template`参数。否则，它将创建一个新的子卷：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s time to boot our first container:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候启动我们的第一个容器了：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Try to log in and kill it with *Ctrl* + *]]]*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试登录并使用*Ctrl* + *]]]*杀死它。
- en: 'From now on, you can manage the containers with the `machinectl` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，您可以使用`machinectl`命令管理容器：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Log in with the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下登录：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are many other parameters of `machinectl` that are worth investigating!
    If you get a permission-denied message, think about SELinux troubleshooting! Also,
    `journalctl` has a `-M` parameter to see the logging within the container, or
    use the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`machinectl`还有许多其他参数值得研究！如果收到权限被拒绝的消息，请考虑SELinux故障排除！此外，`journalctl`有一个`-M`参数，用于查看容器内的日志，或者使用以下命令：'
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you execute `hostnamectl` in the container, you''ll see something similar
    to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在容器中执行`hostnamectl`，您将看到类似以下内容：
- en: '![Detailed output of the hostnamectl command](img/B15455_09_02.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![hostnamectl命令的详细输出](img/B15455_09_02.jpg)'
- en: 'Figure 9.2: Output of the hostnamectl command'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.2：hostnamectl命令的输出
- en: The kernel is the one of the host!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是主机的内核！
- en: Enabling a Container at Boot Time
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在启动时启用容器
- en: 'To make a container available at boot time, enable the target, `machines.target`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使容器在启动时可用，请启用目标`machines.target`：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now create a `nspawn` file for our container: `/etc/systemd/nspawn/centos01.nspawn`.
    The filename must be the same as the container:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为我们的容器创建一个`nspawn`文件：`/etc/systemd/nspawn/centos01.nspawn`。文件名必须与容器相同：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`[Network]` also sets up port forwarding from TCP port `80` in the container
    to port `80` on the host. You have to configure an IP address on the network interface
    in the container and on the host on the virtual Ethernet interface in the subnet
    to make it work.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Network]`还设置了从容器的TCP端口`80`到主机的端口`80`的端口转发。您必须在容器中的网络接口上配置IP地址，并在子网中的虚拟以太网接口上配置主机上的IP地址，以使其正常工作。'
- en: 'Now enable the VM:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启用VM：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that you know how to work with systemd-nspawn and deploy your container,
    let''s go ahead and discuss the most popular containerization tool: Docker. You
    might have heard a lot about Docker, so let''s get started!'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用`systemd-nspawn`并部署您的容器，让我们继续讨论最流行的容器化工具：Docker。您可能已经听说过很多关于Docker的事情，所以让我们开始吧！
- en: Docker
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: In March 2010, Solomon Hykes started the development of Docker. It started in
    France as an internal dotCloud. Thanks to the public release at a big Python conference
    in 2013 and the interest of Red Hat, Docker really took off. In the last quarter
    of that same year, the name of the company was changed to Docker Inc.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年3月，Solomon Hykes开始开发Docker。它在法国作为内部dotCloud开始。由于2013年在一次大型Python会议上的公开发布以及Red
    Hat的兴趣，Docker真正起飞。在同年的最后一个季度，公司的名称更改为Docker Inc。
- en: Docker was originally built on top of LXC but after a while, LXC was replaced
    by their own `libcontainer` library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Docker最初是建立在LXC之上的，但过了一段时间，LXC被他们自己的`libcontainer`库所取代。
- en: 'The architecture of Docker is quite complex: it consists of a client, Docker,
    and a daemon, `dockerd`. Another daemon, `containerd`, is an abstraction layer
    for the OS and the type of container technology that is being used. You can interact
    with `containerd` using the `docker- containerd-ctr` utility. The `containerd`
    daemon is responsible for the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的架构非常复杂：它由客户端、Docker和守护进程`dockerd`组成。另一个守护进程`containerd`是操作系统和正在使用的容器技术类型的抽象层。您可以使用`docker-containerd-ctr`工具与`containerd`进行交互。`containerd`守护进程负责以下内容：
- en: The registry (where you can store images)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表（您可以存储镜像的地方）
- en: The image (building, metadata, and so on)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像（构建、元数据等）
- en: Networking
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Volumes (to store persistent data)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷（用于存储持久数据）
- en: Signing (trust on content)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名（内容的信任）
- en: '`containerd` communicates with RunC, which is responsible for the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`containerd`与RunC通信，RunC负责以下内容：'
- en: Life cycle management
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期管理
- en: Runtime information
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时信息
- en: Running commands within the container
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内运行命令
- en: Generating the specs (image ID, tags, and so on)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成规格（镜像ID、标签等）
- en: There are two editions of Docker available—**Docker Community Edition** (**CE**)
    and **Docker Enterprise Edition** (**EE**). Docker EE was sold to Mirantis by
    Docker Inc in November 2019; however, Docker CE is still handled by Docker Inc.
    Docker EE adds Docker support, but also an integrated security framework, certified
    plugins, support for Docker Swarm (which is a container orchestration solution
    like Kubernetes), and support for RBAC/AD/LDAP. All of this comes at a price,
    though. If you feel like your environment needs these added advantages, it's worth
    paying for. On the other hand, Docker CE is open-source software that is available
    for free.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有两个版本可用——**Docker社区版**（**CE**）和**Docker企业版**（**EE**）。Docker EE于2019年11月由Docker
    Inc出售给Mirantis；然而，Docker CE仍由Docker Inc处理。Docker EE增加了Docker支持，还有集成的安全框架，认证插件，对Docker
    Swarm（类似于Kubernetes的容器编排解决方案）的支持，以及对RBAC/AD/LDAP的支持。然而，所有这些都是需要付费的。如果您觉得您的环境需要这些额外的优势，那么值得付费。另一方面，Docker
    CE是开源软件，可以免费使用。
- en: Docker Installation
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker安装
- en: There are multiple ways to install and use Docker CE in Azure. You can install
    a Linux distribution of your choice and install Docker on top of it. There are
    several VMs available in the Azure Marketplace, such as RancherOS, which is a
    very minimal Linux distribution that was specially created to run Docker. And,
    last but not least, there is the Docker for Azure template, which is provided
    by Docker at [https://docs.docker.com/docker-for-azure](https://docs.docker.com/docker-for-azure)
    and [https://docs.docker.com/docker-for-azure](https://docs.docker.com/docker-for-azure).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中有多种安装和使用Docker CE的方法。您可以安装您选择的Linux发行版，并在其上安装Docker。Azure Marketplace中提供了几个VM，如RancherOS，这是一个非常精简的Linux发行版，专门用于运行Docker。最后但同样重要的是，还有Docker
    for Azure模板，由Docker提供，网址为[https://docs.docker.com/docker-for-azure](https://docs.docker.com/docker-for-azure)和[https://docs.docker.com/docker-for-azure](https://docs.docker.com/docker-for-azure)。
- en: 'For the purposes of this chapter, the Docker on Ubuntu Server VM is absolutely
    not a bad idea; it saves a lot of work! But there are several reasons not to use
    this VM:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的目的，Ubuntu服务器VM上的Docker绝对不是一个坏主意；它可以节省很多工作！但是有几个原因不使用这个VM：
- en: It really can help to understand things better if you configure everything yourself.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您自己配置一切，确实可以帮助更好地理解事物。
- en: The software used is relatively old.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的软件相对较旧。
- en: The Docker VM extension that is used to create the VM is deprecated and not
    in active development any longer.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建VM的Docker VM扩展已被弃用，不再处于活跃开发状态。
- en: The Docker for Azure template also installs and configures Docker Swarm, a Docker-native
    clustering system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Docker for Azure模板还安装并配置了Docker Swarm，这是一个Docker本地的集群系统。
- en: The Docker website provides excellent documentation about how to install Docker
    manually. If you would like to install using `apt` or `yum` without following
    the script, you can follow the official Docker documentation ([https://docs.docker.com/v17.09/engine/installation/#supported-platforms](https://docs.docker.com/v17.09/engine/installation/#supported-platforms)).
    If you are following that, then you can skip the `cloud-init` script.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Docker网站提供了关于如何手动安装Docker的优秀文档。如果您想使用`apt`或`yum`进行安装而不是按照脚本，可以按照官方Docker文档进行操作（[https://docs.docker.com/v17.09/engine/installation/#supported-platforms](https://docs.docker.com/v17.09/engine/installation/#supported-platforms)）。如果您按照这个方法操作，可以跳过`cloud-init`脚本。
- en: Here, we'll follow the installation via our script. Please note that this script
    is convenient for lab environments, but not for production environments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将按照我们的脚本进行安装。请注意，这个脚本对实验环境很方便，但不适用于生产环境。
- en: It installs the latest version of Docker from the Edge channel, not from the
    Stable channel. In theory, this could be a little bit unstable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它从Edge渠道安装最新版本的Docker，而不是从Stable渠道。理论上，这可能会有点不稳定。
- en: However, for the purposes of this chapter, it's a good way to get started. To
    get things up and running very quickly, let's use the technique of cloud-init
    that we learned in *Chapter 7, Deploying Your Virtual Machines*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于本章的目的，这是一个很好的开始方式。为了快速启动和运行，让我们使用*第7章，部署您的虚拟机*中学到的cloud-init技术。
- en: 'Start by creating a new resource group, for instance, `Docker_LOA`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的资源组，例如`Docker_LOA`：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a cloud-init configuration file; in my example, the file is named `docker.yml`
    with the following content:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个cloud-init配置文件；在我的示例中，文件名为`docker.yml`，内容如下：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Don't forget to replace `<ssh user>` with the login name of the account you're
    using to execute the `az` command.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记用您用于执行`az`命令的帐户的登录名替换`<ssh user>`。
- en: 'You might have noticed that we added `ExecStart` twice in the script. ExecStart
    allows you to specify what command needs to be run when a unit is started. It''s
    a good practice to clear it by setting `ExecStart=` and then specifying the actual
    command in the second line. The reason is that when Docker is installed, it will
    have an `ExecStart` value initially and when we supply another value, it will
    lead to a conflict. This conflict will stop the service from starting. Let''s
    go ahead and create a VM with Docker installed using the cloud-init file we created:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a VM with the distribution of your choice:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the VM is ready, log in and execute the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you get a message that says "`Warning: docker.service changed on disk, run
    systemctl daemon-reload to reload docker.service`," be patient, cloud-init is
    still busy. Also, if you see that `docker.service` is not found, allow some time
    for cloud-init to finish the installation. You can always verify if the Docker
    CE is installed by executing `dpkg -l | grep docker`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following to receive even more information about the Docker daemon:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s time to download our first container and run it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the following screenshot, you can see that the container was run successfully
    and you received a `Hello from Docker!` message:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Successful execution of the container using docker run hello-world command](img/B15455_09_03.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Successful container execution'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A Docker container is an executed image. To list the available images on your
    system, execute the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the previous example, we ran `docker run hello-world`. So, the image is
    already pulled in and you can see that the `hello-world` image is listed when
    we use the `docker image ls` command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the hello-world image by using the docker image'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: ls command](img/B15455_09_04.jpg)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: Listing the Docker image'
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you execute `docker run hello-world` again, this time the image will not
    be downloaded. Instead, it will go for the image that was already stored or downloaded
    during the previous run.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s download another image:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, we''ll list all containers, even those that are not running:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All containers have the `exited` status. If you want to keep the container
    running, you have to add the `-dt` parameters to the run command; `-d` means run
    as detached:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want an interactive shell to the Ubuntu container (as you SSH to a VM),
    you can add the `-i` parameter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Verify that it is running by viewing the process list again:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the container ID or name, you can execute a command in a container and
    receive the standard output in your Terminal:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For instance, you can execute the following command to see the OS release of
    the container image:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Attach to the container to verify whether the content is as expected:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And detach using *Ctrl* + *P* and *Ctrl* + *Q*, which means that you will exit
    from the interactive shell and the container will start running in the background.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, if you have been following along, by this time, you will be able
    to run containers, run them as detached, execute commands to the container from
    the host machine, and also get an interactive shell to the container. So far,
    we have used images that are already available in Docker Hub. In the next section,
    we will learn how to build our own Docker images with custom configurations from
    a base image.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Building Docker Images
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Docker image contains layers. For every command you run to add a component
    to the container, a layer is added. Each container is an image with read-only
    layers and a writable layer on top of that. The first layer is the boot filesystem
    and the second is called the base; it contains the OS. You can pull images from
    the Docker Registry (you'll find out more about the Registry later on) or build
    them yourself.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to build one yourself, you can do so in a similar way to what we
    saw earlier on, with systemd-nspawn containers, for instance, by using debootstrap.
    Most of the commands require root user access, so escalate your privileges as
    follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己构建一个，可以以类似的方式进行，就像我们之前看到的那样，使用systemd-nspawn容器，例如，通过使用debootstrap。大多数命令需要root用户访问权限，因此请按以下方式提升您的权限：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s take Debian as the base image here. This will help you understand the
    `docker import` command. Download and extract Debian Stretch:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Debian作为基本镜像。这将帮助您了解`docker import`命令。下载并提取Debian Stretch：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a tarball and import it directly into Docker:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个tarball并将其直接导入Docker：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Verify it using the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令进行验证：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Docker also provides a very minimal base image called `scratch`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还提供了一个名为`scratch`的非常小的基本镜像。
- en: 'A Docker image is built from a Dockerfile. Let''s create a working directory
    to save the Dockerfile:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是从Dockerfile构建的。让我们创建一个工作目录来保存Dockerfile：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As the `stretch` image is already available in Docker Hub, it''s a good idea
    to tag your image with a new name so that Docker will not try to pull the image,
    but rather go for the local image. To tag the image, use the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`stretch`镜像已经在Docker Hub中可用，因此最好使用新名称标记您的镜像，以便Docker不会尝试拉取镜像，而是选择本地镜像。要标记镜像，请使用以下命令：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, create a Dockerfile by executing `vi Dockerfile` (you can use any text
    editor). The first line in this file adds the base image as a layer:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过执行`vi Dockerfile`（您可以使用任何文本编辑器）创建一个Dockerfile。此文件中的第一行将基本镜像添加为一个层：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The second layer contains Debian updates:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层包含Debian更新：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The third layer contains the Apache installation:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第三层包含Apache安装：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the latest layer and run Apache in this read/write layer. `CMD` is used
    to specify the defaults for executing the container:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 添加最新的层并在这个读/写层中运行Apache。`CMD`用于指定执行容器的默认值：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Open port `80`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 打开端口`80`：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Save the file and your file entries will look like the following screenshot.
    Adding comments is a good practice; however, it''s optional:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，您的文件条目将如下截图所示。添加注释是一个好习惯；但是，这是可选的：
- en: '![Docker image creation using cat Dockerfile](img/B15455_09_05.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![使用cat Dockerfile创建Docker镜像](img/B15455_09_05.jpg)'
- en: 'Figure 9.5: Creating a Docker image'
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.5：创建Docker镜像
- en: 'Build the container:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If everything went well, the output should show something similar to the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，输出应该显示类似于以下内容：
- en: '![Output representing successfully built Docker image](img/B15455_09_06.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![表示成功构建Docker镜像的输出](img/B15455_09_06.jpg)'
- en: 'Figure 9.6: Docker image built successfully'
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.6：成功构建Docker镜像
- en: 'You can test the container:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以测试容器：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Review the history of the build:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 查看构建历史：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As shown in the following screenshot, you''ll be able to see the history of
    the build for your container:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，您将能够查看容器的构建历史：
- en: '![Detailed output displaying the history of the built container ](img/B15455_09_07.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![显示构建容器的详细输出](img/B15455_09_07.jpg)'
- en: 'Figure 9.7: Reviewing the history of the container built'
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.7：审查构建的容器历史
- en: 'Execute `docker ps` to get the ID of the container, and use that to collect
    information about the container:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`docker ps`以获取容器的ID，并使用该ID收集有关容器的信息：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the output, you can find the IP address of the container:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您可以找到容器的IP地址：
- en: '![Output of the IP address of the container](img/B15455_09_08.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![容器的IP地址输出](img/B15455_09_08.jpg)'
- en: 'Figure 9.8: Fetching the IP address of the Docker'
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.8：获取Docker的IP地址
- en: 'Use `curl` to see whether the web server is really running:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`查看Web服务器是否真的在运行：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You will be able to see the famous "It works" page in HTML as shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够在此处看到著名的HTML“它起作用”页面：
- en: '![Testing the web server using curl command](img/B15455_09_09.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![使用curl命令测试Web服务器](img/B15455_09_09.jpg)'
- en: 'Figure 9.9: Using the curl command to test the web server'
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.9：使用curl命令测试Web服务器
- en: 'Now, we''ll stop the container using the following command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下命令停止容器：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now run it again:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行它：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This makes the website available on localhost port `8080`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使网站在本地主机端口`8080`上可用。
- en: You can also use **acbuild** to build Docker containers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用**acbuild**来构建Docker容器。
- en: Docker Machine
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker Machine
- en: 'There is another way to create Docker containers: Docker Machine. This is a
    tool that creates VMs that will host Docker. It''s something you should run on
    a development machine, physical or not, and you should execute everything remotely.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种创建Docker容器的方法：Docker Machine。这是一个创建将托管Docker的VM的工具。这是您应该在开发机器上运行的东西，无论是物理的还是虚拟的，您都应该远程执行所有操作。
- en: Please note that Docker Machine can be installed on macOS, Linux, and Windows
    machines. Refer to the Docker Machine documentation ([https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/))
    for macOS and Windows installation as we're following only the Linux installation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Docker Machine可以安装在macOS、Linux和Windows机器上。请参考Docker Machine文档（[https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/)）以获取macOS和Windows安装信息，因为我们只关注Linux安装。
- en: 'Switch back to the Ubuntu machine where we installed Docker. Install the following
    dependency:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回安装了Docker的Ubuntu机器。安装以下依赖项：
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, you need to download Docker Machine and then extract it to your `PATH`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要下载Docker Machine，然后将其提取到您的`PATH`中：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Autocompletion can be very useful, and also make sure you run the following
    script as root, as the script will write to the `/etc/` directory:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 自动补全可能非常有用，还要确保以root身份运行以下脚本，因为脚本将写入`/etc/`目录：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Log out and log in again. In order to verify that `bash-completion` is working,
    you can tap the tab button to see available commands for `docker-machine` as shown
    in the following screenshot:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注销并重新登录。为了验证`bash-completion`是否有效，您可以点击tab按钮查看`docker-machine`的可用命令，如下截图所示：
- en: '![To verify the bash-completion using docker-machine command](img/B15455_09_10.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![使用docker-machine命令验证bash-completion](img/B15455_09_10.jpg)'
- en: 'Figure 9.10: Verifying that bash-completion is successful'
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.10：验证bash-completion是否成功
- en: 'Verify the version:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using Azure as a driver, you can now deploy a VM:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are other options, such as the public IP and the resource group name,
    that can be passed during deployment. You can see the complete list and default
    values for these options in the Docker documentation ([https://docs.docker.com/machine/drivers/azure/](https://docs.docker.com/machine/drivers/azure/)).
    If we don't specify a value for a specific option, Docker will take the default
    value. Another thing to keep in mind is that the VM name should only contain lowercase
    alpha-numeric characters or hyphens if required; otherwise, you will get an error.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see that the deployment of a VM named
    `docker-machine-2` of size `Standard_A2` was successful and that Docker is running
    on the machine. For simplicity, we have saved our subscription ID to a variable,
    `$SUB_ID`, so that we don''t have to check it every time; you can also do the
    same if required. Since we have already authenticated before, the driver is not
    asking us to sign in again. The driver remembers your credentials for up to two
    weeks, which means you don''t have to sign in every time you deploy. You can also
    see what resources were deployed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Output representing successful deployment of docker-machine-2 VM](img/B15455_09_11.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Deploying the docker-machine-2 VM'
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To tell Docker to use the remote environment instead of running containers
    locally, execute the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To verify that the remote environment is being used, use the `info` command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Among other information, the output shows you that you are using a specific
    VM running in Azure:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Detailed information about the Docker using dockor info command](img/B15455_09_12.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Fetching the docker information'
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And for Docker Machine, execute the following command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output should be similar to the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing various detail of the Docker machine](img/B15455_09_13.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Listing docker-machine'
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s create an nginx container with the host port `80` mapped to container
    port `80`. This means that all traffic coming to the host VM''s port `80` will
    be directed to port `80` of the container. This is given using the `–p` parameter.
    Execute the following command to create an nginx container:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Find the IP address of the VM:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Use that IP address in a browser to verify that nginx is running.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Machine also allows us to copy files into the VM with the `scp` parameter,
    or even to mount the files locally:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Use `docker ps` to find the running instances, stop them, and remove them, so
    that they are ready for the next utility.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker Compose is a tool for creating a multiple-container application, for
    instance, a web application that needs a web server and a database.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check for the latest or stable release of Docker Compose at [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)
    and install it, replacing the version number in the command with the latest release:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, apply executable permission to the binary we downloaded:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, verify the installation:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the installation was successful, you will be able to see the version of
    Docker Compose installed:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying the version of the Dockor Compose information](img/B15455_09_14.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Verifying Docker compose installation'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After installation, if the preceding command fails, then check your path or
    else create a symbolic link to `/usr/bin` or any other directory in your path.
    To find out what directories are in your `PATH`, execute `$PATH` in the shell.To
    create a symbolic link, execute `sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `docker-compose.yml` with the following content:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Replace `<password>` with the password of your choice. While still being connected
    to the Azure environment, using Docker Machine, execute the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the build is successful, two containers are running, which you can verify
    by using `docker ps` and opening a browser with the correct IP address (`docker-machine
    ip <vm name>`). The WordPress installer is waiting for you.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Docker Registry
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every time we executed `docker run` or `docker pull` (download only), images
    were fetched from the internet. Where did they come from? Run this command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output of the preceding command gives you the answer: [https://index.docker.io/v1/](https://index.docker.io/v1/).
    This URL is the official Docker Hub. Docker Hub, or Docker Store, also has a nice
    web interface available via [https://hub.docker.com](https://hub.docker.com),
    and is an online repository of private and publicly available Docker images.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker search` command can be used to search this repository. To limit
    the output of this command, you can add filters:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here''s the output of the `docker search` command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of docker search command](img/B15455_09_15.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: Output of the docker search command'
  id: totrans-321
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Optionally, add the `--no-trunc` parameter to see the complete description of
    the image. In the output, there is also a star rating that can help us to select
    the best available image.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: If you create your own account on the Docker Hub website, you can use `docker
    push` to upload your images to the registry. It is free of charge!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in with the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Build the image:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can also tag the image afterward:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For versioning, it is a good idea to use a string such as `v1.11.1.2019`, which
    means the first version was released on November 1, 2019\. If you don't add the
    version, it is tagged as the latest version.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'You can''t see the tags using the `docker search` command. You''ll need the
    web interface or to query the Docker API using `curl` (a tool to transfer data
    to and from a server) and `jq` (a tool similar to `sed` but specifically for JSON
    data):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: jq is not installed by default. You have to install it using `apt install jq`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'This output will be in JSON format. You can further query using `jq` and refine
    the output if needed. If you don''t want to use jq for formatting JSON, you can
    use the native `sed`, `tr`, and `cut` commands to format output and get something
    cleaner:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you would like to get all the tags for nginx, you can replace `<image name>`
    with `nginx`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed Docker Hub and how to check available images. Similarly, Azure
    offers Azure Container Registry, where you can store your private images and pull
    them when required. Before we start Azure Container Registry, we need to understand
    Azure Container Instances, with which you can run containers without the hassle
    of managing the host machines. Let's go ahead and learn more.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Instances
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are able to run a container in a VM, we can go one step further:
    we can use the Azure Container Instances service to run it without managing servers.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do that using the Azure portal. In the left-hand navigation bar, select
    **All Services** and search for **Container instances**. Once you are in **Container
    instances**, click on **Add** to create a new container instance and the portal
    will redirect you to the following window:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new container instance on the Azure Container Instances portal](img/B15455_09_16.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Creating a Docker container instance'
  id: totrans-343
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can create a resource group or use an existing one. Set the container name
    to `nginx`, set `Public` because we are going to pull a public image, set the
    image name to `nginx:latest`, set `Linux`, and choose the desired resource requirement
    for the container. Hit **Next** and in the **Networking** section, we will expose
    **port 80** for HTTP traffic as shown in the following screenshot. Also, you can
    add a **DNS label** and opt for a public IP address if required:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding networking details for container instance](img/B15455_09_17.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Adding networking details a container instance'
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is enough for the validation and creation of the instance. You can skip
    the next sections and go to **Review+ Create**. However, Azure offers advanced
    options in the **Advanced** tab. These can be used to add environment variables,
    set the restart policy option, and use command override to include a set of commands
    that need to be executed when the container is initialized. If you want, you can
    configure this as well.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create containers with the command line using the Azure CLI:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can also use PowerShell:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Please note that the DNS label must be unique in your region.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output of the commands, the IP address of the instance is visible:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![Container creation using PowerShell](img/B15455_09_18.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: Creating containers using PowerShell'
  id: totrans-355
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You should be able to access the web server on an FQDN and IP address. As shown
    in the screenshot, you can point your browser to the DNS label or IP address and
    you can see the **Welcome to nginx!** page:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of the web page when the browser is pointed to the DNS label](img/B15455_09_19.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: Output of the web server when the browser is pointed to the DNS
    label'
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To get the list of container instances, execute the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Alternatively, execute the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: So far, we have been relying on the Docker Registry to save, pull, and push
    images. Azure offers a private image registry where you can store your images
    so that they can be used when needed. This service is called Azure Container Registry.
    Let's learn about it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Registry
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, instead of the Docker Registry, you can use the private Azure
    Container Registry. This service is not free of charge! Using this Azure service
    has the advantage that you have all the features of Blob storage (reliability,
    availability, replication, and so on) and can keep all the traffic within Azure,
    which makes this registry an interesting option in terms of features, performance,
    and cost.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure Portal
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to create a registry is by using the Azure portal. In the left-hand
    navigation bar, select **All Services** and search for **Container registries**.
    Click on **Add** and you should get the following screen. Don''t forget to enable
    the **Admin user** option; by doing so, you can sign in to the container registry
    via **docker login** with the username as the registry name and the password as
    the access key:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![Container registry creation using the Azure portal](img/B15455_09_20.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: Creating a container registry using the Azure portal'
  id: totrans-369
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If the registry is ready, there will be a popup saying that the job is finished
    and you will be able to see the resource. If you navigate to the **Access Keys
    blade**, you will find the login server and your username, which is the same as
    the registry name and the set of passwords:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Access key blade pane](img/B15455_09_21.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.21: The Access key blade pane'
  id: totrans-372
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use this information to log into the repository, the same way you did with Docker
    Hub.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: After pushing an image, it will be available in the repository. From there,
    you can deploy it to the Azure Container Instances service and run it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure CLI
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have created an Azure Container Registry instance via the Azure portal. It
    is also possible to use the Azure CLI and PowerShell to perform the same task.
    We will be following the Azure CLI steps and we encourage you to attempt this
    process using PowerShell on your own.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we need a Linux VM in which Docker and the Azure CLI are installed.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a resource group, or you can use the same resource
    group that was used in the portal example. Just to recall the command we studied
    in the beginning, in the *Docker Installation* section; we will proceed with a
    new resource group:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Once you get the success message, proceed with the creation of the container
    registry using the following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we are creating the container registry with the Basic SKU. There are other
    SKUs available that offer more storage options and throughput. SKUs point to different
    pricing tiers of container registry. Visit the Microsoft Azure pricing page ([https://azure.microsoft.com/en-in/pricing/details/container-registry/](https://azure.microsoft.com/en-in/pricing/details/container-registry/))
    to see the pricing of each SKU. Since this is a demonstration and to keep the
    cost minimal, we will go with Basic.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'After the deployment of the Azure Container Registry instance, we will log
    in to the registry. But to sign in, we require the password. We already know the
    username, which is the name of the registry, so let''s find the password of the
    registry:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output will show the username and password. Please make a note of them.
    You can use password 1 or password 2\. Now that we are sure of the credentials,
    we''ll log in to the Azure Container Registry instance by executing the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If the login is successful, you should receive the output shown in the following
    screenshot:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![Output displaying successful login of Azure Container Registry](img/B15455_09_22.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.22: Azure Container Registry login successful'
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's go ahead and push an image to the registry. In order to push an image,
    first we need to have an image. If you are using the same VM that was used in
    the previous examples, you might have some images pulled in. If the images are
    not there, you can use `docker pull <image name>` to get the image. You can verify
    the list of available images using the `docker images` command. Since we already
    have an nginx image, we are not going to pull it from Docker Hub.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the image, let''s tag it. Tagging will help you know which
    image you are using. For example, if you have an image tagged as `v1` and you
    make some changes to it, you can tag it as `v2`. Tagging helps you to have a logical
    organization of your images based on release date, version number, or any other
    identifier. We need to tag in a `<AcrLoginName>/<image name>:<version tag>` format,
    where `acr-name` is the FQDN of the Azure Container Registry instance. To get
    the FQDN of the Azure Container Registry instance, execute the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For the nginx image, we are going to tag it as `nginx:v1`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let''s push the tagged image to Azure Container Registry using the `docker
    push` command:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'All layers should be pushed, as shown in the screenshot:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![Pushing the tagged image to Azure Container Registry](img/B15455_09_23.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.23: Pushing the tagged image to the container registry'
  id: totrans-399
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Suppose you have pushed multiple images to Azure Container Registry and would
    like to get a list of all images. Then you can make use of the `az acr repository
    list` command. To list all the images in the Azure Container Registry instance
    we created, use this command:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You can use the `docker run` command to run the container. But always make sure
    that the image name is in the format `<AcrLoginName>/<image>`. The era of Docker
    is going to end, and eventually it will be replaced with daemonless next-generation
    tools.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The next section is all about these tools and how you can create an analogy
    with Docker for a smooth transition.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Buildah, Podman, and Skopeo
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed how Docker works and how it can be used
    to deploy containers. As previously stated, Docker uses the Docker daemon, which
    helps us to achieve all this. What if we say people have started bidding goodbye
    to Docker? Yes, with the introduction of next-generation container management
    tools, Docker is fading away. We are not saying that Docker is completely out
    of the picture, but in time it will be replaced by rootless or daemonless Linux
    container tools. You read it right: there is no daemon running for these tools,
    and the approach of using the monolith daemon is coming to an end. No wonder people
    have started calling the containers deployed using these tools "Dockerless containers."'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: History
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might wonder when this all happened. Back in 2015, Docker Inc. and CoreOS,
    along with some other organizations, came up with the idea of the **Open Container
    Initiative** (**OCI**). The intention behind this was to standardize the container
    runtime and image format specs. OCI image format is supported by most container
    image registries, such as Docker Hub and Azure Container Registry. Most container
    runtimes that are available now are either OCI-compatible or they have OCI in
    the pipeline. This was just the beginning.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, Docker was the only container runtime available for Kubernetes. Obviously,
    other vendors wanted to have support for their specific runtimes in Kubernetes.
    Due to this dilemma and the lack of support for other vendors, Kubernetes created
    CRI in 2017\. CRI stands for Container Runtime Interface. You can use other runtimes,
    such as CRI-O, containerd, or frakti. Since Kubernetes was booming and due to
    their support for multiple runtimes, the monopoly of Docker started to topple.
    In no time, the monopoly status of Docker changed and it became one of the supported
    runtimes in Kubernetes. The ripples made by this change actually gave birth to
    the idea of daemonless tools and the idea to overthrow the approach of using the
    monolith daemon, which requires superuser access.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using generic terms, let's try to understand popular ones. Buildah
    is for building containers, Podman is for running containers, and Skopeo lets
    you perform various operations on images and repositories where images are stored.
    Let's take a closer look at each of these tools. Some people suggest removing
    Docker before using these tools, but we suggest keeping Docker so that you can
    constantly compare these tools to it. If you have followed the previous sections
    on Docker, you will be able to create an analogy.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing these tools is very straightforward. You can use apt in Ubuntu or
    yum in RHEL to install these tools. Since we are using the same VM, we will be
    following the Ubuntu installation of these packages. To install Buildah, execute
    the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Since we already have the PPA repository added during the installation of Buildah,
    we can deploy Podman straight away using `apt install`. To install Podman, execute
    the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In order to install Skopeo, we need `snap` to be installed on the Ubuntu VM.
    If you are on Ubuntu 16.04 LTS or later, snap will be installed by default. Otherwise,
    you have to manually install it using `apt install snapd`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Skopeo using snap:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are getting an error message stating that `revision is not meant production`,
    you can use the `–devmode` parameter to install; this will skip this error and
    complete the installation.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to explore these tools.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Buildah
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed Dockerfiles. Here is the interesting
    part: Buildah has full support for Dockerfiles. All you have to do is write the
    Dockerfile and use the `bud` command, which stands for build-using-docker. Let''s
    take the same example we used in the Dockerfile section. Create a Dockerfile by
    executing `vi Dockerfile` (you can use any text editor) and add the following
    lines:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Save the file.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we build, there is something else we need to take care of. Buildah looks
    for the list of registries in the `/etc/containers/registries.conf` file. If this
    file doesn''t exist, we need to create one, add the following code, and save the
    file:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: By doing so, we are instructing to search Docker Hub for the image. You can
    also add your Azure Container Registry instance to the list if required.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and build the image; make sure you are in the directory where
    the Dockerfile is. Start the build process using this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We have created an image called `nginx-buildah`. To see the list of images,
    you can use the `buildah images` command. Yes, we know it looks very similar to
    how you list images in Docker. We need to keep this analogy in mind and it will
    help you learn.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be similar to this:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of the list of images using buildah images command](img/B15455_09_24.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.24: Listing the images using the buildah command'
  id: totrans-433
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see that Buildah lists the image we pulled from Docker Hub and also
    the image we created that is stored in the localhost repository.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a container from an image, we can use the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This will create a container called `<image>-working-container`. If you want
    to build an nginx container, execute this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You will get a similar output to this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an nginx container using "buildah from nginx" command](img/B15455_09_25.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.25: Building an nginx container'
  id: totrans-441
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Just like using `docker ps` to list all the containers, we will run `buildah
    ps` and we will be able to see the `nginx-working-container` we just created:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the containers using buildah ps command](img/B15455_09_26.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.26: Listing the containers using the buildah ps command'
  id: totrans-444
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Also, we can execute commands directly in the container using the `buildah
    run` command. The syntax is as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Let''s try to print the content of the `/etc/os-release` file of the nginx
    container we created. The command will be as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output will be similar to this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '![Printing the content of the nginx container using buildah run nginx-working-container
    cat /etc/os-release command](img/B15455_09_27.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.27: Printing the content of the nginx container'
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Like Docker, Buildah has support for commands such as `push`, `pull`, `tag`,
    and `inspect`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Podman
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The images we build via Buildah follow OCI compliance and can be used with
    Podman. In Podman, the analogy keeps on continuing; all we have to do is replace
    all Docker commands with Podman commands. One of the key things that we have to
    keep in mind is that in Podman, we cannot do port binding for a container as a
    non-root user. If your container needs a port mapping, then you have to run Podman
    as root. As we have already covered Docker and you are already familiar with Docker
    commands, we will just try to run a container and verify. Let''s create an nginx
    container with the port mapped to `8080`. Since we need to map a port, we will
    run the command as `sudo`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Since we have created the container using the `sudo` command, it will be owned
    by the root user. If a container is created using `sudo`, make sure you chain
    sudo for all actions related to that container.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the containers, use `podman ps`, and we can see that the container
    is listening on `0.0.0.0:8080` of the host, which is mapped to the port of the
    container:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '![Using podman ps command to list the containers](img/B15455_09_28.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.28: Listing the containers using the podman ps command'
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s do a `curl` call and confirm whether the web server is running on port
    `8080` or not:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If everything is working, you will be able to see the nginx welcome page:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying the authentication to the port of the web server curl command](img/B15455_09_29.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.29: Verifying the authentication to the port of the web server'
  id: totrans-464
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Yes, the container is running daemonless!
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: We are not covering all Podman commands here, and once you are familiar with
    Docker, all you have to do is replace `docker` with `podman` in the command line.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Skopeo
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you recall, earlier we tried to get the tags of an image using Docker. Using
    Skopeo, you can inspect a repository, copy images, and delete images. To start
    with, we will use the `skopeo inspect` command to obtain the tags of an image
    in Docker Hub without pulling it:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Running this command will trigger some warnings. You can ignore them. If you
    check the output, you can see that it is giving the tags, layers, OS type, and
    so on.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `skopeo copy` command to copy container images across multiple
    storage repositories. Also, you can use Skopeo with Azure Container Registry.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not be covering all these. However, you can visit the GitHub repositories
    of these tools:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Buildah: [https://github.com/containers/buildah](https://github.com/containers/buildah
    )'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Podman: [https://github.com/containers/libpod](https://github.com/containers/libpod)'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Skopeo: [https://github.com/containers/skopeo](https://github.com/containers/skopeo
    )'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers and Storage
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section aims to give you a basic idea of containers and storage. Every
    build tool that can create images provides the option to add data to your container.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: You should use this feature only to provide configuration files. Data for applications
    should be hosted, as much as possible, outside the container. If you want to quickly
    update/remove/replace/scale your container, it's almost impossible if the data
    is within the container.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: When we create a container, storage is attached to the container. However, the
    containers are ephemeral, which means that the storage is also destroyed when
    you destroy the container. Let's assume you created a Ubuntu container for testing
    and you saved some scripts that were tested on the container in the hope that
    you can use them later. Now, if you accidentally deleted this container, all the
    scripts that you tested and saved for later would be gone.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Your application data is important and you would like to retain it even after
    the container's life cycle is complete. So, we want to separate the data from
    the container life cycle. By doing so, your data is not destroyed and can be reused
    if needed. In Docker, this is achieved by using volumes.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Docker supports a wide range of options for persistent volumes, including Azure
    Files. In other words, you can tie your Azure file share to a Docker container
    as a persistent volume. To demonstrate this, we will go for the host volume, where
    a location will be mounted as a volume to the container. The purpose of these
    steps is to show how data can be saved even after the container is removed from
    the host.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Volume info is passed to the `docker run` command using the `-v` parameter
    while creating the container. The general syntax is as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Assume that you have an application that will create a file in a `/var/log`
    directory in the container and we need to make this persistent. In the next command,
    we are mapping a directory in the host to the `/var/log` directory of the container.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this exercise, you need a Linux VM with Docker running on it. Let''s
    create a `~/myfiles` directory on the host machine that will be mapped to the
    container:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let''s create an Ubuntu container with an interactive shell, where the `-v`
    parameter is passed to mount the volume:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If the container was created successfully, you will be logged in as a root
    user to the container:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Ubuntu container](img/B15455_09_30.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.30: Creating the Ubuntu container'
  id: totrans-491
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We will go to the `/var/log` directory of the container and create 10 empty
    files using this command:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Listing the contents of the directory will show the 10 files we just created:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the list of recent 10 files created in the /var/log directory](img/B15455_09_31.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.31: Listing the contents of the /var/log directory'
  id: totrans-496
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exit from the interactive shell using *Ctrl* + *D*, and now we are back in
    the host machine. Now we will delete the container:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `id/name` can be obtained from the output of the `docker ps --all` command.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Now that the container has been deleted, we will go to the `~/myfiles` directory
    of the host machine to verify the contents.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see that the container has been successfully
    deleted; however, the `~/myfiles` directory still holds the files we created inside
    the container:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the files in the ~/myfiles directory](img/B15455_09_32.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.32: Listing the files in the ~/myfiles directory'
  id: totrans-503
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we know how to make our volume persistent. For Docker, there are solutions
    such as [https://github.com/ContainX/docker-volume-netshare](https://github.com/ContainX/docker-volume-netshare).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Docker and want to use Azure Files, you can use Cloudstor,
    a plugin that is available at [https://docs.docker.com/docker-for-azure/persistent-data-volumes](https://docs.docker.com/docker-for-azure/persistent-data-volumes).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure File Storage maybe not the cheapest solution, but this way you get
    all the availability and backup options you need.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: If you're going to use Kubernetes, it's a whole other story. We'll cover that
    in the next chapter.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, another way of deploying your workload in Azure was discussed.
    After an introduction to the history, ideas, and concepts of container virtualization,
    we went into some of the available options. Along with older implementations,
    such as LXC, we discussed other great and rock-solid implementations to host containers:
    systemd-nspawn and Docker.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: We not only saw how to run existing images pulled from repositories but also
    how to create our own image. Perhaps the greatest news is that there is a tool
    called Buildah that is able to create an image using the OCI standard from the
    Open Container Initiative and can be used for Docker.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'The majority of this chapter was about Docker. This is by far the most widely
    implemented container solution today. And, talking about implementations, there
    are many ways to implement/deploy Docker:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Deploy it manually in a VM
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy a ready-to-go VM from the marketplace
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Machine
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Container Instances
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Docker Hub and Azure Container Registry was also discussed.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed new container technologies such as Buildah, Podman, and
    Skopeo.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter with a few words about containers and storage. You might
    be wondering what will happen to the storage attached to a container if the container
    is destroyed, or how to make the storage persistent. You will learn about persistence
    in the next chapter, *Chapter 10*, *Working with Azure Kubernetes Service*. Also,
    we will be discussing the famous container orchestration tool Kubernetes.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are the reasons for using containers?
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When are containers not the solution that you need?
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you need something like a virtual private server, do you want a VM, or is
    there a container virtualization solution available that may be a good idea?
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why shouldn't it be difficult to migrate from one solution, let's say Docker,
    to another, for example, Buildah?
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a development machine used for?
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is using Buildah such a good idea, even if it is under heavy development?
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why shouldn't you store application data in a container?
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Carrying out further reading is not a very easy thing to do in the area of
    container virtualization. For `systemd-nspawn`, it''s relatively easy: the man
    pages are an easy read. Let''s make a suggestion that is relevant for `systemd-nspawn`
    and even Docker: Red Hat provides a document on their website called the Resource
    Management Guide ([https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/))
    with good information about cgroups.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of references on Docker are listed here:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '*Orchestrating Docker*, by Shrikrishna Holla, where you can understand how
    to manage and deploy Docker services'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Docker Enterprise: A companion guide for agile container adoption*,
    by Mark Panthofer, where you can explore add-on services of Docker EE and how
    they can be used'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
