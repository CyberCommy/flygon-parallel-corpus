- en: Advanced IoT Exploitation and Security Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding ROP gadgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining web security vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring continuous integration testing for firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring continuous integration testing for web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring continuous integration testing for mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To exploit IoT vulnerabilities and to be able to protect yourself from them,
    automation is needed to develop weaponized proof of concepts as well as provide
    scalability for defensive security teams. If security teams do not keep pace with
    how fast code is being pushed and developed, vulnerabilities are bound to be introduced.
    Additionally, security teams will need to adapt to the speed of dev teams and
    not hinder their current processes for security testing as well as review. This
    chapter will cover advanced IoT exploitation techniques as well as methods of
    discovering, and preventing IoT vulnerabilities in an automated manner.
  prefs: []
  type: TYPE_NORMAL
- en: Finding ROP gadgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important things during exploitation of embedded devices is
    to have the ability to exploit vulnerable binaries using techniques such as **Return
    Oriented Programming** (**ROP**), which is what we are going to look at in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we require this technique is because during exploitation we often
    need our end result as a shell or execution of a backdoor, which could grant us
    additional information or access to sensitive resources.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of ROP is the same in both ARM and MIPS (and even x86); however,
    there are some platform-level differences which we will need to keep in mind.
    To explain ROP in extremely simple terminology, it involves picking up specific
    instructions (gadgets) from various locations and chaining them together to build
    a complete ROP chain which will perform a specific task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, to perform ROP, we need to be able to identify the useful
    ROP gadgets which can be chained together. To find these specific gadgets, we
    can look at various locations in the libc or other libraries manually, or even
    use automated tools and scripts which can help us do the same.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, we will take a very simple example with a vulnerable
    program on ARM and then also later look at some other examples which will help
    us deepen our understanding of ROP-based exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the components that we will require for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GDB-Multiarch**: This is the GDB for various architectures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BuildRoot**: This is used to compile our vulnerable program for ARM architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PwnDbg**: This is the GDB plugin that aids in exploitation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ropxx**: This is the Python script that helps us combine ROP gadgets and
    build our final chain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not looking at any automated tools as of now, but are rather focusing
    on the manual approach so as to understand the fundamentals. If you would like
    to use an automated tool later (which I recommend), you can take a look at the
    *See also* section for some useful links.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how we can get started with exploiting a plain
    vanilla stack based buffer overflow on an ARM environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vulnerable program in this case is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding program, the `main` function takes a user-supplied
    input and then passes that argument to the vulnerable function which has a buffer,
    with the name buff, of 10 bytes. As expected, if the input argument size is significantly
    larger than the size of the buff, it will lead to an overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Once it overflows the buff, we will need to find a way to overwrite either `pc`
    or `lr` registers to take control of the program execution flow. This can be done
    by setting a breakpoint at the `strcpy` address and then analyzing the stack before
    and after the copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first go ahead and run this program using Qemu emulation for ARM architecture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f923203f-f2e3-4220-af7f-082226249514.png)'
  prefs: []
  type: TYPE_IMG
- en: We have also added the `-``g` parameter to attach a debugger to the running
    instance, in this case at port `12345`, which we can now connect with using GDB,
    as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use GDB-multiarch here followed by specifying the sysroot and remote
    target, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a453c807-b295-4515-b153-58670f379b82.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's set a breakpoint at main (b main) and continue (c) the program.
  prefs: []
  type: TYPE_NORMAL
- en: Now here comes the interesting part of looking for gadgets. To find useful gadgets,
    we need to look for instructions which allow us to set certain values that we
    can jump to, let's say system (in our current scenario), as well as while jumping,
    have an argument as the address of `/bin/sh` which would give us the shell.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we may need to place the address of the system in either `pc`
    or `lr`, and the address of `/bin/sh` in `r0`, which is the first register in
    ARM, and is also taken as an argument to the function that is being called. Once
    we have found the instructions that will allow us do all this, we also need to
    ensure that one of these things are present in the instructions following our
    useful instructions mentioned earlier, namely, either branch to an address, which
    we have control of, or `pop {pc}` or `pop {lr}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the disassembly of `erand48`, which is one of the functions present
    in the `libc`, we can see that it has a specific set of useful instructions which
    allow us to take control of the execution as well as set the value of the registers.
    This is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8958a75-fe9e-4aba-9388-cd0f9f88596e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are three of the instructions that we are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lmd sp, {r0, r1}`: This instruction loads the value of `r0` and `r1` from the
    stack. This will be used to control the `r0`, which serves as an argument to the
    function we are about to jump to (system).'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '`add sp, sp, #12`: This instruction simply increments the stack pointer by
    `12`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pop {pc}`: This instruction pops the value from the stack and puts it inside
    `pc`, which implies that we will be able to take control of the program execution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to find two things now, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The address of the system.
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: The address of `/bin/sh`.
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can find the address of the system using the `print` command or using the
    disass system, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0a19344-b3eb-4fd8-83c1-c1d532ca99a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s generate a cyclic string of 50 characters and see how we can overflow
    the buff to jump to `errand48` successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/790b6335-21ee-4418-badf-395aeb5805a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s debug the program using the generated string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ff91c4d0-3d74-4b23-bdd3-97393858776d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now set a breakpoint at the vulnerable function and continue our execution.
    GDB will hit the breakpoint, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aade2565-8feb-42a0-9db2-2fdff0ec66dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s also set a breakpoint at the last instruction of the vulnerable function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/895ce702-a883-4cd2-8984-872d25808228.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the breakpoint is hit, let''s analyze the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9257c1d1-8390-4d32-821f-e5df160123c2.png)'
  prefs: []
  type: TYPE_IMG
- en: The highlighted instruction will pop two dwords (double words) from the stack
    to `fp` and `pc` respectively. If we look at the second value in the stack here,
    it is `0x61616165` ('eaaa'), which means that this is the value that would go
    in `pc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the offset of this value, we will be able to figure out how many
    characters the offset will be if we want to overwrite `pc` with our desired address.
    We can find this out by using `cyclic` `-``l 0x61616165`, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/55877aa0-d6e0-41af-8894-9b8413cb8ec8.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that we need to place our desired value of `pc` (erand48 `ldm` instruction)
    at the offset of 16 in a Little Endian format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can generate the new string using the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c955cc3e-b427-4da4-a652-6de82d8c106e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can rerun the generated string, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b387db38-5b7f-4808-8411-347674db7c27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this stage, attach GDB as we did earlier. Set the breakpoint on the last
    instruction of the vulnerable function, which is at the address `0x84e0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b98021d4-b4c9-467c-bcfb-f3ba13fa7a8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This time we can see that `pc` is being loaded with the address of `erand48`
    instruction located at `0x4087b9dc`. Let''s step one instruction using `ni` to
    reach the `ldm` instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dacc9ae1-2b73-4594-bb4c-5852142711b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see at this step, the register `r0` is loaded with `0x61616161`,
    which is the register we want to place the address of `/bin/sh string` in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d6a4fb1-9cb7-4831-9847-ff3afcf4fbf5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The effective offset will be *16 + 4 + 0 = 20*, which is presented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, at offset 20, we need to put the address of the string `/bin/sh`, which
    will then be passed to the system as an argument. Step two has more instructions
    to reach pop, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9fb9b1f6-50d0-49f7-aa33-cc8967718ff7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `pc` will get the value of `0x61616164` and the offset can be calculated
    in the same way as we did earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ff96be0-6be7-4173-835c-6681bc305cd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So the effective offset for `pc` will be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*16 + 4 + 0 + 12 = 32*'
  prefs: []
  type: TYPE_NORMAL
- en: This means at offset 32, we will need to put the address of the system, which
    we found earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Also, let's go ahead and put the `/bin/sh` ASCII string at offset 36 and refer
    to it at offset 20\. Thus, the address of the string on stack will be `0x407fff18`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `ropgen` module to generate the exploit string, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab5e3be6-f1b0-47e9-844a-6c94bc0bbf5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s debug and step through the execution once again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/69ceeee0-4890-42a4-8f3e-bdd7a60e7d03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look at the stack now, the ASCII string `/bin/sh` is now at the address
    `0x407fff38`, which means that we need to adjust our code to reflect this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/441da483-a57b-446f-a5c4-a5b15ced8af3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Debugging the same way as we did earlier, we can see that our ASCII string
    is loaded at the correct address this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/933b13f7-c07a-4b83-b103-d44cbb6965a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can step once again to reach the `erand48` address, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e5e9c80-8d99-40c4-9e36-8474fd966aa6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Register `r0` this time stores the address of the ASCII string as desired.
    Step two times by hitting **c** to arrive at the last instruction of the function
    (pop pc) as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e911f0e7-93cf-4906-9c8c-0420d0cf539f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `pop {pc}` will load the address of the system from the stack and put it
    inside `pc`, which will then go to the system with the argument located in `r0`,
    which we placed as the address of our `/bin/sh string`. We can look at regs to
    confirm this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/51562d9d-cf40-4b10-927f-adc7a41b5cde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we hit `c`, we will be able to get a shell, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bfddccc7-2162-49bb-a85a-679fe0c5ad95.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, we were able to exploit a stack-based buffer overflow and use ROP to jump
    to the system with our desired string as argument, taking advantage of the instructions
    located in the `erand48` function, finally giving us a shell.
  prefs: []
  type: TYPE_NORMAL
- en: This, however, was a very simple example of getting started with ROP on ARM-based
    architectures. A similar technique can be applied for ROP on MIPS, as shown next
    very briefly. Another thing that we have shown here is how to get around the cache
    incoherency issue, which usually comes during exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vulnerable program that we are looking for in this case is the `socket_bof`
    from the DVRF firmware. The first instruction that we will jump to in this case
    is sleep, providing it the argument of the time we want to sleep. We are calling
    sleep to flush the cache and then later preparing our gadgets to call the system
    with the command address as the argument, as shown next. The following screenshot
    shows what our first gadget will look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d50b447-9879-4033-aceb-492f3f997d73.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, with this gadget, apart from setting the `$a0`, which is the
    first register (just like `r0` in ARM), we are also able to control the **Return
    Address** (**RA**) and a number of other registers, such as `$fp`, `$s7`, `$s6`...`$s0`,
    and finally jump to `$ra`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next gadget, we will prepare to jump to sleep with the `$a0` value,
    which we have already set. Note that, in this gadget, `$t9` is getting the value
    from `$s0`, which we were able to control in the previous gadget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f08807eb-ef79-4436-b0f1-d23f24259a9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have this gadget set, the next gadget will set the system argument
    (the address of the string command that we want to execute) and also allow us
    to jump to system. In this case, the argument is `$sp+24`, and `$t9` (which we
    want to set as system address) gets its value from `$s3`, which we were able to
    control in the very first gadget mentioned earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/78c5d533-c622-4599-a82d-a14c611d871d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have all the gadgets in place, the next step is to obviously calculate
    the various offsets to ensure that our ROP chain works. The overall ROP chain
    looks like the one shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b7c6f10-29f5-449f-8cd6-9b912d0e83ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, place the individual arguments in the correct location, run the binary,
    and figure out the `libc` address from the `/proc/maps`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2cacb017-45cd-481d-a56a-c6f2a1d76709.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have the `libc` address identified correctly and the program running,
    you should be able to see that our arguments are now placed in the correct address
    during runtime, which can be confirmed using GDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e76df9c-cebc-4ad0-86bd-16a0b0beb754.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, `id` is the command that we wanted to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, here is what our ROP chain in this case looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/52f3fe0b-b46e-4195-a08b-61663ed82c48.png)'
  prefs: []
  type: TYPE_IMG
- en: That is all for ROP exploitation, where we went through examples for both ARM
    and MIPS. In real-world scenarios, the applications are the same-it might be the
    case that instead of just a few instructions, you will require a number of instructions
    to form your ROP chain.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can look at some of the automated tools which will help you during the
    process of ROP-based exploitation on various platforms. Some of the tools that
    are recommended you look at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ROPGadget: [https://github.com/JonathanSalwan/ROPgadget](https://github.com/JonathanSalwan/ROPgadget)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MoneyShot: [https://github.com/blasty/moneyshot](https://github.com/blasty/moneyshot)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining web security vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When adversaries target a type of IoT device, multiple vulnerabilities are often
    used in weaponizing an exploit. These vulnerabilities may be low in criticality
    by themselves; however, when combined, the exploit impact is much greater. It
    is not uncommon for a combination of low vulnerabilities to escalate into a critical
    vulnerability. This is especially important with regard to IoT devices. One critical
    bug discovered in an IoT device can compromise the integrity of the device. This
    recipe will cover how to chain web security vulnerabilities together to gain access
    to a Subaru-connected vehicle without a key fob, car keys, or credentials.
  prefs: []
  type: TYPE_NORMAL
- en: It is important that any vulnerability research stays within legal grounds.
    Performing unauthorized testing against MySubaru accounts and Subaru servers is
    illegal. All testing should take place in a controlled environment and should
    be rightfully owned. Although Subaru remote services do not control engine and
    drivetrain functions, testing outcomes are unknown. All critical vulnerabilities
    in this recipe have been reported and resolved by Subaru.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in performing any assessment is threat modeling; in this case,
    threat modeling a 2017 Subaru WRX STi connected vehicle from a black box perspective.
    Start with identifying entry points into a vehicle, which will provide an identified
    attack surface that can be built on.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - identifying assets and entry points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every car is different with some models having more features than other models.
    Research the publicly available resources on Subaru-connected vehicles and the
    different features between models and years. For example, we know a connected
    vehicle have access to the internet via a cellar 4G/LTE connection, but others
    may gain internet access via tethering to a phone''s connection or other means
    such as Wi-Fi. Let''s start there and document what we know about the target vehicle
    before performing any active attack phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cellular connectivity**: The Subaru connected vehicles are connected to the
    internet via AT&T 4G LTE ([http://about.att.com/story/att_subaru_bring_4G_lte_to_select_model_year_vehicles.html](http://about.att.com/story/att_subaru_bring_4G_lte_to_select_model_year_vehicles.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wi-Fi**: This is not available in the target Subaru vehicle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bluetooth**: The infotainment system connects devices via Bluetooth to access
    media, device contact books, and messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key fobs**: To gain access and start this particular vehicle, the key fob
    is needed. The key fob transmits at the frequency range of 314.35-314.35 MHz ([https://fccid.io/HYQ14AHC](https://fccid.io/HYQ14AHC)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USB connectivity**: The infotainment system uses USB to connect a device''s
    media as well as updates for GPS and the infotainment system itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SD card**: The infotainment system has a microSD card slot for GPS maps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OBD II**: This is used to access the CAN bus for diagnostics and can flash
    ECU images on the vehicle for tuning or other performance modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAN bus**: Every vehicle has one or multiple CAN buses for in-vehicle communication.
    The CAN bus is inherently vulnerable and can be sniffed using free tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile applications**: Subaru''s Starlink in-vehicle technology connects
    to the MySubaru application which allows you to lock and unlock your vehicle remotely,
    access your horn and lights, view car health reports, and locate your vehicle
    on a map. To use these features, a subscription must be purchased.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web application**: In addition to the MySubaru mobile application, Subaru''s
    Starlink in-vehicle technology connects to a web interface which allows you to
    lock and unlock your vehicle remotely, access your horn and lights, change user
    settings, schedule services, add authorized users, and locate your vehicle on
    a map. To use these features, a subscription must be purchased.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have listed the entry points of a connected vehicle, we have a better
    idea as to what to target first. We can also gauge the level of effort based upon
    our skillset and comfortability.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - finding the weakest link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There has been plenty of research on infotainment systems and CAN bus exploitation.
    Any protocol vulnerabilities discovered in Bluetooth, Wi-Fi, or the key fob might
    turn into a zero-day-like vulnerability and take quite a bit of time. Having said
    that, let's shift our attention to the MySubaru mobile apps and the web application.
    With mobile and web applications, vicinity to the car is not necessary. All that
    is needed is a STARLINK Safety Plus and Security Plus subscription, supported
    model, and credentials to a MySubaru account. This is great because we multitask
    and work on all three applications concurrently. In addition, Subaru has delegated
    unlocking, locking, honking the horn, and locating a vehicle via its mobile and
    web applications. The target applications are version 1.4.5 of the MySubaru Android
    and iOS apps. Any application-level bug discovered could have a high-level impact
    and may also pose a safety concern to Subaru owners.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 - reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are focusing our efforts on the applications, we need to perform a
    level of recon on all three applications. Let's start with the mobile applications
    first and then move forward with the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Android application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android apps are simple to disassemble and analyze statically prior to performing
    dynamic tests. Some level of effort is required when reversing Android apps, but
    if we can discover the low hanging fruit, then we have an easy win. We first need
    to acquire the MySubaru app via a third-party marketplace and ensure it is the
    same as the Google Play version. Once this is verified, the following steps should
    be taken to perform a baseline level of recon on the MySubaru Android app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disassemble the APK using MobSF or a similar tool:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze classes and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify whether the app is native or hybrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for hardcoded values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for potential secrets and environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the app and monitor Android components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activities, services, and intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SD card usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SharedPreferences.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy all API requests from the Android app to the vehicle using Burp Suite
    or similar tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login/Logout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlock/lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honk the horn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flash the lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locate the vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View the vehicle health report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit vehicle details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure color-coded highlights and notes are taken for Android communication.
    This will help when compiling the different API calls used to identify vulnerabilities
    for Android as well as the other Subaru applications.
  prefs: []
  type: TYPE_NORMAL
- en: iOS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When reversing iOS apps, more time is required to obtain the IPA file, decrypt
    it, transfer the application binary to our host computer, and then work toward
    finding vulnerabilities. In this case, we must download the MySubaru application
    via the App Store and perform the decryption and binary transference to our host
    computer. Once this is complete, the following steps should be taken to perform
    a baseline level of recon on the iOS MySubaru app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disassemble the iOS binary using Hopper or similar tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze classes and methods (use Class-dump-z)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify whether the app is native or hybrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for hardcoded values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for potential secrets and environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install the app and monitor iOS components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPC via URL schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Analyze data storage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache.db
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localstorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Proxy all API requests from the iOS app to the vehicle using Burp Suite or
    similar tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login/Logout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlock/lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honk the horn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flash the lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locate the vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View the vehicle health report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit vehicle details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between iOS and Android API calls should be noted. The storage
    of data should also be noted with an emphasis on personal details as well as credentials.
    Observations on potential roadblocks should be identified based upon the recon
    performed on both applications. For example, both mobile applications send remote
    service calls via a `POST` request with a `sessionId` parameter value, which is
    unique for every request.
  prefs: []
  type: TYPE_NORMAL
- en: This may hinder our ability to forge remote service requests since this value
    is unique and not a hardcoded value. One key observation found in the iOS application
    is the caching of all HTTP requests and responses to a `Cache.db` SQLite database.
    All data in the `Cache.db` is in clear text with vehicle details, personal owner
    details, account tokens, and API requests can be extracted by attackers when backing
    up an iOS device or using free tools such as iFunbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a cached request with a `handoffToken` token
    in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67d4eb47-993a-4b9e-b148-443ab09c1158.png)'
  prefs: []
  type: TYPE_IMG
- en: Web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will take a look at the MySubaru web application and inspect all HTTP
    requests and responses. The MySubaru web application contains additional options
    that the mobile applications do not have such as adding authorized users or changing
    the account pin number. Follow the same steps when proxying the web application
    traffic, but ensure all state configuration changes, such as the ones listed as
    follows, are clicked and analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: Login/Logout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock/Unlock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honk the horn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flash the lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locate the vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View the vehicle health report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit vehicle details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add and remove authorized users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change pin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change security questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change personal account details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All differences between the web application and mobile applications should be
    noted. So far, a major difference between the web and mobile apps is how remote
    service API requests are sent to Subaru servers. The API endpoint remains the
    same for all applications, which can be useful if we uncover a vulnerability to
    exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the HTTP history in Burp Suite with color
    coding for all applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42b354f1-a899-4f38-96b3-b7318530ac8c.png)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 - identifying vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all application features and API calls noted in our web proxy, we can
    now start to identify vulnerabilities in the design and also test logic flaws
    for vulnerabilities. The following is a list of the observed vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: The web application sends all remote service calls over the URL as a `GET` request
    while the mobile applications send remote service calls as a `POST` with the parameters
    in the body. There are no randomly generated `sessionIds` used to execute remote
    service calls for the web.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Certificate pinning and validation is not enforced for mobile applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All requests and responses are cached for the iOS application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Account configuration changes, such as editing the vehicle details or adding
    authorized users, do not contain anti-CSRF tokens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Owners are not notified when an authorized user is added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates to the account pin do not require knowledge of the previous set pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates to security questions do not require re-authentication, do not have
    a minimum character length, and can all be the same value such as 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorized users have full access to Subaru remote services and do not have
    a limit how many can be added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are no concurrent login policies for all applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the pin and security question update profile
    section that does not require authentication or previous knowledge of the settings
    to make changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c7f1627-47fb-466e-ada1-a326df8db7e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we can start changing configuration parameter values that reflect user input
    to the screen. Since we are not authorized to send malicious payloads in this
    case, all efforts will be manual, and parameters will be manually input via Burp
    Suite's repeater. With that in mind, we can try basic XSS payloads and observe
    whether any validation and/or encoding is in place. The first location that comes
    to mind which reflects our parameter values is the vehicle nickname. It appears
    that a vanilla `<script> alert(1)</script>` works and executes in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is now an authenticated **cross-site scripting** (**XSS**) vulnerability
    that may be of use to us (Vulnerability #10). The following is a screenshot of
    the XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40887edf-f1ec-44d2-a32c-cd236099b297.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can check for other API logic flaws such as whether rate limiting
    is enforced or whether the API requests can be replayed without modification.
    This can be done by sending the HTTP requests to Burp Suite''s repeater and replay
    requests. We will find that there are no replay or rate limiting security controls
    enforced when making remote service calls (Vulnerability #11). Although there
    is a brief 5 second period that is needed in between API requests in order for
    the vehicle to execute requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another logical flaw to be tested is the login process between the mobile app
    and Subaru servers. Subaru passes user credentials via a `POST` body and then
    redirects users to their account dashboard after authenticating. During the login
    process and after the account credentials have successfully authenticated, a `GET`
    request is sent to Subaru''s servers with the username, handoffToken, and other
    parameters. This is the same HTTP request found in the `Cache.db` of the iOS application,
    but with a different token value. This `GET` request can be copied and pasted
    into a browser and be autologged into a MySubaru account without the need for
    a username or password (Vulnerability #12). In addition, the handoffToken never
    expires and will still be valid even if a MySubaru user logs out of the web and
    mobile applications. Even password changes do not expire this token. This is a
    great find as we can now gain persistent access to a MySubaru account without
    the owner knowing an attacker has access. Another issue related to the handoffToken
    is the fact that new tokens are created for new devices and authorized users who
    log into their MySubaru mobile applications. For example, an owner logs in to
    their MySubaru account with two iPhones and two Android devices. There are now
    four live handoffTokens for their account. This also applies to the authorized
    users. For instance, two authorized users (`carhackingemail@gmail.com` and `carhackingemail1@gmail.com`)
    log in to their MySubaru mobile applications with three devices. There are now
    six live tokens for the authorized users, which expands the attack surface to
    10 live tokens for one MySubaru account. The following is an example that shows
    two authorized user accounts, `carhackingemail@gmail.com` and `carhackingemail1@gmail.com`,
    that log in with three different mobile devices and get issued different handoffToken
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb7d4b3d-7c46-45bc-bac5-bdcd343dfcdc.png)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 - Exploitation -- Chaining vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At least 11 vulnerabilities have been identified through passive and active
    analysis. Some of the vulnerabilities can be directly exploited while others may
    be indirectly exploited because of the application's logic and design. With the
    goal of accessing a vehicle without a key fob, car keys, or credentials, we should
    have what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking through the identified security bugs, user intervention will be needed
    to successfully exploit a MySubaru owner''s account and vehicle. There are several
    ways in which we can do this. We can try the following attack scenario which relies
    on a form of social engineering:'
  prefs: []
  type: TYPE_NORMAL
- en: Craft a malicious page that employs an XSS payload for the vehicle's nickname
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquire a handoffToken to gain a valid session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add authorized users via CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forge unlock remote service calls to the target Subaru vehicle via CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change security questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change pin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profit $$
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other attack scenarios that can be used to gain a valid `handoffToken`
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: The victim logs in with the attacker device where the token can be extracted
    from the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The victim backs up the mobile device (Android/iOS ) to the attacker's computer
    and the attacker restores the victim's backup to a test mobile device which contains
    the handoffToken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attacker steals the authorized user's token instead of the owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MITM victim traffic via a Wi-Fi hotspot or other means
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain `Cache.db` via iFunBox (iOS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The audit logs leak the handoffToken via `URL GET` requests, which can be acquired
    by system administrators of Subaru, admins of corporate networks that inspect
    network traffic, and wireless hotspots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The attackers can not only gain unauthorized access to a vehicle but can also
    track an owner and put their safety at risk. Other post exploit scenarios can
    also be explored such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Steal contents inside the vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sabotage the vehicle's engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retain persistence to a MySubaru account which may have multiple vehicles provisioned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implant an out-of-band tracker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implant a malicious Wi-Fi access point w/GSM for remote connection to exploit
    neighboring access points or vehicles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replay remote service requests such as locking the vehicle to drain the battery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have noticed, these are fundamental web security vulnerabilities
    and not ground breaking zero-day exploits. The impact for exploiting fundamental
    vulnerabilities are much higher for IoT-connected devices and vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit the following web pages to read about the research discussed in this
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.scmagazine.com/researcher-hacks-subaru-wrx-sti-starlink/article/666460/](https://www.scmagazine.com/researcher-hacks-subaru-wrx-sti-starlink/article/666460/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.bitdefender.com/box/blog/iot-news/researcher-finds-basic-mistakes-subarus-starlink-service/](https://www.bitdefender.com/box/blog/iot-news/researcher-finds-basic-mistakes-subarus-starlink-service/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.databreachtoday.com/exclusive-vulnerabilities-could-unlock-brand-new-subarus-a-9970](http://www.databreachtoday.com/exclusive-vulnerabilities-could-unlock-brand-new-subarus-a-9970)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring continuous integration testing for firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building firmware written in C/C++ can be a challenge for legacy products with
    complex Makefiles. Nevertheless, all source code should be statically analyzed
    for security vulnerabilities prior to deploying production builds. This recipe
    will show how to configure basic C/C++ static analysis for firmware in a continuous
    integration environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the following application and tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jenkins**: This is an open source build automation server that can be customized
    to run quality and security code analysis. Jenkins can be downloaded via the following
    link [https://jenkins.io/download/](https://jenkins.io/download/). There are various
    ways to install Jenkins depending on the operating system. For Debian and Ubuntu,
    the following commands can be used to install Jenkins:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line to  `/etc/apt/sources.list`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Fuzzgoat**: This is a vulnerable C program that can be downloaded via the
    following GitHub repository [https://github.com/packttestaccount/fuzzgoat](https://github.com/packttestaccount/fuzzgoat).
    Clone the fuzzgoat application into your Jenkins build server using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Flawfinder**: This is a simple tool that analyzes C/C++ code for potential
    security vulnerabilities. Flawfinder can be downloaded via the following link
    [https://www.dwheeler.com/flawfinder/flawfinder-2.0.4.tar.gz](https://www.dwheeler.com/flawfinder/flawfinder-2.0.4.tar.gz).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple way to install Flawfinder is via pip using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To setup continuous integration testing of firmware, use the following steps
    to create your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Jenkins is installed, log in and click on New Item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aba628cc-7a9d-4a5d-8a1a-3e7dda6226be.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure your `JAVA_HOME` environment variable is configured. If there are multiple
    Java versions in use, make sure to configure the JDK via the Global Tool Configuration
    in Jenkins via `http://127.0.0.1:8080/configureTools/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a name and select the Freestyle project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5648c9e9-2ea8-4210-8aae-c83954e4ae52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The configuration page will appear. Do not input any settings just yet as we
    are going to load a local project into a workspace that Jenkins will create after
    we build the project. The build will fail, which is okay because we just want
    Jenkins to create the directory and then we will copy our project files with C
    code into the workspace. This step will also be used in the following recipes
    to create workspaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/def1200a-f377-42fb-8971-170b782f80de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the Save button is clicked, Jenkins will redirect you to the project page
    where we will select Build Now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/089dca88-628d-4283-a34e-9ed6a26bf8e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, Jenkins has built our workspace where we can transfer our code files over.
    The directory structure differs depending on the operating system used. For Ubuntu,
    workspace files are located in `/var/lib/Jenkins/workspace/` and for OS X workspace
    files are located in `/Users/Shared/Jenkins/Home/workspace/`. Transfer the fuzzgoat
    files into the newly created workspace directory, which has the project name as
    the directory. In this case, it's `/var/lib/Jenkins/workspace/PacktTestFirmware/`.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the Jenkins *Nix user has the proper file and folder permissions to scan
    anything in the `workspace` directory. This also includes permission for the tools
    to scan the relative directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that fuzzgoat is within the Jenkins workspace directory, navigate back
    to the Jenkins build project and add a build step to execute a shell command,
    which will be executing `flawfinder` in our `workspace` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5cf6a9c6-356e-4ffd-9eea-900ee77c4577.png)![](img/4228b997-8122-4ad3-82d7-6a7814dbc73f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add another build step to execute another shell command. This will execute
    the `make` command in the working directory which is based upon the Makefile fuzzgoat
    has supplied us with. Click on Save afterwards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc55c928-9720-41f0-b89f-a42a27ab1622.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Build Now option in the project page. Click on the permalink arrow
    and select Console Output, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9fef50d-f8a2-4110-92f2-399fee2c3313.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following page should appear with the build and `flawfinder` results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6477d128-7fd5-44ce-befe-e6b47ac8c5f7.png)![](img/478cc1d4-8bec-4476-9263-7c90351f4105.png)'
  prefs: []
  type: TYPE_IMG
- en: Build steps can be customized to alert engineering or security managers to perform
    an action based upon the results. However, not all the hits from `flawfinder`
    are vulnerabilities, but they should be reviewed to ensure software security bugs
    are not introduced. Keep in mind, `flawfinder` is a simple tool that offers a
    minimum amount of checks for C/C++ code. It simply checks for common buffer overflow
    issues and other well-known problems such as the usage of banned functions. Commercial
    SAST tools include dependency graphs as well as call graphs to check for dependency
    software bugs and application data flow. In addition, many commercial SAST tools
    also include IDE plugins that check code in real time for software security bugs.
    There are free IDE plugins for C/C++ with XCode's Clang Static Analyzer; however,
    custom configurations are required in order to compile such code within an OS
    X environment. Clang will not analyze any files that cannot be compiled. In the
    configuring continuous integration testing for mobile applications section, we
    will discuss how to use an IDE plugin to statically analyze code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the Clang Static Analyzer, visit the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://clang-analyzer.llvm.org/](https://clang-analyzer.llvm.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://help.apple.com/xcode/mac/9.0/#/devb7babe820](https://help.apple.com/xcode/mac/9.0/#/devb7babe820)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a list of more source code analysis tools for various programming languages,
    refer to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/Source_Code_Analysis_Tools](https://www.owasp.org/index.php/Source_Code_Analysis_Tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring continuous integration testing for web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether an IoT device uses a web application or web service for messaging, its
    code should be statically and dynamically analyzed for software security bugs.
    In this recipe, we will demonstrate how to configure dynamic scanning of web application
    builds prior to production deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use Jenkins as our automation build server and OWASP
    ZAP as our dynamic scanner. We will use the OWASP ZAP Jenkins plugin and the OWASP
    ZAP tool that can be downloaded via the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/zaproxy/zaproxy/wiki/Downloads](https://github.com/zaproxy/zaproxy/wiki/Downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To setup continuous integration testing for web applications, use the following
    steps to create your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to download the OWASP ZAP plugin, which can be done via Jenkin''s
    plugin manager, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/20926133-8feb-44e6-906c-9799e3cc9938.png)'
  prefs: []
  type: TYPE_IMG
- en: OWASP ZAP plugin download
  prefs: []
  type: TYPE_NORMAL
- en: 'Jenkins will then restart. Log back into Jenkins and we will work towards configuring
    ZAP. There are two ways to use ZAP in Jenkins. One is to run ZAP with a loaded
    session and another is to set up Selenium to execute ZAP and persist a session
    afterwards. We will set up ZAP to run with a loaded session for our target build.
    To do so, we first need to configure ZAP settings and environmental variables
    via `http://127.0.0.1:8080/`configure in this case. Set the ZAP host and port
    number as seen in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/26bd354b-cba8-4360-9e77-d850f2e52bc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple ZAP hosts can be configured to allow multiple concurrent build scans.
    This can be configured in the build step of the individual projects, which overrides
    the system settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the default directory of ZAP according to the operating system ([https://github.com/zaproxy/zaproxy/wiki/FAQconfig](https://github.com/zaproxy/zaproxy/wiki/FAQconfig))
    in use. The following is the default directory ZAP uses for OS X:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use the weekly version of ZAP, use `/Users/<user>/Library/Application\
    Support/ZAP_D/`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/411a6ca4-44f6-41e9-b74b-2c49d9b01221.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, create a Freestyle project, as we did in the previous recipe, and name
    it appropriately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dc296661-1e1e-44aa-bc65-4766b586f6b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the project and select Build Now so that Jenkins creates our project workspace
    like the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we are going to execute ZAP with a loaded session, we must create a session
    and save it in the project workspace directory. To do that, navigate to the target
    application build that is running and proxy the application traffic through the
    browser to ZAP. Ensure to click on all links, and spider pages and perform application
    functions. In the following example, we are using The BodgeIT Store that is running
    locally on port `8888` and saving the session to the project workspace by navigating
    to File | Persist Session...:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3e60316-e57c-4099-ad7b-88586770bc04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the session within the Jenkins workspace directory of our project. In
    this case, the PacktZAPscan in the workspace project directory as seen in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05038cb4-2588-458d-9ca6-254edd0c96b3.png)'
  prefs: []
  type: TYPE_IMG
- en: PacktZAPscan in the workspace project directory
  prefs: []
  type: TYPE_NORMAL
- en: 'While in ZAP, let''s configure ZAP''s API key. Navigate to the Tools menu and
    open the Options page. In Options, select the API section and insert the default
    `ZAPROXY-PLUGIN` key provided by the Jenkins plugin, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a8469828-810b-40d4-be41-b7dd2d4b872f.png)'
  prefs: []
  type: TYPE_IMG
- en: Note, this API key can be disabled altogether, or changed via the ZAP plugin
    command line arguments section when creating a build step. If the API keys do
    not match the Jenkins plugin API key value, the scan will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our session saved in our workspace, navigate back to our project and select
    Configure. Insert the proper source code management settings, build environment,
    and any build scripts according to the application architecture. In the Build
    section, select Add build step | Execute ZAP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df0020c4-d637-4f52-8684-2215312fb8ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter in the ZAP host settings and home directory path with the appropriate
    session that was saved. If the session is not saved in the project workspace folder,
    the session will not appear in the Load Session drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d23107f-f887-40e2-af83-572889c22b69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter in session properties such as contexts and any authentication credentials.
    Context refers to the in-scope and out-of-scope targets for automated scanning.
    The context must be unique and not within the loaded session. We can use the build
    ID environment variable to iterate context numbers so they''re unique, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a71cada9-19c3-483c-a4d5-e3f7a6b49324.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next session is the Attack Mode section. Here, we specify the target URL,
    scan settings, and any customized scan policies that might be configured and saved
    into the project workspace. In the upcoming example, the test URL is input with
    spidering selected and a customized XSS scan policy that has been configured.
    The default policy is used when no customized scan policy is specified. After
    configuring the attack settings, name the generated report, select the Format and
    any Export Report settings, then click on Save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f88244a-3aeb-4db1-9b03-a434895f42ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure that the permissions are properly set so that Jenkins and ZAP can scan
    your workspace directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then be directed to the project page. Select Build Now and click on
    the build''s Console Output. This will show the build status and progress of the
    ZAP scan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e07979b7-96c9-45f9-8461-2974cce0b96d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The console output should look similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35e46e51-cf77-4fb3-8512-d6b93f70179d.png)'
  prefs: []
  type: TYPE_IMG
- en: Console output
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the build and scan are finished, a report is generated in the workspace
    project directory under the `reports` folder, as shown in the following screenshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4cd67bf2-8be2-4b83-90c7-3d15849b2eec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The XML and HTML versions of the report are available for review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fdbccdc0-28ec-4715-bea3-e10f1ae9d71d.png)'
  prefs: []
  type: TYPE_IMG
- en: ZAP scans and reported alerts can be heavily customized to only report on medium
    and/or high severity findings. Scans should be tailored to each application by
    creating contextual details and scan policies according to the application architecture.
    For example, if an application is running on an Apache web server, Apache Tomcat
    application server, and a MySQL database, the scan policies should be customized
    to run checks against the respective architecture environment. Running default
    scan policies are not recommended as unrelated attacks will be used, causing scan
    times to drag on for long periods of time and may even exhaust ZAP's internal
    database resources. Scanners are only as good as the configuration, rulesets,
    and policies they are given.
  prefs: []
  type: TYPE_NORMAL
- en: Automated scans are great for catching low hanging fruit and scalability but
    they should never replace manual web application security assessments. Automated
    scanners cannot perform contextual business logic tests or the intelligence to
    catch unreported findings that manual assessments can. A combination of automated
    and manual testing should be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the Jenkins OWASP ZAP plugin, refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.jenkins.io/display/JENKINS/zap+plugin](https://wiki.jenkins.io/display/JENKINS/zap+plugin)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.jenkins.io/display/JENKINS/Configure+the+Job#ConfiguretheJob-ConfiguretheJobtoExecuteZAP](https://wiki.jenkins.io/display/JENKINS/Configure+the+Job#ConfiguretheJob-ConfiguretheJobtoExecuteZAP)'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring continuous integration testing for mobile applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the same trend of automated analysis in the earlier recipes, this
    recipe will show how to configure dependency scans and dynamic analysis of Android
    application builds prior to production deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use a Jenkins automation build server and the following
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile Security Framework** (**MobSF**): This is an open source mobile application
    static and dynamic analysis tool. MobSF is actively being worked on and modified
    for the mobile security community. MobSF can be downloaded from the following
    link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/MobSF/Mobile-Security-Framework-MobSF/archive/master.zip](https://github.com/MobSF/Mobile-Security-Framework-MobSF/archive/master.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: '**OWASP Dependency-Check**: This is a tool that detects publicly disclosed
    vulnerabilities within a project''s dependencies for multiple programming languages
    such as Java, NodeJS, Python, Ruby, and Swift to name a few. We will use the Jenkins OWASP
    Dependency-Check Plugin that can be downloaded via the Jenkins plugin manger,
    as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e9f24b72-1ff4-4c9a-8608-674fd00e4af5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Dependency-Check can also be downloaded as a standalone tool using the methods
    described in the following link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/jeremylong/DependencyCheck](https://github.com/jeremylong/DependencyCheck)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To setup continuous integration testing for mobile applications, use the following
    steps to create your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first start by creating a freestyle project with an appropriate name
    for the application build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4894f823-9ec9-419c-a587-04491fac48e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Save and build the project so that our workspace is created as we did in the
    earlier recipes for the purpose of simplicity. Next, copy over your Android project
    files to the new workspace Jenkins created for us, as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ff1796ad-6e49-4759-a432-510295872968.png)'
  prefs: []
  type: TYPE_IMG
- en: The path of our workspace in this instance is `/Users/Shared/Jenkins/Home/workspace/PacktTestAndroid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the Configure option in your project and set up your build settings
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7bd19abb-6f25-44d3-b0b5-570d96e31f01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Input any necessary build scripts for your build environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4307a089-e17e-4657-9610-3db10bd84a69.png)'
  prefs: []
  type: TYPE_IMG
- en: If this is an existing project, you might already know where the output APK
    will be placed after a build is complete. For new projects, ensure your build
    compiles to an APK. Knowing where the APK is stored when running builds is the
    key for the next sections of scanning the built APK.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a separate window, open a Terminal and navigate to the location where the
    MobSF is installed. Once in MobSF''s folder, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Your Terminal should look like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ca88dee-ff56-49a9-b0c6-65371dc2b077.png)'
  prefs: []
  type: TYPE_IMG
- en: Take note of MobSF's API key as we will need this to execute the REST API calls
    from our Jenkins build server.
  prefs: []
  type: TYPE_NORMAL
- en: The API key changes when all scans and MobSF database information is deleted
    via the `clean.sh` script MobSF supplies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate back to the Jenkins configuration page of our Android project. Add
    a build step to execute a shell command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bda9bc10-a42c-407a-a841-adf581cc6a05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the command area, we will execute REST API calls to upload our APK that
    is built over to MobSF. To do so, you will need to have your REST API key and
    the location where the APK is stored after a build. Use the following command
    and insert your API key as well as file path to your API like the `curl` command
    shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `curl` command uploads our freshly built APK in our workspace, which will
    then be scanned. MobSF creates a hash of the uploaded binary and this is something
    that will be needed to reference your specific binary for other API calls. The
    `awk` command just parses the JSON response data and inserts the hash value into
    a file that will be called in later MobSF API requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our APK uploaded, add another build step to execute a shell command and
    insert the following command with your APK name and API key values to scan the
    build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes a couple of minutes for MobSF to scan the APK, so let''s create another
    execute shell build set and insert the following `sleep` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `sleep` command can be changed according to how long MobSF takes to analyze
    your specific application. In this case, it's about two minutes. Bear in mind
    that if you do not wait long enough for MobSF to scan the APK and you try to download
    the report, it will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create another build step to generate and download the PDF that was just
    mentioned. Insert the following command with your respective API key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can choose to name the MobSF report however you like. To make the report
    unique, the build ID environment variable is used. Jenkins should now be able
    to upload, scan, generate, and download a MobSF report from our built APK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a build step to invoke Dependency-Check, which scans our project''s
    dependencies for known vulnerabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90dc9351-907f-4714-aba9-da617647ad13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The build step Path to scan for Dependency-Check should be empty as the project
    files in the workspace directory will be scanned and used to output results in
    the workspace as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/597283b6-d819-4d11-95ee-8bdeea28b55f.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure permissions are properly set so that Jenkins and Dependency-Check can
    scan your workspace directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your project configuration build steps should look similar to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/667cc64a-b858-4e55-9d59-b67ac1130115.png)'
  prefs: []
  type: TYPE_IMG
- en: Project configuration build steps
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the project configurations and build the Android application. View the
    Android application project''s console output to see the build progress. The first
    build step is to build the actual application APK, then perform MobSF scanning
    functions, and lastly scan the project''s dependencies with a Dependency-Check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/69441c78-d460-4b65-94d4-81e8a9644df2.png)'
  prefs: []
  type: TYPE_IMG
- en: Console output
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the second and third build steps to upload as
    well as scan the APK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2724cfa3-0df8-4ea9-a304-7e3d02872dc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Build steps to upload and scan APK
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth, fifth, and sixth build steps follow next with executing a `sleep`
    command, generating a PDF of the MobSF scan results, and scanning the project''s
    dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3860df4a-7dbf-4804-9110-ca17a73e84fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you check your project workspace, there should now be a MobSF report as
    well as a Dependency-Check report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9c3080d7-2d34-4238-919f-19d8c820eaa2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the MobSF and Dependency-Check reports should open the output of
    the scans in their respective format (PDF for MobSF and HTML, JSON, XML for Dependency-Check),
    as shown in the following screenshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad6e5830-b5b4-4658-a3ce-c356776f542f.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the scans
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image is the Dependency-Check HTML report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d781cf55-ea8b-48df-80e0-b5ed5dc312d5.png)'
  prefs: []
  type: TYPE_IMG
- en: These scan reports can be configured to be sent to a centralized reporting server
    as well as perform actions such as send an email alert or Jira ticket if certain
    severity findings are discovered for a build. Jenkins is highly customizable with
    more advanced features than those covered in this chapter. A great OWASP project
    that aids application security teams with increasing speed and automation of security
    testing is the OWASP AppSec Pipeline project ([https://www.owasp.org/index.php/OWASP_AppSec_Pipeline](https://www.owasp.org/index.php/OWASP_AppSec_Pipeline)).
    Various tools and design patterns for an AppSec pipeline are discussed to enable
    small security teams to be as scalable and efficient as possible given the speed
    of code being pushed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Dependency-Check Jenkins plugin also comes with a location to archive multiple
    application dependencies and the use of vulnerable components across applications
    called OWASP Dependency-Track. This can be configured via `http://JenkinsURL:8080/configure`
    in the OWASP Dependency-Track section. For more details on OWASP Dependency-Track,
    see the following link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/OWASP_Dependency_Track_Project](https://www.owasp.org/index.php/OWASP_Dependency_Track_Project).'
  prefs: []
  type: TYPE_NORMAL
- en: For details about MobSF's REST API, visit their documentation page at [https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/3.-REST-API-Documentation](https://github.com/MobSF/Mobile-Security-Framework-MobSF/wiki/3.-REST-API-Documentation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
