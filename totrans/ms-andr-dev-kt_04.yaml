- en: Connecting Screen Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello fellow readers! We have come to an important point in our application
    development--connecting our screens. As you know, we created screens in the previous
    chapter, and, in this chapter, we will connect them by using Android's powerful
    framework. We will continue with our work, and, with Android, we will do more
    serious stuff with our UI. Prepare yourself and concentrate on every aspect of
    this chapter. It will be very interesting! We promise!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using drawer navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing information between activities and fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are continuing our journey through Android Application Development. So far,
    we have created a base for our application, defined the ground for a UI, and created
    major screens; however, these screens are not connected. In this chapter, we will
    connect them and make fantastic interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Since everything starts from our `MainActivity` class, we will apply some improvements
    before we set some actions to trigger other screens. We have to *wrap* it with
    an application bar. What is an application bar? It's a piece of the UI that is
    used to access other parts of the application and provide visual structure with
    interactive elements. We already have one, but it's not the usual Android application
    bar. At this point, our application is has a modified application bar, and we
    want it to have a standard Android application bar.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will show you exactly how to create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by replacing a top-level activity extension to `AppCompatActivity`. We
    need to access features that are needed for an application bar. `AppCompatActivity`
    will add these additional features to standard `FragmentActivity`. Your `BaseActivity`
    definition should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then update the theme application that is used, so the application bar can
    be used. Open Android Manifest and set a new theme as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open your `activity_main` layout. Remove the header included directive
    and add `Toolbar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the same change to all layouts. When you finish it, update your `BaseActivity`
    code to use the new `Toolbar`. Your `onCreate()` method should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We assigned an application bar by calling the `setSupportActionBar()`method
    and passing the toolbar''s ID from the layout. If you run the application, it
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89c17146-6ab6-4d9a-b96b-918002b179c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We lost the buttons we had in our header! Don''t worry, we will get them back!
    We will create a menu that will handle actions instead of buttons. In Android,
    a menu is an interface that is used to manage the items, and you can define your
    own menu resource. In the `/res` directory, create a `menu` folder. Right-click
    on the `menu` folder and choose the New | New menu resource file. Call it main.
    A new XML file opens. Update its content according to this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We set common attributes, the icon, and the order. To make sure your icons
    will be visible, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, items in the menu will be expanded if there is any space available;
    otherwise, they will be accessible through the context menu. Other options of
    spacing in Android that you can choose are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Always**: This button is always placed in an application bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Never**: This button is never placed in an application bar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**collapseAction View**: This button can be shown as a widget'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**withText**: This button is displayed with text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To assign a menu to the application bar, add the following to `BaseActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, connect actions to menu items and extend `MainActivity` by adding
    the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we overrode the `onOptionsItemSelected()` method and handled cases for
    menu item ID. On each selection, we added a log message. Now run your application.
    You should see these menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a64c25e9-44f3-42c1-af22-a949c77deb86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click a few times on each item and observe Logcat. You should see logs similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We successfully switched our header to the application bar. It is quite different
    to the header we had in the application wireframe. This is not important at the
    moment since we will do some significant styling in the next chapters. Our application
    bar will look different.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will deal with the navigation drawer, and we will
    begin to assemble our application's navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Using the navigation drawer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you probably remember, in our mockup we have presented that there will be
    links to filtered data (Notes and Todos). We will filter these by using the navigation
    drawer. Every modern application uses a navigation drawer. It''s a piece of the
    UI that displays the application''s navigation options. To define the drawer,
    we have to put the `DrawerLayout` view in our layout. Open `activity_main` and
    apply the following modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The main content of the screen must be the first child of `DrawerLayout`. The
    navigation drawer uses the second child as the content of the drawer. In our case,
    it's `ListView`. To tell the navigation drawer if navigation should be positioned
    left or right, use the `layout_gravity` attribute. If we plan to use the navigation
    drawer positioned to the right, we should set the attribute value to `end`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have an empty navigation drawer, and we have to populate it with some
    buttons. Create a new layout file for each navigation item. Call it `adapter_navigation_drawer`.
    Define it as a simple linear layout with only one button inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new package called `navigation`. In this package, create a new
    Kotlin `data` class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a drawer item entity. Now create one more class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This class shown here extends Android's `BaseAdapter` and overrides methods
    needed for the adapter to provide view instances. All views that the adapter creates
    will be assigned to expand `ListView` in our navigation drawer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will assign this adapter. To do that, we need to update our `MainActivity` class
    by executing the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code example, we instantiated several `NavigationDrawerItem` instances,
    then, we assigned a title to the buttons and `Runnable` actions that we will execute.
    Each `Runnable` will jump to a specific page of our view pager. We passed all
    instances to the adapter as one single mutable list. You may have also noticed
    that we changed the line for the `drawing_menu` item. By clicking on it, we will
    expand our navigation drawer. Please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build your application and run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the menu button at the top-right position of the main screen or expand
    the navigation drawer by swiping from the far-left side of the screen to the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that the view pager is animating its page positions below the
    navigation drawer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec3eed2d-ebf3-4377-90f5-f07682c6b54e.png)'
  prefs: []
  type: TYPE_IMG
- en: Connecting activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you remember, other than `MainActivity`, we also have some more activities.
    In our application, we created activities to create/edit Notes and TODOs. Our
    plan is to connect them to the button click events, and then, when the user clicks
    on the button, the proper screen will open. We will start by defining an `enum`
    that represents an operation that we will perform in an opened activity. When
    we open it, we can view, create, or update Note or Todo. Create a new package
    called `model` and `enum` with the name `MODE`. Make sure you have the following
    `enum` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We added a few additions here. In `enum`'s companion object, we defined the
    extras key definition. Soon, you will need it, and you will understand its purpose.
    We also created a method that will give us an `enum` based on its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you probably remember, both activities for working with Notes and Todos
    share the same class. Open `ItemActivity` and extend it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a field mode of the type we just defined that will tell us if
    we are viewing, creating, or editing a Note or Todo item. Then, we overrode the
    `onCreate()` method. This is important! When we click on the button and open the
    activity, we will pass some values to it. This code snippet retrieves the value
    we passed. To achieve that, we access the `Intent` instance (in the next section,
    we will explain `intents`) and the integer field called `MODE` (value of `MODE.EXTRAS_KEY`).
    The method that gives us this value is called `getIntExtra()`. There is a version
    of the method for every type. If there is no value, `MODE.VIEW.mode` is returned.
    Finally, we set mode to a value we obtained by getting the `MODE` instance from
    the integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle is triggering an activity opening. Open `ItemsFragment`
    and extend it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We accessed the `FloatingActionButton` instance and assigned a click listener.
    On clicking, we will create a dialog with two options. Each of these options will
    trigger a proper method for activity opening. The implementation of both methods
    is very similar. As an example, we will focus on `openCreateNote()`.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `Intent` instance. In Android, `Intent` represents our
    intention to do something. To start an activity, we must pass the context and
    the class of the activity we want to start. We must also assign some values to
    it. Those values will be passed to an activity instance. In our case, we are passing
    the integer value for the `MODE.CREATE. startActivity()` method that will execute
    the intent and a screen will appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application, click on the rounded button at the bottom-right corner
    of your screen, and choose an option from the dialog, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86fa1e85-d1dd-4447-a404-b8a44219ebd4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will take you to this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e57f3569-ed85-4e67-a7fe-3396fc51415a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will take you further to add your own data with date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35e3969d-bb6c-433e-bac1-9314a656490a.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking deeper into Android Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most operations you plan to perform in Android are defined through the `Intent`
    class. `Intents` can be used to start activities like we did, start services (processes
    running in background), or send broadcast messages.
  prefs: []
  type: TYPE_NORMAL
- en: '`Intent` usually accepts an action and data that we want to pass to some class.
    Action attributes we can set are, for example, `ACTION_VIEW`, `ACTION_EDIT`, `ACTION_MAIN`.'
  prefs: []
  type: TYPE_NORMAL
- en: Except action and data, we can set a category for the intent. The category gives
    additional information to the action we set. We can also set the type for the
    intent and the component that stands for the explicit component class name we
    will use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of `intents`:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit intents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit intents have an explicit component set that provides an explicit class
    to be run. Implicit intents do not have an explicit component, but the system
    decides what to do with it based on the data and attributes we assigned. Intent
    resolution process is responsible for handling such `intents`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combinations of these parameters are endless. We will give some examples so
    you can better understand the purpose of `intents`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening a web page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Capturing an image from a camera:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Picking an image from the gallery:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `intents` are a crucial part of the Android Framework. In the
    next section, we will extend our code to make more use of `intents`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing information between activities and fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To pass information between our activities, we will use the Android Bundle.
    Bundle can contain multiple values of different types. We will illustrate the
    use of Bundle by extending our code. Open `ItemsFragemnt` and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we introduced some important changes. First of all, we started our Note
    and Todo activities as sub activities. This means that our `MainActivity` class
    depends on the result of the work of those activities. When starting the sub activity
    instead of the `startActivity()` method, we used `startActivityForResult()`. Parameters
    we passed are the intent and request number. To get a result of the execution,
    we overrode the `onActivityResult()` method. As you can see, we checked which
    activity finished and if that execution produced a successful result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also changed the way we pass the information. We created the `Bundle` instance
    and assigned multiple values, like in case of the Todo activity. We added mode,
    date, and time. Bundle is assigned to intent using the `putExtras()` method. To
    use these extras, we updated our activities too. Open `ItemsActivity` and apply
    changes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we introduced the field holding result of activity work. We also updated
    the way we handle the passed information. As you can see, if there are any extras
    available, we will obtain an integer value for the mode. And, finally, the `onDestroy()`
    method sets the result of the work that will be available for parent activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `TodoActivity` and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have obtained values for date and time extras and set them to date/time
    picker buttons. Run your application and open the Todo activity. Your Todo screen
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2659bc5-b44b-4bcd-a06e-677c78e168a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you leave the Todo activity and return back to the main screen, observe
    your Logcat. There will be a log with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: W/Items fragment--we didn't create a new TODO.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have not created any Todo items yet, we passed a proper result. We
    canceled the creation process by going back to the main screen. In the later chapters,
    and the ones following, we will create Notes and Todos with success.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used this chapter to connect our interface and establish a real application
    flow. We established a connection between screens by setting proper actions to
    UI elements. We passed the data from point to point. All this in a very easy way!
    We have something that is working, but it looks ugly. In the next chapter, we
    will make sure it looks pretty! We will style it and add some nice visual effects.
    Prepare yourself to meet Android's powerful UI API.
  prefs: []
  type: TYPE_NORMAL
