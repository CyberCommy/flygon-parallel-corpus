- en: Dealing with Channels and Goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover concurrent programming with Go, using its basic built-in
    functionalities, channels, and goroutines. Concurrency describes the capability
    of executing different parts of an application during the same time period.
  prefs: []
  type: TYPE_NORMAL
- en: Making software concurrent can be a powerful tool in building system applications
    because some operations can be started even if others have not yet ended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantage usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is a language that centers around concurrency, to the point where two of
    the main features—channels and goroutines—are part of the built-in package. We
    will now see how they work and what their basic functionalities are, starting
    with goroutines, which make it possible to execute parts of an application concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing threads and goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Goroutines are one of the primitives used for concurrency, but how do they differ
    from threads? Let's read about each of them here.
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Current OSes are built for modern architectures that have processors with more
    than one core per CPU, or use technologies, such as hyper-threading, that allow
    a single core to support more than one thread. Threads are parts of processes
    that can be managed by the OS scheduler, which can assign them to a specific core/CPU.
    Like processes, threads carry information about the application execution, but
    the size of such information is smaller than processes. This includes the current
    instruction in the program, a stack of the current execution, and the variables
    needed for it.
  prefs: []
  type: TYPE_NORMAL
- en: The OS is already responsible for the context switch between processes; it saves
    the older process information and loads the new process information. This is called
    a **process context switch** and it's a very costly operation, even more than
    process execution.
  prefs: []
  type: TYPE_NORMAL
- en: In order to jump from one thread to another, the same operation can be done
    between threads. This is called a **t****hread context switch** and it is also
    a heavy operation—even if it is not as hefty as the process switch—because a thread
    carries less information than a process.
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threads have a minimum size in memory; usually, it is in the order of MBs (2
    MB for Linux). The minimum size sets some limitations on the application creation
    of a new thread—if each thread is at least some MBs, 1,000 threads will occupy at
    least a few GBs of memory. The way that Go tackles these issues is through the
    use of a construct similar to threads, but this is handled by the language runtime
    instead of the OS. The size of a goroutine in memory is three orders of magnitude
    (2 KB per goroutine), meaning that the minimum memory usage of 1,000 goroutines
    is comparable to the memory usage of a single thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is obtained by defining what data the goroutines are retaining internally,
    using a data structure called `g` that describes the goroutine information, such
    as stack and status. This is an unexported data type in the `runtime` package and
    it can be found in the Go source code. Go keeps a track of OSes using another
    data structure from the same package called `m`. The logical processors that are
    acquired in order to execute a goroutine are stored in `p` structures. This can
    be verified in the Go `runtime` package documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type g`: [golang.org/pkg/runtime/?m=all#m](https://golang.org/pkg/runtime/?m=all#g)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type m`: [golang.org/pkg/runtime/?m=all#g](https://golang.org/pkg/runtime/?m=all#m)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type p`: [golang.org/pkg/runtime/?m=all#p](https://golang.org/pkg/runtime/?m=all#p)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three entities interact as follows—for each goroutine, a new `g` gets
    created, `g` is queued into `p`, and each `p` tries to acquire `m` to execute
    the code from `g`. There are some operations that will block the execution, such
    as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in synchronization (channels and the `sync` package)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System calls that are blocking, such as file operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When these kinds of operations happen, the runtime detaches `p` from `m` and
    uses (or creates, if it does not already exist) another dedicated `m` for the
    blocking operation. The thread becomes idle after executing such operations.
  prefs: []
  type: TYPE_NORMAL
- en: New goroutine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Goroutines are one of the best examples of how Go hides complexity behind a
    simple interface. When writing an application in order to launch a goroutine,
    all that is needed is to execute a function preceded by the `go` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/3gPGZkJtJYv](https://play.golang.org/p/3gPGZkJtJYv).
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application of the previous example, we will see that it does
    not produce any output. Why? In Go, the application terminates when the main goroutine
    does, and it looks like this is the case. What happens is that the Go statements
    create the goroutine with the respective `runtime.g`, but this has to be picked
    up by the Go scheduler, and this does not happen because the program terminates
    right after the goroutine has been instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `time.Sleep` function to let the main goroutine wait (even a nanosecond!)
    is enough to let the scheduler pick up the goroutine and execute its code. This
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/2u125pTclv6](https://play.golang.org/p/2u125pTclv6).
  prefs: []
  type: TYPE_NORMAL
- en: 'We already saw that Go methods also count as functions, which is why they can
    be executed concurrently the with `go` statement, as they were normal functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/RUhgfRAPa2b](https://play.golang.org/p/RUhgfRAPa2b).
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures are anonymous functions, so they can be used as well, which is actually
    a very common practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/a-JvOVwAwUV](https://play.golang.org/p/a-JvOVwAwUV).
  prefs: []
  type: TYPE_NORMAL
- en: Multiple goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Organizing code in multiple goroutines can be helpful to split the work between
    processors and has many other advantages, as we will see in the next chapters. Since
    they are so lightweight, we can create a number of goroutines very easily using
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/Jaljd1padeX](https://play.golang.org/p/Jaljd1padeX).
  prefs: []
  type: TYPE_NORMAL
- en: This example prints a list of numbers from `0` to `9` in parallel, using concurrent
    goroutines instead of doing the same thing sequentially in a single goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Argument evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we change this example slightly by using a closure without arguments, we
    will see a very different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/RV54AsYY-2y](https://play.golang.org/p/RV54AsYY-2y).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this program, we can see that the Go compiler issues a warning in
    the loop: `loop variable i captured by func literal`.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable in the loop gets referenced in the function we defined—the creation
    loop of the goroutines is quicker than goroutines executing, and the result is
    that the loop finishes before a single goroutine is started, resulting in the
    print of the value of the loop variable after the last iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid the error of the captured loop variable, it''s better to
    pass the same variable as an argument to the closure. The arguments of the goroutine
    function are evaluated upon creation, meaning that changes to that variable will
    not be reflected inside the goroutine, unless you are passing a reference to a
    value such as a pointer, map, slice, channel, or function. We can see this difference
    by running the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/r1dtBiTUMaw](https://play.golang.org/p/r1dtBiTUMaw).
  prefs: []
  type: TYPE_NORMAL
- en: Passing the argument by value is not influenced by the last assignment of the
    program, while passing a pointer type implies that changes done to the pointer
    content will be seen by the goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Goroutines allow code to be executed concurrently, but the synchronization
    between values is not ensured out of the box. We can check out what happens when
    trying to use a variable concurrently with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have an integer variable that changes in the main routine—doing a millisecond
    pause between each operation—and after the change, the value is printed.
  prefs: []
  type: TYPE_NORMAL
- en: In another goroutine, there is a similar loop (using another variable) and another
    `print` statement that compares the two values. Considering that the pauses are
    the same, we would expect to see the same values, but this is not the case. We
    see that sometimes, the two goroutines are out of sync.
  prefs: []
  type: TYPE_NORMAL
- en: The changes are not reflected immediately because the memory is not synchronized
    instantaneously. We will learn how to ensure data synchronization in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Channels are a concept that is unique to Go and a few other programming languages.
    Channels are very powerful tools that allow a simple method for synchronizing different
    goroutines, which is one of the ways we can solve the issue raised by the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Properties and operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A channel is a built-in type in Go that is typed as arrays, slices, and maps.
    It is presented in the form of `chan type` and initialized by the `make` function.
  prefs: []
  type: TYPE_NORMAL
- en: Capacity and size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as the type that is traveling through the channel, there is another
    property that the channel has: its `capacity`. This represents the number of items
    a channel can hold before any new attempt to send an item is made, resulting in
    a blocking operation. The capacity of the channel is decided at its creation and
    its default value is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The capacity of the channel cannot be changed after its creation and can be
    read at any time using the built-in `cap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/Yhz4bTxm5L8](https://play.golang.org/p/Yhz4bTxm5L8).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `len` function, when used on a channel, tells us the number of elements
    that are held by the channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/zJCL5VGmMsC](https://play.golang.org/p/zJCL5VGmMsC).
  prefs: []
  type: TYPE_NORMAL
- en: From the previous example, we can see how the channel capacity remains as `5` and
    the length grows with each element.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a channel is full or its capacity is `0`, then the operation will block.
    If we take the last example, which fills the channel and tries to execute another
    send operation, our application gets stuck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/uSfm5zWN8-x](https://play.golang.org/p/uSfm5zWN8-x).
  prefs: []
  type: TYPE_NORMAL
- en: 'When all goroutines are locked (in this specific case, we only have the main
    goroutine), the Go runtime raises a deadlock—a fatal error that terminates the
    execution of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is can happen with both receive or send operations, and it''s the symptom
    of an error in the application design. Let''s take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, there is the `a <- 10` send operation and the matching `<-a` receive
    operation, but nevertheless, it results in a deadlock. However, the channel we
    created has no capacity, so the first send operation will block. We can intervene
    here in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**By increasing the capacity**: This is a pretty easy solution that involves
    initializing the channel with `make(chan int, 1)`. It works best only if the number
    of receivers is known a priori; if it is higher than the capacity, then the problem
    appears again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**By making the operations concurrent**: This is a far better approach because
    it uses the channels for what they made for—concurrency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to make the previous example work by using the second approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see that there are no deadlocks here and the program prints the
    values correctly. Using the capacity approach will also make it work, but it will
    be tailored to the fact that we are sending a single message, while the other
    method will allow us to send any number of messages through the channel and receive
    them accordingly from the other side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/RKcojupCruB](https://play.golang.org/p/RKcojupCruB).
  prefs: []
  type: TYPE_NORMAL
- en: We now have a constant to store the number of operations executed, but there
    is a better and more idiomatic way to let a receiver know when there are no more
    messages. We will cover this in the next chapter about synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Closing channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way of handling the end of a synchronization between a sender and
    a receiver is the `close` operation. This function is normally executed by the
    sender because the receiver can verify whether the channel is still open each
    time it gets a value using a second variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second receiver is a Boolean that will be `true` if the channel is still
    open, and `false` otherwise. When a receive operation is done on a `close` channel,
    the second received variable will have the `false` value, and the first one will
    have the `0` value of the channel type, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` for numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false` for Booleans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""` for strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nil` for slices, maps, or pointers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example of sending multiple messages can be rewritten using the `close` function,
    without having prior knowledge of how many messages will be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/GUzgG4kf5ta](https://play.golang.org/p/GUzgG4kf5ta).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a more synthetic and elegant way to receive a message from a channel
    until it''s closed: by using the same keyword that we used to iterate maps, arrays,
    and slices. This is done through `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: One-way channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another possibility when handling channel variables is specifying whether they
    are only for sending or only for receiving data. This is indicated by the `<-`
    arrow, which will precede `chan` if it''s just for receiving, or follow it if
    it''s just for sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/ZgEPZ99PLJv](https://play.golang.org/p/ZgEPZ99PLJv).
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels are already pointers, so casting one of them to its send-only or receive-only
    version will return the same channel, but will reduce the number of operations
    that can be performed on it. The types of channels are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Send only channels, `chan<-`, which will allow you to send items, close the
    channel, and prevent you from sending data with a compile error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive only channel, `<-chan`, that will allow you to receive data, and any
    send or close operations will be compiling errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a function argument is a send/receive channel, the conversion is implicit
    and it is a good practice to adopt because it prevents mistakes such as closing
    the channel from the receiver. We can take the other example and make use of the
    one-way channels with some refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a function for sending values that uses a send-only channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same thing for receiving using a receive-only channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, use them with the same channel that will be automatically converted
    in the one-way version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/pPuqpfnq8jJ](https://play.golang.org/p/pPuqpfnq8jJ).
  prefs: []
  type: TYPE_NORMAL
- en: Waiting receiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the examples we saw in the previous section had the sending operations
    done in a goroutine, and had the receiving operations done in the main goroutine.
    It could be the case that all operations are handled by goroutines, so do we synchronize
    the main one with the others?
  prefs: []
  type: TYPE_NORMAL
- en: A typical technique is the use of another channel used for the sole purpose
    of signaling that a goroutine has finished its job. The receiving goroutine knows
    that there are no more messages to get with the closure of the communication channel
    and it closes another channel that is shared with the main goroutine after finishing
    its operation. The `main` function can wait for the closure of the channel before
    exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical channel that is used for this scope does not carry any additional
    information except for whether it is open or closed, so it is usually a `chan
    struct{}` channel. This is because an empty data structure has no size in memory.
    We can see this pattern in action by making some changes to the previous example,
    starting with the receiver function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The receiver function gets an extra argument—the channel. This is used to signal
    that the sender is done and the `main` function will use that channel to wait
    for the receiver to end its task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/thPflJsnKj4](https://play.golang.org/p/thPflJsnKj4).
  prefs: []
  type: TYPE_NORMAL
- en: Special values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of situations in which channels behave differently. We will
    now see what happens when a channel is set to its zero value—`nil`—or when it
    is already closed.
  prefs: []
  type: TYPE_NORMAL
- en: nil channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have previously discussed how channels belong to the pointer types in Go,
    so their default value is `nil`. But what happens when you send or receive from
    a `nil` channel?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create a very simple app that tries to send to an empty channel, we get
    a deadlock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/KHJ4rvxh7TM](https://play.golang.org/p/KHJ4rvxh7TM).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do the same for a receiving operation, we get the same result of a deadlock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/gIjhy7aMxiR](https://play.golang.org/p/gIjhy7aMxiR).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing left to check is how the `close` function behaves with a `nil`
    channel. It panics with the `close of nil channel` explicit value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/5RjdcYUHLSL](https://play.golang.org/p/5RjdcYUHLSL).
  prefs: []
  type: TYPE_NORMAL
- en: To recap, we have seen that a `nil` channel's send and receive are blocking
    operations, and that `close` causes a panic.
  prefs: []
  type: TYPE_NORMAL
- en: Closed channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know that receiving from a closed channel returns a zero value for
    the channel type, and a second Boolean is `false`. But what happens if we try
    to send something after closing the channel? Let''s find out with the help of
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/_l_xZt1ZojT](https://play.golang.org/p/_l_xZt1ZojT).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to send data after closing, it will return a very specific panic: `send
    on closed channel`. A similar thing will happen when we try to close a channel
    that has already been closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/GHK7ERt1XQf](https://play.golang.org/p/GHK7ERt1XQf).
  prefs: []
  type: TYPE_NORMAL
- en: This example will cause a panic with a specific value—`close of closed channel`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many situations in which more than one goroutines are executing their
    code and communicating through channels. A typical scenario is to wait for one
    of the channels' send or receive operations to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: When you operate with many channels, Go makes it possible to use a special keyword
    that executes something similar to `switch` but for channel operations. This is
    done with the `select` statement, followed by a series of `case` statements and
    an optional `default` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a quick example of where we are receiving a value from a channel
    in a goroutine, and sending a value to another channel in a different goroutine.
    In these, the main goroutine we are using is a `select` statement to interact
    with the two channels, receive from the first, and send to the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/_8P1Edxe3o4](https://play.golang.org/p/_8P1Edxe3o4).
  prefs: []
  type: TYPE_NORMAL
- en: When running this program in the playground, we can see that the receive operation
    from the second channel is always the first to finish. If we switch the execution
    order of the goroutines, we get the opposite results. The operation executed last
    is the one picked up first. This happens because the playground is a web service
    that runs and executes Go code in a safe environment and does some optimizations
    to make this operation deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Default clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we add a default case to the previous example, the result of the application
    execution will be very different, particularly if we change `select`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/F1aE7ImBNFk](https://play.golang.org/p/F1aE7ImBNFk).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `select` statement will always choose the `default` statement. This happens
    because the goroutines are not picked up by the scheduler yet, when the `select` statement
    is executed. If we add a very small pause (using `time.Sleep`) before the `select`
    switch, we will have the scheduler pick at least one goroutine and we will then
    have one of the two operations executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/-aXc3FN6qDj](https://play.golang.org/p/-aXc3FN6qDj).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will have a mixed set of operations executed, depending on
    which one gets picked up by the Go scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Timers and tickers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `time` package offers a couple of tools that make it possible to orchestrate
    goroutines and channels—timers and tickers.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The utility that can replace the `default` clause in a `select` statement is
    the `time.Timer` type. This contains a receive-only channel that will return a
    `time.Time` value after the duration specified during its construction, using
    `time.NewTimer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/vCAff1kI4yA](https://play.golang.org/p/vCAff1kI4yA).
  prefs: []
  type: TYPE_NORMAL
- en: A timer exposes a read-only channel, so it's not possible to close it. When
    created with `time.NewTimer`, it waits for the specified duration before firing
    a value in the channel.
  prefs: []
  type: TYPE_NORMAL
- en: The `Timer.Stop` method will try to avoid sending data through the channel and
    return whether it succeeded or not. If `false` is returned after trying to stop
    the timer, we still need to receive the value from the channel before being able
    to use the channel again.
  prefs: []
  type: TYPE_NORMAL
- en: '`Timer.Reset` restarts the timer with the given duration, and returns a Boolean
    as it happens with `Stop`. This value is either `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` when the timer is active'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false` when the timer was fired or stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will test these functionalities with a practical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating a new timer of `1ms`. Here, we wait `0.5ms` and then stop it
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/ddL_fP1UBVv](https://play.golang.org/p/ddL_fP1UBVv).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are resetting the timer back to `1ms` and waiting for it to fire, to
    see whether `Stop` returns `false` and the channel gets drained.
  prefs: []
  type: TYPE_NORMAL
- en: AfterFunc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very useful utility that uses `time.Timer` is the `time.AfterFunc` function, which
    returns a timer that will execute the passed function in its own goroutine when
    the timer fires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/77HIIdlRlZ1](https://play.golang.org/p/77HIIdlRlZ1).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we define two timers for two different closures, and
    we stop one of them and let the other trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Tickers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`time.Ticker` is similar to `time.Timer`, but its channel delivers more elements
    at regular intervals equal to the duration. They are specified when creating it
    with `time.NewTicker`.  This makes it possible to stop the ticker from firing
    with the `Ticker.Stop` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/8w8I7zIGe-_j](https://play.golang.org/p/8w8I7zIGe-_j).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are also using `time.After`—a function that returns the
    channel from an anonymous `time.Timer`. This can be used when there's no need
    to stop the timer. There is another function, `time.Tick`, that returns the channel
    of an anonymous `time.Ticker`. Both functions will return a channel that the application
    has no control over and this channel will eventually be picked up by the garbage
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the overview of channels, from their properties and basic usage
    to some more advanced concurrency examples. We also checked some special cases
    and how to synchronize multiple channels.
  prefs: []
  type: TYPE_NORMAL
- en: Combining channels and goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the fundamental tools and properties of Go concurrency, we
    can use them to build better tools for our applications. We will see some examples
    that make use of channels and goroutines to solve real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical scenario is having a web API that has a certain limit to the number
    of calls that can be done in a certain period of time. This type of API will just
    prevent the usage for a while if this threshold is crossed, making it unusable
    for the time being. When creating a client for the API, we need to be aware of
    this and make sure our application does not overuse it.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a very good scenario where we can use `time.Ticker` to define an interval
    between calls. In this example, we will create a client for Google Maps'' geocoding
    service that has a limit of 100,000 requests per 24 hours. Let''s start by defining
    the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The client is made by an HTTP client that will call maps, a ticker that will
    help prevent passing the rate limit, and needs an API key for authentication with
    the service. We can define a custom `Transport` struct for our use case that will
    inject the key in the request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very good example of how Go interfaces allow the extension of their
    own behavior. We are defining a type that implements the `http.RoundTripper` interface,
    and also an attribute that is an instance of the same interface. The implementation
    injects the API key to the request before executing the underlying transport.
    This type allows us to define a helper function that creates a new client, where
    we are using the new transport that we defined together with the default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The maps geocoding API returns a series of addresses that are composed of various
    parts. This is available at [https://developers.google.com/maps/documentation/geocoding/intro#GeocodingResponses](https://developers.google.com/maps/documentation/geocoding/intro#GeocodingResponses).
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is encoded in JSON, so we need a data structure that can receive
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the structure to execute a reverse geocoding operation—getting a
    location from the coordinates by using the respective endpoint. We wait for the
    ticket before executing the HTTP request, remembering to `defer` the closure of
    the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can decode the result in a data structure that uses the `Result` type
    we already defined and checks for the `status` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the client to geocode a series of coordinates, expecting
    the requests to be at least `860ms` from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example is a Google Maps client that uses a `time.Ticker` channel
    to limit the rate of the requests. The rate limit makes sense for an API key.
    Let's imagine that we have more API keys from different accounts, so we could
    potentially execute more requests.
  prefs: []
  type: TYPE_NORMAL
- en: A very typical concurrent approach is the workers pool. Here, you have a series
    of clients that can be picked up to process an input and different parts of the
    application can ask to use such clients, returning the clients back when they
    are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create more than one client that shares the same channels for both requests
    and responses, with requests being the coordinates and the results being the response
    from the service. Since the channel for responses is unique, we can define a custom
    type that holds all the information needed for that channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is creating the channels—we are going to read a comma-separated
    list of values from an environment variable here. We will create a channel for
    requests, and one for responses. Both channels have a capacity equal to the number
    of workers, in this case, but this would work even if the channels were unbuffered.
    Since we are just using channels, we will need another channel, `done`, which
    signals whether a worker has finished working on their last job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a goroutine for each of the keys, in which we define a
    client that feeds on the requests channel, executes the request, and sends the
    result to the dedicated channel. When the requests channel is closed, the goroutine
    will exit the range and send a message to the `done` channel, which is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The locations can be sent to the request channel sequentially in another goroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can keep count of the done signals we are receiving and close the results
    channel when all the workers are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The channel is used to count how many workers are done, and once every one
    of them is done, it will close the result channel. This will allow us to just
    loop over it to get the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using a channel is just one of the ways to wait for all the goroutines to finish,
    and we will see more idiomatic ways of doing it in the next chapter with the `sync`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Pool of workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A channel can be used as a pool of resources that allows us to request them
    on demand. In the following example, we will create a small application that will
    look up which addresses are valid in a network, using a third-party client from
    the `github.com/tatsushid/go-fastping` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pool will have two methods, one for getting a new client and another to
    return the client back to the pool. The `Get` method will try to get an existing
    client from the channel or return a new one if this is not available. The `Put`
    method will try to put the client back in the channel, or discard it otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The client will need to specify which network needs to be scanned, so it requires
    a list of available networks starting with the `net.Interfaces` function, ranging
    through the interfaces and their addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can accept a command-line argument to select between interfaces, and we
    can show a list of interfaces to the user to select when the argument is either
    not present or wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `help` function is just a print of the interfaces IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is obtain the range of IPs that need to be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the IP, we can create a function to obtain other IPs in the
    same network. IPs in Go are a byte slice, so we will replace the least significant
    bits in order to obtain the final address. Since the IP is a slice, its value
    will be overwritten by each operation (slices are pointers). We are going to update
    a copy of the original IP—because slices are pointers to the same array—in order
    to avoid overwrites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will need one channel for results and another for keeping a track
    of the goroutines; and for each IP, we need to check whether we can launch a goroutine
    for each address. We will use a pool of 10 clients and inside each goroutine—we
    will ask for each client, then return them to the pool. All valid IPs will be
    sent through the result channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time a routine finishes, we send a value in the `done` channel so we can
    keep count of the `done` signals received before exiting the application. This
    will be the result loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The loop will continue until the count from the channel reaches the number of
    goroutines. This concludes the more convoluted examples of the usage of channels
    and goroutines together.
  prefs: []
  type: TYPE_NORMAL
- en: Semaphores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Semaphores are tools used to solve concurrency issues. They have a certain number
    of available quotas that is used to limit the access to resources; also, various
    threads can request one or more quotas from it, and then release them when they
    are done. If the number of quotas available is one, it means that the semaphore
    supports only one access at time, with a behavior similar to mutexes. If the quota
    is more than one, we are referring to the most common type—the weighted semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, a semaphore can be implemented using a channel with a capacity equal
    to the quotas, where you send a message to the channel to acquire a quota, and
    receive one from it to release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows us how to implement a semaphore using a channel in
    a few lines. Here''s an example of how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/BR5GN2QopjQ](https://play.golang.org/p/BR5GN2QopjQ).
  prefs: []
  type: TYPE_NORMAL
- en: We can see from the previous example how the program serves some requests on
    the first round of acquisition, and the others on the second round, not allowing
    more than five executions at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about the two main actors in Go concurrency—goroutines
    and channels. We started by explaining what a thread is, what the differences
    are between threads and goroutines, and why they are so convenient. Threads are
    heavy and require a CPU core, while goroutines are lightweight and not bound to
    a core. We saw how easily a new goroutine can be started by executing a function
    preceded by the `go` keyword, and how it is possible to start a series of different
    goroutines at once. We saw how the arguments of the concurrent functions are evaluated
    when the goroutine is created and not when it actually starts. We also saw that
    it is very difficult to keep different goroutines in sync without any additional
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we introduced channels that are used to share information between different
    goroutines and solve the synchronization problem that we mentioned previously.
    We saw that goroutines have a maximum capacity and a size—how many elements it
    is holding at present. Size cannot overcome capacity, and when an extra element
    is sent to a full channel, the operation blocks it until an element is removed
    from the channel. Receiving from a channel that is empty is also a blocking operation.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to close channels with the `close` function, how this operation should
    be done in the same goroutine that sends data, and how operations behave in special
    cases such as `nil` or a closed channel. We introduced the `select` statement
    to choose between concurrent channel operations and control the application flow.
    Then, we introduced the tools related to concurrency from the `time` package—tickers
    and timers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we showed some real-world examples, including a rate-limited Google
    Maps client and a tool to simultaneously ping all the addresses of a network.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some synchronization primitives that will
    allow a better handling of goroutines and memory, using more clear and simple
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a thread and who is responsible for it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are goroutines different from threads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When are arguments evaluated when launching a goroutine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between buffered and unbuffered channels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are one-way channels useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when operations are done on `nil` or closed channels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are timers and tickers used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
