- en: Shell Scripting and SQL Data Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we covered a wide array of security features that are available
    in the Linux environment. First, we discussed executing commands with root privileges.
    We then moved on to TCP wrappers, focusing on the `/etc/hosts.allow` and `/etc/hosts.deny`
    files. Next, we covered SSH; we looked at setting up SSH access between a client
    and a server. Finally, we covered encryption in depth.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the final chapter of this book—we will be covering the basics
    of shell scripting and SQL management. First, we will look at the syntax for writing
    a shell script; this will be followed by writing scripts with various loops, such
    as the `for` and `while` loops. Next, we will cover writing shell scripts using
    `if` statements. Finally, we will finish this chapter (and book) by covering the
    basics of SQL management.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL data management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover shell scripting, starting with the basics and
    moving on to writing scripts using loops and `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of shell scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing scripts using `for` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing scripts using `while` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing scripts using `if` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of shell scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the command line, we often work with a series of the same commands on a
    regular basis. It would be ideal to somehow bundle those commands and simplify
    the process, executing a single command or script to accomplish an overall objective
    that would take longer if we had to type out a single command repetitively. This
    is where shell scripting shines. We can place our commands, regardless of how
    long they may be, into a single file; give it an appropriate name; and execute
    the script as needed. The following code shows the basic syntax for creating a
    shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is the first line in the script; it is used to define
    the shell interpreter. The first characters, `#!`, are often known as shebang,
    sha-bang, hashbang, pound-bang, or hash-pling. The `/bin/sh` object defines which
    interpreter should be used for this script; in this case, it''s the Shell Command
    Language (`sh`). Another popular interpreter that you are bound to see is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to the previous declaration, in that we have `#!`, which indicates
    that we are going to define the shell interpreter to use; in this case, we''re
    using the Bourne Again Shell, or Bash. This shell offers more extensions that
    the regular `sh` shell; in fact, most newer Linux distributions are ported with
    Bash as a defacto shell. We can easily identify which shell is in play by issuing
    the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! The environment variable, `SHELL`, stores the current shell; the value
    returned indicates that we are running the bash shell. Another way to identify
    the shell is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The bash shell is being used. Also, we can use the `ps` command
    to display the current shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! For our purposes, we will be using `#!/bin/bash` for written scripts.
    To begin writing your very first script, open a text editor, such as vi or nano,
    and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Excellent! We have our declaration in the first line; we''ve defined the `/bin/bash`
    shell. Next, we have two lines that begin with a `#` symbol. Any line (other than
    the first line at the top) is referred to as a comment. That being said, the last
    two lines are comments. We can prove this by saving our script; we can use `:wq`,
    which will save and exit our script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Excellent! We''ve used `+x`, which turns on the execute bit for the user, group,
    and others; also, the script''s name has been changed to the color green, to indicate
    that the file is now executable. In order to run this script, we use the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! The script was executed; however, the contents were not displayed.
    This is due to the fact that we''ve only defined comments so far; we have not
    defined anything else inside of our script. Let''s make our script display a short
    message. Open the script using either vi or nano, and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We''ve added our first command to be executed: the `echo` command.
    This will simply respond with whatever is passed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We''ve successfully written our very first script. Let''s add another
    command, to illustrate the effectiveness of scripting; we''ll add the `date` command,
    which will provide the date whenever we execute our script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! We now have two commands that are executed every time our script
    runs. In addition to sending output to the display, we can carry out other tasks.
    For instance, we can create an archive file; let''s create a `.tar` file of the `/home/philip/Downloads`
    directory for illustration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we used the `tar` command to create an archive of the
    `/home/philip/Downloads` directory. Now, we can run the script to see the results,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! Our script was successful, and an archive was created with the `.tar`
    extension. Additionally, we can create a script that takes input from the user,
    using the `read` command. Let''s create another script and name it `input.sh`,
    using vi or nano, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We''ve created an `input.sh` script; we''ve used the `read` command
    to store the input from the user. The value stored in the name is called a variable.
    It is displayed in the last line, by adding a `$` in front of the variable''s
    name. The result of the script is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The prompt is paused until we enter something; we will enter a name and look
    at the results, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The name that we entered was appended to the last line. Another
    way that we can define a variable is by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we give the variable a name, and then specify a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new script named `myvar.sh`, using either vi or nano. The following
    code shows how we can define a variable using a new script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! We defined a variable, `OUR_VAR`, and we gave it the value, `Philip
    Inshanally`; this was then called inside of the `echo` command, by placing a `$`
    symbol in front of the variable name. As you can see, there are various ways to
    define a variable. The variable value needs to be enclosed in parentheses whenever
    there is a space between the words. If there is only a single word, or numbers,
    you do not have to enclose the value in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Do not enclose a single word or a number in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Writing scripts using for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to write out each command in a script line by line, which can
    be cumbersome at times. We can achieve the same objective by using loops, which
    execute based on an expression being met, generating the commands for us. The
    basic syntax of a `for` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines a condition and, once the condition is met, we have
    a series of commands. To see this in action, let''s create a script, called `myForLoop.sh`,
    using either vi or nano:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! The line that begins with `for o in {1..10}` defines how many times
    we would like to execute the `for` loop; it will be executed 10 times. The command
    under the `do` section is the command that will be executed; the `$o` is the variable
    that was defined in the `for` section. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! This condition can also be written in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We wrote the values, separated by spaces, and the script was successful.
    We can also specify the condition in three parts, similar to the C programming
    language, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! In the preceding code, the `for ((p=1; p<=6; p++))` line defines
    a variable and assigns it a value of `p=1;` the `p<=6` checks for the condition,
    and the `p++` means to increment the value of the variable as long as the condition
    is met.
  prefs: []
  type: TYPE_NORMAL
- en: Writing scripts using the while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another popular loop that can be used in scripting is the `while` loop. The
    basic syntax of a `while` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we specify a condition, and, as long as the condition
    is met, the loop will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script named `myWhile.sh`, using either vi or nano, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! First, we defined a variable, `d=1`, and we then specified a condition,
    `(( $d <= 8 ))`, which checks whether the variable, `d`, is less than or equal
    to `8`; following this, we are using the `echo` command to provide the text, based
    on the condition. The last part, `d=$(( d+1 ))`, will increment the variable after
    each condition is met, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! Another technique that can be used for a condition is `:`, used after
    the `while` statement. The `:` will always be `True`; this means that the loop
    will not end until we end the script, using *Ctrl* + *C*. Let''s create another
    script, named `infinite.sh`, using either vi or nano, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A prompt will appear, allowing us to type anything; as soon as we press the
    *Enter* key, another message will be displayed, including whatever we typed. This
    will continue infinitely, until we exit the script using *Ctrl* + *C*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! The script did not quit until we used the *Ctrl* + *C* combination.
    Another way to illustrate the effectiveness of the `while` loop is to look for
    a string before the script exits. Create another script, named `whileString.sh`,
    using either vi or nano, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We declared a variable, `someString=begin`; this can be any value
    that you choose. Next, we checked for a condition, `[ "$someString" != "quit"
    ]`, which looks for the `quit` string. As long as the string is not `quit`, the
    script will keep running infinitely, until we type `quit` or press *Ctrl* + *C*,
    which will exit the script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We could keep entering text, and the script would continue to run,
    unless we entered quit or pressed *Ctrl* + *C*, which would exit the script.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we used square brackets ([]) to enclose the text; the script would
    not work with the regular parantheses (()) when testing for a string value.
  prefs: []
  type: TYPE_NORMAL
- en: Writing scripts using if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use `if` statements in scripting, in order to test a condition. The
    basic syntax of an `if` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a simple `if` script, using the preceding code as guidance. Sometimes,
    we may need to use double square brackets, which offer enhancements over the older,
    single-bracket style. Let''s create a script named `myif.sh`, using vi or nano, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `echo` command to display a welcome message; we then used `if [[
    $1 == 4 ]]; then`; this statement is checking for `4`. The script executed; however,
    we did not see the `echo` command inside of the `if` statement being executed.
    In order to see the message inside of the `if` statement, we have to type a value
    when we run our script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful; the statement inside of the `if` construct was executed, but, if
    we passed any value other than `4`, we would see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The command inside of the `if` statement was not executed, due to the fact
    that the value that we passed is not equal to the value being checked against.
    We can add another bit to the `if` statement, to handle an alternate response;
    we can use the `else` clause. The following is the syntax of the `else` clause
    that is injected into the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can edit our `my.sh` script, using either vi or nano, and add an `else`
    clause to handle any alternate responses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We can run our script with the `else` clause injected; the result
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We''re shown a different message whenever the user enters a value
    other than `4`. Furthermore, we can nest an `if` statement inside of another `if`
    statement. The basic syntax for nesting `if` statements is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can edit our `myif.sh` script, using either vi or nano, and add a second
    `elif` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added `elif [[ $1 == 2 ]]; then`, which checks for the value `2`. Once
    this condition is met, a message will be displayed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We can see that when we enter a value that matches the `elif` condition,
    the command under the `elif` condition is executed. Additionally, when we enter
    a value that does not match either the `if` or `elif` condition, a catch-all message
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to test multiple conditions on a single `if` statement
    or `elif` statement. Let''s edit our `myif.sh`, using vi or nano, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we''ve added a second condition in the `if` statement;
    namely, `if [[ $1 == 4 ]] || [[ $1 == 3 ]] ; then`. The || means *or*. This is
    checking for either condition to be met, and the command will be executed under
    the `if` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! Once either condition is met in the `if` clause, the command is
    executed under the `if` clause. Additionally, there is the `&&` command, used
    for comparing conditions; this means that both conditions must be met. We can
    quickly edit our `myif.sh` script and add in `&&`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user enters `2`, the `elif` condition will be met; this is due to
    the fact that both conditions need to be true. If the user enters any value other
    than `2`, the catch-all `else` clause will be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Both conditions were met in the `elif` clause, resulting in the command
    being executed under the `elif` clause.
  prefs: []
  type: TYPE_NORMAL
- en: SQL data management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Structured Query Language** (**SQL**) is a well-known language used for database
    manipulation. There are various versions of SQL. We will be working with an open
    standard of MySQL: the `mysql-community-server` package. First, we will need the
    MySQL `YUM` repository in our Fedora 28 system; we will use the `dnf` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! The repository was successfully installed. Now, we will install the
    server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, some output has been omitted for brevity. The package
    is going to take up over 1 GB in space; the time it will take to download will
    vary, depending on your internet connection. The progress will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After some time, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! The next step is to enable the `mysqld` service; we will use the
    `systemctl` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome! The `mysqld.service` was started successfully. During the installation,
    a random `root` password for the `mysql` server was generated; we have to look
    inside of the `/var/log/mysqld.log` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The random password for the `root` of the `mysql` is `#a7RCyoyzwOF`. Finally,
    we should secure our `mysql` database; we will use the `mysql_secure_installation`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have to enter the random password; then, we have to set a new password,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validate_password` plugin is installed by default; this sets the password
    specifications. We will have to enter a password that is a combination that consists
    of at least one uppercase character, one lowercase character, one digit, and one
    special character. The total password length must be at least eight characters,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, an anonymous user account is generated; we will select `y` to remove
    it and continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will allow the `root` user to log in remotely, so we will press a key, and
    this step will be skipped, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mysql` is now more secure, as compared to the default installation. We
    can now log in to the `mysql` database using the `mysql` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We will now create our first database; we will use the `create database`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We will now create a user that can access our database; we will use
    the `create user` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, once again, the password requirements are not being
    met; we can remedy this by either lowering the settings or removing the `validate_password`
    components. We will remove the `validate_password` components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We used the `UNINSTALL COMPONENT` command to remove `component_validate_password`.
    Now, we can log in as we did earlier and continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! The last step is to reload the grant tables; we will use the `flush`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! When we left off `;`, the command was not executed. We always need
    to end with a semicolon (;). Now, we can test over the network, from our Ubuntu
    system. We will have to install the `mysql-client` on the Ubuntu 18 system, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We successfully connected the `mysql` server hosted on our Fedora
    28 system over the network, using the Ubuntu 18 client. We can now use a variety
    of commands, such as the `show databases` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We can see two databases: the one that we created earlier and an internal
    database. However, if we run this command as the root user, we will see all of
    the available databases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! Another way to view the databases is to use the `mysql` command
    with the `-e` option; this allows us to perform commands from the shell. The following
    code snippet shows how we can list the databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! Following this, we can use the `use` command to switch to a given
    database. The following code shows how we can specify the database to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now inside of the `netaccess` database. To begin using the databases,
    we have to first create a table; before we create a table, we need to know what
    type of table we would like to create. For instance, let''s suppose that we want
    to create a table about public places; we will want to have a field for the name
    of the place. If we just create a table with the name of the place, it will not
    be that appealing; we will want to add other aspects, such as the service provided
    and the location, to name a couple. As you can see, a table can contain a variety
    of options. To start, we will use the fields mentioned in our example; we''re
    going to use the `create table` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We successfully created our first table. We can view the tables
    using the `show tables` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see our table listed. We can view the fields that we created using the
    `describe` command. The following code shows how we can use the `describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! We can see the fields, along with their types; the `varchar` type length
    can be a value between 0 and 65,535\. Currently, the table is empty, so we have
    to populate it.
  prefs: []
  type: TYPE_NORMAL
- en: The insert command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `insert` command to populate a table. The basic syntax is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add some information to the table that we created earlier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! We specified the values and passed them with the `insert` command,
    which stored the data in the table. Another way to insert data is to insert data
    in only some of the fields; we have to specify the field names to do selective
    insertion. The following code shows how we can insert data into some portions
    of the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We only inserted values for two fields (`name` and `location`). Another
    way to insert data is to use the `mysql` command with the `-e` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! The data was successfully entered into the table.
  prefs: []
  type: TYPE_NORMAL
- en: The select command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve been adding contents to our table. However, we have not seen
    the values that we''ve added. We can use the `select` command to view the contents
    of a table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We can see all of the values that we have entered so far in our
    table. Furthermore, we can perform selective searches by specifying the `where`
    clause, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! We can also perform searches using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: The update command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `update` command to make changes to a table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! We''ve filled in the data for the `service_provided` field of `Telephone
    Company`; this can be verified using the `select` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We can see that the field for `service_provided` has been filled.
    Additionally, we can change the data by using the `update` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: The delete command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can remove values from the fields of a table using the `delete` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! The field that was specified with the `delete` command was removed.
  prefs: []
  type: TYPE_NORMAL
- en: The from option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `from` option to specify which table to use; for instance, if
    we specify a non-existing table, we will see the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The table does not exist, so we have to enter the correct table when performing
    queries, using the `from` option.
  prefs: []
  type: TYPE_NORMAL
- en: The where condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `where` condition when we want to perform some selective manipulation.
    We''ve used the `where` condition previously, with the `select`, `update`, and `delete`
    commands. As a refresher, we can use the `where` condition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Only the results from the condition are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The group by option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `group by` option to provide results based on the criteria that
    we specify, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! The results are grouped by the specified criteria. This is useful when
    we have tables that consist of numbers, for instance, customer ID, employee ID,
    and ordered, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: The order by option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `order by` option to sort the data in the table, in either an
    ascending or descending order. The following code shows how to use the `order
    by` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the default, the data is sorted in an ascending order; however, we
    can display the results in a descending order by passing the `DESC` keyword, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! The results are displayed in a descending order.
  prefs: []
  type: TYPE_NORMAL
- en: The join option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a simple join by passing the `join` option; this can be used to
    combine rows from separate tables, to look at a common factor between the tables.
    I''ve created two tables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The columns that are identical are the first columns of each table; the `Cust`
    table refers to this as `custID`, whereas the `Purchase` table refers to this
    as ordered. Based on this, we can create a select query that will merge the two
    tables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We referenced the fields by placing the table's name in front of
    `Purchase.orderID`, `Cust.custName`, `Purchase.orderDate`; this defined how the
    table would be presented.
  prefs: []
  type: TYPE_NORMAL
- en: The next portion, `FROM Purchase INNER JOIN Cust ON Purchase.orderID=Cust.custID;`,
    defined that the content would be coming from the `Purchase` table, and it would
    be joined by using the common column of `Purchase.orderID=Cust.custID`, hence
    producing the results containing data from both tables.
  prefs: []
  type: TYPE_NORMAL
- en: This is known as an inner join; it returns data that has matching values in
    both tables.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at shell scripting and SQL management. First, we
    covered the basics of shell scripting. Next, we worked our way through writing
    scripts using `for` loops. This was followed by using the `while` loop. We finished
    off with `if` statements in scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we worked with SQL management. First, we installed the MySQL repository,
    and then, we installed the community-server edition of MySQL. This was followed
    by securing our `mysql` server. Then, we dove into the creation of a database,
    followed by creating a table. We then started to manage the data in the table
    by using a variety of techniques; we finished by creating additional tables, in
    order to demonstrate inner joins.
  prefs: []
  type: TYPE_NORMAL
- en: I've had an awesome time compiling every chapter in this book. I'm confident
    that you will learn a lot from this book as you move forward with your career.
    I want to thank you for choosing this book and making it a part of your collection.
    Until next time, this is Philip Inshanally, reminding you to always be grateful.
    I'll see you soon!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What characters identify is at the start the line where the interpreter is defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `#$`
  prefs: []
  type: TYPE_NORMAL
- en: B. `#@`
  prefs: []
  type: TYPE_NORMAL
- en: C. `#!`
  prefs: []
  type: TYPE_NORMAL
- en: D. `#^`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following environment variables stores the current shell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `SHELL`
  prefs: []
  type: TYPE_NORMAL
- en: B. `BASH`
  prefs: []
  type: TYPE_NORMAL
- en: C. `SH`
  prefs: []
  type: TYPE_NORMAL
- en: D. `TCSH`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following keywords ends a `for` loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `do`
  prefs: []
  type: TYPE_NORMAL
- en: B. `do loop`
  prefs: []
  type: TYPE_NORMAL
- en: C. `done`
  prefs: []
  type: TYPE_NORMAL
- en: D. `fi`
  prefs: []
  type: TYPE_NORMAL
- en: If a script resides in the present directory, what character needs to be placed
    in front of `/`, in order to run the script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `.`
  prefs: []
  type: TYPE_NORMAL
- en: B. `:`
  prefs: []
  type: TYPE_NORMAL
- en: C. `;`
  prefs: []
  type: TYPE_NORMAL
- en: D. `“`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following commands can create a variable to store the user's input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `execute`
  prefs: []
  type: TYPE_NORMAL
- en: B. `pause`
  prefs: []
  type: TYPE_NORMAL
- en: C. `write`
  prefs: []
  type: TYPE_NORMAL
- en: D. `read`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following characters can be used to test two conditions and return
    `TRUE` if either condition is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `&&`
  prefs: []
  type: TYPE_NORMAL
- en: B. `||`
  prefs: []
  type: TYPE_NORMAL
- en: C. `//`
  prefs: []
  type: TYPE_NORMAL
- en: D. `==`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following characters is used as a wildcard when using the `select`
    command to perform a `mysql` query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `+`
  prefs: []
  type: TYPE_NORMAL
- en: B. `/`
  prefs: []
  type: TYPE_NORMAL
- en: C. `*`
  prefs: []
  type: TYPE_NORMAL
- en: D. `-`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following options is used to check for a condition when using the
    `select` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `from`
  prefs: []
  type: TYPE_NORMAL
- en: B. `if`
  prefs: []
  type: TYPE_NORMAL
- en: C. `where`
  prefs: []
  type: TYPE_NORMAL
- en: D. `JOIN`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following commands would create a table using mysql?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `create tables`
  prefs: []
  type: TYPE_NORMAL
- en: B. `CREATE TABLE`
  prefs: []
  type: TYPE_NORMAL
- en: C. `CREATE TABLES`
  prefs: []
  type: TYPE_NORMAL
- en: D. `create TABLEs`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following commands can be used to change a value using `mysql`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `INSERT`
  prefs: []
  type: TYPE_NORMAL
- en: B. `DELETE`
  prefs: []
  type: TYPE_NORMAL
- en: C. `UPDATE`
  prefs: []
  type: TYPE_NORMAL
- en: D. `JOIN`
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following site provides useful information about shell scripting: [https://www.shellscript.sh](https://www.shellscript.sh)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following site provides useful information about loops: [https://www.tutorialspoint.com](https://www.tutorialspoint.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following site provides useful information about mysql: [https://www.w3schools.com](https://www.w3schools.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
