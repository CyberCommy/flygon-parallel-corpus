- en: Classes and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin language provides full support for OOP programming. We will review
    powerful structures that allow us to simplify data model definition and operate
    on it in an easy and flexible way. We'll learn how Kotlin simplifies and improves
    implementations of many concepts known from Java. We will take a look at different
    type of classes, properties, initializer blocks, and constructors. We will learn
    about **operator overloading** and interface default implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Class declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property access syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors and initializers blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructive declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealed classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes are a fundamental building block of OOP. In fact, Kotlin classes are
    very similar to Java classes. Kotlin, however, allows more functionality together
    with simpler and much more concise syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Class declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes in Kotlin are defined using the `class` keyword*.* The following is
    the simplest class declaration--an empty class named `Person` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition of `Person` does not contain any body. Still, it can be instantiated
    using a default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Even such a simple task as class instantiation is simplified in Kotlin. Unlike
    Java, Kotlin does not require the `new` keyword to create a class instance. Due
    to strong Kotlin interoperability with Java, we can instantiate classes defined
    in Java and Kotlin exactly the same way (without the `new` keyword). The syntax
    used to instantiate a class depends on the actual language used to create class
    instance (Kotlin or Java), not the language the class was declared in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is the rule of thumb to use the `new` keyword inside a Java file and never
    use the `new` keyword inside a Kotlin file.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property is just a combination of a *backing field* and its accessors. It could
    be a *backing field* with both a getter and a setter or a backing field with only
    one of them. Properties can be defined at the top-level (directly inside file)
    or as a member (for example, inside class, interface, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, it is advisable to define properties (private fields with getters/setters)
    instead of accessing public fields directly (According to *Effective Java, by
    Joshua Bloch,* book''s item 14: in public classes, use accessor methods, not public
    fields).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java getter and setter conventions for private fields'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getter** : A parameterless method with a name that corresponds to property
    name and a `get` prefix (for a `Boolean` property there might be an `is` prefix
    used instead)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setter** : Single-argument methods with names starting with `set` : for example,
    `setResult(String resultCode)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin guards this principle by language design, because this approach provides
    various encapsulation benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to change internal implementation without changing an external API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforces invariants (call methods that validate objects state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to perform additional actions when accessing member (for example, log
    operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To define a top-level property, we simply define it in the Kotlin file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s imagine that we need a class to store basic data regarding a person.
    This data may be downloaded from an external API (backend) or retrieved from a
    local database. Our class will have to define two (member) properties, `name`
    and `age` . Let''s look at the Java implementation first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This class contains only two properties. Since we can make the Java IDE generate
    accessors code for us, at least we don't have to write the code by ourselves.
    However, the problem with this approach is that we cannot get along without these
    automatically generated chunks, and that makes the code very verbose. We (developers)
    spend most of our time just reading the code, not writing it, so reading redundant
    code wastes a lot of valuable time. Also a simple task such as refactoring the
    property name becomes a little bit trickier, because the IDE might not update
    constructor parameter names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, boilerplate code can be decreased significantly by using Kotlin.
    Kotlin solves this problem by introducing the concept of *properties* that is
    built into the language. Let''s look at a Kotlin equivalent of the preceding Java
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an exact equivalent of the preceding Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `constructor` method is equivalent of the Java constructor that is called
    when an object instance is created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getters and setters are generated by the Kotlin compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can still define custom implementations of getters and setters. We will discuss
    this in more detail in the *Custom getters/setters section* .
  prefs: []
  type: TYPE_NORMAL
- en: 'All the constructors that we have already defined are called *secondary* *constructors.*
    Kotlin also provides alternative, very concise syntax for defining constructors.
    We can define a constructor (with all parameters) as part of the class header.
    This kind of constructor is called a *primary constructor* . Let''s move a property
    declaration from the secondary constructor into the primary constructor to make
    our code a little bit shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In Kotlin, the primary constructor, as opposed to the secondary constructor,
    can't contain any code, so all initialization code must be placed inside the initializer
    block (`init` ). An initializer block will be executed during class creation,
    so we can assign constructor parameters to fields inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify code, we can remove the initializer block and access constructor
    parameters directly in property initializers. This allows us to assign constructor
    parameters to a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We managed to make the code shorter, but it still contains a lot of boilerplate,
    because type declarations and property names are duplicated (constructor parameter,
    field assignment, and field itself). When properties does not have any custom
    getters or setters we can define them directly inside primary constructor by adding
    val or var modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the primary constructor does not have any annotations (`@Inject`
    , and so on) or visibility modifiers (`public` , `private` , and so on), then
    the `constructor` keyword can be omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the constructor takes a few parameters, it is good practice to define
    each parameter in a new line to improve code readability and decrease chance of
    potential merge conflicts (when merging branches from source code repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summing up, the preceding example is equivalent of the Java class presented
    at the beginning of this section--both properties are defined directly in the
    class primary constructor and Kotlin compiler does all the work for us--it generates
    appropriate fields and accessors (getters/setters).
  prefs: []
  type: TYPE_NORMAL
- en: Note that this notation contains only the most important information about this
    data model class--its name, parameter names, types, and mutability (`val` /`var`
    ) information. Implementation has nearly zero boilerplate. This makes the class
    very easy to read, understand, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Read-write versus read-only property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the properties in the previous examples were defined as read-write (a setter
    and a getter are generated). To define read-only properties we need to use the
    `val` keyword, so only getter will be generated. Let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin does not support write-only properties (properties of which only setter
    is generated).
  prefs: []
  type: TYPE_NORMAL
- en: '| **Keyword** | **Read** | **Write** |'
  prefs: []
  type: TYPE_TB
- en: '| `var` | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `val` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| (unsupported) | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: Property access syntax between Kotlin and Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another big improvement introduced by Kotlin is the way of accessing properties.
    In Java, we would access property using the corresponding method (`setSpeed` /`getSpeed`
    ). Kotlin promotes *property access syntax* , which is a more expressive way of
    accessing properties. Let''s compare both approaches, assuming we have a simple
    `Car` class that has a single `speed` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, in Kotlin there is no need to add `get` , `set` prefixes and
    parentheses to access or modify an object property. Using property access syntax
    allows for direct usage of increment (++) and decrement (--) operators together
    with property access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Increment and decrement operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two kinds of increment (++ ) and decrement(--) operators: pre-increment/pre-decrement
    where the operator is defined before the expression, and post-increment/post-decrement
    where the operator is defined after the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, using post- versus pre-increment/decrement would change
    nothing because those operations are executed in sequence. But this makes a huge
    difference when the increment/decrement operator is combined with a function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the pre-increment operator, speed is retrieved, incremented, and passed
    to a function as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In post-increment operator speed is retrieved, passed to a function as an argument,
    and then it is incremented, so the old value is passed to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This works in an analogical way for pre-decrement and post-decrement operators.
  prefs: []
  type: TYPE_NORMAL
- en: Property access syntax is not limited only to classes defined in Kotlin. Each
    method that follows the Java conventions for getters and setters is represented
    as a property in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can define a class in Java and access its properties in
    Kotlin using *property access* syntax. Let''s define a Java `Fish` class with
    two properties, `size` and `isHungry` , and let''s instantiate this class in Kotlin
    and access the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This works both ways, so we can define the `Fish` class in Kotlin using very
    concise syntax and access it in a usual Java way, because the Kotlin compiler
    will generate all the required getters and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, syntax used to access the class property depends on the actual
    language that the class uses, not the language that the class was declared in.
    This allows for more idiomatic usage of many classes defined in the Android framework.
    Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Java method access syntax** | **Kotlin property access syntax** |'
  prefs: []
  type: TYPE_TB
- en: '| `activity.getFragmentManager()` | `activity.fragmentManager` |'
  prefs: []
  type: TYPE_TB
- en: '| `view.setVisibility(Visibility.GONE)` | `view.visibility = Visibility.GONE`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `context.getResources().getDisplayMetrics().density` | `context.resources.displayMetrics.density`
    |'
  prefs: []
  type: TYPE_TB
- en: Property access syntax results in more concise code that decreases the original
    Java language complexity. Notice that it is still possible to use method access
    syntax with Kotlin although property access syntax is often the better alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some methods in the Android framework that use the `is` prefix for
    their name; in this cases Boolean properties also have the `is` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin marks overridden members using the `override` modifier, not `@Override`
    annotation like Java.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although using `finishing` would be the most natural and consistent approach,
    it's impossible to use it by default due to potential conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another case where we can''t use the property access syntax is when the property
    defines only setter without getter, because Kotlin does not support write-only
    properties, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Custom getters/setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we want to have more control about property usage. We may want to
    perform other auxiliary operations when using property; for example, verify a
    value before it''s assigned to a field, log the whole operation, or invalidate
    an instance state. We can do it by specifying custom setters and/or getters. Let''s
    add the `ecoRating` property to our `Fruit` class. In most cases, we would add
    this property to the class declaration header like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to define custom getters and setters, we need to define a property
    in the class body instead of the class declaration header. Let''s move the `ecoRating`
    property into the class body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the property is defined inside the body of a class, we have to initialize
    it with value (even nullable properties need to be initialized with a null value).
    We can provide the default value instead of filling a property with the constructor
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compute default values based on some other properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Different values will be set for different weight constructor arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a property is defined in a class body, the type declaration can be omitted,
    because it can be inferred from the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a custom getter and setter with the default behavior that will
    be the equivalent of the preceding property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `get` and `set` block, we can have access to a special variable called
    `field` *,* which refers to the corresponding backing field of the property. Notice
    that the Kotlin property declaration is closely positioned to a custom getter/setter.
    This contradicts with Java and solves the issue where the field declaration is
    usually at the top of the file containing class and corresponding getter/setter
    is at the bottom of this file, so we can't really see them on a single screen
    and thus code is more difficult to read. Apart from that location, Kotlin property
    behavior is quite similar to Java. Each time we retrieve, value from the `ecoRating`
    property, a `get` block will be executed, and each time we assign a new value
    to the `ecoRating` property, a `set` block will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: This is a read-write property (`var` ), so it may contain both corresponding
    getters and setters. In case we explicitly define only one of them, the default
    implementation will be used for another.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a value computed each time when a property value is retrieved, we need
    to explicitly define getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since Kotlin 1.1 type can be omitted (it is to be inferred).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The getter versus property default value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we used getter, so the property value is calculated
    each time the value is retrieved. By omitting getter we can create a default value
    for the property. This value will be computed only once during class creation
    and it will never change (changing the `weight` property will have no effect on
    the `isHeavy` property value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of property does have a backing field, because its value is always
    computed during object creation. We can also create read-write properties without
    a backing field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This type of property does not have a backing field, because its value is always
    computed using another property.
  prefs: []
  type: TYPE_NORMAL
- en: Late-initialized properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we know that a property won''t be null, but it won''t be initialized
    with the value at declaration time. Let''s look at common Android examples--retrieving
    reference to a layout element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `button` variable can't be initialized at declaration time, because the
    `MainActivity` layout is not yet initialized. We can retrieve reference to the
    button defined in the layout inside the `onCreate` method, but to do it we need
    to declare a variable as nullable (`Button?` ).
  prefs: []
  type: TYPE_NORMAL
- en: Such an approach seems quite impractical, because after the `onCreate` method
    is called a `button` instance is available all the time. However, the client still
    needs to use the safe call operator or other nullity checks to access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid nullity checks when accessing a property, we need a way to inform
    the Kotlin compiler that this variable will be filled before usage, but its initialization
    will be delayed in time. To do this, we can use the `lateinit` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, with the property marked as `lateinit` *,* we can access our application
    instance without performing nullity checks.
  prefs: []
  type: TYPE_NORMAL
- en: The `lateinit` modifier tells the compiler that this property is non-nullable,
    but its initialization is delayed in time. Naturally, when we try to access the
    property before it is initialized, the application will throw `UninitializedPropertyAccessException`
    . This is fine, because we assume that this scenario should not happen.
  prefs: []
  type: TYPE_NORMAL
- en: A scenario where a variable initialization is not possible at declaration time
    is quite common and it is not always related to views. Properties can be initialized
    through Dependency Injection, or via the `setup` method of a unit test. In such
    scenarios, we cannot supply a non-nullable value in the constructor, but we still
    want to avoid nullity checks.
  prefs: []
  type: TYPE_NORMAL
- en: '**The lateinit property and frameworks**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lateinit` property is also helpful when a property is injected by the
    Dependency Injection framework. The popular Android Dependency Injection framework,
    **Dagger** , uses the `@Inject` annotation to mark properties that need to be
    injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Inject lateinit var locationManager: LocationManager`'
  prefs: []
  type: TYPE_NORMAL
- en: We know that the property will never be null (because it will be injected),
    but the Kotlin compiler does not understand this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar scenarios happen with the popular framework, **Mockito** *:* `@Mock
    lateinit var mockEventBus: EventBus`'
  prefs: []
  type: TYPE_NORMAL
- en: The variable will be mocked, but it will happen sometime later, after test class
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin generates multiple JVM bytecode elements from a single property (`private`
    field, getter, setter). Sometimes the framework annotation processor or the reflection-based
    library requires a particular element to be defined as a public field. A good
    example of such behavior is the JUnit test framework. It requires rules to be
    provided through a test class field or a getter method. We may encounter this
    problem when defining `ActivityTestRule` or Mockito''s (mocking framework for
    unit tests) `Rule` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code annotates the Kotlin property that JUnit won''t recognize,
    so `ActivityTestRule` can''t be properly initialized. The JUnit annotation processor
    expects the `Rule` annotation on the field or getter. There are a few ways to
    solve this problem. We can expose the Kotlin property as a Java field by annotating
    it with the `@JvmField` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The field will have the same visibility as the underlying property. There are
    a few limitations regarding `@JvmField` annotation usage. We can annotate a property
    with `@JvmField` if it has a backing field, it is not private, does not have open,
    override, or const modifiers, and is not a delegated property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also annotate getter by adding an annotation directly to getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t want to define getter, we can still add an annotation to getter
    using the use-site target (`get` ). By doing so, we simply specify which element
    generated by the Kotlin compiler will be annotated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Inline properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can optimize property calls by using the `inline` modifier. During compilation
    each property call will be optimized. Instead of really calling a property, the
    call will be replaced with the property body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With inline property, we are using the `inline` modifier. The preceding code
    will be compiled to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Inlining improves performance, because there is no need to create additional
    objects. No getter will be invoked, because the body would replace the property
    usage. Inlining has one limitation--it can be only applied to properties that
    do not have a backing field.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin allows us to define classes without any constructors. We can also define
    a primary constructor and one or more secondary constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring properties is not allowed for secondary constructors. If we need
    a property that is initialized by secondary constructors, we must declare it in
    the class body, and we can initialize it in the secondary constructor body. Let''s
    define the `fresh` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we defined our `fresh` property as nullable, because when an instance
    of the object will be created using a primary constructor the `fresh` property
    will be null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also assign the default value to the `fresh` property to make it non-nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When a primary constructor is defined, every secondary constructor must call
    the primary constructor implicitly or explicitly. An implicit call means that
    we call the primary constructor directly. An explicit call means that we call
    another secondary constructor that calls primary constructor. To call another
    constructor, we use the `this` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Call to primary constructor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call to secondary constructor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the class has no primary constructor and the super class has a non-empty
    constructor, then each secondary constructor has to initialize the base class
    using the `super` keyword or call another constructor that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: A view example can be greatly simplified by using the `@JvmOverloads` annotation
    that will be described in the `@JvmOverloads` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, this generated constructor will be public. If we want to prevent
    the generation of such an implicit `public` constructor, we have to declare an
    empty primary constructor with a `private` or `protected` visibility modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the constructor visibility, we need to explicitly use the `constructor`
    keyword in the class definition header. The `constructor` keyword is also required
    when we want to annotate a constructor. A common example is to annotate a class
    constructor using the Dagger (Dependency Injection framework) `@Inject` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the visibility modifier and annotation can be applied at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Property versus constructor parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The important thing to notice is the fact that if we remove the `var` /`val`
    keyword from constructor property declaration, we''ll end up with a constructor
    parameter declaration. This means that the property will be changed into constructor
    parameter, so no accessors will be generated and we will not be able to access
    the property on the class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have an error because `fresh` is missing a `val`
    or `var` keyword, so it is a constructor parameter, not a class property such
    as `weight` . The following table summarizes the compiler accessor generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class declaration** | **Getter generated** | **Setter generated** | **Type**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `class Fruit (name:String)` | No | No | Constructor parameter |'
  prefs: []
  type: TYPE_TB
- en: '| `class Fruit (val name:String)` | Yes | No | Property |'
  prefs: []
  type: TYPE_TB
- en: '| `class Fruit (var name:String)` | Yes | Yes | Property |'
  prefs: []
  type: TYPE_TB
- en: 'Sometimes we may wonder when we should use a property and when we should use
    a method. A good guideline to follow is to use property instead of method when:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not throw an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is cheap to calculate (or cached on the first run)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns the same result over multiple invocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor with default arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the early days of Java, there was a serious flaw with object creation.
    It is difficult to create an object instance when an object requires multiple
    parameters and some of those parameters are optional. There are a few ways to
    solve this problem, such as, the Telescoping constructor pattern, the JavaBeans
    pattern, and even the Builder pattern. Each of them have their pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The patterns solve the issue of object creation. Each of them is explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Telescoping constructor pattern** : Class with a list of constructors where
    each one adds a new parameter. Now a days it''s considered an anti-pattern, but
    Android framework still uses it in a few places; for example, the `android.view.View`
    class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**JavaBeans pattern** : Parameterless constructor plus one or more setters
    methods to configure objects. The main problem with this pattern is that we can''t
    say whether or not all the required methods have been called on an object, so
    it may be only partially constructed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**Builder pattern** : Uses another object, a builder, that receives initialization
    arguments step by step and then returns the resulting constructed object at once
    when the build method is called; for example, `android.app.Notification.Builder`
    , or `android.app.AlertDialog.Builder` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For a long time, `builder` was most widely used, but a combination of *default
    arguments* and *named argument syntax* is an even more concise option. Let''s
    define some default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'By defining default parameter values, we can create objects in multiple ways,
    without a need to pass all arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Using arguments syntax with default parameters gives us much more flexibility
    in objects creation. We can pass only required parameters in any order that we
    want without defining multiple methods and constructors, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already know, a supertype of all Kotlin types is `Any` . It is the equivalent
    of the Java `Object` type. Each Kotlin class explicitly or implicitly extends
    the `Any` class. If we do not specify the parent class, the `Any` will be used
    implicitly set as parent for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin, like Java, promotes single inheritance, so a class can have only one
    parent class, but it can implement multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to Java, every class and every method in Kotlin is final by default.
    This plays along with the *Effective Java Item 17: Design and document for inheritance
    or else prohibit it* rule. This is used to prevent unexpected behavior from a
    subclass altering. Modification of a base class can cause the incorrect behavior
    of subclasses, because the changed code of the base class no longer matches the
    assumptions in its subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that a class cannot be extended and a method cannot be overridden
    until it's explicitly declared as open using the `open` keyword. This is the exact
    opposite of the Java `final` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want to declare a base class `Plant` and subclass `Tree` *:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will not compile, because the class `Plant` is final by
    default. Let''s make it `open` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we define inheritance in Kotlin simply by using the colon character
    (:). There is no `extends` or `implements` keywords known from Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add some methods and properties to our `Plant` class, and try to
    override it in the `Tree` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will also not compile. We have said already that all methods are
    also closed by default, so each method we want to override must be explicitly
    marked as `open` . Let''s fix the code by marking the `grow` method as open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, we could open and override the `height` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: To quickly override any member, go to a class where a member is declared, add
    the `open` modifier, and then go to a class where we want to override member,
    run the `override` members (the shortcut for Windows is *Ctrl* + *O* , and for
    macOS, it is *Command* + *O* ) action, and select all the members you want to
    override. This way all the required code will be generated by Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that all trees grow in the same way (the same computation of
    growing algorithm is applicable for all trees). We want to allow creating new
    subclasses of the `Tree` class to have more control over trees, but at the same
    time we want to preserve our growing algorithm--not allowing any subclasses of
    the `Tree` class to override this behavior. To achieve this, we need to explicitly
    mark the `grow` method in the `Tree` class as `final` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It's not possible to override grow method here because it's `final`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's sum up all this `open` and final behavior. To make a method overridable
    in a subclass, we needed to explicitly mark it as open in the superclass. To make
    sure that overridden method will not be overridden again by any subclass, we need
    to mark it as `final` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the grow method in the `Plant` class does not really
    provide any functionality (it has an empty body). This is a sign that maybe we
    don''t want to instantiate the `Plant` class at all, but treat it as a base class
    and only instantiate various classes such as `Tree` that extends the `Plant` class.
    We should mark the `Plant` class as `abstract` to disallow its instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Marking the class as abstract will also make the method class open by default,
    so we don't have to explicitly mark each member as `open` . Notice that when we
    are defining the `grow` method as abstract, we have to remove its body, because
    the `abstract` method can't have a body.
  prefs: []
  type: TYPE_NORMAL
- en: The JvmOverloads annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some classes in the Android platform use Telescoping constructors, which is
    considered as an anti-pattern. A good example of such a class is the `android.view.View
    class` . There may be a case when only a single constructor is used (inflating
    the custom view from Kotlin code), but it is much safer to override all three
    constructors when the subclassing subclass `android.view.View` , because the class
    will work correctly in all scenarios. Normally our custom view class would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This case introduces a lot of boilerplate code just for constructors that delegate
    calls to other constructors. Kotlin''s solution to this problem is to use the
    `@JvmOverload` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Annotating a constructor with the `@JvmOverload` annotation informs the compiler
    to generate in JVM bytecode additional constructor overload for every parameter
    with a default value. In this case, all the required constructors will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin interfaces are similar to Java 8 interfaces and in contrast to interfaces
    from previous Java versions. An interface is defined using the `interface` keyword.
    Let''s define an `EmailProvider` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the preceding interface in Kotlin, use the same syntax as for
    extending classes--a single colon character (`:` ). There is no `implements` keyword
    like in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The question may arise of how to extend a class and implement an interface
    at the same time. Simply place the class name after the colon, and use comma character
    to add one or more interfaces. It''s not required to place the super class at
    the first position although it''s considered good practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'As with Java, the Kotlin class can extend only one class, but it can implement
    one or more interfaces. We can also declare properties in the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'All methods and properties have to be overridden in a class implementing interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, properties defined in a primary constructor can be used to override parameters
    from an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: All methods and properties defined in an interface that does not have default
    implementation are treated by default as abstract, so we don't have to explicitly
    define them as abstract. All abstract methods and properties must be implemented
    (overridden) by a concrete (non-abstract) class that implements an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, another way to define methods and properties in the interface.
    Kotlin, similar to Java 8, introduces major improvement to interfaces. An interface
    cannot only define behavior, but also implements it. This means that the default
    method of property implementation can be provided by an interface. The only limitation
    is that an interface cannot reference any backing fields--store a state (because
    there is no good place to store it). This is a differing factor between interface
    and abstract class. Interfaces are stateless (they can''t have a state), while
    abstract classes are stateful (they can have a state). Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EmailProvider` interface provides the default implementation for the `nickname`
    property, so we don''t have to define it in the `User` class, and we can still
    use the property as any other property defined in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies for methods. Simply define a method with the body in the interface,
    so the `User` class will take all default implementation from the interface, and
    will have to override only the `email` member--the only member in the inference
    without default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one interesting case related to default implementations. A class can''t
    inherit from multiple classes, but it can implement multiple interfaces. We can
    have two interfaces containing methods with the same signature and default implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In such cases, conflict must be resolved explicitly by overriding the `foo`
    method in a class implementing the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can still call both default interface implementations by qualifying `super`
    using angle brackets and specifying the parent interface type name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often we create a class whose only purpose is to store data; for example, data
    retrieved from a server or local database. Those classes are building blocks of
    application data models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, we need to generate a lot of redundant getters/setters together with
    `hashCode` and `equals` methods. Android Studio can generate most of the code
    for us, but maintaining this code is still an issue. In Kotlin, we can define
    a special kind of class called the data class by adding the `data` keyword to
    a class declaration header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: A data class adds additional capabilities to a class in the form of methods
    generated by the Kotlin compiler. Those methods are `equals` , `hashCode` , `toString`
    , `copy` , and multiple `componentN` methods. The limitation is that data classes
    can't be marked as *abstract* , *inner,* and *sealed* . Let's discuss methods
    added by a data modifier in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The equals and hashCode method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with data classes, there is often a need to compare two instances
    for structural equality (that they contain the same data, but not necessarily
    are the same instance). We many simply want to check if one instance of the `User`
    class equals another `User` instance or if two product instances represent the
    same product. A common pattern used to check if objects are equal is to use an
    `equals` method that uses the `hashCode` method internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The general contract for overridden implementations of `hashCode` is that two
    equal objects (according to `equals` implementation) need to have the same hash
    code. The reason behind it is that `hashCode` is often compared before `equals`
    , because of its performance--it's much cheaper to compare hash code than every
    field in the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `hashCode` is the same then the `equals` method checks if two objects are
    the same instance, the same type, and then verifies equality by comparing all
    significant fields. If at least one of the fields of the first object is not equal
    to a corresponding field of a second object then the objects are not considered
    as equal. Another way around--two objects are equal when they have the same `hashCode`
    and all significant (compared) fields have the same value. Let''s check an example
    of the Java product class containing two fields, `name` and `price` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This approach is widely used in Java and other OOP programming languages. In
    the early days, programmers had to write this code manually for every class that
    needed to be compared and maintained the code making sure that it was correct
    and it compares every significant value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, modern IDEs such as Android Studio can generate this code and update
    the appropriate methods. We don''t have to write the code, but we still have to
    maintain it by making sure that all the required fields are compared by the `equals`
    method. Sometimes we don''t know if it is a standard code generated by the IDE
    or it is a tweaked version. For each Kotlin data class*,* those methods are automatically
    generated by a compiler, so this problem does not exist. Here is a definition
    of `Product` in Kotlin, which contains all methods defined in the previous Java
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class contains all methods defined in previous Java classes, but
    there is no massive boilerplate code to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](text00035.html) , *Laying a Foundation* , we mentioned that,
    in Kotlin, using the structural equality operator (==) will always call the `equals`
    method under the hood, so it means that we can easily and safely compare instances
    of our `Product` data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `hashCode` and `equals` methods are generated based on every
    property declared in the primary constructor. In most scenarios this is enough,
    but if we need more control we are still allowed to override these methods by
    ourselves in the data class. In this case, the default implementation won't be
    generated by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The toString method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generated methods contain names and values of all properties declared in the
    primary constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We can actually log meaningful data to a console or log file, instead of class
    name and memory address like in Java (`Person@a4d2e77` ). This makes the debugging
    process much simpler, because we have a proper, human readable format.
  prefs: []
  type: TYPE_NORMAL
- en: The copy method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the Kotlin compiler will also generate an appropriate `copy` method
    that will allow us to easily create a copy of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Java does not have named argument syntax, so when calling the `copy` method
    Java code we need to pass all arguments (the order of the arguments corresponds
    to the order of properties defined in the primary constructor). In Kotlin, this
    approach decreases the need for `copy` constructors or `copy` factories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copy` constructor takes a single argument and type is the class containing
    the constructor and returns the `newInstance` of this class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copy` factory is the static factory that takes a single argument whose
    type is the class containing the factory and returns a new instance of this class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copy` method takes arguments that correspond to all properties declared
    in the primary constructor. When combined with the default arguments syntax, we
    can provide all or only some of the properties to create a modified instance copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very flexible way of creating copy of the object where we can easily
    say if, and how, copy should differ from original instances. On the other hand,
    the programming approach promotes concept of immutability, which can be easily
    implemented with an argumentless call of the `copy` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Instead of defining mutable properties (`var` ) and modifying the object state,
    we can define immutable properties (`val` ), make an object immutable, and operate
    on it by getting its copy with the changed values. This approach reduces the need
    of data synchronization in multithreading applications and the number of potential
    errors related with it, because immutable objects can be freely shared across
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: Destructive declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes it makes sense to restructure objects into multiple variables. This
    syntax is called a **destructuring declaration** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'A destructuring declaration allows us to create multiple variables at once.
    The preceding code will result in creating values the `firstName` , `lastName`
    *,* and `height` variables. Under the hood, the compiler will generate code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: For every property declared in the primary constructor of the data class, the
    Kotlin compiler generates a single `componentN` method. The suffix of the component
    function corresponds to the order of properties declared in the primary constructor,
    so the `firstName` corresponds to `component1` , `lastName` corresponds to `component2`
    , and `height` corresponds to `component3` . In fact, we could invoke those methods
    directly on the `Person` class to retrieve a property value, but there is no point
    of doing so, because their names are meaningless and code would be very difficult
    to read and maintain. We should leave those methods for the compiler for destructuring
    the object and use property access syntax such as `person.firstName` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also omit one or more properties using an underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we want only to create two variables, `firstName` and `height`
    ; the `lastName` is ignored. The code generated by the compiler will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also destructure simple types like `String` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructive declarations can also be used together with the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin has a predefined set of operators with fixed symbolic representation
    (`+, *` , and so on) and fixed precedence. Most of the operators are translated
    directly into method calls; some are translated into more complex expressions.
    The following table contains a list of all the operators available in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator token** | **Corresponding method/expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `a + b` | `a.plus(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a - b` | `a.minus(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | `a.times(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a / b` | `a.div(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a % b` | `a.rem(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a..b` | `a.rangeTo(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a += b` | `a.plusAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a -= b` | `a.minusAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a *= b` | `a.timesAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a /= b` | `a.divAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a %= b` | `a.remAssign(b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a++` | `a.inc()` |'
  prefs: []
  type: TYPE_TB
- en: '| `a--` | `a.dec()` |'
  prefs: []
  type: TYPE_TB
- en: '| `a in b` | `b.contains(a)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a !in b` | `!b.contains(a)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i]` | `a.get(i)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i, j]` | `a.get(i, j)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i_1, ..., i_n]` | `a.get(i_1, ..., i_n)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i] = b` | `a.set(i, b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i, j] = b` | `a.set(i, j, b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a[i_1, ..., i_n] = b` | `a.set(i_1, ..., i_n, b)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a()` | `a.invoke()` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(i)` | `a.invoke(i)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(i, j)` | `a.invoke(i, j)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(i_1, ..., i_n)` | `a.invoke(i_1, ..., i_n)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a == b` | `a?.equals(b) ?: (b === null)` |'
  prefs: []
  type: TYPE_TB
- en: '| `a != b` | `!(a?.equals(b) ?: (b === null))` |'
  prefs: []
  type: TYPE_TB
- en: '| `a > b` | `a.compareTo(b) > 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `a < b` | `a.compareTo(b) < 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `a >= b` | `a.compareTo(b) >= 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `a <= b` | `a.compareTo(b) <= 0` |'
  prefs: []
  type: TYPE_TB
- en: The Kotlin compiler translates tokens that represent specific operations (left
    column) to corresponding methods or expressions that will be invoked (right column).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide custom implementations for each operator by using them in class
    `operator` method corresponding with an `operator` token. Let''s define a simple
    `Point` class containing `x` and `y` properties together with two operators, `plus`
    and `times` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'By defining `plus` and `times` operators, we can perform addition and multiplication
    operations on any `Point` instance. Each time `+` or `*` operations are called,
    Kotlin calls corresponding operator method `plus` or `times` *.* Under the hood,
    the compiler will generate method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we are passing the other `point` instance to the `plus` operator
    method, but this type is not mandatory. Operator method does not actually override
    any method from the super class, so it has no fixed declaration with fixed parameters
    and fixed types. We don''t have to inherit from a particular Kotlin type to be
    able to overload operators. All we need to have is a method with proper signature
    marked as `operator` . The Kotlin compiler will do the rest by the running method
    that corresponds to the operator. In fact, we can define multiple operators with
    the same name and different parameter types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Both operators are working fine, because the Kotlin compiler can select proper
    overload of the operator. Many basic operators have corresponding compound assign
    operator (`plus` has `plusAssign` , times has `timesAssign` , and so on), so when
    we define an operator such as the `+` operator, Kotlin supports the `+` operation
    and `+=` operation as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the important difference that in some scenarios it may be performance
    critical. A compound assign operator (for example, the `+=` operator) has the
    `Unit` return type, so it just modifies the state of the existing object, while
    the basic operator (for example, the `+` operator) always returns a new instance
    of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'When we define both `plus` and `plusAssign` operators with the same parameter
    types, when we try to use the `plusAssign` (compound) operator, the compiler will
    throw an error, because it does not know which method should be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Operator overloading works also for classes defined in Java. All we need is
    a method with the proper signature and name that corresponds to the operator''s
    method name. The Kotlin compiler will translate operator usage to this method.
    Operator modifier is not present in Java, so it''s not required in the Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Object declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few ways to declare singletons in Java. Here is the most common
    way to define the class that has a private constructor and retrieves instances
    via a static factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works fine for a single thread, but it''s not thread safe,
    so in some cases two instances of `Singleton` can be created. There are a few
    ways to fix it. We can use the `synchronized` block presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution, however, is very verbose. In Kotlin, there is a special language
    construct for creating singletons called **object declaration** , so we can achieve
    the same result in a much simpler way. Defining objects is similar to defining
    classes; the only difference is that we use the `object` keyword instead of the
    `class` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add methods and properties to an object declaration exactly the same
    way as in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is accessed the same way as any Java static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Object declarations are initialized lazily and they can be nested inside other
    object declarations or non-inner classes. Also, they cannot be assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Object expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An object expression is equivalent to Java''s anonymous class. It is used to
    instantiate objects that might inherit from some class or implements an interface.
    A classic use-case is when we need to define objects that are implementing some
    interface. This is how in Java we could implement the `ServiceConnection` interface
    and assign it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The closest Kotlin equivalent of the preceding implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is using an object expression, which creates instance
    of anonymous class that implements `ServiceConnection` interface. An object expression
    can also extend classes. Here is how we can create an instance of the abstract
    class `BroadcastReceiver` *:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: While object expressions allow us to create objects of an anonymous type that
    can implement some interface and extend some class, we can use them to easily
    solve interesting problems related to the Adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter design pattern allows otherwise incompatible classes to work together
    by converting the interface of one class into an interface expected by the clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a `Player` interface and function that requires `Player`
    as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we have `VideoPlaye*r*` class from a public library that has the `play`
    method defined, but it is not implementing our `Player` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The `VideoPlayer` class meets all the interface requirements, but it cannot
    be passed as `Player` because it is not implementing the interface. To use it
    as a player, we need to make an Adapter. In this example, we will implement it
    as an object of an anonymous type that implements the `Player` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We were able to solve our problem without defining the `VideoPlayer` subclass.
    We can also define custom methods and properties in the object expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very easy way to define custom anonymous objects that are not present
    in Java. To define similar types in Java, we need to define the custom interface.
    We can now add a behavior to our `VideoPlayer` class to fully implement the `Player`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can call on anonymous object (`player` ) methods defined
    in the `VideoPlayer` class and expression object.
  prefs: []
  type: TYPE_NORMAL
- en: Companion objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin, as opposed to Java, lacks the ability to define static members, but
    instead it allows us to define *objects* that are associated with a class. In
    other words, an object is initialized only once; therefore only one instance of
    an object exists, sharing its state across all instances of a particular class.
    When a singleton object is associated with a class of the same name, it is called
    the **companion object** of the class, and the class is called the **companion
    class** of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram presents three instances of the `Car` class sharing a
    single instance of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Members, such as methods and properties, defined inside a companion object
    may be accessed similarly to the way we access static fields and methods in Java.
    The main purpose of a companion object is to have code that is related to class,
    but not necessary to any particular instance of this class. It is a good way to
    define members that would be defined as static in Java; for example, factory,
    which creates a class instance method converting some units, activity request
    code, shared preferences key, and so on. To define the simplest companion object,
    we need to define a single block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define a `start` method that will allow us to start an activity
    in an easy way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Only single instance of `key` exists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method start can be invoked without creating object instance. Just like Java
    static method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retreive value after instance is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that we are able to call `start` prior to the activity instance creation.
    Let''s use the companion object to track how many instances of the `Car` class
    were created. To achieve this we need to define that `count` property with a private
    setter. It could be also defined as a top-level property, but it is better to
    place it inside a companion object, because we don''t want to allow counter modification
    outside of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The class can access all the methods and properties defined in the companion
    object, but the companion object can''t access any of the class content. The companion
    object is assigned to a specific class, but not to a particular instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: To access an instance of the companion object directly, we can use the class
    name.
  prefs: []
  type: TYPE_NORMAL
- en: We can also access the companion object by using more verbose syntax, `Car.Companion.count`
    , but in most cases there is no point of doing so, unless we want to access `companion`
    from Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Companion object instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A companion object is a singleton created by a companion class and kept in its
    static property. The instantiation of a `companion` object is lazy. This means
    that `companion` object will be instantiated when it is needed for the first time--when
    its members are accessed, or instance of a class containing the `companion` object
    is created. To mark up when the `Car` class instance and its corresponding `companion`
    object are created, we need to add two initializer blocks--one for the `Car` class,
    another for the companion object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initializer block inside the `companion` object works exactly the same
    way as in the class--it''s executed when an instance is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'While the class initialization block is equivalent of the Java constructor
    body, the compilation object initialization block is the equivalent of the Java
    static initialization block in Kotlin. For now, the `count` property can be updated
    by any client, because it''s accessible from outside of the `Car` class. We will
    fix this issue later in this chapter in the `Visibility` modifiers section. Now
    let''s access the `Car` companion object class member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'By accessing the `count` property defined in the companion object, we trigger
    its creation, but notice that an instance of `Car` class is not created. Later
    when we create a `Car` class instance `companion` object is already created. Now
    let''s instantiate the `Car` class before accessing the `companion` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Companion object is created together with first instance of `Car` class, so
    when we create some other instances of the user class, the `companion` object
    for the class already exists, so it's not created.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the preceding instantiation describes two separate examples.
    Both could not be true in a single program, because only a single instance of
    class `companion` object can exist and it is created the first time when it is
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `companion` objects can also contain functions, implement interfaces, and
    even extend classes. We can define a companion object that will include a static
    constriction method with the additional possibility to override implementation
    for testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Provider is a generic class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abstract function used to create instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Field used to keep created instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Field used to in tests, to provide alternative implementation of instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function that is returning override instance if it was set, instance if it was
    created, or it is creating instance using the create method and filling instance
    field with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With such implementation, we can define the interface with a default static
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'To get instance, we need to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to specify some other instance for testing purposes (for example,
    in Espresso tests) then we can always specify them using object expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Companion objects are really popular in the Kotlin Android world. They are mostly
    used to define all elements that were static in Java (constant fields, static
    creators, and so on), but they also provide additional capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Enum classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerated type (`enum` ) is a data type consisting of a set of named values.
    To define an enum type, we need to add the `enum` keyword to the class declaration
    header*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse string into `enum` , use the `valueOf` method (like in Java):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the Kotlin helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'To display all values in the `Color` enum, use values function (like in Java):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the Kotlin `enumerateValues` helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enum` type can also have its constructor and there can be custom data
    associated to each `enum` constant. Let''s add properties with values of `red`
    , `green` *,* and `blue` color components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Having these values, we can define a function that will calculate RGB value
    for each color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the last constant (`VIOLET` ) is followed by a semicolon. This
    is a rare situation where a semicolon is actually required in Kotlin code. It
    separates the constant definitions from the member definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rgb()` method accesses the `r` , `g` , and `b` variable data for a particular
    enum and calculates the value for each `enum` element separately. We can also
    add a validation for the enum constructor arguments using the `init` block and
    the Kotlin standard library `require` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining an incorrect enum will result in an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'There are cases where we want to associate fundamentally different behavior
    with each constant. To do this we can define an abstract method or property and
    override it in each enum block. Let''s define the enum `Temperature` and `temperature`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Now, each color contains not only RGB information, but also an additional enum
    describing its temperature. We have added a property, but in an analogical way
    we could add custom methods to each enum element.
  prefs: []
  type: TYPE_NORMAL
- en: Infix calls for named methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Infix calls are one of Kotlin''s features that allow us to create more fluid
    and readable code. It allows us to write code that is closer to natural human
    language. We have already seen usage of the infix method in [Chapter 2](text00035.html)
    *, Laying a Foundation,* which allowed us to easily create an instance of a `Pair`
    class. Here is a quick reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Pair` class represents a generic pair of two values. There is no meaning
    attached to values in this class, so it can be used for any purpose. `Pair` is
    a data class, so it contains all data class methods (`equals` , `hashCode` , `component1`
    , and so on). Here is a definition of the `Pair` class from the Kotlin standard
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Meaning of this `out` modifier used behind a generic type will be described
    in [Chapter 6](text00153.html) , Generic are your friends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pairs have a custom `toString` method. This is implemented to make printed syntax
    more readable while first and second names are not meaningful in most usage contexts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we dive deeper and learn how to define our own infix method, let''s
    translate just the presented code into a more familiar form. Each infix method
    can be used like any other method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'In its essence, the infix notation is simply the ability to call a method without
    using the dot operator and call operator (parentheses). The infix notation only
    looks different, but it''s still a regular method call underneath. In both foregoing
    examples, we simply call the *to* method on the `String` class instance. *to*
    is an extension function and it will be explained in [Chapter 7](text00171.html)
    , *Extension Functions and Properties* , but we can imagine as if it is a method
    of the `String` class, in this case, which is just returning an instance of `Pair`
    containing itself and the passed argument. We can operate on the returned `Pair`
    like on any data class object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, this method is allowed to be infix only when it has a single parameter.
    Also, an infix notation does not happen automatically--we need to explicitly mark
    the method as infix. Let''s define our `Point` class with the infix method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are creating a new `Point` instance, but we could also modify
    an existing one (if the type was mutable). This decision is for the developer
    to make, but infix is more often used together with immutable types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `infix` methods combined with enums to achieve very fluent syntax.
    Let''s implement natural syntax that will allow us to define cards from a classic
    playing card deck. It includes 52:13 ranks of each of the four suits: clubs, diamonds,
    hearts, and spades.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source for the preceding image: [https://mathematica.stackexchange.com/questions/16108/standard-deck-of-52-playing-cards-in-curated-data](https://mathematica.stackexchange.com/questions/16108/standard-deck-of-52-playing-cards-in-curated-data)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to define the syntax that will allow us to define a card from its
    suit and rank it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we need two enums to represent all the ranks and suits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need a class that will represent a card composed of a particular rank
    and particular suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can instantiate a `Card` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the syntax, we introduce a new infix method into the `Rank` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to create a `Card` call like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the method is marked as infix, we can remove the dot call operator
    and parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Usage of static imports will allow us to shorten the syntax even more and achieve
    our final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Besides being super simple, this code is also 100% type-safe. We can only define
    cards using predefined enums of `Rank` and `Suit` , so we are unable to define
    some fictional card by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin supports four types of visibility modifiers (access modifiers)--`private`
    , `protected` , `public` , and `internal` . Kotlin does not support package-`private`
    Java modifiers. The main difference is that the default visibility modifier in
    Kotlin is `public` , and it''s not required to specify it explicitly, so it can
    be omitted for a particular declaration. All of the modifiers can be applied to
    various elements divided into two main groups based on their declaration site:
    top-level elements and nested members.'
  prefs: []
  type: TYPE_NORMAL
- en: A quick reminder from [Chapter 3](text00073.html) , *Playing with Functions*
    , top level elements are elements declared directly inside the Kotlin file, as
    opposed to elements nested inside a class, object, interface, or function. In
    Java, we could declare only classes and interfaces at the top level, while Kotlin
    also allows functions, objects, properties, and extensions there.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we have top-level elements visibility modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` (default): Element is visible everywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private` : Element is visible inside the file containing the declaration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected` : Not available at top level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal` : Element is visible everywhere in the same module. It is public
    for elements in the same module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is a module in Java and Kotlin?**'
  prefs: []
  type: TYPE_NORMAL
- en: A module is just a set of Kotlin files compiled together; for example, IntelliJ
    IDEA module, Gradle project. The modular structure of applications allows for
    better distributed responsibilities and speeds up build time, because only changed
    modules are recompiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '`version` property is public, so it is accessible in all files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UnitConveter` is accessible in the branch.kt file, while it is in the same
    module, but not in `main.kt` because it is located in another module.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `printSomething` function is accessible only in the same file where it is
    defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the package in Kotlin is not giving any extra visibility privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second group consists of members--elements, declared inside a top level
    element. Mainly those will be methods, properties, constructors, sometimes objects,
    companion objects, getters and setters, and occasionally nested classes and nested
    interfaces. Here are the obligatory rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` (default): Client who sees the declaring class sees its public members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private` : Element is visible only inside the class or interface containing
    the member.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected` : Visible inside the class containing the declaration and subclasses.
    It is not applicable inside an object, because an object cannot be opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`internal` : Any client inside this module who sees the declaring class sees
    its internal members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define a top level element. In this example, we will define class, but
    the same logic is applied to any top level element that has nested members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create an instance of the `Person` class, we can access only the `name`
    property marked with a public modifier and the `learn` method marked with `internal`
    modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '`client` who can access the `Person` instance, can also access the `name` property.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`speak` method is accessible only inside the `Person` class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`age` property is accessible inside the `Person` class and its subclasses.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`client` inside the module that can access the `Person` class instance can
    also access its `public` members.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inheritance accessibility is similar to external access accessibility, but
    the main difference is that the member marked with the `protected` modifier is
    also visible inside the subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: In the `Student` subclass we can access members marked with public, protected,
    and internal, but not members marked with private modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Internal modifier and Java bytecode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is pretty obvious how `public` , `private` , and `protected` modifiers are
    compiled to Java while they have direct analogs. But there is a problem with the
    internal modifier because it has no direct analog in Java so there is also no
    support on Java bytecode. This is why the internal modifier is actually compiled
    to the `public` modifier, and to communicate that it shouldn''t be used in Java,
    its name is mashed (changed so that it is not usable anymore). For example, when
    we have the `Foo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be possible to use it from Java this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: It is pretty controversial that internal visibility is guarded by Kotlin and
    it can be bypassed using a Java adapter, but there is no other possibility to
    implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides defining visibility modifiers in a class, we are also able to override
    them while overriding a member. This gives us the ability to weaken access restrictions
    in the inheritance hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Error speak method is not accessible because it's protected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visibility of the speak method was changed to public so we can access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Defining modifiers for members and their visibility scope is quite straightforward,
    so let''s see how to define class and constructor visibility. As we know, primary
    constructor definition is in the class header, so two visibility modifiers are
    required in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the preceding class is defined at the top level, it will be visible
    inside the module, but it can be only instantiated from within the file containing
    the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Getter and setters by default have the same visibility modifier as the property,
    but we can modify it. Kotlin allows us to place a visibility modifier before the
    `get` /`set` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have changed the getter visibility. Notice that
    this approach allows us to change the visibility modifier without changing its
    default implementation (generated by the compiler). Now, our instance counter
    is safe, because it's read-only external clients, but we can still modify the
    property value from inside the `Car` class.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A sealed class is a class with limited number of subclasses (sealed subtyping
    hierarchy). Prior to Kotlin 1.1, those subclasses had to be defined inside a sealed
    class body. Kotlin 1.1 weakened this restriction and allowed us to define sealed
    class subclasses in the same file as a sealed class declaration. All the classes
    are declared close to each other, so we can easily see all possible subclasses
    by simply looking at one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: To mark a class as sealed, simply add a `sealed` modifier to the class declaration
    header. The preceding declaration means that the `Vehicle` class can be only extended
    by three classes `Car` , `Truck` , and `Bus` because they are declared inside
    the same file. We could add a fourth class in our `vehicle.kt` file, but it would
    not be possible to define such a class in another file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sealed` subtyping restriction applies only to direct inheritors of the
    `Vehicle` class. This means that `Vehicle` can be extended only by classes defined
    in the same file (`Car` , `Truck` , or `Bus` ), but assuming that `Car` , `Truck`
    , or `Bus` classes would be open then they can be extended by a class declared
    inside any file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent this behavior, we would need to also mark `Car` , `Truck` , or `Bus`
    classes as sealed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The sealed classes work really well with the `when` expression. There is no
    need for an `else` clause, because a compiler can verify that each subclass of
    a sealed class has a corresponding clause inside the `when` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '*W* e can safely add a new subclass to the `Vehicle` class, because if somewhere
    in the application the corresponding clause of the `when` expression is missing,
    the application will not compile. This fixes problems with the Java `switch` statement,
    where programmers often forget to add proper capsules, which leads to program
    crashes at runtime or undetected bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed classes are abstract by default, so a abstract modifier is redundant.
    Sealed classes can never be `open` or `final` . We can also substitute a subclass
    with objects in case we need to make sure that only a single instance exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding declaration not only protects the inheritance hierarchy, but
    also limits CEO to a single instance. There are a few interesting applications
    for sealed classes that exceed the scope of this book, but it''s good to be aware
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Define data types such as a linked list or binary tree ([https://en.wikipedia.org/wiki/Algebraic_data_type](https://en.wikipedia.org/wiki/Algebraic_data_type)
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect inheritance hierarchy when building an application module or library
    by disallowing clients to extend our class and still keep the ability to extend
    it by ourselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State machine where some states contain data that makes no sense in other states
    ([https://en.wikipedia.org/wiki/Finite-state_machine](https://en.wikipedia.org/wiki/Finite-state_machine)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of possible tokens types for lexical analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A nested class is a class defined inside another class. Nesting small classes
    within top-level classes places the code closer to where it is used, and allows
    a better way of grouping classes. Typical examples are `Tree` /`Leaf` listeners
    or presenter states. Kotlin similar to Java allows us to define a *nested class*
    and there are two main ways to do so. We can define class as a member inside a
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example allows us to create an instance of a `Nested` class without
    creating instances of an `Outer` class. In this case, a class cannot refer directly
    to instance variables or methods defined in its enclosing class (it can use them
    only through an object reference). This is equivalent of a Java static nested
    class and in general static members.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to access members of an outer class, we must create a second kind
    of class by marking a nested class as `inner` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to instantiate the `inner` class we must first instantiate the `Outer`
    class. In this case, the `Inner` class can access all the methods and properties
    defined in the outer class and share state with outer class. Only a single instance
    of Inner class can exist per instance of the `Outer` class. Let''s sum up the
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Behavior** | **Class (member)** | **Inner class (member)** |'
  prefs: []
  type: TYPE_TB
- en: '| Behave as a Java static member | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Instance of this class can exist without an instance of enclosing class |
    Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Has Reference to outer class | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Share state with outer class (can access outer class members) | No | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| Number of instances | Unlimited | One per outer class instance |'
  prefs: []
  type: TYPE_TB
- en: When deciding whether we should define `inner` class or top-level class we should
    think about potential class usage. If the class is only useful for a single class
    instance we should declare it as *inner* . If an *inner* class at some point would
    be useful in another context than serving its *outer class,* then we should declare
    it as a top-level class.
  prefs: []
  type: TYPE_NORMAL
- en: Import aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alias is a way to introduce new names for types. If the type name is already
    used in the file, is inappropriate, or too long, you can introduce a different
    name and use it instead of the original type name. Alias does not introduce a
    new type and it is available only before compile time (when writing code). The
    compiler replaces a class alias with an actual class, so it does not exist at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we need to use a few classes with the same name in a single file.
    For example, InterstitialAd type is defined both in the Facebook and Google advertising
    libraries. Let''s suppose that we want to use them both in a single file. This
    situation is common in projects where we need both ad providers implemented to
    allow for a profit comparison between them. The problem is that using both data
    types in a single file would mean that we need to access one or both of them by
    a fully qualified class name (namespace + class name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '**Qualified versus unqualified class name**'
  prefs: []
  type: TYPE_NORMAL
- en: The unqualified class name is simply the name of the class; for example, `Box`
    . A qualified class name is a namespace combined with a class name; for example,
    `com.test.Box` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In these situations, people often say that the best fix is to rename one of
    the classes, but sometimes this may not be possible (the class is defined in an
    external library) or desirable (class name is consistent with backend database
    table). In this situation, where both the classes are located in an external library,
    the solution for class naming conflict is to use an `import` alias. We can use
    it to rename Google `InterstitialAd` to `GoogleAd` , and Facebook `InterstitialAd`
    to `FbAd` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can use these aliases around the file as if they were actual types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Using the `import` alias, we can explicitly redefine names of a class that are
    imported into a file. In this situation, we didn't have to use two aliases, but
    this serves to improve readability--it's better to have `FbAd` and `GoogleAd`
    than `InterstitialAd` and `GoogleAd` . We don't have to use fully qualified class
    names any more, because we simply said to the compiler "each time when you encounter
    `GoogleAd` alias translate it to `com.google.android.gms.ads.InterstitialAd` during
    compilation and each time when you encounter `FbAdalias` translate it to `com.facebook.ads.InterstitialAd`
    . Import alias works only inside a file where alias is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed constructs, which are buildings blocks for
    object-oriented programming. We've learned how to define interfaces and various
    classes and the difference between `inner` , `sealed` , `enum` , and data classes.
    We learned that all elements are public by default and all classes/interfaces
    are `final` *(* by default*)* , so we need to explicitly open them to allow inheritance
    and members overriding.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how to define proper data models using very concise data classes
    combined with even more powerful properties. We know how to properly operate on
    data using various methods generated by the compiler and how to overload operators.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create singletons by using object declarations and how to
    define objects of an anonymous type that may extend some class and/or implement
    some interface using object expressions. We also presented usage of the `lateinit`
    modifier that allows us to define non-nullable data types with initialization
    delayed in time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the more functional side of Kotlin by looking
    into concepts related to **functional programming** (**FP** ). We will discuss
    functional types, lambdas, and higher-order functions.
  prefs: []
  type: TYPE_NORMAL
