- en: A React App with MobX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with React is fun. Now, couple that with MobX for all your state management
    needs, and you have a supercharged combination. With the basics of MobX out of
    the way, we can now venture into building a simple React app using the ideas discussed
    so far. We will tackle the process of defining an observable state, the actions
    that can be invoked on that state, and the React UI that will observe and render
    the changing state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The book search use-case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the observable state and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Reactive UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter03](https://github.com/PacktPublishing/MobX-Quick-Start-Guide/tree/master/src/Chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2v0HnkW](http://bit.ly/2v0HnkW)'
  prefs: []
  type: TYPE_NORMAL
- en: The book search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use-case for our simple React app is one from traditional e-commerce applications,
    that is, searching for a product in a giant inventory. In our case, the search
    is for books. We will use the *Goodreads* API to search for a book by title or
    author. Goodreads requires us to register an account to use their API.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Goodreads account by visiting this URL: [https://www.goodreads.com/api/keys](https://www.goodreads.com/api/keys). You
    can use your Amazon or Facebook account to log in. Once you have the account,
    you need to generate an API key to make the API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Goodreads exposes a set of endpoints that give back the results in XML. Agreed,
    it's not ideal, but they have an extensive collection of books and it's a small
    price to pay to convert XML into a JSON object. In fact, we will use an `npm`
    package for this conversion. The endpoint we will be using is search-books ([https://www.goodreads.com/search/index.xml?key=API_KEY&q=SEARCH_TERM](https://www.goodreads.com/search/index.xml?key=API_KEY&q=SEARCH_TERM)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI for our app will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Even in this fairly simple-looking interface, there are some non-trivial use-cases.
    Since we are making a network call to fetch the results, we have an intermediate
    state of *waiting-for-results* before we show the *list-of-results*. Also, the
    real world is harsh and your network call could fail or return zero results. All
    these states will be handled in our React UI with the help of MobX.
  prefs: []
  type: TYPE_NORMAL
- en: Observable state and actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UI is just a grandiose transformation of data. It is also an observer of
    this data and fires actions to change it. Since data (aka state) is so central
    to a UI, it makes sense we start first by modeling this state. With MobX, observables
    represent that state. Looking back at the UI design from before, we can identify
    various parts of the observable state:'
  prefs: []
  type: TYPE_NORMAL
- en: There is the search-text that the user types. This is an `observable` field
    of type string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an observable array of results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is meta information about the results, such as the current subset and
    the total result count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is some state to capture the `async search()` operation that we will be
    invoking. The initial `status` of the operation is `empty`. Once the user invokes
    the search, we are in the `pending` state. When the search completes, we could
    either be in the `completed` or `failed` state. This looks more like an enumeration
    of `<empty>`*,* `pending`, `completed`, or `failed`, and can be captured with
    an `observable` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since all of these state properties are related, we could put them under one
    observable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is certainly a good start and seems to capture most of what we need to
    show on the UI. Besides the state, we also need to identify the operations that
    can be performed on the UI. For our simple UI, this includes invoking the search
    and updating the term as the user types characters into the text box. Operations
    in MobX are modeled as actions, which internally mutate the observable state.
    We can add these as *actions* on the `searchState` observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `searchState` observable is slowly growing in size and also accumulating
    some syntactic-noise in defining the observable state. As we add more observable
    fields, computed properties and actions, this can definitely become more unwieldy.
    A better way to model this is to use classes and decorators.
  prefs: []
  type: TYPE_NORMAL
- en: There is a little caveat with the way we have defined the actions for the `searchState`
    observable. Note that we have deliberately avoided the use of arrow-functions
    to define the action. This is because arrow-functions capture the **lexical this**
    at the time the action is defined. However, the `observable()` API returns a new
    object, which is of course different from the **lexical this** that is captured
    in the `action()` call. This means, the `this` that you are mutating would not
    be the object that is returned from `observable()`. You can try this out by passing
    arrow-functions into the `action()` calls.
  prefs: []
  type: TYPE_NORMAL
- en: By passing a plain-function into the `action()`, we can be assured that `this`
    would point to the correct instance of the observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this looks with classes and decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of decorators makes it easy to see the observable fields of the class.
    In fact, we have the flexibility to mix and match observable fields with regular
    fields. Decorators also make it easy to tweak the level of observability (for
    example: a `shallow` observable for the results). The `BookSearchStore` class
    captures the observable fields and actions with the help of decorators. Since
    we only need one instance of this class, we are exporting the singleton-instance
    as `store`.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the async action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Things are more interesting with the `async search()` action. Our UI needs
    to know the exact state of the operation at any point in time. For that, we have
    the observable field: `status`, that keeps track of the operation state. It starts
    with the `empty` state initially and goes to `pending` at the beginning of the
    operation. Once the operation completes, it can either be in the `completed` or
    `failed` state. You can see this in the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things stand out in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`async` actions are not very different from `sync` actions. In fact, an *async-action
    is just sync-actions at different points in time*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the observable state is just a matter of assignment. We wrap the code
    after `await` in a `runInAction()` to ensure all observables are mutated inside
    an action. This becomes key when we turn on the `enforceActions` configuration
    for MobX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we are using `async-await`, we are handling the two future possibilities
    in one place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `searchBooks()` function is just a service-method that makes the call to
    the Goodreads API and fetches the results. It returns a promise, which we `await`
    inside the `async` action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we have the observable state of our app ready, along with the
    set of actions that can be performed on these observables. The UI that we will
    create is simply going to paint this observable state and expose controls to invoke
    the actions. Let's jump straight into the observer-land of UI.
  prefs: []
  type: TYPE_NORMAL
- en: One observation you can make in the `async search()` method just seen is the
    wrapping of the state mutation in `runInAction()`. This can get tedious if you
    have multiple `await` calls with state mutation in between those calls. Diligently
    wrapping each of those state-mutations can be cumbersome and you may even forget
    to wrap!
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this unwieldy ceremony, you could use a utility function called `flow()`,
    which takes in a `generator` function and, instead of `await`, uses the `yield`
    operator. The `flow()` utility correctly wraps the state-mutations following a
    `yield` within `action()`, so you don't have to do it yourself. We will use this
    approach in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the core-triad of MobX, reactions play the role of affecting the outside
    world. In [Chapter 2](part0035.html#11C3M0-58c2559ca4304cecab9bc46f496bc070),
    *Observables, Actions, and Reactions*, we have seen a few of these reactions in
    the form of `autorun()`, `reaction()`, and `when()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `observer()` is yet another kind of reaction that helps in binding the React
    world to MobX. `observer()` is part of the `mobx-react` NPM package, a binding
    library for MobX and React. It creates a **higher-order-component** (**HOC**)
    that wraps a React component to automatically update on changes to the observable
    state. Internally, `observer()` keeps track of observables that are dereferenced
    in the `render` method of the component. When any of them change, a re-render
    of the component is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite common to sprinkle `observer()` components throughout the UI component
    tree. Wherever an observable is required to render the component, an `observer()`
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UI that we want to build will map the observable state of the `BookSearchStore` to
    various components. Let''s decompose the UI into its structural components, as
    seen in the following figure. The observer-components here include the **SearchTextField**
    and the **ResultsList**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00020.jpeg)When you start out mapping the observable state to
    React components, you should start with one monolithic component that reads all
    the necessary state and renders it out. Then, you can start splitting the observer-components
    and gradually create the component hierarchy. It is recommended to get as granular
    as you can with your observer-components. This ensures React is not unnecessarily
    rendering the entire component when only a small part of it is changing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the highest level, we have the `App` component that composes the `SearchTextField`
    and `ResultsList`. In code, this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If it has caught your eye already, there is a new decorator on the `App` class
    that we have not seen before: `inject(''store'')`, also part of the `mobx-react`
    package. This creates a HOC that binds the `store` observable to the React component.
    This means that, inside the `render()` of the `App` component, we can expect a
    `store` property to be available on the `props`.'
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `material-ui` NPM package for various UI components. This component
    library gives a material design look to our UI and provides many of the utility
    components, such as `TextField`, `LinearProgress`, `Grid`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `inject()`, you can connect the observable `BookSearchStore` to any of
    your React components. The mystery question, however, is: *How does* `inject()`
    *know about our* `BookSearchStore`*? *This is where you need to see what happens
    at one level above the `App` component, where we render the entire React app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Provider` component from `mobx-react` establishes the real connecting
    glue with the `BookSearchStore` observable. The exported singleton instance of
    `BookSearchStore` (named `store`), is passed as a prop named `store` into `Provider`.
    Internally, it uses the React Context to propagate the `store` to any component
    wrapped by the `inject()` decorator. Thus, the `Provider` provides the `store` observable
    and `inject()` connects to *React Context* (exposed by `Provider`), and injects
    the `store` into the wrapped component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is worth noting that there is nothing special about the named prop `store`.
    You can choose any name you like, and can even pass multiple observable instances
    into `Provider`. If our simple app needed a separate store for *user-preferences*,
    we could have passed it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this means `inject()` will also be referencing this as `userPreferences`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The SearchTextField component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting back to our original example, we can leverage the power of `Provider`
    and `inject()` to get access to `store` (an instance of `BookSearchStore`) at
    any level in the component tree. `SearchTextField` component makes use of it to
    become an observer of the `store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`SearchTextField` observes the `term` property of `store` and updates itself
    when it changes. The change to the `term` is handled as part of the `onChange`
    handler of the `TextField`. The actual `onChange` handler is passed as a prop
    into `SearchTextField` by the `App` component. It is inside the `App` component
    where we fire the `setTerm()` action to update the `store.term` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `SearchTextField` not only handles the updates to the `store.term` observable,
    but also shows the status of the search operation with the `SearchStatus` component.
    We include this component right inside `SearchTextField`, but there are no props
    passed into it. This may seem a little unsettling at first. How in the world is
    `SearchStatus` going to know about the current `store.status`? Well, this should
    be obvious once you look at the definition of `SearchStatus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using `inject()`, we get access to the `store` observable, and by wrapping the
    component with `observer()`, we can react to changes in the observable state (`term`,
    `status`). Notice the use of the nested calls to `inject('store')(observer( ()
    => {} ))`. The order here is important. You first call `inject()` by requesting
    the Provider-prop that you want injected. This returns a function that takes a
    component as input. Here we use `observer()` to create a HOC and pass it to `inject()`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `SearchStatus` component is pretty much self-contained, `SearchTextField`
    can simply include it and expect it to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When the `store.status` changes, only the virtual-DOM for `SearchStatus` changes,
    re-rendering just that component. The rest of `SearchTextField` is left unchanged.
    This rendering efficiency is built into `observer()`, and there is no extra work
    needed on your part. Internally, `observer()` carefully tracks the observables
    that are used in `render()` and sets up a `reaction()` to update the component
    when any of the tracked observables change.
  prefs: []
  type: TYPE_NORMAL
- en: The ResultsList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `SearchTextField`, the search action will be invoked when you type some
    text and hit *Enter*. This changes the observable state, which is partly rendered
    by `SearchTextField`. However, when the results arrive, the list of books that
    match the *search-term* are shown by the `ResultsList` component. As expected,
    it is an *observer*-component, which connects to the `store` observable via `inject()`.
    But this time, it uses a slightly different approach to connect to `store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the `@inject` decorator that takes in a function to extract
    the `store` observable. This gives you a more type-safe approach rather than using
    a string property. You will also see that we renamed `store` to `searchStore` in
    the *extractor-function*. Thus, the `store` observable is injected with the name
    `searchStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the render method for the `ResultsList`, we are doing a few other things
    that are worth calling out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking whether the search results are empty with the `isEmpty` property.
    This wasn''t declared earlier but is really a `computed` property that checks
    the length of the results array and returns `true` if it''s zero:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the search operation has completed and no results were returned (`isEmpty
    = true`), we show the `EmptyResults` component.
  prefs: []
  type: TYPE_NORMAL
- en: If the search completed and we got some results back, we show the counts and
    also a list of results, with each result rendered with the `BookItem` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, our component tree for our app looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **Provider** is literally the provider of the observable state. It relies
    on the React Context to propagate the `store` observable in the component sub-tree.
    By decorating components with `inject()` and`observer()`, you can connect to the
    observable state and react to changes. The **SearchTextField**, **SearchStatus**,
    and **ResultsList** components rely on `observer()` and `inject()` to give you
    a reactive-UI.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of `React.createContext()` in React 16.3+, you can create
    your own `Provider` component if you wish. It might be a little verbose, but it
    achieves the same purpose—propagating the store across the component sub-tree.
    Give it a shot, if you feel a little adventurous.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mobx` and `mobx-react` are two NPM packages that are used extensively to build
    the Reactive UI. The `mobx` package provides the API to build the observable state,
    actions, and reactions. On the other hand, `mobx-react` gives the binding glue
    to connect the React components to the observable state and also react to any
    changes. In our example, we made use of these APIs to build a book search app.
    When creating your *observer-driven* component tree, make sure to go granular
    with the use of observers. This way you will react to just the observables you
    need to render the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: The `SearchTextField`, `SearchStatus`, and `ResultsList` components were created
    with the intent of being granular and reacting to a focused observable surface.
    This is the recommended way to use MobX with React.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will dive deeper into MobX, with an exploration of the
    Observables.
  prefs: []
  type: TYPE_NORMAL
