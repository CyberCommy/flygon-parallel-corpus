- en: Chapter 4. Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point in your journey with Node.js, it is inevitable that you will have
    to debug some nasty bugs. So, let's expect them beforehand and plan for that day.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few methods that we can use to debug our software; the first one
    we are going to look at is logging. The simplest way to log a message is to use
    `console`. In most of the previous examples `console` has been used to portray
    what is going on without needing to see the entire HTTP request and response,
    thus making things a lot more readable and simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example will log requests and responses on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are using a framework that accepts middleware, such as express, we could
    use a simple `npm` package called **morgan**; you can find the package at [https://www.npmjs.com/package/morgan](https://www.npmjs.com/package/morgan):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it by using `require` to bring it into our code and adding it as
    middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is running, we can see each request and response without having
    to add logging to each handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This kind of logging is a simple way to see what is being used on the server
    and how long each request is taking. Here, you can see that the first requests
    took the longest and then they got a lot faster. The difference is only of 3 ms;
    if the time was larger, it could have been a big problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can increase the information that''s logged by changing the format we pass
    to morgan, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By running the server you will see more information, such as the remote user,
    date and time of the request, amount of content that was returned, and the client
    they are using.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Timing is definitely an important factor as it can be helpful when sifting through
    the mountains of logs that you will obtain. Some bugs can be like a ticking time-bomb
    waiting to explode at 3 AM on a Saturday night. All these logs mean nothing to
    us if the process has died and the logs have disappeared. There is another popular
    and useful package called `bunyan,` which wraps many logging methods into one.
  prefs: []
  type: TYPE_NORMAL
- en: Bunyan brings to the table the advantage of writeable streams to write logs,
    whether it is a file on disk or `stdout`. This allows us to persist our logs for
    postmortem debugging. You can find more details about `bunyan` at [https://www.npmjs.com/package/bunyan](https://www.npmjs.com/package/bunyan).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s install the package. We want it installed both locally and globally
    so that we can also use it as a command line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, lets do some logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't look very pretty, does it? Bunyan uses a simple structured JSON
    string to save messages; this makes it easy to parse, extend, and read. Bunyan
    comes with a CLI utility to make everything nice and pretty.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the example with the utility, then we will see that the output is
    nicely formatted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add a few more levels, you will see on your console that each is colored
    differently to help us identify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, trace and debug weren't outputted on the console. This is because
    they are used to follow the flow of the program rather than the key information
    and are usually very noisy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the level of logs we want to see by passing this as an option
    when we create the logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We usually don't want to see logs that are lower than the info level, as any
    information that is useful for post-mortem debugging should have been logged using
    the info or higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bunyan''s api is good for the function of logging errors and objects. It saves
    the correct structures in its JSON output, which is ready for display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the example and pretty-print it, we will see that they save it
    as an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful because, if you just log an error, you will either get an empty
    object if you used `JSON.stringify` or just the message if you used `toString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is to lot simpler and cleaner to use `logger.error( error )` than `logger.error(
    { message: error.message /*, ... */ } );`.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, `bunyan` uses the concept of streams, which means that
    we can write to a file, `stdout`, or any other service we wish to extend to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write to a file, all we need to do is add it to the options passed to `bunyan`
    at setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the example, you won''t see any logs being outputted to the console
    but they will be written to file instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you list what''s in the directory you will see a new file has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you read what''s in the file you will see that the logs have already been
    written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run this through `bunyan` in order to print it out nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can log to a file, we also want to be able to see the messages
    as they are displayed. If we were just logging to a file, we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log to `stdout` as the file it is being written to; alternatively
    we could just add another stream to `bunyan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example will display the logs to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see the logs have been appended to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Great, now we have the logging down, what shall we do with it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it helps to know where our errors are occurring and it starts to get really
    messy when you have lots of anonymous functions around the place. If you noticed
    in the examples that cover an HTTP server, the majority of the functions were
    named. This is very helpful in tracking down errors when callbacks are involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It might look a bit messy and that''s because it is. Let''s run the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can see that there are no function names in our code and also there is no
    naming in the stack trace unlike the first few functions. In Node.js, the naming
    of functions will come from either the variable name or the actual function name.
    For example, if you use `Cls.prototype.func` then the name will be `Cls.func`
    but if you use the function `func` then the name will be `func`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that there is a slight benefit here but this becomes very useful
    once you start using patterns involving `async` callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s throw an error in a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our example gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where it starts to get difficult to read; assigning simple names to
    our functions can help us find where the error is coming from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another aspect of debugging is handling and expecting errors beforehand. There
    are three ways in which we can handle our errors:'
  prefs: []
  type: TYPE_NORMAL
- en: a simple `try`/`catch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: catching them at the process level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: catching errors on the domain level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `try`/`catch` function will be sufficient if we expect an error to occur
    and we will be able to continue without knowing the result of whatever was being
    executed, or we could handle and return the error, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Another simple way to catch errors is to add an error handler to your process;
    any errors that are caught at this level are usually fatal and should be treated
    as such. An exit of the process should follow and you should be using a package,
    such as `forever` or `pm2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You should always exit the process following an uncaught error. The fact that
    it is uncaught means that your application is in an unknown state where anything
    can happen. For example, there could have been an error in your HTTP router and
    no more requests can be routed to the correct handlers. You can read more about
    this at [https://nodejs.org/api/process.html#process_event_uncaughtexception](https://nodejs.org/api/process.html#process_event_uncaughtexception).
  prefs: []
  type: TYPE_NORMAL
- en: A better way to handle errors on a global level is using `domain`. With domains
    you can almost *sandbox* a group of asynchronous code together.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think in the context of a request to our server. We make a request, read
    from a database, make calls to external services, write back to a database, do
    some logging, do some business logic, and we expect perfect data coming from external
    sources all around the code. However, in the real world it isn't always so and
    we can't handle every error that could possibly occur; moreover, we don't want
    to take down our entire server just because of one error for a very specific request.
    That's where we need domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is a problem with this code; however, as we are running this synchronously
    we are still putting the process into a broken state. This is because the error
    bubbled up to the node itself and then was passed to the active domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are creating the domain in an asynchronous callback, we can be sure
    that the process can continue. We can mimic this by using `process.nextTick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example should display the correct logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have covered a few post-mortem debugging methods to help
    us uncover bugs including logging, naming practices, and sufficient error handling.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover configuration of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
