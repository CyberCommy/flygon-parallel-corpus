- en: Chapter 4. Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point in your journey with Node.js, it is inevitable that you will have
    to debug some nasty bugs. So, let's expect them beforehand and plan for that day.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few methods that we can use to debug our software; the first one
    we are going to look at is logging. The simplest way to log a message is to use
    `console`. In most of the previous examples `console` has been used to portray
    what is going on without needing to see the entire HTTP request and response,
    thus making things a lot more readable and simple.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running this example will log requests and responses on the console:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we are using a framework that accepts middleware, such as express, we could
    use a simple `npm` package called **morgan**; you can find the package at [https://www.npmjs.com/package/morgan](https://www.npmjs.com/package/morgan):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use it by using `require` to bring it into our code and adding it as
    middleware:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the server is running, we can see each request and response without having
    to add logging to each handler:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This kind of logging is a simple way to see what is being used on the server
    and how long each request is taking. Here, you can see that the first requests
    took the longest and then they got a lot faster. The difference is only of 3 ms;
    if the time was larger, it could have been a big problem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'We can increase the information that''s logged by changing the format we pass
    to morgan, as shown:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By running the server you will see more information, such as the remote user,
    date and time of the request, amount of content that was returned, and the client
    they are using.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Timing is definitely an important factor as it can be helpful when sifting through
    the mountains of logs that you will obtain. Some bugs can be like a ticking time-bomb
    waiting to explode at 3 AM on a Saturday night. All these logs mean nothing to
    us if the process has died and the logs have disappeared. There is another popular
    and useful package called `bunyan,` which wraps many logging methods into one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Bunyan brings to the table the advantage of writeable streams to write logs,
    whether it is a file on disk or `stdout`. This allows us to persist our logs for
    postmortem debugging. You can find more details about `bunyan` at [https://www.npmjs.com/package/bunyan](https://www.npmjs.com/package/bunyan).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s install the package. We want it installed both locally and globally
    so that we can also use it as a command line tool:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, lets do some logging:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running our example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This doesn't look very pretty, does it? Bunyan uses a simple structured JSON
    string to save messages; this makes it easy to parse, extend, and read. Bunyan
    comes with a CLI utility to make everything nice and pretty.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the example with the utility, then we will see that the output is
    nicely formatted:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we add a few more levels, you will see on your console that each is colored
    differently to help us identify them:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s run the example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you notice, trace and debug weren't outputted on the console. This is because
    they are used to follow the flow of the program rather than the key information
    and are usually very noisy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the level of logs we want to see by passing this as an option
    when we create the logger:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, when we run the example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We usually don't want to see logs that are lower than the info level, as any
    information that is useful for post-mortem debugging should have been logged using
    the info or higher.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Bunyan''s api is good for the function of logging errors and objects. It saves
    the correct structures in its JSON output, which is ready for display:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s run the example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we look at the example and pretty-print it, we will see that they save it
    as an error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is useful because, if you just log an error, you will either get an empty
    object if you used `JSON.stringify` or just the message if you used `toString`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s run the example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is to lot simpler and cleaner to use `logger.error( error )` than `logger.error(
    { message: error.message /*, ... */ } );`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, `bunyan` uses the concept of streams, which means that
    we can write to a file, `stdout`, or any other service we wish to extend to.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'To write to a file, all we need to do is add it to the options passed to `bunyan`
    at setup:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By running the example, you won''t see any logs being outputted to the console
    but they will be written to file instead:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you list what''s in the directory you will see a new file has been created:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you read what''s in the file you will see that the logs have already been
    written:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can run this through `bunyan` in order to print it out nicely:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we can log to a file, we also want to be able to see the messages
    as they are displayed. If we were just logging to a file, we could use:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will log to `stdout` as the file it is being written to; alternatively
    we could just add another stream to `bunyan`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running the example will display the logs to the console:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also see the logs have been appended to the file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Great, now we have the logging down, what shall we do with it?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Well, it helps to know where our errors are occurring and it starts to get really
    messy when you have lots of anonymous functions around the place. If you noticed
    in the examples that cover an HTTP server, the majority of the functions were
    named. This is very helpful in tracking down errors when callbacks are involved.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It might look a bit messy and that''s because it is. Let''s run the following
    example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can see that there are no function names in our code and also there is no
    naming in the stack trace unlike the first few functions. In Node.js, the naming
    of functions will come from either the variable name or the actual function name.
    For example, if you use `Cls.prototype.func` then the name will be `Cls.func`
    but if you use the function `func` then the name will be `func`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that there is a slight benefit here but this becomes very useful
    once you start using patterns involving `async` callbacks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s throw an error in a callback:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running our example gives us:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is where it starts to get difficult to read; assigning simple names to
    our functions can help us find where the error is coming from:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Error handling
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another aspect of debugging is handling and expecting errors beforehand. There
    are three ways in which we can handle our errors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: a simple `try`/`catch`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: catching them at the process level
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: catching errors on the domain level
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `try`/`catch` function will be sufficient if we expect an error to occur
    and we will be able to continue without knowing the result of whatever was being
    executed, or we could handle and return the error, as shown:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Another simple way to catch errors is to add an error handler to your process;
    any errors that are caught at this level are usually fatal and should be treated
    as such. An exit of the process should follow and you should be using a package,
    such as `forever` or `pm2`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You should always exit the process following an uncaught error. The fact that
    it is uncaught means that your application is in an unknown state where anything
    can happen. For example, there could have been an error in your HTTP router and
    no more requests can be routed to the correct handlers. You can read more about
    this at [https://nodejs.org/api/process.html#process_event_uncaughtexception](https://nodejs.org/api/process.html#process_event_uncaughtexception).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: A better way to handle errors on a global level is using `domain`. With domains
    you can almost *sandbox* a group of asynchronous code together.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Let's think in the context of a request to our server. We make a request, read
    from a database, make calls to external services, write back to a database, do
    some logging, do some business logic, and we expect perfect data coming from external
    sources all around the code. However, in the real world it isn't always so and
    we can't handle every error that could possibly occur; moreover, we don't want
    to take down our entire server just because of one error for a very specific request.
    That's where we need domains.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在请求服务器的情境下思考。我们发出请求，从数据库中读取数据，调用外部服务，写回数据库，进行一些日志记录，执行一些业务逻辑，并且我们期望来自代码周围所有外部来源的数据都是完美的。然而，在现实世界中并非总是如此，我们无法处理可能发生的每一个错误；此外，我们也不希望因为一个非常特定的请求出现错误而导致整个服务器崩溃。这就是我们需要域的地方。
- en: 'Let''s look at the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s run the code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这段代码：
- en: '[PRE39]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is a problem with this code; however, as we are running this synchronously
    we are still putting the process into a broken state. This is because the error
    bubbled up to the node itself and then was passed to the active domain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在问题；然而，由于我们是同步运行的，我们仍然将进程置于一个破碎的状态。这是因为错误冒泡到了节点本身，然后传递给了活动域。
- en: 'When we are creating the domain in an asynchronous callback, we can be sure
    that the process can continue. We can mimic this by using `process.nextTick`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在异步回调中创建域时，我们可以确保进程可以继续。我们可以通过使用`process.nextTick`来模拟这一点：
- en: '[PRE40]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running the example should display the correct logs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例应该显示正确的日志：
- en: '[PRE41]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have covered a few post-mortem debugging methods to help
    us uncover bugs including logging, naming practices, and sufficient error handling.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些事后调试方法，帮助我们发现错误，包括日志记录、命名惯例和充分的错误处理。
- en: In the next chapter, we will cover configuration of our applications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何配置我们的应用程序。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID为bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他使用都需要版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
