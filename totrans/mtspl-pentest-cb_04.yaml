- en: Chapter 4. Client-side Exploitation and Antivirus Bypass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer unsafe scripting misconfiguration vulnerability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet Explorer recursive call memory corruption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Word RTF stack buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adobe Reader `util.printf()` buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating binary and shellcode from `msfpayload`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing client-side antivirus protection using `msfencode`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `killav.rb` script to disable antivirus programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deeper look into the `killav.rb` script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing antivirus services from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we focused on penetration testing the target operating
    system. Operating systems are the first level of penetrating the target because
    an unpatched and outdated operating system can be easy to exploit and it will
    reduce our effort of looking for other methods of penetrating the target. But
    the situation can vary. There can be cases in which a firewall may block our scan
    packets and, thus, prevent us from gaining any information about the target operating
    system or open ports.
  prefs: []
  type: TYPE_NORMAL
- en: There can also be a possibility that the target has automatic updates which
    patches the vulnerabilities of the operating system at regular intervals. This
    can again kill all the attacks of penetrating the target. Such security measures
    can prevent us from gaining access to the target machine by exploiting known vulnerabilities
    of the operating system in use. So we will have to move a step ahead. This is
    where client-side exploitation and antivirus bypassing techniques comes into play.
    Let us first understand a typical client-side attack vector.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the penetration tester has figured out that the target machine has an
    updated Windows XP SP3 operating system and Internet Explorer version 7 set up
    as the default browser to access the Internet and other web-related services.
    So, the pen-tester will now craft a malicious URL that will contain an executable
    script which can exploit a known vulnerability of IE 7\. Now he builds a harmless
    looking HTML page and creates a hyperlink which contains the same malicious URL.
    In the next step, he transfers the HTML page to the target user through social
    engineering and somehow entices him to click the malicious hyperlink. Since the
    link contained a known exploit of IE 7 browser, it can compromise the browser
    and allow further code execution, thus giving the penetration tester power to
    control the target system. He can move ahead to set up a backdoor, drop a virus,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly happens now? Although the target machine was running a patched
    and updated version of Windows the default browser IE 7 was not updated or rather
    neglected by the target user. This allowed the penetration tester to craft a scenario
    and break into the system through the browser vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario discussed previously is a simple client-side attack in which the
    target unknowingly executes a script which exploits vulnerability in the application
    software used by the target user. On successful execution of the exploit, the
    attacker compromises the system security.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit provides us with a large variety of exploit modules for several popular
    software which can be used to perform a client-side attack. Some of the popular
    tools which we will discuss in this chapter include Internet Explorer, Microsoft
    Office pack, Adobe reader, Flash, and so on. Metasploit repository contains several
    modules for these popular tools. Let us quickly analyze the client-side exploitation
    process in Metasploit. Our aim is to successfully attack the target through a
    client-side execution and set up shell connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Metasploit breaks this penetration process into two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It generates the respective malicious link/file for the application tool you
    choose to target. After that, it starts listening on a particular port for a back
    connection with the target. Then the attacker sends the malicious link/file to
    the target user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now once the target executes the malicious link/file, the application gets exploited
    and Metasploit immediately transfers the payload to some other Windows process
    so that if the target application crashes (due to exploit) or a user closes the
    application, the connectivity still remains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two preceding steps will be clear to you when we will discuss the recipes
    based on client-side attacks. This chapter will focus on some key application
    software based on the Windows operating system. We will start with analyzing browser-based
    client side exploits. We will look into various existing flaws in Internet Explorer
    (version 6, 7, and 8) and how to target it to penetrate the user machine. Then,
    we will shift to another popular software package named Microsoft Office (version
    2003 and 2007) and analyze its formatting vulnerability. Then, we will move ahead
    with analyzing PDF vulnerabilities and how a malicious PDF can be used to compromise
    the user security. Last, but not the least, we will discuss a very important aspect
    of penetration testing called antivirus bypass. It will focus on overriding the
    client-side antivirus protection to exploit the target machine without raising
    alarms.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will leverage the complete power of the Metasploit framework so
    that you will love reading and implementing it. Let us move ahead with our recipes
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer unsafe scripting misconfiguration vulnerability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us start with the first browser-based client side exploit. The elementary
    process of using any client-side exploit module is similar to the ones we discussed
    in previous chapters. The only difference lies in transferring the exploit to
    the target. Unlike operating system-based exploits, client-side exploits require
    manual execution of the exploit and payload at the target machine. You will understand
    it clearly, once we proceed with the recipe. So let us quickly dive into implementing
    the attack.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with launching our msfconsole and selecting the relevant exploit.
    The process is similar to what we have been discussing so far in previous chapters.
    Then, we will move ahead to select a payload which will help us set a shell connectivity
    with the target machine. The exploit we will be dealing with in this recipe is
    `exploit/windows/browser/i.e. unsafe scripting`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This exploit is known to affect Internet Explorer version 6 and 7 which are
    default browsers in all versions of Windows XP and 2003 servers. But it ran successfully
    even on my Windows 7 ultimate with internet Explorer 8 (unpatched).
  prefs: []
  type: TYPE_NORMAL
- en: This exploit works when the **Initialize and script ActiveX controls not marked
    as safe** setting is marked within Internet Explorer. The following setting can
    be found by launching Internet Explorer and browsing to **Tools** | **Internet
    Options** | **Security** | **Custom Level** | **Initialize and script ActiveX
    controls not marked as safe** | **Enable**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/7423_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similar settings can be made in other versions of Internet Explorer as well.
    In this recipe, we will exploit two different targets. One is running Windows
    XP SP2 with IE 7 and the other is running Windows 7 with IE 8\. Let us now move
    ahead to execute the exploit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start with launching the msfconsole and set our respective exploit as
    active. We will be using the `reverse_tcp` payload to get shell connectivity with
    the two targets once they are exploited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our exploit, as well as the payload has been set active. As you can see,
    we have not used the RHOST option here because it is a client-based attack. Let''s
    see what happens when we execute the `exploit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, a link has been generated as a result of the `exploit` command.
    This is the malicious link (`http://192.168.56.101:8080/2IGIaoJQB`) that we will
    have to send to our targets, so that it can exploit their browser. Also the last
    line says "server started" which is actually listening for a connection on port
    4444 from the target machine. Let us first analyze the outcome of the link execution
    on the Windows XP target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser will try to load the page, but at the end nothing will be displayed.
    In turn, the browser either will hang or will remain idle. But you will notice
    some activity on your msfconsole. This activity will be similar to the one shown
    in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! We have an active session with our target machine. The preceding command-line
    output shows that an executable file has been created in the `temp` folder of
    our target which is responsible for this entire exploitation process.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now analyze the outcome of this malicious link execution on the Windows
    7 machine with IE 8.
  prefs: []
  type: TYPE_NORMAL
- en: We will notice that Internet Explorer will prompt with an alert message. On
    clicking **Allow**, the outside script will get executed and the browser may crash
    or hang (depending upon the system).
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7423_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us switch to attacking the msfconsole and notice the activity. We will
    notice the following command-line activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have yet another active session opened with the Windows 7 machine as well.
    Let us start interacting with our sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the sessions command has revealed the active sessions available
    to us. One is our Win XP machine and the other one is the Win7 machine. Let us
    move ahead to interact with the second session, that is, the Windows 7 machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working process might be clear to you. Let us focus on the reason for this
    exploit. When "Initialize and script ActiveX controls not marked safe for scripting"
    is set, then it allows access to the `WScript.Shell` ActiveX control. This `WScript.Shell`
    object provides functions to read the file system, environment variables, read
    and modify registry, and manage shortcuts. This feature of `WScript.Shell` allows
    the attacker to create a JavaScript to interact with the file system and run commands.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us talk about another important browser-based exploit which can be used
    in a client-side attack.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer Aurora memory corruption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another widely used exploit for IE which came into light in mid 2010\.
    This flaw was the key component of "Operation Aurora" in which hackers targeted
    some top companies. This module exploits a memory corruption flaw in IE 6\. I
    am leaving this module as an exercise for you to try out and explore. The exploit
    can be found in `exploit/windows/browser/ms10_002_aurora`.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer CSS recursive call memory corruption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the most recent exploits available for the Windows platform running
    IE browser. This exploit is known to affect Windows 7 and Windows 2008 server
    with IE 8 as the default browser. The working process of this exploit is similar
    to the one we just discussed in the previous recipe. So let us quickly test it.
    Our target machine is a Windows 7 ultimate edition with IE 8 (unpatched) running
    as the default browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with launching the msfconsole. Our exploit in this recipe is `exploit/windows/browser/ms11_003_ie_css_import`
    and our payload will be `windows/meterpreter/bind_tcp` which will help in gaining
    shell connectivity with the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start the same way we have been doing so far. First, we will select
    the exploit. Then, we will select the payload and pass on the various parameter
    values required by the exploit and the payload. Let us move ahead with all these
    steps in our msfconsole.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the exploit and payload have been set along with various parameters.
    After executing the `exploit` command, the module has generated a local link `http://192.168.56.101:8080/K9JqHoWjzyAPji`.
    This is the malicious link which has to be transferred to the target in order
    to make him execute in his IE browser. The target browser will freeze completely
    and will consume a large part of the system resource. The target will be forced
    to shut down the browser. Let us monitor the activities on the msfconsole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Upon successful execution of the exploit in the target's browser, we have a
    session started in the msfconsole, thus, opening shell connectivity. But there
    is something more that happens after opening a session between msf and the target.
    The `InitialAutoRunScript` executes a `migrate -f` command which migrates the
    payload from `iexplore.exe` to `notepad.exe`. This step is essential for a persistent
    connectivity. Even if the target user closes the browser, still the connection
    will be alive as we have migrated to another process.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us dig out this vulnerability for more information. Well, the reason for
    the vulnerability is exactly what its name says. When Microsoft's HTML engine
    (mshtml) parses an HTML page that recursively imports the same CSS file multiple
    times, then it leads to a memory corruption and allows arbitrary code execution.
    Consider the following HTML code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The same CSS file has been called four times. When mshtml parses this HTML page
    then it leads to a memory corruption. This exploit utilizes a combination of heap
    spraying and the .NET 2.0 **mscorie.dll** module to bypass DEP and ASLR. Due to
    over consumption of system resources, it finally crashes. Using this vulnerability
    the attacker gains the same user rights as the logged in user.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7423_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that the background consists of the
    IE instance in which the malicious link has been executed and the foreground image
    is of the Windows task manager in which you can clearly see the over consumption
    of memory by the IE browser. Another interesting thing to note in this task manager
    is the notepad.exe process. Even though there is no running instance of notepad,
    still the task manager is showing this process. The obvious reason for this is
    that we have migrated from iexplorer.exe to notepad.exe so this process is running
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a common error which we may encounter while using this exploit module.
    Let's have a quick look at it and find out a relevant solution.
  prefs: []
  type: TYPE_NORMAL
- en: Missing .NET CLR 2.0.50727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may encounter an error "Target machine does not have the .NET CLR 2.0.50727"
    while using this exploit module. Well, the reason for this error is not because
    .Net is missing. The main reason for it is that Internet Explorer is not set as
    the default browser so the user agent is being abused to fetch an address from
    a non-ASLR region. This error can be overcome by setting Internet Explorer as
    the default web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Word RTF stack buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two recipes, we focused completely on browser-based exploits.
    Now in this recipe, we will focus on another popular Windows tool called Microsoft
    Office. The RTF buffer overflow flaw exists in both 2010 and 2007 versions of
    the Office software pack. This vulnerability exists in the handling of `pfragments`
    shape property within the Microsoft Word RTF parser. Let us understand this exploit
    in detail. I am assuming that we have already gained information about our target
    that it has Office pack installed on his system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with launching the msfconsole. The exploit we will be using in
    this recipe can be located at `exploit/windows/fileformat/ms10_087_rtf_pfragments_bof`.
    The payload we will be using is `windows/meterpreter/reverse_tcp` to get shell
    connectivity with the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working process will again be similar to what we have seen so far in previous
    recipes. We will first set our exploit. Then, we will select a payload and then
    pass the relevant parameters for both in order to execute the exploit successfully.
    Let us perform these steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The exploit contains a parameter `FILENAME` which contains information about
    the malicious filename to be created. The default value is `msf.rtf`. Let us change
    it to some less suspicious name. We will also set the value for `LHOST` which
    is the attacking machine IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The filename has been changed to `priceinfo.rtf` and the value of `LHOST` has
    been set to `192.168.56.101`. So we are all set to execute the exploit module
    now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Metasploit has created a malicious file for us which we will have to use in
    order to proceed with the client-side attack. The file is located at `/root/.msf4/local/priceinfo.rtf`.
    Now the next step is to send this file to the target user either through a mail
    or through some other medium. Once the target user executes this malicious file,
    we will notice that it will open as a word document. After few seconds of execution,
    the Microsoft Word instance will either hang or crash depending upon the system.
    In the meantime, the malicious file successfully executes the exploit and provides
    an active session with the target. In order to make the connection persistent,
    the exploit migrates itself to some other process which will run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines of the command line shows a successful execution of the
    exploit which results in an active session with `SESSION ID = 2`. The last part
    of the command line shows that the exploit has successfully migrated from `WINWORD.EXE`
    to `notepad.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exploit module simply creates a malicious word file that passes illegal
    values to the word parser. The failure of parser in recognizing the illegal values
    leads to a buffer overflow in it. Then the payload comes into action which executes
    the code to set up a back connection with the attacking machine. The success of
    this attack varies from machine to machine as there can be situations when **Windows
    ASLR (Address Space Layout Randomization)** can prevent execution of an arbitrary
    code (payload).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another popular exploit available for the Office suite. I will leave
    it as a lesson for you to practically try it. Here I will give a brief overview
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Excel 2007 buffer overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This known exploit targets the Microsoft Excel tool (`.xlb`) for version 2007\.
    Execution of a malicious .xlb file can lead to a stack-based buffer overflow and
    lead to an arbitrary code execution. The exploit can be located at `exploit/windows/fileformat/ms11_021_xlb_bof`.
  prefs: []
  type: TYPE_NORMAL
- en: Adobe Reader util.printf() buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PDF is one of the most widely used formats for sharing files and documents.
    So, using it as a potential weapon to exploit the target machine can be a fruitful
    idea. Adobe Reader is the most popular PDF file reader tool. The exploit we will
    discuss here is a vulnerability existing in Adobe Reader prior to versions 8.1.3\.
    The exploit works by creating a malicious PDF file which, when opened in vulnerable
    versions of Adobe Reader, causes a buffer overflow and allows an arbitrary code
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exploit process is very similar to those we have discussed so far in this
    chapter. Almost all client-side attacks work in a similar manner in which we first
    generate a malicious file/link and then somehow ask the target user to execute
    it on his/her machine. So a client-side attack involves Social Engineering as
    well. Let us move on to this exploit. Here, our target machine is Windows XP SP3
    running Adobe Reader version 8.1.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with launching our msfconsole and use the module `exploit/windows/fileformat/adobe_utilprintf`
    and payload module as `windows/meterpreter/reverse_tcp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with selecting the exploit and setting it a active. Then, we will
    set the payload. After selecting the exploit and the payload, our next step will
    be to pass the various parameter values required to execute it. So, let us move
    ahead to perform these steps over the msfconsole.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the target version of Adobe Reader is listed as 8.1.2 and the
    operating system is mentioned as Windows XP SP3\. So, the success of this exploit
    will greatly depend on the version or Adobe Reader and operating system used by
    the target.
  prefs: []
  type: TYPE_NORMAL
- en: The exploit module contains a parameter `FILENAME` with a default value. This
    parameter decides the name of the malicious PDF file that will be created. Let
    us change its value to something less suspicious. Also we will have to pass the
    IP address of the local machine in `LHOST` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we are all set to execute the exploit command and generate the malicious
    PDF file which will be used in our client-side attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, a malicious PDF file named `progressreport.pdf` has been created and
    stored in the `/root/.msf4/local` folder.
  prefs: []
  type: TYPE_NORMAL
- en: This time we will adopt a slightly different approach to start a listener for
    reverse connection. Suppose a situation comes when you have to suddenly close
    your msfconsole. What about the exploit then? Do we have to create the malicious
    PDF again? The answer is No. There is a special listener module present in Metasploit
    which can be used to start a listener on your msfconsole so that you can resume
    with your penetration testing process using the same files/links that you generated
    for the client-side attack. Consider a scenario where we have generated the malicious
    PDF file but not yet used it for client-side attack. So let us start the msfconsole
    again and use the `exploit/multi/handler` module to set up a listener for the
    reverse connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have set up the module `multi/handler` and then we also added
    a payload to it. The next step is to add an `LHOST` and `LPORT` depending upon
    the usage. We also have an additional option to run additional scripts along with
    the multi/handler module. We will discuss it later in the next chapter. The final
    step is to execute the exploit command and start the listener.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So our reverse handler is up and running. Now it is ready to receive back the
    connection once the malicious PDF is executed on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Once the PDF is executed on the client machine, it completely freezes and the
    Adobe Reader hangs completely, leading to denial of service. The reason for this
    crash is due to the buffer overflow caused by the malicious PDF file. On the attacker
    side, you will see that a meterpreter session has been started and now the target
    machine can be handled remotely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This problem was identified in the way vulnerable versions of Adobe Reader implement
    the JavaScript `util.printf()` function. The function first converts the argument
    it receives to a String, using only the first 16 digits of the argument and padding
    the rest with a fixed value of "0" (0x30). By passing an overly long and properly
    formatted command to the function, it is possible to overwrite the program's memory
    and control its execution flow. The Metasploit module creates a specifically crafted
    PDF file that embeds JavaScript code to manipulate the program's memory allocation
    pattern and trigger the vulnerability. This can allow an attacker to execute the
    arbitrary code with the privileges of a user running the Adobe Reader application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two lines of JavaScript embedded in a PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These two simple JavaScript lines cause the byte 0x20 to be copied 5000 times
    on the stack. This allows you to take control of the exception handler, and also
    to trigger an exception when trying to write in the section that comes after the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Generating binary and shellcode from msfpayload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed many techniques that can be used for penetrating the
    target machine using the client-side attacks. All those techniques involved exploiting
    vulnerability in the various pieces of application software that run on the client
    machine. But, there can be a scenario when the previously discussed techniques
    may not work. These attacks leave us to the mercy of the vulnerable application
    software which we will have to exploit in order to gain access.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit provides us with another feature in which we can execute a client-side
    attack without worrying about exploiting the application software running on the
    target machine. `msfpayload` is the solution for it. Let us give a quick introduction
    to `msfpayload` and move ahead with our recipe to practically implement it.
  prefs: []
  type: TYPE_NORMAL
- en: '`msfpayload` is a command-line instance of Metasploit that is used to generate
    various file types of shellcodes available in the Metasploit repository. The various
    file type options available are C, Ruby, Raw, Exe, Dll, VBA, and War. We can convert
    any Metasploit shellcode into one of these mentioned file formats using `msfpayload`.
    Then, it can be transferred to the target for execution. Once the file is executed
    on the target machine, we will get an active session. This reduces the overhead
    of exploiting any vulnerability existing in the application software running on
    the target machine. The other major benefit of `msfpayload` is that it can be
    used to generate customized shellcodes in specific programming languages such
    as C, Ruby, and so on which can be used in your own exploit development code.'
  prefs: []
  type: TYPE_NORMAL
- en: A major drawback of using `msfpayload` is that the files generated using it
    can be easily detected by antivirus programs when the target tries to execute
    it. Let us move ahead with the recipe and feel the power that `msfpayload` can
    add to our penetration testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us begin experimenting with `msfpayload`. We will start with launching the
    BackTrack terminal. We can start with the command `msfpayload -h` to view the
    description of its usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To view the available list of shellcodes, we can use the `msfpayload -l` command.
    You will find a huge list of available shellcodes at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us proceed to see how we can generate a specific customized shellcode in
    C language. We will be using `windows/shell/reverse_tcp` payload to generate its
    shellcode in C language. We will first choose our respective payload shell and
    pass various parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice the little `o` parameter in the command line the various parameter options
    of the shellcode payload are listed. We will have to pass the values in order
    to generate a customized shellcode for our use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So we have set up the `LHOST` and `LPORT` according to our need. The next step
    will be to generate a C code for our customized shell (the displayed output has
    been shortened to fit)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice the capital `C` parameter in the command line. You will notice a complete
    shellcode in C language which we can use in our own exploit development code.
    Alternatively, we also have the option to generate codes in Ruby and Perl language.
  prefs: []
  type: TYPE_NORMAL
- en: Let us proceed to the next step of generating a binary executable for the shellcode
    which can be used in our client-side attack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice the various parameters that we have passed in the command-line. We have
    used the `X` parameter to generate an exe file type and the file has been generated
    in the folder `.local` with the name `setup.exe`. This generated exe can now be
    used in our client-side attack.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our executable is ready, we will have to set up a listener in our msfconsole
    to listen for a back connection when the target executes this exe file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we used the same payload and passed the same parameter values which
    we used while generating the executable. Now our listener is ready to receive
    a reverse connection. Once the target user (running Windows prior to Windows 7)
    executes the malicious exe, we will get a shell connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing client-side antivirus protection using msfencode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we focused on how to generate an executable shellcode
    and use it as a weapon for a client-side attack. But, such executables are easily
    detectable by the client-side antivirus protection which can prevent execution
    of such malicious files and raise alarms as well. So what can we do now? We will
    have to move to the next level of attack vector by bypassing the antivirus protection.
    Encoding the executables is an effective technique.
  prefs: []
  type: TYPE_NORMAL
- en: Antivirus uses a signature-based technique in which they identify a potential
    threat by verifying the file's first few lines of code with their signature database.
    If a match is found, then the file is treated as a threat. We will have to exploit
    this technique of antiviruses in order to bypass them. `msfencode` is an effective
    tool which encodes the shellcodes and makes them less detectable to antiviruses.
    There are numerous encoding options provided to us by `msfencode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important thing to keep in mind before starting this recipe. The
    success of this recipe depends on two factors: the type of shellcode used and
    the type of antivirus running on the target machine. This recipe involves a lot
    of experimentation to check which shell to use and what type of encoding can be
    used to bypass a particular type of antivirus. Here, we have two targets. One
    is running Windows XP SP2 with AVG 10 (free version) running on it and the other
    is a Windows 7 Ultimate machine running ESET NOD32 (full and updated version).
    First, we will discuss a simple technique that can bypass old and un-updated antivirus,
    but can be detected by the latest versions of it. Then, we will discuss another
    technique which currently bypasses any antivirus available to date.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`msfencode` is generally pipelined with the `msfpayload` command to encode
    the shellcode generated by it. This reduces our working steps. Let us get started
    with `msfencode` first. Executing the `msfencode -h` command lists various parameters
    available to us, and `msfencode -l` lists the various encoding styles. Let us
    have a look at each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of different encoders available with the framework and each uses
    different techniques to obfuscate the shellcode. The `shikata_ga_nai` encoding
    technique implements a polymorphic XOR additive feedback encoder. The decoder
    stub is generated based on dynamic instruction substitution and dynamic block
    ordering. Registers are also selected dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have divided this recipe into three different cases to give a better understanding
    of how we can dig deeper into this useful tool and develop our own logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 1:** We will start with encoding a simple shell. Both the `msfpayload`
    and `msfencode` commands will be pipelined together.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let us understand the command line. We used the `windows/shell/reverse_tcp`
    shell and generated a raw file type using the `R` parameter. Then, we pipelined
    the `msfencode` command. The `e` parameter is used to determine the encoding style
    which is `cmd/generic_sh` in our case. The `c` parameter represents the number
    of iterations and the `t` parameter represents the file type to be created after
    encoding. Finally, the file will be created in `.local` folder with `encoded.exe`
    as the filename. When the `encoded.exe` file is used for the client-side attack
    on our two targets, then it is easily identified as a threat by both Windows XP(with
    AVG 10) and Windows 7(with NOD32). It may have provided us with shell connectivity,
    but the activity was blocked by the antivirus.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 2:** Now we will increase the complexity of this encoding by adding
    a default windows exe template to the shell and also by increasing the number
    of iterations for encoding. Default templates will help us in creating a less
    suspicious file by binding the shellcode with one of the default Windows executables
    like `calc.exe` or `cmd.exe`. The Windows templates are available in the folder
    `/opt/framework3/msf3/lib/msf/util/../../../data/templates`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a template by copying any default Windows executable in this
    folder and then use it as a template. In this recipe, I have copied `cmd.exe`
    into this folder to use it as a template for my shell. So what will our command
    line look like in this case?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The only extra parameter in this case is `-x` which is used for specifying an
    alternate executable template. We have used `cmd.exe` as the template which is
    the default windows executable for the command prompt. Also we have changed the
    encoding style to `shikata_ga_nai` which ranks as "Excellent" in `msfencode`.
    The number of iterations has also been increased to 20 in this case. The executable
    created in this case appears like a `cmd.exe` executable (because of the template)
    and it easily bypasses the client-side antivirus protection of the Windows XP
    target which is running AVG 10 antivirus. Unfortunately, it was detected as a
    threat on our Windows 7 target running the latest version of NOD32\. So, it can
    be used to bypass the older versions of antiviruses running on Windows machines.
    The second problem, with this technique, is that it fails to launch a shell on
    Windows 7/Server 2008 machines even if they have older antivirus protection. The
    shellcode crashes on execution (because of the template) and even though it bypasses
    the antivirus, still it fails to launch a shell on newer versions of Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 3:** This case will overcome the shortcomings that we faced in Case
    2\. In this case, we will generate a client-side script instead of an executable
    file. The well-known client-side script for the Windows platform is visual basic
    script (`.vbs`). This technique can be used to bypass any antivirus known to date
    running on the latest versions of Windows. The reason that VB scripts make a potential
    weapon to bypass the antivirus is that they are never treated as a threat by antivirus
    programs and this is the reason why their signatures never match with the VB script
    file. Let us create a malicious VB script using `msfpayload` and `msfencode`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice the slight changes in the command line. The only change is that exe has
    been replaced by VBS, and we have not used any templates in order to prevent any
    crashes during client-side execution. This technique can help us bypass the antivirus
    protection of both our targets and provide us shell connectivity. We can set up
    a listener using the multi/handler module (discussed in the previous recipe) and
    wait for a back connection with the targets once they execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have noticed by now, this recipe is purely based on trying out
    different combinations of payloads and encoders. The more you try out different
    combinations, the greater will be your chances of getting success. There are many
    things to explore in `msfpayload` and `msfencode`, so I would encourage you to
    actively try out different experiments and discover your own ways of bypassing
    the antivirus protection.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encoders are primarily used to obfuscate the shellcode script into a form that
    cannot be recognized by antiviruses. The `shikata_ga_nai` encoder uses polymorphic
    XOR technique in which the encoder uses dynamically generated gats as encoders.
    The reason which makes `shikata_ga_nai` popular is that it uses a self-decoding
    technique. Self-decryption means the software decrypts a part of itself at runtime.
    Ideally, the software just contains a decryptor stub and the encrypted code. Iterations
    further complicate the encoding process by using the same operation over and over
    again to make the shellcode look completely alien to antiviruses.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us find a quick way of testing a payload against different anti-virus vendors
    and find out which of them detect our encoded payload.
  prefs: []
  type: TYPE_NORMAL
- en: Quick multiple scanning with VirusTotal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VirusTotal is an online website cum utility tool that can scan your file against
    multiple antivirus vendors to figure out how many of them are detecting it as
    a threat. You can scan your encoded payload against virus total to find whether
    it is raising an alarm in any of the antivirus products or not. This can help
    you in quickly figuring out whether your encoded payload will be effective in
    the field or not.
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick multiple scanning with VirusTotal](img/7423_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: VirusTotal can be browsed from [http://www.virustotal.com](http://www.virustotal.com).
    It will ask you to upload the file you wish to scan against multiple antivirus
    products. Once the scanning is complete, it will return the test results.
  prefs: []
  type: TYPE_NORMAL
- en: Using the killav.rb script to disable antivirus programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we focused on various techniques that can be implemented
    to bypass the client-side antivirus protection and open an active session. Well,
    the story doesn't end here. What if we want to download files from the target
    system, or install a keylogger, and so on. Such activities can raise an alarm
    in the antivirus. So, once we have gained an active session, our next target should
    be to kill the antivirus protection silently. This recipe is all about de-activating
    them. Killing antivirus is essential in order to keep our activities undetected
    on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be using some of the meterpreter scripts available to
    us during an active session. We have an entire chapter dedicated to meterpreter
    scripts so here I will just give a quick introduction to meterpreter scripts and
    some useful meterpreter commands. We will be analyzing meterpreter in great detail
    in our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start with a quick introduction to meterpreter. Meterpreter is an advanced
    payload that greatly enhances the power of command execution on the target machine.
    It is a command interpreter which works by in-memory DLL injection and provides
    us with lots of advantages over traditional command interpreters (generally exists
    with shell codes) as it is more flexible, stable, and extensible. It can work
    as if several payloads are working together on the target machine. It communicates
    over the stager socket and provides a comprehensive client-side ruby API. We can
    get a meterpreter shell by using the payloads available in the `windows/meterpreter`
    directory. In this recipe, we will be using the `windows/meterpreter/reverse_tcp`
    payload and our target machine is Windows 7 running ESET NOD32 antivirus.
  prefs: []
  type: TYPE_NORMAL
- en: Let us set up our listener in msfconsole and wait for a back connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So our listener in now ready. Once the client-side attack executes successfully
    on the target, we will have a meterpreter session opened in msfconsole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are all set to leverage the powers of meterpreter in our experiment
    of killing antivirus. The first command we will execute is `getuid` which gives
    us the username of the system in which we broke in. The user can be either the
    main administrator or a less privileged user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't looks like we have the administrator privilege in the system we just
    penetrated. So the next step will be to escalate our privilege to administrator
    so that we can execute commands on the target without interruption. We will use
    the `getsystem` command which attempts to elevate our privilege from a local user
    to administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we can see that `getsystem` has successfully elevated our privilege on the
    penetrated system using `technique 4` which is KiTrap0D exploit. We can check
    our new escalated ID by again using the `getuid` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So now we have the main administrator rights. The next step will be to run the
    `ps` command which lists all the running processes on the system. We will have
    to look at those processes that control the antivirus running on the target machine
    (output has been shortened to fit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: From the `Name` and `Path` columns, we can easily identify the processes that
    belong to an antivirus instance. In our case, there are two processes responsible
    for antivirus protection on the target system. They are `egui.exe` and `eset.exe`.
    Let us see how we can use the Metasploit to kill these processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meterpreter provides a very useful script named `killav.rb` which can be used
    to kill the antivirus processes running on the target system and, thus, disable
    it. Let us try this script on our Windows 7 target which is running ESET NOD32
    antivirus.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `run` command is used to execute Ruby scripts in meterpreter. Once the script
    has executed, we can again check the running processes on the target in order
    to make sure that all the antivirus processes have been killed. If none of the
    antivirus processes are running, then it means that the antivirus has been temporarily
    disabled on the target machine and we can now move ahead with our penetration
    testing process.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the processes are still running? Let's find out the solution in
    the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: A deeper look into the killav.rb script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing from our previous recipe, we focused on how to kill running antivirus
    processes on the target machine using the `killav.rb` script. But, what if the
    processes are still running or they were not killed even after using the script?
    There can be two reasons for it. Either the `killav.rb` doesn't include those
    processes in its list to kill or the antivirus process is running as a service.
    In this recipe, we will try to overcome the problems. So let's quickly move on
    to our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with the same meterpreter session where we ended our previous
    recipe. We have used the `killav.rb` script once, but still the antivirus processes
    are running. We can view the running processes by using the `ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the two antivirus processes are still alive even after using
    the `killav.rb` script. Let us start with giving a look at the `killav.rb` script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To view and edit the `killav.rb` script, open a new terminal window and browse
    to `/pentest/exploits/framework3/scripts/meterpreter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`vim` is a quick editor for files in Unix. It will open the whole script on
    our screen. Scroll down to find the various processes listed in it. These are
    the processes that the script looks for to kill. Check the entire list to look
    for `eset.exe` and `egui.exe`. If they are not available, then add the two processes
    in the script. To start the editing mode in vim, press the *a* key. It will start
    the insert mode. Now add the two processes in the script''s process list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The following code snippet shows the two processes added at the top of the list.
    To exit the insert mode, press the *esc* key. Now to save the script, press the
    *:* key. You will reach a mini command prompt of the vim editor. Now type `wq`
    to save and exit the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now go back to the meterpreter session and execute the `killav.rb` script again,
    and notice what happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The output of the command execution shows that the script successfully killed
    the two processes. Now, in order to verify whether all the antivirus processes
    have been killed or not, we will again execute the `ps` command to cross check
    (output shortened to fit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You will find that there are no active processes for ESET antivirus. This shows
    that the script successfully killed the antivirus program. This example clearly
    shows how we can increase the efficiency of in-built scripts by adding our own
    inputs into it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us give a quick look at the `killav.rb` script which we have actively used
    in this recipe. The script contains a whole list of processes in an array (%W)
    which it looks for on the target machine to kill.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The last few lines of the code are self-explanatory. The script looks for a
    match for processes running on the target system with its array. When a match
    is found, it uses the `process.kill` function to kill the process. This loop continues
    until all the elements of the array are matched with the available processes.
  prefs: []
  type: TYPE_NORMAL
- en: Killing antivirus services from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we gave two reasons to why the antivirus process is
    still running even after using the `killav.rb` script. In the previous recipe,
    we addressed the first issue, that is, the `killav.rb` list doesn't include the
    processes to be killed. In this recipe, we will address the second issue that
    the antivirus program is running as a service on the target machine. Before we
    proceed, let us first understand the difference between a process and a service.
  prefs: []
  type: TYPE_NORMAL
- en: A process is any piece of software that is running on a computer. Some processes
    start when your computer boots, others are started manually when needed. Some
    processes are services that publish methods to access them, so other programs
    can call them as needed. A process is user-based, whereas a service is system-based.
  prefs: []
  type: TYPE_NORMAL
- en: Antivirus can also run some components as a service such as e-mail filters,
    web access filters, and so on. The `killav.rb` script cannot kill services. So,
    even if we kill the processes using `killav.rb`, the antivirus service will immediately
    start them again. So even if `killav.rb` is killing all the antivirus processes
    and still they are listed every time we use the `ps` command, then it can be concluded
    that some component of antivirus is running as a service which is responsible
    for restarting the processes repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with a scenario in which the target machine is a Windows 7 machine
    running AVG 10 antivirus. I am assuming that we already have an active meterpreter
    session with the target machine with administrative privilege.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will use the Windows command prompt. So we will start off by opening
    a command prompt shell with the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use the `tasklist` command to look for various available tasks.
    Adding the `/SVC` parameter will list only those processes which are running as
    a service. As we know that the target machine is using AVG antivirus, we can add
    a wild card search to list only those services which belong to avg. So our command-line
    will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So we have a whole list or services and processes for AVG antivirus. The next
    step will be to issue the `taskkill` command to kill these tasks and disable the
    antivirus protection.
  prefs: []
  type: TYPE_NORMAL
- en: We can again give a wild card search to kill all tasks that have `avg` as the
    process name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `/F` parameter is used to force kill the process. This will ultimately kill
    the various antivirus services running on the target machine. This recipe has
    lots of areas to explore. You may encounter some problems, but they can be overcome
    by following the right set of commands.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Killing services from the command line simply evokes calls to the operating
    system which disables the particular service. Once we have an active shell session
    with our target, we can evoke these calls on behalf of the command line through
    our shell.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us conclude this recipe with some final notes on what to do if the antivirus
    service is still alive.
  prefs: []
  type: TYPE_NORMAL
- en: Some services did not kill—what next?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This can be due to several reasons. You may get an error for some services when
    you give the `taskkill` command. To overcome this, we can use the `net stop` and
    `sc config` commands for such services. I would recommend that you read about
    these two commands from Microsoft's website and understand their usage. They can
    help us kill or disable even those services that do not stop with the `taskkill`
    command.
  prefs: []
  type: TYPE_NORMAL
