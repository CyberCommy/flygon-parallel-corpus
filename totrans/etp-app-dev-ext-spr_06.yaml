- en: Chapter 6. Back to Business – The Service Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service layer is the nucleus of the application; it is where the business
    logic resides. The business logic encapsulates the rules that define the working
    application and it is where a significant amount of development time is spent.
    Enhancements, changing requirements, and ongoing maintenance will usually require
    modifications to the service layer. Business rules may include such operations
    as restricting access to specific roles, security constraints, calculations, validations,
    compliance checks, and logging, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some typical business logic examples could include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only administrators can change the country assigned to a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administrators can only change a user to a country in their own geographical
    region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If payment is made in a currency other that USD, an exchange rate premium of
    5 percent must be added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Australian zip code must be exactly four digits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reassigning an invoice to the Canadian affiliate can only be performed during
    East Coast business hours
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each new invoice must be logged onto a separate file, if not originating from
    one of the five largest business clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The core business rules we will be implementing in this chapter are far simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: A user must be authenticated prior to accessing any resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only a 3T administrator can maintain the 3T configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users may only update and add task logs for themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service layer considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to have clearly defined entry points for service layer operations.
    This will again be achieved through Java interfaces that define the operations
    exposed by the service layer. Clients of the service layer will interact with
    the business logic through these interfaces, not the implementing classes.
  prefs: []
  type: TYPE_NORMAL
- en: For similar reasons, it is important that the service layer itself is decoupled
    from the underlying DAO implementation. We have already achieved this by ensuring
    that our DAO layer exposes its persistence operations through interfaces. The
    service layer should know nothing about how the persistence layer is implemented
    and there should not be any persistence operations coded within the service layer
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enterprise application clients come in many different forms, most commonly
    web browsers and web services. However, there may be other types of clients; for
    example, standalone servers using RMI. In all cases, the service layer must be
    as independent as possible of the client implementation. As such, the service
    layer should never incorporate presentation logic and should know nothing about
    how the data is used. The following diagram illustrates where the service layer
    sits in the overall application structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service layer considerations](img/5457_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The service layer interacts with the data access layer via domain objects. There
    is a clear demarcation of roles with this design. The DAO layer is responsible
    for interacting with the database and the service layer has no knowledge of how
    this is done. Likewise, the DAO layer has no interest in how the domain objects
    are consumed. This is the role of the service layer where business logic controls
    decide what can and should be done with the domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: A well-architected service layer should have a simple interface that allows
    any type of request handling layer to work with the underlying application business
    logic. If a list of Company entities are requested from the service layer, the
    exposed interface method that provides this functionality does not need to know
    whether the list is being used to render a web page, to execute a web service
    call, or to send an e-mail with an attached Excel spreadsheet. The request handling
    layer will be discussed in detail in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The service layer classes and interfaces will follow the same naming conventions
    of our DAO layer, where `Service` simply replaces the `Dao` equivalent name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the service layer](img/5457_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our first definition will be for the `Result` class.
  prefs: []
  type: TYPE_NORMAL
- en: The Result Data Transfer Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The service layer will communicate with the request handling tier through interfaces
    that return `Result` **Data Transfer Objects** (**DTO**). The DTO design pattern
    is commonly used in enterprise application programming to transfer data between
    different layers or subsystems. Our `Result` DTO will have the following three
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean success`: This property is used if the action was successful and an
    appropriate data payload is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String msg`: This is a message that may be used by the client for logging
    or informational purposes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<T> data`: This is a generically typed data payload that will be consumed
    by the request handling layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Result` class is also a **Value Object** (**VO**), an immutable object
    whose state cannot be changed after creation. Each instance variable is marked
    `final` and we will use an appropriate `ResultFactory` method to create the value
    object instance. Value objects are a concept used in Domain-Driven Design to represent
    data without any conceptual identity. You can find out more about Domain-Driven
    Design at [http://en.wikipedia.org/wiki/Domain-driven_design](http://en.wikipedia.org/wiki/Domain-driven_design).
    The definition of the `Result` class follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the `Result` constructors are package-private (cannot
    be created by classes outside of the package). The `Result` value object instantiation
    will be managed by the `ResultFactory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The static utility methods will create and return `Result` instances configured
    for the appropriate purpose in our service layer.
  prefs: []
  type: TYPE_NORMAL
- en: In our design, a failure is considered to be a recoverable state of the application.
    Attempting to log in with an invalid username/password combination would be an
    example of a failed action. Not having permission to perform a delete would be
    another possible failure action. The client of the service layer can recover from
    such actions and present graceful messages to the user by examining the `msg`
    of the `Result`. An alternate design pattern for handling failures is through
    Java-checked exceptions; an exception is thrown when a failure is encountered.
    Implementing such a design pattern forces the client to catch the exception, determine
    the cause of the exception, and handle processing accordingly. We prefer our design
    for handling failures and recommend you to not use checked exceptions unless a
    truly exceptional situation has occurred. The resulting code is cleaner to read
    and we can avoid the overhead of working with exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The AbstractService.java class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All service layer implementations will extend the `AbstractService` class to
    provide common functionality. We will simply define a `logger`, `@Autowire`, the
    `UserDao` implementation, and add a convenience method for checking if a user
    is valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in the previous chapter, Spring injects the container-managed bean
    with matching type for each of the `@Autowired` annotated fields. Each service
    layer implementation that extends the `AbstractService` class will hence have
    access to the `UserDao` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our service layer will implement very basic security to differentiate between
    normal users and administrator users. The `admin_role` column in the `ttt_user`
    table is used to identify if a user has administrator privileges. Enterprise applications
    will most likely have LDAP realms with appropriate roles configured for different
    user groups but the principle is the same; we need to be able to identify if a
    user is allowed to perform an action. The administrator role will be the only
    role on our 3T application and we will now add a helper method to the `User` class
    to identify whether the user is an administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The service layer implementations will use this new method to test if the user
    is an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: The service layer interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service layer interfaces define methods that will be exposed to clients.
    These methods define the core actions required by our 3T application. Each method
    has a `String actionUsername` argument to identify the user executing this request.
    The `actionUsername` can be used in the implementation for logging purposes or
    to ensure a valid user is requesting data. The definition of valid will depend
    on the action being performed. Each interface will use generic types to define
    the returned `Result` value object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CompanyService` interface will return a data payload that is either a
    Company object (`Result<Company>`) or a list of Company objects (`Result<List<Company>>`).
    The definition of this interface follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note we have defined a single `store` method that will be used to save data
    to persistent storage. The implementing method will decide if a `persist` or `merge`
    is required. In a similar way, we can define the remaining interfaces (package
    and import definitions have been removed).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each interface defined previously will have an appropriate implementation. The
    implementing classes will follow our DAO naming conventions by adding `Impl` to
    the interface names resulting in `CompanyServiceImpl`, `ProjectServiceImpl`, `TaskServiceImpl`,
    `TaskLogServiceImpl`, and `UserServiceImpl`. We will define the `CompanyServiceImpl`,
    `TaskServiceImpl`, and `TaskLogServiceImpl` classes and leave the `ProjectServiceImpl`
    and `UserServiceImpl` as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service layer implementations will process business logic with one or more
    calls to the DAO layer, validating parameters, and confirming user authorization
    as required. The 3T application security is very simple as mentioned in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: A valid user is required for all actions. The `actionUsername` must represent
    a valid user in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only an administrator can modify the `Company`, `Project`, or `Task` data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only an administrator can modify or add users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our service layer implementation will use the `isValidUser` method in the `AbstractService`
    class to check if the user is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication, authorization, and security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application security is a critical part of enterprise application development
    and it is important to understand the difference between authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication verifies who you are. It involves verifying the username/password
    combination and is performed once during the initial login to the 3T application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization verifies what you are allowed to do. 3T administrators are allowed
    to perform more actions than normal users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 3T user must have a valid record in the `ttt_user` table; the service layer
    will simply test if the provided username represents a valid user. The actual
    authorization of the user will be covered in the next chapter when we develop
    the request handling layer.
  prefs: []
  type: TYPE_NORMAL
- en: Securing an enterprise application is beyond the scope of this book but no discussion
    of this topic would be complete without mentioning Spring Security, an overview
    of which can be found at [http://static.springframework.org/spring-security/site/index.html](http://static.springframework.org/spring-security/site/index.html).
    Spring Security has become the de facto standard for securing Spring-based applications
    and an excellent book called *Spring Security 3*, by Packt Publishing, that covers
    all concepts can be found here at [http://www.springsecuritybook.com](http://www.springsecuritybook.com).
    We recommend you learn more about Spring Security to understand the many different
    ways you can authenticate users and secure your service layer.
  prefs: []
  type: TYPE_NORMAL
- en: The CompanyService implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CompanyServiceImpl` class is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each method returns a `Result` object that is created by the appropriate `ResultFactory`
    static method. Each method confirms the `actionUsername` method that identifies
    a valid user for the action. Methods that modify the `Company` entity require
    an administrative user (the `store` and `remove` methods). Other methods that
    retrieve data (the `find*` method) simply require a valid user; one that exists
    in the `ttt_user` table.
  prefs: []
  type: TYPE_NORMAL
- en: Note the reuse of the `if(isValidUser(actionUsername))` and `if(!actionUser.isAdmin())`
    code blocks in each method. This is not considered a good practice as this logic
    should be part of the security framework and not replicated on a per method basis.
    Using Spring Security, for example, you can apply security to a service layer
    bean by using annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `@Secured` annotation is used to define a list of security configuration
    attributes that are applicable to the business methods. A user would then be linked
    to one or more roles by the security framework. Such a design pattern is less
    intrusive, easier to maintain, and easier to enhance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We once again recommend you learn more about Spring Security for use in real-world
    enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: Any action that cannot be performed as expected is considered to have "failed".
    In this case, the `ResultFactory.getFailResult` method is called to create the
    failure `Result` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: Each service layer class uses the `@Service` annotation to identify this as
    a Spring-managed bean. The Spring Framework will be configured to scan for this
    annotation using `<context:component-scan base-package="com.gieman.tttracker.service"/>`
    in the application context configuration file. Spring will then load the `CompanyServiceImpl`
    class into the bean container under the `companyService` name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `store` method is used to both `persist` and `merge` a Company entity. The
    service layer client has no need to know if this will be an `insert` statement
    or an `update` statement. The appropriate action is selected in the `store` method
    based on the existence of the primary key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `remove` method checks if the company has projects assigned. The business
    rule implemented will only allow a company deletion if there are no projects assigned
    and then check if `company.getProjects().isEmpty()` is true. If projects are assigned,
    the `remove` method fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactional attributes depend on the action being implemented. If data is
    being modified, we use `@Transactional(readOnly = false, propagation = Propagation.REQUIRED)`
    to ensure a transaction is created if not already available. If data is not being
    modified in the method, we use `@Transactional(readOnly = true, propagation =
    Propagation.SUPPORTS)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All service layer implementations will follow a similar pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskService implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TaskServiceImpl` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This class implements the following business rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a task is not allowed if task logs are assigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only administrators can modify a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that in the `remove` method we check if task logs are assigned to the
    task using the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `taskLogDao.findTaskLogCountByTask` method uses the `getSingleResult()`
    method on the `Query` interface to return a `long` value as defined in the `TaskLogDaoImpl`.
    It would have been possible to code a method as follows to find the `taskLogCount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However this option would result in JPA loading all `TaskLog` entities assigned
    to the task into memory. This is not an efficient use of resources as there could
    be millions of `TaskLog` records in a large system.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskLogService implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TaskLogService` implementation will be the final class we will go through
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again there is a lot of business logic in this class. The main business
    rules implemented are:'
  prefs: []
  type: TYPE_NORMAL
- en: Only the owner of the `TaskLog` or an administrator can find a task log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An administrator can add a task log for any other user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A normal user can only add a task log for themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the owner of a task log or an administrator can remove a task log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A normal user can only retrieve their own task logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An administrator can retrieve anyone's task logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `findByUser` method requires a valid start and end date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We leave the remaining service layer classes (`UserServiceImpl` and `ProjectServiceImpl`)
    for you to implement as exercises.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to configure the testing environment for our service layer.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service layer testing is a critical part of the enterprise application development.
    As mentioned previously, the service layer encapsulates the business rules that
    define the working application and is where a significant amount of development
    time is spent. Business logic evolves as the application is enhanced, new modules
    are added, and business rules change. The test cases for the service layer will
    therefore represent the evolution of the application. Well-documented test cases
    will enhance the knowledge base of the application lifecycle, define changes,
    and explain the purpose of the change. The service layer test cases will become
    a repository of information appreciated by all developers working on the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change required to enable service layer testing is to add the following
    to the `testingContext.xml` file defined in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Test case classes added to the directory `src/test/java/com/gieman/tttracker/service`
    will then be available for testing. We will add the following classes to the service
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the service layer](img/5457_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `AbstractServiceForTesting` superclass will once again extend `AbstractTransactionalJUnit4SpringContextTests`,
    define the `@ContextConfiguration` configuration file, and override the default
    Spring logger with the `slf4j` logger.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this test case by right-clicking on the file in the editor and selecting
    the **Test File** option should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the service layer](img/5457_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `UserServiceTest` class is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note we have not yet defined the implementation of the `UserService` interface
    but we have already written test cases. Thanks to the use of Java interfaces,
    we are able to define test cases before the implementation has been coded. This
    is one of the key concepts of **Test-driven Development** (**TDD**), where developers
    write test cases that define the desired behavior before writing the actual code
    that passes the tests. This strategy is also part of the test-first programming
    concept of Extreme Programming ([http://en.wikipedia.org/wiki/Extreme_programming](http://en.wikipedia.org/wiki/Extreme_programming)),
    where test cases are written before the implementation coding starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the `UserServiceTest` test file when the `UserServiceImpl` has been
    coded should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the service layer](img/5457_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Automating the service layer tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Updating the `pom.xml` as follows will include the service layer test cases
    during the Maven build process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting **Run** | **Test Project** from the **NetBeans** menu will then execute
    all test cases from both the `dao` and `service` packages, resulting in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating the service layer tests](img/5457_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We leave it to you to add test cases for the remaining service layer implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implement the `ProjectServiceImpl` and `UserServiceImpl` interfaces as required
    by their interface definitions. Business logic to consider when implementing the
    `UserServiceImpl` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Only an admin user may modify data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `email` address may not be empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `password` may not be zero length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `adminRole` flag must be either `Y` or `N`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users are not allowed to delete themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users cannot be deleted if they have task logs assigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm your `UserServiceImpl` implementation by executing the `UserServiceTest`
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service layer is the most valuable asset an enterprise application possesses.
    It is the core of all business logic processing and is the layer that holds the
    most detailed code. Our service layer has no coupling with the DAO implementation
    and is independent of how the data is used. It is purely focused on business logic
    operations, delivering data through a simple, generically typed value object using
    the data transfer object design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Our service layer implementation has clearly defined entry points for business
    logic operations. This is achieved through Java interfaces that define all publicly
    accessible methods. The use of interfaces also enables us to write test cases
    prior to coding the implementations—a core principle of test-driven development
    and extreme programming. In the following chapter, we will use these interfaces
    to define a request handling layer for web clients.
  prefs: []
  type: TYPE_NORMAL
