- en: Chapter 8. Integrating Network Paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with TCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SMTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a virtual hosting paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node's capabilities extend far beyond simply serving web pages. Node's core
    focus of supporting various computing tasks and networking objectives with a simple
    to understand interface allows developers like ourselves to unleash our creativity
    and innovate increasingly interconnected solutions and ideas.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be looking at some fundamental examples of such interconnectivity
    with the knowledge that we can take these archetypes, growing and combining them
    into larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of how to implement network paradigms can help us to exceed the normal
    boundaries of a web app, providing advanced functionality to our users, and implementing
    more ways for individuals to connect with our services.
  prefs: []
  type: TYPE_NORMAL
- en: Sending email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many platforms, the ability to send email comes standard, but the Node approach
    leaves the email functionality to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, there are some excellent module creators in the Node community who
    have already created modules for sending email. In this recipe, we'll be using
    the well-featured third-party `nodemailer` module to send an imaginary newsletter
    to a list of recipients.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to send an email, we'll need a functioning SMTP server that we can
    connect to. In a later recipe, we'll be creating our own SMTP server, but for
    now we'll have to acquire some details of our SMTP to use our client with.
  prefs: []
  type: TYPE_NORMAL
- en: If we have an email address, we have access to an SMTP server. We can find out
    the SMTP host address from our provider.
  prefs: []
  type: TYPE_NORMAL
- en: If required we can obtain access to an SMTP server by signing up for a Gmail
    account (at [mail.google.com)](http://mail.google.com)). Once we have an account,
    we can use `smtp.gmail.com` as the host, with our Gmail address as the username.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a new folder with a new file called `mailout.js` to hold our code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three main elements to using `nodemailer`. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the SMTP transport
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Putting together the message object (which includes the transport)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passing the object to the `sendMail` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add the `nodemailer` module and create the transport as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will need to fill in our own SMTP settings for the `user` and `pass` values.
  prefs: []
  type: TYPE_NORMAL
- en: We've used the `secureConnection` setting and set the port to `465`, so we can
    use Gmail's SSL/TLS-secured SMTP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we incorporate our configured transport into an object which we''ll call
    `msg` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice we haven't set a `to` property on the object. We're going to mail out
    to multiple addresses, so `to` will be set dynamically. For testing purposes,
    we'll create an array of `mailinator` email addresses. **Mailinator** ([http://www.mailinator.com](http://www.mailinator.com))
    is a free service that allows us to quickly create temporary email addresses simply
    by sending an email to an invented address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we simply loop through and send our newsletter to each address as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we point our browser at [http://mailtest1.mailinator.com](http://mailtest1.mailinator.com)
    (or `mailtest2, mailtest3`, and so on), we should see our message in Mailinator's
    temporary inbox.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Nodemailer's `createTransport` method, we can quickly configure our app
    with the required SMTP settings, later including these settings in the `msg` object
    as used by the `sendMail` method.
  prefs: []
  type: TYPE_NORMAL
- en: We don't set an initial `to` property because it's modified through each iteration
    of `maillist.forEach` before being passed into the `sendMail` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`sendMail` is asynchronous, as most methods with callbacks are (`forEach being`
    an exception). After each `sendMail` is called, `forEach` moves on and calls the
    next `sendMail` without waiting for the `sendMail` invocation to complete. This
    means that the `forEach` loop will finish before all the `sendMail` calls are
    finished. So in order to know when all the mail has been sent we use a counter
    (`i`).'
  prefs: []
  type: TYPE_NORMAL
- en: Each time an email is sent we increase our `i` variable by `1`. Once `i` is
    equivalent to the size of our `maillist` array, all emails have been dispatched
    so we call `transport.close`.
  prefs: []
  type: TYPE_NORMAL
- en: Nodemailer opens multiple connections (a connection pool) to the SMTP server
    and reuses those connections for all the emails being sent. This ensures fast
    and efficient emailing, removing the overhead of opening and closing connections
    for each email sent. `transport.close` shuts down the connection pool and thus
    allows our app to finish execution.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nodemailer is a well-featured, highly-configurable mailing module as we'll see.
  prefs: []
  type: TYPE_NORMAL
- en: Using sendmail as an alternative transport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many hosting providers have a `sendmail` service that connects to a default
    SMTP server, the details of which we need not know. Nodemailer will interface
    with `sendmail` if we simply alter our `transport` object to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If `sendmail` isn''t in our host server''s environment `PATH` variable (to
    find out simply type `sendmail` from an SSH prompt), we can instead specify where
    `sendmail` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: HTML emails
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Emails can contain HTML and gracefully degrade to plain text for basic user
    agents. To send an HTML email, we simply add the `html` property to our `msg`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The plain text should be included along with HTML, allowing a fallback for email
    clients with no HTML support.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t want to write the text portion separately, we can have Nodemailer
    extract the text from the HTML for us, using the `generateTextFromHtml` property
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Sending attachments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if we wanted to tell a really bad joke, using email attachments?
  prefs: []
  type: TYPE_NORMAL
- en: We'll dynamically create a text file and load an image file from disk, both
    of which we'll attach to an email.
  prefs: []
  type: TYPE_NORMAL
- en: For the image, we'll be using `deer.jpg` (which can be found in the supporting
    code files). This should go in the same folder as our mail out file (let's call
    it `mailout_attachments.js)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of course this is a proof of concept for attachments, and isn't the best use
    of email. Attachments are provided as an array of objects within the `msg` object.
    Each attachment object must have a `fileName` property, which is the filename
    given to the attachment in the email. This doesn't have to match the name of the
    actual file loaded from disk.
  prefs: []
  type: TYPE_NORMAL
- en: The file contents can be written directly via the `contents` property, using
    a string or a `Buffer` object, or we can use `filePath` to stream a file from
    disk (we can also pass a stream directly to a `sourceStream` property).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Sending SMS* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating an SMTP server* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending SMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to send SMS text messages to our users is another way for us to connect
    with them
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to connect our computer to a GSM modem, interact with specialized
    libraries (such as Asterisk, `asterisk.org`, combined with ngSMS, `ozekisms.com)`,
    and interface with the libraries and the telephony equipment to send SMS messages.
  prefs: []
  type: TYPE_NORMAL
- en: There are easier ways though. Services like Twilio provide gateway SMS services,
    where we contact them via an HTTP REST API and they handle the SMS sending for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll convert our newsletter mail out app into a blanket SMS
    service using the `twilio` module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This requires a Twilio account ([https://www.twilio.com/try-twilio](https://www.twilio.com/try-twilio)).
    Once signed up and logged in we should take note of our Account SID, Auth Token,
    and Sandbox phone number (we may have to select our country of residence to obtain
    the appropriate Sandbox number).
  prefs: []
  type: TYPE_NORMAL
- en: We'll need some phone numbers to send texts to for testing purposes. In the
    sandbox mode (which is what we'll be using for development), any number we want
    to text or call must go through a verification process. We do this by selecting
    the **Numbers** link from the **Account** section, and clicking **Verify a Number**.
    Twilio will then call that number and expect a PIN provided on screen to be entered
    for confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file, `smsout.js`, and install the `twilio` helper module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we require `twilio` and put together some configuration settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Twilio phone number**'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start interacting with the Twilio service, we have to specify
    a registered Twilio phone number in order to create our `phone`. For development
    purposes, we can simply use the sandbox number, which can be found from the Twilio
    dashboard ([http://www.twilio.com/user/account](http://www.twilio.com/user/account)).
    In a production scenario, we would need to upgrade our account and purchase a
    unique phone number from Twilio.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `settings` present and correct we''re ready to create a Twilio client,
    using it to initialize a virtual phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We created `restClient` here also, which offers API calls reflective of Twilio's
    raw REST API. We'll be using `restClient` to check the status of our SMS message
    in order to determine if the message has been sent from Twilio to the target phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we define a list of numbers to text (we''ll have to provide our own) to
    text, much like our `maillist` array in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless we have upgraded our account, any number on `smslist` must be pre-verified
    with Twilio. This can be done through the Twilio Numbers account section ([https://www.twilio.com/user/account/phone-numbers/](https://www.twilio.com/user/account/phone-numbers/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we simply loop through `smslist` and use `phone` to send an SMS message
    to each recipient as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should work fine, except that the process won''t exit (because `twilio`
    initializes a server to receive Twilio callbacks) and we don''t know when an SMS
    is actually sent from Twilio to the recipient. One way to check is to make another
    request to the Twilio REST API asking for a status update. The `twilio RestClient`
    makes this easy for us as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If our SMS hasn''t been sent on the first call, we need to wait and check it
    again. Let''s make some final improvements as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now the console will output each time a number has been confirmed as sent. When
    all numbers have been messaged the process exits.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `twilio.RestClient` gives us access to low-level interactions with the Twitter
    API via the `twilio` helper. This simply wraps generic API calls with our preset
    authorization settings for us, making the HTTP requests on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: '`twilio.Client` is a higher-level API presented by the `twilio` helper and
    handles two-way interactions between Twilio and the client. The third parameter
    that must be provided to initialize a new client is the `hostname` parameter.
    The `twilio` module provides this to Twilio as part of a callback URL requested
    from the Twilio servers to confirm that an SMS message has been sent.'
  prefs: []
  type: TYPE_NORMAL
- en: We ignored this behavior and supplied a dummy hostname, implementing our own
    method of confirming an SMS was sent. Our method doesn't require us to have a
    live server address accessible from the Web (see the *There's more..*. section
    for a live server implementation that uses the `hostname` property as intended).
  prefs: []
  type: TYPE_NORMAL
- en: We use the `sendSms` method of our created `phone` object to make an HTTP request
    of the Twilio API via the `twilio` module, passing in the desired recipient, message,
    and a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Once the request is made, our callback is triggered with the initial `sms` object.
    We use this to determine the ID that Twilio has given our `sendSMS` request with
    `smsInstance.sid` (which is `sms.smsDetails.sid)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`smsInstance.sid` is passed to `restClient.getSmsInstance` which provides us
    with an updated instance of our `smsIntance` object, we call it `presentSms`.
    This call is made from within a custom, self-calling function expression called
    `checkStatus`, which has our initial `sms.smsDetails` object passed to it.'
  prefs: []
  type: TYPE_NORMAL
- en: We are looking to see if Twilio has sent our text message yet. If it has, `presentSms.status`
    will be `sent`. If it's anything other than this, we want to wait a short while
    and then ask Twilio for another update on the status of our queued SMS message.
    That is, unless the returned status is a `404`, in which case there has been an
    issue and we need to notify the user, but continue on to process the next SMS
    message.
  prefs: []
  type: TYPE_NORMAL
- en: As in the *Sending email* recipe, we keep a count of how many messages are sent.
    Once they total the amount of recipients we exit the process, since `smsout.js`
    is a command-line app (in a server scenario we wouldn't need or want to do this).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Twilio module's versatility stretches beyond sending SMS messages. It can
    also transparently handle Twilio callbacks for us through emitting events.
  prefs: []
  type: TYPE_NORMAL
- en: Using the processed event listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a live public server, we would be better off providing our hostname to
    `twilio.Client` so it can manage callback URL requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this code to work, it must be hosted on a live public server. For more information
    on hosting Node on live servers, see[Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live
  prefs: []
  type: TYPE_NORMAL
- en: 'We would remove `restClient` and change our `settings` object to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our SMS sending code is simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `twilio` client provides a `statusCallback` URL to Twilio. Twilio will request
    this URL (something like `http://nodecookbook.com:31337/autoprovision/0)` to confirm
    and the `twilio` helper module will emit a `processed` event to notify us of Twilio's
    confirmation. We listen out for this event, checking the given `SmsStatus` via
    that `req` object to confirm success.
  prefs: []
  type: TYPE_NORMAL
- en: Making an automated phone call
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this next example to work, we would need to have a valid hostname and be
    running our app on a web-exposed server as in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this code to work, it must be hosted on a live public server. For more information
    on hosting Node on live servers, see[Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live
  prefs: []
  type: TYPE_NORMAL
- en: To make a call we start with the usual setup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use the `makeCall` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If our account is not upgraded, whatever number we supply to `makeCall` must
    be verified through the Twilio `Numbers` area in the account section ([https://www.twilio.com/user/account/phone-numbers/](https://www.twilio.com/user/account/phone-numbers/)).
  prefs: []
  type: TYPE_NORMAL
- en: '`makeCall` invokes a callback with a `call` parameter. `call` is an event emitter,
    with `answered` and `ended` events. The `twilio` module transparently converts
    Twilio confirmation callbacks into these events.'
  prefs: []
  type: TYPE_NORMAL
- en: The `answered` event feeds the `req` and `res` objects to its callback. `req`
    holds information about the outgoing call, and `res` has methods which allow us
    to interact with the call, namely `res.append` and `res.send`.
  prefs: []
  type: TYPE_NORMAL
- en: To send a computerized text-to-speech message to the recipient, we instantiate
    a new instance of the `twilio` module's `Twiml` class and use the `Say` method
    (watch out for the unusual convention of giving a capital S to a non-class, using
    a small s will throw an error).
  prefs: []
  type: TYPE_NORMAL
- en: '`TwiML` is Twilio''s markup language. It''s simply API-specific XML. The `twilio`
    module provides the `Twiml` class to handle the ugly business of forming the necessary
    XML. We use it to create two `Say` verbs. Behind the `twilio` scenes, the two
    `append` calls followed by the send invocation would create and issue the following
    `TwiML` to `twilio:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `TwiML` code is received by `twilio` and converted into speech. After the
    woman's voice says `Come alone` the phone call ends, triggering the `ended` event
    in our app (which the `twilio` module emits as a result of receiving an HTTP request
    from `twilio` signifying the call has ended).
  prefs: []
  type: TYPE_NORMAL
- en: We listen to the `ended` event determining when `twilio` (or the recipient)
    have hung up. Once `ended` has triggered we exit the process, outputting the `req`
    object as an overview of the call.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending email discussed in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with TCP discussed in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html "Chapter 10. Taking It Live"),Taking It Live'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with TCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Transmission Control Protocol (TCP) provides the backbone of HTTP communications.
    With TCP, we can open up interfaces between processes running on separate server
    hosts and remotely communicate between processes with less overhead and fewer
    complexities than HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Node provides us with the `net` module for creating TCP interfaces. When it
    comes to scaling, reliability, load balancing, synchronization, or real-time social
    communications, TCP is a fundamental element.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to demonstrate the sort of foundation needed to
    communicate between processes over a network by setting up a TCP connection that
    allows us to remotely monitor and filter HTTP headers of website hits in real
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll need two new files: `server.js` and `monitor.js`. Let''s place them
    in a new folder.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create our first TCP server in `server.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `nc` (netcat) command-line program to test this out in another
    terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we're using Windows, we can download netcat from [http://www.joncraton.org/blog/netcat-for-windows](http://www.joncraton.org/blog/netcat-for-windows).
  prefs: []
  type: TYPE_NORMAL
- en: The response should be `Hello, this is TCP\n` and the `server.js` console should
    output `testing 1 2 3`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, HTTP sits on top of TCP, so we can make an HTTP request of a TCP server.
    If we navigate our browser to `http://localhost:8080` and watch the console, we'll
    see all the headers from our browser's HTTP request appear in the console, with
    the browser displaying **Hello this is TCP**.
  prefs: []
  type: TYPE_NORMAL
- en: We've given the TCP server the name of `fauxHttp`. We're going to use it to
    record HTTP headers from browser clients (with some adjustments we could easily
    adapt our code to work with an actual HTTP server).
  prefs: []
  type: TYPE_NORMAL
- en: 'Still inside `server.js`, we''re going to create another TCP server that opens
    a second port for `monitor.js` to communicate with our server. Before we do though,
    we''ll make a new `EventEmitter` object as a bridge between our two `server.js`
    TCP servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've replaced `console.log` in the `data` listener of `socket` with new `stats
    EventEmitter` which will `emit` a custom `stats` event upon receiving TCP data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also included a `filter` variable to be used in our second TCP interface
    in `server.js` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our `monitorInterface` server listens to our `stats` emitter to determine when
    the first TCP server has received information, sending this information (after
    it has been filtered) to a client connected on port `8081.`
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do now is create this client. Inside `monitor.js` we write the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we open two terminals, running `server.js` in one and `monitor.js` in the
    other, and navigate to `http://localhost:8080` in our browser `server.js` transmits
    the `User-Agent` string from the HTTP headers of each request to `monitor.js`.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply a different filter, such as `Accept`. By simply typing it into
    a running `monitor.js` process, any non-matching filters will default to returning
    the preliminary request line (`GET /, POST /route/here`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'To run across separate systems, we simply place `server.js` on a remote host
    and then update the second parameter of `net.connect` from `localhost` to the
    name of our server, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP layer works on top of TCP. So when our browser makes a request, the
    TCP server receives all the HTTP header information. `http.createServer` would
    handle these headers and other HTTP protocol interactions. However, `net.createServer`
    simply receives TCP data.
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.write` and `socket.end` are similar to `response.write` and `response.end`
    within an HTTP server callback function, but without reference to the requirements
    of the HTTP protocol. Nevertheless, the similarities are enough for our browser
    to be able to receive data from `socket.write`.'
  prefs: []
  type: TYPE_NORMAL
- en: All our `fauxHttp` TCP server does is receive a request via port `8080`, outputs
    `Hello, this is TCP\n` to the client, and reads any data from the client directly
    through to our `stats` event emitter.
  prefs: []
  type: TYPE_NORMAL
- en: Our `monitorInterface` TCP server listens on a separate port (`8081`), essentially
    giving us a sort of (completely insecure) admin interface. In the `monitorInterface`
    callback, we listen to the `stats` emitter which is triggered whenever a browser
    (or any TCP client) hits `localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the listener callback of `stats`, we retrieve the desired `header`, using
    the `filter` variable to search the HTTP headers with the `match` objects `index`
    and `input` properties, enabling us to extract the specified header. If there
    are no matches, we `match` an empty string, thereby returning a `match` object
    containing an `index` of `0` resulting in the extraction of the first line of
    the HTTP headers (the requested path and method).
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the `monitorInterface` TCP server callback listens on the `socket`
    for a `data` event and sets the `filter` variable to whatever the client sends.
    This enables the `monitor.js` client to alter the `filter` by piping the `process.stdin`
    stream directly into the TCP `client`. Meaning we can type directly into `monitor.js'`
    running process and the `data` event from the `socket` of `monitorInterface` will
    trigger in `server.js` receiving whatever is typed in `monitor.js'` STDIN.
  prefs: []
  type: TYPE_NORMAL
- en: '`monitor.js` avails of this functionality by piping the `process.stdin` stream
    directly into the TCP `client`. This means we can type directly into the running
    process and the `data` event from `socket` of `monitorInterface` in `server.js`,
    and this will trigger passing anything typed from STDIN of `monitor.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at some ways we can further harness the power of TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There can be various reasons to forward a port. As an example, if we wish to
    SSH into our server over a mobile connection, we may find that port `22` has been
    blocked. The same can apply with corporate firewalls (this could be because a
    blanket block is applied to all privileged ports except the most common such as
    `80` and `443)`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `net` module to forward TCP traffic from one port to another,
    essentially circumventing a firewall. So naturally this should be used only for
    legitimate cases and with any necessary permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll require `net` and define ports to forward from and to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So we can either define ports via command line or default to forwarding the
    arbitrary port `9000` to the SSH port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we create a TCP server that receives connections via `fromPort`, creating
    a TCP client connection to `toPort`, passing all data between these connections
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use the `data` events to receive and push data between `client` (our bridge
    connection) and `socket` (the incoming connection).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run our script on the remote server (with no arguments), we can log
    in to a secure shell from our local computer using port `9000` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using pcap to watch TCP traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the third-party `pcap` module, we can also observe TCP packets as they
    travel in and out of our system. This can be useful for analysis and optimization
    of expected behaviors, performance, and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `pcap` fails to choose the correct device, there will be no output (or maybe
    unrelated output). In this case, we need to know which device to sniff. If we
    are connected wirelessly, it may well be `wlan0` or `wlan1and` if we are wired,
    in it could be `eth0/eth1`. We can find out by typing `ifconfig` (Linux, Mac OS
    X) or `ipconfig` (Windows) on the command line to see which device has an `inet
    address` matching the network part of our router's IP address (for example, `192.168.1.xxx)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we save this as `tcp_stats.js`, we can run it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `pcap` module interfaces with privileged ports and therefore must be run
    as root (for operating systems such as Linux and Mac OS x that enforce privileged
    ports).
  prefs: []
  type: TYPE_NORMAL
- en: If we navigate to any website and then refresh the page, the `tcpTracker end`
    event of `pcap` is triggered in which we output the `session` object.
  prefs: []
  type: TYPE_NORMAL
- en: To initialize the `tcpTracker`, we create a `pcap` session and attach a listener
    for the `packet` event where we pass each decoded `packet` into `tcpTracker`.
  prefs: []
  type: TYPE_NORMAL
- en: Upon creating the `pcap` session we pass an empty string followed by `tcp` to
    the `createSession` method. The empty string causes `pcap` to automatically choose
    an interface (if this doesn't work we can specify the appropriate interface, for
    example, `eth0, wlan1` or `lo` if we want to analyze `localhost` TCP packets).
    The second parameter, `tcp`, instructs `pcap` to only listen for TCP packets.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an SMTP server* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing a virtual hosting paradigm* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SMTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't have to rely on a third-party SMTP server, we can create our own!
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create our own internal SMTP server (just like the first
    SMTP servers) using the third-party `simplesmtp` module which is an underlying
    library of the `nodemailer` module from the first recipe of this chapter, *Sending
    email*. For information on converting an internal SMTP server to an externally
    exposed MX record server, see the *There's more..*. section at the end of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a file and call it `server.js`, then make a new folder called
    `mailboxes`, containing three subfolders: `bob, bib`, and `susie`. We''ll also
    want to have our `mailout.js` file from the first recipe to hand.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll set up some initial variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we initialize the SMTP server with authentication enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll react to some `simplesmtp` events to process incoming mail, beginning
    with the `startData` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `data` and `dataReady` events will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For terser code we chained these two events together with dot notation. Finally,
    we tell our SMTP server what port to listen on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In production, it would be expedient to specify the port as `25` (or in more
    advanced cases `465` or `587)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's test our server by converting our `mailout.js` file from the *Sending
    email* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we alter our `createTransport` invocation to reflect the values of our
    custom SMTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we modify the `maillist` array to reflect our mailboxes, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Bob and Bib are sent together. We also added an address which doesn't have a
    mailbox ( `<[nobody@nodecookbook.com](mailto:nobody@nodecookbook.com)>` ) in order
    to test our catch all functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run `server.js` in one terminal and in another run `mailout.js`,
    output from `mailout.js` should be something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If we look in the `mailboxes/bob` directory, we'll see our email from `spamnot@ok.com`,
    the same for `susie` and `bib.`
  prefs: []
  type: TYPE_NORMAL
- en: '`server.js` should have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, upon analyzing the contents of `mailboxes/caught`, we'll see our
    email in there sent to Mr Nobody.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SMTP is based upon a series of plain text communications between an SMTP client
    and server over a TCP connection. The `simplesmtp` module carries out these communications
    for us, yielding a higher-level API for developer interactions.
  prefs: []
  type: TYPE_NORMAL
- en: When we call `simplesmtp.createServer` with `requireAuthorization` set to `true`,
    our new server (simply called `smtp)` will emit an `authorizeUser` event and will
    not continue to process until we have invoked the fourth parameter, `cb` (the
    callback). `cb` takes two parameters. With the first we can specify a reason why
    access is denied via an `Error` object (we simply pass `null)`. The second is
    a Boolean saying whether the user is authorized or not (if not, and the error
    parameter is null a generic access denied error is sent to the mail client).
  prefs: []
  type: TYPE_NORMAL
- en: We determine the second `cb` parameter by looping through our `users` array,
    finding out if the username and password are correct (in reality, we may wish
    to use a database for this part). If there is a match, our `auth` variable is
    set to `true` and passed to `cb`, otherwise it remains `false` and the client
    is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: If the client is authorized, `smtp` will emit several events for each envelope
    (an envelope is an email package containing all the recipients for that email,
    body text, email headers, attachments, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: In the `startData` event, we are provided with an `envelope` parameter where
    we use the `envelope.to` property to check whether our recipients have a mailbox.
    SMTP allows more than one recipient to be specified per email, so `envelope.to`
    is always an array, even if it contains only one recipient. Therefore, we use
    `forEach` to loop through `envelope.to` in order to check mailboxes for each recipient
    stipulated.
  prefs: []
  type: TYPE_NORMAL
- en: We find out the intended recipient mailbox by splitting the address by the `@`
    character, loading it into our `rcpt` variable. We perform no verification on
    the domain portion of the address, although `simplesmtp` automatically verifies
    that the domain is genuine before emitting any of the events.
  prefs: []
  type: TYPE_NORMAL
- en: '`rcpt` gets added to our `envelope.mailboxes` array, which we added to `envelope`
    before looping through `envelope.to`. We use `envelope.mailboxes` in the later
    `data` and `dataReady` events.'
  prefs: []
  type: TYPE_NORMAL
- en: Still inside the `envelope.to forEach` loop, we add one final property to `envelope`
    named after the mailbox name (`rcpt`). If the mailbox exists, we create `writeStream`
    to `saveTo` (a path with a filename determined from combining `envelope.from`
    with `envelope.date)`. We now have an endpoint to each recipient's mailbox ready
    to receive data. If the mailbox doesn't exist for the recipient, we set `envelope[rcpt]`
    to `catchall. catchall` is the global we set at the top of our file. It's a `writeStream`
    with the `a` flag set so that the `caught` file accumulates orphaned emails. We
    create the `catchall writeStream` on initialization and then reuse the same `writeStream`
    for all emails addressed to non-existent mailboxes. This saves us from creating
    a `writeStream` for every badly addressed email received, thus saving resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `data` event is triggered for each chunk of the email body received by the
    server, giving us `envelope` and `chunk`. We save each `chunk` to its applicable
    file using `envelope[rcpt].write`, determining the `rcpt` by looping through our
    custom `envelope.mailboxes` array.
  prefs: []
  type: TYPE_NORMAL
- en: The `dataReady` event signifies that all data has been received and the data
    is ready for processing. Since we've already stored it, we use this event to `end`
    the relevant `writeStream` for each `rcpt` in our `mailboxes`. The `dataReady`
    event also requires a callback (cb). The first parameter can be an `Error` object,
    which allows for a final rejection of an email (for instance if the content of
    the email was analyzed and found to be spam). The second parameter expects a queue
    ID to send to the mail client, in our case we simply give `Date.now`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at how to convert our SMTP server into a public mail exchange
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving emails from external SMTP servers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By removing authorization settings and remotely hosting our SMTP server, listening
    on port `25`, we can allow other mail servers to communicate with our SMTP server
    so email can be transferred from one network to another (for example, from a Gmail
    account to our hosted SMTP server).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s save our file as `mx_smtp.js` and modify the following accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We've discarded the `users` variable and changed the `smtp` variable so the
    object with the `requireAuthentication` property and the accompanying `authorizeUser`
    event are removed. In order for an external mail program to forward to our SMTP
    server it must be able to connect. Since other mail programs don't possess authentication
    details we have to open our server to allow them to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `startData` data and `dataReady` events all remain the same. The final
    change is to the port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In order for this to work, we must have a live server which we have root access
    to (for example, an amazon EC2 micro instance), and a domain where we can alter
    the mail exchange (MX) records.
  prefs: []
  type: TYPE_NORMAL
- en: So for instance, say we're hosting our SMTP server at `mysmtpserver.net` and
    we want to receive emails for `bob@nodecookbook.com`. We point the MX records
    of `nodecookbook.com` to `mysmtpserver.net` with a priority of 10.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an example of how to change DNS records with a registrar, see [http://support.godaddy.com/help/article/680](http://support.godaddy.com/help/article/680).
    For more info on MX records, take a look at [http://en.wikipedia.org/wiki/MX_record](http://en.wikipedia.org/wiki/MX_record).
  prefs: []
  type: TYPE_NORMAL
- en: Once changes are made they can take a while to propagate (up to 48 hours, though
    often faster). We can use `dig mx` (Mac OS X and Linux) or `nslookup set q=MX`
    (Windows) to determine if the update to our MX records has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: We must have Node installed on our remove host, ensuring that port `25` is exposed
    and not in use by any other programs. To check whether other programs are using
    port `25`, log in with SSH and type `netstat -l`. If you see `*:smtp` in the **Active
    Internet Connections** (only servers) section, a program is already using the
    port and must be stopped (try `ps -ef` to look for any suspects).
  prefs: []
  type: TYPE_NORMAL
- en: On the live server, we create our `mailboxes` folder containing `bob bib` and
    `susie`, copy our `mx_smtp.js` file over, and install `simplesmtp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, if everything is properly set up, and our MX records are updated, we can
    execute our `mx_smtp.js` file on the live server. Then send a test email to `<[bob@nodecookbook.com](mailto:bob@nodecookbook.com)>`
    (or `@` whatever domain we possess which we have altered the MX records for),
    wait a few seconds, and then check the `mailboxes/bob` folder. The email should
    have appeared.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending email discussed in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying to a server environment* discussed In [Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a virtual hosting paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we wish to host multiple sites on one server, we can do so with virtual
    hosting. Virtual hosting is a way to uniquely handle multiple domain names according
    to their name. The technique is surprisingly simple: we just look at the incoming
    `Host` header and respond accordingly. In this task, we''re going to implement
    simple name based virtual hosting for static sites.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll create a folder called `sites`, with `localhost-site` and `nodecookbook`
    as subdirectories. In `localhost-site/index.html` we''ll write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And in `nodecookbook/index.html` we''ll add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: For local testing, we'll want to configure our system with some extra host names
    so we can point different domains to our server. To do this, we edit `/etc/hosts`
    on Linux and Max OS X, or `%SystemRoot%\system32\drivers\etc\hosts` for Windows
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file it maps our local loopback IP `127.0.0.1` to `localhost`.
    Let''s change this line to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to create two new files: `mappings.js` and `server.js`. The
    `mappings.js` file will provide static file servers for each domain name, and
    `server.js` will provide the virtual hosting logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using the `node-static` module for serving our sites, our virtual
    host will only serve static websites. If we don''t already have it, we can install
    it via `npm` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with `mappings.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We've used the domains laid out in our system's `hosts` file. In a production
    scenario domains would be directed to us by DNS records.
  prefs: []
  type: TYPE_NORMAL
- en: Now for `server.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now when we navigate to `http://localhost:8080` or `http://localhost.localdomain:8080`,
    we get the content in `sites/localhost-site/index.html`. Whereas, if we go to
    `http://nodecookbook:8080`, we get the big Node Cookbook welcome message.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any time our server receives a request, we strip the port number (which wouldn't
    be necessary with port `80` servers) to determine the `domain.`
  prefs: []
  type: TYPE_NORMAL
- en: We then cross reference the `domain` with our `mappings.sites` object. If a
    site is found, we call its `serve` method, which is inherited from the `node-static`
    library. In `mappings.js`, each `exports.sites` property contains a `node-static
    Server` instance pointed at the relevant site directory. We've used our custom
    `staticServer` function as a wrapper to keep the code a little tidier.
  prefs: []
  type: TYPE_NORMAL
- en: To use the static `Server` instance, we call its `serve` method, passing through
    the `req` and `res` objects, as in `server.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `site` variable is an instance of `static.Server` pointing to the appropriate
    site folder for the given domain name.
  prefs: []
  type: TYPE_NORMAL
- en: If `server.js` fails to find a site in `mapping.js` for the requested domain,
    we simply pass a `404` error back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about going beyond static hosting into dynamic hosting, or what if we want
    to use an SSL/TLS certificate with our sites?
  prefs: []
  type: TYPE_NORMAL
- en: Virtual hosting Express apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Express/Connect come with the `vhost` middleware which allows us to implement
    dynamic Express-based virtual hosting with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set up two Express apps. Let''s remove the `nodecookbook`
    and `localhost-site` folders and regenerate them using the `express` binary as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d also need to modify the last part of `app.js` in each site''s file, wrapping
    the `app.listen` method in an `if module.parent` conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In our `nodecookbook` app, let's add the following to `index.jade:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: And in the `localhost-site` app, we add this code to `index.jade:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'With our sites set up, we can modify `mappings.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We've removed the `node-static` module since we're using Express instead. Our
    `staticServe` convenience function has been modified as `appServe`, which simply
    loads each Express app using `require` according to its mapping in `exports.servers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we''ll update `server.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We create a master `app` then loop through `mappings.sites`, passing each sub-app
    into `app.use` with `express.vhost`. The `vhost` middleware takes two arguments.
    The first is the domain. We get each `domain` from the `mappings.sites` keys.
    The second is an Express app. We retrieve each Express app from the values in
    `mappings.sites`.
  prefs: []
  type: TYPE_NORMAL
- en: We simply request the domain and the `vhost` middleware lines up the relevant
    domain with the relevant app to deliver the correct site.
  prefs: []
  type: TYPE_NORMAL
- en: Server Name Indication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to Server Name Indication (SNI), name-based virtual hosting for sites
    served over SSL/TLS was a complex administration issue (requiring every hostname
    to be stored in a multi-domain certificate).
  prefs: []
  type: TYPE_NORMAL
- en: This is because an encrypted connection is established based upon a certificate
    that specifies a domain name before any HTTP headers are received by the server.
    Therefore, the server cannot provide a certificate that is specific to one domain.
    As a result, the browser would vividly warn the user that the connection may be
    unsafe since the domain name listed on the certificate didn't match the domain
    being accessed. In order to avoid this scenario, a virtual host would have to
    buy a certificate containing every domain hosted, then reapply for a new certificate
    every time a new domain was added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: SNI forwards the requested domain to the server at the beginning of the SSL/TLS
    handshake, allowing our server to choose the appropriate certificate for a domain,
    and preventing the browser from telling our users that they may be under attack.
  prefs: []
  type: TYPE_NORMAL
- en: '`https.Server` (inheriting from `tls.Server)` has the `addContext` method,
    which allows us to specify hostname and certificate credentials for multiple individual
    domains.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's enable TLS-compatible virtual hosting by making a few changes. First,
    in `mappings.js`, we'll add another convenience function called `secureShare:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll alter the way we load the sites, calling `secureShare` instead of
    `staticServe:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: For this example to work in a production scenario, we'll have to replace the
    sample domains with the ones that we control and obtain genuine certificates signed
    by a trusted Certificate Authority.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can test locally by following the instructions in the supporting code files
    for this chapter (under `secure_virtual_hosting/howto)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our `sites` folder structure to conform to alterations made in
    `mappings.js` by renaming `nodecookbook` to `nodecookbook.com` and `localhost-site`
    to `davidmarkclements.com`, changing the latter''s `index.html` file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Each `site` folder also needs a `certs` folder containing our `cert.pem` and
    `key.pem` files. These files must be certificates purchased specifically for the
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `server.js`, we change the top of our script to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The filesystem (`fs`) module is required to load our credentials. As we''ve
    replaced `http` with `https`, we will alter our `createServer` call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Simply adding`'s'` to `http` does the trick. On this occasion, there's no SSL/TLS
    credentials since we'll be loading these on a per domain basis with the `addContext`
    method. Therefore, we just pass an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `mappings.js`, our `secureShare` function returns an object containing three
    properties, `content, key`, and `cert`, where `content` holds the static server.
    So in `server.js`, we update this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As we're hosting on a live server, we expose it to incoming web connections
    by binding to `0.0.0.0:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We could also change the `port` variable to `443` to serve directly over the
    HTTPS port (we must run the server as root to do this, which has security implications
    in a live environment, see[Chapter 10](ch10.html "Chapter 10. Taking It Live"),
    *Taking It Live*, for how to do this safely).
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we add the following to the bottom of `server.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This loads the `key` and `cert` properties for each domain based on the settings
    laid out in `mappings.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Provided we have trusted CA-certified credentials for each specified domain,
    and we're using a modern browser, we can navigate to each site using HTTPS without
    a receiving a warning.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Caveat**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a catch: Server Name Indication only works in modern browsers. Although
    modern browsers in this context exclude Internet Explorer 7/8 and Safari when
    run on Windows XP, as well as Android Gingerbread (versions 2.x) and Blackberry
    browsers. If we provided a default certificate via the options object of `https.createServer`,
    the user will still be able to view the site on older browsers, but they will
    receive the same warnings as if we weren''t using SNI (the older browsers don''t
    indicate the hostname in SSL/TLS negotiations so our SNI handling never occurs).
    Depending on the intended market, we may have to use alternative methods until
    these older browsers are used in sufficiently low numbers in relation to our purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Serving static files* discussed In [Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"),Making a Web Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dynamic routing* discussed In [Chapter 6](ch06.html "Chapter 6. Accelerating
    Development with Express"),Accelerating Development with Express'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting up an HTTPS web server* discussed In [Chapter 7](ch07.html "Chapter 7. Implementing
    Security, Encryption, and Authentication"),Implementing Security, Encryption,
    and Authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying to a server environment* discussed In [Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
